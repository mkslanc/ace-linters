(self["webpackChunkace_linters_root"] = self["webpackChunkace_linters_root"] || []).push([[3258],{

/***/ 53258:
/***/ (function(module) {

function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
(function webpackUniversalModuleDefinition(root, factory) {
    if (true) module.exports = factory();
    else { var i, a; }
})(this, ()=>{
    return /******/ (()=>{
        /******/ var __webpack_modules__ = {
            /***/ 6093: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_810__)=>{
                "use strict";
                /* provided dependency */ var process = __nested_webpack_require_810__(9907);
                /* provided dependency */ var console = __nested_webpack_require_810__(4364);
                // Currently in sync with Node.js lib/assert.js
                // https://github.com/nodejs/node/commit/2a51ae424a513ec9a6aa3466baa0cc1d55dd4f3b
                // Originally from narwhal.js (http://narwhaljs.org)
                // Copyright (c) 2009 Thomas Robinson <280north.com>
                //
                // Permission is hereby granted, free of charge, to any person obtaining a copy
                // of this software and associated documentation files (the 'Software'), to
                // deal in the Software without restriction, including without limitation the
                // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
                // sell copies of the Software, and to permit persons to whom the Software is
                // furnished to do so, subject to the following conditions:
                //
                // The above copyright notice and this permission notice shall be included in
                // all copies or substantial portions of the Software.
                //
                // THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                // AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
                // ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
                // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                function _typeof(obj) {
                    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                        _typeof = function _typeof(obj) {
                            return typeof obj;
                        };
                    } else {
                        _typeof = function _typeof(obj) {
                            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                        };
                    }
                    return _typeof(obj);
                }
                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                }
                var _require = __nested_webpack_require_810__(1342), _require$codes = _require.codes, ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE, ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
                var AssertionError = __nested_webpack_require_810__(9801);
                var _require2 = __nested_webpack_require_810__(6827), inspect = _require2.inspect;
                var _require$types = __nested_webpack_require_810__(6827).types, isPromise = _require$types.isPromise, isRegExp = _require$types.isRegExp;
                var objectAssign = Object.assign ? Object.assign : __nested_webpack_require_810__(3046).assign;
                var objectIs = Object.is ? Object.is : __nested_webpack_require_810__(5968);
                var errorCache = new Map();
                var isDeepEqual;
                var isDeepStrictEqual;
                var parseExpressionAt;
                var findNodeAround;
                var decoder;
                function lazyLoadComparison() {
                    var comparison = __nested_webpack_require_810__(5656);
                    isDeepEqual = comparison.isDeepEqual;
                    isDeepStrictEqual = comparison.isDeepStrictEqual;
                } // Escape control characters but not \n and \t to keep the line breaks and
                // indentation intact.
                // eslint-disable-next-line no-control-regex
                var escapeSequencesRegExp = /[\x00-\x08\x0b\x0c\x0e-\x1f]/g;
                var meta = /* unused pure expression or super */ null && 0;
                var escapeFn = function escapeFn(str) {
                    return meta[str.charCodeAt(0)];
                };
                var warned = false; // The assert module provides functions that throw
                // AssertionError's when particular conditions are not met. The
                // assert module must conform to the following interface.
                var assert = module1.exports = ok;
                var NO_EXCEPTION_SENTINEL = {}; // All of the following functions must throw an AssertionError
                // when a corresponding condition is not met, with a message that
                // may be undefined if not provided. All assertion methods provide
                // both the actual and expected values to the assertion error for
                // display purposes.
                function innerFail(obj) {
                    if (obj.message instanceof Error) throw obj.message;
                    throw new AssertionError(obj);
                }
                function fail(actual, expected, message, operator, stackStartFn) {
                    var argsLen = arguments.length;
                    var internalMessage;
                    if (argsLen === 0) {
                        internalMessage = 'Failed';
                    } else if (argsLen === 1) {
                        message = actual;
                        actual = undefined;
                    } else {
                        if (warned === false) {
                            warned = true;
                            var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);
                            warn('assert.fail() with more than one argument is deprecated. ' + 'Please use assert.strictEqual() instead or only pass a message.', 'DeprecationWarning', 'DEP0094');
                        }
                        if (argsLen === 2) operator = '!=';
                    }
                    if (message instanceof Error) throw message;
                    var errArgs = {
                        actual: actual,
                        expected: expected,
                        operator: operator === undefined ? 'fail' : operator,
                        stackStartFn: stackStartFn || fail
                    };
                    if (message !== undefined) {
                        errArgs.message = message;
                    }
                    var err = new AssertionError(errArgs);
                    if (internalMessage) {
                        err.message = internalMessage;
                        err.generatedMessage = true;
                    }
                    throw err;
                }
                assert.fail = fail; // The AssertionError is defined in internal/error.
                assert.AssertionError = AssertionError;
                function innerOk(fn, argLen, value, message) {
                    if (!value) {
                        var generatedMessage = false;
                        if (argLen === 0) {
                            generatedMessage = true;
                            message = 'No value argument passed to `assert.ok()`';
                        } else if (message instanceof Error) {
                            throw message;
                        }
                        var err = new AssertionError({
                            actual: value,
                            expected: true,
                            message: message,
                            operator: '==',
                            stackStartFn: fn
                        });
                        err.generatedMessage = generatedMessage;
                        throw err;
                    }
                } // Pure assertion tests whether a value is truthy, as determined
                // by !!value.
                function ok() {
                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                        args[_key] = arguments[_key];
                    }
                    innerOk.apply(void 0, [
                        ok,
                        args.length
                    ].concat(args));
                }
                assert.ok = ok; // The equality assertion tests shallow, coercive equality with ==.
                /* eslint-disable no-restricted-properties */ assert.equal = function equal(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    } // eslint-disable-next-line eqeqeq
                    if (actual != expected) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: '==',
                            stackStartFn: equal
                        });
                    }
                }; // The non-equality assertion tests for whether two objects are not
                // equal with !=.
                assert.notEqual = function notEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    } // eslint-disable-next-line eqeqeq
                    if (actual == expected) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: '!=',
                            stackStartFn: notEqual
                        });
                    }
                }; // The equivalence assertion tests a deep equality relation.
                assert.deepEqual = function deepEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (isDeepEqual === undefined) lazyLoadComparison();
                    if (!isDeepEqual(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'deepEqual',
                            stackStartFn: deepEqual
                        });
                    }
                }; // The non-equivalence assertion tests for any deep inequality.
                assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (isDeepEqual === undefined) lazyLoadComparison();
                    if (isDeepEqual(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'notDeepEqual',
                            stackStartFn: notDeepEqual
                        });
                    }
                };
                /* eslint-enable */ assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (isDeepEqual === undefined) lazyLoadComparison();
                    if (!isDeepStrictEqual(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'deepStrictEqual',
                            stackStartFn: deepStrictEqual
                        });
                    }
                };
                assert.notDeepStrictEqual = notDeepStrictEqual;
                function notDeepStrictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (isDeepEqual === undefined) lazyLoadComparison();
                    if (isDeepStrictEqual(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'notDeepStrictEqual',
                            stackStartFn: notDeepStrictEqual
                        });
                    }
                }
                assert.strictEqual = function strictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (!objectIs(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'strictEqual',
                            stackStartFn: strictEqual
                        });
                    }
                };
                assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
                    if (arguments.length < 2) {
                        throw new ERR_MISSING_ARGS('actual', 'expected');
                    }
                    if (objectIs(actual, expected)) {
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: 'notStrictEqual',
                            stackStartFn: notStrictEqual
                        });
                    }
                };
                var Comparison = function Comparison(obj, keys, actual) {
                    var _this = this;
                    _classCallCheck(this, Comparison);
                    keys.forEach(function(key) {
                        if (key in obj) {
                            if (actual !== undefined && typeof actual[key] === 'string' && isRegExp(obj[key]) && obj[key].test(actual[key])) {
                                _this[key] = actual[key];
                            } else {
                                _this[key] = obj[key];
                            }
                        }
                    });
                };
                function compareExceptionKey(actual, expected, key, message, keys, fn) {
                    if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
                        if (!message) {
                            // Create placeholder objects to create a nice output.
                            var a = new Comparison(actual, keys);
                            var b = new Comparison(expected, keys, actual);
                            var err = new AssertionError({
                                actual: a,
                                expected: b,
                                operator: 'deepStrictEqual',
                                stackStartFn: fn
                            });
                            err.actual = actual;
                            err.expected = expected;
                            err.operator = fn.name;
                            throw err;
                        }
                        innerFail({
                            actual: actual,
                            expected: expected,
                            message: message,
                            operator: fn.name,
                            stackStartFn: fn
                        });
                    }
                }
                function expectedException(actual, expected, msg, fn) {
                    if (typeof expected !== 'function') {
                        if (isRegExp(expected)) return expected.test(actual); // assert.doesNotThrow does not accept objects.
                        if (arguments.length === 2) {
                            throw new ERR_INVALID_ARG_TYPE('expected', [
                                'Function',
                                'RegExp'
                            ], expected);
                        } // Handle primitives properly.
                        if (_typeof(actual) !== 'object' || actual === null) {
                            var err = new AssertionError({
                                actual: actual,
                                expected: expected,
                                message: msg,
                                operator: 'deepStrictEqual',
                                stackStartFn: fn
                            });
                            err.operator = fn.name;
                            throw err;
                        }
                        var keys = Object.keys(expected); // Special handle errors to make sure the name and the message are compared
                        // as well.
                        if (expected instanceof Error) {
                            keys.push('name', 'message');
                        } else if (keys.length === 0) {
                            throw new ERR_INVALID_ARG_VALUE('error', expected, 'may not be an empty object');
                        }
                        if (isDeepEqual === undefined) lazyLoadComparison();
                        keys.forEach(function(key) {
                            if (typeof actual[key] === 'string' && isRegExp(expected[key]) && expected[key].test(actual[key])) {
                                return;
                            }
                            compareExceptionKey(actual, expected, key, msg, keys, fn);
                        });
                        return true;
                    } // Guard instanceof against arrow functions as they don't have a prototype.
                    if (expected.prototype !== undefined && actual instanceof expected) {
                        return true;
                    }
                    if (Error.isPrototypeOf(expected)) {
                        return false;
                    }
                    return expected.call({}, actual) === true;
                }
                function getActual(fn) {
                    if (typeof fn !== 'function') {
                        throw new ERR_INVALID_ARG_TYPE('fn', 'Function', fn);
                    }
                    try {
                        fn();
                    } catch (e) {
                        return e;
                    }
                    return NO_EXCEPTION_SENTINEL;
                }
                function checkIsPromise(obj) {
                    // Accept native ES6 promises and promises that are implemented in a similar
                    // way. Do not accept thenables that use a function as `obj` and that have no
                    // `catch` handler.
                    // TODO: thenables are checked up until they have the correct methods,
                    // but according to documentation, the `then` method should receive
                    // the `fulfill` and `reject` arguments as well or it may be never resolved.
                    return isPromise(obj) || obj !== null && _typeof(obj) === 'object' && typeof obj.then === 'function' && typeof obj.catch === 'function';
                }
                function waitForActual(promiseFn) {
                    return Promise.resolve().then(function() {
                        var resultPromise;
                        if (typeof promiseFn === 'function') {
                            // Return a rejected promise if `promiseFn` throws synchronously.
                            resultPromise = promiseFn(); // Fail in case no promise is returned.
                            if (!checkIsPromise(resultPromise)) {
                                throw new ERR_INVALID_RETURN_VALUE('instance of Promise', 'promiseFn', resultPromise);
                            }
                        } else if (checkIsPromise(promiseFn)) {
                            resultPromise = promiseFn;
                        } else {
                            throw new ERR_INVALID_ARG_TYPE('promiseFn', [
                                'Function',
                                'Promise'
                            ], promiseFn);
                        }
                        return Promise.resolve().then(function() {
                            return resultPromise;
                        }).then(function() {
                            return NO_EXCEPTION_SENTINEL;
                        }).catch(function(e) {
                            return e;
                        });
                    });
                }
                function expectsError(stackStartFn, actual, error, message) {
                    if (typeof error === 'string') {
                        if (arguments.length === 4) {
                            throw new ERR_INVALID_ARG_TYPE('error', [
                                'Object',
                                'Error',
                                'Function',
                                'RegExp'
                            ], error);
                        }
                        if (_typeof(actual) === 'object' && actual !== null) {
                            if (actual.message === error) {
                                throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error message \"".concat(actual.message, "\" is identical to the message."));
                            }
                        } else if (actual === error) {
                            throw new ERR_AMBIGUOUS_ARGUMENT('error/message', "The error \"".concat(actual, "\" is identical to the message."));
                        }
                        message = error;
                        error = undefined;
                    } else if (error != null && _typeof(error) !== 'object' && typeof error !== 'function') {
                        throw new ERR_INVALID_ARG_TYPE('error', [
                            'Object',
                            'Error',
                            'Function',
                            'RegExp'
                        ], error);
                    }
                    if (actual === NO_EXCEPTION_SENTINEL) {
                        var details = '';
                        if (error && error.name) {
                            details += " (".concat(error.name, ")");
                        }
                        details += message ? ": ".concat(message) : '.';
                        var fnType = stackStartFn.name === 'rejects' ? 'rejection' : 'exception';
                        innerFail({
                            actual: undefined,
                            expected: error,
                            operator: stackStartFn.name,
                            message: "Missing expected ".concat(fnType).concat(details),
                            stackStartFn: stackStartFn
                        });
                    }
                    if (error && !expectedException(actual, error, message, stackStartFn)) {
                        throw actual;
                    }
                }
                function expectsNoError(stackStartFn, actual, error, message) {
                    if (actual === NO_EXCEPTION_SENTINEL) return;
                    if (typeof error === 'string') {
                        message = error;
                        error = undefined;
                    }
                    if (!error || expectedException(actual, error)) {
                        var details = message ? ": ".concat(message) : '.';
                        var fnType = stackStartFn.name === 'doesNotReject' ? 'rejection' : 'exception';
                        innerFail({
                            actual: actual,
                            expected: error,
                            operator: stackStartFn.name,
                            message: "Got unwanted ".concat(fnType).concat(details, "\n") + "Actual message: \"".concat(actual && actual.message, "\""),
                            stackStartFn: stackStartFn
                        });
                    }
                    throw actual;
                }
                assert.throws = function throws(promiseFn) {
                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){
                        args[_key2 - 1] = arguments[_key2];
                    }
                    expectsError.apply(void 0, [
                        throws,
                        getActual(promiseFn)
                    ].concat(args));
                };
                assert.rejects = function rejects(promiseFn) {
                    for(var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++){
                        args[_key3 - 1] = arguments[_key3];
                    }
                    return waitForActual(promiseFn).then(function(result) {
                        return expectsError.apply(void 0, [
                            rejects,
                            result
                        ].concat(args));
                    });
                };
                assert.doesNotThrow = function doesNotThrow(fn) {
                    for(var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++){
                        args[_key4 - 1] = arguments[_key4];
                    }
                    expectsNoError.apply(void 0, [
                        doesNotThrow,
                        getActual(fn)
                    ].concat(args));
                };
                assert.doesNotReject = function doesNotReject(fn) {
                    for(var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++){
                        args[_key5 - 1] = arguments[_key5];
                    }
                    return waitForActual(fn).then(function(result) {
                        return expectsNoError.apply(void 0, [
                            doesNotReject,
                            result
                        ].concat(args));
                    });
                };
                assert.ifError = function ifError(err) {
                    if (err !== null && err !== undefined) {
                        var message = 'ifError got unwanted exception: ';
                        if (_typeof(err) === 'object' && typeof err.message === 'string') {
                            if (err.message.length === 0 && err.constructor) {
                                message += err.constructor.name;
                            } else {
                                message += err.message;
                            }
                        } else {
                            message += inspect(err);
                        }
                        var newErr = new AssertionError({
                            actual: err,
                            expected: null,
                            operator: 'ifError',
                            message: message,
                            stackStartFn: ifError
                        }); // Make sure we actually have a stack trace!
                        var origStack = err.stack;
                        if (typeof origStack === 'string') {
                            // This will remove any duplicated frames from the error frames taken
                            // from within `ifError` and add the original error frames to the newly
                            // created ones.
                            var tmp2 = origStack.split('\n');
                            tmp2.shift(); // Filter all frames existing in err.stack.
                            var tmp1 = newErr.stack.split('\n');
                            for(var i = 0; i < tmp2.length; i++){
                                // Find the first occurrence of the frame.
                                var pos = tmp1.indexOf(tmp2[i]);
                                if (pos !== -1) {
                                    // Only keep new frames.
                                    tmp1 = tmp1.slice(0, pos);
                                    break;
                                }
                            }
                            newErr.stack = "".concat(tmp1.join('\n'), "\n").concat(tmp2.join('\n'));
                        }
                        throw newErr;
                    }
                }; // Expose a strict only variant of assert
                function strict() {
                    for(var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++){
                        args[_key6] = arguments[_key6];
                    }
                    innerOk.apply(void 0, [
                        strict,
                        args.length
                    ].concat(args));
                }
                assert.strict = objectAssign(strict, assert, {
                    equal: assert.strictEqual,
                    deepEqual: assert.deepStrictEqual,
                    notEqual: assert.notStrictEqual,
                    notDeepEqual: assert.notDeepStrictEqual
                });
                assert.strict.strict = assert.strict;
            /***/ },
            /***/ 9801: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_32028__)=>{
                "use strict";
                /* provided dependency */ var process = __nested_webpack_require_32028__(9907);
                // Currently in sync with Node.js lib/internal/assert/assertion_error.js
                // https://github.com/nodejs/node/commit/0817840f775032169ddd70c85ac059f18ffcc81c
                function _objectSpread(target) {
                    for(var i = 1; i < arguments.length; i++){
                        var source = arguments[i] != null ? arguments[i] : {};
                        var ownKeys = Object.keys(source);
                        if (typeof Object.getOwnPropertySymbols === 'function') {
                            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                            }));
                        }
                        ownKeys.forEach(function(key) {
                            _defineProperty(target, key, source[key]);
                        });
                    }
                    return target;
                }
                function _defineProperty(obj, key, value) {
                    if (key in obj) {
                        Object.defineProperty(obj, key, {
                            value: value,
                            enumerable: true,
                            configurable: true,
                            writable: true
                        });
                    } else {
                        obj[key] = value;
                    }
                    return obj;
                }
                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                }
                function _defineProperties(target, props) {
                    for(var i = 0; i < props.length; i++){
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) _defineProperties(Constructor, staticProps);
                    return Constructor;
                }
                function _possibleConstructorReturn(self, call) {
                    if (call && (_typeof(call) === "object" || typeof call === "function")) {
                        return call;
                    }
                    return _assertThisInitialized(self);
                }
                function _assertThisInitialized(self) {
                    if (self === void 0) {
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    }
                    return self;
                }
                function _inherits(subClass, superClass) {
                    if (typeof superClass !== "function" && superClass !== null) {
                        throw new TypeError("Super expression must either be null or a function");
                    }
                    subClass.prototype = Object.create(superClass && superClass.prototype, {
                        constructor: {
                            value: subClass,
                            writable: true,
                            configurable: true
                        }
                    });
                    if (superClass) _setPrototypeOf(subClass, superClass);
                }
                function _wrapNativeSuper(Class) {
                    var _cache = typeof Map === "function" ? new Map() : undefined;
                    _wrapNativeSuper = function _wrapNativeSuper(Class) {
                        if (Class === null || !_isNativeFunction(Class)) return Class;
                        if (typeof Class !== "function") {
                            throw new TypeError("Super expression must either be null or a function");
                        }
                        if (typeof _cache !== "undefined") {
                            if (_cache.has(Class)) return _cache.get(Class);
                            _cache.set(Class, Wrapper);
                        }
                        function Wrapper() {
                            return _construct(Class, arguments, _getPrototypeOf(this).constructor);
                        }
                        Wrapper.prototype = Object.create(Class.prototype, {
                            constructor: {
                                value: Wrapper,
                                enumerable: false,
                                writable: true,
                                configurable: true
                            }
                        });
                        return _setPrototypeOf(Wrapper, Class);
                    };
                    return _wrapNativeSuper(Class);
                }
                function isNativeReflectConstruct() {
                    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
                    if (Reflect.construct.sham) return false;
                    if (typeof Proxy === "function") return true;
                    try {
                        Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));
                        return true;
                    } catch (e) {
                        return false;
                    }
                }
                function _construct(Parent, args, Class) {
                    if (isNativeReflectConstruct()) {
                        _construct = Reflect.construct;
                    } else {
                        _construct = function _construct(Parent, args, Class) {
                            var a = [
                                null
                            ];
                            a.push.apply(a, args);
                            var Constructor = Function.bind.apply(Parent, a);
                            var instance = new Constructor();
                            if (Class) _setPrototypeOf(instance, Class.prototype);
                            return instance;
                        };
                    }
                    return _construct.apply(null, arguments);
                }
                function _isNativeFunction(fn) {
                    return Function.toString.call(fn).indexOf("[native code]") !== -1;
                }
                function _setPrototypeOf(o, p) {
                    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                        o.__proto__ = p;
                        return o;
                    };
                    return _setPrototypeOf(o, p);
                }
                function _getPrototypeOf(o) {
                    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                        return o.__proto__ || Object.getPrototypeOf(o);
                    };
                    return _getPrototypeOf(o);
                }
                function _typeof(obj) {
                    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                        _typeof = function _typeof(obj) {
                            return typeof obj;
                        };
                    } else {
                        _typeof = function _typeof(obj) {
                            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                        };
                    }
                    return _typeof(obj);
                }
                var _require = __nested_webpack_require_32028__(6827), inspect = _require.inspect;
                var _require2 = __nested_webpack_require_32028__(1342), ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE; // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
                function endsWith(str, search, this_len) {
                    if (this_len === undefined || this_len > str.length) {
                        this_len = str.length;
                    }
                    return str.substring(this_len - search.length, this_len) === search;
                } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat
                function repeat(str, count) {
                    count = Math.floor(count);
                    if (str.length == 0 || count == 0) return '';
                    var maxCount = str.length * count;
                    count = Math.floor(Math.log(count) / Math.log(2));
                    while(count){
                        str += str;
                        count--;
                    }
                    str += str.substring(0, maxCount - str.length);
                    return str;
                }
                var blue = '';
                var green = '';
                var red = '';
                var white = '';
                var kReadableOperator = {
                    deepStrictEqual: 'Expected values to be strictly deep-equal:',
                    strictEqual: 'Expected values to be strictly equal:',
                    strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
                    deepEqual: 'Expected values to be loosely deep-equal:',
                    equal: 'Expected values to be loosely equal:',
                    notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
                    notStrictEqual: 'Expected "actual" to be strictly unequal to:',
                    notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
                    notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
                    notEqual: 'Expected "actual" to be loosely unequal to:',
                    notIdentical: 'Values identical but not reference-equal:'
                }; // Comparing short primitives should just show === / !== instead of using the
                // diff.
                var kMaxShortLength = 10;
                function copyError(source) {
                    var keys = Object.keys(source);
                    var target = Object.create(Object.getPrototypeOf(source));
                    keys.forEach(function(key) {
                        target[key] = source[key];
                    });
                    Object.defineProperty(target, 'message', {
                        value: source.message
                    });
                    return target;
                }
                function inspectValue(val) {
                    // The util.inspect default values could be changed. This makes sure the
                    // error messages contain the necessary information nevertheless.
                    return inspect(val, {
                        compact: false,
                        customInspect: false,
                        depth: 1000,
                        maxArrayLength: Infinity,
                        // Assert compares only enumerable properties (with a few exceptions).
                        showHidden: false,
                        // Having a long line as error is better than wrapping the line for
                        // comparison for now.
                        // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
                        // have meta information about the inspected properties (i.e., know where
                        // in what line the property starts and ends).
                        breakLength: Infinity,
                        // Assert does not detect proxies currently.
                        showProxy: false,
                        sorted: true,
                        // Inspect getters as we also check them when comparing entries.
                        getters: true
                    });
                }
                function createErrDiff(actual, expected, operator) {
                    var other = '';
                    var res = '';
                    var lastPos = 0;
                    var end = '';
                    var skipped = false;
                    var actualInspected = inspectValue(actual);
                    var actualLines = actualInspected.split('\n');
                    var expectedLines = inspectValue(expected).split('\n');
                    var i = 0;
                    var indicator = ''; // In case both values are objects explicitly mark them as not reference equal
                    // for the `strictEqual` operator.
                    if (operator === 'strictEqual' && _typeof(actual) === 'object' && _typeof(expected) === 'object' && actual !== null && expected !== null) {
                        operator = 'strictEqualObject';
                    } // If "actual" and "expected" fit on a single line and they are not strictly
                    // equal, check further special handling.
                    if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
                        var inputLength = actualLines[0].length + expectedLines[0].length; // If the character length of "actual" and "expected" together is less than
                        // kMaxShortLength and if neither is an object and at least one of them is
                        // not `zero`, use the strict equal comparison to visualize the output.
                        if (inputLength <= kMaxShortLength) {
                            if ((_typeof(actual) !== 'object' || actual === null) && (_typeof(expected) !== 'object' || expected === null) && (actual !== 0 || expected !== 0)) {
                                // -0 === +0
                                return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
                            }
                        } else if (operator !== 'strictEqualObject') {
                            // If the stderr is a tty and the input length is lower than the current
                            // columns per line, add a mismatch indicator below the output. If it is
                            // not a tty, use a default value of 80 characters.
                            var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;
                            if (inputLength < maxLength) {
                                while(actualLines[0][i] === expectedLines[0][i]){
                                    i++;
                                } // Ignore the first characters.
                                if (i > 2) {
                                    // Add position indicator for the first mismatch in case it is a
                                    // single line and the input length is less than the column length.
                                    indicator = "\n  ".concat(repeat(' ', i), "^");
                                    i = 0;
                                }
                            }
                        }
                    } // Remove all ending lines that match (this optimizes the output for
                    // readability by reducing the number of total changed lines).
                    var a = actualLines[actualLines.length - 1];
                    var b = expectedLines[expectedLines.length - 1];
                    while(a === b){
                        if (i++ < 2) {
                            end = "\n  ".concat(a).concat(end);
                        } else {
                            other = a;
                        }
                        actualLines.pop();
                        expectedLines.pop();
                        if (actualLines.length === 0 || expectedLines.length === 0) break;
                        a = actualLines[actualLines.length - 1];
                        b = expectedLines[expectedLines.length - 1];
                    }
                    var maxLines = Math.max(actualLines.length, expectedLines.length); // Strict equal with identical objects that are not identical by reference.
                    // E.g., assert.deepStrictEqual({ a: Symbol() }, { a: Symbol() })
                    if (maxLines === 0) {
                        // We have to get the result again. The lines were all removed before.
                        var _actualLines = actualInspected.split('\n'); // Only remove lines in case it makes sense to collapse those.
                        // TODO: Accept env to always show the full error.
                        if (_actualLines.length > 30) {
                            _actualLines[26] = "".concat(blue, "...").concat(white);
                            while(_actualLines.length > 27){
                                _actualLines.pop();
                            }
                        }
                        return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join('\n'), "\n");
                    }
                    if (i > 3) {
                        end = "\n".concat(blue, "...").concat(white).concat(end);
                        skipped = true;
                    }
                    if (other !== '') {
                        end = "\n  ".concat(other).concat(end);
                        other = '';
                    }
                    var printedLines = 0;
                    var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
                    var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");
                    for(i = 0; i < maxLines; i++){
                        // Only extra expected lines exist
                        var cur = i - lastPos;
                        if (actualLines.length < i + 1) {
                            // If the last diverging line is more than one line above and the
                            // current line is at least line three, add some of the former lines and
                            // also add dots to indicate skipped entries.
                            if (cur > 1 && i > 2) {
                                if (cur > 4) {
                                    res += "\n".concat(blue, "...").concat(white);
                                    skipped = true;
                                } else if (cur > 3) {
                                    res += "\n  ".concat(expectedLines[i - 2]);
                                    printedLines++;
                                }
                                res += "\n  ".concat(expectedLines[i - 1]);
                                printedLines++;
                            } // Mark the current line as the last diverging one.
                            lastPos = i; // Add the expected line to the cache.
                            other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
                            printedLines++; // Only extra actual lines exist
                        } else if (expectedLines.length < i + 1) {
                            // If the last diverging line is more than one line above and the
                            // current line is at least line three, add some of the former lines and
                            // also add dots to indicate skipped entries.
                            if (cur > 1 && i > 2) {
                                if (cur > 4) {
                                    res += "\n".concat(blue, "...").concat(white);
                                    skipped = true;
                                } else if (cur > 3) {
                                    res += "\n  ".concat(actualLines[i - 2]);
                                    printedLines++;
                                }
                                res += "\n  ".concat(actualLines[i - 1]);
                                printedLines++;
                            } // Mark the current line as the last diverging one.
                            lastPos = i; // Add the actual line to the result.
                            res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
                            printedLines++; // Lines diverge
                        } else {
                            var expectedLine = expectedLines[i];
                            var actualLine = actualLines[i]; // If the lines diverge, specifically check for lines that only diverge by
                            // a trailing comma. In that case it is actually identical and we should
                            // mark it as such.
                            var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ',') || actualLine.slice(0, -1) !== expectedLine); // If the expected line has a trailing comma but is otherwise identical,
                            // add a comma at the end of the actual line. Otherwise the output could
                            // look weird as in:
                            //
                            //   [
                            //     1         // No comma at the end!
                            // +   2
                            //   ]
                            //
                            if (divergingLines && endsWith(expectedLine, ',') && expectedLine.slice(0, -1) === actualLine) {
                                divergingLines = false;
                                actualLine += ',';
                            }
                            if (divergingLines) {
                                // If the last diverging line is more than one line above and the
                                // current line is at least line three, add some of the former lines and
                                // also add dots to indicate skipped entries.
                                if (cur > 1 && i > 2) {
                                    if (cur > 4) {
                                        res += "\n".concat(blue, "...").concat(white);
                                        skipped = true;
                                    } else if (cur > 3) {
                                        res += "\n  ".concat(actualLines[i - 2]);
                                        printedLines++;
                                    }
                                    res += "\n  ".concat(actualLines[i - 1]);
                                    printedLines++;
                                } // Mark the current line as the last diverging one.
                                lastPos = i; // Add the actual line to the result and cache the expected diverging
                                // line so consecutive diverging lines show up as +++--- and not +-+-+-.
                                res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
                                other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
                                printedLines += 2; // Lines are identical
                            } else {
                                // Add all cached information to the result before adding other things
                                // and reset the cache.
                                res += other;
                                other = ''; // If the last diverging line is exactly one line above or if it is the
                                // very first line, add the line to the result.
                                if (cur === 1 || i === 0) {
                                    res += "\n  ".concat(actualLine);
                                    printedLines++;
                                }
                            }
                        } // Inspected object to big (Show ~20 rows max)
                        if (printedLines > 20 && i < maxLines - 2) {
                            return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
                        }
                    }
                    return "".concat(msg).concat(skipped ? skippedMsg : '', "\n").concat(res).concat(other).concat(end).concat(indicator);
                }
                var AssertionError = /*#__PURE__*/ function(_Error) {
                    _inherits(AssertionError, _Error);
                    function AssertionError(options) {
                        var _this;
                        _classCallCheck(this, AssertionError);
                        if (_typeof(options) !== 'object' || options === null) {
                            throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);
                        }
                        var message = options.message, operator = options.operator, stackStartFn = options.stackStartFn;
                        var actual = options.actual, expected = options.expected;
                        var limit = Error.stackTraceLimit;
                        Error.stackTraceLimit = 0;
                        if (message != null) {
                            _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, String(message)));
                        } else {
                            if (process.stderr && process.stderr.isTTY) {
                                // Reset on each call to make sure we handle dynamically set environment
                                // variables correct.
                                if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {
                                    blue = "\x1B[34m";
                                    green = "\x1B[32m";
                                    white = "\x1B[39m";
                                    red = "\x1B[31m";
                                } else {
                                    blue = '';
                                    green = '';
                                    white = '';
                                    red = '';
                                }
                            } // Prevent the error stack from being visible by duplicating the error
                            // in a very close way to the original in case both sides are actually
                            // instances of Error.
                            if (_typeof(actual) === 'object' && actual !== null && _typeof(expected) === 'object' && expected !== null && 'stack' in actual && actual instanceof Error && 'stack' in expected && expected instanceof Error) {
                                actual = copyError(actual);
                                expected = copyError(expected);
                            }
                            if (operator === 'deepStrictEqual' || operator === 'strictEqual') {
                                _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, createErrDiff(actual, expected, operator)));
                            } else if (operator === 'notDeepStrictEqual' || operator === 'notStrictEqual') {
                                // In case the objects are equal but the operator requires unequal, show
                                // the first object and say A equals B
                                var base = kReadableOperator[operator];
                                var res = inspectValue(actual).split('\n'); // In case "actual" is an object, it should not be reference equal.
                                if (operator === 'notStrictEqual' && _typeof(actual) === 'object' && actual !== null) {
                                    base = kReadableOperator.notStrictEqualObject;
                                } // Only remove lines in case it makes sense to collapse those.
                                // TODO: Accept env to always show the full error.
                                if (res.length > 30) {
                                    res[26] = "".concat(blue, "...").concat(white);
                                    while(res.length > 27){
                                        res.pop();
                                    }
                                } // Only print a single input.
                                if (res.length === 1) {
                                    _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(base, " ").concat(res[0])));
                                } else {
                                    _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(base, "\n\n").concat(res.join('\n'), "\n")));
                                }
                            } else {
                                var _res = inspectValue(actual);
                                var other = '';
                                var knownOperators = kReadableOperator[operator];
                                if (operator === 'notDeepEqual' || operator === 'notEqual') {
                                    _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);
                                    if (_res.length > 1024) {
                                        _res = "".concat(_res.slice(0, 1021), "...");
                                    }
                                } else {
                                    other = "".concat(inspectValue(expected));
                                    if (_res.length > 512) {
                                        _res = "".concat(_res.slice(0, 509), "...");
                                    }
                                    if (other.length > 512) {
                                        other = "".concat(other.slice(0, 509), "...");
                                    }
                                    if (operator === 'deepEqual' || operator === 'equal') {
                                        _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
                                    } else {
                                        other = " ".concat(operator, " ").concat(other);
                                    }
                                }
                                _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).call(this, "".concat(_res).concat(other)));
                            }
                        }
                        Error.stackTraceLimit = limit;
                        _this.generatedMessage = !message;
                        Object.defineProperty(_assertThisInitialized(_this), 'name', {
                            value: 'AssertionError [ERR_ASSERTION]',
                            enumerable: false,
                            writable: true,
                            configurable: true
                        });
                        _this.code = 'ERR_ASSERTION';
                        _this.actual = actual;
                        _this.expected = expected;
                        _this.operator = operator;
                        if (Error.captureStackTrace) {
                            // eslint-disable-next-line no-restricted-syntax
                            Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
                        } // Create error message including the error code in the name.
                        _this.stack; // Reset the name.
                        _this.name = 'AssertionError';
                        return _possibleConstructorReturn(_this);
                    }
                    _createClass(AssertionError, [
                        {
                            key: "toString",
                            value: function toString() {
                                return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
                            }
                        },
                        {
                            key: inspect.custom,
                            value: function value(recurseTimes, ctx) {
                                // This limits the `actual` and `expected` property default inspection to
                                // the minimum depth. Otherwise those values would be too verbose compared
                                // to the actual error message which contains a combined view of these two
                                // input values.
                                return inspect(this, _objectSpread({}, ctx, {
                                    customInspect: false,
                                    depth: 0
                                }));
                            }
                        }
                    ]);
                    return AssertionError;
                }(_wrapNativeSuper(Error));
                module1.exports = AssertionError;
            /***/ },
            /***/ 1342: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_65617__)=>{
                "use strict";
                // Currently in sync with Node.js lib/internal/errors.js
                // https://github.com/nodejs/node/commit/3b044962c48fe313905877a96b5d0894a5404f6f
                /* eslint node-core/documented-errors: "error" */ /* eslint node-core/alphabetize-errors: "error" */ /* eslint node-core/prefer-util-format-errors: "error" */ // The whole point behind this internal module is to allow Node.js to no
                // longer be forced to treat every error message change as a semver-major
                // change. The NodeError classes here all expose a `code` property whose
                // value statically and permanently identifies the error. While the error
                // message may change, the code should not.
                function _typeof(obj) {
                    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                        _typeof = function _typeof(obj) {
                            return typeof obj;
                        };
                    } else {
                        _typeof = function _typeof(obj) {
                            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                        };
                    }
                    return _typeof(obj);
                }
                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                }
                function _possibleConstructorReturn(self, call) {
                    if (call && (_typeof(call) === "object" || typeof call === "function")) {
                        return call;
                    }
                    return _assertThisInitialized(self);
                }
                function _assertThisInitialized(self) {
                    if (self === void 0) {
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    }
                    return self;
                }
                function _getPrototypeOf(o) {
                    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                        return o.__proto__ || Object.getPrototypeOf(o);
                    };
                    return _getPrototypeOf(o);
                }
                function _inherits(subClass, superClass) {
                    if (typeof superClass !== "function" && superClass !== null) {
                        throw new TypeError("Super expression must either be null or a function");
                    }
                    subClass.prototype = Object.create(superClass && superClass.prototype, {
                        constructor: {
                            value: subClass,
                            writable: true,
                            configurable: true
                        }
                    });
                    if (superClass) _setPrototypeOf(subClass, superClass);
                }
                function _setPrototypeOf(o, p) {
                    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                        o.__proto__ = p;
                        return o;
                    };
                    return _setPrototypeOf(o, p);
                }
                var codes = {}; // Lazy loaded
                var assert;
                var util;
                function createErrorType(code, message, Base) {
                    if (!Base) {
                        Base = Error;
                    }
                    function getMessage(arg1, arg2, arg3) {
                        if (typeof message === 'string') {
                            return message;
                        } else {
                            return message(arg1, arg2, arg3);
                        }
                    }
                    var NodeError = /*#__PURE__*/ function(_Base) {
                        _inherits(NodeError, _Base);
                        function NodeError(arg1, arg2, arg3) {
                            var _this;
                            _classCallCheck(this, NodeError);
                            _this = _possibleConstructorReturn(this, _getPrototypeOf(NodeError).call(this, getMessage(arg1, arg2, arg3)));
                            _this.code = code;
                            return _this;
                        }
                        return NodeError;
                    }(Base);
                    codes[code] = NodeError;
                } // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
                function oneOf(expected, thing) {
                    if (Array.isArray(expected)) {
                        var len = expected.length;
                        expected = expected.map(function(i) {
                            return String(i);
                        });
                        if (len > 2) {
                            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
                        } else if (len === 2) {
                            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
                        } else {
                            return "of ".concat(thing, " ").concat(expected[0]);
                        }
                    } else {
                        return "of ".concat(thing, " ").concat(String(expected));
                    }
                } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
                function startsWith(str, search, pos) {
                    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
                } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
                function endsWith(str, search, this_len) {
                    if (this_len === undefined || this_len > str.length) {
                        this_len = str.length;
                    }
                    return str.substring(this_len - search.length, this_len) === search;
                } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
                function includes(str, search, start) {
                    if (typeof start !== 'number') {
                        start = 0;
                    }
                    if (start + search.length > str.length) {
                        return false;
                    } else {
                        return str.indexOf(search, start) !== -1;
                    }
                }
                createErrorType('ERR_AMBIGUOUS_ARGUMENT', 'The "%s" argument is ambiguous. %s', TypeError);
                createErrorType('ERR_INVALID_ARG_TYPE', function(name, expected, actual) {
                    if (assert === undefined) assert = __nested_webpack_require_65617__(6093);
                    assert(typeof name === 'string', "'name' must be a string"); // determiner: 'must be' or 'must not be'
                    var determiner;
                    if (typeof expected === 'string' && startsWith(expected, 'not ')) {
                        determiner = 'must not be';
                        expected = expected.replace(/^not /, '');
                    } else {
                        determiner = 'must be';
                    }
                    var msg;
                    if (endsWith(name, ' argument')) {
                        // For cases like 'first argument'
                        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
                    } else {
                        var type = includes(name, '.') ? 'property' : 'argument';
                        msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
                    } // TODO(BridgeAR): Improve the output by showing `null` and similar.
                    msg += ". Received type ".concat(_typeof(actual));
                    return msg;
                }, TypeError);
                createErrorType('ERR_INVALID_ARG_VALUE', function(name, value) {
                    var reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'is invalid';
                    if (util === undefined) util = __nested_webpack_require_65617__(6827);
                    var inspected = util.inspect(value);
                    if (inspected.length > 128) {
                        inspected = "".concat(inspected.slice(0, 128), "...");
                    }
                    return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
                }, TypeError, RangeError);
                createErrorType('ERR_INVALID_RETURN_VALUE', function(input, name, value) {
                    var type;
                    if (value && value.constructor && value.constructor.name) {
                        type = "instance of ".concat(value.constructor.name);
                    } else {
                        type = "type ".concat(_typeof(value));
                    }
                    return "Expected ".concat(input, " to be returned from the \"").concat(name, "\"") + " function but got ".concat(type, ".");
                }, TypeError);
                createErrorType('ERR_MISSING_ARGS', function() {
                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                        args[_key] = arguments[_key];
                    }
                    if (assert === undefined) assert = __nested_webpack_require_65617__(6093);
                    assert(args.length > 0, 'At least one arg needs to be specified');
                    var msg = 'The ';
                    var len = args.length;
                    args = args.map(function(a) {
                        return "\"".concat(a, "\"");
                    });
                    switch(len){
                        case 1:
                            msg += "".concat(args[0], " argument");
                            break;
                        case 2:
                            msg += "".concat(args[0], " and ").concat(args[1], " arguments");
                            break;
                        default:
                            msg += args.slice(0, len - 1).join(', ');
                            msg += ", and ".concat(args[len - 1], " arguments");
                            break;
                    }
                    return "".concat(msg, " must be specified");
                }, TypeError);
                module1.exports.codes = codes;
            /***/ },
            /***/ 5656: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_76678__)=>{
                "use strict";
                // Currently in sync with Node.js lib/internal/util/comparisons.js
                // https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9
                function _slicedToArray(arr, i) {
                    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
                }
                function _nonIterableRest() {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance");
                }
                function _iterableToArrayLimit(arr, i) {
                    var _arr = [];
                    var _n = true;
                    var _d = false;
                    var _e = undefined;
                    try {
                        for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){
                            _arr.push(_s.value);
                            if (i && _arr.length === i) break;
                        }
                    } catch (err) {
                        _d = true;
                        _e = err;
                    } finally{
                        try {
                            if (!_n && _i["return"] != null) _i["return"]();
                        } finally{
                            if (_d) throw _e;
                        }
                    }
                    return _arr;
                }
                function _arrayWithHoles(arr) {
                    if (Array.isArray(arr)) return arr;
                }
                function _typeof(obj) {
                    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                        _typeof = function _typeof(obj) {
                            return typeof obj;
                        };
                    } else {
                        _typeof = function _typeof(obj) {
                            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                        };
                    }
                    return _typeof(obj);
                }
                var regexFlagsSupported = /a/g.flags !== undefined;
                var arrayFromSet = function arrayFromSet(set) {
                    var array = [];
                    set.forEach(function(value) {
                        return array.push(value);
                    });
                    return array;
                };
                var arrayFromMap = function arrayFromMap(map) {
                    var array = [];
                    map.forEach(function(value, key) {
                        return array.push([
                            key,
                            value
                        ]);
                    });
                    return array;
                };
                var objectIs = Object.is ? Object.is : __nested_webpack_require_76678__(5968);
                var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
                    return [];
                };
                var numberIsNaN = Number.isNaN ? Number.isNaN : __nested_webpack_require_76678__(7838);
                function uncurryThis(f) {
                    return f.call.bind(f);
                }
                var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
                var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
                var objectToString = uncurryThis(Object.prototype.toString);
                var _require$types = __nested_webpack_require_76678__(6827).types, isAnyArrayBuffer = _require$types.isAnyArrayBuffer, isArrayBufferView = _require$types.isArrayBufferView, isDate = _require$types.isDate, isMap = _require$types.isMap, isRegExp = _require$types.isRegExp, isSet = _require$types.isSet, isNativeError = _require$types.isNativeError, isBoxedPrimitive = _require$types.isBoxedPrimitive, isNumberObject = _require$types.isNumberObject, isStringObject = _require$types.isStringObject, isBooleanObject = _require$types.isBooleanObject, isBigIntObject = _require$types.isBigIntObject, isSymbolObject = _require$types.isSymbolObject, isFloat32Array = _require$types.isFloat32Array, isFloat64Array = _require$types.isFloat64Array;
                function isNonIndex(key) {
                    if (key.length === 0 || key.length > 10) return true;
                    for(var i = 0; i < key.length; i++){
                        var code = key.charCodeAt(i);
                        if (code < 48 || code > 57) return true;
                    } // The maximum size for an array is 2 ** 32 -1.
                    return key.length === 10 && key >= Math.pow(2, 32);
                }
                function getOwnNonIndexProperties(value) {
                    return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
                } // Taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
                // original notice:
                /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */ function compare(a, b) {
                    if (a === b) {
                        return 0;
                    }
                    var x = a.length;
                    var y = b.length;
                    for(var i = 0, len = Math.min(x, y); i < len; ++i){
                        if (a[i] !== b[i]) {
                            x = a[i];
                            y = b[i];
                            break;
                        }
                    }
                    if (x < y) {
                        return -1;
                    }
                    if (y < x) {
                        return 1;
                    }
                    return 0;
                }
                var ONLY_ENUMERABLE = undefined;
                var kStrict = true;
                var kLoose = false;
                var kNoIterator = 0;
                var kIsArray = 1;
                var kIsSet = 2;
                var kIsMap = 3; // Check if they have the same source and flags
                function areSimilarRegExps(a, b) {
                    return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
                }
                function areSimilarFloatArrays(a, b) {
                    if (a.byteLength !== b.byteLength) {
                        return false;
                    }
                    for(var offset = 0; offset < a.byteLength; offset++){
                        if (a[offset] !== b[offset]) {
                            return false;
                        }
                    }
                    return true;
                }
                function areSimilarTypedArrays(a, b) {
                    if (a.byteLength !== b.byteLength) {
                        return false;
                    }
                    return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
                }
                function areEqualArrayBuffers(buf1, buf2) {
                    return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
                }
                function isEqualBoxedPrimitive(val1, val2) {
                    if (isNumberObject(val1)) {
                        return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
                    }
                    if (isStringObject(val1)) {
                        return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
                    }
                    if (isBooleanObject(val1)) {
                        return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
                    }
                    if (isBigIntObject(val1)) {
                        return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
                    }
                    return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
                } // Notes: Type tags are historical [[Class]] properties that can be set by
                // FunctionTemplate::SetClassName() in C++ or Symbol.toStringTag in JS
                // and retrieved using Object.prototype.toString.call(obj) in JS
                // See https://tc39.github.io/ecma262/#sec-object.prototype.tostring
                // for a list of tags pre-defined in the spec.
                // There are some unspecified tags in the wild too (e.g. typed array tags).
                // Since tags can be altered, they only serve fast failures
                //
                // Typed arrays and buffers are checked by comparing the content in their
                // underlying ArrayBuffer. This optimization requires that it's
                // reasonable to interpret their underlying memory in the same way,
                // which is checked by comparing their type tags.
                // (e.g. a Uint8Array and a Uint16Array with the same memory content
                // could still be different because they will be interpreted differently).
                //
                // For strict comparison, objects should have
                // a) The same built-in type tags
                // b) The same prototypes.
                function innerDeepEqual(val1, val2, strict, memos) {
                    // All identical values are equivalent, as determined by ===.
                    if (val1 === val2) {
                        if (val1 !== 0) return true;
                        return strict ? objectIs(val1, val2) : true;
                    } // Check more closely if val1 and val2 are equal.
                    if (strict) {
                        if (_typeof(val1) !== 'object') {
                            return typeof val1 === 'number' && numberIsNaN(val1) && numberIsNaN(val2);
                        }
                        if (_typeof(val2) !== 'object' || val1 === null || val2 === null) {
                            return false;
                        }
                        if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
                            return false;
                        }
                    } else {
                        if (val1 === null || _typeof(val1) !== 'object') {
                            if (val2 === null || _typeof(val2) !== 'object') {
                                // eslint-disable-next-line eqeqeq
                                return val1 == val2;
                            }
                            return false;
                        }
                        if (val2 === null || _typeof(val2) !== 'object') {
                            return false;
                        }
                    }
                    var val1Tag = objectToString(val1);
                    var val2Tag = objectToString(val2);
                    if (val1Tag !== val2Tag) {
                        return false;
                    }
                    if (Array.isArray(val1)) {
                        // Check for sparse arrays and general fast path
                        if (val1.length !== val2.length) {
                            return false;
                        }
                        var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
                        var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
                        if (keys1.length !== keys2.length) {
                            return false;
                        }
                        return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
                    } // [browserify] This triggers on certain types in IE (Map/Set) so we don't
                    // wan't to early return out of the rest of the checks. However we can check
                    // if the second value is one of these values and the first isn't.
                    if (val1Tag === '[object Object]') {
                        // return keyCheck(val1, val2, strict, memos, kNoIterator);
                        if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {
                            return false;
                        }
                    }
                    if (isDate(val1)) {
                        if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
                            return false;
                        }
                    } else if (isRegExp(val1)) {
                        if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {
                            return false;
                        }
                    } else if (isNativeError(val1) || val1 instanceof Error) {
                        // Do not compare the stack as it might differ even though the error itself
                        // is otherwise identical.
                        if (val1.message !== val2.message || val1.name !== val2.name) {
                            return false;
                        }
                    } else if (isArrayBufferView(val1)) {
                        if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
                            if (!areSimilarFloatArrays(val1, val2)) {
                                return false;
                            }
                        } else if (!areSimilarTypedArrays(val1, val2)) {
                            return false;
                        } // Buffer.compare returns true, so val1.length === val2.length. If they both
                        // only contain numeric keys, we don't need to exam further than checking
                        // the symbols.
                        var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
                        var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
                        if (_keys.length !== _keys2.length) {
                            return false;
                        }
                        return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
                    } else if (isSet(val1)) {
                        if (!isSet(val2) || val1.size !== val2.size) {
                            return false;
                        }
                        return keyCheck(val1, val2, strict, memos, kIsSet);
                    } else if (isMap(val1)) {
                        if (!isMap(val2) || val1.size !== val2.size) {
                            return false;
                        }
                        return keyCheck(val1, val2, strict, memos, kIsMap);
                    } else if (isAnyArrayBuffer(val1)) {
                        if (!areEqualArrayBuffers(val1, val2)) {
                            return false;
                        }
                    } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
                        return false;
                    }
                    return keyCheck(val1, val2, strict, memos, kNoIterator);
                }
                function getEnumerables(val, keys) {
                    return keys.filter(function(k) {
                        return propertyIsEnumerable(val, k);
                    });
                }
                function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
                    // For all remaining Object pairs, including Array, objects and Maps,
                    // equivalence is determined by having:
                    // a) The same number of owned enumerable properties
                    // b) The same set of keys/indexes (although not necessarily the same order)
                    // c) Equivalent values for every corresponding key/index
                    // d) For Sets and Maps, equal contents
                    // Note: this accounts for both named and indexed properties on Arrays.
                    if (arguments.length === 5) {
                        aKeys = Object.keys(val1);
                        var bKeys = Object.keys(val2); // The pair must have the same number of owned properties.
                        if (aKeys.length !== bKeys.length) {
                            return false;
                        }
                    } // Cheap key test
                    var i = 0;
                    for(; i < aKeys.length; i++){
                        if (!hasOwnProperty(val2, aKeys[i])) {
                            return false;
                        }
                    }
                    if (strict && arguments.length === 5) {
                        var symbolKeysA = objectGetOwnPropertySymbols(val1);
                        if (symbolKeysA.length !== 0) {
                            var count = 0;
                            for(i = 0; i < symbolKeysA.length; i++){
                                var key = symbolKeysA[i];
                                if (propertyIsEnumerable(val1, key)) {
                                    if (!propertyIsEnumerable(val2, key)) {
                                        return false;
                                    }
                                    aKeys.push(key);
                                    count++;
                                } else if (propertyIsEnumerable(val2, key)) {
                                    return false;
                                }
                            }
                            var symbolKeysB = objectGetOwnPropertySymbols(val2);
                            if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
                                return false;
                            }
                        } else {
                            var _symbolKeysB = objectGetOwnPropertySymbols(val2);
                            if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
                                return false;
                            }
                        }
                    }
                    if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
                        return true;
                    } // Use memos to handle cycles.
                    if (memos === undefined) {
                        memos = {
                            val1: new Map(),
                            val2: new Map(),
                            position: 0
                        };
                    } else {
                        // We prevent up to two map.has(x) calls by directly retrieving the value
                        // and checking for undefined. The map can only contain numbers, so it is
                        // safe to check for undefined only.
                        var val2MemoA = memos.val1.get(val1);
                        if (val2MemoA !== undefined) {
                            var val2MemoB = memos.val2.get(val2);
                            if (val2MemoB !== undefined) {
                                return val2MemoA === val2MemoB;
                            }
                        }
                        memos.position++;
                    }
                    memos.val1.set(val1, memos.position);
                    memos.val2.set(val2, memos.position);
                    var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
                    memos.val1.delete(val1);
                    memos.val2.delete(val2);
                    return areEq;
                }
                function setHasEqualElement(set, val1, strict, memo) {
                    // Go looking.
                    var setValues = arrayFromSet(set);
                    for(var i = 0; i < setValues.length; i++){
                        var val2 = setValues[i];
                        if (innerDeepEqual(val1, val2, strict, memo)) {
                            // Remove the matching element to make sure we do not check that again.
                            set.delete(val2);
                            return true;
                        }
                    }
                    return false;
                } // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using
                // Sadly it is not possible to detect corresponding values properly in case the
                // type is a string, number, bigint or boolean. The reason is that those values
                // can match lots of different string values (e.g., 1n == '+00001').
                function findLooseMatchingPrimitives(prim) {
                    switch(_typeof(prim)){
                        case 'undefined':
                            return null;
                        case 'object':
                            // Only pass in null as object!
                            return undefined;
                        case 'symbol':
                            return false;
                        case 'string':
                            prim = +prim;
                        // Loose equal entries exist only if the string is possible to convert to
                        // a regular number and not NaN.
                        // Fall through
                        case 'number':
                            if (numberIsNaN(prim)) {
                                return false;
                            }
                    }
                    return true;
                }
                function setMightHaveLoosePrim(a, b, prim) {
                    var altValue = findLooseMatchingPrimitives(prim);
                    if (altValue != null) return altValue;
                    return b.has(altValue) && !a.has(altValue);
                }
                function mapMightHaveLoosePrim(a, b, prim, item, memo) {
                    var altValue = findLooseMatchingPrimitives(prim);
                    if (altValue != null) {
                        return altValue;
                    }
                    var curB = b.get(altValue);
                    if (curB === undefined && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
                        return false;
                    }
                    return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
                }
                function setEquiv(a, b, strict, memo) {
                    // This is a lazily initiated Set of entries which have to be compared
                    // pairwise.
                    var set = null;
                    var aValues = arrayFromSet(a);
                    for(var i = 0; i < aValues.length; i++){
                        var val = aValues[i]; // Note: Checking for the objects first improves the performance for object
                        // heavy sets but it is a minor slow down for primitives. As they are fast
                        // to check this improves the worst case scenario instead.
                        if (_typeof(val) === 'object' && val !== null) {
                            if (set === null) {
                                set = new Set();
                            } // If the specified value doesn't exist in the second set its an not null
                            // object (or non strict only: a not matching primitive) we'll need to go
                            // hunting for something thats deep-(strict-)equal to it. To make this
                            // O(n log n) complexity we have to copy these values in a new set first.
                            set.add(val);
                        } else if (!b.has(val)) {
                            if (strict) return false; // Fast path to detect missing string, symbol, undefined and null values.
                            if (!setMightHaveLoosePrim(a, b, val)) {
                                return false;
                            }
                            if (set === null) {
                                set = new Set();
                            }
                            set.add(val);
                        }
                    }
                    if (set !== null) {
                        var bValues = arrayFromSet(b);
                        for(var _i = 0; _i < bValues.length; _i++){
                            var _val = bValues[_i]; // We have to check if a primitive value is already
                            // matching and only if it's not, go hunting for it.
                            if (_typeof(_val) === 'object' && _val !== null) {
                                if (!setHasEqualElement(set, _val, strict, memo)) return false;
                            } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {
                                return false;
                            }
                        }
                        return set.size === 0;
                    }
                    return true;
                }
                function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
                    // To be able to handle cases like:
                    //   Map([[{}, 'a'], [{}, 'b']]) vs Map([[{}, 'b'], [{}, 'a']])
                    // ... we need to consider *all* matching keys, not just the first we find.
                    var setValues = arrayFromSet(set);
                    for(var i = 0; i < setValues.length; i++){
                        var key2 = setValues[i];
                        if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {
                            set.delete(key2);
                            return true;
                        }
                    }
                    return false;
                }
                function mapEquiv(a, b, strict, memo) {
                    var set = null;
                    var aEntries = arrayFromMap(a);
                    for(var i = 0; i < aEntries.length; i++){
                        var _aEntries$i = _slicedToArray(aEntries[i], 2), key = _aEntries$i[0], item1 = _aEntries$i[1];
                        if (_typeof(key) === 'object' && key !== null) {
                            if (set === null) {
                                set = new Set();
                            }
                            set.add(key);
                        } else {
                            // By directly retrieving the value we prevent another b.has(key) check in
                            // almost all possible cases.
                            var item2 = b.get(key);
                            if (item2 === undefined && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {
                                if (strict) return false; // Fast path to detect missing string, symbol, undefined and null
                                // keys.
                                if (!mapMightHaveLoosePrim(a, b, key, item1, memo)) return false;
                                if (set === null) {
                                    set = new Set();
                                }
                                set.add(key);
                            }
                        }
                    }
                    if (set !== null) {
                        var bEntries = arrayFromMap(b);
                        for(var _i2 = 0; _i2 < bEntries.length; _i2++){
                            var _bEntries$_i = _slicedToArray(bEntries[_i2], 2), key = _bEntries$_i[0], item = _bEntries$_i[1];
                            if (_typeof(key) === 'object' && key !== null) {
                                if (!mapHasEqualEntry(set, a, key, item, strict, memo)) return false;
                            } else if (!strict && (!a.has(key) || !innerDeepEqual(a.get(key), item, false, memo)) && !mapHasEqualEntry(set, a, key, item, false, memo)) {
                                return false;
                            }
                        }
                        return set.size === 0;
                    }
                    return true;
                }
                function objEquiv(a, b, strict, keys, memos, iterationType) {
                    // Sets and maps don't have their entries accessible via normal object
                    // properties.
                    var i = 0;
                    if (iterationType === kIsSet) {
                        if (!setEquiv(a, b, strict, memos)) {
                            return false;
                        }
                    } else if (iterationType === kIsMap) {
                        if (!mapEquiv(a, b, strict, memos)) {
                            return false;
                        }
                    } else if (iterationType === kIsArray) {
                        for(; i < a.length; i++){
                            if (hasOwnProperty(a, i)) {
                                if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {
                                    return false;
                                }
                            } else if (hasOwnProperty(b, i)) {
                                return false;
                            } else {
                                // Array is sparse.
                                var keysA = Object.keys(a);
                                for(; i < keysA.length; i++){
                                    var key = keysA[i];
                                    if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {
                                        return false;
                                    }
                                }
                                if (keysA.length !== Object.keys(b).length) {
                                    return false;
                                }
                                return true;
                            }
                        }
                    } // The pair must have equivalent values for every corresponding key.
                    // Possibly expensive deep test:
                    for(i = 0; i < keys.length; i++){
                        var _key = keys[i];
                        if (!innerDeepEqual(a[_key], b[_key], strict, memos)) {
                            return false;
                        }
                    }
                    return true;
                }
                function isDeepEqual(val1, val2) {
                    return innerDeepEqual(val1, val2, kLoose);
                }
                function isDeepStrictEqual(val1, val2) {
                    return innerDeepEqual(val1, val2, kStrict);
                }
                module1.exports = {
                    isDeepEqual: isDeepEqual,
                    isDeepStrictEqual: isDeepStrictEqual
                };
            /***/ },
            /***/ 9818: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_108232__)=>{
                "use strict";
                var GetIntrinsic = __nested_webpack_require_108232__(528);
                var callBind = __nested_webpack_require_108232__(8498);
                var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));
                module1.exports = function callBoundIntrinsic(name, allowMissing) {
                    var intrinsic = GetIntrinsic(name, !!allowMissing);
                    if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
                        return callBind(intrinsic);
                    }
                    return intrinsic;
                };
            /***/ },
            /***/ 8498: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_108959__)=>{
                "use strict";
                var bind = __nested_webpack_require_108959__(9138);
                var GetIntrinsic = __nested_webpack_require_108959__(528);
                var setFunctionLength = __nested_webpack_require_108959__(6108);
                var $TypeError = __nested_webpack_require_108959__(3468);
                var $apply = GetIntrinsic('%Function.prototype.apply%');
                var $call = GetIntrinsic('%Function.prototype.call%');
                var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);
                var $defineProperty = __nested_webpack_require_108959__(4940);
                var $max = GetIntrinsic('%Math.max%');
                module1.exports = function callBind(originalFunction) {
                    if (typeof originalFunction !== 'function') {
                        throw new $TypeError('a function is required');
                    }
                    var func = $reflectApply(bind, $call, arguments);
                    return setFunctionLength(func, 1 + $max(0, originalFunction.length - (arguments.length - 1)), true);
                };
                var applyBind = function applyBind() {
                    return $reflectApply(bind, $apply, arguments);
                };
                if ($defineProperty) {
                    $defineProperty(module1.exports, 'apply', {
                        value: applyBind
                    });
                } else {
                    module1.exports.apply = applyBind;
                }
            /***/ },
            /***/ 4364: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_110558__)=>{
                /*global window, global*/ var util = __nested_webpack_require_110558__(6827);
                var assert = __nested_webpack_require_110558__(6093);
                function now() {
                    return new Date().getTime();
                }
                var slice = Array.prototype.slice;
                var console;
                var times = {};
                if (typeof __nested_webpack_require_110558__.g !== "undefined" && __nested_webpack_require_110558__.g.console) {
                    console = __nested_webpack_require_110558__.g.console;
                } else if (typeof window !== "undefined" && window.console) {
                    console = window.console;
                } else {
                    console = {};
                }
                var functions = [
                    [
                        log,
                        "log"
                    ],
                    [
                        info,
                        "info"
                    ],
                    [
                        warn,
                        "warn"
                    ],
                    [
                        error,
                        "error"
                    ],
                    [
                        time,
                        "time"
                    ],
                    [
                        timeEnd,
                        "timeEnd"
                    ],
                    [
                        trace,
                        "trace"
                    ],
                    [
                        dir,
                        "dir"
                    ],
                    [
                        consoleAssert,
                        "assert"
                    ]
                ];
                for(var i = 0; i < functions.length; i++){
                    var tuple = functions[i];
                    var f = tuple[0];
                    var name = tuple[1];
                    if (!console[name]) {
                        console[name] = f;
                    }
                }
                module1.exports = console;
                function log() {}
                function info() {
                    console.log.apply(console, arguments);
                }
                function warn() {
                    console.log.apply(console, arguments);
                }
                function error() {
                    console.warn.apply(console, arguments);
                }
                function time(label) {
                    times[label] = now();
                }
                function timeEnd(label) {
                    var time = times[label];
                    if (!time) {
                        throw new Error("No such label: " + label);
                    }
                    delete times[label];
                    var duration = now() - time;
                    console.log(label + ": " + duration + "ms");
                }
                function trace() {
                    var err = new Error();
                    err.name = "Trace";
                    err.message = util.format.apply(null, arguments);
                    console.error(err.stack);
                }
                function dir(object) {
                    console.log(util.inspect(object) + "\n");
                }
                function consoleAssert(expression) {
                    if (!expression) {
                        var arr = slice.call(arguments, 1);
                        assert.ok(false, util.format.apply(null, arr));
                    }
                }
            /***/ },
            /***/ 686: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_114240__)=>{
                "use strict";
                var $defineProperty = __nested_webpack_require_114240__(4940);
                var $SyntaxError = __nested_webpack_require_114240__(5731);
                var $TypeError = __nested_webpack_require_114240__(3468);
                var gopd = __nested_webpack_require_114240__(9336);
                /** @type {import('.')} */ module1.exports = function defineDataProperty(obj, property, value) {
                    if (!obj || typeof obj !== 'object' && typeof obj !== 'function') {
                        throw new $TypeError('`obj` must be an object or a function`');
                    }
                    if (typeof property !== 'string' && typeof property !== 'symbol') {
                        throw new $TypeError('`property` must be a string or a symbol`');
                    }
                    if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
                        throw new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');
                    }
                    if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
                        throw new $TypeError('`nonWritable`, if provided, must be a boolean or null');
                    }
                    if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
                        throw new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');
                    }
                    if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
                        throw new $TypeError('`loose`, if provided, must be a boolean');
                    }
                    var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
                    var nonWritable = arguments.length > 4 ? arguments[4] : null;
                    var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
                    var loose = arguments.length > 6 ? arguments[6] : false;
                    /* @type {false | TypedPropertyDescriptor<unknown>} */ var desc = !!gopd && gopd(obj, property);
                    if ($defineProperty) {
                        $defineProperty(obj, property, {
                            configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
                            enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
                            value: value,
                            writable: nonWritable === null && desc ? desc.writable : !nonWritable
                        });
                    } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
                        // must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
                        obj[property] = value; // eslint-disable-line no-param-reassign
                    } else {
                        throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
                    }
                };
            /***/ },
            /***/ 1857: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_117528__)=>{
                "use strict";
                var keys = __nested_webpack_require_117528__(9228);
                var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';
                var toStr = Object.prototype.toString;
                var concat = Array.prototype.concat;
                var origDefineProperty = Object.defineProperty;
                var isFunction = function(fn) {
                    return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
                };
                var hasPropertyDescriptors = __nested_webpack_require_117528__(7239)();
                var supportsDescriptors = origDefineProperty && hasPropertyDescriptors;
                var defineProperty = function(object, name, value, predicate) {
                    if (name in object) {
                        if (predicate === true) {
                            if (object[name] === value) {
                                return;
                            }
                        } else if (!isFunction(predicate) || !predicate()) {
                            return;
                        }
                    }
                    if (supportsDescriptors) {
                        origDefineProperty(object, name, {
                            configurable: true,
                            enumerable: false,
                            value: value,
                            writable: true
                        });
                    } else {
                        object[name] = value; // eslint-disable-line no-param-reassign
                    }
                };
                var defineProperties = function(object, map) {
                    var predicates = arguments.length > 2 ? arguments[2] : {};
                    var props = keys(map);
                    if (hasSymbols) {
                        props = concat.call(props, Object.getOwnPropertySymbols(map));
                    }
                    for(var i = 0; i < props.length; i += 1){
                        defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
                    }
                };
                defineProperties.supportsDescriptors = !!supportsDescriptors;
                module1.exports = defineProperties;
            /***/ },
            /***/ 4940: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_119911__)=>{
                "use strict";
                var GetIntrinsic = __nested_webpack_require_119911__(528);
                /** @type {import('.')} */ var $defineProperty = GetIntrinsic('%Object.defineProperty%', true) || false;
                if ($defineProperty) {
                    try {
                        $defineProperty({}, 'a', {
                            value: 1
                        });
                    } catch (e) {
                        // IE 8 has a broken defineProperty
                        $defineProperty = false;
                    }
                }
                module1.exports = $defineProperty;
            /***/ },
            /***/ 6729: /***/ (module1)=>{
                "use strict";
                /** @type {import('./eval')} */ module1.exports = EvalError;
            /***/ },
            /***/ 9838: /***/ (module1)=>{
                "use strict";
                /** @type {import('.')} */ module1.exports = Error;
            /***/ },
            /***/ 1155: /***/ (module1)=>{
                "use strict";
                /** @type {import('./range')} */ module1.exports = RangeError;
            /***/ },
            /***/ 4943: /***/ (module1)=>{
                "use strict";
                /** @type {import('./ref')} */ module1.exports = ReferenceError;
            /***/ },
            /***/ 5731: /***/ (module1)=>{
                "use strict";
                /** @type {import('./syntax')} */ module1.exports = SyntaxError;
            /***/ },
            /***/ 3468: /***/ (module1)=>{
                "use strict";
                /** @type {import('./type')} */ module1.exports = TypeError;
            /***/ },
            /***/ 2140: /***/ (module1)=>{
                "use strict";
                /** @type {import('./uri')} */ module1.exports = URIError;
            /***/ },
            /***/ 3046: /***/ (module1)=>{
                "use strict";
                /**
 * Code refactored from Mozilla Developer Network:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 */ function assign(target, firstSource) {
                    if (target === undefined || target === null) {
                        throw new TypeError('Cannot convert first argument to object');
                    }
                    var to = Object(target);
                    for(var i = 1; i < arguments.length; i++){
                        var nextSource = arguments[i];
                        if (nextSource === undefined || nextSource === null) {
                            continue;
                        }
                        var keysArray = Object.keys(Object(nextSource));
                        for(var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++){
                            var nextKey = keysArray[nextIndex];
                            var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                            if (desc !== undefined && desc.enumerable) {
                                to[nextKey] = nextSource[nextKey];
                            }
                        }
                    }
                    return to;
                }
                function polyfill() {
                    if (!Object.assign) {
                        Object.defineProperty(Object, 'assign', {
                            enumerable: false,
                            configurable: true,
                            writable: true,
                            value: assign
                        });
                    }
                }
                module1.exports = {
                    assign: assign,
                    polyfill: polyfill
                };
            /***/ },
            /***/ 705: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_123757__)=>{
                "use strict";
                var isCallable = __nested_webpack_require_123757__(9617);
                var toStr = Object.prototype.toString;
                var hasOwnProperty = Object.prototype.hasOwnProperty;
                var forEachArray = function forEachArray(array, iterator, receiver) {
                    for(var i = 0, len = array.length; i < len; i++){
                        if (hasOwnProperty.call(array, i)) {
                            if (receiver == null) {
                                iterator(array[i], i, array);
                            } else {
                                iterator.call(receiver, array[i], i, array);
                            }
                        }
                    }
                };
                var forEachString = function forEachString(string, iterator, receiver) {
                    for(var i = 0, len = string.length; i < len; i++){
                        // no such thing as a sparse string.
                        if (receiver == null) {
                            iterator(string.charAt(i), i, string);
                        } else {
                            iterator.call(receiver, string.charAt(i), i, string);
                        }
                    }
                };
                var forEachObject = function forEachObject(object, iterator, receiver) {
                    for(var k in object){
                        if (hasOwnProperty.call(object, k)) {
                            if (receiver == null) {
                                iterator(object[k], k, object);
                            } else {
                                iterator.call(receiver, object[k], k, object);
                            }
                        }
                    }
                };
                var forEach = function forEach(list, iterator, thisArg) {
                    if (!isCallable(iterator)) {
                        throw new TypeError('iterator must be a function');
                    }
                    var receiver;
                    if (arguments.length >= 3) {
                        receiver = thisArg;
                    }
                    if (toStr.call(list) === '[object Array]') {
                        forEachArray(list, iterator, receiver);
                    } else if (typeof list === 'string') {
                        forEachString(list, iterator, receiver);
                    } else {
                        forEachObject(list, iterator, receiver);
                    }
                };
                module1.exports = forEach;
            /***/ },
            /***/ 8794: /***/ (module1)=>{
                "use strict";
                /* eslint no-invalid-this: 1 */ var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
                var toStr = Object.prototype.toString;
                var max = Math.max;
                var funcType = '[object Function]';
                var concatty = function concatty(a, b) {
                    var arr = [];
                    for(var i = 0; i < a.length; i += 1){
                        arr[i] = a[i];
                    }
                    for(var j = 0; j < b.length; j += 1){
                        arr[j + a.length] = b[j];
                    }
                    return arr;
                };
                var slicy = function slicy(arrLike, offset) {
                    var arr = [];
                    for(var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1){
                        arr[j] = arrLike[i];
                    }
                    return arr;
                };
                var joiny = function(arr, joiner) {
                    var str = '';
                    for(var i = 0; i < arr.length; i += 1){
                        str += arr[i];
                        if (i + 1 < arr.length) {
                            str += joiner;
                        }
                    }
                    return str;
                };
                module1.exports = function bind(that) {
                    var target = this;
                    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
                        throw new TypeError(ERROR_MESSAGE + target);
                    }
                    var args = slicy(arguments, 1);
                    var bound;
                    var binder = function() {
                        if (this instanceof bound) {
                            var result = target.apply(this, concatty(args, arguments));
                            if (Object(result) === result) {
                                return result;
                            }
                            return this;
                        }
                        return target.apply(that, concatty(args, arguments));
                    };
                    var boundLength = max(0, target.length - args.length);
                    var boundArgs = [];
                    for(var i = 0; i < boundLength; i++){
                        boundArgs[i] = '$' + i;
                    }
                    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);
                    if (target.prototype) {
                        var Empty = function Empty() {};
                        Empty.prototype = target.prototype;
                        bound.prototype = new Empty();
                        Empty.prototype = null;
                    }
                    return bound;
                };
            /***/ },
            /***/ 9138: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_129476__)=>{
                "use strict";
                var implementation = __nested_webpack_require_129476__(8794);
                module1.exports = Function.prototype.bind || implementation;
            /***/ },
            /***/ 528: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_129757__)=>{
                "use strict";
                var undefined1;
                var $Error = __nested_webpack_require_129757__(9838);
                var $EvalError = __nested_webpack_require_129757__(6729);
                var $RangeError = __nested_webpack_require_129757__(1155);
                var $ReferenceError = __nested_webpack_require_129757__(4943);
                var $SyntaxError = __nested_webpack_require_129757__(5731);
                var $TypeError = __nested_webpack_require_129757__(3468);
                var $URIError = __nested_webpack_require_129757__(2140);
                var $Function = Function;
                // eslint-disable-next-line consistent-return
                var getEvalledConstructor = function(expressionSyntax) {
                    try {
                        return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
                    } catch (e) {}
                };
                var $gOPD = Object.getOwnPropertyDescriptor;
                if ($gOPD) {
                    try {
                        $gOPD({}, '');
                    } catch (e) {
                        $gOPD = null; // this is IE 8, which has a broken gOPD
                    }
                }
                var throwTypeError = function() {
                    throw new $TypeError();
                };
                var ThrowTypeError = $gOPD ? function() {
                    try {
                        // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
                        arguments.callee; // IE 8 does not throw here
                        return throwTypeError;
                    } catch (calleeThrows) {
                        try {
                            // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
                            return $gOPD(arguments, 'callee').get;
                        } catch (gOPDthrows) {
                            return throwTypeError;
                        }
                    }
                }() : throwTypeError;
                var hasSymbols = __nested_webpack_require_129757__(3558)();
                var hasProto = __nested_webpack_require_129757__(6869)();
                var getProto = Object.getPrototypeOf || (hasProto ? function(x) {
                    return x.__proto__;
                } // eslint-disable-line no-proto
                 : null);
                var needsEval = {};
                var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined1 : getProto(Uint8Array);
                var INTRINSICS = {
                    __proto__: null,
                    '%AggregateError%': typeof AggregateError === 'undefined' ? undefined1 : AggregateError,
                    '%Array%': Array,
                    '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined1 : ArrayBuffer,
                    '%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined1,
                    '%AsyncFromSyncIteratorPrototype%': undefined1,
                    '%AsyncFunction%': needsEval,
                    '%AsyncGenerator%': needsEval,
                    '%AsyncGeneratorFunction%': needsEval,
                    '%AsyncIteratorPrototype%': needsEval,
                    '%Atomics%': typeof Atomics === 'undefined' ? undefined1 : Atomics,
                    '%BigInt%': typeof BigInt === 'undefined' ? undefined1 : BigInt,
                    '%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined1 : BigInt64Array,
                    '%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined1 : BigUint64Array,
                    '%Boolean%': Boolean,
                    '%DataView%': typeof DataView === 'undefined' ? undefined1 : DataView,
                    '%Date%': Date,
                    '%decodeURI%': decodeURI,
                    '%decodeURIComponent%': decodeURIComponent,
                    '%encodeURI%': encodeURI,
                    '%encodeURIComponent%': encodeURIComponent,
                    '%Error%': $Error,
                    '%eval%': eval,
                    '%EvalError%': $EvalError,
                    '%Float32Array%': typeof Float32Array === 'undefined' ? undefined1 : Float32Array,
                    '%Float64Array%': typeof Float64Array === 'undefined' ? undefined1 : Float64Array,
                    '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined1 : FinalizationRegistry,
                    '%Function%': $Function,
                    '%GeneratorFunction%': needsEval,
                    '%Int8Array%': typeof Int8Array === 'undefined' ? undefined1 : Int8Array,
                    '%Int16Array%': typeof Int16Array === 'undefined' ? undefined1 : Int16Array,
                    '%Int32Array%': typeof Int32Array === 'undefined' ? undefined1 : Int32Array,
                    '%isFinite%': isFinite,
                    '%isNaN%': isNaN,
                    '%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined1,
                    '%JSON%': typeof JSON === 'object' ? JSON : undefined1,
                    '%Map%': typeof Map === 'undefined' ? undefined1 : Map,
                    '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined1 : getProto(new Map()[Symbol.iterator]()),
                    '%Math%': Math,
                    '%Number%': Number,
                    '%Object%': Object,
                    '%parseFloat%': parseFloat,
                    '%parseInt%': parseInt,
                    '%Promise%': typeof Promise === 'undefined' ? undefined1 : Promise,
                    '%Proxy%': typeof Proxy === 'undefined' ? undefined1 : Proxy,
                    '%RangeError%': $RangeError,
                    '%ReferenceError%': $ReferenceError,
                    '%Reflect%': typeof Reflect === 'undefined' ? undefined1 : Reflect,
                    '%RegExp%': RegExp,
                    '%Set%': typeof Set === 'undefined' ? undefined1 : Set,
                    '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined1 : getProto(new Set()[Symbol.iterator]()),
                    '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined1 : SharedArrayBuffer,
                    '%String%': String,
                    '%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined1,
                    '%Symbol%': hasSymbols ? Symbol : undefined1,
                    '%SyntaxError%': $SyntaxError,
                    '%ThrowTypeError%': ThrowTypeError,
                    '%TypedArray%': TypedArray,
                    '%TypeError%': $TypeError,
                    '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined1 : Uint8Array,
                    '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined1 : Uint8ClampedArray,
                    '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined1 : Uint16Array,
                    '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined1 : Uint32Array,
                    '%URIError%': $URIError,
                    '%WeakMap%': typeof WeakMap === 'undefined' ? undefined1 : WeakMap,
                    '%WeakRef%': typeof WeakRef === 'undefined' ? undefined1 : WeakRef,
                    '%WeakSet%': typeof WeakSet === 'undefined' ? undefined1 : WeakSet
                };
                if (getProto) {
                    try {
                        null.error; // eslint-disable-line no-unused-expressions
                    } catch (e) {
                        // https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
                        var errorProto = getProto(getProto(e));
                        INTRINSICS['%Error.prototype%'] = errorProto;
                    }
                }
                var doEval = function doEval(name) {
                    var value;
                    if (name === '%AsyncFunction%') {
                        value = getEvalledConstructor('async function () {}');
                    } else if (name === '%GeneratorFunction%') {
                        value = getEvalledConstructor('function* () {}');
                    } else if (name === '%AsyncGeneratorFunction%') {
                        value = getEvalledConstructor('async function* () {}');
                    } else if (name === '%AsyncGenerator%') {
                        var fn = doEval('%AsyncGeneratorFunction%');
                        if (fn) {
                            value = fn.prototype;
                        }
                    } else if (name === '%AsyncIteratorPrototype%') {
                        var gen = doEval('%AsyncGenerator%');
                        if (gen && getProto) {
                            value = getProto(gen.prototype);
                        }
                    }
                    INTRINSICS[name] = value;
                    return value;
                };
                var LEGACY_ALIASES = {
                    __proto__: null,
                    '%ArrayBufferPrototype%': [
                        'ArrayBuffer',
                        'prototype'
                    ],
                    '%ArrayPrototype%': [
                        'Array',
                        'prototype'
                    ],
                    '%ArrayProto_entries%': [
                        'Array',
                        'prototype',
                        'entries'
                    ],
                    '%ArrayProto_forEach%': [
                        'Array',
                        'prototype',
                        'forEach'
                    ],
                    '%ArrayProto_keys%': [
                        'Array',
                        'prototype',
                        'keys'
                    ],
                    '%ArrayProto_values%': [
                        'Array',
                        'prototype',
                        'values'
                    ],
                    '%AsyncFunctionPrototype%': [
                        'AsyncFunction',
                        'prototype'
                    ],
                    '%AsyncGenerator%': [
                        'AsyncGeneratorFunction',
                        'prototype'
                    ],
                    '%AsyncGeneratorPrototype%': [
                        'AsyncGeneratorFunction',
                        'prototype',
                        'prototype'
                    ],
                    '%BooleanPrototype%': [
                        'Boolean',
                        'prototype'
                    ],
                    '%DataViewPrototype%': [
                        'DataView',
                        'prototype'
                    ],
                    '%DatePrototype%': [
                        'Date',
                        'prototype'
                    ],
                    '%ErrorPrototype%': [
                        'Error',
                        'prototype'
                    ],
                    '%EvalErrorPrototype%': [
                        'EvalError',
                        'prototype'
                    ],
                    '%Float32ArrayPrototype%': [
                        'Float32Array',
                        'prototype'
                    ],
                    '%Float64ArrayPrototype%': [
                        'Float64Array',
                        'prototype'
                    ],
                    '%FunctionPrototype%': [
                        'Function',
                        'prototype'
                    ],
                    '%Generator%': [
                        'GeneratorFunction',
                        'prototype'
                    ],
                    '%GeneratorPrototype%': [
                        'GeneratorFunction',
                        'prototype',
                        'prototype'
                    ],
                    '%Int8ArrayPrototype%': [
                        'Int8Array',
                        'prototype'
                    ],
                    '%Int16ArrayPrototype%': [
                        'Int16Array',
                        'prototype'
                    ],
                    '%Int32ArrayPrototype%': [
                        'Int32Array',
                        'prototype'
                    ],
                    '%JSONParse%': [
                        'JSON',
                        'parse'
                    ],
                    '%JSONStringify%': [
                        'JSON',
                        'stringify'
                    ],
                    '%MapPrototype%': [
                        'Map',
                        'prototype'
                    ],
                    '%NumberPrototype%': [
                        'Number',
                        'prototype'
                    ],
                    '%ObjectPrototype%': [
                        'Object',
                        'prototype'
                    ],
                    '%ObjProto_toString%': [
                        'Object',
                        'prototype',
                        'toString'
                    ],
                    '%ObjProto_valueOf%': [
                        'Object',
                        'prototype',
                        'valueOf'
                    ],
                    '%PromisePrototype%': [
                        'Promise',
                        'prototype'
                    ],
                    '%PromiseProto_then%': [
                        'Promise',
                        'prototype',
                        'then'
                    ],
                    '%Promise_all%': [
                        'Promise',
                        'all'
                    ],
                    '%Promise_reject%': [
                        'Promise',
                        'reject'
                    ],
                    '%Promise_resolve%': [
                        'Promise',
                        'resolve'
                    ],
                    '%RangeErrorPrototype%': [
                        'RangeError',
                        'prototype'
                    ],
                    '%ReferenceErrorPrototype%': [
                        'ReferenceError',
                        'prototype'
                    ],
                    '%RegExpPrototype%': [
                        'RegExp',
                        'prototype'
                    ],
                    '%SetPrototype%': [
                        'Set',
                        'prototype'
                    ],
                    '%SharedArrayBufferPrototype%': [
                        'SharedArrayBuffer',
                        'prototype'
                    ],
                    '%StringPrototype%': [
                        'String',
                        'prototype'
                    ],
                    '%SymbolPrototype%': [
                        'Symbol',
                        'prototype'
                    ],
                    '%SyntaxErrorPrototype%': [
                        'SyntaxError',
                        'prototype'
                    ],
                    '%TypedArrayPrototype%': [
                        'TypedArray',
                        'prototype'
                    ],
                    '%TypeErrorPrototype%': [
                        'TypeError',
                        'prototype'
                    ],
                    '%Uint8ArrayPrototype%': [
                        'Uint8Array',
                        'prototype'
                    ],
                    '%Uint8ClampedArrayPrototype%': [
                        'Uint8ClampedArray',
                        'prototype'
                    ],
                    '%Uint16ArrayPrototype%': [
                        'Uint16Array',
                        'prototype'
                    ],
                    '%Uint32ArrayPrototype%': [
                        'Uint32Array',
                        'prototype'
                    ],
                    '%URIErrorPrototype%': [
                        'URIError',
                        'prototype'
                    ],
                    '%WeakMapPrototype%': [
                        'WeakMap',
                        'prototype'
                    ],
                    '%WeakSetPrototype%': [
                        'WeakSet',
                        'prototype'
                    ]
                };
                var bind = __nested_webpack_require_129757__(9138);
                var hasOwn = __nested_webpack_require_129757__(8554);
                var $concat = bind.call(Function.call, Array.prototype.concat);
                var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
                var $replace = bind.call(Function.call, String.prototype.replace);
                var $strSlice = bind.call(Function.call, String.prototype.slice);
                var $exec = bind.call(Function.call, RegExp.prototype.exec);
                /* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */ var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
                var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */ 
                var stringToPath = function stringToPath(string) {
                    var first = $strSlice(string, 0, 1);
                    var last = $strSlice(string, -1);
                    if (first === '%' && last !== '%') {
                        throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
                    } else if (last === '%' && first !== '%') {
                        throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
                    }
                    var result = [];
                    $replace(string, rePropName, function(match, number, quote, subString) {
                        result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
                    });
                    return result;
                };
                /* end adaptation */ var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
                    var intrinsicName = name;
                    var alias;
                    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
                        alias = LEGACY_ALIASES[intrinsicName];
                        intrinsicName = '%' + alias[0] + '%';
                    }
                    if (hasOwn(INTRINSICS, intrinsicName)) {
                        var value = INTRINSICS[intrinsicName];
                        if (value === needsEval) {
                            value = doEval(intrinsicName);
                        }
                        if (typeof value === 'undefined' && !allowMissing) {
                            throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
                        }
                        return {
                            alias: alias,
                            name: intrinsicName,
                            value: value
                        };
                    }
                    throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
                };
                module1.exports = function GetIntrinsic(name, allowMissing) {
                    if (typeof name !== 'string' || name.length === 0) {
                        throw new $TypeError('intrinsic name must be a non-empty string');
                    }
                    if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
                        throw new $TypeError('"allowMissing" argument must be a boolean');
                    }
                    if ($exec(/^%?[^%]*%?$/, name) === null) {
                        throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
                    }
                    var parts = stringToPath(name);
                    var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
                    var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
                    var intrinsicRealName = intrinsic.name;
                    var value = intrinsic.value;
                    var skipFurtherCaching = false;
                    var alias = intrinsic.alias;
                    if (alias) {
                        intrinsicBaseName = alias[0];
                        $spliceApply(parts, $concat([
                            0,
                            1
                        ], alias));
                    }
                    for(var i = 1, isOwn = true; i < parts.length; i += 1){
                        var part = parts[i];
                        var first = $strSlice(part, 0, 1);
                        var last = $strSlice(part, -1);
                        if ((first === '"' || first === "'" || first === '`' || last === '"' || last === "'" || last === '`') && first !== last) {
                            throw new $SyntaxError('property names with quotes must have matching quotes');
                        }
                        if (part === 'constructor' || !isOwn) {
                            skipFurtherCaching = true;
                        }
                        intrinsicBaseName += '.' + part;
                        intrinsicRealName = '%' + intrinsicBaseName + '%';
                        if (hasOwn(INTRINSICS, intrinsicRealName)) {
                            value = INTRINSICS[intrinsicRealName];
                        } else if (value != null) {
                            if (!(part in value)) {
                                if (!allowMissing) {
                                    throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
                                }
                                return void undefined1;
                            }
                            if ($gOPD && i + 1 >= parts.length) {
                                var desc = $gOPD(value, part);
                                isOwn = !!desc;
                                // By convention, when a data property is converted to an accessor
                                // property to emulate a data property that does not suffer from
                                // the override mistake, that accessor's getter is marked with
                                // an `originalValue` property. Here, when we detect this, we
                                // uphold the illusion by pretending to see that original data
                                // property, i.e., returning the value rather than the getter
                                // itself.
                                if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
                                    value = desc.get;
                                } else {
                                    value = value[part];
                                }
                            } else {
                                isOwn = hasOwn(value, part);
                                value = value[part];
                            }
                            if (isOwn && !skipFurtherCaching) {
                                INTRINSICS[intrinsicRealName] = value;
                            }
                        }
                    }
                    return value;
                };
            /***/ },
            /***/ 9336: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_153635__)=>{
                "use strict";
                var GetIntrinsic = __nested_webpack_require_153635__(528);
                var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
                if ($gOPD) {
                    try {
                        $gOPD([], 'length');
                    } catch (e) {
                        // IE 8 has a broken gOPD
                        $gOPD = null;
                    }
                }
                module1.exports = $gOPD;
            /***/ },
            /***/ 7239: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_154225__)=>{
                "use strict";
                var $defineProperty = __nested_webpack_require_154225__(4940);
                var hasPropertyDescriptors = function hasPropertyDescriptors() {
                    return !!$defineProperty;
                };
                hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
                    // node v0.6 has a bug where array lengths can be Set but not Defined
                    if (!$defineProperty) {
                        return null;
                    }
                    try {
                        return $defineProperty([], 'length', {
                            value: 1
                        }).length !== 1;
                    } catch (e) {
                        // In Firefox 4-22, defining length on an array throws an exception.
                        return true;
                    }
                };
                module1.exports = hasPropertyDescriptors;
            /***/ },
            /***/ 6869: /***/ (module1)=>{
                "use strict";
                var test = {
                    foo: {}
                };
                var $Object = Object;
                module1.exports = function hasProto() {
                    return ({
                        __proto__: test
                    }).foo === test.foo && !(({
                        __proto__: null
                    }) instanceof $Object);
                };
            /***/ },
            /***/ 3558: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_155787__)=>{
                "use strict";
                var origSymbol = typeof Symbol !== 'undefined' && Symbol;
                var hasSymbolSham = __nested_webpack_require_155787__(2908);
                module1.exports = function hasNativeSymbols() {
                    if (typeof origSymbol !== 'function') {
                        return false;
                    }
                    if (typeof Symbol !== 'function') {
                        return false;
                    }
                    if (typeof origSymbol('foo') !== 'symbol') {
                        return false;
                    }
                    if (typeof Symbol('bar') !== 'symbol') {
                        return false;
                    }
                    return hasSymbolSham();
                };
            /***/ },
            /***/ 2908: /***/ (module1)=>{
                "use strict";
                /* eslint complexity: [2, 18], max-statements: [2, 33] */ module1.exports = function hasSymbols() {
                    if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
                        return false;
                    }
                    if (typeof Symbol.iterator === 'symbol') {
                        return true;
                    }
                    var obj = {};
                    var sym = Symbol('test');
                    var symObj = Object(sym);
                    if (typeof sym === 'string') {
                        return false;
                    }
                    if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
                        return false;
                    }
                    if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
                        return false;
                    }
                    // temp disabled per https://github.com/ljharb/object.assign/issues/17
                    // if (sym instanceof Symbol) { return false; }
                    // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
                    // if (!(symObj instanceof Symbol)) { return false; }
                    // if (typeof Symbol.prototype.toString !== 'function') { return false; }
                    // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }
                    var symVal = 42;
                    obj[sym] = symVal;
                    for(sym in obj){
                        return false;
                    } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
                    if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
                        return false;
                    }
                    if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
                        return false;
                    }
                    var syms = Object.getOwnPropertySymbols(obj);
                    if (syms.length !== 1 || syms[0] !== sym) {
                        return false;
                    }
                    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
                        return false;
                    }
                    if (typeof Object.getOwnPropertyDescriptor === 'function') {
                        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
                        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
                            return false;
                        }
                    }
                    return true;
                };
            /***/ },
            /***/ 1913: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_159546__)=>{
                "use strict";
                var hasSymbols = __nested_webpack_require_159546__(2908);
                module1.exports = function hasToStringTagShams() {
                    return hasSymbols() && !!Symbol.toStringTag;
                };
            /***/ },
            /***/ 8554: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_159898__)=>{
                "use strict";
                var call = Function.prototype.call;
                var $hasOwn = Object.prototype.hasOwnProperty;
                var bind = __nested_webpack_require_159898__(9138);
                /** @type {import('.')} */ module1.exports = bind.call(call, $hasOwn);
            /***/ },
            /***/ 5615: /***/ (module1)=>{
                if (typeof Object.create === 'function') {
                    // implementation from standard node.js 'util' module
                    module1.exports = function inherits(ctor, superCtor) {
                        if (superCtor) {
                            ctor.super_ = superCtor;
                            ctor.prototype = Object.create(superCtor.prototype, {
                                constructor: {
                                    value: ctor,
                                    enumerable: false,
                                    writable: true,
                                    configurable: true
                                }
                            });
                        }
                    };
                } else {
                    // old school shim for old browsers
                    module1.exports = function inherits(ctor, superCtor) {
                        if (superCtor) {
                            ctor.super_ = superCtor;
                            var TempCtor = function() {};
                            TempCtor.prototype = superCtor.prototype;
                            ctor.prototype = new TempCtor();
                            ctor.prototype.constructor = ctor;
                        }
                    };
                }
            /***/ },
            /***/ 5387: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_161685__)=>{
                "use strict";
                var hasToStringTag = __nested_webpack_require_161685__(1913)();
                var callBound = __nested_webpack_require_161685__(9818);
                var $toString = callBound('Object.prototype.toString');
                var isStandardArguments = function isArguments(value) {
                    if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
                        return false;
                    }
                    return $toString(value) === '[object Arguments]';
                };
                var isLegacyArguments = function isArguments(value) {
                    if (isStandardArguments(value)) {
                        return true;
                    }
                    return value !== null && typeof value === 'object' && typeof value.length === 'number' && value.length >= 0 && $toString(value) !== '[object Array]' && $toString(value.callee) === '[object Function]';
                };
                var supportsStandardArguments = function() {
                    return isStandardArguments(arguments);
                }();
                isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests
                module1.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
            /***/ },
            /***/ 9617: /***/ (module1)=>{
                "use strict";
                var fnToStr = Function.prototype.toString;
                var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
                var badArrayLike;
                var isCallableMarker;
                if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
                    try {
                        badArrayLike = Object.defineProperty({}, 'length', {
                            get: function() {
                                throw isCallableMarker;
                            }
                        });
                        isCallableMarker = {};
                        // eslint-disable-next-line no-throw-literal
                        reflectApply(function() {
                            throw 42;
                        }, null, badArrayLike);
                    } catch (_) {
                        if (_ !== isCallableMarker) {
                            reflectApply = null;
                        }
                    }
                } else {
                    reflectApply = null;
                }
                var constructorRegex = /^\s*class\b/;
                var isES6ClassFn = function isES6ClassFunction(value) {
                    try {
                        var fnStr = fnToStr.call(value);
                        return constructorRegex.test(fnStr);
                    } catch (e) {
                        return false; // not a function
                    }
                };
                var tryFunctionObject = function tryFunctionToStr(value) {
                    try {
                        if (isES6ClassFn(value)) {
                            return false;
                        }
                        fnToStr.call(value);
                        return true;
                    } catch (e) {
                        return false;
                    }
                };
                var toStr = Object.prototype.toString;
                var objectClass = '[object Object]';
                var fnClass = '[object Function]';
                var genClass = '[object GeneratorFunction]';
                var ddaClass = '[object HTMLAllCollection]'; // IE 11
                var ddaClass2 = '[object HTML document.all class]';
                var ddaClass3 = '[object HTMLCollection]'; // IE 9-10
                var hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`
                var isIE68 = !(0 in [
                    , 
                ]); // eslint-disable-line no-sparse-arrays, comma-spacing
                var isDDA = function isDocumentDotAll() {
                    return false;
                };
                if (typeof document === 'object') {
                    // Firefox 3 canonicalizes DDA to undefined when it's not accessed directly
                    var all = document.all;
                    if (toStr.call(all) === toStr.call(document.all)) {
                        isDDA = function isDocumentDotAll(value) {
                            /* globals document: false */ // in IE 6-8, typeof document.all is "object" and it's truthy
                            if ((isIE68 || !value) && (typeof value === 'undefined' || typeof value === 'object')) {
                                try {
                                    var str = toStr.call(value);
                                    return (str === ddaClass || str === ddaClass2 || str === ddaClass3 // opera 12.16
                                     || str === objectClass // IE 6-8
                                    ) && value('') == null; // eslint-disable-line eqeqeq
                                } catch (e) {}
                            }
                            return false;
                        };
                    }
                }
                module1.exports = reflectApply ? function isCallable(value) {
                    if (isDDA(value)) {
                        return true;
                    }
                    if (!value) {
                        return false;
                    }
                    if (typeof value !== 'function' && typeof value !== 'object') {
                        return false;
                    }
                    try {
                        reflectApply(value, null, badArrayLike);
                    } catch (e) {
                        if (e !== isCallableMarker) {
                            return false;
                        }
                    }
                    return !isES6ClassFn(value) && tryFunctionObject(value);
                } : function isCallable(value) {
                    if (isDDA(value)) {
                        return true;
                    }
                    if (!value) {
                        return false;
                    }
                    if (typeof value !== 'function' && typeof value !== 'object') {
                        return false;
                    }
                    if (hasToStringTag) {
                        return tryFunctionObject(value);
                    }
                    if (isES6ClassFn(value)) {
                        return false;
                    }
                    var strClass = toStr.call(value);
                    if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
                        return false;
                    }
                    return tryFunctionObject(value);
                };
            /***/ },
            /***/ 2625: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_168745__)=>{
                "use strict";
                var toStr = Object.prototype.toString;
                var fnToStr = Function.prototype.toString;
                var isFnRegex = /^\s*(?:function)?\*/;
                var hasToStringTag = __nested_webpack_require_168745__(1913)();
                var getProto = Object.getPrototypeOf;
                var getGeneratorFunc = function() {
                    if (!hasToStringTag) {
                        return false;
                    }
                    try {
                        return Function('return function*() {}')();
                    } catch (e) {}
                };
                var GeneratorFunction;
                module1.exports = function isGeneratorFunction(fn) {
                    if (typeof fn !== 'function') {
                        return false;
                    }
                    if (isFnRegex.test(fnToStr.call(fn))) {
                        return true;
                    }
                    if (!hasToStringTag) {
                        var str = toStr.call(fn);
                        return str === '[object GeneratorFunction]';
                    }
                    if (!getProto) {
                        return false;
                    }
                    if (typeof GeneratorFunction === 'undefined') {
                        var generatorFunc = getGeneratorFunc();
                        GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
                    }
                    return getProto(fn) === GeneratorFunction;
                };
            /***/ },
            /***/ 8006: /***/ (module1)=>{
                "use strict";
                /* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */ module1.exports = function isNaN1(value) {
                    return value !== value;
                };
            /***/ },
            /***/ 7838: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_170714__)=>{
                "use strict";
                var callBind = __nested_webpack_require_170714__(8498);
                var define1 = __nested_webpack_require_170714__(1857);
                var implementation = __nested_webpack_require_170714__(8006);
                var getPolyfill = __nested_webpack_require_170714__(1591);
                var shim = __nested_webpack_require_170714__(1641);
                var polyfill = callBind(getPolyfill(), Number);
                /* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */ define1(polyfill, {
                    getPolyfill: getPolyfill,
                    implementation: implementation,
                    shim: shim
                });
                module1.exports = polyfill;
            /***/ },
            /***/ 1591: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_171513__)=>{
                "use strict";
                var implementation = __nested_webpack_require_171513__(8006);
                module1.exports = function getPolyfill() {
                    if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN('a')) {
                        return Number.isNaN;
                    }
                    return implementation;
                };
            /***/ },
            /***/ 1641: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_171989__)=>{
                "use strict";
                var define1 = __nested_webpack_require_171989__(1857);
                var getPolyfill = __nested_webpack_require_171989__(1591);
                /* http://www.ecma-international.org/ecma-262/6.0/#sec-number.isnan */ module1.exports = function shimNumberIsNaN() {
                    var polyfill = getPolyfill();
                    define1(Number, {
                        isNaN: polyfill
                    }, {
                        isNaN: function testIsNaN() {
                            return Number.isNaN !== polyfill;
                        }
                    });
                    return polyfill;
                };
            /***/ },
            /***/ 5943: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_172757__)=>{
                "use strict";
                var whichTypedArray = __nested_webpack_require_172757__(2730);
                module1.exports = function isTypedArray(value) {
                    return !!whichTypedArray(value);
                };
            /***/ },
            /***/ 2372: /***/ (module1)=>{
                "use strict";
                var numberIsNaN = function(value) {
                    return value !== value;
                };
                module1.exports = function is(a, b) {
                    if (a === 0 && b === 0) {
                        return 1 / a === 1 / b;
                    }
                    if (a === b) {
                        return true;
                    }
                    if (numberIsNaN(a) && numberIsNaN(b)) {
                        return true;
                    }
                    return false;
                };
            /***/ },
            /***/ 5968: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_173745__)=>{
                "use strict";
                var define1 = __nested_webpack_require_173745__(1857);
                var callBind = __nested_webpack_require_173745__(8498);
                var implementation = __nested_webpack_require_173745__(2372);
                var getPolyfill = __nested_webpack_require_173745__(1937);
                var shim = __nested_webpack_require_173745__(5087);
                var polyfill = callBind(getPolyfill(), Object);
                define1(polyfill, {
                    getPolyfill: getPolyfill,
                    implementation: implementation,
                    shim: shim
                });
                module1.exports = polyfill;
            /***/ },
            /***/ 1937: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_174473__)=>{
                "use strict";
                var implementation = __nested_webpack_require_174473__(2372);
                module1.exports = function getPolyfill() {
                    return typeof Object.is === 'function' ? Object.is : implementation;
                };
            /***/ },
            /***/ 5087: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_174845__)=>{
                "use strict";
                var getPolyfill = __nested_webpack_require_174845__(1937);
                var define1 = __nested_webpack_require_174845__(1857);
                module1.exports = function shimObjectIs() {
                    var polyfill = getPolyfill();
                    define1(Object, {
                        is: polyfill
                    }, {
                        is: function testObjectIs() {
                            return Object.is !== polyfill;
                        }
                    });
                    return polyfill;
                };
            /***/ },
            /***/ 8160: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_175533__)=>{
                "use strict";
                var keysShim;
                if (!Object.keys) {
                    // modified from https://github.com/es-shims/es5-shim
                    var has = Object.prototype.hasOwnProperty;
                    var toStr = Object.prototype.toString;
                    var isArgs = __nested_webpack_require_175533__(968); // eslint-disable-line global-require
                    var isEnumerable = Object.prototype.propertyIsEnumerable;
                    var hasDontEnumBug = !isEnumerable.call({
                        toString: null
                    }, 'toString');
                    var hasProtoEnumBug = isEnumerable.call(function() {}, 'prototype');
                    var dontEnums = [
                        'toString',
                        'toLocaleString',
                        'valueOf',
                        'hasOwnProperty',
                        'isPrototypeOf',
                        'propertyIsEnumerable',
                        'constructor'
                    ];
                    var equalsConstructorPrototype = function(o) {
                        var ctor = o.constructor;
                        return ctor && ctor.prototype === o;
                    };
                    var excludedKeys = {
                        $applicationCache: true,
                        $console: true,
                        $external: true,
                        $frame: true,
                        $frameElement: true,
                        $frames: true,
                        $innerHeight: true,
                        $innerWidth: true,
                        $onmozfullscreenchange: true,
                        $onmozfullscreenerror: true,
                        $outerHeight: true,
                        $outerWidth: true,
                        $pageXOffset: true,
                        $pageYOffset: true,
                        $parent: true,
                        $scrollLeft: true,
                        $scrollTop: true,
                        $scrollX: true,
                        $scrollY: true,
                        $self: true,
                        $webkitIndexedDB: true,
                        $webkitStorageInfo: true,
                        $window: true
                    };
                    var hasAutomationEqualityBug = function() {
                        /* global window */ if (typeof window === 'undefined') {
                            return false;
                        }
                        for(var k in window){
                            try {
                                if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
                                    try {
                                        equalsConstructorPrototype(window[k]);
                                    } catch (e) {
                                        return true;
                                    }
                                }
                            } catch (e) {
                                return true;
                            }
                        }
                        return false;
                    }();
                    var equalsConstructorPrototypeIfNotBuggy = function(o) {
                        /* global window */ if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
                            return equalsConstructorPrototype(o);
                        }
                        try {
                            return equalsConstructorPrototype(o);
                        } catch (e) {
                            return false;
                        }
                    };
                    keysShim = function keys(object) {
                        var isObject = object !== null && typeof object === 'object';
                        var isFunction = toStr.call(object) === '[object Function]';
                        var isArguments = isArgs(object);
                        var isString = isObject && toStr.call(object) === '[object String]';
                        var theKeys = [];
                        if (!isObject && !isFunction && !isArguments) {
                            throw new TypeError('Object.keys called on a non-object');
                        }
                        var skipProto = hasProtoEnumBug && isFunction;
                        if (isString && object.length > 0 && !has.call(object, 0)) {
                            for(var i = 0; i < object.length; ++i){
                                theKeys.push(String(i));
                            }
                        }
                        if (isArguments && object.length > 0) {
                            for(var j = 0; j < object.length; ++j){
                                theKeys.push(String(j));
                            }
                        } else {
                            for(var name in object){
                                if (!(skipProto && name === 'prototype') && has.call(object, name)) {
                                    theKeys.push(String(name));
                                }
                            }
                        }
                        if (hasDontEnumBug) {
                            var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
                            for(var k = 0; k < dontEnums.length; ++k){
                                if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
                                    theKeys.push(dontEnums[k]);
                                }
                            }
                        }
                        return theKeys;
                    };
                }
                module1.exports = keysShim;
            /***/ },
            /***/ 9228: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_181502__)=>{
                "use strict";
                var slice = Array.prototype.slice;
                var isArgs = __nested_webpack_require_181502__(968);
                var origKeys = Object.keys;
                var keysShim = origKeys ? function keys(o) {
                    return origKeys(o);
                } : __nested_webpack_require_181502__(8160);
                var originalKeys = Object.keys;
                keysShim.shim = function shimObjectKeys() {
                    if (Object.keys) {
                        var keysWorksWithArguments = function() {
                            // Safari 5.0 bug
                            var args = Object.keys(arguments);
                            return args && args.length === arguments.length;
                        }(1, 2);
                        if (!keysWorksWithArguments) {
                            Object.keys = function keys(object) {
                                if (isArgs(object)) {
                                    return originalKeys(slice.call(object));
                                }
                                return originalKeys(object);
                            };
                        }
                    } else {
                        Object.keys = keysShim;
                    }
                    return Object.keys || keysShim;
                };
                module1.exports = keysShim;
            /***/ },
            /***/ 968: /***/ (module1)=>{
                "use strict";
                var toStr = Object.prototype.toString;
                module1.exports = function isArguments(value) {
                    var str = toStr.call(value);
                    var isArgs = str === '[object Arguments]';
                    if (!isArgs) {
                        isArgs = str !== '[object Array]' && value !== null && typeof value === 'object' && typeof value.length === 'number' && value.length >= 0 && toStr.call(value.callee) === '[object Function]';
                    }
                    return isArgs;
                };
            /***/ },
            /***/ 9907: /***/ (module1)=>{
                // shim for using process in browser
                var process = module1.exports = {};
                // cached from whatever global is present so that test runners that stub it
                // don't break things.  But we need to wrap it in a try catch in case it is
                // wrapped in strict mode code which doesn't define any globals.  It's inside a
                // function because try/catches deoptimize in certain engines.
                var cachedSetTimeout;
                var cachedClearTimeout;
                function defaultSetTimout() {
                    throw new Error('setTimeout has not been defined');
                }
                function defaultClearTimeout() {
                    throw new Error('clearTimeout has not been defined');
                }
                (function() {
                    try {
                        if (typeof setTimeout === 'function') {
                            cachedSetTimeout = setTimeout;
                        } else {
                            cachedSetTimeout = defaultSetTimout;
                        }
                    } catch (e) {
                        cachedSetTimeout = defaultSetTimout;
                    }
                    try {
                        if (typeof clearTimeout === 'function') {
                            cachedClearTimeout = clearTimeout;
                        } else {
                            cachedClearTimeout = defaultClearTimeout;
                        }
                    } catch (e) {
                        cachedClearTimeout = defaultClearTimeout;
                    }
                })();
                function runTimeout(fun) {
                    if (cachedSetTimeout === setTimeout) {
                        //normal enviroments in sane situations
                        return setTimeout(fun, 0);
                    }
                    // if setTimeout wasn't available but was latter defined
                    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                        cachedSetTimeout = setTimeout;
                        return setTimeout(fun, 0);
                    }
                    try {
                        // when when somebody has screwed with setTimeout but no I.E. maddness
                        return cachedSetTimeout(fun, 0);
                    } catch (e) {
                        try {
                            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                            return cachedSetTimeout.call(null, fun, 0);
                        } catch (e) {
                            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                            return cachedSetTimeout.call(this, fun, 0);
                        }
                    }
                }
                function runClearTimeout(marker) {
                    if (cachedClearTimeout === clearTimeout) {
                        //normal enviroments in sane situations
                        return clearTimeout(marker);
                    }
                    // if clearTimeout wasn't available but was latter defined
                    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                        cachedClearTimeout = clearTimeout;
                        return clearTimeout(marker);
                    }
                    try {
                        // when when somebody has screwed with setTimeout but no I.E. maddness
                        return cachedClearTimeout(marker);
                    } catch (e) {
                        try {
                            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                            return cachedClearTimeout.call(null, marker);
                        } catch (e) {
                            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                            return cachedClearTimeout.call(this, marker);
                        }
                    }
                }
                var queue = [];
                var draining = false;
                var currentQueue;
                var queueIndex = -1;
                function cleanUpNextTick() {
                    if (!draining || !currentQueue) {
                        return;
                    }
                    draining = false;
                    if (currentQueue.length) {
                        queue = currentQueue.concat(queue);
                    } else {
                        queueIndex = -1;
                    }
                    if (queue.length) {
                        drainQueue();
                    }
                }
                function drainQueue() {
                    if (draining) {
                        return;
                    }
                    var timeout = runTimeout(cleanUpNextTick);
                    draining = true;
                    var len = queue.length;
                    while(len){
                        currentQueue = queue;
                        queue = [];
                        while(++queueIndex < len){
                            if (currentQueue) {
                                currentQueue[queueIndex].run();
                            }
                        }
                        queueIndex = -1;
                        len = queue.length;
                    }
                    currentQueue = null;
                    draining = false;
                    runClearTimeout(timeout);
                }
                process.nextTick = function(fun) {
                    var args = new Array(arguments.length - 1);
                    if (arguments.length > 1) {
                        for(var i = 1; i < arguments.length; i++){
                            args[i - 1] = arguments[i];
                        }
                    }
                    queue.push(new Item(fun, args));
                    if (queue.length === 1 && !draining) {
                        runTimeout(drainQueue);
                    }
                };
                // v8 likes predictible objects
                function Item(fun, array) {
                    this.fun = fun;
                    this.array = array;
                }
                Item.prototype.run = function() {
                    this.fun.apply(null, this.array);
                };
                process.title = 'browser';
                process.browser = true;
                process.env = {};
                process.argv = [];
                process.version = ''; // empty string to avoid regexp issues
                process.versions = {};
                function noop() {}
                process.on = noop;
                process.addListener = noop;
                process.once = noop;
                process.off = noop;
                process.removeListener = noop;
                process.removeAllListeners = noop;
                process.emit = noop;
                process.prependListener = noop;
                process.prependOnceListener = noop;
                process.listeners = function(name) {
                    return [];
                };
                process.binding = function(name) {
                    throw new Error('process.binding is not supported');
                };
                process.cwd = function() {
                    return '/';
                };
                process.chdir = function(dir) {
                    throw new Error('process.chdir is not supported');
                };
                process.umask = function() {
                    return 0;
                };
            /***/ },
            /***/ 6108: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_191866__)=>{
                "use strict";
                var GetIntrinsic = __nested_webpack_require_191866__(528);
                var define1 = __nested_webpack_require_191866__(686);
                var hasDescriptors = __nested_webpack_require_191866__(7239)();
                var gOPD = __nested_webpack_require_191866__(9336);
                var $TypeError = __nested_webpack_require_191866__(3468);
                var $floor = GetIntrinsic('%Math.floor%');
                /** @type {import('.')} */ module1.exports = function setFunctionLength(fn, length) {
                    if (typeof fn !== 'function') {
                        throw new $TypeError('`fn` is not a function');
                    }
                    if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {
                        throw new $TypeError('`length` must be a positive 32-bit integer');
                    }
                    var loose = arguments.length > 2 && !!arguments[2];
                    var functionLengthIsConfigurable = true;
                    var functionLengthIsWritable = true;
                    if ('length' in fn && gOPD) {
                        var desc = gOPD(fn, 'length');
                        if (desc && !desc.configurable) {
                            functionLengthIsConfigurable = false;
                        }
                        if (desc && !desc.writable) {
                            functionLengthIsWritable = false;
                        }
                    }
                    if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
                        if (hasDescriptors) {
                            define1(/** @type {Parameters<define>[0]} */ fn, 'length', length, true, true);
                        } else {
                            define1(/** @type {Parameters<define>[0]} */ fn, 'length', length);
                        }
                    }
                    return fn;
                };
            /***/ },
            /***/ 2125: /***/ (__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_193940__)=>{
                "use strict";
                /* harmony export */ __nested_webpack_require_193940__.d(__nested_webpack_exports__, {
                    /* harmony export */ BaseService: ()=>/* binding */ BaseService
                });
                /* harmony import */ var vscode_languageserver_protocol__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_193940__(5501);
                /* harmony import */ var vscode_languageserver_protocol__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __nested_webpack_require_193940__.n(vscode_languageserver_protocol__WEBPACK_IMPORTED_MODULE_0__);
                /* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_193940__(7770);
                /* harmony import */ var vscode_languageserver_textdocument__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_193940__(8041);
                function _define_property(obj, key, value) {
                    if (key in obj) {
                        Object.defineProperty(obj, key, {
                            value: value,
                            enumerable: true,
                            configurable: true,
                            writable: true
                        });
                    } else {
                        obj[key] = value;
                    }
                    return obj;
                }
                class BaseService {
                    addDocument(document1) {
                        this.documents[document1.uri] = vscode_languageserver_textdocument__WEBPACK_IMPORTED_MODULE_1__ /* .TextDocument */ .V.create(document1.uri, document1.languageId, document1.version, document1.text);
                    }
                    getDocument(uri) {
                        return this.documents[uri];
                    }
                    removeDocument(document1) {
                        delete this.documents[document1.uri];
                        if (this.options[document1.uri]) {
                            delete this.options[document1.uri];
                        }
                    }
                    getDocumentValue(uri) {
                        var _this_getDocument;
                        return (_this_getDocument = this.getDocument(uri)) === null || _this_getDocument === void 0 ? void 0 : _this_getDocument.getText();
                    }
                    setValue(identifier, value) {
                        let document1 = this.getDocument(identifier.uri);
                        if (document1) {
                            document1 = vscode_languageserver_textdocument__WEBPACK_IMPORTED_MODULE_1__ /* .TextDocument */ .V.create(document1.uri, document1.languageId, document1.version, value);
                            this.documents[document1.uri] = document1;
                        }
                    }
                    setGlobalOptions(options) {
                        this.globalOptions = options !== null && options !== void 0 ? options : {};
                    }
                    setWorkspace(workspaceUri) {
                        this.workspaceUri = workspaceUri;
                    }
                    setOptions(documentUri, options, merge = false) {
                        this.options[documentUri] = merge ? (0, _utils__WEBPACK_IMPORTED_MODULE_2__ /* .mergeObjects */ .rL)(options, this.options[documentUri]) : options;
                    }
                    getOption(documentUri, optionName) {
                        if (this.options[documentUri] && this.options[documentUri][optionName]) {
                            return this.options[documentUri][optionName];
                        } else {
                            return this.globalOptions[optionName];
                        }
                    }
                    applyDeltas(identifier, deltas) {
                        let document1 = this.getDocument(identifier.uri);
                        if (document1) vscode_languageserver_textdocument__WEBPACK_IMPORTED_MODULE_1__ /* .TextDocument */ .V.update(document1, deltas, identifier.version);
                    }
                    async doComplete(document1, position) {
                        return null;
                    }
                    async doHover(document1, position) {
                        return null;
                    }
                    async doResolve(item) {
                        return null;
                    }
                    async doValidation(document1) {
                        return [];
                    }
                    format(document1, range, options) {
                        return Promise.resolve([]);
                    }
                    async provideSignatureHelp(document1, position) {
                        return null;
                    }
                    async findDocumentHighlights(document1, position) {
                        return [];
                    }
                    get optionsToFilterDiagnostics() {
                        var _this_globalOptions_errorCodesToIgnore, _this_globalOptions_errorCodesToTreatAsWarning, _this_globalOptions_errorCodesToTreatAsInfo, _this_globalOptions_errorMessagesToIgnore, _this_globalOptions_errorMessagesToTreatAsWarning, _this_globalOptions_errorMessagesToTreatAsInfo;
                        return {
                            errorCodesToIgnore: (_this_globalOptions_errorCodesToIgnore = this.globalOptions.errorCodesToIgnore) !== null && _this_globalOptions_errorCodesToIgnore !== void 0 ? _this_globalOptions_errorCodesToIgnore : [],
                            errorCodesToTreatAsWarning: (_this_globalOptions_errorCodesToTreatAsWarning = this.globalOptions.errorCodesToTreatAsWarning) !== null && _this_globalOptions_errorCodesToTreatAsWarning !== void 0 ? _this_globalOptions_errorCodesToTreatAsWarning : [],
                            errorCodesToTreatAsInfo: (_this_globalOptions_errorCodesToTreatAsInfo = this.globalOptions.errorCodesToTreatAsInfo) !== null && _this_globalOptions_errorCodesToTreatAsInfo !== void 0 ? _this_globalOptions_errorCodesToTreatAsInfo : [],
                            errorMessagesToIgnore: (_this_globalOptions_errorMessagesToIgnore = this.globalOptions.errorMessagesToIgnore) !== null && _this_globalOptions_errorMessagesToIgnore !== void 0 ? _this_globalOptions_errorMessagesToIgnore : [],
                            errorMessagesToTreatAsWarning: (_this_globalOptions_errorMessagesToTreatAsWarning = this.globalOptions.errorMessagesToTreatAsWarning) !== null && _this_globalOptions_errorMessagesToTreatAsWarning !== void 0 ? _this_globalOptions_errorMessagesToTreatAsWarning : [],
                            errorMessagesToTreatAsInfo: (_this_globalOptions_errorMessagesToTreatAsInfo = this.globalOptions.errorMessagesToTreatAsInfo) !== null && _this_globalOptions_errorMessagesToTreatAsInfo !== void 0 ? _this_globalOptions_errorMessagesToTreatAsInfo : []
                        };
                    }
                    getSemanticTokens(document1, range) {
                        return Promise.resolve(null);
                    }
                    dispose() {
                        return Promise.resolve();
                    }
                    closeConnection() {
                        return Promise.resolve();
                    }
                    getCodeActions(document1, range, context) {
                        return Promise.resolve(null);
                    }
                    executeCommand(command, args) {
                        return Promise.resolve(null);
                    }
                    sendAppliedResult(result, callbackId) {}
                    constructor(mode, workspaceUri){
                        _define_property(this, "serviceName", void 0);
                        _define_property(this, "mode", void 0);
                        _define_property(this, "documents", {});
                        _define_property(this, "options", {});
                        _define_property(this, "globalOptions", {});
                        _define_property(this, "serviceData", void 0);
                        _define_property(this, "serviceCapabilities", {});
                        _define_property(this, "workspaceUri", void 0);
                        _define_property(this, "clientCapabilities", {
                            textDocument: {
                                diagnostic: {
                                    dynamicRegistration: true,
                                    relatedDocumentSupport: true
                                },
                                publishDiagnostics: {
                                    relatedInformation: true,
                                    versionSupport: false,
                                    tagSupport: {
                                        valueSet: [
                                            vscode_languageserver_protocol__WEBPACK_IMPORTED_MODULE_0__.DiagnosticTag.Unnecessary,
                                            vscode_languageserver_protocol__WEBPACK_IMPORTED_MODULE_0__.DiagnosticTag.Deprecated
                                        ]
                                    }
                                },
                                hover: {
                                    dynamicRegistration: true,
                                    contentFormat: [
                                        'markdown',
                                        'plaintext'
                                    ]
                                },
                                synchronization: {
                                    dynamicRegistration: true,
                                    willSave: false,
                                    didSave: false,
                                    willSaveWaitUntil: false
                                },
                                formatting: {
                                    dynamicRegistration: true
                                },
                                completion: {
                                    dynamicRegistration: true,
                                    completionItem: {
                                        snippetSupport: true,
                                        commitCharactersSupport: false,
                                        documentationFormat: [
                                            'markdown',
                                            'plaintext'
                                        ],
                                        deprecatedSupport: false,
                                        preselectSupport: false
                                    },
                                    contextSupport: false
                                },
                                signatureHelp: {
                                    signatureInformation: {
                                        documentationFormat: [
                                            'markdown',
                                            'plaintext'
                                        ],
                                        activeParameterSupport: true
                                    }
                                },
                                documentHighlight: {
                                    dynamicRegistration: true
                                },
                                semanticTokens: {
                                    multilineTokenSupport: false,
                                    overlappingTokenSupport: false,
                                    tokenTypes: [],
                                    tokenModifiers: [],
                                    formats: [
                                        "relative"
                                    ],
                                    requests: {
                                        full: {
                                            delta: false
                                        },
                                        range: true
                                    },
                                    augmentsSyntaxTokens: true
                                },
                                codeAction: {
                                    dynamicRegistration: true
                                }
                            },
                            workspace: {
                                didChangeConfiguration: {
                                    dynamicRegistration: true
                                },
                                executeCommand: {
                                    dynamicRegistration: true
                                },
                                applyEdit: true,
                                workspaceEdit: {
                                    failureHandling: "abort",
                                    normalizesLineEndings: false,
                                    documentChanges: false
                                }
                            }
                        });
                        this.mode = mode;
                        this.workspaceUri = workspaceUri;
                    }
                }
            /***/ },
            /***/ 7770: /***/ (__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_207268__)=>{
                "use strict";
                /* harmony export */ __nested_webpack_require_207268__.d(__nested_webpack_exports__, {
                    /* harmony export */ Tk: ()=>/* binding */ checkValueAgainstRegexpArray,
                    /* harmony export */ rL: ()=>/* binding */ mergeObjects
                });
                /* unused harmony exports notEmpty, mergeRanges, convertToUri */ function mergeObjects(obj1, obj2, excludeUndefined = false) {
                    if (!obj1) return obj2;
                    if (!obj2) return obj1;
                    if (excludeUndefined) {
                        obj1 = excludeUndefinedValues(obj1);
                        obj2 = excludeUndefinedValues(obj2);
                    }
                    const mergedObjects = {
                        ...obj2,
                        ...obj1
                    }; // Give priority to obj1 values by spreading obj2 first, then obj1
                    for (const key of Object.keys(mergedObjects)){
                        if (obj1[key] && obj2[key]) {
                            if (Array.isArray(obj1[key])) {
                                mergedObjects[key] = obj1[key].concat(obj2[key]);
                            } else if (Array.isArray(obj2[key])) {
                                mergedObjects[key] = obj2[key].concat(obj1[key]);
                            } else if (typeof obj1[key] === 'object' && typeof obj2[key] === 'object') {
                                mergedObjects[key] = mergeObjects(obj1[key], obj2[key]);
                            }
                        }
                    }
                    return mergedObjects;
                }
                function excludeUndefinedValues(obj) {
                    const filteredEntries = Object.entries(obj).filter(([_, value])=>value !== undefined);
                    return Object.fromEntries(filteredEntries);
                }
                function notEmpty1(value) {
                    return value !== null && value !== undefined;
                }
                //taken with small changes from ace-code
                function mergeRanges1(ranges) {
                    var list = ranges;
                    list = list.sort(function(a, b) {
                        return comparePoints(a.start, b.start);
                    });
                    var next = list[0], range;
                    for(var i = 1; i < list.length; i++){
                        range = next;
                        next = list[i];
                        var cmp = comparePoints(range.end, next.start);
                        if (cmp < 0) continue;
                        if (cmp == 0 && !range.isEmpty() && !next.isEmpty()) continue;
                        if (comparePoints(range.end, next.end) < 0) {
                            range.end.row = next.end.row;
                            range.end.column = next.end.column;
                        }
                        list.splice(i, 1);
                        next = range;
                        i--;
                    }
                    return list;
                }
                function comparePoints(p1, p2) {
                    return p1.row - p2.row || p1.column - p2.column;
                }
                function checkValueAgainstRegexpArray(value, regexpArray) {
                    if (!regexpArray) {
                        return false;
                    }
                    for(let i = 0; i < regexpArray.length; i++){
                        if (regexpArray[i].test(value)) {
                            return true;
                        }
                    }
                    return false;
                }
                function convertToUri(filePath) {
                    //already URI
                    if (filePath.startsWith("file:///")) {
                        return filePath;
                    }
                    return URI.file(filePath).toString();
                }
            /***/ },
            /***/ 5272: /***/ (module1)=>{
                module1.exports = function isBuffer(arg) {
                    return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
                };
            /***/ },
            /***/ 1531: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_211656__)=>{
                "use strict";
                // Currently in sync with Node.js lib/internal/util/types.js
                // https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9
                var isArgumentsObject = __nested_webpack_require_211656__(5387);
                var isGeneratorFunction = __nested_webpack_require_211656__(2625);
                var whichTypedArray = __nested_webpack_require_211656__(2730);
                var isTypedArray = __nested_webpack_require_211656__(5943);
                function uncurryThis(f) {
                    return f.call.bind(f);
                }
                var BigIntSupported = typeof BigInt !== 'undefined';
                var SymbolSupported = typeof Symbol !== 'undefined';
                var ObjectToString = uncurryThis(Object.prototype.toString);
                var numberValue = uncurryThis(Number.prototype.valueOf);
                var stringValue = uncurryThis(String.prototype.valueOf);
                var booleanValue = uncurryThis(Boolean.prototype.valueOf);
                if (BigIntSupported) {
                    var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
                }
                if (SymbolSupported) {
                    var symbolValue = uncurryThis(Symbol.prototype.valueOf);
                }
                function checkBoxedPrimitive(value, prototypeValueOf) {
                    if (typeof value !== 'object') {
                        return false;
                    }
                    try {
                        prototypeValueOf(value);
                        return true;
                    } catch (e) {
                        return false;
                    }
                }
                exports1.isArgumentsObject = isArgumentsObject;
                exports1.isGeneratorFunction = isGeneratorFunction;
                exports1.isTypedArray = isTypedArray;
                // Taken from here and modified for better browser support
                // https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
                function isPromise(input) {
                    return typeof Promise !== 'undefined' && input instanceof Promise || input !== null && typeof input === 'object' && typeof input.then === 'function' && typeof input.catch === 'function';
                }
                exports1.isPromise = isPromise;
                function isArrayBufferView(value) {
                    if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
                        return ArrayBuffer.isView(value);
                    }
                    return isTypedArray(value) || isDataView(value);
                }
                exports1.isArrayBufferView = isArrayBufferView;
                function isUint8Array(value) {
                    return whichTypedArray(value) === 'Uint8Array';
                }
                exports1.isUint8Array = isUint8Array;
                function isUint8ClampedArray(value) {
                    return whichTypedArray(value) === 'Uint8ClampedArray';
                }
                exports1.isUint8ClampedArray = isUint8ClampedArray;
                function isUint16Array(value) {
                    return whichTypedArray(value) === 'Uint16Array';
                }
                exports1.isUint16Array = isUint16Array;
                function isUint32Array(value) {
                    return whichTypedArray(value) === 'Uint32Array';
                }
                exports1.isUint32Array = isUint32Array;
                function isInt8Array(value) {
                    return whichTypedArray(value) === 'Int8Array';
                }
                exports1.isInt8Array = isInt8Array;
                function isInt16Array(value) {
                    return whichTypedArray(value) === 'Int16Array';
                }
                exports1.isInt16Array = isInt16Array;
                function isInt32Array(value) {
                    return whichTypedArray(value) === 'Int32Array';
                }
                exports1.isInt32Array = isInt32Array;
                function isFloat32Array(value) {
                    return whichTypedArray(value) === 'Float32Array';
                }
                exports1.isFloat32Array = isFloat32Array;
                function isFloat64Array(value) {
                    return whichTypedArray(value) === 'Float64Array';
                }
                exports1.isFloat64Array = isFloat64Array;
                function isBigInt64Array(value) {
                    return whichTypedArray(value) === 'BigInt64Array';
                }
                exports1.isBigInt64Array = isBigInt64Array;
                function isBigUint64Array(value) {
                    return whichTypedArray(value) === 'BigUint64Array';
                }
                exports1.isBigUint64Array = isBigUint64Array;
                function isMapToString(value) {
                    return ObjectToString(value) === '[object Map]';
                }
                isMapToString.working = typeof Map !== 'undefined' && isMapToString(new Map());
                function isMap(value) {
                    if (typeof Map === 'undefined') {
                        return false;
                    }
                    return isMapToString.working ? isMapToString(value) : value instanceof Map;
                }
                exports1.isMap = isMap;
                function isSetToString(value) {
                    return ObjectToString(value) === '[object Set]';
                }
                isSetToString.working = typeof Set !== 'undefined' && isSetToString(new Set());
                function isSet(value) {
                    if (typeof Set === 'undefined') {
                        return false;
                    }
                    return isSetToString.working ? isSetToString(value) : value instanceof Set;
                }
                exports1.isSet = isSet;
                function isWeakMapToString(value) {
                    return ObjectToString(value) === '[object WeakMap]';
                }
                isWeakMapToString.working = typeof WeakMap !== 'undefined' && isWeakMapToString(new WeakMap());
                function isWeakMap(value) {
                    if (typeof WeakMap === 'undefined') {
                        return false;
                    }
                    return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
                }
                exports1.isWeakMap = isWeakMap;
                function isWeakSetToString(value) {
                    return ObjectToString(value) === '[object WeakSet]';
                }
                isWeakSetToString.working = typeof WeakSet !== 'undefined' && isWeakSetToString(new WeakSet());
                function isWeakSet(value) {
                    return isWeakSetToString(value);
                }
                exports1.isWeakSet = isWeakSet;
                function isArrayBufferToString(value) {
                    return ObjectToString(value) === '[object ArrayBuffer]';
                }
                isArrayBufferToString.working = typeof ArrayBuffer !== 'undefined' && isArrayBufferToString(new ArrayBuffer());
                function isArrayBuffer(value) {
                    if (typeof ArrayBuffer === 'undefined') {
                        return false;
                    }
                    return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
                }
                exports1.isArrayBuffer = isArrayBuffer;
                function isDataViewToString(value) {
                    return ObjectToString(value) === '[object DataView]';
                }
                isDataViewToString.working = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined' && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
                function isDataView(value) {
                    if (typeof DataView === 'undefined') {
                        return false;
                    }
                    return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
                }
                exports1.isDataView = isDataView;
                // Store a copy of SharedArrayBuffer in case it's deleted elsewhere
                var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;
                function isSharedArrayBufferToString(value) {
                    return ObjectToString(value) === '[object SharedArrayBuffer]';
                }
                function isSharedArrayBuffer(value) {
                    if (typeof SharedArrayBufferCopy === 'undefined') {
                        return false;
                    }
                    if (typeof isSharedArrayBufferToString.working === 'undefined') {
                        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
                    }
                    return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
                }
                exports1.isSharedArrayBuffer = isSharedArrayBuffer;
                function isAsyncFunction(value) {
                    return ObjectToString(value) === '[object AsyncFunction]';
                }
                exports1.isAsyncFunction = isAsyncFunction;
                function isMapIterator(value) {
                    return ObjectToString(value) === '[object Map Iterator]';
                }
                exports1.isMapIterator = isMapIterator;
                function isSetIterator(value) {
                    return ObjectToString(value) === '[object Set Iterator]';
                }
                exports1.isSetIterator = isSetIterator;
                function isGeneratorObject(value) {
                    return ObjectToString(value) === '[object Generator]';
                }
                exports1.isGeneratorObject = isGeneratorObject;
                function isWebAssemblyCompiledModule(value) {
                    return ObjectToString(value) === '[object WebAssembly.Module]';
                }
                exports1.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
                function isNumberObject(value) {
                    return checkBoxedPrimitive(value, numberValue);
                }
                exports1.isNumberObject = isNumberObject;
                function isStringObject(value) {
                    return checkBoxedPrimitive(value, stringValue);
                }
                exports1.isStringObject = isStringObject;
                function isBooleanObject(value) {
                    return checkBoxedPrimitive(value, booleanValue);
                }
                exports1.isBooleanObject = isBooleanObject;
                function isBigIntObject(value) {
                    return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
                }
                exports1.isBigIntObject = isBigIntObject;
                function isSymbolObject(value) {
                    return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
                }
                exports1.isSymbolObject = isSymbolObject;
                function isBoxedPrimitive(value) {
                    return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
                }
                exports1.isBoxedPrimitive = isBoxedPrimitive;
                function isAnyArrayBuffer(value) {
                    return typeof Uint8Array !== 'undefined' && (isArrayBuffer(value) || isSharedArrayBuffer(value));
                }
                exports1.isAnyArrayBuffer = isAnyArrayBuffer;
                [
                    'isProxy',
                    'isExternal',
                    'isModuleNamespaceObject'
                ].forEach(function(method) {
                    Object.defineProperty(exports1, method, {
                        enumerable: false,
                        value: function() {
                            throw new Error(method + ' is not supported in userland');
                        }
                    });
                });
            /***/ },
            /***/ 6827: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_224133__)=>{
                /* provided dependency */ var process = __nested_webpack_require_224133__(9907);
                /* provided dependency */ var console = __nested_webpack_require_224133__(4364);
                // Copyright Joyent, Inc. and other Node contributors.
                //
                // Permission is hereby granted, free of charge, to any person obtaining a
                // copy of this software and associated documentation files (the
                // "Software"), to deal in the Software without restriction, including
                // without limitation the rights to use, copy, modify, merge, publish,
                // distribute, sublicense, and/or sell copies of the Software, and to permit
                // persons to whom the Software is furnished to do so, subject to the
                // following conditions:
                //
                // The above copyright notice and this permission notice shall be included
                // in all copies or substantial portions of the Software.
                //
                // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
                // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
                // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
                // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
                // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
                // USE OR OTHER DEALINGS IN THE SOFTWARE.
                var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {
                    var keys = Object.keys(obj);
                    var descriptors = {};
                    for(var i = 0; i < keys.length; i++){
                        descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
                    }
                    return descriptors;
                };
                var formatRegExp = /%[sdj%]/g;
                exports1.format = function(f) {
                    if (!isString(f)) {
                        var objects = [];
                        for(var i = 0; i < arguments.length; i++){
                            objects.push(inspect(arguments[i]));
                        }
                        return objects.join(' ');
                    }
                    var i = 1;
                    var args = arguments;
                    var len = args.length;
                    var str = String(f).replace(formatRegExp, function(x) {
                        if (x === '%%') return '%';
                        if (i >= len) return x;
                        switch(x){
                            case '%s':
                                return String(args[i++]);
                            case '%d':
                                return Number(args[i++]);
                            case '%j':
                                try {
                                    return JSON.stringify(args[i++]);
                                } catch (_) {
                                    return '[Circular]';
                                }
                            default:
                                return x;
                        }
                    });
                    for(var x = args[i]; i < len; x = args[++i]){
                        if (isNull(x) || !isObject(x)) {
                            str += ' ' + x;
                        } else {
                            str += ' ' + inspect(x);
                        }
                    }
                    return str;
                };
                // Mark that a method should not be used.
                // Returns a modified function which warns once by default.
                // If --no-deprecation is set, then it is a no-op.
                exports1.deprecate = function(fn, msg) {
                    if (typeof process !== 'undefined' && process.noDeprecation === true) {
                        return fn;
                    }
                    // Allow for deprecating things in the process of starting up.
                    if (typeof process === 'undefined') {
                        return function() {
                            return exports1.deprecate(fn, msg).apply(this, arguments);
                        };
                    }
                    var warned = false;
                    function deprecated() {
                        if (!warned) {
                            if (process.throwDeprecation) {
                                throw new Error(msg);
                            } else if (process.traceDeprecation) {
                                console.trace(msg);
                            } else {
                                console.error(msg);
                            }
                            warned = true;
                        }
                        return fn.apply(this, arguments);
                    }
                    return deprecated;
                };
                var debugs = {};
                var debugEnvRegex = /^$/;
                if (process.env.NODE_DEBUG) {
                    var debugEnv = process.env.NODE_DEBUG;
                    debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&').replace(/\*/g, '.*').replace(/,/g, '$|^').toUpperCase();
                    debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
                }
                exports1.debuglog = function(set) {
                    set = set.toUpperCase();
                    if (!debugs[set]) {
                        if (debugEnvRegex.test(set)) {
                            var pid = process.pid;
                            debugs[set] = function() {
                                var msg = exports1.format.apply(exports1, arguments);
                                console.error('%s %d: %s', set, pid, msg);
                            };
                        } else {
                            debugs[set] = function() {};
                        }
                    }
                    return debugs[set];
                };
                /**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */ /* legacy: obj, showHidden, depth, colors*/ function inspect(obj, opts) {
                    // default options
                    var ctx = {
                        seen: [],
                        stylize: stylizeNoColor
                    };
                    // legacy...
                    if (arguments.length >= 3) ctx.depth = arguments[2];
                    if (arguments.length >= 4) ctx.colors = arguments[3];
                    if (isBoolean(opts)) {
                        // legacy...
                        ctx.showHidden = opts;
                    } else if (opts) {
                        // got an "options" object
                        exports1._extend(ctx, opts);
                    }
                    // set default options
                    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
                    if (isUndefined(ctx.depth)) ctx.depth = 2;
                    if (isUndefined(ctx.colors)) ctx.colors = false;
                    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
                    if (ctx.colors) ctx.stylize = stylizeWithColor;
                    return formatValue(ctx, obj, ctx.depth);
                }
                exports1.inspect = inspect;
                // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
                inspect.colors = {
                    'bold': [
                        1,
                        22
                    ],
                    'italic': [
                        3,
                        23
                    ],
                    'underline': [
                        4,
                        24
                    ],
                    'inverse': [
                        7,
                        27
                    ],
                    'white': [
                        37,
                        39
                    ],
                    'grey': [
                        90,
                        39
                    ],
                    'black': [
                        30,
                        39
                    ],
                    'blue': [
                        34,
                        39
                    ],
                    'cyan': [
                        36,
                        39
                    ],
                    'green': [
                        32,
                        39
                    ],
                    'magenta': [
                        35,
                        39
                    ],
                    'red': [
                        31,
                        39
                    ],
                    'yellow': [
                        33,
                        39
                    ]
                };
                // Don't use 'blue' not visible on cmd.exe
                inspect.styles = {
                    'special': 'cyan',
                    'number': 'yellow',
                    'boolean': 'yellow',
                    'undefined': 'grey',
                    'null': 'bold',
                    'string': 'green',
                    'date': 'magenta',
                    // "name": intentionally not styling
                    'regexp': 'red'
                };
                function stylizeWithColor(str, styleType) {
                    var style = inspect.styles[styleType];
                    if (style) {
                        return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
                    } else {
                        return str;
                    }
                }
                function stylizeNoColor(str, styleType) {
                    return str;
                }
                function arrayToHash(array) {
                    var hash = {};
                    array.forEach(function(val, idx) {
                        hash[val] = true;
                    });
                    return hash;
                }
                function formatValue(ctx, value, recurseTimes) {
                    // Provide a hook for user-specified inspect functions.
                    // Check that value is an object with an inspect function on it
                    if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
                    value.inspect !== exports1.inspect && // Also filter out any prototype objects using the circular check.
                    !(value.constructor && value.constructor.prototype === value)) {
                        var ret = value.inspect(recurseTimes, ctx);
                        if (!isString(ret)) {
                            ret = formatValue(ctx, ret, recurseTimes);
                        }
                        return ret;
                    }
                    // Primitive types cannot have properties
                    var primitive = formatPrimitive(ctx, value);
                    if (primitive) {
                        return primitive;
                    }
                    // Look up the keys of the object.
                    var keys = Object.keys(value);
                    var visibleKeys = arrayToHash(keys);
                    if (ctx.showHidden) {
                        keys = Object.getOwnPropertyNames(value);
                    }
                    // IE doesn't make error fields non-enumerable
                    // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
                    if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
                        return formatError(value);
                    }
                    // Some type of object without properties can be shortcutted.
                    if (keys.length === 0) {
                        if (isFunction(value)) {
                            var name = value.name ? ': ' + value.name : '';
                            return ctx.stylize('[Function' + name + ']', 'special');
                        }
                        if (isRegExp(value)) {
                            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                        }
                        if (isDate(value)) {
                            return ctx.stylize(Date.prototype.toString.call(value), 'date');
                        }
                        if (isError(value)) {
                            return formatError(value);
                        }
                    }
                    var base = '', array = false, braces = [
                        '{',
                        '}'
                    ];
                    // Make Array say that they are Array
                    if (isArray(value)) {
                        array = true;
                        braces = [
                            '[',
                            ']'
                        ];
                    }
                    // Make functions say that they are functions
                    if (isFunction(value)) {
                        var n = value.name ? ': ' + value.name : '';
                        base = ' [Function' + n + ']';
                    }
                    // Make RegExps say that they are RegExps
                    if (isRegExp(value)) {
                        base = ' ' + RegExp.prototype.toString.call(value);
                    }
                    // Make dates with properties first say the date
                    if (isDate(value)) {
                        base = ' ' + Date.prototype.toUTCString.call(value);
                    }
                    // Make error with message first say the error
                    if (isError(value)) {
                        base = ' ' + formatError(value);
                    }
                    if (keys.length === 0 && (!array || value.length == 0)) {
                        return braces[0] + base + braces[1];
                    }
                    if (recurseTimes < 0) {
                        if (isRegExp(value)) {
                            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                        } else {
                            return ctx.stylize('[Object]', 'special');
                        }
                    }
                    ctx.seen.push(value);
                    var output;
                    if (array) {
                        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
                    } else {
                        output = keys.map(function(key) {
                            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                        });
                    }
                    ctx.seen.pop();
                    return reduceToSingleString(output, base, braces);
                }
                function formatPrimitive(ctx, value) {
                    if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
                    if (isString(value)) {
                        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
                        return ctx.stylize(simple, 'string');
                    }
                    if (isNumber(value)) return ctx.stylize('' + value, 'number');
                    if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
                    // For some reason typeof null is "object", so special case here.
                    if (isNull(value)) return ctx.stylize('null', 'null');
                }
                function formatError(value) {
                    return '[' + Error.prototype.toString.call(value) + ']';
                }
                function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
                    var output = [];
                    for(var i = 0, l = value.length; i < l; ++i){
                        if (hasOwnProperty(value, String(i))) {
                            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
                        } else {
                            output.push('');
                        }
                    }
                    keys.forEach(function(key) {
                        if (!key.match(/^\d+$/)) {
                            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
                        }
                    });
                    return output;
                }
                function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
                    var name, str, desc;
                    desc = Object.getOwnPropertyDescriptor(value, key) || {
                        value: value[key]
                    };
                    if (desc.get) {
                        if (desc.set) {
                            str = ctx.stylize('[Getter/Setter]', 'special');
                        } else {
                            str = ctx.stylize('[Getter]', 'special');
                        }
                    } else {
                        if (desc.set) {
                            str = ctx.stylize('[Setter]', 'special');
                        }
                    }
                    if (!hasOwnProperty(visibleKeys, key)) {
                        name = '[' + key + ']';
                    }
                    if (!str) {
                        if (ctx.seen.indexOf(desc.value) < 0) {
                            if (isNull(recurseTimes)) {
                                str = formatValue(ctx, desc.value, null);
                            } else {
                                str = formatValue(ctx, desc.value, recurseTimes - 1);
                            }
                            if (str.indexOf('\n') > -1) {
                                if (array) {
                                    str = str.split('\n').map(function(line) {
                                        return '  ' + line;
                                    }).join('\n').slice(2);
                                } else {
                                    str = '\n' + str.split('\n').map(function(line) {
                                        return '   ' + line;
                                    }).join('\n');
                                }
                            }
                        } else {
                            str = ctx.stylize('[Circular]', 'special');
                        }
                    }
                    if (isUndefined(name)) {
                        if (array && key.match(/^\d+$/)) {
                            return str;
                        }
                        name = JSON.stringify('' + key);
                        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                            name = name.slice(1, -1);
                            name = ctx.stylize(name, 'name');
                        } else {
                            name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                            name = ctx.stylize(name, 'string');
                        }
                    }
                    return name + ': ' + str;
                }
                function reduceToSingleString(output, base, braces) {
                    var numLinesEst = 0;
                    var length = output.reduce(function(prev, cur) {
                        numLinesEst++;
                        if (cur.indexOf('\n') >= 0) numLinesEst++;
                        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
                    }, 0);
                    if (length > 60) {
                        return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
                    }
                    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
                }
                // NOTE: These type checking functions intentionally don't use `instanceof`
                // because it is fragile and can be easily faked with `Object.create()`.
                exports1.types = __nested_webpack_require_224133__(1531);
                function isArray(ar) {
                    return Array.isArray(ar);
                }
                exports1.isArray = isArray;
                function isBoolean(arg) {
                    return typeof arg === 'boolean';
                }
                exports1.isBoolean = isBoolean;
                function isNull(arg) {
                    return arg === null;
                }
                exports1.isNull = isNull;
                function isNullOrUndefined(arg) {
                    return arg == null;
                }
                exports1.isNullOrUndefined = isNullOrUndefined;
                function isNumber(arg) {
                    return typeof arg === 'number';
                }
                exports1.isNumber = isNumber;
                function isString(arg) {
                    return typeof arg === 'string';
                }
                exports1.isString = isString;
                function isSymbol(arg) {
                    return typeof arg === 'symbol';
                }
                exports1.isSymbol = isSymbol;
                function isUndefined(arg) {
                    return arg === void 0;
                }
                exports1.isUndefined = isUndefined;
                function isRegExp(re) {
                    return isObject(re) && objectToString(re) === '[object RegExp]';
                }
                exports1.isRegExp = isRegExp;
                exports1.types.isRegExp = isRegExp;
                function isObject(arg) {
                    return typeof arg === 'object' && arg !== null;
                }
                exports1.isObject = isObject;
                function isDate(d) {
                    return isObject(d) && objectToString(d) === '[object Date]';
                }
                exports1.isDate = isDate;
                exports1.types.isDate = isDate;
                function isError(e) {
                    return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
                }
                exports1.isError = isError;
                exports1.types.isNativeError = isError;
                function isFunction(arg) {
                    return typeof arg === 'function';
                }
                exports1.isFunction = isFunction;
                function isPrimitive(arg) {
                    return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
                    typeof arg === 'undefined';
                }
                exports1.isPrimitive = isPrimitive;
                exports1.isBuffer = __nested_webpack_require_224133__(5272);
                function objectToString(o) {
                    return Object.prototype.toString.call(o);
                }
                function pad(n) {
                    return n < 10 ? '0' + n.toString(10) : n.toString(10);
                }
                var months = [
                    'Jan',
                    'Feb',
                    'Mar',
                    'Apr',
                    'May',
                    'Jun',
                    'Jul',
                    'Aug',
                    'Sep',
                    'Oct',
                    'Nov',
                    'Dec'
                ];
                // 26 Feb 16:19:34
                function timestamp() {
                    var d = new Date();
                    var time = [
                        pad(d.getHours()),
                        pad(d.getMinutes()),
                        pad(d.getSeconds())
                    ].join(':');
                    return [
                        d.getDate(),
                        months[d.getMonth()],
                        time
                    ].join(' ');
                }
                // log is just a thin wrapper to console.log that prepends a timestamp
                exports1.log = function() {
                    console.log('%s - %s', timestamp(), exports1.format.apply(exports1, arguments));
                };
                /**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */ exports1.inherits = __nested_webpack_require_224133__(5615);
                exports1._extend = function(origin, add) {
                    // Don't do anything if add isn't an object
                    if (!add || !isObject(add)) return origin;
                    var keys = Object.keys(add);
                    var i = keys.length;
                    while(i--){
                        origin[keys[i]] = add[keys[i]];
                    }
                    return origin;
                };
                function hasOwnProperty(obj, prop) {
                    return Object.prototype.hasOwnProperty.call(obj, prop);
                }
                var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;
                exports1.promisify = function promisify(original) {
                    if (typeof original !== 'function') throw new TypeError('The "original" argument must be of type Function');
                    if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
                        var fn = original[kCustomPromisifiedSymbol];
                        if (typeof fn !== 'function') {
                            throw new TypeError('The "util.promisify.custom" argument must be of type Function');
                        }
                        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                            value: fn,
                            enumerable: false,
                            writable: false,
                            configurable: true
                        });
                        return fn;
                    }
                    function fn() {
                        var promiseResolve, promiseReject;
                        var promise = new Promise(function(resolve, reject) {
                            promiseResolve = resolve;
                            promiseReject = reject;
                        });
                        var args = [];
                        for(var i = 0; i < arguments.length; i++){
                            args.push(arguments[i]);
                        }
                        args.push(function(err, value) {
                            if (err) {
                                promiseReject(err);
                            } else {
                                promiseResolve(value);
                            }
                        });
                        try {
                            original.apply(this, args);
                        } catch (err) {
                            promiseReject(err);
                        }
                        return promise;
                    }
                    Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
                    if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                        value: fn,
                        enumerable: false,
                        writable: false,
                        configurable: true
                    });
                    return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
                };
                exports1.promisify.custom = kCustomPromisifiedSymbol;
                function callbackifyOnRejected(reason, cb) {
                    // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
                    // Because `null` is a special error value in callbacks which means "no error
                    // occurred", we error-wrap so the callback consumer can distinguish between
                    // "the promise rejected with null" or "the promise fulfilled with undefined".
                    if (!reason) {
                        var newReason = new Error('Promise was rejected with a falsy value');
                        newReason.reason = reason;
                        reason = newReason;
                    }
                    return cb(reason);
                }
                function callbackify(original) {
                    if (typeof original !== 'function') {
                        throw new TypeError('The "original" argument must be of type Function');
                    }
                    // We DO NOT return the promise as it gives the user a false sense that
                    // the promise is actually somehow related to the callback's execution
                    // and that the callback throwing will reject the promise.
                    function callbackified() {
                        var args = [];
                        for(var i = 0; i < arguments.length; i++){
                            args.push(arguments[i]);
                        }
                        var maybeCb = args.pop();
                        if (typeof maybeCb !== 'function') {
                            throw new TypeError('The last argument must be of type Function');
                        }
                        var self = this;
                        var cb = function() {
                            return maybeCb.apply(self, arguments);
                        };
                        // In true node style we process the callback on `nextTick` with all the
                        // implications (stack, `uncaughtException`, `async_hooks`)
                        original.apply(this, args).then(function(ret) {
                            process.nextTick(cb.bind(null, null, ret));
                        }, function(rej) {
                            process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
                        });
                    }
                    Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
                    Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
                    return callbackified;
                }
                exports1.callbackify = callbackify;
            /***/ },
            /***/ 9208: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_255731__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */ module1.exports = __nested_webpack_require_255731__(9110);
            /***/ },
            /***/ 9110: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_256290__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    var desc = Object.getOwnPropertyDescriptor(m, k);
                    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                        desc = {
                            enumerable: true,
                            get: function() {
                                return m[k];
                            }
                        };
                    }
                    Object.defineProperty(o, k2, desc);
                } : function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    o[k2] = m[k];
                });
                var __exportStar = this && this.__exportStar || function(m, exports1) {
                    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
                };
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createMessageConnection = exports1.BrowserMessageWriter = exports1.BrowserMessageReader = void 0;
                const ril_1 = __nested_webpack_require_256290__(3312);
                // Install the browser runtime abstract.
                ril_1.default.install();
                const api_1 = __nested_webpack_require_256290__(7672);
                __exportStar(__nested_webpack_require_256290__(7672), exports1);
                class BrowserMessageReader extends api_1.AbstractMessageReader {
                    listen(callback) {
                        return this._onData.event(callback);
                    }
                    constructor(port){
                        super();
                        this._onData = new api_1.Emitter();
                        this._messageListener = (event)=>{
                            this._onData.fire(event.data);
                        };
                        port.addEventListener('error', (event)=>this.fireError(event));
                        port.onmessage = this._messageListener;
                    }
                }
                exports1.BrowserMessageReader = BrowserMessageReader;
                class BrowserMessageWriter extends api_1.AbstractMessageWriter {
                    write(msg) {
                        try {
                            this.port.postMessage(msg);
                            return Promise.resolve();
                        } catch (error) {
                            this.handleError(error, msg);
                            return Promise.reject(error);
                        }
                    }
                    handleError(error, msg) {
                        this.errorCount++;
                        this.fireError(error, msg, this.errorCount);
                    }
                    end() {}
                    constructor(port){
                        super();
                        this.port = port;
                        this.errorCount = 0;
                        port.addEventListener('error', (event)=>this.fireError(event));
                    }
                }
                exports1.BrowserMessageWriter = BrowserMessageWriter;
                function createMessageConnection(reader, writer, logger, options) {
                    if (logger === undefined) {
                        logger = api_1.NullLogger;
                    }
                    if (api_1.ConnectionStrategy.is(options)) {
                        options = {
                            connectionStrategy: options
                        };
                    }
                    return (0, api_1.createMessageConnection)(reader, writer, logger, options);
                }
                exports1.createMessageConnection = createMessageConnection;
            /***/ },
            /***/ 3312: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_260705__)=>{
                "use strict";
                /* provided dependency */ var console = __nested_webpack_require_260705__(4364);
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                const api_1 = __nested_webpack_require_260705__(7672);
                class MessageBuffer extends api_1.AbstractMessageBuffer {
                    emptyBuffer() {
                        return MessageBuffer.emptyBuffer;
                    }
                    fromString(value, _encoding) {
                        return new TextEncoder().encode(value);
                    }
                    toString(value, encoding) {
                        if (encoding === 'ascii') {
                            return this.asciiDecoder.decode(value);
                        } else {
                            return new TextDecoder(encoding).decode(value);
                        }
                    }
                    asNative(buffer, length) {
                        if (length === undefined) {
                            return buffer;
                        } else {
                            return buffer.slice(0, length);
                        }
                    }
                    allocNative(length) {
                        return new Uint8Array(length);
                    }
                    constructor(encoding = 'utf-8'){
                        super(encoding);
                        this.asciiDecoder = new TextDecoder('ascii');
                    }
                }
                MessageBuffer.emptyBuffer = new Uint8Array(0);
                class ReadableStreamWrapper {
                    onClose(listener) {
                        this.socket.addEventListener('close', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('close', listener));
                    }
                    onError(listener) {
                        this.socket.addEventListener('error', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('error', listener));
                    }
                    onEnd(listener) {
                        this.socket.addEventListener('end', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('end', listener));
                    }
                    onData(listener) {
                        return this._onData.event(listener);
                    }
                    constructor(socket){
                        this.socket = socket;
                        this._onData = new api_1.Emitter();
                        this._messageListener = (event)=>{
                            const blob = event.data;
                            blob.arrayBuffer().then((buffer)=>{
                                this._onData.fire(new Uint8Array(buffer));
                            }, ()=>{
                                (0, api_1.RAL)().console.error(`Converting blob to array buffer failed.`);
                            });
                        };
                        this.socket.addEventListener('message', this._messageListener);
                    }
                }
                class WritableStreamWrapper {
                    onClose(listener) {
                        this.socket.addEventListener('close', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('close', listener));
                    }
                    onError(listener) {
                        this.socket.addEventListener('error', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('error', listener));
                    }
                    onEnd(listener) {
                        this.socket.addEventListener('end', listener);
                        return api_1.Disposable.create(()=>this.socket.removeEventListener('end', listener));
                    }
                    write(data, encoding) {
                        if (typeof data === 'string') {
                            if (encoding !== undefined && encoding !== 'utf-8') {
                                throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${encoding}`);
                            }
                            this.socket.send(data);
                        } else {
                            this.socket.send(data);
                        }
                        return Promise.resolve();
                    }
                    end() {
                        this.socket.close();
                    }
                    constructor(socket){
                        this.socket = socket;
                    }
                }
                const _textEncoder = new TextEncoder();
                const _ril = Object.freeze({
                    messageBuffer: Object.freeze({
                        create: (encoding)=>new MessageBuffer(encoding)
                    }),
                    applicationJson: Object.freeze({
                        encoder: Object.freeze({
                            name: 'application/json',
                            encode: (msg, options)=>{
                                if (options.charset !== 'utf-8') {
                                    throw new Error(`In a Browser environments only utf-8 text encoding is supported. But got encoding: ${options.charset}`);
                                }
                                return Promise.resolve(_textEncoder.encode(JSON.stringify(msg, undefined, 0)));
                            }
                        }),
                        decoder: Object.freeze({
                            name: 'application/json',
                            decode: (buffer, options)=>{
                                if (!(buffer instanceof Uint8Array)) {
                                    throw new Error(`In a Browser environments only Uint8Arrays are supported.`);
                                }
                                return Promise.resolve(JSON.parse(new TextDecoder(options.charset).decode(buffer)));
                            }
                        })
                    }),
                    stream: Object.freeze({
                        asReadableStream: (socket)=>new ReadableStreamWrapper(socket),
                        asWritableStream: (socket)=>new WritableStreamWrapper(socket)
                    }),
                    console: console,
                    timer: Object.freeze({
                        setTimeout (callback, ms, ...args) {
                            const handle = setTimeout(callback, ms, ...args);
                            return {
                                dispose: ()=>clearTimeout(handle)
                            };
                        },
                        setImmediate (callback, ...args) {
                            const handle = setTimeout(callback, 0, ...args);
                            return {
                                dispose: ()=>clearTimeout(handle)
                            };
                        },
                        setInterval (callback, ms, ...args) {
                            const handle = setInterval(callback, ms, ...args);
                            return {
                                dispose: ()=>clearInterval(handle)
                            };
                        }
                    })
                });
                function RIL() {
                    return _ril;
                }
                (function(RIL) {
                    function install() {
                        api_1.RAL.install(_ril);
                    }
                    RIL.install = install;
                })(RIL || (RIL = {}));
                exports1["default"] = RIL;
            /***/ },
            /***/ 7672: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_269084__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ /// <reference path="../../typings/thenable.d.ts" />
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ProgressType = exports1.ProgressToken = exports1.createMessageConnection = exports1.NullLogger = exports1.ConnectionOptions = exports1.ConnectionStrategy = exports1.AbstractMessageBuffer = exports1.WriteableStreamMessageWriter = exports1.AbstractMessageWriter = exports1.MessageWriter = exports1.ReadableStreamMessageReader = exports1.AbstractMessageReader = exports1.MessageReader = exports1.SharedArrayReceiverStrategy = exports1.SharedArraySenderStrategy = exports1.CancellationToken = exports1.CancellationTokenSource = exports1.Emitter = exports1.Event = exports1.Disposable = exports1.LRUCache = exports1.Touch = exports1.LinkedMap = exports1.ParameterStructures = exports1.NotificationType9 = exports1.NotificationType8 = exports1.NotificationType7 = exports1.NotificationType6 = exports1.NotificationType5 = exports1.NotificationType4 = exports1.NotificationType3 = exports1.NotificationType2 = exports1.NotificationType1 = exports1.NotificationType0 = exports1.NotificationType = exports1.ErrorCodes = exports1.ResponseError = exports1.RequestType9 = exports1.RequestType8 = exports1.RequestType7 = exports1.RequestType6 = exports1.RequestType5 = exports1.RequestType4 = exports1.RequestType3 = exports1.RequestType2 = exports1.RequestType1 = exports1.RequestType0 = exports1.RequestType = exports1.Message = exports1.RAL = void 0;
                exports1.MessageStrategy = exports1.CancellationStrategy = exports1.CancellationSenderStrategy = exports1.CancellationReceiverStrategy = exports1.ConnectionError = exports1.ConnectionErrors = exports1.LogTraceNotification = exports1.SetTraceNotification = exports1.TraceFormat = exports1.TraceValues = exports1.Trace = void 0;
                const messages_1 = __nested_webpack_require_269084__(7162);
                Object.defineProperty(exports1, "Message", {
                    enumerable: true,
                    get: function() {
                        return messages_1.Message;
                    }
                });
                Object.defineProperty(exports1, "RequestType", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType;
                    }
                });
                Object.defineProperty(exports1, "RequestType0", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType0;
                    }
                });
                Object.defineProperty(exports1, "RequestType1", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType1;
                    }
                });
                Object.defineProperty(exports1, "RequestType2", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType2;
                    }
                });
                Object.defineProperty(exports1, "RequestType3", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType3;
                    }
                });
                Object.defineProperty(exports1, "RequestType4", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType4;
                    }
                });
                Object.defineProperty(exports1, "RequestType5", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType5;
                    }
                });
                Object.defineProperty(exports1, "RequestType6", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType6;
                    }
                });
                Object.defineProperty(exports1, "RequestType7", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType7;
                    }
                });
                Object.defineProperty(exports1, "RequestType8", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType8;
                    }
                });
                Object.defineProperty(exports1, "RequestType9", {
                    enumerable: true,
                    get: function() {
                        return messages_1.RequestType9;
                    }
                });
                Object.defineProperty(exports1, "ResponseError", {
                    enumerable: true,
                    get: function() {
                        return messages_1.ResponseError;
                    }
                });
                Object.defineProperty(exports1, "ErrorCodes", {
                    enumerable: true,
                    get: function() {
                        return messages_1.ErrorCodes;
                    }
                });
                Object.defineProperty(exports1, "NotificationType", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType;
                    }
                });
                Object.defineProperty(exports1, "NotificationType0", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType0;
                    }
                });
                Object.defineProperty(exports1, "NotificationType1", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType1;
                    }
                });
                Object.defineProperty(exports1, "NotificationType2", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType2;
                    }
                });
                Object.defineProperty(exports1, "NotificationType3", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType3;
                    }
                });
                Object.defineProperty(exports1, "NotificationType4", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType4;
                    }
                });
                Object.defineProperty(exports1, "NotificationType5", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType5;
                    }
                });
                Object.defineProperty(exports1, "NotificationType6", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType6;
                    }
                });
                Object.defineProperty(exports1, "NotificationType7", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType7;
                    }
                });
                Object.defineProperty(exports1, "NotificationType8", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType8;
                    }
                });
                Object.defineProperty(exports1, "NotificationType9", {
                    enumerable: true,
                    get: function() {
                        return messages_1.NotificationType9;
                    }
                });
                Object.defineProperty(exports1, "ParameterStructures", {
                    enumerable: true,
                    get: function() {
                        return messages_1.ParameterStructures;
                    }
                });
                const linkedMap_1 = __nested_webpack_require_269084__(1109);
                Object.defineProperty(exports1, "LinkedMap", {
                    enumerable: true,
                    get: function() {
                        return linkedMap_1.LinkedMap;
                    }
                });
                Object.defineProperty(exports1, "LRUCache", {
                    enumerable: true,
                    get: function() {
                        return linkedMap_1.LRUCache;
                    }
                });
                Object.defineProperty(exports1, "Touch", {
                    enumerable: true,
                    get: function() {
                        return linkedMap_1.Touch;
                    }
                });
                const disposable_1 = __nested_webpack_require_269084__(8844);
                Object.defineProperty(exports1, "Disposable", {
                    enumerable: true,
                    get: function() {
                        return disposable_1.Disposable;
                    }
                });
                const events_1 = __nested_webpack_require_269084__(2479);
                Object.defineProperty(exports1, "Event", {
                    enumerable: true,
                    get: function() {
                        return events_1.Event;
                    }
                });
                Object.defineProperty(exports1, "Emitter", {
                    enumerable: true,
                    get: function() {
                        return events_1.Emitter;
                    }
                });
                const cancellation_1 = __nested_webpack_require_269084__(6957);
                Object.defineProperty(exports1, "CancellationTokenSource", {
                    enumerable: true,
                    get: function() {
                        return cancellation_1.CancellationTokenSource;
                    }
                });
                Object.defineProperty(exports1, "CancellationToken", {
                    enumerable: true,
                    get: function() {
                        return cancellation_1.CancellationToken;
                    }
                });
                const sharedArrayCancellation_1 = __nested_webpack_require_269084__(3489);
                Object.defineProperty(exports1, "SharedArraySenderStrategy", {
                    enumerable: true,
                    get: function() {
                        return sharedArrayCancellation_1.SharedArraySenderStrategy;
                    }
                });
                Object.defineProperty(exports1, "SharedArrayReceiverStrategy", {
                    enumerable: true,
                    get: function() {
                        return sharedArrayCancellation_1.SharedArrayReceiverStrategy;
                    }
                });
                const messageReader_1 = __nested_webpack_require_269084__(656);
                Object.defineProperty(exports1, "MessageReader", {
                    enumerable: true,
                    get: function() {
                        return messageReader_1.MessageReader;
                    }
                });
                Object.defineProperty(exports1, "AbstractMessageReader", {
                    enumerable: true,
                    get: function() {
                        return messageReader_1.AbstractMessageReader;
                    }
                });
                Object.defineProperty(exports1, "ReadableStreamMessageReader", {
                    enumerable: true,
                    get: function() {
                        return messageReader_1.ReadableStreamMessageReader;
                    }
                });
                const messageWriter_1 = __nested_webpack_require_269084__(9036);
                Object.defineProperty(exports1, "MessageWriter", {
                    enumerable: true,
                    get: function() {
                        return messageWriter_1.MessageWriter;
                    }
                });
                Object.defineProperty(exports1, "AbstractMessageWriter", {
                    enumerable: true,
                    get: function() {
                        return messageWriter_1.AbstractMessageWriter;
                    }
                });
                Object.defineProperty(exports1, "WriteableStreamMessageWriter", {
                    enumerable: true,
                    get: function() {
                        return messageWriter_1.WriteableStreamMessageWriter;
                    }
                });
                const messageBuffer_1 = __nested_webpack_require_269084__(9805);
                Object.defineProperty(exports1, "AbstractMessageBuffer", {
                    enumerable: true,
                    get: function() {
                        return messageBuffer_1.AbstractMessageBuffer;
                    }
                });
                const connection_1 = __nested_webpack_require_269084__(4054);
                Object.defineProperty(exports1, "ConnectionStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionStrategy;
                    }
                });
                Object.defineProperty(exports1, "ConnectionOptions", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionOptions;
                    }
                });
                Object.defineProperty(exports1, "NullLogger", {
                    enumerable: true,
                    get: function() {
                        return connection_1.NullLogger;
                    }
                });
                Object.defineProperty(exports1, "createMessageConnection", {
                    enumerable: true,
                    get: function() {
                        return connection_1.createMessageConnection;
                    }
                });
                Object.defineProperty(exports1, "ProgressToken", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ProgressToken;
                    }
                });
                Object.defineProperty(exports1, "ProgressType", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ProgressType;
                    }
                });
                Object.defineProperty(exports1, "Trace", {
                    enumerable: true,
                    get: function() {
                        return connection_1.Trace;
                    }
                });
                Object.defineProperty(exports1, "TraceValues", {
                    enumerable: true,
                    get: function() {
                        return connection_1.TraceValues;
                    }
                });
                Object.defineProperty(exports1, "TraceFormat", {
                    enumerable: true,
                    get: function() {
                        return connection_1.TraceFormat;
                    }
                });
                Object.defineProperty(exports1, "SetTraceNotification", {
                    enumerable: true,
                    get: function() {
                        return connection_1.SetTraceNotification;
                    }
                });
                Object.defineProperty(exports1, "LogTraceNotification", {
                    enumerable: true,
                    get: function() {
                        return connection_1.LogTraceNotification;
                    }
                });
                Object.defineProperty(exports1, "ConnectionErrors", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionErrors;
                    }
                });
                Object.defineProperty(exports1, "ConnectionError", {
                    enumerable: true,
                    get: function() {
                        return connection_1.ConnectionError;
                    }
                });
                Object.defineProperty(exports1, "CancellationReceiverStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.CancellationReceiverStrategy;
                    }
                });
                Object.defineProperty(exports1, "CancellationSenderStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.CancellationSenderStrategy;
                    }
                });
                Object.defineProperty(exports1, "CancellationStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.CancellationStrategy;
                    }
                });
                Object.defineProperty(exports1, "MessageStrategy", {
                    enumerable: true,
                    get: function() {
                        return connection_1.MessageStrategy;
                    }
                });
                const ral_1 = __nested_webpack_require_269084__(5091);
                exports1.RAL = ral_1.default;
            /***/ },
            /***/ 6957: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_287148__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.CancellationTokenSource = exports1.CancellationToken = void 0;
                const ral_1 = __nested_webpack_require_287148__(5091);
                const Is = __nested_webpack_require_287148__(6618);
                const events_1 = __nested_webpack_require_287148__(2479);
                var CancellationToken;
                (function(CancellationToken) {
                    CancellationToken.None = Object.freeze({
                        isCancellationRequested: false,
                        onCancellationRequested: events_1.Event.None
                    });
                    CancellationToken.Cancelled = Object.freeze({
                        isCancellationRequested: true,
                        onCancellationRequested: events_1.Event.None
                    });
                    function is(value) {
                        const candidate = value;
                        return candidate && (candidate === CancellationToken.None || candidate === CancellationToken.Cancelled || Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
                    }
                    CancellationToken.is = is;
                })(CancellationToken = exports1.CancellationToken || (exports1.CancellationToken = {}));
                const shortcutEvent = Object.freeze(function(callback, context) {
                    const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
                    return {
                        dispose () {
                            handle.dispose();
                        }
                    };
                });
                class MutableToken {
                    cancel() {
                        if (!this._isCancelled) {
                            this._isCancelled = true;
                            if (this._emitter) {
                                this._emitter.fire(undefined);
                                this.dispose();
                            }
                        }
                    }
                    get isCancellationRequested() {
                        return this._isCancelled;
                    }
                    get onCancellationRequested() {
                        if (this._isCancelled) {
                            return shortcutEvent;
                        }
                        if (!this._emitter) {
                            this._emitter = new events_1.Emitter();
                        }
                        return this._emitter.event;
                    }
                    dispose() {
                        if (this._emitter) {
                            this._emitter.dispose();
                            this._emitter = undefined;
                        }
                    }
                    constructor(){
                        this._isCancelled = false;
                    }
                }
                class CancellationTokenSource {
                    get token() {
                        if (!this._token) {
                            // be lazy and create the token only when
                            // actually needed
                            this._token = new MutableToken();
                        }
                        return this._token;
                    }
                    cancel() {
                        if (!this._token) {
                            // save an object by returning the default
                            // cancelled token when cancellation happens
                            // before someone asks for the token
                            this._token = CancellationToken.Cancelled;
                        } else {
                            this._token.cancel();
                        }
                    }
                    dispose() {
                        if (!this._token) {
                            // ensure to initialize with an empty token if we had none
                            this._token = CancellationToken.None;
                        } else if (this._token instanceof MutableToken) {
                            // actually dispose
                            this._token.dispose();
                        }
                    }
                }
                exports1.CancellationTokenSource = CancellationTokenSource;
            /***/ },
            /***/ 4054: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_292082__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createMessageConnection = exports1.ConnectionOptions = exports1.MessageStrategy = exports1.CancellationStrategy = exports1.CancellationSenderStrategy = exports1.CancellationReceiverStrategy = exports1.RequestCancellationReceiverStrategy = exports1.IdCancellationReceiverStrategy = exports1.ConnectionStrategy = exports1.ConnectionError = exports1.ConnectionErrors = exports1.LogTraceNotification = exports1.SetTraceNotification = exports1.TraceFormat = exports1.TraceValues = exports1.Trace = exports1.NullLogger = exports1.ProgressType = exports1.ProgressToken = void 0;
                const ral_1 = __nested_webpack_require_292082__(5091);
                const Is = __nested_webpack_require_292082__(6618);
                const messages_1 = __nested_webpack_require_292082__(7162);
                const linkedMap_1 = __nested_webpack_require_292082__(1109);
                const events_1 = __nested_webpack_require_292082__(2479);
                const cancellation_1 = __nested_webpack_require_292082__(6957);
                var CancelNotification;
                (function(CancelNotification) {
                    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');
                })(CancelNotification || (CancelNotification = {}));
                var ProgressToken;
                (function(ProgressToken) {
                    function is(value) {
                        return typeof value === 'string' || typeof value === 'number';
                    }
                    ProgressToken.is = is;
                })(ProgressToken = exports1.ProgressToken || (exports1.ProgressToken = {}));
                var ProgressNotification;
                (function(ProgressNotification) {
                    ProgressNotification.type = new messages_1.NotificationType('$/progress');
                })(ProgressNotification || (ProgressNotification = {}));
                class ProgressType {
                    constructor(){}
                }
                exports1.ProgressType = ProgressType;
                var StarRequestHandler;
                (function(StarRequestHandler) {
                    function is(value) {
                        return Is.func(value);
                    }
                    StarRequestHandler.is = is;
                })(StarRequestHandler || (StarRequestHandler = {}));
                exports1.NullLogger = Object.freeze({
                    error: ()=>{},
                    warn: ()=>{},
                    info: ()=>{},
                    log: ()=>{}
                });
                var Trace;
                (function(Trace) {
                    Trace[Trace["Off"] = 0] = "Off";
                    Trace[Trace["Messages"] = 1] = "Messages";
                    Trace[Trace["Compact"] = 2] = "Compact";
                    Trace[Trace["Verbose"] = 3] = "Verbose";
                })(Trace = exports1.Trace || (exports1.Trace = {}));
                var TraceValues;
                (function(TraceValues) {
                    /**
     * Turn tracing off.
     */ TraceValues.Off = 'off';
                    /**
     * Trace messages only.
     */ TraceValues.Messages = 'messages';
                    /**
     * Compact message tracing.
     */ TraceValues.Compact = 'compact';
                    /**
     * Verbose message tracing.
     */ TraceValues.Verbose = 'verbose';
                })(TraceValues = exports1.TraceValues || (exports1.TraceValues = {}));
                (function(Trace) {
                    function fromString(value) {
                        if (!Is.string(value)) {
                            return Trace.Off;
                        }
                        value = value.toLowerCase();
                        switch(value){
                            case 'off':
                                return Trace.Off;
                            case 'messages':
                                return Trace.Messages;
                            case 'compact':
                                return Trace.Compact;
                            case 'verbose':
                                return Trace.Verbose;
                            default:
                                return Trace.Off;
                        }
                    }
                    Trace.fromString = fromString;
                    function toString(value) {
                        switch(value){
                            case Trace.Off:
                                return 'off';
                            case Trace.Messages:
                                return 'messages';
                            case Trace.Compact:
                                return 'compact';
                            case Trace.Verbose:
                                return 'verbose';
                            default:
                                return 'off';
                        }
                    }
                    Trace.toString = toString;
                })(Trace = exports1.Trace || (exports1.Trace = {}));
                var TraceFormat;
                (function(TraceFormat) {
                    TraceFormat["Text"] = "text";
                    TraceFormat["JSON"] = "json";
                })(TraceFormat = exports1.TraceFormat || (exports1.TraceFormat = {}));
                (function(TraceFormat) {
                    function fromString(value) {
                        if (!Is.string(value)) {
                            return TraceFormat.Text;
                        }
                        value = value.toLowerCase();
                        if (value === 'json') {
                            return TraceFormat.JSON;
                        } else {
                            return TraceFormat.Text;
                        }
                    }
                    TraceFormat.fromString = fromString;
                })(TraceFormat = exports1.TraceFormat || (exports1.TraceFormat = {}));
                var SetTraceNotification;
                (function(SetTraceNotification) {
                    SetTraceNotification.type = new messages_1.NotificationType('$/setTrace');
                })(SetTraceNotification = exports1.SetTraceNotification || (exports1.SetTraceNotification = {}));
                var LogTraceNotification;
                (function(LogTraceNotification) {
                    LogTraceNotification.type = new messages_1.NotificationType('$/logTrace');
                })(LogTraceNotification = exports1.LogTraceNotification || (exports1.LogTraceNotification = {}));
                var ConnectionErrors;
                (function(ConnectionErrors) {
                    /**
     * The connection is closed.
     */ ConnectionErrors[ConnectionErrors["Closed"] = 1] = "Closed";
                    /**
     * The connection got disposed.
     */ ConnectionErrors[ConnectionErrors["Disposed"] = 2] = "Disposed";
                    /**
     * The connection is already in listening mode.
     */ ConnectionErrors[ConnectionErrors["AlreadyListening"] = 3] = "AlreadyListening";
                })(ConnectionErrors = exports1.ConnectionErrors || (exports1.ConnectionErrors = {}));
                class ConnectionError extends Error {
                    constructor(code, message){
                        super(message);
                        this.code = code;
                        Object.setPrototypeOf(this, ConnectionError.prototype);
                    }
                }
                exports1.ConnectionError = ConnectionError;
                var ConnectionStrategy;
                (function(ConnectionStrategy) {
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.func(candidate.cancelUndispatched);
                    }
                    ConnectionStrategy.is = is;
                })(ConnectionStrategy = exports1.ConnectionStrategy || (exports1.ConnectionStrategy = {}));
                var IdCancellationReceiverStrategy;
                (function(IdCancellationReceiverStrategy) {
                    function is(value) {
                        const candidate = value;
                        return candidate && (candidate.kind === undefined || candidate.kind === 'id') && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));
                    }
                    IdCancellationReceiverStrategy.is = is;
                })(IdCancellationReceiverStrategy = exports1.IdCancellationReceiverStrategy || (exports1.IdCancellationReceiverStrategy = {}));
                var RequestCancellationReceiverStrategy;
                (function(RequestCancellationReceiverStrategy) {
                    function is(value) {
                        const candidate = value;
                        return candidate && candidate.kind === 'request' && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));
                    }
                    RequestCancellationReceiverStrategy.is = is;
                })(RequestCancellationReceiverStrategy = exports1.RequestCancellationReceiverStrategy || (exports1.RequestCancellationReceiverStrategy = {}));
                var CancellationReceiverStrategy;
                (function(CancellationReceiverStrategy) {
                    CancellationReceiverStrategy.Message = Object.freeze({
                        createCancellationTokenSource (_) {
                            return new cancellation_1.CancellationTokenSource();
                        }
                    });
                    function is(value) {
                        return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);
                    }
                    CancellationReceiverStrategy.is = is;
                })(CancellationReceiverStrategy = exports1.CancellationReceiverStrategy || (exports1.CancellationReceiverStrategy = {}));
                var CancellationSenderStrategy;
                (function(CancellationSenderStrategy) {
                    CancellationSenderStrategy.Message = Object.freeze({
                        sendCancellation (conn, id) {
                            return conn.sendNotification(CancelNotification.type, {
                                id
                            });
                        },
                        cleanup (_) {}
                    });
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
                    }
                    CancellationSenderStrategy.is = is;
                })(CancellationSenderStrategy = exports1.CancellationSenderStrategy || (exports1.CancellationSenderStrategy = {}));
                var CancellationStrategy;
                (function(CancellationStrategy) {
                    CancellationStrategy.Message = Object.freeze({
                        receiver: CancellationReceiverStrategy.Message,
                        sender: CancellationSenderStrategy.Message
                    });
                    function is(value) {
                        const candidate = value;
                        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
                    }
                    CancellationStrategy.is = is;
                })(CancellationStrategy = exports1.CancellationStrategy || (exports1.CancellationStrategy = {}));
                var MessageStrategy;
                (function(MessageStrategy) {
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.func(candidate.handleMessage);
                    }
                    MessageStrategy.is = is;
                })(MessageStrategy = exports1.MessageStrategy || (exports1.MessageStrategy = {}));
                var ConnectionOptions;
                (function(ConnectionOptions) {
                    function is(value) {
                        const candidate = value;
                        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
                    }
                    ConnectionOptions.is = is;
                })(ConnectionOptions = exports1.ConnectionOptions || (exports1.ConnectionOptions = {}));
                var ConnectionState;
                (function(ConnectionState) {
                    ConnectionState[ConnectionState["New"] = 1] = "New";
                    ConnectionState[ConnectionState["Listening"] = 2] = "Listening";
                    ConnectionState[ConnectionState["Closed"] = 3] = "Closed";
                    ConnectionState[ConnectionState["Disposed"] = 4] = "Disposed";
                })(ConnectionState || (ConnectionState = {}));
                function createMessageConnection(messageReader, messageWriter, _logger, options) {
                    const logger = _logger !== undefined ? _logger : exports1.NullLogger;
                    let sequenceNumber = 0;
                    let notificationSequenceNumber = 0;
                    let unknownResponseSequenceNumber = 0;
                    const version = '2.0';
                    let starRequestHandler = undefined;
                    const requestHandlers = new Map();
                    let starNotificationHandler = undefined;
                    const notificationHandlers = new Map();
                    const progressHandlers = new Map();
                    let timer;
                    let messageQueue = new linkedMap_1.LinkedMap();
                    let responsePromises = new Map();
                    let knownCanceledRequests = new Set();
                    let requestTokens = new Map();
                    let trace = Trace.Off;
                    let traceFormat = TraceFormat.Text;
                    let tracer;
                    let state = ConnectionState.New;
                    const errorEmitter = new events_1.Emitter();
                    const closeEmitter = new events_1.Emitter();
                    const unhandledNotificationEmitter = new events_1.Emitter();
                    const unhandledProgressEmitter = new events_1.Emitter();
                    const disposeEmitter = new events_1.Emitter();
                    const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
                    function createRequestQueueKey(id) {
                        if (id === null) {
                            throw new Error(`Can't send requests with id null since the response can't be correlated.`);
                        }
                        return 'req-' + id.toString();
                    }
                    function createResponseQueueKey(id) {
                        if (id === null) {
                            return 'res-unknown-' + (++unknownResponseSequenceNumber).toString();
                        } else {
                            return 'res-' + id.toString();
                        }
                    }
                    function createNotificationQueueKey() {
                        return 'not-' + (++notificationSequenceNumber).toString();
                    }
                    function addMessageToQueue(queue, message) {
                        if (messages_1.Message.isRequest(message)) {
                            queue.set(createRequestQueueKey(message.id), message);
                        } else if (messages_1.Message.isResponse(message)) {
                            queue.set(createResponseQueueKey(message.id), message);
                        } else {
                            queue.set(createNotificationQueueKey(), message);
                        }
                    }
                    function cancelUndispatched(_message) {
                        return undefined;
                    }
                    function isListening() {
                        return state === ConnectionState.Listening;
                    }
                    function isClosed() {
                        return state === ConnectionState.Closed;
                    }
                    function isDisposed() {
                        return state === ConnectionState.Disposed;
                    }
                    function closeHandler() {
                        if (state === ConnectionState.New || state === ConnectionState.Listening) {
                            state = ConnectionState.Closed;
                            closeEmitter.fire(undefined);
                        }
                    // If the connection is disposed don't sent close events.
                    }
                    function readErrorHandler(error) {
                        errorEmitter.fire([
                            error,
                            undefined,
                            undefined
                        ]);
                    }
                    function writeErrorHandler(data) {
                        errorEmitter.fire(data);
                    }
                    messageReader.onClose(closeHandler);
                    messageReader.onError(readErrorHandler);
                    messageWriter.onClose(closeHandler);
                    messageWriter.onError(writeErrorHandler);
                    function triggerMessageQueue() {
                        if (timer || messageQueue.size === 0) {
                            return;
                        }
                        timer = (0, ral_1.default)().timer.setImmediate(()=>{
                            timer = undefined;
                            processMessageQueue();
                        });
                    }
                    function handleMessage(message) {
                        if (messages_1.Message.isRequest(message)) {
                            handleRequest(message);
                        } else if (messages_1.Message.isNotification(message)) {
                            handleNotification(message);
                        } else if (messages_1.Message.isResponse(message)) {
                            handleResponse(message);
                        } else {
                            handleInvalidMessage(message);
                        }
                    }
                    function processMessageQueue() {
                        if (messageQueue.size === 0) {
                            return;
                        }
                        const message = messageQueue.shift();
                        try {
                            var _options;
                            const messageStrategy = (_options = options) === null || _options === void 0 ? void 0 : _options.messageStrategy;
                            if (MessageStrategy.is(messageStrategy)) {
                                messageStrategy.handleMessage(message, handleMessage);
                            } else {
                                handleMessage(message);
                            }
                        } finally{
                            triggerMessageQueue();
                        }
                    }
                    const callback = (message)=>{
                        try {
                            // We have received a cancellation message. Check if the message is still in the queue
                            // and cancel it if allowed to do so.
                            if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
                                const cancelId = message.params.id;
                                const key = createRequestQueueKey(cancelId);
                                const toCancel = messageQueue.get(key);
                                if (messages_1.Message.isRequest(toCancel)) {
                                    var _options;
                                    const strategy = (_options = options) === null || _options === void 0 ? void 0 : _options.connectionStrategy;
                                    const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
                                    if (response && (response.error !== undefined || response.result !== undefined)) {
                                        messageQueue.delete(key);
                                        requestTokens.delete(cancelId);
                                        response.id = toCancel.id;
                                        traceSendingResponse(response, message.method, Date.now());
                                        messageWriter.write(response).catch(()=>logger.error(`Sending response for canceled message failed.`));
                                        return;
                                    }
                                }
                                const cancellationToken = requestTokens.get(cancelId);
                                // The request is already running. Cancel the token
                                if (cancellationToken !== undefined) {
                                    cancellationToken.cancel();
                                    traceReceivedNotification(message);
                                    return;
                                } else {
                                    // Remember the cancel but still queue the message to
                                    // clean up state in process message.
                                    knownCanceledRequests.add(cancelId);
                                }
                            }
                            addMessageToQueue(messageQueue, message);
                        } finally{
                            triggerMessageQueue();
                        }
                    };
                    function handleRequest(requestMessage) {
                        if (isDisposed()) {
                            // we return here silently since we fired an event when the
                            // connection got disposed.
                            return;
                        }
                        function reply(resultOrError, method, startTime) {
                            const message = {
                                jsonrpc: version,
                                id: requestMessage.id
                            };
                            if (resultOrError instanceof messages_1.ResponseError) {
                                message.error = resultOrError.toJson();
                            } else {
                                message.result = resultOrError === undefined ? null : resultOrError;
                            }
                            traceSendingResponse(message, method, startTime);
                            messageWriter.write(message).catch(()=>logger.error(`Sending response failed.`));
                        }
                        function replyError(error, method, startTime) {
                            const message = {
                                jsonrpc: version,
                                id: requestMessage.id,
                                error: error.toJson()
                            };
                            traceSendingResponse(message, method, startTime);
                            messageWriter.write(message).catch(()=>logger.error(`Sending response failed.`));
                        }
                        function replySuccess(result, method, startTime) {
                            // The JSON RPC defines that a response must either have a result or an error
                            // So we can't treat undefined as a valid response result.
                            if (result === undefined) {
                                result = null;
                            }
                            const message = {
                                jsonrpc: version,
                                id: requestMessage.id,
                                result: result
                            };
                            traceSendingResponse(message, method, startTime);
                            messageWriter.write(message).catch(()=>logger.error(`Sending response failed.`));
                        }
                        traceReceivedRequest(requestMessage);
                        const element = requestHandlers.get(requestMessage.method);
                        let type;
                        let requestHandler;
                        if (element) {
                            type = element.type;
                            requestHandler = element.handler;
                        }
                        const startTime = Date.now();
                        if (requestHandler || starRequestHandler) {
                            var _requestMessage_id;
                            const tokenKey = (_requestMessage_id = requestMessage.id) !== null && _requestMessage_id !== void 0 ? _requestMessage_id : String(Date.now()); //
                            const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver) ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey) : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
                            if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
                                cancellationSource.cancel();
                            }
                            if (requestMessage.id !== null) {
                                requestTokens.set(tokenKey, cancellationSource);
                            }
                            try {
                                let handlerResult;
                                if (requestHandler) {
                                    if (requestMessage.params === undefined) {
                                        if (type !== undefined && type.numberOfParams !== 0) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                                            return;
                                        }
                                        handlerResult = requestHandler(cancellationSource.token);
                                    } else if (Array.isArray(requestMessage.params)) {
                                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byName) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                                            return;
                                        }
                                        handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
                                    } else {
                                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                                            return;
                                        }
                                        handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
                                    }
                                } else if (starRequestHandler) {
                                    handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
                                }
                                const promise = handlerResult;
                                if (!handlerResult) {
                                    requestTokens.delete(tokenKey);
                                    replySuccess(handlerResult, requestMessage.method, startTime);
                                } else if (promise.then) {
                                    promise.then((resultOrError)=>{
                                        requestTokens.delete(tokenKey);
                                        reply(resultOrError, requestMessage.method, startTime);
                                    }, (error)=>{
                                        requestTokens.delete(tokenKey);
                                        if (error instanceof messages_1.ResponseError) {
                                            replyError(error, requestMessage.method, startTime);
                                        } else if (error && Is.string(error.message)) {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                                        } else {
                                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                                        }
                                    });
                                } else {
                                    requestTokens.delete(tokenKey);
                                    reply(handlerResult, requestMessage.method, startTime);
                                }
                            } catch (error) {
                                requestTokens.delete(tokenKey);
                                if (error instanceof messages_1.ResponseError) {
                                    reply(error, requestMessage.method, startTime);
                                } else if (error && Is.string(error.message)) {
                                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                                } else {
                                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                                }
                            }
                        } else {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
                        }
                    }
                    function handleResponse(responseMessage) {
                        if (isDisposed()) {
                            // See handle request.
                            return;
                        }
                        if (responseMessage.id === null) {
                            if (responseMessage.error) {
                                logger.error(`Received response message without id: Error is: \n${JSON.stringify(responseMessage.error, undefined, 4)}`);
                            } else {
                                logger.error(`Received response message without id. No further error information provided.`);
                            }
                        } else {
                            const key = responseMessage.id;
                            const responsePromise = responsePromises.get(key);
                            traceReceivedResponse(responseMessage, responsePromise);
                            if (responsePromise !== undefined) {
                                responsePromises.delete(key);
                                try {
                                    if (responseMessage.error) {
                                        const error = responseMessage.error;
                                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
                                    } else if (responseMessage.result !== undefined) {
                                        responsePromise.resolve(responseMessage.result);
                                    } else {
                                        throw new Error('Should never happen.');
                                    }
                                } catch (error) {
                                    if (error.message) {
                                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
                                    } else {
                                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
                                    }
                                }
                            }
                        }
                    }
                    function handleNotification(message) {
                        if (isDisposed()) {
                            // See handle request.
                            return;
                        }
                        let type = undefined;
                        let notificationHandler;
                        if (message.method === CancelNotification.type.method) {
                            const cancelId = message.params.id;
                            knownCanceledRequests.delete(cancelId);
                            traceReceivedNotification(message);
                            return;
                        } else {
                            const element = notificationHandlers.get(message.method);
                            if (element) {
                                notificationHandler = element.handler;
                                type = element.type;
                            }
                        }
                        if (notificationHandler || starNotificationHandler) {
                            try {
                                traceReceivedNotification(message);
                                if (notificationHandler) {
                                    if (message.params === undefined) {
                                        if (type !== undefined) {
                                            if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                                            }
                                        }
                                        notificationHandler();
                                    } else if (Array.isArray(message.params)) {
                                        // There are JSON-RPC libraries that send progress message as positional params although
                                        // specified as named. So convert them if this is the case.
                                        const params = message.params;
                                        if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                                            notificationHandler({
                                                token: params[0],
                                                value: params[1]
                                            });
                                        } else {
                                            if (type !== undefined) {
                                                if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                                                    logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                                                }
                                                if (type.numberOfParams !== message.params.length) {
                                                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                                                }
                                            }
                                            notificationHandler(...params);
                                        }
                                    } else {
                                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                                            logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                                        }
                                        notificationHandler(message.params);
                                    }
                                } else if (starNotificationHandler) {
                                    starNotificationHandler(message.method, message.params);
                                }
                            } catch (error) {
                                if (error.message) {
                                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
                                } else {
                                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
                                }
                            }
                        } else {
                            unhandledNotificationEmitter.fire(message);
                        }
                    }
                    function handleInvalidMessage(message) {
                        if (!message) {
                            logger.error('Received empty message.');
                            return;
                        }
                        logger.error(`Received message which is neither a response nor a notification message:\n${JSON.stringify(message, null, 4)}`);
                        // Test whether we find an id to reject the promise
                        const responseMessage = message;
                        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
                            const key = responseMessage.id;
                            const responseHandler = responsePromises.get(key);
                            if (responseHandler) {
                                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));
                            }
                        }
                    }
                    function stringifyTrace(params) {
                        if (params === undefined || params === null) {
                            return undefined;
                        }
                        switch(trace){
                            case Trace.Verbose:
                                return JSON.stringify(params, null, 4);
                            case Trace.Compact:
                                return JSON.stringify(params);
                            default:
                                return undefined;
                        }
                    }
                    function traceSendingRequest(message) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
                                data = `Params: ${stringifyTrace(message.params)}\n\n`;
                            }
                            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
                        } else {
                            logLSPMessage('send-request', message);
                        }
                    }
                    function traceSendingNotification(message) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.params) {
                                    data = `Params: ${stringifyTrace(message.params)}\n\n`;
                                } else {
                                    data = 'No parameters provided.\n\n';
                                }
                            }
                            tracer.log(`Sending notification '${message.method}'.`, data);
                        } else {
                            logLSPMessage('send-notification', message);
                        }
                    }
                    function traceSendingResponse(message, method, startTime) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.error && message.error.data) {
                                    data = `Error data: ${stringifyTrace(message.error.data)}\n\n`;
                                } else {
                                    if (message.result) {
                                        data = `Result: ${stringifyTrace(message.result)}\n\n`;
                                    } else if (message.error === undefined) {
                                        data = 'No result returned.\n\n';
                                    }
                                }
                            }
                            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
                        } else {
                            logLSPMessage('send-response', message);
                        }
                    }
                    function traceReceivedRequest(message) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
                                data = `Params: ${stringifyTrace(message.params)}\n\n`;
                            }
                            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
                        } else {
                            logLSPMessage('receive-request', message);
                        }
                    }
                    function traceReceivedNotification(message) {
                        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.params) {
                                    data = `Params: ${stringifyTrace(message.params)}\n\n`;
                                } else {
                                    data = 'No parameters provided.\n\n';
                                }
                            }
                            tracer.log(`Received notification '${message.method}'.`, data);
                        } else {
                            logLSPMessage('receive-notification', message);
                        }
                    }
                    function traceReceivedResponse(message, responsePromise) {
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        if (traceFormat === TraceFormat.Text) {
                            let data = undefined;
                            if (trace === Trace.Verbose || trace === Trace.Compact) {
                                if (message.error && message.error.data) {
                                    data = `Error data: ${stringifyTrace(message.error.data)}\n\n`;
                                } else {
                                    if (message.result) {
                                        data = `Result: ${stringifyTrace(message.result)}\n\n`;
                                    } else if (message.error === undefined) {
                                        data = 'No result returned.\n\n';
                                    }
                                }
                            }
                            if (responsePromise) {
                                const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';
                                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
                            } else {
                                tracer.log(`Received response ${message.id} without active response promise.`, data);
                            }
                        } else {
                            logLSPMessage('receive-response', message);
                        }
                    }
                    function logLSPMessage(type, message) {
                        if (!tracer || trace === Trace.Off) {
                            return;
                        }
                        const lspMessage = {
                            isLSPMessage: true,
                            type,
                            message,
                            timestamp: Date.now()
                        };
                        tracer.log(lspMessage);
                    }
                    function throwIfClosedOrDisposed() {
                        if (isClosed()) {
                            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');
                        }
                        if (isDisposed()) {
                            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');
                        }
                    }
                    function throwIfListening() {
                        if (isListening()) {
                            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');
                        }
                    }
                    function throwIfNotListening() {
                        if (!isListening()) {
                            throw new Error('Call listen() first.');
                        }
                    }
                    function undefinedToNull(param) {
                        if (param === undefined) {
                            return null;
                        } else {
                            return param;
                        }
                    }
                    function nullToUndefined(param) {
                        if (param === null) {
                            return undefined;
                        } else {
                            return param;
                        }
                    }
                    function isNamedParam(param) {
                        return param !== undefined && param !== null && !Array.isArray(param) && typeof param === 'object';
                    }
                    function computeSingleParam(parameterStructures, param) {
                        switch(parameterStructures){
                            case messages_1.ParameterStructures.auto:
                                if (isNamedParam(param)) {
                                    return nullToUndefined(param);
                                } else {
                                    return [
                                        undefinedToNull(param)
                                    ];
                                }
                            case messages_1.ParameterStructures.byName:
                                if (!isNamedParam(param)) {
                                    throw new Error(`Received parameters by name but param is not an object literal.`);
                                }
                                return nullToUndefined(param);
                            case messages_1.ParameterStructures.byPosition:
                                return [
                                    undefinedToNull(param)
                                ];
                            default:
                                throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
                        }
                    }
                    function computeMessageParams(type, params) {
                        let result;
                        const numberOfParams = type.numberOfParams;
                        switch(numberOfParams){
                            case 0:
                                result = undefined;
                                break;
                            case 1:
                                result = computeSingleParam(type.parameterStructures, params[0]);
                                break;
                            default:
                                result = [];
                                for(let i = 0; i < params.length && i < numberOfParams; i++){
                                    result.push(undefinedToNull(params[i]));
                                }
                                if (params.length < numberOfParams) {
                                    for(let i = params.length; i < numberOfParams; i++){
                                        result.push(null);
                                    }
                                }
                                break;
                        }
                        return result;
                    }
                    const connection = {
                        sendNotification: (type, ...args)=>{
                            throwIfClosedOrDisposed();
                            let method;
                            let messageParams;
                            if (Is.string(type)) {
                                method = type;
                                const first = args[0];
                                let paramStart = 0;
                                let parameterStructures = messages_1.ParameterStructures.auto;
                                if (messages_1.ParameterStructures.is(first)) {
                                    paramStart = 1;
                                    parameterStructures = first;
                                }
                                let paramEnd = args.length;
                                const numberOfParams = paramEnd - paramStart;
                                switch(numberOfParams){
                                    case 0:
                                        messageParams = undefined;
                                        break;
                                    case 1:
                                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                                        break;
                                    default:
                                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                                        }
                                        messageParams = args.slice(paramStart, paramEnd).map((value)=>undefinedToNull(value));
                                        break;
                                }
                            } else {
                                const params = args;
                                method = type.method;
                                messageParams = computeMessageParams(type, params);
                            }
                            const notificationMessage = {
                                jsonrpc: version,
                                method: method,
                                params: messageParams
                            };
                            traceSendingNotification(notificationMessage);
                            return messageWriter.write(notificationMessage).catch((error)=>{
                                logger.error(`Sending notification failed.`);
                                throw error;
                            });
                        },
                        onNotification: (type, handler)=>{
                            throwIfClosedOrDisposed();
                            let method;
                            if (Is.func(type)) {
                                starNotificationHandler = type;
                            } else if (handler) {
                                if (Is.string(type)) {
                                    method = type;
                                    notificationHandlers.set(type, {
                                        type: undefined,
                                        handler
                                    });
                                } else {
                                    method = type.method;
                                    notificationHandlers.set(type.method, {
                                        type,
                                        handler
                                    });
                                }
                            }
                            return {
                                dispose: ()=>{
                                    if (method !== undefined) {
                                        notificationHandlers.delete(method);
                                    } else {
                                        starNotificationHandler = undefined;
                                    }
                                }
                            };
                        },
                        onProgress: (_type, token, handler)=>{
                            if (progressHandlers.has(token)) {
                                throw new Error(`Progress handler for token ${token} already registered`);
                            }
                            progressHandlers.set(token, handler);
                            return {
                                dispose: ()=>{
                                    progressHandlers.delete(token);
                                }
                            };
                        },
                        sendProgress: (_type, token, value)=>{
                            // This should not await but simple return to ensure that we don't have another
                            // async scheduling. Otherwise one send could overtake another send.
                            return connection.sendNotification(ProgressNotification.type, {
                                token,
                                value
                            });
                        },
                        onUnhandledProgress: unhandledProgressEmitter.event,
                        sendRequest: (type, ...args)=>{
                            throwIfClosedOrDisposed();
                            throwIfNotListening();
                            let method;
                            let messageParams;
                            let token = undefined;
                            if (Is.string(type)) {
                                method = type;
                                const first = args[0];
                                const last = args[args.length - 1];
                                let paramStart = 0;
                                let parameterStructures = messages_1.ParameterStructures.auto;
                                if (messages_1.ParameterStructures.is(first)) {
                                    paramStart = 1;
                                    parameterStructures = first;
                                }
                                let paramEnd = args.length;
                                if (cancellation_1.CancellationToken.is(last)) {
                                    paramEnd = paramEnd - 1;
                                    token = last;
                                }
                                const numberOfParams = paramEnd - paramStart;
                                switch(numberOfParams){
                                    case 0:
                                        messageParams = undefined;
                                        break;
                                    case 1:
                                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                                        break;
                                    default:
                                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                                        }
                                        messageParams = args.slice(paramStart, paramEnd).map((value)=>undefinedToNull(value));
                                        break;
                                }
                            } else {
                                const params = args;
                                method = type.method;
                                messageParams = computeMessageParams(type, params);
                                const numberOfParams = type.numberOfParams;
                                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;
                            }
                            const id = sequenceNumber++;
                            let disposable;
                            if (token) {
                                disposable = token.onCancellationRequested(()=>{
                                    const p = cancellationStrategy.sender.sendCancellation(connection, id);
                                    if (p === undefined) {
                                        logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                                        return Promise.resolve();
                                    } else {
                                        return p.catch(()=>{
                                            logger.log(`Sending cancellation messages for id ${id} failed`);
                                        });
                                    }
                                });
                            }
                            const requestMessage = {
                                jsonrpc: version,
                                id: id,
                                method: method,
                                params: messageParams
                            };
                            traceSendingRequest(requestMessage);
                            if (typeof cancellationStrategy.sender.enableCancellation === 'function') {
                                cancellationStrategy.sender.enableCancellation(requestMessage);
                            }
                            return new Promise(async (resolve, reject)=>{
                                const resolveWithCleanup = (r)=>{
                                    var _disposable;
                                    resolve(r);
                                    cancellationStrategy.sender.cleanup(id);
                                    (_disposable = disposable) === null || _disposable === void 0 ? void 0 : _disposable.dispose();
                                };
                                const rejectWithCleanup = (r)=>{
                                    var _disposable;
                                    reject(r);
                                    cancellationStrategy.sender.cleanup(id);
                                    (_disposable = disposable) === null || _disposable === void 0 ? void 0 : _disposable.dispose();
                                };
                                const responsePromise = {
                                    method: method,
                                    timerStart: Date.now(),
                                    resolve: resolveWithCleanup,
                                    reject: rejectWithCleanup
                                };
                                try {
                                    await messageWriter.write(requestMessage);
                                    responsePromises.set(id, responsePromise);
                                } catch (error) {
                                    logger.error(`Sending request failed.`);
                                    // Writing the message failed. So we need to reject the promise.
                                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : 'Unknown reason'));
                                    throw error;
                                }
                            });
                        },
                        onRequest: (type, handler)=>{
                            throwIfClosedOrDisposed();
                            let method = null;
                            if (StarRequestHandler.is(type)) {
                                method = undefined;
                                starRequestHandler = type;
                            } else if (Is.string(type)) {
                                method = null;
                                if (handler !== undefined) {
                                    method = type;
                                    requestHandlers.set(type, {
                                        handler: handler,
                                        type: undefined
                                    });
                                }
                            } else {
                                if (handler !== undefined) {
                                    method = type.method;
                                    requestHandlers.set(type.method, {
                                        type,
                                        handler
                                    });
                                }
                            }
                            return {
                                dispose: ()=>{
                                    if (method === null) {
                                        return;
                                    }
                                    if (method !== undefined) {
                                        requestHandlers.delete(method);
                                    } else {
                                        starRequestHandler = undefined;
                                    }
                                }
                            };
                        },
                        hasPendingResponse: ()=>{
                            return responsePromises.size > 0;
                        },
                        trace: async (_value, _tracer, sendNotificationOrTraceOptions)=>{
                            let _sendNotification = false;
                            let _traceFormat = TraceFormat.Text;
                            if (sendNotificationOrTraceOptions !== undefined) {
                                if (Is.boolean(sendNotificationOrTraceOptions)) {
                                    _sendNotification = sendNotificationOrTraceOptions;
                                } else {
                                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
                                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
                                }
                            }
                            trace = _value;
                            traceFormat = _traceFormat;
                            if (trace === Trace.Off) {
                                tracer = undefined;
                            } else {
                                tracer = _tracer;
                            }
                            if (_sendNotification && !isClosed() && !isDisposed()) {
                                await connection.sendNotification(SetTraceNotification.type, {
                                    value: Trace.toString(_value)
                                });
                            }
                        },
                        onError: errorEmitter.event,
                        onClose: closeEmitter.event,
                        onUnhandledNotification: unhandledNotificationEmitter.event,
                        onDispose: disposeEmitter.event,
                        end: ()=>{
                            messageWriter.end();
                        },
                        dispose: ()=>{
                            if (isDisposed()) {
                                return;
                            }
                            state = ConnectionState.Disposed;
                            disposeEmitter.fire(undefined);
                            const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, 'Pending response rejected since connection got disposed');
                            for (const promise of responsePromises.values()){
                                promise.reject(error);
                            }
                            responsePromises = new Map();
                            requestTokens = new Map();
                            knownCanceledRequests = new Set();
                            messageQueue = new linkedMap_1.LinkedMap();
                            // Test for backwards compatibility
                            if (Is.func(messageWriter.dispose)) {
                                messageWriter.dispose();
                            }
                            if (Is.func(messageReader.dispose)) {
                                messageReader.dispose();
                            }
                        },
                        listen: ()=>{
                            throwIfClosedOrDisposed();
                            throwIfListening();
                            state = ConnectionState.Listening;
                            messageReader.listen(callback);
                        },
                        inspect: ()=>{
                            // eslint-disable-next-line no-console
                            (0, ral_1.default)().console.log('inspect');
                        }
                    };
                    connection.onNotification(LogTraceNotification.type, (params)=>{
                        if (trace === Trace.Off || !tracer) {
                            return;
                        }
                        const verbose = trace === Trace.Verbose || trace === Trace.Compact;
                        tracer.log(params.message, verbose ? params.verbose : undefined);
                    });
                    connection.onNotification(ProgressNotification.type, (params)=>{
                        const handler = progressHandlers.get(params.token);
                        if (handler) {
                            handler(params.value);
                        } else {
                            unhandledProgressEmitter.fire(params);
                        }
                    });
                    return connection;
                }
                exports1.createMessageConnection = createMessageConnection;
            /***/ },
            /***/ 8844: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Disposable = void 0;
                var Disposable;
                (function(Disposable) {
                    function create(func) {
                        return {
                            dispose: func
                        };
                    }
                    Disposable.create = create;
                })(Disposable = exports1.Disposable || (exports1.Disposable = {}));
            /***/ },
            /***/ 2479: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_363174__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Emitter = exports1.Event = void 0;
                const ral_1 = __nested_webpack_require_363174__(5091);
                var Event;
                (function(Event) {
                    const _disposable = {
                        dispose () {}
                    };
                    Event.None = function() {
                        return _disposable;
                    };
                })(Event = exports1.Event || (exports1.Event = {}));
                class CallbackList {
                    add(callback, context = null, bucket) {
                        if (!this._callbacks) {
                            this._callbacks = [];
                            this._contexts = [];
                        }
                        this._callbacks.push(callback);
                        this._contexts.push(context);
                        if (Array.isArray(bucket)) {
                            bucket.push({
                                dispose: ()=>this.remove(callback, context)
                            });
                        }
                    }
                    remove(callback, context = null) {
                        if (!this._callbacks) {
                            return;
                        }
                        let foundCallbackWithDifferentContext = false;
                        for(let i = 0, len = this._callbacks.length; i < len; i++){
                            if (this._callbacks[i] === callback) {
                                if (this._contexts[i] === context) {
                                    // callback & context match => remove it
                                    this._callbacks.splice(i, 1);
                                    this._contexts.splice(i, 1);
                                    return;
                                } else {
                                    foundCallbackWithDifferentContext = true;
                                }
                            }
                        }
                        if (foundCallbackWithDifferentContext) {
                            throw new Error('When adding a listener with a context, you should remove it with the same context');
                        }
                    }
                    invoke(...args) {
                        if (!this._callbacks) {
                            return [];
                        }
                        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
                        for(let i = 0, len = callbacks.length; i < len; i++){
                            try {
                                ret.push(callbacks[i].apply(contexts[i], args));
                            } catch (e) {
                                // eslint-disable-next-line no-console
                                (0, ral_1.default)().console.error(e);
                            }
                        }
                        return ret;
                    }
                    isEmpty() {
                        return !this._callbacks || this._callbacks.length === 0;
                    }
                    dispose() {
                        this._callbacks = undefined;
                        this._contexts = undefined;
                    }
                }
                class Emitter {
                    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */ get event() {
                        if (!this._event) {
                            this._event = (listener, thisArgs, disposables)=>{
                                if (!this._callbacks) {
                                    this._callbacks = new CallbackList();
                                }
                                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
                                    this._options.onFirstListenerAdd(this);
                                }
                                this._callbacks.add(listener, thisArgs);
                                const result = {
                                    dispose: ()=>{
                                        if (!this._callbacks) {
                                            // disposable is disposed after emitter is disposed.
                                            return;
                                        }
                                        this._callbacks.remove(listener, thisArgs);
                                        result.dispose = Emitter._noop;
                                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                                            this._options.onLastListenerRemove(this);
                                        }
                                    }
                                };
                                if (Array.isArray(disposables)) {
                                    disposables.push(result);
                                }
                                return result;
                            };
                        }
                        return this._event;
                    }
                    /**
     * To be kept private to fire an event to
     * subscribers
     */ fire(event) {
                        if (this._callbacks) {
                            this._callbacks.invoke.call(this._callbacks, event);
                        }
                    }
                    dispose() {
                        if (this._callbacks) {
                            this._callbacks.dispose();
                            this._callbacks = undefined;
                        }
                    }
                    constructor(_options){
                        this._options = _options;
                    }
                }
                exports1.Emitter = Emitter;
                Emitter._noop = function() {};
            /***/ },
            /***/ 6618: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.stringArray = exports1.array = exports1.func = exports1.error = exports1.number = exports1.string = exports1.boolean = void 0;
                function boolean(value) {
                    return value === true || value === false;
                }
                exports1.boolean = boolean;
                function string(value) {
                    return typeof value === 'string' || value instanceof String;
                }
                exports1.string = string;
                function number(value) {
                    return typeof value === 'number' || value instanceof Number;
                }
                exports1.number = number;
                function error(value) {
                    return value instanceof Error;
                }
                exports1.error = error;
                function func(value) {
                    return typeof value === 'function';
                }
                exports1.func = func;
                function array(value) {
                    return Array.isArray(value);
                }
                exports1.array = array;
                function stringArray(value) {
                    return array(value) && value.every((elem)=>string(elem));
                }
                exports1.stringArray = stringArray;
            /***/ },
            /***/ 1109: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ var _a;
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.LRUCache = exports1.LinkedMap = exports1.Touch = void 0;
                var Touch;
                (function(Touch) {
                    Touch.None = 0;
                    Touch.First = 1;
                    Touch.AsOld = Touch.First;
                    Touch.Last = 2;
                    Touch.AsNew = Touch.Last;
                })(Touch = exports1.Touch || (exports1.Touch = {}));
                class LinkedMap {
                    clear() {
                        this._map.clear();
                        this._head = undefined;
                        this._tail = undefined;
                        this._size = 0;
                        this._state++;
                    }
                    isEmpty() {
                        return !this._head && !this._tail;
                    }
                    get size() {
                        return this._size;
                    }
                    get first() {
                        var _this__head;
                        return (_this__head = this._head) === null || _this__head === void 0 ? void 0 : _this__head.value;
                    }
                    get last() {
                        var _this__tail;
                        return (_this__tail = this._tail) === null || _this__tail === void 0 ? void 0 : _this__tail.value;
                    }
                    has(key) {
                        return this._map.has(key);
                    }
                    get(key, touch = Touch.None) {
                        const item = this._map.get(key);
                        if (!item) {
                            return undefined;
                        }
                        if (touch !== Touch.None) {
                            this.touch(item, touch);
                        }
                        return item.value;
                    }
                    set(key, value, touch = Touch.None) {
                        let item = this._map.get(key);
                        if (item) {
                            item.value = value;
                            if (touch !== Touch.None) {
                                this.touch(item, touch);
                            }
                        } else {
                            item = {
                                key,
                                value,
                                next: undefined,
                                previous: undefined
                            };
                            switch(touch){
                                case Touch.None:
                                    this.addItemLast(item);
                                    break;
                                case Touch.First:
                                    this.addItemFirst(item);
                                    break;
                                case Touch.Last:
                                    this.addItemLast(item);
                                    break;
                                default:
                                    this.addItemLast(item);
                                    break;
                            }
                            this._map.set(key, item);
                            this._size++;
                        }
                        return this;
                    }
                    delete(key) {
                        return !!this.remove(key);
                    }
                    remove(key) {
                        const item = this._map.get(key);
                        if (!item) {
                            return undefined;
                        }
                        this._map.delete(key);
                        this.removeItem(item);
                        this._size--;
                        return item.value;
                    }
                    shift() {
                        if (!this._head && !this._tail) {
                            return undefined;
                        }
                        if (!this._head || !this._tail) {
                            throw new Error('Invalid list');
                        }
                        const item = this._head;
                        this._map.delete(item.key);
                        this.removeItem(item);
                        this._size--;
                        return item.value;
                    }
                    forEach(callbackfn, thisArg) {
                        const state = this._state;
                        let current = this._head;
                        while(current){
                            if (thisArg) {
                                callbackfn.bind(thisArg)(current.value, current.key, this);
                            } else {
                                callbackfn(current.value, current.key, this);
                            }
                            if (this._state !== state) {
                                throw new Error(`LinkedMap got modified during iteration.`);
                            }
                            current = current.next;
                        }
                    }
                    keys() {
                        const state = this._state;
                        let current = this._head;
                        const iterator = {
                            [Symbol.iterator]: ()=>{
                                return iterator;
                            },
                            next: ()=>{
                                if (this._state !== state) {
                                    throw new Error(`LinkedMap got modified during iteration.`);
                                }
                                if (current) {
                                    const result = {
                                        value: current.key,
                                        done: false
                                    };
                                    current = current.next;
                                    return result;
                                } else {
                                    return {
                                        value: undefined,
                                        done: true
                                    };
                                }
                            }
                        };
                        return iterator;
                    }
                    values() {
                        const state = this._state;
                        let current = this._head;
                        const iterator = {
                            [Symbol.iterator]: ()=>{
                                return iterator;
                            },
                            next: ()=>{
                                if (this._state !== state) {
                                    throw new Error(`LinkedMap got modified during iteration.`);
                                }
                                if (current) {
                                    const result = {
                                        value: current.value,
                                        done: false
                                    };
                                    current = current.next;
                                    return result;
                                } else {
                                    return {
                                        value: undefined,
                                        done: true
                                    };
                                }
                            }
                        };
                        return iterator;
                    }
                    entries() {
                        const state = this._state;
                        let current = this._head;
                        const iterator = {
                            [Symbol.iterator]: ()=>{
                                return iterator;
                            },
                            next: ()=>{
                                if (this._state !== state) {
                                    throw new Error(`LinkedMap got modified during iteration.`);
                                }
                                if (current) {
                                    const result = {
                                        value: [
                                            current.key,
                                            current.value
                                        ],
                                        done: false
                                    };
                                    current = current.next;
                                    return result;
                                } else {
                                    return {
                                        value: undefined,
                                        done: true
                                    };
                                }
                            }
                        };
                        return iterator;
                    }
                    [(_a = Symbol.toStringTag, Symbol.iterator)]() {
                        return this.entries();
                    }
                    trimOld(newSize) {
                        if (newSize >= this.size) {
                            return;
                        }
                        if (newSize === 0) {
                            this.clear();
                            return;
                        }
                        let current = this._head;
                        let currentSize = this.size;
                        while(current && currentSize > newSize){
                            this._map.delete(current.key);
                            current = current.next;
                            currentSize--;
                        }
                        this._head = current;
                        this._size = currentSize;
                        if (current) {
                            current.previous = undefined;
                        }
                        this._state++;
                    }
                    addItemFirst(item) {
                        // First time Insert
                        if (!this._head && !this._tail) {
                            this._tail = item;
                        } else if (!this._head) {
                            throw new Error('Invalid list');
                        } else {
                            item.next = this._head;
                            this._head.previous = item;
                        }
                        this._head = item;
                        this._state++;
                    }
                    addItemLast(item) {
                        // First time Insert
                        if (!this._head && !this._tail) {
                            this._head = item;
                        } else if (!this._tail) {
                            throw new Error('Invalid list');
                        } else {
                            item.previous = this._tail;
                            this._tail.next = item;
                        }
                        this._tail = item;
                        this._state++;
                    }
                    removeItem(item) {
                        if (item === this._head && item === this._tail) {
                            this._head = undefined;
                            this._tail = undefined;
                        } else if (item === this._head) {
                            // This can only happened if size === 1 which is handle
                            // by the case above.
                            if (!item.next) {
                                throw new Error('Invalid list');
                            }
                            item.next.previous = undefined;
                            this._head = item.next;
                        } else if (item === this._tail) {
                            // This can only happened if size === 1 which is handle
                            // by the case above.
                            if (!item.previous) {
                                throw new Error('Invalid list');
                            }
                            item.previous.next = undefined;
                            this._tail = item.previous;
                        } else {
                            const next = item.next;
                            const previous = item.previous;
                            if (!next || !previous) {
                                throw new Error('Invalid list');
                            }
                            next.previous = previous;
                            previous.next = next;
                        }
                        item.next = undefined;
                        item.previous = undefined;
                        this._state++;
                    }
                    touch(item, touch) {
                        if (!this._head || !this._tail) {
                            throw new Error('Invalid list');
                        }
                        if (touch !== Touch.First && touch !== Touch.Last) {
                            return;
                        }
                        if (touch === Touch.First) {
                            if (item === this._head) {
                                return;
                            }
                            const next = item.next;
                            const previous = item.previous;
                            // Unlink the item
                            if (item === this._tail) {
                                // previous must be defined since item was not head but is tail
                                // So there are more than on item in the map
                                previous.next = undefined;
                                this._tail = previous;
                            } else {
                                // Both next and previous are not undefined since item was neither head nor tail.
                                next.previous = previous;
                                previous.next = next;
                            }
                            // Insert the node at head
                            item.previous = undefined;
                            item.next = this._head;
                            this._head.previous = item;
                            this._head = item;
                            this._state++;
                        } else if (touch === Touch.Last) {
                            if (item === this._tail) {
                                return;
                            }
                            const next = item.next;
                            const previous = item.previous;
                            // Unlink the item.
                            if (item === this._head) {
                                // next must be defined since item was not tail but is head
                                // So there are more than on item in the map
                                next.previous = undefined;
                                this._head = next;
                            } else {
                                // Both next and previous are not undefined since item was neither head nor tail.
                                next.previous = previous;
                                previous.next = next;
                            }
                            item.next = undefined;
                            item.previous = this._tail;
                            this._tail.next = item;
                            this._tail = item;
                            this._state++;
                        }
                    }
                    toJSON() {
                        const data = [];
                        this.forEach((value, key)=>{
                            data.push([
                                key,
                                value
                            ]);
                        });
                        return data;
                    }
                    fromJSON(data) {
                        this.clear();
                        for (const [key, value] of data){
                            this.set(key, value);
                        }
                    }
                    constructor(){
                        this[_a] = 'LinkedMap';
                        this._map = new Map();
                        this._head = undefined;
                        this._tail = undefined;
                        this._size = 0;
                        this._state = 0;
                    }
                }
                exports1.LinkedMap = LinkedMap;
                class LRUCache extends LinkedMap {
                    get limit() {
                        return this._limit;
                    }
                    set limit(limit) {
                        this._limit = limit;
                        this.checkTrim();
                    }
                    get ratio() {
                        return this._ratio;
                    }
                    set ratio(ratio) {
                        this._ratio = Math.min(Math.max(0, ratio), 1);
                        this.checkTrim();
                    }
                    get(key, touch = Touch.AsNew) {
                        return super.get(key, touch);
                    }
                    peek(key) {
                        return super.get(key, Touch.None);
                    }
                    set(key, value) {
                        super.set(key, value, Touch.Last);
                        this.checkTrim();
                        return this;
                    }
                    checkTrim() {
                        if (this.size > this._limit) {
                            this.trimOld(Math.round(this._limit * this._ratio));
                        }
                    }
                    constructor(limit, ratio = 1){
                        super();
                        this._limit = limit;
                        this._ratio = Math.min(Math.max(0, ratio), 1);
                    }
                }
                exports1.LRUCache = LRUCache;
            /***/ },
            /***/ 9805: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.AbstractMessageBuffer = void 0;
                const CR = 13;
                const LF = 10;
                const CRLF = '\r\n';
                class AbstractMessageBuffer {
                    get encoding() {
                        return this._encoding;
                    }
                    append(chunk) {
                        const toAppend = typeof chunk === 'string' ? this.fromString(chunk, this._encoding) : chunk;
                        this._chunks.push(toAppend);
                        this._totalLength += toAppend.byteLength;
                    }
                    tryReadHeaders(lowerCaseKeys = false) {
                        if (this._chunks.length === 0) {
                            return undefined;
                        }
                        let state = 0;
                        let chunkIndex = 0;
                        let offset = 0;
                        let chunkBytesRead = 0;
                        row: while(chunkIndex < this._chunks.length){
                            const chunk = this._chunks[chunkIndex];
                            offset = 0;
                            column: while(offset < chunk.length){
                                const value = chunk[offset];
                                switch(value){
                                    case CR:
                                        switch(state){
                                            case 0:
                                                state = 1;
                                                break;
                                            case 2:
                                                state = 3;
                                                break;
                                            default:
                                                state = 0;
                                        }
                                        break;
                                    case LF:
                                        switch(state){
                                            case 1:
                                                state = 2;
                                                break;
                                            case 3:
                                                state = 4;
                                                offset++;
                                                break row;
                                            default:
                                                state = 0;
                                        }
                                        break;
                                    default:
                                        state = 0;
                                }
                                offset++;
                            }
                            chunkBytesRead += chunk.byteLength;
                            chunkIndex++;
                        }
                        if (state !== 4) {
                            return undefined;
                        }
                        // The buffer contains the two CRLF at the end. So we will
                        // have two empty lines after the split at the end as well.
                        const buffer = this._read(chunkBytesRead + offset);
                        const result = new Map();
                        const headers = this.toString(buffer, 'ascii').split(CRLF);
                        if (headers.length < 2) {
                            return result;
                        }
                        for(let i = 0; i < headers.length - 2; i++){
                            const header = headers[i];
                            const index = header.indexOf(':');
                            if (index === -1) {
                                throw new Error('Message header must separate key and value using :');
                            }
                            const key = header.substr(0, index);
                            const value = header.substr(index + 1).trim();
                            result.set(lowerCaseKeys ? key.toLowerCase() : key, value);
                        }
                        return result;
                    }
                    tryReadBody(length) {
                        if (this._totalLength < length) {
                            return undefined;
                        }
                        return this._read(length);
                    }
                    get numberOfBytes() {
                        return this._totalLength;
                    }
                    _read(byteCount) {
                        if (byteCount === 0) {
                            return this.emptyBuffer();
                        }
                        if (byteCount > this._totalLength) {
                            throw new Error(`Cannot read so many bytes!`);
                        }
                        if (this._chunks[0].byteLength === byteCount) {
                            // super fast path, precisely first chunk must be returned
                            const chunk = this._chunks[0];
                            this._chunks.shift();
                            this._totalLength -= byteCount;
                            return this.asNative(chunk);
                        }
                        if (this._chunks[0].byteLength > byteCount) {
                            // fast path, the reading is entirely within the first chunk
                            const chunk = this._chunks[0];
                            const result = this.asNative(chunk, byteCount);
                            this._chunks[0] = chunk.slice(byteCount);
                            this._totalLength -= byteCount;
                            return result;
                        }
                        const result = this.allocNative(byteCount);
                        let resultOffset = 0;
                        let chunkIndex = 0;
                        while(byteCount > 0){
                            const chunk = this._chunks[chunkIndex];
                            if (chunk.byteLength > byteCount) {
                                // this chunk will survive
                                const chunkPart = chunk.slice(0, byteCount);
                                result.set(chunkPart, resultOffset);
                                resultOffset += byteCount;
                                this._chunks[chunkIndex] = chunk.slice(byteCount);
                                this._totalLength -= byteCount;
                                byteCount -= byteCount;
                            } else {
                                // this chunk will be entirely read
                                result.set(chunk, resultOffset);
                                resultOffset += chunk.byteLength;
                                this._chunks.shift();
                                this._totalLength -= chunk.byteLength;
                                byteCount -= chunk.byteLength;
                            }
                        }
                        return result;
                    }
                    constructor(encoding = 'utf-8'){
                        this._encoding = encoding;
                        this._chunks = [];
                        this._totalLength = 0;
                    }
                }
                exports1.AbstractMessageBuffer = AbstractMessageBuffer;
            /***/ },
            /***/ 656: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_398866__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ReadableStreamMessageReader = exports1.AbstractMessageReader = exports1.MessageReader = void 0;
                const ral_1 = __nested_webpack_require_398866__(5091);
                const Is = __nested_webpack_require_398866__(6618);
                const events_1 = __nested_webpack_require_398866__(2479);
                const semaphore_1 = __nested_webpack_require_398866__(418);
                var MessageReader;
                (function(MessageReader) {
                    function is(value) {
                        let candidate = value;
                        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
                    }
                    MessageReader.is = is;
                })(MessageReader = exports1.MessageReader || (exports1.MessageReader = {}));
                class AbstractMessageReader {
                    dispose() {
                        this.errorEmitter.dispose();
                        this.closeEmitter.dispose();
                    }
                    get onError() {
                        return this.errorEmitter.event;
                    }
                    fireError(error) {
                        this.errorEmitter.fire(this.asError(error));
                    }
                    get onClose() {
                        return this.closeEmitter.event;
                    }
                    fireClose() {
                        this.closeEmitter.fire(undefined);
                    }
                    get onPartialMessage() {
                        return this.partialMessageEmitter.event;
                    }
                    firePartialMessage(info) {
                        this.partialMessageEmitter.fire(info);
                    }
                    asError(error) {
                        if (error instanceof Error) {
                            return error;
                        } else {
                            return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
                        }
                    }
                    constructor(){
                        this.errorEmitter = new events_1.Emitter();
                        this.closeEmitter = new events_1.Emitter();
                        this.partialMessageEmitter = new events_1.Emitter();
                    }
                }
                exports1.AbstractMessageReader = AbstractMessageReader;
                var ResolvedMessageReaderOptions;
                (function(ResolvedMessageReaderOptions) {
                    function fromOptions(options) {
                        let charset;
                        let result;
                        let contentDecoder;
                        const contentDecoders = new Map();
                        let contentTypeDecoder;
                        const contentTypeDecoders = new Map();
                        if (options === undefined || typeof options === 'string') {
                            charset = options !== null && options !== void 0 ? options : 'utf-8';
                        } else {
                            var _options_charset;
                            charset = (_options_charset = options.charset) !== null && _options_charset !== void 0 ? _options_charset : 'utf-8';
                            if (options.contentDecoder !== undefined) {
                                contentDecoder = options.contentDecoder;
                                contentDecoders.set(contentDecoder.name, contentDecoder);
                            }
                            if (options.contentDecoders !== undefined) {
                                for (const decoder of options.contentDecoders){
                                    contentDecoders.set(decoder.name, decoder);
                                }
                            }
                            if (options.contentTypeDecoder !== undefined) {
                                contentTypeDecoder = options.contentTypeDecoder;
                                contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
                            }
                            if (options.contentTypeDecoders !== undefined) {
                                for (const decoder of options.contentTypeDecoders){
                                    contentTypeDecoders.set(decoder.name, decoder);
                                }
                            }
                        }
                        if (contentTypeDecoder === undefined) {
                            contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
                            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
                        }
                        return {
                            charset,
                            contentDecoder,
                            contentDecoders,
                            contentTypeDecoder,
                            contentTypeDecoders
                        };
                    }
                    ResolvedMessageReaderOptions.fromOptions = fromOptions;
                })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
                class ReadableStreamMessageReader extends AbstractMessageReader {
                    set partialMessageTimeout(timeout) {
                        this._partialMessageTimeout = timeout;
                    }
                    get partialMessageTimeout() {
                        return this._partialMessageTimeout;
                    }
                    listen(callback) {
                        this.nextMessageLength = -1;
                        this.messageToken = 0;
                        this.partialMessageTimer = undefined;
                        this.callback = callback;
                        const result = this.readable.onData((data)=>{
                            this.onData(data);
                        });
                        this.readable.onError((error)=>this.fireError(error));
                        this.readable.onClose(()=>this.fireClose());
                        return result;
                    }
                    onData(data) {
                        this.buffer.append(data);
                        while(true){
                            if (this.nextMessageLength === -1) {
                                const headers = this.buffer.tryReadHeaders(true);
                                if (!headers) {
                                    return;
                                }
                                const contentLength = headers.get('content-length');
                                if (!contentLength) {
                                    this.fireError(new Error('Header must provide a Content-Length property.'));
                                    return;
                                }
                                const length = parseInt(contentLength);
                                if (isNaN(length)) {
                                    this.fireError(new Error('Content-Length value must be a number.'));
                                    return;
                                }
                                this.nextMessageLength = length;
                            }
                            const body = this.buffer.tryReadBody(this.nextMessageLength);
                            if (body === undefined) {
                                /** We haven't received the full message yet. */ this.setPartialMessageTimer();
                                return;
                            }
                            this.clearPartialMessageTimer();
                            this.nextMessageLength = -1;
                            // Make sure that we convert one received message after the
                            // other. Otherwise it could happen that a decoding of a second
                            // smaller message finished before the decoding of a first larger
                            // message and then we would deliver the second message first.
                            this.readSemaphore.lock(async ()=>{
                                const bytes = this.options.contentDecoder !== undefined ? await this.options.contentDecoder.decode(body) : body;
                                const message = await this.options.contentTypeDecoder.decode(bytes, this.options);
                                this.callback(message);
                            }).catch((error)=>{
                                this.fireError(error);
                            });
                        }
                    }
                    clearPartialMessageTimer() {
                        if (this.partialMessageTimer) {
                            this.partialMessageTimer.dispose();
                            this.partialMessageTimer = undefined;
                        }
                    }
                    setPartialMessageTimer() {
                        this.clearPartialMessageTimer();
                        if (this._partialMessageTimeout <= 0) {
                            return;
                        }
                        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout)=>{
                            this.partialMessageTimer = undefined;
                            if (token === this.messageToken) {
                                this.firePartialMessage({
                                    messageToken: token,
                                    waitingTime: timeout
                                });
                                this.setPartialMessageTimer();
                            }
                        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
                    }
                    constructor(readable, options){
                        super();
                        this.readable = readable;
                        this.options = ResolvedMessageReaderOptions.fromOptions(options);
                        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
                        this._partialMessageTimeout = 10000;
                        this.nextMessageLength = -1;
                        this.messageToken = 0;
                        this.readSemaphore = new semaphore_1.Semaphore(1);
                    }
                }
                exports1.ReadableStreamMessageReader = ReadableStreamMessageReader;
            /***/ },
            /***/ 9036: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_410127__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WriteableStreamMessageWriter = exports1.AbstractMessageWriter = exports1.MessageWriter = void 0;
                const ral_1 = __nested_webpack_require_410127__(5091);
                const Is = __nested_webpack_require_410127__(6618);
                const semaphore_1 = __nested_webpack_require_410127__(418);
                const events_1 = __nested_webpack_require_410127__(2479);
                const ContentLength = 'Content-Length: ';
                const CRLF = '\r\n';
                var MessageWriter;
                (function(MessageWriter) {
                    function is(value) {
                        let candidate = value;
                        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) && Is.func(candidate.onError) && Is.func(candidate.write);
                    }
                    MessageWriter.is = is;
                })(MessageWriter = exports1.MessageWriter || (exports1.MessageWriter = {}));
                class AbstractMessageWriter {
                    dispose() {
                        this.errorEmitter.dispose();
                        this.closeEmitter.dispose();
                    }
                    get onError() {
                        return this.errorEmitter.event;
                    }
                    fireError(error, message, count) {
                        this.errorEmitter.fire([
                            this.asError(error),
                            message,
                            count
                        ]);
                    }
                    get onClose() {
                        return this.closeEmitter.event;
                    }
                    fireClose() {
                        this.closeEmitter.fire(undefined);
                    }
                    asError(error) {
                        if (error instanceof Error) {
                            return error;
                        } else {
                            return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
                        }
                    }
                    constructor(){
                        this.errorEmitter = new events_1.Emitter();
                        this.closeEmitter = new events_1.Emitter();
                    }
                }
                exports1.AbstractMessageWriter = AbstractMessageWriter;
                var ResolvedMessageWriterOptions;
                (function(ResolvedMessageWriterOptions) {
                    function fromOptions(options) {
                        if (options === undefined || typeof options === 'string') {
                            return {
                                charset: options !== null && options !== void 0 ? options : 'utf-8',
                                contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder
                            };
                        } else {
                            var _options_charset, _options_contentTypeEncoder;
                            return {
                                charset: (_options_charset = options.charset) !== null && _options_charset !== void 0 ? _options_charset : 'utf-8',
                                contentEncoder: options.contentEncoder,
                                contentTypeEncoder: (_options_contentTypeEncoder = options.contentTypeEncoder) !== null && _options_contentTypeEncoder !== void 0 ? _options_contentTypeEncoder : (0, ral_1.default)().applicationJson.encoder
                            };
                        }
                    }
                    ResolvedMessageWriterOptions.fromOptions = fromOptions;
                })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
                class WriteableStreamMessageWriter extends AbstractMessageWriter {
                    async write(msg) {
                        return this.writeSemaphore.lock(async ()=>{
                            const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer)=>{
                                if (this.options.contentEncoder !== undefined) {
                                    return this.options.contentEncoder.encode(buffer);
                                } else {
                                    return buffer;
                                }
                            });
                            return payload.then((buffer)=>{
                                const headers = [];
                                headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
                                headers.push(CRLF);
                                return this.doWrite(msg, headers, buffer);
                            }, (error)=>{
                                this.fireError(error);
                                throw error;
                            });
                        });
                    }
                    async doWrite(msg, headers, data) {
                        try {
                            await this.writable.write(headers.join(''), 'ascii');
                            return this.writable.write(data);
                        } catch (error) {
                            this.handleError(error, msg);
                            return Promise.reject(error);
                        }
                    }
                    handleError(error, msg) {
                        this.errorCount++;
                        this.fireError(error, msg, this.errorCount);
                    }
                    end() {
                        this.writable.end();
                    }
                    constructor(writable, options){
                        super();
                        this.writable = writable;
                        this.options = ResolvedMessageWriterOptions.fromOptions(options);
                        this.errorCount = 0;
                        this.writeSemaphore = new semaphore_1.Semaphore(1);
                        this.writable.onError((error)=>this.fireError(error));
                        this.writable.onClose(()=>this.fireClose());
                    }
                }
                exports1.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
            /***/ },
            /***/ 7162: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_417012__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Message = exports1.NotificationType9 = exports1.NotificationType8 = exports1.NotificationType7 = exports1.NotificationType6 = exports1.NotificationType5 = exports1.NotificationType4 = exports1.NotificationType3 = exports1.NotificationType2 = exports1.NotificationType1 = exports1.NotificationType0 = exports1.NotificationType = exports1.RequestType9 = exports1.RequestType8 = exports1.RequestType7 = exports1.RequestType6 = exports1.RequestType5 = exports1.RequestType4 = exports1.RequestType3 = exports1.RequestType2 = exports1.RequestType1 = exports1.RequestType = exports1.RequestType0 = exports1.AbstractMessageSignature = exports1.ParameterStructures = exports1.ResponseError = exports1.ErrorCodes = void 0;
                const is = __nested_webpack_require_417012__(6618);
                /**
 * Predefined error codes.
 */ var ErrorCodes;
                (function(ErrorCodes) {
                    // Defined by JSON RPC
                    ErrorCodes.ParseError = -32700;
                    ErrorCodes.InvalidRequest = -32600;
                    ErrorCodes.MethodNotFound = -32601;
                    ErrorCodes.InvalidParams = -32602;
                    ErrorCodes.InternalError = -32603;
                    /**
     * This is the start range of JSON RPC reserved error codes.
     * It doesn't denote a real error code. No application error codes should
     * be defined between the start and end range. For backwards
     * compatibility the `ServerNotInitialized` and the `UnknownErrorCode`
     * are left in the range.
     *
     * @since 3.16.0
    */ ErrorCodes.jsonrpcReservedErrorRangeStart = -32099;
                    /** @deprecated use  jsonrpcReservedErrorRangeStart */ ErrorCodes.serverErrorStart = -32099;
                    /**
     * An error occurred when write a message to the transport layer.
     */ ErrorCodes.MessageWriteError = -32099;
                    /**
     * An error occurred when reading a message from the transport layer.
     */ ErrorCodes.MessageReadError = -32098;
                    /**
     * The connection got disposed or lost and all pending responses got
     * rejected.
     */ ErrorCodes.PendingResponseRejected = -32097;
                    /**
     * The connection is inactive and a use of it failed.
     */ ErrorCodes.ConnectionInactive = -32096;
                    /**
     * Error code indicating that a server received a notification or
     * request before the server has received the `initialize` request.
     */ ErrorCodes.ServerNotInitialized = -32002;
                    ErrorCodes.UnknownErrorCode = -32001;
                    /**
     * This is the end range of JSON RPC reserved error codes.
     * It doesn't denote a real error code.
     *
     * @since 3.16.0
    */ ErrorCodes.jsonrpcReservedErrorRangeEnd = -32000;
                    /** @deprecated use  jsonrpcReservedErrorRangeEnd */ ErrorCodes.serverErrorEnd = -32000;
                })(ErrorCodes = exports1.ErrorCodes || (exports1.ErrorCodes = {}));
                /**
 * An error object return in a response in case a request
 * has failed.
 */ class ResponseError extends Error {
                    toJson() {
                        const result = {
                            code: this.code,
                            message: this.message
                        };
                        if (this.data !== undefined) {
                            result.data = this.data;
                        }
                        return result;
                    }
                    constructor(code, message, data){
                        super(message);
                        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
                        this.data = data;
                        Object.setPrototypeOf(this, ResponseError.prototype);
                    }
                }
                exports1.ResponseError = ResponseError;
                class ParameterStructures {
                    static is(value) {
                        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
                    }
                    toString() {
                        return this.kind;
                    }
                    constructor(kind){
                        this.kind = kind;
                    }
                }
                exports1.ParameterStructures = ParameterStructures;
                /**
 * The parameter structure is automatically inferred on the number of parameters
 * and the parameter type in case of a single param.
 */ ParameterStructures.auto = new ParameterStructures('auto');
                /**
 * Forces `byPosition` parameter structure. This is useful if you have a single
 * parameter which has a literal type.
 */ ParameterStructures.byPosition = new ParameterStructures('byPosition');
                /**
 * Forces `byName` parameter structure. This is only useful when having a single
 * parameter. The library will report errors if used with a different number of
 * parameters.
 */ ParameterStructures.byName = new ParameterStructures('byName');
                /**
 * An abstract implementation of a MessageType.
 */ class AbstractMessageSignature {
                    get parameterStructures() {
                        return ParameterStructures.auto;
                    }
                    constructor(method, numberOfParams){
                        this.method = method;
                        this.numberOfParams = numberOfParams;
                    }
                }
                exports1.AbstractMessageSignature = AbstractMessageSignature;
                /**
 * Classes to type request response pairs
 */ class RequestType0 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 0);
                    }
                }
                exports1.RequestType0 = RequestType0;
                class RequestType extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.RequestType = RequestType;
                class RequestType1 extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.RequestType1 = RequestType1;
                class RequestType2 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 2);
                    }
                }
                exports1.RequestType2 = RequestType2;
                class RequestType3 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 3);
                    }
                }
                exports1.RequestType3 = RequestType3;
                class RequestType4 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 4);
                    }
                }
                exports1.RequestType4 = RequestType4;
                class RequestType5 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 5);
                    }
                }
                exports1.RequestType5 = RequestType5;
                class RequestType6 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 6);
                    }
                }
                exports1.RequestType6 = RequestType6;
                class RequestType7 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 7);
                    }
                }
                exports1.RequestType7 = RequestType7;
                class RequestType8 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 8);
                    }
                }
                exports1.RequestType8 = RequestType8;
                class RequestType9 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 9);
                    }
                }
                exports1.RequestType9 = RequestType9;
                class NotificationType extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.NotificationType = NotificationType;
                class NotificationType0 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 0);
                    }
                }
                exports1.NotificationType0 = NotificationType0;
                class NotificationType1 extends AbstractMessageSignature {
                    get parameterStructures() {
                        return this._parameterStructures;
                    }
                    constructor(method, _parameterStructures = ParameterStructures.auto){
                        super(method, 1);
                        this._parameterStructures = _parameterStructures;
                    }
                }
                exports1.NotificationType1 = NotificationType1;
                class NotificationType2 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 2);
                    }
                }
                exports1.NotificationType2 = NotificationType2;
                class NotificationType3 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 3);
                    }
                }
                exports1.NotificationType3 = NotificationType3;
                class NotificationType4 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 4);
                    }
                }
                exports1.NotificationType4 = NotificationType4;
                class NotificationType5 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 5);
                    }
                }
                exports1.NotificationType5 = NotificationType5;
                class NotificationType6 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 6);
                    }
                }
                exports1.NotificationType6 = NotificationType6;
                class NotificationType7 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 7);
                    }
                }
                exports1.NotificationType7 = NotificationType7;
                class NotificationType8 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 8);
                    }
                }
                exports1.NotificationType8 = NotificationType8;
                class NotificationType9 extends AbstractMessageSignature {
                    constructor(method){
                        super(method, 9);
                    }
                }
                exports1.NotificationType9 = NotificationType9;
                var Message;
                (function(Message) {
                    /**
     * Tests if the given message is a request message
     */ function isRequest(message) {
                        const candidate = message;
                        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
                    }
                    Message.isRequest = isRequest;
                    /**
     * Tests if the given message is a notification message
     */ function isNotification(message) {
                        const candidate = message;
                        return candidate && is.string(candidate.method) && message.id === void 0;
                    }
                    Message.isNotification = isNotification;
                    /**
     * Tests if the given message is a response message
     */ function isResponse(message) {
                        const candidate = message;
                        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
                    }
                    Message.isResponse = isResponse;
                })(Message = exports1.Message || (exports1.Message = {}));
            /***/ },
            /***/ 5091: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                let _ral;
                function RAL() {
                    if (_ral === undefined) {
                        throw new Error(`No runtime abstraction layer installed`);
                    }
                    return _ral;
                }
                (function(RAL) {
                    function install(ral) {
                        if (ral === undefined) {
                            throw new Error(`No runtime abstraction layer provided`);
                        }
                        _ral = ral;
                    }
                    RAL.install = install;
                })(RAL || (RAL = {}));
                exports1["default"] = RAL;
            /***/ },
            /***/ 418: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_432519__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.Semaphore = void 0;
                const ral_1 = __nested_webpack_require_432519__(5091);
                class Semaphore {
                    lock(thunk) {
                        return new Promise((resolve, reject)=>{
                            this._waiting.push({
                                thunk,
                                resolve,
                                reject
                            });
                            this.runNext();
                        });
                    }
                    get active() {
                        return this._active;
                    }
                    runNext() {
                        if (this._waiting.length === 0 || this._active === this._capacity) {
                            return;
                        }
                        (0, ral_1.default)().timer.setImmediate(()=>this.doRunNext());
                    }
                    doRunNext() {
                        if (this._waiting.length === 0 || this._active === this._capacity) {
                            return;
                        }
                        const next = this._waiting.shift();
                        this._active++;
                        if (this._active > this._capacity) {
                            throw new Error(`To many thunks active`);
                        }
                        try {
                            const result = next.thunk();
                            if (result instanceof Promise) {
                                result.then((value)=>{
                                    this._active--;
                                    next.resolve(value);
                                    this.runNext();
                                }, (err)=>{
                                    this._active--;
                                    next.reject(err);
                                    this.runNext();
                                });
                            } else {
                                this._active--;
                                next.resolve(result);
                                this.runNext();
                            }
                        } catch (err) {
                            this._active--;
                            next.reject(err);
                            this.runNext();
                        }
                    }
                    constructor(capacity = 1){
                        if (capacity <= 0) {
                            throw new Error('Capacity must be greater than 0');
                        }
                        this._capacity = capacity;
                        this._active = 0;
                        this._waiting = [];
                    }
                }
                exports1.Semaphore = Semaphore;
            /***/ },
            /***/ 3489: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_435962__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.SharedArrayReceiverStrategy = exports1.SharedArraySenderStrategy = void 0;
                const cancellation_1 = __nested_webpack_require_435962__(6957);
                var CancellationState;
                (function(CancellationState) {
                    CancellationState.Continue = 0;
                    CancellationState.Cancelled = 1;
                })(CancellationState || (CancellationState = {}));
                class SharedArraySenderStrategy {
                    enableCancellation(request) {
                        if (request.id === null) {
                            return;
                        }
                        const buffer = new SharedArrayBuffer(4);
                        const data = new Int32Array(buffer, 0, 1);
                        data[0] = CancellationState.Continue;
                        this.buffers.set(request.id, buffer);
                        request.$cancellationData = buffer;
                    }
                    async sendCancellation(_conn, id) {
                        const buffer = this.buffers.get(id);
                        if (buffer === undefined) {
                            return;
                        }
                        const data = new Int32Array(buffer, 0, 1);
                        Atomics.store(data, 0, CancellationState.Cancelled);
                    }
                    cleanup(id) {
                        this.buffers.delete(id);
                    }
                    dispose() {
                        this.buffers.clear();
                    }
                    constructor(){
                        this.buffers = new Map();
                    }
                }
                exports1.SharedArraySenderStrategy = SharedArraySenderStrategy;
                class SharedArrayBufferCancellationToken {
                    get isCancellationRequested() {
                        return Atomics.load(this.data, 0) === CancellationState.Cancelled;
                    }
                    get onCancellationRequested() {
                        throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
                    }
                    constructor(buffer){
                        this.data = new Int32Array(buffer, 0, 1);
                    }
                }
                class SharedArrayBufferCancellationTokenSource {
                    cancel() {}
                    dispose() {}
                    constructor(buffer){
                        this.token = new SharedArrayBufferCancellationToken(buffer);
                    }
                }
                class SharedArrayReceiverStrategy {
                    createCancellationTokenSource(request) {
                        const buffer = request.$cancellationData;
                        if (buffer === undefined) {
                            return new cancellation_1.CancellationTokenSource();
                        }
                        return new SharedArrayBufferCancellationTokenSource(buffer);
                    }
                    constructor(){
                        this.kind = 'request';
                    }
                }
                exports1.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;
            /***/ },
            /***/ 5501: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_439867__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    var desc = Object.getOwnPropertyDescriptor(m, k);
                    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                        desc = {
                            enumerable: true,
                            get: function() {
                                return m[k];
                            }
                        };
                    }
                    Object.defineProperty(o, k2, desc);
                } : function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    o[k2] = m[k];
                });
                var __exportStar = this && this.__exportStar || function(m, exports1) {
                    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
                };
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createProtocolConnection = void 0;
                const browser_1 = __nested_webpack_require_439867__(9208);
                __exportStar(__nested_webpack_require_439867__(9208), exports1);
                __exportStar(__nested_webpack_require_439867__(3147), exports1);
                function createProtocolConnection(reader, writer, logger, options) {
                    return (0, browser_1.createMessageConnection)(reader, writer, logger, options);
                }
                exports1.createProtocolConnection = createProtocolConnection;
            /***/ },
            /***/ 3147: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_442056__) {
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    var desc = Object.getOwnPropertyDescriptor(m, k);
                    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                        desc = {
                            enumerable: true,
                            get: function() {
                                return m[k];
                            }
                        };
                    }
                    Object.defineProperty(o, k2, desc);
                } : function(o, m, k, k2) {
                    if (k2 === undefined) k2 = k;
                    o[k2] = m[k];
                });
                var __exportStar = this && this.__exportStar || function(m, exports1) {
                    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
                };
                Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.LSPErrorCodes = exports1.createProtocolConnection = void 0;
                __exportStar(__nested_webpack_require_442056__(9110), exports1);
                __exportStar(__nested_webpack_require_442056__(7717), exports1);
                __exportStar(__nested_webpack_require_442056__(8431), exports1);
                __exportStar(__nested_webpack_require_442056__(1815), exports1);
                var connection_1 = __nested_webpack_require_442056__(291);
                Object.defineProperty(exports1, "createProtocolConnection", {
                    enumerable: true,
                    get: function() {
                        return connection_1.createProtocolConnection;
                    }
                });
                var LSPErrorCodes;
                (function(LSPErrorCodes) {
                    /**
    * This is the start range of LSP reserved error codes.
    * It doesn't denote a real error code.
    *
    * @since 3.16.0
    */ LSPErrorCodes.lspReservedErrorRangeStart = -32899;
                    /**
     * A request failed but it was syntactically correct, e.g the
     * method name was known and the parameters were valid. The error
     * message should contain human readable information about why
     * the request failed.
     *
     * @since 3.17.0
     */ LSPErrorCodes.RequestFailed = -32803;
                    /**
     * The server cancelled the request. This error code should
     * only be used for requests that explicitly support being
     * server cancellable.
     *
     * @since 3.17.0
     */ LSPErrorCodes.ServerCancelled = -32802;
                    /**
     * The server detected that the content of a document got
     * modified outside normal conditions. A server should
     * NOT send this error code if it detects a content change
     * in it unprocessed messages. The result even computed
     * on an older state might still be useful for the client.
     *
     * If a client decides that a result is not of any use anymore
     * the client should cancel the request.
     */ LSPErrorCodes.ContentModified = -32801;
                    /**
     * The client has canceled a request and a server as detected
     * the cancel.
     */ LSPErrorCodes.RequestCancelled = -32800;
                    /**
    * This is the end range of LSP reserved error codes.
    * It doesn't denote a real error code.
    *
    * @since 3.16.0
    */ LSPErrorCodes.lspReservedErrorRangeEnd = -32800;
                })(LSPErrorCodes = exports1.LSPErrorCodes || (exports1.LSPErrorCodes = {}));
            /***/ },
            /***/ 291: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_446205__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.createProtocolConnection = void 0;
                const vscode_jsonrpc_1 = __nested_webpack_require_446205__(9110);
                function createProtocolConnection(input, output, logger, options) {
                    if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
                        options = {
                            connectionStrategy: options
                        };
                    }
                    return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);
                }
                exports1.createProtocolConnection = createProtocolConnection;
            /***/ },
            /***/ 8431: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_447442__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ProtocolNotificationType = exports1.ProtocolNotificationType0 = exports1.ProtocolRequestType = exports1.ProtocolRequestType0 = exports1.RegistrationType = exports1.MessageDirection = void 0;
                const vscode_jsonrpc_1 = __nested_webpack_require_447442__(9110);
                var MessageDirection;
                (function(MessageDirection) {
                    MessageDirection["clientToServer"] = "clientToServer";
                    MessageDirection["serverToClient"] = "serverToClient";
                    MessageDirection["both"] = "both";
                })(MessageDirection = exports1.MessageDirection || (exports1.MessageDirection = {}));
                class RegistrationType {
                    constructor(method){
                        this.method = method;
                    }
                }
                exports1.RegistrationType = RegistrationType;
                class ProtocolRequestType0 extends vscode_jsonrpc_1.RequestType0 {
                    constructor(method){
                        super(method);
                    }
                }
                exports1.ProtocolRequestType0 = ProtocolRequestType0;
                class ProtocolRequestType extends vscode_jsonrpc_1.RequestType {
                    constructor(method){
                        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
                    }
                }
                exports1.ProtocolRequestType = ProtocolRequestType;
                class ProtocolNotificationType0 extends vscode_jsonrpc_1.NotificationType0 {
                    constructor(method){
                        super(method);
                    }
                }
                exports1.ProtocolNotificationType0 = ProtocolNotificationType0;
                class ProtocolNotificationType extends vscode_jsonrpc_1.NotificationType {
                    constructor(method){
                        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
                    }
                }
                exports1.ProtocolNotificationType = ProtocolNotificationType;
            /***/ },
            /***/ 7602: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_450168__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox, Microsoft and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.CallHierarchyOutgoingCallsRequest = exports1.CallHierarchyIncomingCallsRequest = exports1.CallHierarchyPrepareRequest = void 0;
                const messages_1 = __nested_webpack_require_450168__(8431);
                /**
 * A request to result a `CallHierarchyItem` in a document at a given position.
 * Can be used as an input to an incoming or outgoing call hierarchy.
 *
 * @since 3.16.0
 */ var CallHierarchyPrepareRequest;
                (function(CallHierarchyPrepareRequest) {
                    CallHierarchyPrepareRequest.method = 'textDocument/prepareCallHierarchy';
                    CallHierarchyPrepareRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CallHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest.method);
                })(CallHierarchyPrepareRequest = exports1.CallHierarchyPrepareRequest || (exports1.CallHierarchyPrepareRequest = {}));
                /**
 * A request to resolve the incoming calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */ var CallHierarchyIncomingCallsRequest;
                (function(CallHierarchyIncomingCallsRequest) {
                    CallHierarchyIncomingCallsRequest.method = 'callHierarchy/incomingCalls';
                    CallHierarchyIncomingCallsRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CallHierarchyIncomingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest.method);
                })(CallHierarchyIncomingCallsRequest = exports1.CallHierarchyIncomingCallsRequest || (exports1.CallHierarchyIncomingCallsRequest = {}));
                /**
 * A request to resolve the outgoing calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */ var CallHierarchyOutgoingCallsRequest;
                (function(CallHierarchyOutgoingCallsRequest) {
                    CallHierarchyOutgoingCallsRequest.method = 'callHierarchy/outgoingCalls';
                    CallHierarchyOutgoingCallsRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CallHierarchyOutgoingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest.method);
                })(CallHierarchyOutgoingCallsRequest = exports1.CallHierarchyOutgoingCallsRequest || (exports1.CallHierarchyOutgoingCallsRequest = {}));
            /***/ },
            /***/ 3747: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_453199__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ColorPresentationRequest = exports1.DocumentColorRequest = void 0;
                const messages_1 = __nested_webpack_require_453199__(8431);
                /**
 * A request to list all color symbols found in a given text document. The request's
 * parameter is of type {@link DocumentColorParams} the
 * response is of type {@link ColorInformation ColorInformation[]} or a Thenable
 * that resolves to such.
 */ var DocumentColorRequest;
                (function(DocumentColorRequest) {
                    DocumentColorRequest.method = 'textDocument/documentColor';
                    DocumentColorRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentColorRequest.type = new messages_1.ProtocolRequestType(DocumentColorRequest.method);
                })(DocumentColorRequest = exports1.DocumentColorRequest || (exports1.DocumentColorRequest = {}));
                /**
 * A request to list all presentation for a color. The request's
 * parameter is of type {@link ColorPresentationParams} the
 * response is of type {@link ColorInformation ColorInformation[]} or a Thenable
 * that resolves to such.
 */ var ColorPresentationRequest;
                (function(ColorPresentationRequest) {
                    ColorPresentationRequest.method = 'textDocument/colorPresentation';
                    ColorPresentationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ColorPresentationRequest.type = new messages_1.ProtocolRequestType(ColorPresentationRequest.method);
                })(ColorPresentationRequest = exports1.ColorPresentationRequest || (exports1.ColorPresentationRequest = {}));
            /***/ },
            /***/ 7639: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_455502__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ConfigurationRequest = void 0;
                const messages_1 = __nested_webpack_require_455502__(8431);
                //---- Get Configuration request ----
                /**
 * The 'workspace/configuration' request is sent from the server to the client to fetch a certain
 * configuration setting.
 *
 * This pull model replaces the old push model were the client signaled configuration change via an
 * event. If the server still needs to react to configuration changes (since the server caches the
 * result of `workspace/configuration` requests) the server should register for an empty configuration
 * change event and empty the cache if such an event is received.
 */ var ConfigurationRequest;
                (function(ConfigurationRequest) {
                    ConfigurationRequest.method = 'workspace/configuration';
                    ConfigurationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    ConfigurationRequest.type = new messages_1.ProtocolRequestType(ConfigurationRequest.method);
                })(ConfigurationRequest = exports1.ConfigurationRequest || (exports1.ConfigurationRequest = {}));
            /***/ },
            /***/ 5581: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_457284__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.DeclarationRequest = void 0;
                const messages_1 = __nested_webpack_require_457284__(8431);
                // @ts-ignore: to avoid inlining LocationLink as dynamic import
                let __noDynamicImport;
                /**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositionParams]
 * (#TextDocumentPositionParams) the response is of type {@link Declaration}
 * or a typed array of {@link DeclarationLink} or a Thenable that resolves
 * to such.
 */ var DeclarationRequest;
                (function(DeclarationRequest) {
                    DeclarationRequest.method = 'textDocument/declaration';
                    DeclarationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DeclarationRequest.type = new messages_1.ProtocolRequestType(DeclarationRequest.method);
                })(DeclarationRequest = exports1.DeclarationRequest || (exports1.DeclarationRequest = {}));
            /***/ },
            /***/ 1494: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_458949__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.DiagnosticRefreshRequest = exports1.WorkspaceDiagnosticRequest = exports1.DocumentDiagnosticRequest = exports1.DocumentDiagnosticReportKind = exports1.DiagnosticServerCancellationData = void 0;
                const vscode_jsonrpc_1 = __nested_webpack_require_458949__(9110);
                const Is = __nested_webpack_require_458949__(8633);
                const messages_1 = __nested_webpack_require_458949__(8431);
                /**
 * @since 3.17.0
 */ var DiagnosticServerCancellationData;
                (function(DiagnosticServerCancellationData) {
                    function is(value) {
                        const candidate = value;
                        return candidate && Is.boolean(candidate.retriggerRequest);
                    }
                    DiagnosticServerCancellationData.is = is;
                })(DiagnosticServerCancellationData = exports1.DiagnosticServerCancellationData || (exports1.DiagnosticServerCancellationData = {}));
                /**
 * The document diagnostic report kinds.
 *
 * @since 3.17.0
 */ var DocumentDiagnosticReportKind;
                (function(DocumentDiagnosticReportKind) {
                    /**
     * A diagnostic report with a full
     * set of problems.
     */ DocumentDiagnosticReportKind.Full = 'full';
                    /**
     * A report indicating that the last
     * returned report is still accurate.
     */ DocumentDiagnosticReportKind.Unchanged = 'unchanged';
                })(DocumentDiagnosticReportKind = exports1.DocumentDiagnosticReportKind || (exports1.DocumentDiagnosticReportKind = {}));
                /**
 * The document diagnostic request definition.
 *
 * @since 3.17.0
 */ var DocumentDiagnosticRequest;
                (function(DocumentDiagnosticRequest) {
                    DocumentDiagnosticRequest.method = 'textDocument/diagnostic';
                    DocumentDiagnosticRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentDiagnosticRequest.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest.method);
                    DocumentDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();
                })(DocumentDiagnosticRequest = exports1.DocumentDiagnosticRequest || (exports1.DocumentDiagnosticRequest = {}));
                /**
 * The workspace diagnostic request definition.
 *
 * @since 3.17.0
 */ var WorkspaceDiagnosticRequest;
                (function(WorkspaceDiagnosticRequest) {
                    WorkspaceDiagnosticRequest.method = 'workspace/diagnostic';
                    WorkspaceDiagnosticRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WorkspaceDiagnosticRequest.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest.method);
                    WorkspaceDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();
                })(WorkspaceDiagnosticRequest = exports1.WorkspaceDiagnosticRequest || (exports1.WorkspaceDiagnosticRequest = {}));
                /**
 * The diagnostic refresh request definition.
 *
 * @since 3.17.0
 */ var DiagnosticRefreshRequest;
                (function(DiagnosticRefreshRequest) {
                    DiagnosticRefreshRequest.method = `workspace/diagnostic/refresh`;
                    DiagnosticRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    DiagnosticRefreshRequest.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest.method);
                })(DiagnosticRefreshRequest = exports1.DiagnosticRefreshRequest || (exports1.DiagnosticRefreshRequest = {}));
            /***/ },
            /***/ 4781: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_463193__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WillDeleteFilesRequest = exports1.DidDeleteFilesNotification = exports1.DidRenameFilesNotification = exports1.WillRenameFilesRequest = exports1.DidCreateFilesNotification = exports1.WillCreateFilesRequest = exports1.FileOperationPatternKind = void 0;
                const messages_1 = __nested_webpack_require_463193__(8431);
                /**
 * A pattern kind describing if a glob pattern matches a file a folder or
 * both.
 *
 * @since 3.16.0
 */ var FileOperationPatternKind;
                (function(FileOperationPatternKind) {
                    /**
     * The pattern matches a file only.
     */ FileOperationPatternKind.file = 'file';
                    /**
     * The pattern matches a folder only.
     */ FileOperationPatternKind.folder = 'folder';
                })(FileOperationPatternKind = exports1.FileOperationPatternKind || (exports1.FileOperationPatternKind = {}));
                /**
 * The will create files request is sent from the client to the server before files are actually
 * created as long as the creation is triggered from within the client.
 *
 * The request can return a `WorkspaceEdit` which will be applied to workspace before the
 * files are created. Hence the `WorkspaceEdit` can not manipulate the content of the file
 * to be created.
 *
 * @since 3.16.0
 */ var WillCreateFilesRequest;
                (function(WillCreateFilesRequest) {
                    WillCreateFilesRequest.method = 'workspace/willCreateFiles';
                    WillCreateFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillCreateFilesRequest.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest.method);
                })(WillCreateFilesRequest = exports1.WillCreateFilesRequest || (exports1.WillCreateFilesRequest = {}));
                /**
 * The did create files notification is sent from the client to the server when
 * files were created from within the client.
 *
 * @since 3.16.0
 */ var DidCreateFilesNotification;
                (function(DidCreateFilesNotification) {
                    DidCreateFilesNotification.method = 'workspace/didCreateFiles';
                    DidCreateFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidCreateFilesNotification.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification.method);
                })(DidCreateFilesNotification = exports1.DidCreateFilesNotification || (exports1.DidCreateFilesNotification = {}));
                /**
 * The will rename files request is sent from the client to the server before files are actually
 * renamed as long as the rename is triggered from within the client.
 *
 * @since 3.16.0
 */ var WillRenameFilesRequest;
                (function(WillRenameFilesRequest) {
                    WillRenameFilesRequest.method = 'workspace/willRenameFiles';
                    WillRenameFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillRenameFilesRequest.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest.method);
                })(WillRenameFilesRequest = exports1.WillRenameFilesRequest || (exports1.WillRenameFilesRequest = {}));
                /**
 * The did rename files notification is sent from the client to the server when
 * files were renamed from within the client.
 *
 * @since 3.16.0
 */ var DidRenameFilesNotification;
                (function(DidRenameFilesNotification) {
                    DidRenameFilesNotification.method = 'workspace/didRenameFiles';
                    DidRenameFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidRenameFilesNotification.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification.method);
                })(DidRenameFilesNotification = exports1.DidRenameFilesNotification || (exports1.DidRenameFilesNotification = {}));
                /**
 * The will delete files request is sent from the client to the server before files are actually
 * deleted as long as the deletion is triggered from within the client.
 *
 * @since 3.16.0
 */ var DidDeleteFilesNotification;
                (function(DidDeleteFilesNotification) {
                    DidDeleteFilesNotification.method = 'workspace/didDeleteFiles';
                    DidDeleteFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidDeleteFilesNotification.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification.method);
                })(DidDeleteFilesNotification = exports1.DidDeleteFilesNotification || (exports1.DidDeleteFilesNotification = {}));
                /**
 * The did delete files notification is sent from the client to the server when
 * files were deleted from within the client.
 *
 * @since 3.16.0
 */ var WillDeleteFilesRequest;
                (function(WillDeleteFilesRequest) {
                    WillDeleteFilesRequest.method = 'workspace/willDeleteFiles';
                    WillDeleteFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillDeleteFilesRequest.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest.method);
                })(WillDeleteFilesRequest = exports1.WillDeleteFilesRequest || (exports1.WillDeleteFilesRequest = {}));
            /***/ },
            /***/ 1203: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_469198__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.FoldingRangeRequest = void 0;
                const messages_1 = __nested_webpack_require_469198__(8431);
                /**
 * A request to provide folding ranges in a document. The request's
 * parameter is of type {@link FoldingRangeParams}, the
 * response is of type {@link FoldingRangeList} or a Thenable
 * that resolves to such.
 */ var FoldingRangeRequest;
                (function(FoldingRangeRequest) {
                    FoldingRangeRequest.method = 'textDocument/foldingRange';
                    FoldingRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    FoldingRangeRequest.type = new messages_1.ProtocolRequestType(FoldingRangeRequest.method);
                })(FoldingRangeRequest = exports1.FoldingRangeRequest || (exports1.FoldingRangeRequest = {}));
            /***/ },
            /***/ 7287: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_470637__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ImplementationRequest = void 0;
                const messages_1 = __nested_webpack_require_470637__(8431);
                // @ts-ignore: to avoid inlining LocationLink as dynamic import
                let __noDynamicImport;
                /**
 * A request to resolve the implementation locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositionParams]
 * (#TextDocumentPositionParams) the response is of type {@link Definition} or a
 * Thenable that resolves to such.
 */ var ImplementationRequest;
                (function(ImplementationRequest) {
                    ImplementationRequest.method = 'textDocument/implementation';
                    ImplementationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ImplementationRequest.type = new messages_1.ProtocolRequestType(ImplementationRequest.method);
                })(ImplementationRequest = exports1.ImplementationRequest || (exports1.ImplementationRequest = {}));
            /***/ },
            /***/ 9383: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_472286__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.InlayHintRefreshRequest = exports1.InlayHintResolveRequest = exports1.InlayHintRequest = void 0;
                const messages_1 = __nested_webpack_require_472286__(8431);
                /**
 * A request to provide inlay hints in a document. The request's parameter is of
 * type {@link InlayHintsParams}, the response is of type
 * {@link InlayHint InlayHint[]} or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */ var InlayHintRequest;
                (function(InlayHintRequest) {
                    InlayHintRequest.method = 'textDocument/inlayHint';
                    InlayHintRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InlayHintRequest.type = new messages_1.ProtocolRequestType(InlayHintRequest.method);
                })(InlayHintRequest = exports1.InlayHintRequest || (exports1.InlayHintRequest = {}));
                /**
 * A request to resolve additional properties for an inlay hint.
 * The request's parameter is of type {@link InlayHint}, the response is
 * of type {@link InlayHint} or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */ var InlayHintResolveRequest;
                (function(InlayHintResolveRequest) {
                    InlayHintResolveRequest.method = 'inlayHint/resolve';
                    InlayHintResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InlayHintResolveRequest.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest.method);
                })(InlayHintResolveRequest = exports1.InlayHintResolveRequest || (exports1.InlayHintResolveRequest = {}));
                /**
 * @since 3.17.0
 */ var InlayHintRefreshRequest;
                (function(InlayHintRefreshRequest) {
                    InlayHintRefreshRequest.method = `workspace/inlayHint/refresh`;
                    InlayHintRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    InlayHintRefreshRequest.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest.method);
                })(InlayHintRefreshRequest = exports1.InlayHintRefreshRequest || (exports1.InlayHintRefreshRequest = {}));
            /***/ },
            /***/ 3491: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_475089__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.InlineValueRefreshRequest = exports1.InlineValueRequest = void 0;
                const messages_1 = __nested_webpack_require_475089__(8431);
                /**
 * A request to provide inline values in a document. The request's parameter is of
 * type {@link InlineValueParams}, the response is of type
 * {@link InlineValue InlineValue[]} or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */ var InlineValueRequest;
                (function(InlineValueRequest) {
                    InlineValueRequest.method = 'textDocument/inlineValue';
                    InlineValueRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InlineValueRequest.type = new messages_1.ProtocolRequestType(InlineValueRequest.method);
                })(InlineValueRequest = exports1.InlineValueRequest || (exports1.InlineValueRequest = {}));
                /**
 * @since 3.17.0
 */ var InlineValueRefreshRequest;
                (function(InlineValueRefreshRequest) {
                    InlineValueRefreshRequest.method = `workspace/inlineValue/refresh`;
                    InlineValueRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    InlineValueRefreshRequest.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest.method);
                })(InlineValueRefreshRequest = exports1.InlineValueRefreshRequest || (exports1.InlineValueRefreshRequest = {}));
            /***/ },
            /***/ 1815: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_477155__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WorkspaceSymbolRequest = exports1.CodeActionResolveRequest = exports1.CodeActionRequest = exports1.DocumentSymbolRequest = exports1.DocumentHighlightRequest = exports1.ReferencesRequest = exports1.DefinitionRequest = exports1.SignatureHelpRequest = exports1.SignatureHelpTriggerKind = exports1.HoverRequest = exports1.CompletionResolveRequest = exports1.CompletionRequest = exports1.CompletionTriggerKind = exports1.PublishDiagnosticsNotification = exports1.WatchKind = exports1.RelativePattern = exports1.FileChangeType = exports1.DidChangeWatchedFilesNotification = exports1.WillSaveTextDocumentWaitUntilRequest = exports1.WillSaveTextDocumentNotification = exports1.TextDocumentSaveReason = exports1.DidSaveTextDocumentNotification = exports1.DidCloseTextDocumentNotification = exports1.DidChangeTextDocumentNotification = exports1.TextDocumentContentChangeEvent = exports1.DidOpenTextDocumentNotification = exports1.TextDocumentSyncKind = exports1.TelemetryEventNotification = exports1.LogMessageNotification = exports1.ShowMessageRequest = exports1.ShowMessageNotification = exports1.MessageType = exports1.DidChangeConfigurationNotification = exports1.ExitNotification = exports1.ShutdownRequest = exports1.InitializedNotification = exports1.InitializeErrorCodes = exports1.InitializeRequest = exports1.WorkDoneProgressOptions = exports1.TextDocumentRegistrationOptions = exports1.StaticRegistrationOptions = exports1.PositionEncodingKind = exports1.FailureHandlingKind = exports1.ResourceOperationKind = exports1.UnregistrationRequest = exports1.RegistrationRequest = exports1.DocumentSelector = exports1.NotebookCellTextDocumentFilter = exports1.NotebookDocumentFilter = exports1.TextDocumentFilter = void 0;
                exports1.TypeHierarchySubtypesRequest = exports1.TypeHierarchyPrepareRequest = exports1.MonikerRequest = exports1.MonikerKind = exports1.UniquenessLevel = exports1.WillDeleteFilesRequest = exports1.DidDeleteFilesNotification = exports1.WillRenameFilesRequest = exports1.DidRenameFilesNotification = exports1.WillCreateFilesRequest = exports1.DidCreateFilesNotification = exports1.FileOperationPatternKind = exports1.LinkedEditingRangeRequest = exports1.ShowDocumentRequest = exports1.SemanticTokensRegistrationType = exports1.SemanticTokensRefreshRequest = exports1.SemanticTokensRangeRequest = exports1.SemanticTokensDeltaRequest = exports1.SemanticTokensRequest = exports1.TokenFormat = exports1.CallHierarchyPrepareRequest = exports1.CallHierarchyOutgoingCallsRequest = exports1.CallHierarchyIncomingCallsRequest = exports1.WorkDoneProgressCancelNotification = exports1.WorkDoneProgressCreateRequest = exports1.WorkDoneProgress = exports1.SelectionRangeRequest = exports1.DeclarationRequest = exports1.FoldingRangeRequest = exports1.ColorPresentationRequest = exports1.DocumentColorRequest = exports1.ConfigurationRequest = exports1.DidChangeWorkspaceFoldersNotification = exports1.WorkspaceFoldersRequest = exports1.TypeDefinitionRequest = exports1.ImplementationRequest = exports1.ApplyWorkspaceEditRequest = exports1.ExecuteCommandRequest = exports1.PrepareRenameRequest = exports1.RenameRequest = exports1.PrepareSupportDefaultBehavior = exports1.DocumentOnTypeFormattingRequest = exports1.DocumentRangeFormattingRequest = exports1.DocumentFormattingRequest = exports1.DocumentLinkResolveRequest = exports1.DocumentLinkRequest = exports1.CodeLensRefreshRequest = exports1.CodeLensResolveRequest = exports1.CodeLensRequest = exports1.WorkspaceSymbolResolveRequest = void 0;
                exports1.DidCloseNotebookDocumentNotification = exports1.DidSaveNotebookDocumentNotification = exports1.DidChangeNotebookDocumentNotification = exports1.NotebookCellArrayChange = exports1.DidOpenNotebookDocumentNotification = exports1.NotebookDocumentSyncRegistrationType = exports1.NotebookDocument = exports1.NotebookCell = exports1.ExecutionSummary = exports1.NotebookCellKind = exports1.DiagnosticRefreshRequest = exports1.WorkspaceDiagnosticRequest = exports1.DocumentDiagnosticRequest = exports1.DocumentDiagnosticReportKind = exports1.DiagnosticServerCancellationData = exports1.InlayHintRefreshRequest = exports1.InlayHintResolveRequest = exports1.InlayHintRequest = exports1.InlineValueRefreshRequest = exports1.InlineValueRequest = exports1.TypeHierarchySupertypesRequest = void 0;
                const messages_1 = __nested_webpack_require_477155__(8431);
                const vscode_languageserver_types_1 = __nested_webpack_require_477155__(7717);
                const Is = __nested_webpack_require_477155__(8633);
                const protocol_implementation_1 = __nested_webpack_require_477155__(7287);
                Object.defineProperty(exports1, "ImplementationRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_implementation_1.ImplementationRequest;
                    }
                });
                const protocol_typeDefinition_1 = __nested_webpack_require_477155__(9264);
                Object.defineProperty(exports1, "TypeDefinitionRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_typeDefinition_1.TypeDefinitionRequest;
                    }
                });
                const protocol_workspaceFolder_1 = __nested_webpack_require_477155__(6860);
                Object.defineProperty(exports1, "WorkspaceFoldersRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_workspaceFolder_1.WorkspaceFoldersRequest;
                    }
                });
                Object.defineProperty(exports1, "DidChangeWorkspaceFoldersNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification;
                    }
                });
                const protocol_configuration_1 = __nested_webpack_require_477155__(7639);
                Object.defineProperty(exports1, "ConfigurationRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_configuration_1.ConfigurationRequest;
                    }
                });
                const protocol_colorProvider_1 = __nested_webpack_require_477155__(3747);
                Object.defineProperty(exports1, "DocumentColorRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_colorProvider_1.DocumentColorRequest;
                    }
                });
                Object.defineProperty(exports1, "ColorPresentationRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_colorProvider_1.ColorPresentationRequest;
                    }
                });
                const protocol_foldingRange_1 = __nested_webpack_require_477155__(1203);
                Object.defineProperty(exports1, "FoldingRangeRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_foldingRange_1.FoldingRangeRequest;
                    }
                });
                const protocol_declaration_1 = __nested_webpack_require_477155__(5581);
                Object.defineProperty(exports1, "DeclarationRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_declaration_1.DeclarationRequest;
                    }
                });
                const protocol_selectionRange_1 = __nested_webpack_require_477155__(1530);
                Object.defineProperty(exports1, "SelectionRangeRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_selectionRange_1.SelectionRangeRequest;
                    }
                });
                const protocol_progress_1 = __nested_webpack_require_477155__(4166);
                Object.defineProperty(exports1, "WorkDoneProgress", {
                    enumerable: true,
                    get: function() {
                        return protocol_progress_1.WorkDoneProgress;
                    }
                });
                Object.defineProperty(exports1, "WorkDoneProgressCreateRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_progress_1.WorkDoneProgressCreateRequest;
                    }
                });
                Object.defineProperty(exports1, "WorkDoneProgressCancelNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_progress_1.WorkDoneProgressCancelNotification;
                    }
                });
                const protocol_callHierarchy_1 = __nested_webpack_require_477155__(7602);
                Object.defineProperty(exports1, "CallHierarchyIncomingCallsRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
                    }
                });
                Object.defineProperty(exports1, "CallHierarchyOutgoingCallsRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
                    }
                });
                Object.defineProperty(exports1, "CallHierarchyPrepareRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
                    }
                });
                const protocol_semanticTokens_1 = __nested_webpack_require_477155__(2067);
                Object.defineProperty(exports1, "TokenFormat", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.TokenFormat;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensRequest;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensDeltaRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensRangeRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensRangeRequest;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensRefreshRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
                    }
                });
                Object.defineProperty(exports1, "SemanticTokensRegistrationType", {
                    enumerable: true,
                    get: function() {
                        return protocol_semanticTokens_1.SemanticTokensRegistrationType;
                    }
                });
                const protocol_showDocument_1 = __nested_webpack_require_477155__(4333);
                Object.defineProperty(exports1, "ShowDocumentRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_showDocument_1.ShowDocumentRequest;
                    }
                });
                const protocol_linkedEditingRange_1 = __nested_webpack_require_477155__(2249);
                Object.defineProperty(exports1, "LinkedEditingRangeRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
                    }
                });
                const protocol_fileOperations_1 = __nested_webpack_require_477155__(4781);
                Object.defineProperty(exports1, "FileOperationPatternKind", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.FileOperationPatternKind;
                    }
                });
                Object.defineProperty(exports1, "DidCreateFilesNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.DidCreateFilesNotification;
                    }
                });
                Object.defineProperty(exports1, "WillCreateFilesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.WillCreateFilesRequest;
                    }
                });
                Object.defineProperty(exports1, "DidRenameFilesNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.DidRenameFilesNotification;
                    }
                });
                Object.defineProperty(exports1, "WillRenameFilesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.WillRenameFilesRequest;
                    }
                });
                Object.defineProperty(exports1, "DidDeleteFilesNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.DidDeleteFilesNotification;
                    }
                });
                Object.defineProperty(exports1, "WillDeleteFilesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_fileOperations_1.WillDeleteFilesRequest;
                    }
                });
                const protocol_moniker_1 = __nested_webpack_require_477155__(7684);
                Object.defineProperty(exports1, "UniquenessLevel", {
                    enumerable: true,
                    get: function() {
                        return protocol_moniker_1.UniquenessLevel;
                    }
                });
                Object.defineProperty(exports1, "MonikerKind", {
                    enumerable: true,
                    get: function() {
                        return protocol_moniker_1.MonikerKind;
                    }
                });
                Object.defineProperty(exports1, "MonikerRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_moniker_1.MonikerRequest;
                    }
                });
                const protocol_typeHierarchy_1 = __nested_webpack_require_477155__(7062);
                Object.defineProperty(exports1, "TypeHierarchyPrepareRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest;
                    }
                });
                Object.defineProperty(exports1, "TypeHierarchySubtypesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest;
                    }
                });
                Object.defineProperty(exports1, "TypeHierarchySupertypesRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest;
                    }
                });
                const protocol_inlineValue_1 = __nested_webpack_require_477155__(3491);
                Object.defineProperty(exports1, "InlineValueRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlineValue_1.InlineValueRequest;
                    }
                });
                Object.defineProperty(exports1, "InlineValueRefreshRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlineValue_1.InlineValueRefreshRequest;
                    }
                });
                const protocol_inlayHint_1 = __nested_webpack_require_477155__(9383);
                Object.defineProperty(exports1, "InlayHintRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlayHint_1.InlayHintRequest;
                    }
                });
                Object.defineProperty(exports1, "InlayHintResolveRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlayHint_1.InlayHintResolveRequest;
                    }
                });
                Object.defineProperty(exports1, "InlayHintRefreshRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_inlayHint_1.InlayHintRefreshRequest;
                    }
                });
                const protocol_diagnostic_1 = __nested_webpack_require_477155__(1494);
                Object.defineProperty(exports1, "DiagnosticServerCancellationData", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.DiagnosticServerCancellationData;
                    }
                });
                Object.defineProperty(exports1, "DocumentDiagnosticReportKind", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.DocumentDiagnosticReportKind;
                    }
                });
                Object.defineProperty(exports1, "DocumentDiagnosticRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.DocumentDiagnosticRequest;
                    }
                });
                Object.defineProperty(exports1, "WorkspaceDiagnosticRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.WorkspaceDiagnosticRequest;
                    }
                });
                Object.defineProperty(exports1, "DiagnosticRefreshRequest", {
                    enumerable: true,
                    get: function() {
                        return protocol_diagnostic_1.DiagnosticRefreshRequest;
                    }
                });
                const protocol_notebook_1 = __nested_webpack_require_477155__(4792);
                Object.defineProperty(exports1, "NotebookCellKind", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookCellKind;
                    }
                });
                Object.defineProperty(exports1, "ExecutionSummary", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.ExecutionSummary;
                    }
                });
                Object.defineProperty(exports1, "NotebookCell", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookCell;
                    }
                });
                Object.defineProperty(exports1, "NotebookDocument", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookDocument;
                    }
                });
                Object.defineProperty(exports1, "NotebookDocumentSyncRegistrationType", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookDocumentSyncRegistrationType;
                    }
                });
                Object.defineProperty(exports1, "DidOpenNotebookDocumentNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.DidOpenNotebookDocumentNotification;
                    }
                });
                Object.defineProperty(exports1, "NotebookCellArrayChange", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.NotebookCellArrayChange;
                    }
                });
                Object.defineProperty(exports1, "DidChangeNotebookDocumentNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.DidChangeNotebookDocumentNotification;
                    }
                });
                Object.defineProperty(exports1, "DidSaveNotebookDocumentNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.DidSaveNotebookDocumentNotification;
                    }
                });
                Object.defineProperty(exports1, "DidCloseNotebookDocumentNotification", {
                    enumerable: true,
                    get: function() {
                        return protocol_notebook_1.DidCloseNotebookDocumentNotification;
                    }
                });
                // @ts-ignore: to avoid inlining LocationLink as dynamic import
                let __noDynamicImport;
                /**
 * The TextDocumentFilter namespace provides helper functions to work with
 * {@link TextDocumentFilter} literals.
 *
 * @since 3.17.0
 */ var TextDocumentFilter;
                (function(TextDocumentFilter) {
                    function is(value) {
                        const candidate = value;
                        return Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern);
                    }
                    TextDocumentFilter.is = is;
                })(TextDocumentFilter = exports1.TextDocumentFilter || (exports1.TextDocumentFilter = {}));
                /**
 * The NotebookDocumentFilter namespace provides helper functions to work with
 * {@link NotebookDocumentFilter} literals.
 *
 * @since 3.17.0
 */ var NotebookDocumentFilter;
                (function(NotebookDocumentFilter) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && (Is.string(candidate.notebookType) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
                    }
                    NotebookDocumentFilter.is = is;
                })(NotebookDocumentFilter = exports1.NotebookDocumentFilter || (exports1.NotebookDocumentFilter = {}));
                /**
 * The NotebookCellTextDocumentFilter namespace provides helper functions to work with
 * {@link NotebookCellTextDocumentFilter} literals.
 *
 * @since 3.17.0
 */ var NotebookCellTextDocumentFilter;
                (function(NotebookCellTextDocumentFilter) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && (Is.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook)) && (candidate.language === undefined || Is.string(candidate.language));
                    }
                    NotebookCellTextDocumentFilter.is = is;
                })(NotebookCellTextDocumentFilter = exports1.NotebookCellTextDocumentFilter || (exports1.NotebookCellTextDocumentFilter = {}));
                /**
 * The DocumentSelector namespace provides helper functions to work with
 * {@link DocumentSelector}s.
 */ var DocumentSelector;
                (function(DocumentSelector) {
                    function is(value) {
                        if (!Array.isArray(value)) {
                            return false;
                        }
                        for (let elem of value){
                            if (!Is.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
                                return false;
                            }
                        }
                        return true;
                    }
                    DocumentSelector.is = is;
                })(DocumentSelector = exports1.DocumentSelector || (exports1.DocumentSelector = {}));
                /**
 * The `client/registerCapability` request is sent from the server to the client to register a new capability
 * handler on the client side.
 */ var RegistrationRequest;
                (function(RegistrationRequest) {
                    RegistrationRequest.method = 'client/registerCapability';
                    RegistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    RegistrationRequest.type = new messages_1.ProtocolRequestType(RegistrationRequest.method);
                })(RegistrationRequest = exports1.RegistrationRequest || (exports1.RegistrationRequest = {}));
                /**
 * The `client/unregisterCapability` request is sent from the server to the client to unregister a previously registered capability
 * handler on the client side.
 */ var UnregistrationRequest;
                (function(UnregistrationRequest) {
                    UnregistrationRequest.method = 'client/unregisterCapability';
                    UnregistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    UnregistrationRequest.type = new messages_1.ProtocolRequestType(UnregistrationRequest.method);
                })(UnregistrationRequest = exports1.UnregistrationRequest || (exports1.UnregistrationRequest = {}));
                var ResourceOperationKind;
                (function(ResourceOperationKind) {
                    /**
     * Supports creating new files and folders.
     */ ResourceOperationKind.Create = 'create';
                    /**
     * Supports renaming existing files and folders.
     */ ResourceOperationKind.Rename = 'rename';
                    /**
     * Supports deleting existing files and folders.
     */ ResourceOperationKind.Delete = 'delete';
                })(ResourceOperationKind = exports1.ResourceOperationKind || (exports1.ResourceOperationKind = {}));
                var FailureHandlingKind;
                (function(FailureHandlingKind) {
                    /**
     * Applying the workspace change is simply aborted if one of the changes provided
     * fails. All operations executed before the failing operation stay executed.
     */ FailureHandlingKind.Abort = 'abort';
                    /**
     * All operations are executed transactional. That means they either all
     * succeed or no changes at all are applied to the workspace.
     */ FailureHandlingKind.Transactional = 'transactional';
                    /**
     * If the workspace edit contains only textual file changes they are executed transactional.
     * If resource changes (create, rename or delete file) are part of the change the failure
     * handling strategy is abort.
     */ FailureHandlingKind.TextOnlyTransactional = 'textOnlyTransactional';
                    /**
     * The client tries to undo the operations already executed. But there is no
     * guarantee that this is succeeding.
     */ FailureHandlingKind.Undo = 'undo';
                })(FailureHandlingKind = exports1.FailureHandlingKind || (exports1.FailureHandlingKind = {}));
                /**
 * A set of predefined position encoding kinds.
 *
 * @since 3.17.0
 */ var PositionEncodingKind;
                (function(PositionEncodingKind) {
                    /**
     * Character offsets count UTF-8 code units (e.g. bytes).
     */ PositionEncodingKind.UTF8 = 'utf-8';
                    /**
     * Character offsets count UTF-16 code units.
     *
     * This is the default and must always be supported
     * by servers
     */ PositionEncodingKind.UTF16 = 'utf-16';
                    /**
     * Character offsets count UTF-32 code units.
     *
     * Implementation note: these are the same as Unicode codepoints,
     * so this `PositionEncodingKind` may also be used for an
     * encoding-agnostic representation of character offsets.
     */ PositionEncodingKind.UTF32 = 'utf-32';
                })(PositionEncodingKind = exports1.PositionEncodingKind || (exports1.PositionEncodingKind = {}));
                /**
 * The StaticRegistrationOptions namespace provides helper functions to work with
 * {@link StaticRegistrationOptions} literals.
 */ var StaticRegistrationOptions;
                (function(StaticRegistrationOptions) {
                    function hasId(value) {
                        const candidate = value;
                        return candidate && Is.string(candidate.id) && candidate.id.length > 0;
                    }
                    StaticRegistrationOptions.hasId = hasId;
                })(StaticRegistrationOptions = exports1.StaticRegistrationOptions || (exports1.StaticRegistrationOptions = {}));
                /**
 * The TextDocumentRegistrationOptions namespace provides helper functions to work with
 * {@link TextDocumentRegistrationOptions} literals.
 */ var TextDocumentRegistrationOptions;
                (function(TextDocumentRegistrationOptions) {
                    function is(value) {
                        const candidate = value;
                        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
                    }
                    TextDocumentRegistrationOptions.is = is;
                })(TextDocumentRegistrationOptions = exports1.TextDocumentRegistrationOptions || (exports1.TextDocumentRegistrationOptions = {}));
                /**
 * The WorkDoneProgressOptions namespace provides helper functions to work with
 * {@link WorkDoneProgressOptions} literals.
 */ var WorkDoneProgressOptions;
                (function(WorkDoneProgressOptions) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === undefined || Is.boolean(candidate.workDoneProgress));
                    }
                    WorkDoneProgressOptions.is = is;
                    function hasWorkDoneProgress(value) {
                        const candidate = value;
                        return candidate && Is.boolean(candidate.workDoneProgress);
                    }
                    WorkDoneProgressOptions.hasWorkDoneProgress = hasWorkDoneProgress;
                })(WorkDoneProgressOptions = exports1.WorkDoneProgressOptions || (exports1.WorkDoneProgressOptions = {}));
                /**
 * The initialize request is sent from the client to the server.
 * It is sent once as the request after starting up the server.
 * The requests parameter is of type {@link InitializeParams}
 * the response if of type {@link InitializeResult} of a Thenable that
 * resolves to such.
 */ var InitializeRequest;
                (function(InitializeRequest) {
                    InitializeRequest.method = 'initialize';
                    InitializeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    InitializeRequest.type = new messages_1.ProtocolRequestType(InitializeRequest.method);
                })(InitializeRequest = exports1.InitializeRequest || (exports1.InitializeRequest = {}));
                /**
 * Known error codes for an `InitializeErrorCodes`;
 */ var InitializeErrorCodes;
                (function(InitializeErrorCodes) {
                    /**
     * If the protocol version provided by the client can't be handled by the server.
     *
     * @deprecated This initialize error got replaced by client capabilities. There is
     * no version handshake in version 3.0x
     */ InitializeErrorCodes.unknownProtocolVersion = 1;
                })(InitializeErrorCodes = exports1.InitializeErrorCodes || (exports1.InitializeErrorCodes = {}));
                /**
 * The initialized notification is sent from the client to the
 * server after the client is fully initialized and the server
 * is allowed to send requests from the server to the client.
 */ var InitializedNotification;
                (function(InitializedNotification) {
                    InitializedNotification.method = 'initialized';
                    InitializedNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    InitializedNotification.type = new messages_1.ProtocolNotificationType(InitializedNotification.method);
                })(InitializedNotification = exports1.InitializedNotification || (exports1.InitializedNotification = {}));
                //---- Shutdown Method ----
                /**
 * A shutdown request is sent from the client to the server.
 * It is sent once when the client decides to shutdown the
 * server. The only notification that is sent after a shutdown request
 * is the exit event.
 */ var ShutdownRequest;
                (function(ShutdownRequest) {
                    ShutdownRequest.method = 'shutdown';
                    ShutdownRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ShutdownRequest.type = new messages_1.ProtocolRequestType0(ShutdownRequest.method);
                })(ShutdownRequest = exports1.ShutdownRequest || (exports1.ShutdownRequest = {}));
                //---- Exit Notification ----
                /**
 * The exit event is sent from the client to the server to
 * ask the server to exit its process.
 */ var ExitNotification;
                (function(ExitNotification) {
                    ExitNotification.method = 'exit';
                    ExitNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    ExitNotification.type = new messages_1.ProtocolNotificationType0(ExitNotification.method);
                })(ExitNotification = exports1.ExitNotification || (exports1.ExitNotification = {}));
                /**
 * The configuration change notification is sent from the client to the server
 * when the client's configuration has changed. The notification contains
 * the changed configuration as defined by the language client.
 */ var DidChangeConfigurationNotification;
                (function(DidChangeConfigurationNotification) {
                    DidChangeConfigurationNotification.method = 'workspace/didChangeConfiguration';
                    DidChangeConfigurationNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeConfigurationNotification.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification.method);
                })(DidChangeConfigurationNotification = exports1.DidChangeConfigurationNotification || (exports1.DidChangeConfigurationNotification = {}));
                //---- Message show and log notifications ----
                /**
 * The message type
 */ var MessageType;
                (function(MessageType) {
                    /**
     * An error message.
     */ MessageType.Error = 1;
                    /**
     * A warning message.
     */ MessageType.Warning = 2;
                    /**
     * An information message.
     */ MessageType.Info = 3;
                    /**
     * A log message.
     */ MessageType.Log = 4;
                })(MessageType = exports1.MessageType || (exports1.MessageType = {}));
                /**
 * The show message notification is sent from a server to a client to ask
 * the client to display a particular message in the user interface.
 */ var ShowMessageNotification;
                (function(ShowMessageNotification) {
                    ShowMessageNotification.method = 'window/showMessage';
                    ShowMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;
                    ShowMessageNotification.type = new messages_1.ProtocolNotificationType(ShowMessageNotification.method);
                })(ShowMessageNotification = exports1.ShowMessageNotification || (exports1.ShowMessageNotification = {}));
                /**
 * The show message request is sent from the server to the client to show a message
 * and a set of options actions to the user.
 */ var ShowMessageRequest;
                (function(ShowMessageRequest) {
                    ShowMessageRequest.method = 'window/showMessageRequest';
                    ShowMessageRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    ShowMessageRequest.type = new messages_1.ProtocolRequestType(ShowMessageRequest.method);
                })(ShowMessageRequest = exports1.ShowMessageRequest || (exports1.ShowMessageRequest = {}));
                /**
 * The log message notification is sent from the server to the client to ask
 * the client to log a particular message.
 */ var LogMessageNotification;
                (function(LogMessageNotification) {
                    LogMessageNotification.method = 'window/logMessage';
                    LogMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;
                    LogMessageNotification.type = new messages_1.ProtocolNotificationType(LogMessageNotification.method);
                })(LogMessageNotification = exports1.LogMessageNotification || (exports1.LogMessageNotification = {}));
                //---- Telemetry notification
                /**
 * The telemetry event notification is sent from the server to the client to ask
 * the client to log telemetry data.
 */ var TelemetryEventNotification;
                (function(TelemetryEventNotification) {
                    TelemetryEventNotification.method = 'telemetry/event';
                    TelemetryEventNotification.messageDirection = messages_1.MessageDirection.serverToClient;
                    TelemetryEventNotification.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification.method);
                })(TelemetryEventNotification = exports1.TelemetryEventNotification || (exports1.TelemetryEventNotification = {}));
                /**
 * Defines how the host (editor) should sync
 * document changes to the language server.
 */ var TextDocumentSyncKind;
                (function(TextDocumentSyncKind) {
                    /**
     * Documents should not be synced at all.
     */ TextDocumentSyncKind.None = 0;
                    /**
     * Documents are synced by always sending the full content
     * of the document.
     */ TextDocumentSyncKind.Full = 1;
                    /**
     * Documents are synced by sending the full content on open.
     * After that only incremental updates to the document are
     * send.
     */ TextDocumentSyncKind.Incremental = 2;
                })(TextDocumentSyncKind = exports1.TextDocumentSyncKind || (exports1.TextDocumentSyncKind = {}));
                /**
 * The document open notification is sent from the client to the server to signal
 * newly opened text documents. The document's truth is now managed by the client
 * and the server must not try to read the document's truth using the document's
 * uri. Open in this sense means it is managed by the client. It doesn't necessarily
 * mean that its content is presented in an editor. An open notification must not
 * be sent more than once without a corresponding close notification send before.
 * This means open and close notification must be balanced and the max open count
 * is one.
 */ var DidOpenTextDocumentNotification;
                (function(DidOpenTextDocumentNotification) {
                    DidOpenTextDocumentNotification.method = 'textDocument/didOpen';
                    DidOpenTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidOpenTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification.method);
                })(DidOpenTextDocumentNotification = exports1.DidOpenTextDocumentNotification || (exports1.DidOpenTextDocumentNotification = {}));
                var TextDocumentContentChangeEvent;
                (function(TextDocumentContentChangeEvent) {
                    /**
     * Checks whether the information describes a delta event.
     */ function isIncremental(event) {
                        let candidate = event;
                        return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range !== undefined && (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
                    }
                    TextDocumentContentChangeEvent.isIncremental = isIncremental;
                    /**
     * Checks whether the information describes a full replacement event.
     */ function isFull(event) {
                        let candidate = event;
                        return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
                    }
                    TextDocumentContentChangeEvent.isFull = isFull;
                })(TextDocumentContentChangeEvent = exports1.TextDocumentContentChangeEvent || (exports1.TextDocumentContentChangeEvent = {}));
                /**
 * The document change notification is sent from the client to the server to signal
 * changes to a text document.
 */ var DidChangeTextDocumentNotification;
                (function(DidChangeTextDocumentNotification) {
                    DidChangeTextDocumentNotification.method = 'textDocument/didChange';
                    DidChangeTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification.method);
                })(DidChangeTextDocumentNotification = exports1.DidChangeTextDocumentNotification || (exports1.DidChangeTextDocumentNotification = {}));
                /**
 * The document close notification is sent from the client to the server when
 * the document got closed in the client. The document's truth now exists where
 * the document's uri points to (e.g. if the document's uri is a file uri the
 * truth now exists on disk). As with the open notification the close notification
 * is about managing the document's content. Receiving a close notification
 * doesn't mean that the document was open in an editor before. A close
 * notification requires a previous open notification to be sent.
 */ var DidCloseTextDocumentNotification;
                (function(DidCloseTextDocumentNotification) {
                    DidCloseTextDocumentNotification.method = 'textDocument/didClose';
                    DidCloseTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidCloseTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification.method);
                })(DidCloseTextDocumentNotification = exports1.DidCloseTextDocumentNotification || (exports1.DidCloseTextDocumentNotification = {}));
                /**
 * The document save notification is sent from the client to the server when
 * the document got saved in the client.
 */ var DidSaveTextDocumentNotification;
                (function(DidSaveTextDocumentNotification) {
                    DidSaveTextDocumentNotification.method = 'textDocument/didSave';
                    DidSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification.method);
                })(DidSaveTextDocumentNotification = exports1.DidSaveTextDocumentNotification || (exports1.DidSaveTextDocumentNotification = {}));
                /**
 * Represents reasons why a text document is saved.
 */ var TextDocumentSaveReason;
                (function(TextDocumentSaveReason) {
                    /**
     * Manually triggered, e.g. by the user pressing save, by starting debugging,
     * or by an API call.
     */ TextDocumentSaveReason.Manual = 1;
                    /**
     * Automatic after a delay.
     */ TextDocumentSaveReason.AfterDelay = 2;
                    /**
     * When the editor lost focus.
     */ TextDocumentSaveReason.FocusOut = 3;
                })(TextDocumentSaveReason = exports1.TextDocumentSaveReason || (exports1.TextDocumentSaveReason = {}));
                /**
 * A document will save notification is sent from the client to the server before
 * the document is actually saved.
 */ var WillSaveTextDocumentNotification;
                (function(WillSaveTextDocumentNotification) {
                    WillSaveTextDocumentNotification.method = 'textDocument/willSave';
                    WillSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification.method);
                })(WillSaveTextDocumentNotification = exports1.WillSaveTextDocumentNotification || (exports1.WillSaveTextDocumentNotification = {}));
                /**
 * A document will save request is sent from the client to the server before
 * the document is actually saved. The request can return an array of TextEdits
 * which will be applied to the text document before it is saved. Please note that
 * clients might drop results if computing the text edits took too long or if a
 * server constantly fails on this request. This is done to keep the save fast and
 * reliable.
 */ var WillSaveTextDocumentWaitUntilRequest;
                (function(WillSaveTextDocumentWaitUntilRequest) {
                    WillSaveTextDocumentWaitUntilRequest.method = 'textDocument/willSaveWaitUntil';
                    WillSaveTextDocumentWaitUntilRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WillSaveTextDocumentWaitUntilRequest.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest.method);
                })(WillSaveTextDocumentWaitUntilRequest = exports1.WillSaveTextDocumentWaitUntilRequest || (exports1.WillSaveTextDocumentWaitUntilRequest = {}));
                /**
 * The watched files notification is sent from the client to the server when
 * the client detects changes to file watched by the language client.
 */ var DidChangeWatchedFilesNotification;
                (function(DidChangeWatchedFilesNotification) {
                    DidChangeWatchedFilesNotification.method = 'workspace/didChangeWatchedFiles';
                    DidChangeWatchedFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeWatchedFilesNotification.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification.method);
                })(DidChangeWatchedFilesNotification = exports1.DidChangeWatchedFilesNotification || (exports1.DidChangeWatchedFilesNotification = {}));
                /**
 * The file event type
 */ var FileChangeType;
                (function(FileChangeType) {
                    /**
     * The file got created.
     */ FileChangeType.Created = 1;
                    /**
     * The file got changed.
     */ FileChangeType.Changed = 2;
                    /**
     * The file got deleted.
     */ FileChangeType.Deleted = 3;
                })(FileChangeType = exports1.FileChangeType || (exports1.FileChangeType = {}));
                var RelativePattern;
                (function(RelativePattern) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is.string(candidate.pattern);
                    }
                    RelativePattern.is = is;
                })(RelativePattern = exports1.RelativePattern || (exports1.RelativePattern = {}));
                var WatchKind;
                (function(WatchKind) {
                    /**
     * Interested in create events.
     */ WatchKind.Create = 1;
                    /**
     * Interested in change events
     */ WatchKind.Change = 2;
                    /**
     * Interested in delete events
     */ WatchKind.Delete = 4;
                })(WatchKind = exports1.WatchKind || (exports1.WatchKind = {}));
                /**
 * Diagnostics notification are sent from the server to the client to signal
 * results of validation runs.
 */ var PublishDiagnosticsNotification;
                (function(PublishDiagnosticsNotification) {
                    PublishDiagnosticsNotification.method = 'textDocument/publishDiagnostics';
                    PublishDiagnosticsNotification.messageDirection = messages_1.MessageDirection.serverToClient;
                    PublishDiagnosticsNotification.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification.method);
                })(PublishDiagnosticsNotification = exports1.PublishDiagnosticsNotification || (exports1.PublishDiagnosticsNotification = {}));
                /**
 * How a completion was triggered
 */ var CompletionTriggerKind;
                (function(CompletionTriggerKind) {
                    /**
     * Completion was triggered by typing an identifier (24x7 code
     * complete), manual invocation (e.g Ctrl+Space) or via API.
     */ CompletionTriggerKind.Invoked = 1;
                    /**
     * Completion was triggered by a trigger character specified by
     * the `triggerCharacters` properties of the `CompletionRegistrationOptions`.
     */ CompletionTriggerKind.TriggerCharacter = 2;
                    /**
     * Completion was re-triggered as current completion list is incomplete
     */ CompletionTriggerKind.TriggerForIncompleteCompletions = 3;
                })(CompletionTriggerKind = exports1.CompletionTriggerKind || (exports1.CompletionTriggerKind = {}));
                /**
 * Request to request completion at a given text document position. The request's
 * parameter is of type {@link TextDocumentPosition} the response
 * is of type {@link CompletionItem CompletionItem[]} or {@link CompletionList}
 * or a Thenable that resolves to such.
 *
 * The request can delay the computation of the {@link CompletionItem.detail `detail`}
 * and {@link CompletionItem.documentation `documentation`} properties to the `completionItem/resolve`
 * request. However, properties that are needed for the initial sorting and filtering, like `sortText`,
 * `filterText`, `insertText`, and `textEdit`, must not be changed during resolve.
 */ var CompletionRequest;
                (function(CompletionRequest) {
                    CompletionRequest.method = 'textDocument/completion';
                    CompletionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CompletionRequest.type = new messages_1.ProtocolRequestType(CompletionRequest.method);
                })(CompletionRequest = exports1.CompletionRequest || (exports1.CompletionRequest = {}));
                /**
 * Request to resolve additional information for a given completion item.The request's
 * parameter is of type {@link CompletionItem} the response
 * is of type {@link CompletionItem} or a Thenable that resolves to such.
 */ var CompletionResolveRequest;
                (function(CompletionResolveRequest) {
                    CompletionResolveRequest.method = 'completionItem/resolve';
                    CompletionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CompletionResolveRequest.type = new messages_1.ProtocolRequestType(CompletionResolveRequest.method);
                })(CompletionResolveRequest = exports1.CompletionResolveRequest || (exports1.CompletionResolveRequest = {}));
                /**
 * Request to request hover information at a given text document position. The request's
 * parameter is of type {@link TextDocumentPosition} the response is of
 * type {@link Hover} or a Thenable that resolves to such.
 */ var HoverRequest;
                (function(HoverRequest) {
                    HoverRequest.method = 'textDocument/hover';
                    HoverRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    HoverRequest.type = new messages_1.ProtocolRequestType(HoverRequest.method);
                })(HoverRequest = exports1.HoverRequest || (exports1.HoverRequest = {}));
                /**
 * How a signature help was triggered.
 *
 * @since 3.15.0
 */ var SignatureHelpTriggerKind;
                (function(SignatureHelpTriggerKind) {
                    /**
     * Signature help was invoked manually by the user or by a command.
     */ SignatureHelpTriggerKind.Invoked = 1;
                    /**
     * Signature help was triggered by a trigger character.
     */ SignatureHelpTriggerKind.TriggerCharacter = 2;
                    /**
     * Signature help was triggered by the cursor moving or by the document content changing.
     */ SignatureHelpTriggerKind.ContentChange = 3;
                })(SignatureHelpTriggerKind = exports1.SignatureHelpTriggerKind || (exports1.SignatureHelpTriggerKind = {}));
                var SignatureHelpRequest;
                (function(SignatureHelpRequest) {
                    SignatureHelpRequest.method = 'textDocument/signatureHelp';
                    SignatureHelpRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SignatureHelpRequest.type = new messages_1.ProtocolRequestType(SignatureHelpRequest.method);
                })(SignatureHelpRequest = exports1.SignatureHelpRequest || (exports1.SignatureHelpRequest = {}));
                /**
 * A request to resolve the definition location of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the response is of either type {@link Definition}
 * or a typed array of {@link DefinitionLink} or a Thenable that resolves
 * to such.
 */ var DefinitionRequest;
                (function(DefinitionRequest) {
                    DefinitionRequest.method = 'textDocument/definition';
                    DefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DefinitionRequest.type = new messages_1.ProtocolRequestType(DefinitionRequest.method);
                })(DefinitionRequest = exports1.DefinitionRequest || (exports1.DefinitionRequest = {}));
                /**
 * A request to resolve project-wide references for the symbol denoted
 * by the given text document position. The request's parameter is of
 * type {@link ReferenceParams} the response is of type
 * {@link Location Location[]} or a Thenable that resolves to such.
 */ var ReferencesRequest;
                (function(ReferencesRequest) {
                    ReferencesRequest.method = 'textDocument/references';
                    ReferencesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ReferencesRequest.type = new messages_1.ProtocolRequestType(ReferencesRequest.method);
                })(ReferencesRequest = exports1.ReferencesRequest || (exports1.ReferencesRequest = {}));
                /**
 * Request to resolve a {@link DocumentHighlight} for a given
 * text document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the request response is of type [DocumentHighlight[]]
 * (#DocumentHighlight) or a Thenable that resolves to such.
 */ var DocumentHighlightRequest;
                (function(DocumentHighlightRequest) {
                    DocumentHighlightRequest.method = 'textDocument/documentHighlight';
                    DocumentHighlightRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentHighlightRequest.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest.method);
                })(DocumentHighlightRequest = exports1.DocumentHighlightRequest || (exports1.DocumentHighlightRequest = {}));
                /**
 * A request to list all symbols found in a given text document. The request's
 * parameter is of type {@link TextDocumentIdentifier} the
 * response is of type {@link SymbolInformation SymbolInformation[]} or a Thenable
 * that resolves to such.
 */ var DocumentSymbolRequest;
                (function(DocumentSymbolRequest) {
                    DocumentSymbolRequest.method = 'textDocument/documentSymbol';
                    DocumentSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentSymbolRequest.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest.method);
                })(DocumentSymbolRequest = exports1.DocumentSymbolRequest || (exports1.DocumentSymbolRequest = {}));
                /**
 * A request to provide commands for the given text document and range.
 */ var CodeActionRequest;
                (function(CodeActionRequest) {
                    CodeActionRequest.method = 'textDocument/codeAction';
                    CodeActionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CodeActionRequest.type = new messages_1.ProtocolRequestType(CodeActionRequest.method);
                })(CodeActionRequest = exports1.CodeActionRequest || (exports1.CodeActionRequest = {}));
                /**
 * Request to resolve additional information for a given code action.The request's
 * parameter is of type {@link CodeAction} the response
 * is of type {@link CodeAction} or a Thenable that resolves to such.
 */ var CodeActionResolveRequest;
                (function(CodeActionResolveRequest) {
                    CodeActionResolveRequest.method = 'codeAction/resolve';
                    CodeActionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CodeActionResolveRequest.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest.method);
                })(CodeActionResolveRequest = exports1.CodeActionResolveRequest || (exports1.CodeActionResolveRequest = {}));
                /**
 * A request to list project-wide symbols matching the query string given
 * by the {@link WorkspaceSymbolParams}. The response is
 * of type {@link SymbolInformation SymbolInformation[]} or a Thenable that
 * resolves to such.
 *
 * @since 3.17.0 - support for WorkspaceSymbol in the returned data. Clients
 *  need to advertise support for WorkspaceSymbols via the client capability
 *  `workspace.symbol.resolveSupport`.
 *
 */ var WorkspaceSymbolRequest;
                (function(WorkspaceSymbolRequest) {
                    WorkspaceSymbolRequest.method = 'workspace/symbol';
                    WorkspaceSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WorkspaceSymbolRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest.method);
                })(WorkspaceSymbolRequest = exports1.WorkspaceSymbolRequest || (exports1.WorkspaceSymbolRequest = {}));
                /**
 * A request to resolve the range inside the workspace
 * symbol's location.
 *
 * @since 3.17.0
 */ var WorkspaceSymbolResolveRequest;
                (function(WorkspaceSymbolResolveRequest) {
                    WorkspaceSymbolResolveRequest.method = 'workspaceSymbol/resolve';
                    WorkspaceSymbolResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    WorkspaceSymbolResolveRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest.method);
                })(WorkspaceSymbolResolveRequest = exports1.WorkspaceSymbolResolveRequest || (exports1.WorkspaceSymbolResolveRequest = {}));
                /**
 * A request to provide code lens for the given text document.
 */ var CodeLensRequest;
                (function(CodeLensRequest) {
                    CodeLensRequest.method = 'textDocument/codeLens';
                    CodeLensRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CodeLensRequest.type = new messages_1.ProtocolRequestType(CodeLensRequest.method);
                })(CodeLensRequest = exports1.CodeLensRequest || (exports1.CodeLensRequest = {}));
                /**
 * A request to resolve a command for a given code lens.
 */ var CodeLensResolveRequest;
                (function(CodeLensResolveRequest) {
                    CodeLensResolveRequest.method = 'codeLens/resolve';
                    CodeLensResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    CodeLensResolveRequest.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest.method);
                })(CodeLensResolveRequest = exports1.CodeLensResolveRequest || (exports1.CodeLensResolveRequest = {}));
                /**
 * A request to refresh all code actions
 *
 * @since 3.16.0
 */ var CodeLensRefreshRequest;
                (function(CodeLensRefreshRequest) {
                    CodeLensRefreshRequest.method = `workspace/codeLens/refresh`;
                    CodeLensRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    CodeLensRefreshRequest.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest.method);
                })(CodeLensRefreshRequest = exports1.CodeLensRefreshRequest || (exports1.CodeLensRefreshRequest = {}));
                /**
 * A request to provide document links
 */ var DocumentLinkRequest;
                (function(DocumentLinkRequest) {
                    DocumentLinkRequest.method = 'textDocument/documentLink';
                    DocumentLinkRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentLinkRequest.type = new messages_1.ProtocolRequestType(DocumentLinkRequest.method);
                })(DocumentLinkRequest = exports1.DocumentLinkRequest || (exports1.DocumentLinkRequest = {}));
                /**
 * Request to resolve additional information for a given document link. The request's
 * parameter is of type {@link DocumentLink} the response
 * is of type {@link DocumentLink} or a Thenable that resolves to such.
 */ var DocumentLinkResolveRequest;
                (function(DocumentLinkResolveRequest) {
                    DocumentLinkResolveRequest.method = 'documentLink/resolve';
                    DocumentLinkResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentLinkResolveRequest.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest.method);
                })(DocumentLinkResolveRequest = exports1.DocumentLinkResolveRequest || (exports1.DocumentLinkResolveRequest = {}));
                /**
 * A request to to format a whole document.
 */ var DocumentFormattingRequest;
                (function(DocumentFormattingRequest) {
                    DocumentFormattingRequest.method = 'textDocument/formatting';
                    DocumentFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest.method);
                })(DocumentFormattingRequest = exports1.DocumentFormattingRequest || (exports1.DocumentFormattingRequest = {}));
                /**
 * A request to to format a range in a document.
 */ var DocumentRangeFormattingRequest;
                (function(DocumentRangeFormattingRequest) {
                    DocumentRangeFormattingRequest.method = 'textDocument/rangeFormatting';
                    DocumentRangeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentRangeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest.method);
                })(DocumentRangeFormattingRequest = exports1.DocumentRangeFormattingRequest || (exports1.DocumentRangeFormattingRequest = {}));
                /**
 * A request to format a document on type.
 */ var DocumentOnTypeFormattingRequest;
                (function(DocumentOnTypeFormattingRequest) {
                    DocumentOnTypeFormattingRequest.method = 'textDocument/onTypeFormatting';
                    DocumentOnTypeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    DocumentOnTypeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest.method);
                })(DocumentOnTypeFormattingRequest = exports1.DocumentOnTypeFormattingRequest || (exports1.DocumentOnTypeFormattingRequest = {}));
                //---- Rename ----------------------------------------------
                var PrepareSupportDefaultBehavior;
                (function(PrepareSupportDefaultBehavior) {
                    /**
     * The client's default behavior is to select the identifier
     * according the to language's syntax rule.
     */ PrepareSupportDefaultBehavior.Identifier = 1;
                })(PrepareSupportDefaultBehavior = exports1.PrepareSupportDefaultBehavior || (exports1.PrepareSupportDefaultBehavior = {}));
                /**
 * A request to rename a symbol.
 */ var RenameRequest;
                (function(RenameRequest) {
                    RenameRequest.method = 'textDocument/rename';
                    RenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    RenameRequest.type = new messages_1.ProtocolRequestType(RenameRequest.method);
                })(RenameRequest = exports1.RenameRequest || (exports1.RenameRequest = {}));
                /**
 * A request to test and perform the setup necessary for a rename.
 *
 * @since 3.16 - support for default behavior
 */ var PrepareRenameRequest;
                (function(PrepareRenameRequest) {
                    PrepareRenameRequest.method = 'textDocument/prepareRename';
                    PrepareRenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    PrepareRenameRequest.type = new messages_1.ProtocolRequestType(PrepareRenameRequest.method);
                })(PrepareRenameRequest = exports1.PrepareRenameRequest || (exports1.PrepareRenameRequest = {}));
                /**
 * A request send from the client to the server to execute a command. The request might return
 * a workspace edit which the client will apply to the workspace.
 */ var ExecuteCommandRequest;
                (function(ExecuteCommandRequest) {
                    ExecuteCommandRequest.method = 'workspace/executeCommand';
                    ExecuteCommandRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    ExecuteCommandRequest.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest.method);
                })(ExecuteCommandRequest = exports1.ExecuteCommandRequest || (exports1.ExecuteCommandRequest = {}));
                /**
 * A request sent from the server to the client to modified certain resources.
 */ var ApplyWorkspaceEditRequest;
                (function(ApplyWorkspaceEditRequest) {
                    ApplyWorkspaceEditRequest.method = 'workspace/applyEdit';
                    ApplyWorkspaceEditRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    ApplyWorkspaceEditRequest.type = new messages_1.ProtocolRequestType('workspace/applyEdit');
                })(ApplyWorkspaceEditRequest = exports1.ApplyWorkspaceEditRequest || (exports1.ApplyWorkspaceEditRequest = {}));
            /***/ },
            /***/ 2249: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_546271__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.LinkedEditingRangeRequest = void 0;
                const messages_1 = __nested_webpack_require_546271__(8431);
                /**
 * A request to provide ranges that can be edited together.
 *
 * @since 3.16.0
 */ var LinkedEditingRangeRequest;
                (function(LinkedEditingRangeRequest) {
                    LinkedEditingRangeRequest.method = 'textDocument/linkedEditingRange';
                    LinkedEditingRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    LinkedEditingRangeRequest.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest.method);
                })(LinkedEditingRangeRequest = exports1.LinkedEditingRangeRequest || (exports1.LinkedEditingRangeRequest = {}));
            /***/ },
            /***/ 7684: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_547644__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.MonikerRequest = exports1.MonikerKind = exports1.UniquenessLevel = void 0;
                const messages_1 = __nested_webpack_require_547644__(8431);
                /**
 * Moniker uniqueness level to define scope of the moniker.
 *
 * @since 3.16.0
 */ var UniquenessLevel;
                (function(UniquenessLevel) {
                    /**
     * The moniker is only unique inside a document
     */ UniquenessLevel.document = 'document';
                    /**
     * The moniker is unique inside a project for which a dump got created
     */ UniquenessLevel.project = 'project';
                    /**
     * The moniker is unique inside the group to which a project belongs
     */ UniquenessLevel.group = 'group';
                    /**
     * The moniker is unique inside the moniker scheme.
     */ UniquenessLevel.scheme = 'scheme';
                    /**
     * The moniker is globally unique
     */ UniquenessLevel.global = 'global';
                })(UniquenessLevel = exports1.UniquenessLevel || (exports1.UniquenessLevel = {}));
                /**
 * The moniker kind.
 *
 * @since 3.16.0
 */ var MonikerKind;
                (function(MonikerKind) {
                    /**
     * The moniker represent a symbol that is imported into a project
     */ MonikerKind.$import = 'import';
                    /**
     * The moniker represents a symbol that is exported from a project
     */ MonikerKind.$export = 'export';
                    /**
     * The moniker represents a symbol that is local to a project (e.g. a local
     * variable of a function, a class not visible outside the project, ...)
     */ MonikerKind.local = 'local';
                })(MonikerKind = exports1.MonikerKind || (exports1.MonikerKind = {}));
                /**
 * A request to get the moniker of a symbol at a given text document position.
 * The request parameter is of type {@link TextDocumentPositionParams}.
 * The response is of type {@link Moniker Moniker[]} or `null`.
 */ var MonikerRequest;
                (function(MonikerRequest) {
                    MonikerRequest.method = 'textDocument/moniker';
                    MonikerRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    MonikerRequest.type = new messages_1.ProtocolRequestType(MonikerRequest.method);
                })(MonikerRequest = exports1.MonikerRequest || (exports1.MonikerRequest = {}));
            /***/ },
            /***/ 4792: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_550678__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.DidCloseNotebookDocumentNotification = exports1.DidSaveNotebookDocumentNotification = exports1.DidChangeNotebookDocumentNotification = exports1.NotebookCellArrayChange = exports1.DidOpenNotebookDocumentNotification = exports1.NotebookDocumentSyncRegistrationType = exports1.NotebookDocument = exports1.NotebookCell = exports1.ExecutionSummary = exports1.NotebookCellKind = void 0;
                const vscode_languageserver_types_1 = __nested_webpack_require_550678__(7717);
                const Is = __nested_webpack_require_550678__(8633);
                const messages_1 = __nested_webpack_require_550678__(8431);
                /**
 * A notebook cell kind.
 *
 * @since 3.17.0
 */ var NotebookCellKind;
                (function(NotebookCellKind) {
                    /**
     * A markup-cell is formatted source that is used for display.
     */ NotebookCellKind.Markup = 1;
                    /**
     * A code-cell is source code.
     */ NotebookCellKind.Code = 2;
                    function is(value) {
                        return value === 1 || value === 2;
                    }
                    NotebookCellKind.is = is;
                })(NotebookCellKind = exports1.NotebookCellKind || (exports1.NotebookCellKind = {}));
                var ExecutionSummary;
                (function(ExecutionSummary) {
                    function create(executionOrder, success) {
                        const result = {
                            executionOrder
                        };
                        if (success === true || success === false) {
                            result.success = success;
                        }
                        return result;
                    }
                    ExecutionSummary.create = create;
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === undefined || Is.boolean(candidate.success));
                    }
                    ExecutionSummary.is = is;
                    function equals(one, other) {
                        if (one === other) {
                            return true;
                        }
                        if (one === null || one === undefined || other === null || other === undefined) {
                            return false;
                        }
                        return one.executionOrder === other.executionOrder && one.success === other.success;
                    }
                    ExecutionSummary.equals = equals;
                })(ExecutionSummary = exports1.ExecutionSummary || (exports1.ExecutionSummary = {}));
                var NotebookCell;
                (function(NotebookCell) {
                    function create(kind, document1) {
                        return {
                            kind,
                            document: document1
                        };
                    }
                    NotebookCell.create = create;
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) && (candidate.metadata === undefined || Is.objectLiteral(candidate.metadata));
                    }
                    NotebookCell.is = is;
                    function diff(one, two) {
                        const result = new Set();
                        if (one.document !== two.document) {
                            result.add('document');
                        }
                        if (one.kind !== two.kind) {
                            result.add('kind');
                        }
                        if (one.executionSummary !== two.executionSummary) {
                            result.add('executionSummary');
                        }
                        if ((one.metadata !== undefined || two.metadata !== undefined) && !equalsMetadata(one.metadata, two.metadata)) {
                            result.add('metadata');
                        }
                        if ((one.executionSummary !== undefined || two.executionSummary !== undefined) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
                            result.add('executionSummary');
                        }
                        return result;
                    }
                    NotebookCell.diff = diff;
                    function equalsMetadata(one, other) {
                        if (one === other) {
                            return true;
                        }
                        if (one === null || one === undefined || other === null || other === undefined) {
                            return false;
                        }
                        if (typeof one !== typeof other) {
                            return false;
                        }
                        if (typeof one !== 'object') {
                            return false;
                        }
                        const oneArray = Array.isArray(one);
                        const otherArray = Array.isArray(other);
                        if (oneArray !== otherArray) {
                            return false;
                        }
                        if (oneArray && otherArray) {
                            if (one.length !== other.length) {
                                return false;
                            }
                            for(let i = 0; i < one.length; i++){
                                if (!equalsMetadata(one[i], other[i])) {
                                    return false;
                                }
                            }
                        }
                        if (Is.objectLiteral(one) && Is.objectLiteral(other)) {
                            const oneKeys = Object.keys(one);
                            const otherKeys = Object.keys(other);
                            if (oneKeys.length !== otherKeys.length) {
                                return false;
                            }
                            oneKeys.sort();
                            otherKeys.sort();
                            if (!equalsMetadata(oneKeys, otherKeys)) {
                                return false;
                            }
                            for(let i = 0; i < oneKeys.length; i++){
                                const prop = oneKeys[i];
                                if (!equalsMetadata(one[prop], other[prop])) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    }
                })(NotebookCell = exports1.NotebookCell || (exports1.NotebookCell = {}));
                var NotebookDocument;
                (function(NotebookDocument) {
                    function create(uri, notebookType, version, cells) {
                        return {
                            uri,
                            notebookType,
                            version,
                            cells
                        };
                    }
                    NotebookDocument.create = create;
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is.typedArray(candidate.cells, NotebookCell.is);
                    }
                    NotebookDocument.is = is;
                })(NotebookDocument = exports1.NotebookDocument || (exports1.NotebookDocument = {}));
                var NotebookDocumentSyncRegistrationType;
                (function(NotebookDocumentSyncRegistrationType) {
                    NotebookDocumentSyncRegistrationType.method = 'notebookDocument/sync';
                    NotebookDocumentSyncRegistrationType.messageDirection = messages_1.MessageDirection.clientToServer;
                    NotebookDocumentSyncRegistrationType.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType.method);
                })(NotebookDocumentSyncRegistrationType = exports1.NotebookDocumentSyncRegistrationType || (exports1.NotebookDocumentSyncRegistrationType = {}));
                /**
 * A notification sent when a notebook opens.
 *
 * @since 3.17.0
 */ var DidOpenNotebookDocumentNotification;
                (function(DidOpenNotebookDocumentNotification) {
                    DidOpenNotebookDocumentNotification.method = 'notebookDocument/didOpen';
                    DidOpenNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidOpenNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification.method);
                    DidOpenNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
                })(DidOpenNotebookDocumentNotification = exports1.DidOpenNotebookDocumentNotification || (exports1.DidOpenNotebookDocumentNotification = {}));
                var NotebookCellArrayChange;
                (function(NotebookCellArrayChange) {
                    function is(value) {
                        const candidate = value;
                        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === undefined || Is.typedArray(candidate.cells, NotebookCell.is));
                    }
                    NotebookCellArrayChange.is = is;
                    function create(start, deleteCount, cells) {
                        const result = {
                            start,
                            deleteCount
                        };
                        if (cells !== undefined) {
                            result.cells = cells;
                        }
                        return result;
                    }
                    NotebookCellArrayChange.create = create;
                })(NotebookCellArrayChange = exports1.NotebookCellArrayChange || (exports1.NotebookCellArrayChange = {}));
                var DidChangeNotebookDocumentNotification;
                (function(DidChangeNotebookDocumentNotification) {
                    DidChangeNotebookDocumentNotification.method = 'notebookDocument/didChange';
                    DidChangeNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification.method);
                    DidChangeNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
                })(DidChangeNotebookDocumentNotification = exports1.DidChangeNotebookDocumentNotification || (exports1.DidChangeNotebookDocumentNotification = {}));
                /**
 * A notification sent when a notebook document is saved.
 *
 * @since 3.17.0
 */ var DidSaveNotebookDocumentNotification;
                (function(DidSaveNotebookDocumentNotification) {
                    DidSaveNotebookDocumentNotification.method = 'notebookDocument/didSave';
                    DidSaveNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidSaveNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification.method);
                    DidSaveNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
                })(DidSaveNotebookDocumentNotification = exports1.DidSaveNotebookDocumentNotification || (exports1.DidSaveNotebookDocumentNotification = {}));
                /**
 * A notification sent when a notebook closes.
 *
 * @since 3.17.0
 */ var DidCloseNotebookDocumentNotification;
                (function(DidCloseNotebookDocumentNotification) {
                    DidCloseNotebookDocumentNotification.method = 'notebookDocument/didClose';
                    DidCloseNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidCloseNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification.method);
                    DidCloseNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
                })(DidCloseNotebookDocumentNotification = exports1.DidCloseNotebookDocumentNotification || (exports1.DidCloseNotebookDocumentNotification = {}));
            /***/ },
            /***/ 4166: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_564255__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.WorkDoneProgressCancelNotification = exports1.WorkDoneProgressCreateRequest = exports1.WorkDoneProgress = void 0;
                const vscode_jsonrpc_1 = __nested_webpack_require_564255__(9110);
                const messages_1 = __nested_webpack_require_564255__(8431);
                var WorkDoneProgress;
                (function(WorkDoneProgress) {
                    WorkDoneProgress.type = new vscode_jsonrpc_1.ProgressType();
                    function is(value) {
                        return value === WorkDoneProgress.type;
                    }
                    WorkDoneProgress.is = is;
                })(WorkDoneProgress = exports1.WorkDoneProgress || (exports1.WorkDoneProgress = {}));
                /**
 * The `window/workDoneProgress/create` request is sent from the server to the client to initiate progress
 * reporting from the server.
 */ var WorkDoneProgressCreateRequest;
                (function(WorkDoneProgressCreateRequest) {
                    WorkDoneProgressCreateRequest.method = 'window/workDoneProgress/create';
                    WorkDoneProgressCreateRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    WorkDoneProgressCreateRequest.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest.method);
                })(WorkDoneProgressCreateRequest = exports1.WorkDoneProgressCreateRequest || (exports1.WorkDoneProgressCreateRequest = {}));
                /**
 * The `window/workDoneProgress/cancel` notification is sent from  the client to the server to cancel a progress
 * initiated on the server side.
 */ var WorkDoneProgressCancelNotification;
                (function(WorkDoneProgressCancelNotification) {
                    WorkDoneProgressCancelNotification.method = 'window/workDoneProgress/cancel';
                    WorkDoneProgressCancelNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    WorkDoneProgressCancelNotification.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification.method);
                })(WorkDoneProgressCancelNotification = exports1.WorkDoneProgressCancelNotification || (exports1.WorkDoneProgressCancelNotification = {}));
            /***/ },
            /***/ 1530: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_567096__)=>{
                "use strict";
                /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.SelectionRangeRequest = void 0;
                const messages_1 = __nested_webpack_require_567096__(8431);
                /**
 * A request to provide selection ranges in a document. The request's
 * parameter is of type {@link SelectionRangeParams}, the
 * response is of type {@link SelectionRange SelectionRange[]} or a Thenable
 * that resolves to such.
 */ var SelectionRangeRequest;
                (function(SelectionRangeRequest) {
                    SelectionRangeRequest.method = 'textDocument/selectionRange';
                    SelectionRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SelectionRangeRequest.type = new messages_1.ProtocolRequestType(SelectionRangeRequest.method);
                })(SelectionRangeRequest = exports1.SelectionRangeRequest || (exports1.SelectionRangeRequest = {}));
            /***/ },
            /***/ 2067: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_568576__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.SemanticTokensRefreshRequest = exports1.SemanticTokensRangeRequest = exports1.SemanticTokensDeltaRequest = exports1.SemanticTokensRequest = exports1.SemanticTokensRegistrationType = exports1.TokenFormat = void 0;
                const messages_1 = __nested_webpack_require_568576__(8431);
                //------- 'textDocument/semanticTokens' -----
                var TokenFormat;
                (function(TokenFormat) {
                    TokenFormat.Relative = 'relative';
                })(TokenFormat = exports1.TokenFormat || (exports1.TokenFormat = {}));
                var SemanticTokensRegistrationType;
                (function(SemanticTokensRegistrationType) {
                    SemanticTokensRegistrationType.method = 'textDocument/semanticTokens';
                    SemanticTokensRegistrationType.type = new messages_1.RegistrationType(SemanticTokensRegistrationType.method);
                })(SemanticTokensRegistrationType = exports1.SemanticTokensRegistrationType || (exports1.SemanticTokensRegistrationType = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokensRequest;
                (function(SemanticTokensRequest) {
                    SemanticTokensRequest.method = 'textDocument/semanticTokens/full';
                    SemanticTokensRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SemanticTokensRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRequest.method);
                    SemanticTokensRequest.registrationMethod = SemanticTokensRegistrationType.method;
                })(SemanticTokensRequest = exports1.SemanticTokensRequest || (exports1.SemanticTokensRequest = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokensDeltaRequest;
                (function(SemanticTokensDeltaRequest) {
                    SemanticTokensDeltaRequest.method = 'textDocument/semanticTokens/full/delta';
                    SemanticTokensDeltaRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SemanticTokensDeltaRequest.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest.method);
                    SemanticTokensDeltaRequest.registrationMethod = SemanticTokensRegistrationType.method;
                })(SemanticTokensDeltaRequest = exports1.SemanticTokensDeltaRequest || (exports1.SemanticTokensDeltaRequest = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokensRangeRequest;
                (function(SemanticTokensRangeRequest) {
                    SemanticTokensRangeRequest.method = 'textDocument/semanticTokens/range';
                    SemanticTokensRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    SemanticTokensRangeRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest.method);
                    SemanticTokensRangeRequest.registrationMethod = SemanticTokensRegistrationType.method;
                })(SemanticTokensRangeRequest = exports1.SemanticTokensRangeRequest || (exports1.SemanticTokensRangeRequest = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokensRefreshRequest;
                (function(SemanticTokensRefreshRequest) {
                    SemanticTokensRefreshRequest.method = `workspace/semanticTokens/refresh`;
                    SemanticTokensRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    SemanticTokensRefreshRequest.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest.method);
                })(SemanticTokensRefreshRequest = exports1.SemanticTokensRefreshRequest || (exports1.SemanticTokensRefreshRequest = {}));
            /***/ },
            /***/ 4333: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_572887__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.ShowDocumentRequest = void 0;
                const messages_1 = __nested_webpack_require_572887__(8431);
                /**
 * A request to show a document. This request might open an
 * external program depending on the value of the URI to open.
 * For example a request to open `https://code.visualstudio.com/`
 * will very likely open the URI in a WEB browser.
 *
 * @since 3.16.0
*/ var ShowDocumentRequest;
                (function(ShowDocumentRequest) {
                    ShowDocumentRequest.method = 'window/showDocument';
                    ShowDocumentRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    ShowDocumentRequest.type = new messages_1.ProtocolRequestType(ShowDocumentRequest.method);
                })(ShowDocumentRequest = exports1.ShowDocumentRequest || (exports1.ShowDocumentRequest = {}));
            /***/ },
            /***/ 9264: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_574365__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.TypeDefinitionRequest = void 0;
                const messages_1 = __nested_webpack_require_574365__(8431);
                // @ts-ignore: to avoid inlining LocatioLink as dynamic import
                let __noDynamicImport;
                /**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositionParams]
 * (#TextDocumentPositionParams) the response is of type {@link Definition} or a
 * Thenable that resolves to such.
 */ var TypeDefinitionRequest;
                (function(TypeDefinitionRequest) {
                    TypeDefinitionRequest.method = 'textDocument/typeDefinition';
                    TypeDefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    TypeDefinitionRequest.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest.method);
                })(TypeDefinitionRequest = exports1.TypeDefinitionRequest || (exports1.TypeDefinitionRequest = {}));
            /***/ },
            /***/ 7062: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_576014__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox, Microsoft and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.TypeHierarchySubtypesRequest = exports1.TypeHierarchySupertypesRequest = exports1.TypeHierarchyPrepareRequest = void 0;
                const messages_1 = __nested_webpack_require_576014__(8431);
                /**
 * A request to result a `TypeHierarchyItem` in a document at a given position.
 * Can be used as an input to a subtypes or supertypes type hierarchy.
 *
 * @since 3.17.0
 */ var TypeHierarchyPrepareRequest;
                (function(TypeHierarchyPrepareRequest) {
                    TypeHierarchyPrepareRequest.method = 'textDocument/prepareTypeHierarchy';
                    TypeHierarchyPrepareRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    TypeHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest.method);
                })(TypeHierarchyPrepareRequest = exports1.TypeHierarchyPrepareRequest || (exports1.TypeHierarchyPrepareRequest = {}));
                /**
 * A request to resolve the supertypes for a given `TypeHierarchyItem`.
 *
 * @since 3.17.0
 */ var TypeHierarchySupertypesRequest;
                (function(TypeHierarchySupertypesRequest) {
                    TypeHierarchySupertypesRequest.method = 'typeHierarchy/supertypes';
                    TypeHierarchySupertypesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    TypeHierarchySupertypesRequest.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest.method);
                })(TypeHierarchySupertypesRequest = exports1.TypeHierarchySupertypesRequest || (exports1.TypeHierarchySupertypesRequest = {}));
                /**
 * A request to resolve the subtypes for a given `TypeHierarchyItem`.
 *
 * @since 3.17.0
 */ var TypeHierarchySubtypesRequest;
                (function(TypeHierarchySubtypesRequest) {
                    TypeHierarchySubtypesRequest.method = 'typeHierarchy/subtypes';
                    TypeHierarchySubtypesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
                    TypeHierarchySubtypesRequest.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest.method);
                })(TypeHierarchySubtypesRequest = exports1.TypeHierarchySubtypesRequest || (exports1.TypeHierarchySubtypesRequest = {}));
            /***/ },
            /***/ 6860: /***/ (__unused_webpack_module, exports1, __nested_webpack_require_578948__)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.DidChangeWorkspaceFoldersNotification = exports1.WorkspaceFoldersRequest = void 0;
                const messages_1 = __nested_webpack_require_578948__(8431);
                /**
 * The `workspace/workspaceFolders` is sent from the server to the client to fetch the open workspace folders.
 */ var WorkspaceFoldersRequest;
                (function(WorkspaceFoldersRequest) {
                    WorkspaceFoldersRequest.method = 'workspace/workspaceFolders';
                    WorkspaceFoldersRequest.messageDirection = messages_1.MessageDirection.serverToClient;
                    WorkspaceFoldersRequest.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest.method);
                })(WorkspaceFoldersRequest = exports1.WorkspaceFoldersRequest || (exports1.WorkspaceFoldersRequest = {}));
                /**
 * The `workspace/didChangeWorkspaceFolders` notification is sent from the client to the server when the workspace
 * folder configuration changes.
 */ var DidChangeWorkspaceFoldersNotification;
                (function(DidChangeWorkspaceFoldersNotification) {
                    DidChangeWorkspaceFoldersNotification.method = 'workspace/didChangeWorkspaceFolders';
                    DidChangeWorkspaceFoldersNotification.messageDirection = messages_1.MessageDirection.clientToServer;
                    DidChangeWorkspaceFoldersNotification.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification.method);
                })(DidChangeWorkspaceFoldersNotification = exports1.DidChangeWorkspaceFoldersNotification || (exports1.DidChangeWorkspaceFoldersNotification = {}));
            /***/ },
            /***/ 8633: /***/ (__unused_webpack_module, exports1)=>{
                "use strict";
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports1, "__esModule", {
                    value: true
                });
                exports1.objectLiteral = exports1.typedArray = exports1.stringArray = exports1.array = exports1.func = exports1.error = exports1.number = exports1.string = exports1.boolean = void 0;
                function boolean(value) {
                    return value === true || value === false;
                }
                exports1.boolean = boolean;
                function string(value) {
                    return typeof value === 'string' || value instanceof String;
                }
                exports1.string = string;
                function number(value) {
                    return typeof value === 'number' || value instanceof Number;
                }
                exports1.number = number;
                function error(value) {
                    return value instanceof Error;
                }
                exports1.error = error;
                function func(value) {
                    return typeof value === 'function';
                }
                exports1.func = func;
                function array(value) {
                    return Array.isArray(value);
                }
                exports1.array = array;
                function stringArray(value) {
                    return array(value) && value.every((elem)=>string(elem));
                }
                exports1.stringArray = stringArray;
                function typedArray(value, check) {
                    return Array.isArray(value) && value.every(check);
                }
                exports1.typedArray = typedArray;
                function objectLiteral(value) {
                    // Strictly speaking class instances pass this check as well. Since the LSP
                    // doesn't use classes we ignore this for now. If we do we need to add something
                    // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
                    return value !== null && typeof value === 'object';
                }
                exports1.objectLiteral = objectLiteral;
            /***/ },
            /***/ 7717: /***/ (__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_583843__)=>{
                "use strict";
                __nested_webpack_require_583843__.r(__nested_webpack_exports__);
                /* harmony export */ __nested_webpack_require_583843__.d(__nested_webpack_exports__, {
                    /* harmony export */ AnnotatedTextEdit: ()=>/* binding */ AnnotatedTextEdit,
                    /* harmony export */ ChangeAnnotation: ()=>/* binding */ ChangeAnnotation,
                    /* harmony export */ ChangeAnnotationIdentifier: ()=>/* binding */ ChangeAnnotationIdentifier,
                    /* harmony export */ CodeAction: ()=>/* binding */ CodeAction,
                    /* harmony export */ CodeActionContext: ()=>/* binding */ CodeActionContext,
                    /* harmony export */ CodeActionKind: ()=>/* binding */ CodeActionKind,
                    /* harmony export */ CodeActionTriggerKind: ()=>/* binding */ CodeActionTriggerKind,
                    /* harmony export */ CodeDescription: ()=>/* binding */ CodeDescription,
                    /* harmony export */ CodeLens: ()=>/* binding */ CodeLens,
                    /* harmony export */ Color: ()=>/* binding */ Color,
                    /* harmony export */ ColorInformation: ()=>/* binding */ ColorInformation,
                    /* harmony export */ ColorPresentation: ()=>/* binding */ ColorPresentation,
                    /* harmony export */ Command: ()=>/* binding */ Command,
                    /* harmony export */ CompletionItem: ()=>/* binding */ CompletionItem,
                    /* harmony export */ CompletionItemKind: ()=>/* binding */ CompletionItemKind1,
                    /* harmony export */ CompletionItemLabelDetails: ()=>/* binding */ CompletionItemLabelDetails,
                    /* harmony export */ CompletionItemTag: ()=>/* binding */ CompletionItemTag,
                    /* harmony export */ CompletionList: ()=>/* binding */ CompletionList,
                    /* harmony export */ CreateFile: ()=>/* binding */ CreateFile,
                    /* harmony export */ DeleteFile: ()=>/* binding */ DeleteFile,
                    /* harmony export */ Diagnostic: ()=>/* binding */ Diagnostic,
                    /* harmony export */ DiagnosticRelatedInformation: ()=>/* binding */ DiagnosticRelatedInformation,
                    /* harmony export */ DiagnosticSeverity: ()=>/* binding */ DiagnosticSeverity,
                    /* harmony export */ DiagnosticTag: ()=>/* binding */ DiagnosticTag,
                    /* harmony export */ DocumentHighlight: ()=>/* binding */ DocumentHighlight,
                    /* harmony export */ DocumentHighlightKind: ()=>/* binding */ DocumentHighlightKind,
                    /* harmony export */ DocumentLink: ()=>/* binding */ DocumentLink,
                    /* harmony export */ DocumentSymbol: ()=>/* binding */ DocumentSymbol,
                    /* harmony export */ DocumentUri: ()=>/* binding */ DocumentUri,
                    /* harmony export */ EOL: ()=>/* binding */ EOL,
                    /* harmony export */ FoldingRange: ()=>/* binding */ FoldingRange,
                    /* harmony export */ FoldingRangeKind: ()=>/* binding */ FoldingRangeKind,
                    /* harmony export */ FormattingOptions: ()=>/* binding */ FormattingOptions,
                    /* harmony export */ Hover: ()=>/* binding */ Hover,
                    /* harmony export */ InlayHint: ()=>/* binding */ InlayHint,
                    /* harmony export */ InlayHintKind: ()=>/* binding */ InlayHintKind,
                    /* harmony export */ InlayHintLabelPart: ()=>/* binding */ InlayHintLabelPart,
                    /* harmony export */ InlineValueContext: ()=>/* binding */ InlineValueContext,
                    /* harmony export */ InlineValueEvaluatableExpression: ()=>/* binding */ InlineValueEvaluatableExpression,
                    /* harmony export */ InlineValueText: ()=>/* binding */ InlineValueText,
                    /* harmony export */ InlineValueVariableLookup: ()=>/* binding */ InlineValueVariableLookup,
                    /* harmony export */ InsertReplaceEdit: ()=>/* binding */ InsertReplaceEdit,
                    /* harmony export */ InsertTextFormat: ()=>/* binding */ InsertTextFormat1,
                    /* harmony export */ InsertTextMode: ()=>/* binding */ InsertTextMode,
                    /* harmony export */ Location: ()=>/* binding */ Location,
                    /* harmony export */ LocationLink: ()=>/* binding */ LocationLink,
                    /* harmony export */ MarkedString: ()=>/* binding */ MarkedString1,
                    /* harmony export */ MarkupContent: ()=>/* binding */ MarkupContent1,
                    /* harmony export */ MarkupKind: ()=>/* binding */ MarkupKind,
                    /* harmony export */ OptionalVersionedTextDocumentIdentifier: ()=>/* binding */ OptionalVersionedTextDocumentIdentifier,
                    /* harmony export */ ParameterInformation: ()=>/* binding */ ParameterInformation,
                    /* harmony export */ Position: ()=>/* binding */ Position,
                    /* harmony export */ Range: ()=>/* binding */ Range,
                    /* harmony export */ RenameFile: ()=>/* binding */ RenameFile,
                    /* harmony export */ SelectionRange: ()=>/* binding */ SelectionRange,
                    /* harmony export */ SemanticTokenModifiers: ()=>/* binding */ SemanticTokenModifiers,
                    /* harmony export */ SemanticTokenTypes: ()=>/* binding */ SemanticTokenTypes,
                    /* harmony export */ SemanticTokens: ()=>/* binding */ SemanticTokens,
                    /* harmony export */ SignatureInformation: ()=>/* binding */ SignatureInformation,
                    /* harmony export */ SymbolInformation: ()=>/* binding */ SymbolInformation,
                    /* harmony export */ SymbolKind: ()=>/* binding */ SymbolKind,
                    /* harmony export */ SymbolTag: ()=>/* binding */ SymbolTag,
                    /* harmony export */ TextDocument: ()=>/* binding */ TextDocument,
                    /* harmony export */ TextDocumentEdit: ()=>/* binding */ TextDocumentEdit,
                    /* harmony export */ TextDocumentIdentifier: ()=>/* binding */ TextDocumentIdentifier,
                    /* harmony export */ TextDocumentItem: ()=>/* binding */ TextDocumentItem,
                    /* harmony export */ TextEdit: ()=>/* binding */ TextEdit,
                    /* harmony export */ URI: ()=>/* binding */ URI1,
                    /* harmony export */ VersionedTextDocumentIdentifier: ()=>/* binding */ VersionedTextDocumentIdentifier,
                    /* harmony export */ WorkspaceChange: ()=>/* binding */ WorkspaceChange,
                    /* harmony export */ WorkspaceEdit: ()=>/* binding */ WorkspaceEdit,
                    /* harmony export */ WorkspaceFolder: ()=>/* binding */ WorkspaceFolder,
                    /* harmony export */ WorkspaceSymbol: ()=>/* binding */ WorkspaceSymbol,
                    /* harmony export */ integer: ()=>/* binding */ integer,
                    /* harmony export */ uinteger: ()=>/* binding */ uinteger
                });
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var DocumentUri;
                (function(DocumentUri) {
                    function is(value) {
                        return typeof value === 'string';
                    }
                    DocumentUri.is = is;
                })(DocumentUri || (DocumentUri = {}));
                var URI1;
                (function(URI1) {
                    function is(value) {
                        return typeof value === 'string';
                    }
                    URI1.is = is;
                })(URI1 || (URI1 = {}));
                var integer;
                (function(integer) {
                    integer.MIN_VALUE = -2147483648;
                    integer.MAX_VALUE = 2147483647;
                    function is(value) {
                        return typeof value === 'number' && integer.MIN_VALUE <= value && value <= integer.MAX_VALUE;
                    }
                    integer.is = is;
                })(integer || (integer = {}));
                var uinteger;
                (function(uinteger) {
                    uinteger.MIN_VALUE = 0;
                    uinteger.MAX_VALUE = 2147483647;
                    function is(value) {
                        return typeof value === 'number' && uinteger.MIN_VALUE <= value && value <= uinteger.MAX_VALUE;
                    }
                    uinteger.is = is;
                })(uinteger || (uinteger = {}));
                /**
 * The Position namespace provides helper functions to work with
 * {@link Position} literals.
 */ var Position;
                (function(Position) {
                    /**
     * Creates a new Position literal from the given line and character.
     * @param line The position's line.
     * @param character The position's character.
     */ function create(line, character) {
                        if (line === Number.MAX_VALUE) {
                            line = uinteger.MAX_VALUE;
                        }
                        if (character === Number.MAX_VALUE) {
                            character = uinteger.MAX_VALUE;
                        }
                        return {
                            line: line,
                            character: character
                        };
                    }
                    Position.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Position} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
                    }
                    Position.is = is;
                })(Position || (Position = {}));
                /**
 * The Range namespace provides helper functions to work with
 * {@link Range} literals.
 */ var Range;
                (function(Range) {
                    function create(one, two, three, four) {
                        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
                            return {
                                start: Position.create(one, two),
                                end: Position.create(three, four)
                            };
                        } else if (Position.is(one) && Position.is(two)) {
                            return {
                                start: one,
                                end: two
                            };
                        } else {
                            throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
                        }
                    }
                    Range.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Range} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
                    }
                    Range.is = is;
                })(Range || (Range = {}));
                /**
 * The Location namespace provides helper functions to work with
 * {@link Location} literals.
 */ var Location;
                (function(Location) {
                    /**
     * Creates a Location literal.
     * @param uri The location's uri.
     * @param range The location's range.
     */ function create(uri, range) {
                        return {
                            uri: uri,
                            range: range
                        };
                    }
                    Location.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Location} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
                    }
                    Location.is = is;
                })(Location || (Location = {}));
                /**
 * The LocationLink namespace provides helper functions to work with
 * {@link LocationLink} literals.
 */ var LocationLink;
                (function(LocationLink) {
                    /**
     * Creates a LocationLink literal.
     * @param targetUri The definition's uri.
     * @param targetRange The full range of the definition.
     * @param targetSelectionRange The span of the symbol definition at the target.
     * @param originSelectionRange The span of the symbol being defined in the originating source file.
     */ function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
                        return {
                            targetUri: targetUri,
                            targetRange: targetRange,
                            targetSelectionRange: targetSelectionRange,
                            originSelectionRange: originSelectionRange
                        };
                    }
                    LocationLink.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link LocationLink} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
                    }
                    LocationLink.is = is;
                })(LocationLink || (LocationLink = {}));
                /**
 * The Color namespace provides helper functions to work with
 * {@link Color} literals.
 */ var Color;
                (function(Color) {
                    /**
     * Creates a new Color literal.
     */ function create(red, green, blue, alpha) {
                        return {
                            red: red,
                            green: green,
                            blue: blue,
                            alpha: alpha
                        };
                    }
                    Color.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Color} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
                    }
                    Color.is = is;
                })(Color || (Color = {}));
                /**
 * The ColorInformation namespace provides helper functions to work with
 * {@link ColorInformation} literals.
 */ var ColorInformation;
                (function(ColorInformation) {
                    /**
     * Creates a new ColorInformation literal.
     */ function create(range, color) {
                        return {
                            range: range,
                            color: color
                        };
                    }
                    ColorInformation.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link ColorInformation} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
                    }
                    ColorInformation.is = is;
                })(ColorInformation || (ColorInformation = {}));
                /**
 * The Color namespace provides helper functions to work with
 * {@link ColorPresentation} literals.
 */ var ColorPresentation;
                (function(ColorPresentation) {
                    /**
     * Creates a new ColorInformation literal.
     */ function create(label, textEdit, additionalTextEdits) {
                        return {
                            label: label,
                            textEdit: textEdit,
                            additionalTextEdits: additionalTextEdits
                        };
                    }
                    ColorPresentation.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link ColorInformation} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
                    }
                    ColorPresentation.is = is;
                })(ColorPresentation || (ColorPresentation = {}));
                /**
 * A set of predefined range kinds.
 */ var FoldingRangeKind;
                (function(FoldingRangeKind) {
                    /**
     * Folding range for a comment
     */ FoldingRangeKind.Comment = 'comment';
                    /**
     * Folding range for an import or include
     */ FoldingRangeKind.Imports = 'imports';
                    /**
     * Folding range for a region (e.g. `#region`)
     */ FoldingRangeKind.Region = 'region';
                })(FoldingRangeKind || (FoldingRangeKind = {}));
                /**
 * The folding range namespace provides helper functions to work with
 * {@link FoldingRange} literals.
 */ var FoldingRange;
                (function(FoldingRange) {
                    /**
     * Creates a new FoldingRange literal.
     */ function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
                        var result = {
                            startLine: startLine,
                            endLine: endLine
                        };
                        if (Is.defined(startCharacter)) {
                            result.startCharacter = startCharacter;
                        }
                        if (Is.defined(endCharacter)) {
                            result.endCharacter = endCharacter;
                        }
                        if (Is.defined(kind)) {
                            result.kind = kind;
                        }
                        if (Is.defined(collapsedText)) {
                            result.collapsedText = collapsedText;
                        }
                        return result;
                    }
                    FoldingRange.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link FoldingRange} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
                    }
                    FoldingRange.is = is;
                })(FoldingRange || (FoldingRange = {}));
                /**
 * The DiagnosticRelatedInformation namespace provides helper functions to work with
 * {@link DiagnosticRelatedInformation} literals.
 */ var DiagnosticRelatedInformation;
                (function(DiagnosticRelatedInformation) {
                    /**
     * Creates a new DiagnosticRelatedInformation literal.
     */ function create(location, message) {
                        return {
                            location: location,
                            message: message
                        };
                    }
                    DiagnosticRelatedInformation.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link DiagnosticRelatedInformation} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
                    }
                    DiagnosticRelatedInformation.is = is;
                })(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
                /**
 * The diagnostic's severity.
 */ var DiagnosticSeverity;
                (function(DiagnosticSeverity) {
                    /**
     * Reports an error.
     */ DiagnosticSeverity.Error = 1;
                    /**
     * Reports a warning.
     */ DiagnosticSeverity.Warning = 2;
                    /**
     * Reports an information.
     */ DiagnosticSeverity.Information = 3;
                    /**
     * Reports a hint.
     */ DiagnosticSeverity.Hint = 4;
                })(DiagnosticSeverity || (DiagnosticSeverity = {}));
                /**
 * The diagnostic tags.
 *
 * @since 3.15.0
 */ var DiagnosticTag;
                (function(DiagnosticTag) {
                    /**
     * Unused or unnecessary code.
     *
     * Clients are allowed to render diagnostics with this tag faded out instead of having
     * an error squiggle.
     */ DiagnosticTag.Unnecessary = 1;
                    /**
     * Deprecated or obsolete code.
     *
     * Clients are allowed to rendered diagnostics with this tag strike through.
     */ DiagnosticTag.Deprecated = 2;
                })(DiagnosticTag || (DiagnosticTag = {}));
                /**
 * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.
 *
 * @since 3.16.0
 */ var CodeDescription;
                (function(CodeDescription) {
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.href);
                    }
                    CodeDescription.is = is;
                })(CodeDescription || (CodeDescription = {}));
                /**
 * The Diagnostic namespace provides helper functions to work with
 * {@link Diagnostic} literals.
 */ var Diagnostic;
                (function(Diagnostic) {
                    /**
     * Creates a new Diagnostic literal.
     */ function create(range, message, severity, code, source, relatedInformation) {
                        var result = {
                            range: range,
                            message: message
                        };
                        if (Is.defined(severity)) {
                            result.severity = severity;
                        }
                        if (Is.defined(code)) {
                            result.code = code;
                        }
                        if (Is.defined(source)) {
                            result.source = source;
                        }
                        if (Is.defined(relatedInformation)) {
                            result.relatedInformation = relatedInformation;
                        }
                        return result;
                    }
                    Diagnostic.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Diagnostic} interface.
     */ function is(value) {
                        var _a;
                        var candidate = value;
                        return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
                    }
                    Diagnostic.is = is;
                })(Diagnostic || (Diagnostic = {}));
                /**
 * The Command namespace provides helper functions to work with
 * {@link Command} literals.
 */ var Command;
                (function(Command) {
                    /**
     * Creates a new Command literal.
     */ function create(title, command) {
                        var args = [];
                        for(var _i = 2; _i < arguments.length; _i++){
                            args[_i - 2] = arguments[_i];
                        }
                        var result = {
                            title: title,
                            command: command
                        };
                        if (Is.defined(args) && args.length > 0) {
                            result.arguments = args;
                        }
                        return result;
                    }
                    Command.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link Command} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
                    }
                    Command.is = is;
                })(Command || (Command = {}));
                /**
 * The TextEdit namespace provides helper function to create replace,
 * insert and delete edits more easily.
 */ var TextEdit;
                (function(TextEdit) {
                    /**
     * Creates a replace text edit.
     * @param range The range of text to be replaced.
     * @param newText The new text.
     */ function replace(range, newText) {
                        return {
                            range: range,
                            newText: newText
                        };
                    }
                    TextEdit.replace = replace;
                    /**
     * Creates an insert text edit.
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     */ function insert(position, newText) {
                        return {
                            range: {
                                start: position,
                                end: position
                            },
                            newText: newText
                        };
                    }
                    TextEdit.insert = insert;
                    /**
     * Creates a delete text edit.
     * @param range The range of text to be deleted.
     */ function del(range) {
                        return {
                            range: range,
                            newText: ''
                        };
                    }
                    TextEdit.del = del;
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);
                    }
                    TextEdit.is = is;
                })(TextEdit || (TextEdit = {}));
                var ChangeAnnotation;
                (function(ChangeAnnotation) {
                    function create(label, needsConfirmation, description) {
                        var result = {
                            label: label
                        };
                        if (needsConfirmation !== undefined) {
                            result.needsConfirmation = needsConfirmation;
                        }
                        if (description !== undefined) {
                            result.description = description;
                        }
                        return result;
                    }
                    ChangeAnnotation.create = create;
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) && (Is.string(candidate.description) || candidate.description === undefined);
                    }
                    ChangeAnnotation.is = is;
                })(ChangeAnnotation || (ChangeAnnotation = {}));
                var ChangeAnnotationIdentifier;
                (function(ChangeAnnotationIdentifier) {
                    function is(value) {
                        var candidate = value;
                        return Is.string(candidate);
                    }
                    ChangeAnnotationIdentifier.is = is;
                })(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
                var AnnotatedTextEdit;
                (function(AnnotatedTextEdit) {
                    /**
     * Creates an annotated replace text edit.
     *
     * @param range The range of text to be replaced.
     * @param newText The new text.
     * @param annotation The annotation.
     */ function replace(range, newText, annotation) {
                        return {
                            range: range,
                            newText: newText,
                            annotationId: annotation
                        };
                    }
                    AnnotatedTextEdit.replace = replace;
                    /**
     * Creates an annotated insert text edit.
     *
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     * @param annotation The annotation.
     */ function insert(position, newText, annotation) {
                        return {
                            range: {
                                start: position,
                                end: position
                            },
                            newText: newText,
                            annotationId: annotation
                        };
                    }
                    AnnotatedTextEdit.insert = insert;
                    /**
     * Creates an annotated delete text edit.
     *
     * @param range The range of text to be deleted.
     * @param annotation The annotation.
     */ function del(range, annotation) {
                        return {
                            range: range,
                            newText: '',
                            annotationId: annotation
                        };
                    }
                    AnnotatedTextEdit.del = del;
                    function is(value) {
                        var candidate = value;
                        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
                    }
                    AnnotatedTextEdit.is = is;
                })(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
                /**
 * The TextDocumentEdit namespace provides helper function to create
 * an edit that manipulates a text document.
 */ var TextDocumentEdit;
                (function(TextDocumentEdit) {
                    /**
     * Creates a new `TextDocumentEdit`
     */ function create(textDocument, edits) {
                        return {
                            textDocument: textDocument,
                            edits: edits
                        };
                    }
                    TextDocumentEdit.create = create;
                    function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
                    }
                    TextDocumentEdit.is = is;
                })(TextDocumentEdit || (TextDocumentEdit = {}));
                var CreateFile;
                (function(CreateFile) {
                    function create(uri, options, annotation) {
                        var result = {
                            kind: 'create',
                            uri: uri
                        };
                        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
                            result.options = options;
                        }
                        if (annotation !== undefined) {
                            result.annotationId = annotation;
                        }
                        return result;
                    }
                    CreateFile.create = create;
                    function is(value) {
                        var candidate = value;
                        return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined || (candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
                    }
                    CreateFile.is = is;
                })(CreateFile || (CreateFile = {}));
                var RenameFile;
                (function(RenameFile) {
                    function create(oldUri, newUri, options, annotation) {
                        var result = {
                            kind: 'rename',
                            oldUri: oldUri,
                            newUri: newUri
                        };
                        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
                            result.options = options;
                        }
                        if (annotation !== undefined) {
                            result.annotationId = annotation;
                        }
                        return result;
                    }
                    RenameFile.create = create;
                    function is(value) {
                        var candidate = value;
                        return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined || (candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
                    }
                    RenameFile.is = is;
                })(RenameFile || (RenameFile = {}));
                var DeleteFile;
                (function(DeleteFile) {
                    function create(uri, options, annotation) {
                        var result = {
                            kind: 'delete',
                            uri: uri
                        };
                        if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {
                            result.options = options;
                        }
                        if (annotation !== undefined) {
                            result.annotationId = annotation;
                        }
                        return result;
                    }
                    DeleteFile.create = create;
                    function is(value) {
                        var candidate = value;
                        return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined || (candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
                    }
                    DeleteFile.is = is;
                })(DeleteFile || (DeleteFile = {}));
                var WorkspaceEdit;
                (function(WorkspaceEdit) {
                    function is(value) {
                        var candidate = value;
                        return candidate && (candidate.changes !== undefined || candidate.documentChanges !== undefined) && (candidate.documentChanges === undefined || candidate.documentChanges.every(function(change) {
                            if (Is.string(change.kind)) {
                                return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
                            } else {
                                return TextDocumentEdit.is(change);
                            }
                        }));
                    }
                    WorkspaceEdit.is = is;
                })(WorkspaceEdit || (WorkspaceEdit = {}));
                var TextEditChangeImpl = /** @class */ function() {
                    function TextEditChangeImpl(edits, changeAnnotations) {
                        this.edits = edits;
                        this.changeAnnotations = changeAnnotations;
                    }
                    TextEditChangeImpl.prototype.insert = function(position, newText, annotation) {
                        var edit1;
                        var id;
                        if (annotation === undefined) {
                            edit1 = TextEdit.insert(position, newText);
                        } else if (ChangeAnnotationIdentifier.is(annotation)) {
                            id = annotation;
                            edit1 = AnnotatedTextEdit.insert(position, newText, annotation);
                        } else {
                            this.assertChangeAnnotations(this.changeAnnotations);
                            id = this.changeAnnotations.manage(annotation);
                            edit1 = AnnotatedTextEdit.insert(position, newText, id);
                        }
                        this.edits.push(edit1);
                        if (id !== undefined) {
                            return id;
                        }
                    };
                    TextEditChangeImpl.prototype.replace = function(range, newText, annotation) {
                        var edit1;
                        var id;
                        if (annotation === undefined) {
                            edit1 = TextEdit.replace(range, newText);
                        } else if (ChangeAnnotationIdentifier.is(annotation)) {
                            id = annotation;
                            edit1 = AnnotatedTextEdit.replace(range, newText, annotation);
                        } else {
                            this.assertChangeAnnotations(this.changeAnnotations);
                            id = this.changeAnnotations.manage(annotation);
                            edit1 = AnnotatedTextEdit.replace(range, newText, id);
                        }
                        this.edits.push(edit1);
                        if (id !== undefined) {
                            return id;
                        }
                    };
                    TextEditChangeImpl.prototype.delete = function(range, annotation) {
                        var edit1;
                        var id;
                        if (annotation === undefined) {
                            edit1 = TextEdit.del(range);
                        } else if (ChangeAnnotationIdentifier.is(annotation)) {
                            id = annotation;
                            edit1 = AnnotatedTextEdit.del(range, annotation);
                        } else {
                            this.assertChangeAnnotations(this.changeAnnotations);
                            id = this.changeAnnotations.manage(annotation);
                            edit1 = AnnotatedTextEdit.del(range, id);
                        }
                        this.edits.push(edit1);
                        if (id !== undefined) {
                            return id;
                        }
                    };
                    TextEditChangeImpl.prototype.add = function(edit1) {
                        this.edits.push(edit1);
                    };
                    TextEditChangeImpl.prototype.all = function() {
                        return this.edits;
                    };
                    TextEditChangeImpl.prototype.clear = function() {
                        this.edits.splice(0, this.edits.length);
                    };
                    TextEditChangeImpl.prototype.assertChangeAnnotations = function(value) {
                        if (value === undefined) {
                            throw new Error("Text edit change is not configured to manage change annotations.");
                        }
                    };
                    return TextEditChangeImpl;
                }();
                /**
 * A helper class
 */ var ChangeAnnotations = /** @class */ function() {
                    function ChangeAnnotations(annotations) {
                        this._annotations = annotations === undefined ? Object.create(null) : annotations;
                        this._counter = 0;
                        this._size = 0;
                    }
                    ChangeAnnotations.prototype.all = function() {
                        return this._annotations;
                    };
                    Object.defineProperty(ChangeAnnotations.prototype, "size", {
                        get: function() {
                            return this._size;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    ChangeAnnotations.prototype.manage = function(idOrAnnotation, annotation) {
                        var id;
                        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
                            id = idOrAnnotation;
                        } else {
                            id = this.nextId();
                            annotation = idOrAnnotation;
                        }
                        if (this._annotations[id] !== undefined) {
                            throw new Error("Id ".concat(id, " is already in use."));
                        }
                        if (annotation === undefined) {
                            throw new Error("No annotation provided for id ".concat(id));
                        }
                        this._annotations[id] = annotation;
                        this._size++;
                        return id;
                    };
                    ChangeAnnotations.prototype.nextId = function() {
                        this._counter++;
                        return this._counter.toString();
                    };
                    return ChangeAnnotations;
                }();
                /**
 * A workspace change helps constructing changes to a workspace.
 */ var WorkspaceChange = /** @class */ function() {
                    function WorkspaceChange(workspaceEdit) {
                        var _this = this;
                        this._textEditChanges = Object.create(null);
                        if (workspaceEdit !== undefined) {
                            this._workspaceEdit = workspaceEdit;
                            if (workspaceEdit.documentChanges) {
                                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                                workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                                workspaceEdit.documentChanges.forEach(function(change) {
                                    if (TextDocumentEdit.is(change)) {
                                        var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                                        _this._textEditChanges[change.textDocument.uri] = textEditChange;
                                    }
                                });
                            } else if (workspaceEdit.changes) {
                                Object.keys(workspaceEdit.changes).forEach(function(key) {
                                    var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                                    _this._textEditChanges[key] = textEditChange;
                                });
                            }
                        } else {
                            this._workspaceEdit = {};
                        }
                    }
                    Object.defineProperty(WorkspaceChange.prototype, "edit", {
                        /**
         * Returns the underlying {@link WorkspaceEdit} literal
         * use to be returned from a workspace edit operation like rename.
         */ get: function() {
                            this.initDocumentChanges();
                            if (this._changeAnnotations !== undefined) {
                                if (this._changeAnnotations.size === 0) {
                                    this._workspaceEdit.changeAnnotations = undefined;
                                } else {
                                    this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                                }
                            }
                            return this._workspaceEdit;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    WorkspaceChange.prototype.getTextEditChange = function(key) {
                        if (OptionalVersionedTextDocumentIdentifier.is(key)) {
                            this.initDocumentChanges();
                            if (this._workspaceEdit.documentChanges === undefined) {
                                throw new Error('Workspace edit is not configured for document changes.');
                            }
                            var textDocument = {
                                uri: key.uri,
                                version: key.version
                            };
                            var result = this._textEditChanges[textDocument.uri];
                            if (!result) {
                                var edits = [];
                                var textDocumentEdit = {
                                    textDocument: textDocument,
                                    edits: edits
                                };
                                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                                result = new TextEditChangeImpl(edits, this._changeAnnotations);
                                this._textEditChanges[textDocument.uri] = result;
                            }
                            return result;
                        } else {
                            this.initChanges();
                            if (this._workspaceEdit.changes === undefined) {
                                throw new Error('Workspace edit is not configured for normal text edit changes.');
                            }
                            var result = this._textEditChanges[key];
                            if (!result) {
                                var edits = [];
                                this._workspaceEdit.changes[key] = edits;
                                result = new TextEditChangeImpl(edits);
                                this._textEditChanges[key] = result;
                            }
                            return result;
                        }
                    };
                    WorkspaceChange.prototype.initDocumentChanges = function() {
                        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
                            this._changeAnnotations = new ChangeAnnotations();
                            this._workspaceEdit.documentChanges = [];
                            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                        }
                    };
                    WorkspaceChange.prototype.initChanges = function() {
                        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
                            this._workspaceEdit.changes = Object.create(null);
                        }
                    };
                    WorkspaceChange.prototype.createFile = function(uri, optionsOrAnnotation, options) {
                        this.initDocumentChanges();
                        if (this._workspaceEdit.documentChanges === undefined) {
                            throw new Error('Workspace edit is not configured for document changes.');
                        }
                        var annotation;
                        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
                            annotation = optionsOrAnnotation;
                        } else {
                            options = optionsOrAnnotation;
                        }
                        var operation;
                        var id;
                        if (annotation === undefined) {
                            operation = CreateFile.create(uri, options);
                        } else {
                            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                            operation = CreateFile.create(uri, options, id);
                        }
                        this._workspaceEdit.documentChanges.push(operation);
                        if (id !== undefined) {
                            return id;
                        }
                    };
                    WorkspaceChange.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {
                        this.initDocumentChanges();
                        if (this._workspaceEdit.documentChanges === undefined) {
                            throw new Error('Workspace edit is not configured for document changes.');
                        }
                        var annotation;
                        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
                            annotation = optionsOrAnnotation;
                        } else {
                            options = optionsOrAnnotation;
                        }
                        var operation;
                        var id;
                        if (annotation === undefined) {
                            operation = RenameFile.create(oldUri, newUri, options);
                        } else {
                            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                            operation = RenameFile.create(oldUri, newUri, options, id);
                        }
                        this._workspaceEdit.documentChanges.push(operation);
                        if (id !== undefined) {
                            return id;
                        }
                    };
                    WorkspaceChange.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {
                        this.initDocumentChanges();
                        if (this._workspaceEdit.documentChanges === undefined) {
                            throw new Error('Workspace edit is not configured for document changes.');
                        }
                        var annotation;
                        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
                            annotation = optionsOrAnnotation;
                        } else {
                            options = optionsOrAnnotation;
                        }
                        var operation;
                        var id;
                        if (annotation === undefined) {
                            operation = DeleteFile.create(uri, options);
                        } else {
                            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                            operation = DeleteFile.create(uri, options, id);
                        }
                        this._workspaceEdit.documentChanges.push(operation);
                        if (id !== undefined) {
                            return id;
                        }
                    };
                    return WorkspaceChange;
                }();
                /**
 * The TextDocumentIdentifier namespace provides helper functions to work with
 * {@link TextDocumentIdentifier} literals.
 */ var TextDocumentIdentifier;
                (function(TextDocumentIdentifier) {
                    /**
     * Creates a new TextDocumentIdentifier literal.
     * @param uri The document's uri.
     */ function create(uri) {
                        return {
                            uri: uri
                        };
                    }
                    TextDocumentIdentifier.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link TextDocumentIdentifier} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri);
                    }
                    TextDocumentIdentifier.is = is;
                })(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
                /**
 * The VersionedTextDocumentIdentifier namespace provides helper functions to work with
 * {@link VersionedTextDocumentIdentifier} literals.
 */ var VersionedTextDocumentIdentifier;
                (function(VersionedTextDocumentIdentifier) {
                    /**
     * Creates a new VersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */ function create(uri, version) {
                        return {
                            uri: uri,
                            version: version
                        };
                    }
                    VersionedTextDocumentIdentifier.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link VersionedTextDocumentIdentifier} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
                    }
                    VersionedTextDocumentIdentifier.is = is;
                })(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
                /**
 * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with
 * {@link OptionalVersionedTextDocumentIdentifier} literals.
 */ var OptionalVersionedTextDocumentIdentifier;
                (function(OptionalVersionedTextDocumentIdentifier) {
                    /**
     * Creates a new OptionalVersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */ function create(uri, version) {
                        return {
                            uri: uri,
                            version: version
                        };
                    }
                    OptionalVersionedTextDocumentIdentifier.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link OptionalVersionedTextDocumentIdentifier} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
                    }
                    OptionalVersionedTextDocumentIdentifier.is = is;
                })(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
                /**
 * The TextDocumentItem namespace provides helper functions to work with
 * {@link TextDocumentItem} literals.
 */ var TextDocumentItem;
                (function(TextDocumentItem) {
                    /**
     * Creates a new TextDocumentItem literal.
     * @param uri The document's uri.
     * @param languageId The document's language identifier.
     * @param version The document's version number.
     * @param text The document's text.
     */ function create(uri, languageId, version, text) {
                        return {
                            uri: uri,
                            languageId: languageId,
                            version: version,
                            text: text
                        };
                    }
                    TextDocumentItem.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link TextDocumentItem} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
                    }
                    TextDocumentItem.is = is;
                })(TextDocumentItem || (TextDocumentItem = {}));
                /**
 * Describes the content type that a client supports in various
 * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
 *
 * Please note that `MarkupKinds` must not start with a `$`. This kinds
 * are reserved for internal usage.
 */ var MarkupKind;
                (function(MarkupKind) {
                    /**
     * Plain text is supported as a content format
     */ MarkupKind.PlainText = 'plaintext';
                    /**
     * Markdown is supported as a content format
     */ MarkupKind.Markdown = 'markdown';
                    /**
     * Checks whether the given value is a value of the {@link MarkupKind} type.
     */ function is(value) {
                        var candidate = value;
                        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;
                    }
                    MarkupKind.is = is;
                })(MarkupKind || (MarkupKind = {}));
                var MarkupContent1;
                (function(MarkupContent1) {
                    /**
     * Checks whether the given value conforms to the {@link MarkupContent} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
                    }
                    MarkupContent1.is = is;
                })(MarkupContent1 || (MarkupContent1 = {}));
                /**
 * The kind of a completion entry.
 */ var CompletionItemKind1;
                (function(CompletionItemKind1) {
                    CompletionItemKind1.Text = 1;
                    CompletionItemKind1.Method = 2;
                    CompletionItemKind1.Function = 3;
                    CompletionItemKind1.Constructor = 4;
                    CompletionItemKind1.Field = 5;
                    CompletionItemKind1.Variable = 6;
                    CompletionItemKind1.Class = 7;
                    CompletionItemKind1.Interface = 8;
                    CompletionItemKind1.Module = 9;
                    CompletionItemKind1.Property = 10;
                    CompletionItemKind1.Unit = 11;
                    CompletionItemKind1.Value = 12;
                    CompletionItemKind1.Enum = 13;
                    CompletionItemKind1.Keyword = 14;
                    CompletionItemKind1.Snippet = 15;
                    CompletionItemKind1.Color = 16;
                    CompletionItemKind1.File = 17;
                    CompletionItemKind1.Reference = 18;
                    CompletionItemKind1.Folder = 19;
                    CompletionItemKind1.EnumMember = 20;
                    CompletionItemKind1.Constant = 21;
                    CompletionItemKind1.Struct = 22;
                    CompletionItemKind1.Event = 23;
                    CompletionItemKind1.Operator = 24;
                    CompletionItemKind1.TypeParameter = 25;
                })(CompletionItemKind1 || (CompletionItemKind1 = {}));
                /**
 * Defines whether the insert text in a completion item should be interpreted as
 * plain text or a snippet.
 */ var InsertTextFormat1;
                (function(InsertTextFormat1) {
                    /**
     * The primary text to be inserted is treated as a plain string.
     */ InsertTextFormat1.PlainText = 1;
                    /**
     * The primary text to be inserted is treated as a snippet.
     *
     * A snippet can define tab stops and placeholders with `$1`, `$2`
     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
     * the end of the snippet. Placeholders with equal identifiers are linked,
     * that is typing in one will update others too.
     *
     * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax
     */ InsertTextFormat1.Snippet = 2;
                })(InsertTextFormat1 || (InsertTextFormat1 = {}));
                /**
 * Completion item tags are extra annotations that tweak the rendering of a completion
 * item.
 *
 * @since 3.15.0
 */ var CompletionItemTag;
                (function(CompletionItemTag) {
                    /**
     * Render a completion as obsolete, usually using a strike-out.
     */ CompletionItemTag.Deprecated = 1;
                })(CompletionItemTag || (CompletionItemTag = {}));
                /**
 * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.
 *
 * @since 3.16.0
 */ var InsertReplaceEdit;
                (function(InsertReplaceEdit) {
                    /**
     * Creates a new insert / replace edit
     */ function create(newText, insert, replace) {
                        return {
                            newText: newText,
                            insert: insert,
                            replace: replace
                        };
                    }
                    InsertReplaceEdit.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link InsertReplaceEdit} interface.
     */ function is(value) {
                        var candidate = value;
                        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
                    }
                    InsertReplaceEdit.is = is;
                })(InsertReplaceEdit || (InsertReplaceEdit = {}));
                /**
 * How whitespace and indentation is handled during completion
 * item insertion.
 *
 * @since 3.16.0
 */ var InsertTextMode;
                (function(InsertTextMode) {
                    /**
     * The insertion or replace strings is taken as it is. If the
     * value is multi line the lines below the cursor will be
     * inserted using the indentation defined in the string value.
     * The client will not apply any kind of adjustments to the
     * string.
     */ InsertTextMode.asIs = 1;
                    /**
     * The editor adjusts leading whitespace of new lines so that
     * they match the indentation up to the cursor of the line for
     * which the item is accepted.
     *
     * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a
     * multi line completion item is indented using 2 tabs and all
     * following lines inserted will be indented using 2 tabs as well.
     */ InsertTextMode.adjustIndentation = 2;
                })(InsertTextMode || (InsertTextMode = {}));
                var CompletionItemLabelDetails;
                (function(CompletionItemLabelDetails) {
                    function is(value) {
                        var candidate = value;
                        return candidate && (Is.string(candidate.detail) || candidate.detail === undefined) && (Is.string(candidate.description) || candidate.description === undefined);
                    }
                    CompletionItemLabelDetails.is = is;
                })(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));
                /**
 * The CompletionItem namespace provides functions to deal with
 * completion items.
 */ var CompletionItem;
                (function(CompletionItem) {
                    /**
     * Create a completion item and seed it with a label.
     * @param label The completion item's label
     */ function create(label) {
                        return {
                            label: label
                        };
                    }
                    CompletionItem.create = create;
                })(CompletionItem || (CompletionItem = {}));
                /**
 * The CompletionList namespace provides functions to deal with
 * completion lists.
 */ var CompletionList;
                (function(CompletionList) {
                    /**
     * Creates a new completion list.
     *
     * @param items The completion items.
     * @param isIncomplete The list is not complete.
     */ function create(items, isIncomplete) {
                        return {
                            items: items ? items : [],
                            isIncomplete: !!isIncomplete
                        };
                    }
                    CompletionList.create = create;
                })(CompletionList || (CompletionList = {}));
                var MarkedString1;
                (function(MarkedString1) {
                    /**
     * Creates a marked string from plain text.
     *
     * @param plainText The plain text.
     */ function fromPlainText(plainText) {
                        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
                    }
                    MarkedString1.fromPlainText = fromPlainText;
                    /**
     * Checks whether the given value conforms to the {@link MarkedString} type.
     */ function is(value) {
                        var candidate = value;
                        return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
                    }
                    MarkedString1.is = is;
                })(MarkedString1 || (MarkedString1 = {}));
                var Hover;
                (function(Hover) {
                    /**
     * Checks whether the given value conforms to the {@link Hover} interface.
     */ function is(value) {
                        var candidate = value;
                        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent1.is(candidate.contents) || MarkedString1.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString1.is)) && (value.range === undefined || Range.is(value.range));
                    }
                    Hover.is = is;
                })(Hover || (Hover = {}));
                /**
 * The ParameterInformation namespace provides helper functions to work with
 * {@link ParameterInformation} literals.
 */ var ParameterInformation;
                (function(ParameterInformation) {
                    /**
     * Creates a new parameter information literal.
     *
     * @param label A label string.
     * @param documentation A doc string.
     */ function create(label, documentation) {
                        return documentation ? {
                            label: label,
                            documentation: documentation
                        } : {
                            label: label
                        };
                    }
                    ParameterInformation.create = create;
                })(ParameterInformation || (ParameterInformation = {}));
                /**
 * The SignatureInformation namespace provides helper functions to work with
 * {@link SignatureInformation} literals.
 */ var SignatureInformation;
                (function(SignatureInformation) {
                    function create(label, documentation) {
                        var parameters = [];
                        for(var _i = 2; _i < arguments.length; _i++){
                            parameters[_i - 2] = arguments[_i];
                        }
                        var result = {
                            label: label
                        };
                        if (Is.defined(documentation)) {
                            result.documentation = documentation;
                        }
                        if (Is.defined(parameters)) {
                            result.parameters = parameters;
                        } else {
                            result.parameters = [];
                        }
                        return result;
                    }
                    SignatureInformation.create = create;
                })(SignatureInformation || (SignatureInformation = {}));
                /**
 * A document highlight kind.
 */ var DocumentHighlightKind;
                (function(DocumentHighlightKind) {
                    /**
     * A textual occurrence.
     */ DocumentHighlightKind.Text = 1;
                    /**
     * Read-access of a symbol, like reading a variable.
     */ DocumentHighlightKind.Read = 2;
                    /**
     * Write-access of a symbol, like writing to a variable.
     */ DocumentHighlightKind.Write = 3;
                })(DocumentHighlightKind || (DocumentHighlightKind = {}));
                /**
 * DocumentHighlight namespace to provide helper functions to work with
 * {@link DocumentHighlight} literals.
 */ var DocumentHighlight;
                (function(DocumentHighlight) {
                    /**
     * Create a DocumentHighlight object.
     * @param range The range the highlight applies to.
     * @param kind The highlight kind
     */ function create(range, kind) {
                        var result = {
                            range: range
                        };
                        if (Is.number(kind)) {
                            result.kind = kind;
                        }
                        return result;
                    }
                    DocumentHighlight.create = create;
                })(DocumentHighlight || (DocumentHighlight = {}));
                /**
 * A symbol kind.
 */ var SymbolKind;
                (function(SymbolKind) {
                    SymbolKind.File = 1;
                    SymbolKind.Module = 2;
                    SymbolKind.Namespace = 3;
                    SymbolKind.Package = 4;
                    SymbolKind.Class = 5;
                    SymbolKind.Method = 6;
                    SymbolKind.Property = 7;
                    SymbolKind.Field = 8;
                    SymbolKind.Constructor = 9;
                    SymbolKind.Enum = 10;
                    SymbolKind.Interface = 11;
                    SymbolKind.Function = 12;
                    SymbolKind.Variable = 13;
                    SymbolKind.Constant = 14;
                    SymbolKind.String = 15;
                    SymbolKind.Number = 16;
                    SymbolKind.Boolean = 17;
                    SymbolKind.Array = 18;
                    SymbolKind.Object = 19;
                    SymbolKind.Key = 20;
                    SymbolKind.Null = 21;
                    SymbolKind.EnumMember = 22;
                    SymbolKind.Struct = 23;
                    SymbolKind.Event = 24;
                    SymbolKind.Operator = 25;
                    SymbolKind.TypeParameter = 26;
                })(SymbolKind || (SymbolKind = {}));
                /**
 * Symbol tags are extra annotations that tweak the rendering of a symbol.
 *
 * @since 3.16
 */ var SymbolTag;
                (function(SymbolTag) {
                    /**
     * Render a symbol as obsolete, usually using a strike-out.
     */ SymbolTag.Deprecated = 1;
                })(SymbolTag || (SymbolTag = {}));
                var SymbolInformation;
                (function(SymbolInformation) {
                    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the location of the symbol.
     * @param uri The resource of the location of symbol.
     * @param containerName The name of the symbol containing the symbol.
     */ function create(name, kind, range, uri, containerName) {
                        var result = {
                            name: name,
                            kind: kind,
                            location: {
                                uri: uri,
                                range: range
                            }
                        };
                        if (containerName) {
                            result.containerName = containerName;
                        }
                        return result;
                    }
                    SymbolInformation.create = create;
                })(SymbolInformation || (SymbolInformation = {}));
                var WorkspaceSymbol;
                (function(WorkspaceSymbol) {
                    /**
     * Create a new workspace symbol.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param uri The resource of the location of the symbol.
     * @param range An options range of the location.
     * @returns A WorkspaceSymbol.
     */ function create(name, kind, uri, range) {
                        return range !== undefined ? {
                            name: name,
                            kind: kind,
                            location: {
                                uri: uri,
                                range: range
                            }
                        } : {
                            name: name,
                            kind: kind,
                            location: {
                                uri: uri
                            }
                        };
                    }
                    WorkspaceSymbol.create = create;
                })(WorkspaceSymbol || (WorkspaceSymbol = {}));
                var DocumentSymbol;
                (function(DocumentSymbol) {
                    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param detail The detail of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the symbol.
     * @param selectionRange The selectionRange of the symbol.
     * @param children Children of the symbol.
     */ function create(name, detail, kind, range, selectionRange, children) {
                        var result = {
                            name: name,
                            detail: detail,
                            kind: kind,
                            range: range,
                            selectionRange: selectionRange
                        };
                        if (children !== undefined) {
                            result.children = children;
                        }
                        return result;
                    }
                    DocumentSymbol.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link DocumentSymbol} interface.
     */ function is(value) {
                        var candidate = value;
                        return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === undefined || Is.string(candidate.detail)) && (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) && (candidate.children === undefined || Array.isArray(candidate.children)) && (candidate.tags === undefined || Array.isArray(candidate.tags));
                    }
                    DocumentSymbol.is = is;
                })(DocumentSymbol || (DocumentSymbol = {}));
                /**
 * A set of predefined code action kinds
 */ var CodeActionKind;
                (function(CodeActionKind) {
                    /**
     * Empty kind.
     */ CodeActionKind.Empty = '';
                    /**
     * Base kind for quickfix actions: 'quickfix'
     */ CodeActionKind.QuickFix = 'quickfix';
                    /**
     * Base kind for refactoring actions: 'refactor'
     */ CodeActionKind.Refactor = 'refactor';
                    /**
     * Base kind for refactoring extraction actions: 'refactor.extract'
     *
     * Example extract actions:
     *
     * - Extract method
     * - Extract function
     * - Extract variable
     * - Extract interface from class
     * - ...
     */ CodeActionKind.RefactorExtract = 'refactor.extract';
                    /**
     * Base kind for refactoring inline actions: 'refactor.inline'
     *
     * Example inline actions:
     *
     * - Inline function
     * - Inline variable
     * - Inline constant
     * - ...
     */ CodeActionKind.RefactorInline = 'refactor.inline';
                    /**
     * Base kind for refactoring rewrite actions: 'refactor.rewrite'
     *
     * Example rewrite actions:
     *
     * - Convert JavaScript function to class
     * - Add or remove parameter
     * - Encapsulate field
     * - Make method static
     * - Move method to base class
     * - ...
     */ CodeActionKind.RefactorRewrite = 'refactor.rewrite';
                    /**
     * Base kind for source actions: `source`
     *
     * Source code actions apply to the entire file.
     */ CodeActionKind.Source = 'source';
                    /**
     * Base kind for an organize imports source action: `source.organizeImports`
     */ CodeActionKind.SourceOrganizeImports = 'source.organizeImports';
                    /**
     * Base kind for auto-fix source actions: `source.fixAll`.
     *
     * Fix all actions automatically fix errors that have a clear fix that do not require user input.
     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.
     *
     * @since 3.15.0
     */ CodeActionKind.SourceFixAll = 'source.fixAll';
                })(CodeActionKind || (CodeActionKind = {}));
                /**
 * The reason why code actions were requested.
 *
 * @since 3.17.0
 */ var CodeActionTriggerKind;
                (function(CodeActionTriggerKind) {
                    /**
     * Code actions were explicitly requested by the user or by an extension.
     */ CodeActionTriggerKind.Invoked = 1;
                    /**
     * Code actions were requested automatically.
     *
     * This typically happens when current selection in a file changes, but can
     * also be triggered when file content changes.
     */ CodeActionTriggerKind.Automatic = 2;
                })(CodeActionTriggerKind || (CodeActionTriggerKind = {}));
                /**
 * The CodeActionContext namespace provides helper functions to work with
 * {@link CodeActionContext} literals.
 */ var CodeActionContext;
                (function(CodeActionContext) {
                    /**
     * Creates a new CodeActionContext literal.
     */ function create(diagnostics, only, triggerKind) {
                        var result = {
                            diagnostics: diagnostics
                        };
                        if (only !== undefined && only !== null) {
                            result.only = only;
                        }
                        if (triggerKind !== undefined && triggerKind !== null) {
                            result.triggerKind = triggerKind;
                        }
                        return result;
                    }
                    CodeActionContext.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link CodeActionContext} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
                    }
                    CodeActionContext.is = is;
                })(CodeActionContext || (CodeActionContext = {}));
                var CodeAction;
                (function(CodeAction) {
                    function create(title, kindOrCommandOrEdit, kind) {
                        var result = {
                            title: title
                        };
                        var checkKind = true;
                        if (typeof kindOrCommandOrEdit === 'string') {
                            checkKind = false;
                            result.kind = kindOrCommandOrEdit;
                        } else if (Command.is(kindOrCommandOrEdit)) {
                            result.command = kindOrCommandOrEdit;
                        } else {
                            result.edit = kindOrCommandOrEdit;
                        }
                        if (checkKind && kind !== undefined) {
                            result.kind = kind;
                        }
                        return result;
                    }
                    CodeAction.create = create;
                    function is(value) {
                        var candidate = value;
                        return candidate && Is.string(candidate.title) && (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === undefined || Is.string(candidate.kind)) && (candidate.edit !== undefined || candidate.command !== undefined) && (candidate.command === undefined || Command.is(candidate.command)) && (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) && (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));
                    }
                    CodeAction.is = is;
                })(CodeAction || (CodeAction = {}));
                /**
 * The CodeLens namespace provides helper functions to work with
 * {@link CodeLens} literals.
 */ var CodeLens;
                (function(CodeLens) {
                    /**
     * Creates a new CodeLens literal.
     */ function create(range, data) {
                        var result = {
                            range: range
                        };
                        if (Is.defined(data)) {
                            result.data = data;
                        }
                        return result;
                    }
                    CodeLens.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link CodeLens} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
                    }
                    CodeLens.is = is;
                })(CodeLens || (CodeLens = {}));
                /**
 * The FormattingOptions namespace provides helper functions to work with
 * {@link FormattingOptions} literals.
 */ var FormattingOptions;
                (function(FormattingOptions) {
                    /**
     * Creates a new FormattingOptions literal.
     */ function create(tabSize, insertSpaces) {
                        return {
                            tabSize: tabSize,
                            insertSpaces: insertSpaces
                        };
                    }
                    FormattingOptions.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link FormattingOptions} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
                    }
                    FormattingOptions.is = is;
                })(FormattingOptions || (FormattingOptions = {}));
                /**
 * The DocumentLink namespace provides helper functions to work with
 * {@link DocumentLink} literals.
 */ var DocumentLink;
                (function(DocumentLink) {
                    /**
     * Creates a new DocumentLink literal.
     */ function create(range, target, data) {
                        return {
                            range: range,
                            target: target,
                            data: data
                        };
                    }
                    DocumentLink.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link DocumentLink} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
                    }
                    DocumentLink.is = is;
                })(DocumentLink || (DocumentLink = {}));
                /**
 * The SelectionRange namespace provides helper function to work with
 * SelectionRange literals.
 */ var SelectionRange;
                (function(SelectionRange) {
                    /**
     * Creates a new SelectionRange
     * @param range the range.
     * @param parent an optional parent.
     */ function create(range, parent) {
                        return {
                            range: range,
                            parent: parent
                        };
                    }
                    SelectionRange.create = create;
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));
                    }
                    SelectionRange.is = is;
                })(SelectionRange || (SelectionRange = {}));
                /**
 * A set of predefined token types. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */ var SemanticTokenTypes;
                (function(SemanticTokenTypes) {
                    SemanticTokenTypes["namespace"] = "namespace";
                    /**
     * Represents a generic type. Acts as a fallback for types which can't be mapped to
     * a specific type like class or enum.
     */ SemanticTokenTypes["type"] = "type";
                    SemanticTokenTypes["class"] = "class";
                    SemanticTokenTypes["enum"] = "enum";
                    SemanticTokenTypes["interface"] = "interface";
                    SemanticTokenTypes["struct"] = "struct";
                    SemanticTokenTypes["typeParameter"] = "typeParameter";
                    SemanticTokenTypes["parameter"] = "parameter";
                    SemanticTokenTypes["variable"] = "variable";
                    SemanticTokenTypes["property"] = "property";
                    SemanticTokenTypes["enumMember"] = "enumMember";
                    SemanticTokenTypes["event"] = "event";
                    SemanticTokenTypes["function"] = "function";
                    SemanticTokenTypes["method"] = "method";
                    SemanticTokenTypes["macro"] = "macro";
                    SemanticTokenTypes["keyword"] = "keyword";
                    SemanticTokenTypes["modifier"] = "modifier";
                    SemanticTokenTypes["comment"] = "comment";
                    SemanticTokenTypes["string"] = "string";
                    SemanticTokenTypes["number"] = "number";
                    SemanticTokenTypes["regexp"] = "regexp";
                    SemanticTokenTypes["operator"] = "operator";
                    /**
     * @since 3.17.0
     */ SemanticTokenTypes["decorator"] = "decorator";
                })(SemanticTokenTypes || (SemanticTokenTypes = {}));
                /**
 * A set of predefined token modifiers. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */ var SemanticTokenModifiers;
                (function(SemanticTokenModifiers) {
                    SemanticTokenModifiers["declaration"] = "declaration";
                    SemanticTokenModifiers["definition"] = "definition";
                    SemanticTokenModifiers["readonly"] = "readonly";
                    SemanticTokenModifiers["static"] = "static";
                    SemanticTokenModifiers["deprecated"] = "deprecated";
                    SemanticTokenModifiers["abstract"] = "abstract";
                    SemanticTokenModifiers["async"] = "async";
                    SemanticTokenModifiers["modification"] = "modification";
                    SemanticTokenModifiers["documentation"] = "documentation";
                    SemanticTokenModifiers["defaultLibrary"] = "defaultLibrary";
                })(SemanticTokenModifiers || (SemanticTokenModifiers = {}));
                /**
 * @since 3.16.0
 */ var SemanticTokens;
                (function(SemanticTokens) {
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && (candidate.resultId === undefined || typeof candidate.resultId === 'string') && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');
                    }
                    SemanticTokens.is = is;
                })(SemanticTokens || (SemanticTokens = {}));
                /**
 * The InlineValueText namespace provides functions to deal with InlineValueTexts.
 *
 * @since 3.17.0
 */ var InlineValueText;
                (function(InlineValueText) {
                    /**
     * Creates a new InlineValueText literal.
     */ function create(range, text) {
                        return {
                            range: range,
                            text: text
                        };
                    }
                    InlineValueText.create = create;
                    function is(value) {
                        var candidate = value;
                        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
                    }
                    InlineValueText.is = is;
                })(InlineValueText || (InlineValueText = {}));
                /**
 * The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.
 *
 * @since 3.17.0
 */ var InlineValueVariableLookup;
                (function(InlineValueVariableLookup) {
                    /**
     * Creates a new InlineValueText literal.
     */ function create(range, variableName, caseSensitiveLookup) {
                        return {
                            range: range,
                            variableName: variableName,
                            caseSensitiveLookup: caseSensitiveLookup
                        };
                    }
                    InlineValueVariableLookup.create = create;
                    function is(value) {
                        var candidate = value;
                        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === undefined);
                    }
                    InlineValueVariableLookup.is = is;
                })(InlineValueVariableLookup || (InlineValueVariableLookup = {}));
                /**
 * The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.
 *
 * @since 3.17.0
 */ var InlineValueEvaluatableExpression;
                (function(InlineValueEvaluatableExpression) {
                    /**
     * Creates a new InlineValueEvaluatableExpression literal.
     */ function create(range, expression) {
                        return {
                            range: range,
                            expression: expression
                        };
                    }
                    InlineValueEvaluatableExpression.create = create;
                    function is(value) {
                        var candidate = value;
                        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === undefined);
                    }
                    InlineValueEvaluatableExpression.is = is;
                })(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));
                /**
 * The InlineValueContext namespace provides helper functions to work with
 * {@link InlineValueContext} literals.
 *
 * @since 3.17.0
 */ var InlineValueContext;
                (function(InlineValueContext) {
                    /**
     * Creates a new InlineValueContext literal.
     */ function create(frameId, stoppedLocation) {
                        return {
                            frameId: frameId,
                            stoppedLocation: stoppedLocation
                        };
                    }
                    InlineValueContext.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link InlineValueContext} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Range.is(value.stoppedLocation);
                    }
                    InlineValueContext.is = is;
                })(InlineValueContext || (InlineValueContext = {}));
                /**
 * Inlay hint kinds.
 *
 * @since 3.17.0
 */ var InlayHintKind;
                (function(InlayHintKind) {
                    /**
     * An inlay hint that for a type annotation.
     */ InlayHintKind.Type = 1;
                    /**
     * An inlay hint that is for a parameter.
     */ InlayHintKind.Parameter = 2;
                    function is(value) {
                        return value === 1 || value === 2;
                    }
                    InlayHintKind.is = is;
                })(InlayHintKind || (InlayHintKind = {}));
                var InlayHintLabelPart;
                (function(InlayHintLabelPart) {
                    function create(value) {
                        return {
                            value: value
                        };
                    }
                    InlayHintLabelPart.create = create;
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent1.is(candidate.tooltip)) && (candidate.location === undefined || Location.is(candidate.location)) && (candidate.command === undefined || Command.is(candidate.command));
                    }
                    InlayHintLabelPart.is = is;
                })(InlayHintLabelPart || (InlayHintLabelPart = {}));
                var InlayHint;
                (function(InlayHint) {
                    function create(position, label, kind) {
                        var result = {
                            position: position,
                            label: label
                        };
                        if (kind !== undefined) {
                            result.kind = kind;
                        }
                        return result;
                    }
                    InlayHint.create = create;
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && Position.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === undefined || InlayHintKind.is(candidate.kind)) && candidate.textEdits === undefined || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent1.is(candidate.tooltip)) && (candidate.paddingLeft === undefined || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === undefined || Is.boolean(candidate.paddingRight));
                    }
                    InlayHint.is = is;
                })(InlayHint || (InlayHint = {}));
                var WorkspaceFolder;
                (function(WorkspaceFolder) {
                    function is(value) {
                        var candidate = value;
                        return Is.objectLiteral(candidate) && URI1.is(candidate.uri) && Is.string(candidate.name);
                    }
                    WorkspaceFolder.is = is;
                })(WorkspaceFolder || (WorkspaceFolder = {}));
                var EOL = [
                    '\n',
                    '\r\n',
                    '\r'
                ];
                /**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */ var TextDocument;
                (function(TextDocument) {
                    /**
     * Creates a new ITextDocument literal from the given uri and content.
     * @param uri The document's uri.
     * @param languageId The document's language Id.
     * @param version The document's version.
     * @param content The document's content.
     */ function create(uri, languageId, version, content) {
                        return new FullTextDocument(uri, languageId, version, content);
                    }
                    TextDocument.create = create;
                    /**
     * Checks whether the given literal conforms to the {@link ITextDocument} interface.
     */ function is(value) {
                        var candidate = value;
                        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
                    }
                    TextDocument.is = is;
                    function applyEdits(document1, edits) {
                        var text = document1.getText();
                        var sortedEdits = mergeSort(edits, function(a, b) {
                            var diff = a.range.start.line - b.range.start.line;
                            if (diff === 0) {
                                return a.range.start.character - b.range.start.character;
                            }
                            return diff;
                        });
                        var lastModifiedOffset = text.length;
                        for(var i = sortedEdits.length - 1; i >= 0; i--){
                            var e = sortedEdits[i];
                            var startOffset = document1.offsetAt(e.range.start);
                            var endOffset = document1.offsetAt(e.range.end);
                            if (endOffset <= lastModifiedOffset) {
                                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
                            } else {
                                throw new Error('Overlapping edit');
                            }
                            lastModifiedOffset = startOffset;
                        }
                        return text;
                    }
                    TextDocument.applyEdits = applyEdits;
                    function mergeSort(data, compare) {
                        if (data.length <= 1) {
                            // sorted
                            return data;
                        }
                        var p = data.length / 2 | 0;
                        var left = data.slice(0, p);
                        var right = data.slice(p);
                        mergeSort(left, compare);
                        mergeSort(right, compare);
                        var leftIdx = 0;
                        var rightIdx = 0;
                        var i = 0;
                        while(leftIdx < left.length && rightIdx < right.length){
                            var ret = compare(left[leftIdx], right[rightIdx]);
                            if (ret <= 0) {
                                // smaller_equal -> take left to preserve order
                                data[i++] = left[leftIdx++];
                            } else {
                                // greater -> take right
                                data[i++] = right[rightIdx++];
                            }
                        }
                        while(leftIdx < left.length){
                            data[i++] = left[leftIdx++];
                        }
                        while(rightIdx < right.length){
                            data[i++] = right[rightIdx++];
                        }
                        return data;
                    }
                })(TextDocument || (TextDocument = {}));
                /**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */ var FullTextDocument = /** @class */ function() {
                    function FullTextDocument(uri, languageId, version, content) {
                        this._uri = uri;
                        this._languageId = languageId;
                        this._version = version;
                        this._content = content;
                        this._lineOffsets = undefined;
                    }
                    Object.defineProperty(FullTextDocument.prototype, "uri", {
                        get: function() {
                            return this._uri;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    Object.defineProperty(FullTextDocument.prototype, "languageId", {
                        get: function() {
                            return this._languageId;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    Object.defineProperty(FullTextDocument.prototype, "version", {
                        get: function() {
                            return this._version;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    FullTextDocument.prototype.getText = function(range) {
                        if (range) {
                            var start = this.offsetAt(range.start);
                            var end = this.offsetAt(range.end);
                            return this._content.substring(start, end);
                        }
                        return this._content;
                    };
                    FullTextDocument.prototype.update = function(event, version) {
                        this._content = event.text;
                        this._version = version;
                        this._lineOffsets = undefined;
                    };
                    FullTextDocument.prototype.getLineOffsets = function() {
                        if (this._lineOffsets === undefined) {
                            var lineOffsets = [];
                            var text = this._content;
                            var isLineStart = true;
                            for(var i = 0; i < text.length; i++){
                                if (isLineStart) {
                                    lineOffsets.push(i);
                                    isLineStart = false;
                                }
                                var ch = text.charAt(i);
                                isLineStart = ch === '\r' || ch === '\n';
                                if (ch === '\r' && i + 1 < text.length && text.charAt(i + 1) === '\n') {
                                    i++;
                                }
                            }
                            if (isLineStart && text.length > 0) {
                                lineOffsets.push(text.length);
                            }
                            this._lineOffsets = lineOffsets;
                        }
                        return this._lineOffsets;
                    };
                    FullTextDocument.prototype.positionAt = function(offset) {
                        offset = Math.max(Math.min(offset, this._content.length), 0);
                        var lineOffsets = this.getLineOffsets();
                        var low = 0, high = lineOffsets.length;
                        if (high === 0) {
                            return Position.create(0, offset);
                        }
                        while(low < high){
                            var mid = Math.floor((low + high) / 2);
                            if (lineOffsets[mid] > offset) {
                                high = mid;
                            } else {
                                low = mid + 1;
                            }
                        }
                        // low is the least x for which the line offset is larger than the current offset
                        // or array.length if no line offset is larger than the current offset
                        var line = low - 1;
                        return Position.create(line, offset - lineOffsets[line]);
                    };
                    FullTextDocument.prototype.offsetAt = function(position) {
                        var lineOffsets = this.getLineOffsets();
                        if (position.line >= lineOffsets.length) {
                            return this._content.length;
                        } else if (position.line < 0) {
                            return 0;
                        }
                        var lineOffset = lineOffsets[position.line];
                        var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
                        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
                    };
                    Object.defineProperty(FullTextDocument.prototype, "lineCount", {
                        get: function() {
                            return this.getLineOffsets().length;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    return FullTextDocument;
                }();
                var Is;
                (function(Is) {
                    var toString = Object.prototype.toString;
                    function defined(value) {
                        return typeof value !== 'undefined';
                    }
                    Is.defined = defined;
                    function undefined1(value) {
                        return typeof value === 'undefined';
                    }
                    Is.undefined = undefined1;
                    function boolean(value) {
                        return value === true || value === false;
                    }
                    Is.boolean = boolean;
                    function string(value) {
                        return toString.call(value) === '[object String]';
                    }
                    Is.string = string;
                    function number(value) {
                        return toString.call(value) === '[object Number]';
                    }
                    Is.number = number;
                    function numberRange(value, min, max) {
                        return toString.call(value) === '[object Number]' && min <= value && value <= max;
                    }
                    Is.numberRange = numberRange;
                    function integer(value) {
                        return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;
                    }
                    Is.integer = integer;
                    function uinteger(value) {
                        return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;
                    }
                    Is.uinteger = uinteger;
                    function func(value) {
                        return toString.call(value) === '[object Function]';
                    }
                    Is.func = func;
                    function objectLiteral(value) {
                        // Strictly speaking class instances pass this check as well. Since the LSP
                        // doesn't use classes we ignore this for now. If we do we need to add something
                        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
                        return value !== null && typeof value === 'object';
                    }
                    Is.objectLiteral = objectLiteral;
                    function typedArray(value, check) {
                        return Array.isArray(value) && value.every(check);
                    }
                    Is.typedArray = typedArray;
                })(Is || (Is = {}));
            /***/ },
            /***/ 2730: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_694964__)=>{
                "use strict";
                var forEach = __nested_webpack_require_694964__(705);
                var availableTypedArrays = __nested_webpack_require_694964__(4834);
                var callBind = __nested_webpack_require_694964__(8498);
                var callBound = __nested_webpack_require_694964__(9818);
                var gOPD = __nested_webpack_require_694964__(9336);
                var $toString = callBound('Object.prototype.toString');
                var hasToStringTag = __nested_webpack_require_694964__(1913)();
                var g = typeof globalThis === 'undefined' ? __nested_webpack_require_694964__.g : globalThis;
                var typedArrays = availableTypedArrays();
                var $slice = callBound('String.prototype.slice');
                var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
                var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
                    for(var i = 0; i < array.length; i += 1){
                        if (array[i] === value) {
                            return i;
                        }
                    }
                    return -1;
                };
                var cache = {
                    __proto__: null
                };
                if (hasToStringTag && gOPD && getPrototypeOf) {
                    forEach(typedArrays, function(typedArray) {
                        var arr = new g[typedArray]();
                        if (Symbol.toStringTag in arr) {
                            var proto = getPrototypeOf(arr);
                            var descriptor = gOPD(proto, Symbol.toStringTag);
                            if (!descriptor) {
                                var superProto = getPrototypeOf(proto);
                                descriptor = gOPD(superProto, Symbol.toStringTag);
                            }
                            cache['$' + typedArray] = callBind(descriptor.get);
                        }
                    });
                } else {
                    forEach(typedArrays, function(typedArray) {
                        var arr = new g[typedArray]();
                        cache['$' + typedArray] = callBind(arr.slice);
                    });
                }
                var tryTypedArrays = function tryAllTypedArrays(value) {
                    var found = false;
                    forEach(cache, function(getter, typedArray) {
                        if (!found) {
                            try {
                                if ('$' + getter(value) === typedArray) {
                                    found = $slice(typedArray, 1);
                                }
                            } catch (e) {}
                        }
                    });
                    return found;
                };
                var trySlices = function tryAllSlices(value) {
                    var found = false;
                    forEach(cache, function(getter, name) {
                        if (!found) {
                            try {
                                getter(value);
                                found = $slice(name, 1);
                            } catch (e) {}
                        }
                    });
                    return found;
                };
                module1.exports = function whichTypedArray(value) {
                    if (!value || typeof value !== 'object') {
                        return false;
                    }
                    if (!hasToStringTag) {
                        var tag = $slice($toString(value), 8, -1);
                        if ($indexOf(typedArrays, tag) > -1) {
                            return tag;
                        }
                        if (tag !== 'Object') {
                            return false;
                        }
                        // node < 0.6 hits here on real Typed Arrays
                        return trySlices(value);
                    }
                    if (!gOPD) {
                        return null;
                    } // unknown engine
                    return tryTypedArrays(value);
                };
            /***/ },
            /***/ 4834: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_699211__)=>{
                "use strict";
                var possibleNames = [
                    'BigInt64Array',
                    'BigUint64Array',
                    'Float32Array',
                    'Float64Array',
                    'Int16Array',
                    'Int32Array',
                    'Int8Array',
                    'Uint16Array',
                    'Uint32Array',
                    'Uint8Array',
                    'Uint8ClampedArray'
                ];
                var g = typeof globalThis === 'undefined' ? __nested_webpack_require_699211__.g : globalThis;
                module1.exports = function availableTypedArrays() {
                    var out = [];
                    for(var i = 0; i < possibleNames.length; i++){
                        if (typeof g[possibleNames[i]] === 'function') {
                            out[out.length] = possibleNames[i];
                        }
                    }
                    return out;
                };
            /***/ },
            /***/ 8041: /***/ (__unused_webpack___webpack_module__, __nested_webpack_exports__, __nested_webpack_require_700325__)=>{
                "use strict";
                /* harmony export */ __nested_webpack_require_700325__.d(__nested_webpack_exports__, {
                    /* harmony export */ V: ()=>/* binding */ TextDocument
                });
                /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ class FullTextDocument {
                    get uri() {
                        return this._uri;
                    }
                    get languageId() {
                        return this._languageId;
                    }
                    get version() {
                        return this._version;
                    }
                    getText(range) {
                        if (range) {
                            const start = this.offsetAt(range.start);
                            const end = this.offsetAt(range.end);
                            return this._content.substring(start, end);
                        }
                        return this._content;
                    }
                    update(changes, version) {
                        for (const change of changes){
                            if (FullTextDocument.isIncremental(change)) {
                                // makes sure start is before end
                                const range = getWellformedRange(change.range);
                                // update content
                                const startOffset = this.offsetAt(range.start);
                                const endOffset = this.offsetAt(range.end);
                                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
                                // update the offsets
                                const startLine = Math.max(range.start.line, 0);
                                const endLine = Math.max(range.end.line, 0);
                                let lineOffsets = this._lineOffsets;
                                const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
                                if (endLine - startLine === addedLineOffsets.length) {
                                    for(let i = 0, len = addedLineOffsets.length; i < len; i++){
                                        lineOffsets[i + startLine + 1] = addedLineOffsets[i];
                                    }
                                } else {
                                    if (addedLineOffsets.length < 10000) {
                                        lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);
                                    } else {
                                        this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
                                    }
                                }
                                const diff = change.text.length - (endOffset - startOffset);
                                if (diff !== 0) {
                                    for(let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++){
                                        lineOffsets[i] = lineOffsets[i] + diff;
                                    }
                                }
                            } else if (FullTextDocument.isFull(change)) {
                                this._content = change.text;
                                this._lineOffsets = undefined;
                            } else {
                                throw new Error('Unknown change event received');
                            }
                        }
                        this._version = version;
                    }
                    getLineOffsets() {
                        if (this._lineOffsets === undefined) {
                            this._lineOffsets = computeLineOffsets(this._content, true);
                        }
                        return this._lineOffsets;
                    }
                    positionAt(offset) {
                        offset = Math.max(Math.min(offset, this._content.length), 0);
                        const lineOffsets = this.getLineOffsets();
                        let low = 0, high = lineOffsets.length;
                        if (high === 0) {
                            return {
                                line: 0,
                                character: offset
                            };
                        }
                        while(low < high){
                            const mid = Math.floor((low + high) / 2);
                            if (lineOffsets[mid] > offset) {
                                high = mid;
                            } else {
                                low = mid + 1;
                            }
                        }
                        // low is the least x for which the line offset is larger than the current offset
                        // or array.length if no line offset is larger than the current offset
                        const line = low - 1;
                        offset = this.ensureBeforeEOL(offset, lineOffsets[line]);
                        return {
                            line,
                            character: offset - lineOffsets[line]
                        };
                    }
                    offsetAt(position) {
                        const lineOffsets = this.getLineOffsets();
                        if (position.line >= lineOffsets.length) {
                            return this._content.length;
                        } else if (position.line < 0) {
                            return 0;
                        }
                        const lineOffset = lineOffsets[position.line];
                        if (position.character <= 0) {
                            return lineOffset;
                        }
                        const nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
                        const offset = Math.min(lineOffset + position.character, nextLineOffset);
                        return this.ensureBeforeEOL(offset, lineOffset);
                    }
                    ensureBeforeEOL(offset, lineOffset) {
                        while(offset > lineOffset && isEOL1(this._content.charCodeAt(offset - 1))){
                            offset--;
                        }
                        return offset;
                    }
                    get lineCount() {
                        return this.getLineOffsets().length;
                    }
                    static isIncremental(event) {
                        const candidate = event;
                        return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range !== undefined && (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
                    }
                    static isFull(event) {
                        const candidate = event;
                        return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
                    }
                    constructor(uri, languageId, version, content){
                        this._uri = uri;
                        this._languageId = languageId;
                        this._version = version;
                        this._content = content;
                        this._lineOffsets = undefined;
                    }
                }
                var TextDocument;
                (function(TextDocument) {
                    /**
     * Creates a new text document.
     *
     * @param uri The document's uri.
     * @param languageId  The document's language Id.
     * @param version The document's initial version number.
     * @param content The document's content.
     */ function create(uri, languageId, version, content) {
                        return new FullTextDocument(uri, languageId, version, content);
                    }
                    TextDocument.create = create;
                    /**
     * Updates a TextDocument by modifying its content.
     *
     * @param document the document to update. Only documents created by TextDocument.create are valid inputs.
     * @param changes the changes to apply to the document.
     * @param version the changes version for the document.
     * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.
     *
     */ function update(document1, changes, version) {
                        if (document1 instanceof FullTextDocument) {
                            document1.update(changes, version);
                            return document1;
                        } else {
                            throw new Error('TextDocument.update: document must be created by TextDocument.create');
                        }
                    }
                    TextDocument.update = update;
                    function applyEdits(document1, edits) {
                        const text = document1.getText();
                        const sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b)=>{
                            const diff = a.range.start.line - b.range.start.line;
                            if (diff === 0) {
                                return a.range.start.character - b.range.start.character;
                            }
                            return diff;
                        });
                        let lastModifiedOffset = 0;
                        const spans = [];
                        for (const e of sortedEdits){
                            const startOffset = document1.offsetAt(e.range.start);
                            if (startOffset < lastModifiedOffset) {
                                throw new Error('Overlapping edit');
                            } else if (startOffset > lastModifiedOffset) {
                                spans.push(text.substring(lastModifiedOffset, startOffset));
                            }
                            if (e.newText.length) {
                                spans.push(e.newText);
                            }
                            lastModifiedOffset = document1.offsetAt(e.range.end);
                        }
                        spans.push(text.substr(lastModifiedOffset));
                        return spans.join('');
                    }
                    TextDocument.applyEdits = applyEdits;
                })(TextDocument || (TextDocument = {}));
                function mergeSort(data, compare) {
                    if (data.length <= 1) {
                        // sorted
                        return data;
                    }
                    const p = data.length / 2 | 0;
                    const left = data.slice(0, p);
                    const right = data.slice(p);
                    mergeSort(left, compare);
                    mergeSort(right, compare);
                    let leftIdx = 0;
                    let rightIdx = 0;
                    let i = 0;
                    while(leftIdx < left.length && rightIdx < right.length){
                        const ret = compare(left[leftIdx], right[rightIdx]);
                        if (ret <= 0) {
                            // smaller_equal -> take left to preserve order
                            data[i++] = left[leftIdx++];
                        } else {
                            // greater -> take right
                            data[i++] = right[rightIdx++];
                        }
                    }
                    while(leftIdx < left.length){
                        data[i++] = left[leftIdx++];
                    }
                    while(rightIdx < right.length){
                        data[i++] = right[rightIdx++];
                    }
                    return data;
                }
                function computeLineOffsets(text, isAtLineStart, textOffset = 0) {
                    const result = isAtLineStart ? [
                        textOffset
                    ] : [];
                    for(let i = 0; i < text.length; i++){
                        const ch = text.charCodeAt(i);
                        if (isEOL1(ch)) {
                            if (ch === 13 /* CharCode.CarriageReturn */  && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */ ) {
                                i++;
                            }
                            result.push(textOffset + i + 1);
                        }
                    }
                    return result;
                }
                function isEOL1(char) {
                    return char === 13 /* CharCode.CarriageReturn */  || char === 10 /* CharCode.LineFeed */ ;
                }
                function getWellformedRange(range) {
                    const start = range.start;
                    const end = range.end;
                    if (start.line > end.line || start.line === end.line && start.character > end.character) {
                        return {
                            start: end,
                            end: start
                        };
                    }
                    return range;
                }
                function getWellformedEdit(textEdit) {
                    const range = getWellformedRange(textEdit.range);
                    if (range !== textEdit.range) {
                        return {
                            newText: textEdit.newText,
                            range
                        };
                    }
                    return textEdit;
                }
            /***/ }
        };
        /************************************************************************/ /******/ // The module cache
        /******/ var __webpack_module_cache__ = {};
        /******/ /******/ // The require function
        /******/ function __nested_webpack_require_714846__(moduleId) {
            /******/ // Check if module is in cache
            /******/ var cachedModule = __webpack_module_cache__[moduleId];
            /******/ if (cachedModule !== undefined) {
                /******/ return cachedModule.exports;
            /******/ }
            /******/ // Create a new module (and put it into the cache)
            /******/ var module1 = __webpack_module_cache__[moduleId] = {
                /******/ // no module.id needed
                /******/ // no module.loaded needed
                /******/ exports: {}
            };
            /******/ /******/ // Execute the module function
            /******/ __webpack_modules__[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_714846__);
            /******/ /******/ // Return the exports of the module
            /******/ return module1.exports;
        /******/ }
        /******/ /************************************************************************/ /******/ /* webpack/runtime/compat get default export */ /******/ (()=>{
            /******/ // getDefaultExport function for compatibility with non-harmony modules
            /******/ __nested_webpack_require_714846__.n = (module1)=>{
                /******/ var getter = module1 && module1.__esModule ? /******/ ()=>module1['default'] : /******/ ()=>module1;
                /******/ __nested_webpack_require_714846__.d(getter, {
                    a: getter
                });
                /******/ return getter;
            /******/ };
        /******/ })();
        /******/ /******/ /* webpack/runtime/define property getters */ /******/ (()=>{
            /******/ // define getter functions for harmony exports
            /******/ __nested_webpack_require_714846__.d = (exports1, definition)=>{
                /******/ for(var key in definition){
                    /******/ if (__nested_webpack_require_714846__.o(definition, key) && !__nested_webpack_require_714846__.o(exports1, key)) {
                        /******/ Object.defineProperty(exports1, key, {
                            enumerable: true,
                            get: definition[key]
                        });
                    /******/ }
                /******/ }
            /******/ };
        /******/ })();
        /******/ /******/ /* webpack/runtime/global */ /******/ (()=>{
            /******/ __nested_webpack_require_714846__.g = function() {
                /******/ if (typeof globalThis === 'object') return globalThis;
                /******/ try {
                    /******/ return this || new Function('return this')();
                /******/ } catch (e) {
                    /******/ if (typeof window === 'object') return window;
                /******/ }
            /******/ }();
        /******/ })();
        /******/ /******/ /* webpack/runtime/hasOwnProperty shorthand */ /******/ (()=>{
            /******/ __nested_webpack_require_714846__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
        /******/ })();
        /******/ /******/ /* webpack/runtime/make namespace object */ /******/ (()=>{
            /******/ // define __esModule on exports
            /******/ __nested_webpack_require_714846__.r = (exports1)=>{
                /******/ if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
                    /******/ Object.defineProperty(exports1, Symbol.toStringTag, {
                        value: 'Module'
                    });
                /******/ }
                /******/ Object.defineProperty(exports1, '__esModule', {
                    value: true
                });
            /******/ };
        /******/ })();
        /******/ /************************************************************************/ var __nested_webpack_exports__ = {};
        // This entry need to be wrapped in an IIFE because it need to be in strict mode.
        (()=>{
            "use strict";
            // ESM COMPAT FLAG
            __nested_webpack_require_714846__.r(__nested_webpack_exports__);
            // EXPORTS
            __nested_webpack_require_714846__.d(__nested_webpack_exports__, {
                JsonService: ()=>/* binding */ JsonService
            });
            // EXTERNAL MODULE: ./src/services/base-service.ts
            var base_service = __nested_webpack_require_714846__(2125);
            ; // CONCATENATED MODULE: ../../node_modules/jsonc-parser/lib/esm/impl/scanner.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ /**
 * Creates a JSON scanner on the given text.
 * If ignoreTrivia is set, whitespaces or comments are ignored.
 */ function createScanner(text, ignoreTrivia = false) {
                const len = text.length;
                let pos = 0, value = '', tokenOffset = 0, token = 16 /* SyntaxKind.Unknown */ , lineNumber = 0, lineStartOffset = 0, tokenLineStartOffset = 0, prevTokenLineStartOffset = 0, scanError = 0 /* ScanError.None */ ;
                function scanHexDigits(count, exact) {
                    let digits = 0;
                    let value = 0;
                    while(digits < count || !exact){
                        let ch = text.charCodeAt(pos);
                        if (ch >= 48 /* CharacterCodes._0 */  && ch <= 57 /* CharacterCodes._9 */ ) {
                            value = value * 16 + ch - 48 /* CharacterCodes._0 */ ;
                        } else if (ch >= 65 /* CharacterCodes.A */  && ch <= 70 /* CharacterCodes.F */ ) {
                            value = value * 16 + ch - 65 /* CharacterCodes.A */  + 10;
                        } else if (ch >= 97 /* CharacterCodes.a */  && ch <= 102 /* CharacterCodes.f */ ) {
                            value = value * 16 + ch - 97 /* CharacterCodes.a */  + 10;
                        } else {
                            break;
                        }
                        pos++;
                        digits++;
                    }
                    if (digits < count) {
                        value = -1;
                    }
                    return value;
                }
                function setPosition(newPosition) {
                    pos = newPosition;
                    value = '';
                    tokenOffset = 0;
                    token = 16 /* SyntaxKind.Unknown */ ;
                    scanError = 0 /* ScanError.None */ ;
                }
                function scanNumber() {
                    let start = pos;
                    if (text.charCodeAt(pos) === 48 /* CharacterCodes._0 */ ) {
                        pos++;
                    } else {
                        pos++;
                        while(pos < text.length && isDigit(text.charCodeAt(pos))){
                            pos++;
                        }
                    }
                    if (pos < text.length && text.charCodeAt(pos) === 46 /* CharacterCodes.dot */ ) {
                        pos++;
                        if (pos < text.length && isDigit(text.charCodeAt(pos))) {
                            pos++;
                            while(pos < text.length && isDigit(text.charCodeAt(pos))){
                                pos++;
                            }
                        } else {
                            scanError = 3 /* ScanError.UnexpectedEndOfNumber */ ;
                            return text.substring(start, pos);
                        }
                    }
                    let end = pos;
                    if (pos < text.length && (text.charCodeAt(pos) === 69 /* CharacterCodes.E */  || text.charCodeAt(pos) === 101 /* CharacterCodes.e */ )) {
                        pos++;
                        if (pos < text.length && text.charCodeAt(pos) === 43 /* CharacterCodes.plus */  || text.charCodeAt(pos) === 45 /* CharacterCodes.minus */ ) {
                            pos++;
                        }
                        if (pos < text.length && isDigit(text.charCodeAt(pos))) {
                            pos++;
                            while(pos < text.length && isDigit(text.charCodeAt(pos))){
                                pos++;
                            }
                            end = pos;
                        } else {
                            scanError = 3 /* ScanError.UnexpectedEndOfNumber */ ;
                        }
                    }
                    return text.substring(start, end);
                }
                function scanString() {
                    let result = '', start = pos;
                    while(true){
                        if (pos >= len) {
                            result += text.substring(start, pos);
                            scanError = 2 /* ScanError.UnexpectedEndOfString */ ;
                            break;
                        }
                        const ch = text.charCodeAt(pos);
                        if (ch === 34 /* CharacterCodes.doubleQuote */ ) {
                            result += text.substring(start, pos);
                            pos++;
                            break;
                        }
                        if (ch === 92 /* CharacterCodes.backslash */ ) {
                            result += text.substring(start, pos);
                            pos++;
                            if (pos >= len) {
                                scanError = 2 /* ScanError.UnexpectedEndOfString */ ;
                                break;
                            }
                            const ch2 = text.charCodeAt(pos++);
                            switch(ch2){
                                case 34 /* CharacterCodes.doubleQuote */ :
                                    result += '\"';
                                    break;
                                case 92 /* CharacterCodes.backslash */ :
                                    result += '\\';
                                    break;
                                case 47 /* CharacterCodes.slash */ :
                                    result += '/';
                                    break;
                                case 98 /* CharacterCodes.b */ :
                                    result += '\b';
                                    break;
                                case 102 /* CharacterCodes.f */ :
                                    result += '\f';
                                    break;
                                case 110 /* CharacterCodes.n */ :
                                    result += '\n';
                                    break;
                                case 114 /* CharacterCodes.r */ :
                                    result += '\r';
                                    break;
                                case 116 /* CharacterCodes.t */ :
                                    result += '\t';
                                    break;
                                case 117 /* CharacterCodes.u */ :
                                    const ch3 = scanHexDigits(4, true);
                                    if (ch3 >= 0) {
                                        result += String.fromCharCode(ch3);
                                    } else {
                                        scanError = 4 /* ScanError.InvalidUnicode */ ;
                                    }
                                    break;
                                default:
                                    scanError = 5 /* ScanError.InvalidEscapeCharacter */ ;
                            }
                            start = pos;
                            continue;
                        }
                        if (ch >= 0 && ch <= 0x1f) {
                            if (isLineBreak(ch)) {
                                result += text.substring(start, pos);
                                scanError = 2 /* ScanError.UnexpectedEndOfString */ ;
                                break;
                            } else {
                                scanError = 6 /* ScanError.InvalidCharacter */ ;
                            // mark as error but continue with string
                            }
                        }
                        pos++;
                    }
                    return result;
                }
                function scanNext() {
                    value = '';
                    scanError = 0 /* ScanError.None */ ;
                    tokenOffset = pos;
                    lineStartOffset = lineNumber;
                    prevTokenLineStartOffset = tokenLineStartOffset;
                    if (pos >= len) {
                        // at the end
                        tokenOffset = len;
                        return token = 17 /* SyntaxKind.EOF */ ;
                    }
                    let code = text.charCodeAt(pos);
                    // trivia: whitespace
                    if (isWhiteSpace(code)) {
                        do {
                            pos++;
                            value += String.fromCharCode(code);
                            code = text.charCodeAt(pos);
                        }while (isWhiteSpace(code))
                        return token = 15 /* SyntaxKind.Trivia */ ;
                    }
                    // trivia: newlines
                    if (isLineBreak(code)) {
                        pos++;
                        value += String.fromCharCode(code);
                        if (code === 13 /* CharacterCodes.carriageReturn */  && text.charCodeAt(pos) === 10 /* CharacterCodes.lineFeed */ ) {
                            pos++;
                            value += '\n';
                        }
                        lineNumber++;
                        tokenLineStartOffset = pos;
                        return token = 14 /* SyntaxKind.LineBreakTrivia */ ;
                    }
                    switch(code){
                        // tokens: []{}:,
                        case 123 /* CharacterCodes.openBrace */ :
                            pos++;
                            return token = 1 /* SyntaxKind.OpenBraceToken */ ;
                        case 125 /* CharacterCodes.closeBrace */ :
                            pos++;
                            return token = 2 /* SyntaxKind.CloseBraceToken */ ;
                        case 91 /* CharacterCodes.openBracket */ :
                            pos++;
                            return token = 3 /* SyntaxKind.OpenBracketToken */ ;
                        case 93 /* CharacterCodes.closeBracket */ :
                            pos++;
                            return token = 4 /* SyntaxKind.CloseBracketToken */ ;
                        case 58 /* CharacterCodes.colon */ :
                            pos++;
                            return token = 6 /* SyntaxKind.ColonToken */ ;
                        case 44 /* CharacterCodes.comma */ :
                            pos++;
                            return token = 5 /* SyntaxKind.CommaToken */ ;
                        // strings
                        case 34 /* CharacterCodes.doubleQuote */ :
                            pos++;
                            value = scanString();
                            return token = 10 /* SyntaxKind.StringLiteral */ ;
                        // comments
                        case 47 /* CharacterCodes.slash */ :
                            const start = pos - 1;
                            // Single-line comment
                            if (text.charCodeAt(pos + 1) === 47 /* CharacterCodes.slash */ ) {
                                pos += 2;
                                while(pos < len){
                                    if (isLineBreak(text.charCodeAt(pos))) {
                                        break;
                                    }
                                    pos++;
                                }
                                value = text.substring(start, pos);
                                return token = 12 /* SyntaxKind.LineCommentTrivia */ ;
                            }
                            // Multi-line comment
                            if (text.charCodeAt(pos + 1) === 42 /* CharacterCodes.asterisk */ ) {
                                pos += 2;
                                const safeLength = len - 1; // For lookahead.
                                let commentClosed = false;
                                while(pos < safeLength){
                                    const ch = text.charCodeAt(pos);
                                    if (ch === 42 /* CharacterCodes.asterisk */  && text.charCodeAt(pos + 1) === 47 /* CharacterCodes.slash */ ) {
                                        pos += 2;
                                        commentClosed = true;
                                        break;
                                    }
                                    pos++;
                                    if (isLineBreak(ch)) {
                                        if (ch === 13 /* CharacterCodes.carriageReturn */  && text.charCodeAt(pos) === 10 /* CharacterCodes.lineFeed */ ) {
                                            pos++;
                                        }
                                        lineNumber++;
                                        tokenLineStartOffset = pos;
                                    }
                                }
                                if (!commentClosed) {
                                    pos++;
                                    scanError = 1 /* ScanError.UnexpectedEndOfComment */ ;
                                }
                                value = text.substring(start, pos);
                                return token = 13 /* SyntaxKind.BlockCommentTrivia */ ;
                            }
                            // just a single slash
                            value += String.fromCharCode(code);
                            pos++;
                            return token = 16 /* SyntaxKind.Unknown */ ;
                        // numbers
                        case 45 /* CharacterCodes.minus */ :
                            value += String.fromCharCode(code);
                            pos++;
                            if (pos === len || !isDigit(text.charCodeAt(pos))) {
                                return token = 16 /* SyntaxKind.Unknown */ ;
                            }
                        // found a minus, followed by a number so
                        // we fall through to proceed with scanning
                        // numbers
                        case 48 /* CharacterCodes._0 */ :
                        case 49 /* CharacterCodes._1 */ :
                        case 50 /* CharacterCodes._2 */ :
                        case 51 /* CharacterCodes._3 */ :
                        case 52 /* CharacterCodes._4 */ :
                        case 53 /* CharacterCodes._5 */ :
                        case 54 /* CharacterCodes._6 */ :
                        case 55 /* CharacterCodes._7 */ :
                        case 56 /* CharacterCodes._8 */ :
                        case 57 /* CharacterCodes._9 */ :
                            value += scanNumber();
                            return token = 11 /* SyntaxKind.NumericLiteral */ ;
                        // literals and unknown symbols
                        default:
                            // is a literal? Read the full word.
                            while(pos < len && isUnknownContentCharacter(code)){
                                pos++;
                                code = text.charCodeAt(pos);
                            }
                            if (tokenOffset !== pos) {
                                value = text.substring(tokenOffset, pos);
                                // keywords: true, false, null
                                switch(value){
                                    case 'true':
                                        return token = 8 /* SyntaxKind.TrueKeyword */ ;
                                    case 'false':
                                        return token = 9 /* SyntaxKind.FalseKeyword */ ;
                                    case 'null':
                                        return token = 7 /* SyntaxKind.NullKeyword */ ;
                                }
                                return token = 16 /* SyntaxKind.Unknown */ ;
                            }
                            // some
                            value += String.fromCharCode(code);
                            pos++;
                            return token = 16 /* SyntaxKind.Unknown */ ;
                    }
                }
                function isUnknownContentCharacter(code) {
                    if (isWhiteSpace(code) || isLineBreak(code)) {
                        return false;
                    }
                    switch(code){
                        case 125 /* CharacterCodes.closeBrace */ :
                        case 93 /* CharacterCodes.closeBracket */ :
                        case 123 /* CharacterCodes.openBrace */ :
                        case 91 /* CharacterCodes.openBracket */ :
                        case 34 /* CharacterCodes.doubleQuote */ :
                        case 58 /* CharacterCodes.colon */ :
                        case 44 /* CharacterCodes.comma */ :
                        case 47 /* CharacterCodes.slash */ :
                            return false;
                    }
                    return true;
                }
                function scanNextNonTrivia() {
                    let result;
                    do {
                        result = scanNext();
                    }while (result >= 12 /* SyntaxKind.LineCommentTrivia */  && result <= 15 /* SyntaxKind.Trivia */ )
                    return result;
                }
                return {
                    setPosition: setPosition,
                    getPosition: ()=>pos,
                    scan: ignoreTrivia ? scanNextNonTrivia : scanNext,
                    getToken: ()=>token,
                    getTokenValue: ()=>value,
                    getTokenOffset: ()=>tokenOffset,
                    getTokenLength: ()=>pos - tokenOffset,
                    getTokenStartLine: ()=>lineStartOffset,
                    getTokenStartCharacter: ()=>tokenOffset - prevTokenLineStartOffset,
                    getTokenError: ()=>scanError
                };
            }
            function isWhiteSpace(ch) {
                return ch === 32 /* CharacterCodes.space */  || ch === 9 /* CharacterCodes.tab */ ;
            }
            function isLineBreak(ch) {
                return ch === 10 /* CharacterCodes.lineFeed */  || ch === 13 /* CharacterCodes.carriageReturn */ ;
            }
            function isDigit(ch) {
                return ch >= 48 /* CharacterCodes._0 */  && ch <= 57 /* CharacterCodes._9 */ ;
            }
            var CharacterCodes;
            (function(CharacterCodes) {
                CharacterCodes[CharacterCodes["lineFeed"] = 10] = "lineFeed";
                CharacterCodes[CharacterCodes["carriageReturn"] = 13] = "carriageReturn";
                CharacterCodes[CharacterCodes["space"] = 32] = "space";
                CharacterCodes[CharacterCodes["_0"] = 48] = "_0";
                CharacterCodes[CharacterCodes["_1"] = 49] = "_1";
                CharacterCodes[CharacterCodes["_2"] = 50] = "_2";
                CharacterCodes[CharacterCodes["_3"] = 51] = "_3";
                CharacterCodes[CharacterCodes["_4"] = 52] = "_4";
                CharacterCodes[CharacterCodes["_5"] = 53] = "_5";
                CharacterCodes[CharacterCodes["_6"] = 54] = "_6";
                CharacterCodes[CharacterCodes["_7"] = 55] = "_7";
                CharacterCodes[CharacterCodes["_8"] = 56] = "_8";
                CharacterCodes[CharacterCodes["_9"] = 57] = "_9";
                CharacterCodes[CharacterCodes["a"] = 97] = "a";
                CharacterCodes[CharacterCodes["b"] = 98] = "b";
                CharacterCodes[CharacterCodes["c"] = 99] = "c";
                CharacterCodes[CharacterCodes["d"] = 100] = "d";
                CharacterCodes[CharacterCodes["e"] = 101] = "e";
                CharacterCodes[CharacterCodes["f"] = 102] = "f";
                CharacterCodes[CharacterCodes["g"] = 103] = "g";
                CharacterCodes[CharacterCodes["h"] = 104] = "h";
                CharacterCodes[CharacterCodes["i"] = 105] = "i";
                CharacterCodes[CharacterCodes["j"] = 106] = "j";
                CharacterCodes[CharacterCodes["k"] = 107] = "k";
                CharacterCodes[CharacterCodes["l"] = 108] = "l";
                CharacterCodes[CharacterCodes["m"] = 109] = "m";
                CharacterCodes[CharacterCodes["n"] = 110] = "n";
                CharacterCodes[CharacterCodes["o"] = 111] = "o";
                CharacterCodes[CharacterCodes["p"] = 112] = "p";
                CharacterCodes[CharacterCodes["q"] = 113] = "q";
                CharacterCodes[CharacterCodes["r"] = 114] = "r";
                CharacterCodes[CharacterCodes["s"] = 115] = "s";
                CharacterCodes[CharacterCodes["t"] = 116] = "t";
                CharacterCodes[CharacterCodes["u"] = 117] = "u";
                CharacterCodes[CharacterCodes["v"] = 118] = "v";
                CharacterCodes[CharacterCodes["w"] = 119] = "w";
                CharacterCodes[CharacterCodes["x"] = 120] = "x";
                CharacterCodes[CharacterCodes["y"] = 121] = "y";
                CharacterCodes[CharacterCodes["z"] = 122] = "z";
                CharacterCodes[CharacterCodes["A"] = 65] = "A";
                CharacterCodes[CharacterCodes["B"] = 66] = "B";
                CharacterCodes[CharacterCodes["C"] = 67] = "C";
                CharacterCodes[CharacterCodes["D"] = 68] = "D";
                CharacterCodes[CharacterCodes["E"] = 69] = "E";
                CharacterCodes[CharacterCodes["F"] = 70] = "F";
                CharacterCodes[CharacterCodes["G"] = 71] = "G";
                CharacterCodes[CharacterCodes["H"] = 72] = "H";
                CharacterCodes[CharacterCodes["I"] = 73] = "I";
                CharacterCodes[CharacterCodes["J"] = 74] = "J";
                CharacterCodes[CharacterCodes["K"] = 75] = "K";
                CharacterCodes[CharacterCodes["L"] = 76] = "L";
                CharacterCodes[CharacterCodes["M"] = 77] = "M";
                CharacterCodes[CharacterCodes["N"] = 78] = "N";
                CharacterCodes[CharacterCodes["O"] = 79] = "O";
                CharacterCodes[CharacterCodes["P"] = 80] = "P";
                CharacterCodes[CharacterCodes["Q"] = 81] = "Q";
                CharacterCodes[CharacterCodes["R"] = 82] = "R";
                CharacterCodes[CharacterCodes["S"] = 83] = "S";
                CharacterCodes[CharacterCodes["T"] = 84] = "T";
                CharacterCodes[CharacterCodes["U"] = 85] = "U";
                CharacterCodes[CharacterCodes["V"] = 86] = "V";
                CharacterCodes[CharacterCodes["W"] = 87] = "W";
                CharacterCodes[CharacterCodes["X"] = 88] = "X";
                CharacterCodes[CharacterCodes["Y"] = 89] = "Y";
                CharacterCodes[CharacterCodes["Z"] = 90] = "Z";
                CharacterCodes[CharacterCodes["asterisk"] = 42] = "asterisk";
                CharacterCodes[CharacterCodes["backslash"] = 92] = "backslash";
                CharacterCodes[CharacterCodes["closeBrace"] = 125] = "closeBrace";
                CharacterCodes[CharacterCodes["closeBracket"] = 93] = "closeBracket";
                CharacterCodes[CharacterCodes["colon"] = 58] = "colon";
                CharacterCodes[CharacterCodes["comma"] = 44] = "comma";
                CharacterCodes[CharacterCodes["dot"] = 46] = "dot";
                CharacterCodes[CharacterCodes["doubleQuote"] = 34] = "doubleQuote";
                CharacterCodes[CharacterCodes["minus"] = 45] = "minus";
                CharacterCodes[CharacterCodes["openBrace"] = 123] = "openBrace";
                CharacterCodes[CharacterCodes["openBracket"] = 91] = "openBracket";
                CharacterCodes[CharacterCodes["plus"] = 43] = "plus";
                CharacterCodes[CharacterCodes["slash"] = 47] = "slash";
                CharacterCodes[CharacterCodes["formFeed"] = 12] = "formFeed";
                CharacterCodes[CharacterCodes["tab"] = 9] = "tab";
            })(CharacterCodes || (CharacterCodes = {}));
            ; // CONCATENATED MODULE: ../../node_modules/jsonc-parser/lib/esm/impl/string-intern.js
            const cachedSpaces = new Array(20).fill(0).map((_, index)=>{
                return ' '.repeat(index);
            });
            const maxCachedValues = 200;
            const cachedBreakLinesWithSpaces = {
                ' ': {
                    '\n': new Array(maxCachedValues).fill(0).map((_, index)=>{
                        return '\n' + ' '.repeat(index);
                    }),
                    '\r': new Array(maxCachedValues).fill(0).map((_, index)=>{
                        return '\r' + ' '.repeat(index);
                    }),
                    '\r\n': new Array(maxCachedValues).fill(0).map((_, index)=>{
                        return '\r\n' + ' '.repeat(index);
                    })
                },
                '\t': {
                    '\n': new Array(maxCachedValues).fill(0).map((_, index)=>{
                        return '\n' + '\t'.repeat(index);
                    }),
                    '\r': new Array(maxCachedValues).fill(0).map((_, index)=>{
                        return '\r' + '\t'.repeat(index);
                    }),
                    '\r\n': new Array(maxCachedValues).fill(0).map((_, index)=>{
                        return '\r\n' + '\t'.repeat(index);
                    })
                }
            };
            const supportedEols = [
                '\n',
                '\r',
                '\r\n'
            ];
            ; // CONCATENATED MODULE: ../../node_modules/jsonc-parser/lib/esm/impl/format.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ function format_format(documentText, range, options) {
                let initialIndentLevel;
                let formatText;
                let formatTextStart;
                let rangeStart;
                let rangeEnd;
                if (range) {
                    rangeStart = range.offset;
                    rangeEnd = rangeStart + range.length;
                    formatTextStart = rangeStart;
                    while(formatTextStart > 0 && !format_isEOL(documentText, formatTextStart - 1)){
                        formatTextStart--;
                    }
                    let endOffset = rangeEnd;
                    while(endOffset < documentText.length && !format_isEOL(documentText, endOffset)){
                        endOffset++;
                    }
                    formatText = documentText.substring(formatTextStart, endOffset);
                    initialIndentLevel = computeIndentLevel(formatText, options);
                } else {
                    formatText = documentText;
                    initialIndentLevel = 0;
                    formatTextStart = 0;
                    rangeStart = 0;
                    rangeEnd = documentText.length;
                }
                const eol = getEOL(options, documentText);
                const eolFastPathSupported = supportedEols.includes(eol);
                let numberLineBreaks = 0;
                let indentLevel = 0;
                let indentValue;
                if (options.insertSpaces) {
                    var _cachedSpaces_;
                    indentValue = (_cachedSpaces_ = cachedSpaces[options.tabSize || 4]) !== null && _cachedSpaces_ !== void 0 ? _cachedSpaces_ : repeat(cachedSpaces[1], options.tabSize || 4);
                } else {
                    indentValue = '\t';
                }
                const indentType = indentValue === '\t' ? '\t' : ' ';
                let scanner = createScanner(formatText, false);
                let hasError = false;
                function newLinesAndIndent() {
                    if (numberLineBreaks > 1) {
                        return repeat(eol, numberLineBreaks) + repeat(indentValue, initialIndentLevel + indentLevel);
                    }
                    const amountOfSpaces = indentValue.length * (initialIndentLevel + indentLevel);
                    if (!eolFastPathSupported || amountOfSpaces > cachedBreakLinesWithSpaces[indentType][eol].length) {
                        return eol + repeat(indentValue, initialIndentLevel + indentLevel);
                    }
                    if (amountOfSpaces <= 0) {
                        return eol;
                    }
                    return cachedBreakLinesWithSpaces[indentType][eol][amountOfSpaces];
                }
                function scanNext() {
                    let token = scanner.scan();
                    numberLineBreaks = 0;
                    while(token === 15 /* SyntaxKind.Trivia */  || token === 14 /* SyntaxKind.LineBreakTrivia */ ){
                        if (token === 14 /* SyntaxKind.LineBreakTrivia */  && options.keepLines) {
                            numberLineBreaks += 1;
                        } else if (token === 14 /* SyntaxKind.LineBreakTrivia */ ) {
                            numberLineBreaks = 1;
                        }
                        token = scanner.scan();
                    }
                    hasError = token === 16 /* SyntaxKind.Unknown */  || scanner.getTokenError() !== 0 /* ScanError.None */ ;
                    return token;
                }
                const editOperations = [];
                function addEdit(text, startOffset, endOffset) {
                    if (!hasError && (!range || startOffset < rangeEnd && endOffset > rangeStart) && documentText.substring(startOffset, endOffset) !== text) {
                        editOperations.push({
                            offset: startOffset,
                            length: endOffset - startOffset,
                            content: text
                        });
                    }
                }
                let firstToken = scanNext();
                if (options.keepLines && numberLineBreaks > 0) {
                    addEdit(repeat(eol, numberLineBreaks), 0, 0);
                }
                if (firstToken !== 17 /* SyntaxKind.EOF */ ) {
                    let firstTokenStart = scanner.getTokenOffset() + formatTextStart;
                    let initialIndent = indentValue.length * initialIndentLevel < 20 && options.insertSpaces ? cachedSpaces[indentValue.length * initialIndentLevel] : repeat(indentValue, initialIndentLevel);
                    addEdit(initialIndent, formatTextStart, firstTokenStart);
                }
                while(firstToken !== 17 /* SyntaxKind.EOF */ ){
                    let firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;
                    let secondToken = scanNext();
                    let replaceContent = '';
                    let needsLineBreak = false;
                    while(numberLineBreaks === 0 && (secondToken === 12 /* SyntaxKind.LineCommentTrivia */  || secondToken === 13 /* SyntaxKind.BlockCommentTrivia */ )){
                        let commentTokenStart = scanner.getTokenOffset() + formatTextStart;
                        addEdit(cachedSpaces[1], firstTokenEnd, commentTokenStart);
                        firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;
                        needsLineBreak = secondToken === 12 /* SyntaxKind.LineCommentTrivia */ ;
                        replaceContent = needsLineBreak ? newLinesAndIndent() : '';
                        secondToken = scanNext();
                    }
                    if (secondToken === 2 /* SyntaxKind.CloseBraceToken */ ) {
                        if (firstToken !== 1 /* SyntaxKind.OpenBraceToken */ ) {
                            indentLevel--;
                        }
                        ;
                        if (options.keepLines && numberLineBreaks > 0 || !options.keepLines && firstToken !== 1 /* SyntaxKind.OpenBraceToken */ ) {
                            replaceContent = newLinesAndIndent();
                        } else if (options.keepLines) {
                            replaceContent = cachedSpaces[1];
                        }
                    } else if (secondToken === 4 /* SyntaxKind.CloseBracketToken */ ) {
                        if (firstToken !== 3 /* SyntaxKind.OpenBracketToken */ ) {
                            indentLevel--;
                        }
                        ;
                        if (options.keepLines && numberLineBreaks > 0 || !options.keepLines && firstToken !== 3 /* SyntaxKind.OpenBracketToken */ ) {
                            replaceContent = newLinesAndIndent();
                        } else if (options.keepLines) {
                            replaceContent = cachedSpaces[1];
                        }
                    } else {
                        switch(firstToken){
                            case 3 /* SyntaxKind.OpenBracketToken */ :
                            case 1 /* SyntaxKind.OpenBraceToken */ :
                                indentLevel++;
                                if (options.keepLines && numberLineBreaks > 0 || !options.keepLines) {
                                    replaceContent = newLinesAndIndent();
                                } else {
                                    replaceContent = cachedSpaces[1];
                                }
                                break;
                            case 5 /* SyntaxKind.CommaToken */ :
                                if (options.keepLines && numberLineBreaks > 0 || !options.keepLines) {
                                    replaceContent = newLinesAndIndent();
                                } else {
                                    replaceContent = cachedSpaces[1];
                                }
                                break;
                            case 12 /* SyntaxKind.LineCommentTrivia */ :
                                replaceContent = newLinesAndIndent();
                                break;
                            case 13 /* SyntaxKind.BlockCommentTrivia */ :
                                if (numberLineBreaks > 0) {
                                    replaceContent = newLinesAndIndent();
                                } else if (!needsLineBreak) {
                                    replaceContent = cachedSpaces[1];
                                }
                                break;
                            case 6 /* SyntaxKind.ColonToken */ :
                                if (options.keepLines && numberLineBreaks > 0) {
                                    replaceContent = newLinesAndIndent();
                                } else if (!needsLineBreak) {
                                    replaceContent = cachedSpaces[1];
                                }
                                break;
                            case 10 /* SyntaxKind.StringLiteral */ :
                                if (options.keepLines && numberLineBreaks > 0) {
                                    replaceContent = newLinesAndIndent();
                                } else if (secondToken === 6 /* SyntaxKind.ColonToken */  && !needsLineBreak) {
                                    replaceContent = '';
                                }
                                break;
                            case 7 /* SyntaxKind.NullKeyword */ :
                            case 8 /* SyntaxKind.TrueKeyword */ :
                            case 9 /* SyntaxKind.FalseKeyword */ :
                            case 11 /* SyntaxKind.NumericLiteral */ :
                            case 2 /* SyntaxKind.CloseBraceToken */ :
                            case 4 /* SyntaxKind.CloseBracketToken */ :
                                if (options.keepLines && numberLineBreaks > 0) {
                                    replaceContent = newLinesAndIndent();
                                } else {
                                    if ((secondToken === 12 /* SyntaxKind.LineCommentTrivia */  || secondToken === 13 /* SyntaxKind.BlockCommentTrivia */ ) && !needsLineBreak) {
                                        replaceContent = cachedSpaces[1];
                                    } else if (secondToken !== 5 /* SyntaxKind.CommaToken */  && secondToken !== 17 /* SyntaxKind.EOF */ ) {
                                        hasError = true;
                                    }
                                }
                                break;
                            case 16 /* SyntaxKind.Unknown */ :
                                hasError = true;
                                break;
                        }
                        if (numberLineBreaks > 0 && (secondToken === 12 /* SyntaxKind.LineCommentTrivia */  || secondToken === 13 /* SyntaxKind.BlockCommentTrivia */ )) {
                            replaceContent = newLinesAndIndent();
                        }
                    }
                    if (secondToken === 17 /* SyntaxKind.EOF */ ) {
                        if (options.keepLines && numberLineBreaks > 0) {
                            replaceContent = newLinesAndIndent();
                        } else {
                            replaceContent = options.insertFinalNewline ? eol : '';
                        }
                    }
                    const secondTokenStart = scanner.getTokenOffset() + formatTextStart;
                    addEdit(replaceContent, firstTokenEnd, secondTokenStart);
                    firstToken = secondToken;
                }
                return editOperations;
            }
            function repeat(s, count) {
                let result = '';
                for(let i = 0; i < count; i++){
                    result += s;
                }
                return result;
            }
            function computeIndentLevel(content, options) {
                let i = 0;
                let nChars = 0;
                const tabSize = options.tabSize || 4;
                while(i < content.length){
                    let ch = content.charAt(i);
                    if (ch === cachedSpaces[1]) {
                        nChars++;
                    } else if (ch === '\t') {
                        nChars += tabSize;
                    } else {
                        break;
                    }
                    i++;
                }
                return Math.floor(nChars / tabSize);
            }
            function getEOL(options, text) {
                for(let i = 0; i < text.length; i++){
                    const ch = text.charAt(i);
                    if (ch === '\r') {
                        if (i + 1 < text.length && text.charAt(i + 1) === '\n') {
                            return '\r\n';
                        }
                        return '\r';
                    } else if (ch === '\n') {
                        return '\n';
                    }
                }
                return options && options.eol || '\n';
            }
            function format_isEOL(text, offset) {
                return '\r\n'.indexOf(text.charAt(offset)) !== -1;
            }
            ; // CONCATENATED MODULE: ../../node_modules/jsonc-parser/lib/esm/impl/parser.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ var ParseOptions;
            (function(ParseOptions) {
                ParseOptions.DEFAULT = {
                    allowTrailingComma: false
                };
            })(ParseOptions || (ParseOptions = {}));
            /**
 * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.
 */ function getLocation(text, position) {
                const segments = []; // strings or numbers
                const earlyReturnException = new Object();
                let previousNode = undefined;
                const previousNodeInst = {
                    value: {},
                    offset: 0,
                    length: 0,
                    type: 'object',
                    parent: undefined
                };
                let isAtPropertyKey = false;
                function setPreviousNode(value, offset, length, type) {
                    previousNodeInst.value = value;
                    previousNodeInst.offset = offset;
                    previousNodeInst.length = length;
                    previousNodeInst.type = type;
                    previousNodeInst.colonOffset = undefined;
                    previousNode = previousNodeInst;
                }
                try {
                    visit(text, {
                        onObjectBegin: (offset, length)=>{
                            if (position <= offset) {
                                throw earlyReturnException;
                            }
                            previousNode = undefined;
                            isAtPropertyKey = position > offset;
                            segments.push(''); // push a placeholder (will be replaced)
                        },
                        onObjectProperty: (name, offset, length)=>{
                            if (position < offset) {
                                throw earlyReturnException;
                            }
                            setPreviousNode(name, offset, length, 'property');
                            segments[segments.length - 1] = name;
                            if (position <= offset + length) {
                                throw earlyReturnException;
                            }
                        },
                        onObjectEnd: (offset, length)=>{
                            if (position <= offset) {
                                throw earlyReturnException;
                            }
                            previousNode = undefined;
                            segments.pop();
                        },
                        onArrayBegin: (offset, length)=>{
                            if (position <= offset) {
                                throw earlyReturnException;
                            }
                            previousNode = undefined;
                            segments.push(0);
                        },
                        onArrayEnd: (offset, length)=>{
                            if (position <= offset) {
                                throw earlyReturnException;
                            }
                            previousNode = undefined;
                            segments.pop();
                        },
                        onLiteralValue: (value, offset, length)=>{
                            if (position < offset) {
                                throw earlyReturnException;
                            }
                            setPreviousNode(value, offset, length, getNodeType(value));
                            if (position <= offset + length) {
                                throw earlyReturnException;
                            }
                        },
                        onSeparator: (sep, offset, length)=>{
                            if (position <= offset) {
                                throw earlyReturnException;
                            }
                            if (sep === ':' && previousNode && previousNode.type === 'property') {
                                previousNode.colonOffset = offset;
                                isAtPropertyKey = false;
                                previousNode = undefined;
                            } else if (sep === ',') {
                                const last = segments[segments.length - 1];
                                if (typeof last === 'number') {
                                    segments[segments.length - 1] = last + 1;
                                } else {
                                    isAtPropertyKey = true;
                                    segments[segments.length - 1] = '';
                                }
                                previousNode = undefined;
                            }
                        }
                    });
                } catch (e) {
                    if (e !== earlyReturnException) {
                        throw e;
                    }
                }
                return {
                    path: segments,
                    previousNode,
                    isAtPropertyKey,
                    matches: (pattern)=>{
                        let k = 0;
                        for(let i = 0; k < pattern.length && i < segments.length; i++){
                            if (pattern[k] === segments[i] || pattern[k] === '*') {
                                k++;
                            } else if (pattern[k] !== '**') {
                                return false;
                            }
                        }
                        return k === pattern.length;
                    }
                };
            }
            /**
 * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
 * Therefore always check the errors list to find out if the input was valid.
 */ function parse(text, errors = [], options = ParseOptions.DEFAULT) {
                let currentProperty = null;
                let currentParent = [];
                const previousParents = [];
                function onValue(value) {
                    if (Array.isArray(currentParent)) {
                        currentParent.push(value);
                    } else if (currentProperty !== null) {
                        currentParent[currentProperty] = value;
                    }
                }
                const visitor = {
                    onObjectBegin: ()=>{
                        const object = {};
                        onValue(object);
                        previousParents.push(currentParent);
                        currentParent = object;
                        currentProperty = null;
                    },
                    onObjectProperty: (name)=>{
                        currentProperty = name;
                    },
                    onObjectEnd: ()=>{
                        currentParent = previousParents.pop();
                    },
                    onArrayBegin: ()=>{
                        const array = [];
                        onValue(array);
                        previousParents.push(currentParent);
                        currentParent = array;
                        currentProperty = null;
                    },
                    onArrayEnd: ()=>{
                        currentParent = previousParents.pop();
                    },
                    onLiteralValue: onValue,
                    onError: (error, offset, length)=>{
                        errors.push({
                            error,
                            offset,
                            length
                        });
                    }
                };
                visit(text, visitor, options);
                return currentParent[0];
            }
            /**
 * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
 */ function parser_parseTree(text, errors = [], options = ParseOptions.DEFAULT) {
                let currentParent = {
                    type: 'array',
                    offset: -1,
                    length: -1,
                    children: [],
                    parent: undefined
                }; // artificial root
                function ensurePropertyComplete(endOffset) {
                    if (currentParent.type === 'property') {
                        currentParent.length = endOffset - currentParent.offset;
                        currentParent = currentParent.parent;
                    }
                }
                function onValue(valueNode) {
                    currentParent.children.push(valueNode);
                    return valueNode;
                }
                const visitor = {
                    onObjectBegin: (offset)=>{
                        currentParent = onValue({
                            type: 'object',
                            offset,
                            length: -1,
                            parent: currentParent,
                            children: []
                        });
                    },
                    onObjectProperty: (name, offset, length)=>{
                        currentParent = onValue({
                            type: 'property',
                            offset,
                            length: -1,
                            parent: currentParent,
                            children: []
                        });
                        currentParent.children.push({
                            type: 'string',
                            value: name,
                            offset,
                            length,
                            parent: currentParent
                        });
                    },
                    onObjectEnd: (offset, length)=>{
                        ensurePropertyComplete(offset + length); // in case of a missing value for a property: make sure property is complete
                        currentParent.length = offset + length - currentParent.offset;
                        currentParent = currentParent.parent;
                        ensurePropertyComplete(offset + length);
                    },
                    onArrayBegin: (offset, length)=>{
                        currentParent = onValue({
                            type: 'array',
                            offset,
                            length: -1,
                            parent: currentParent,
                            children: []
                        });
                    },
                    onArrayEnd: (offset, length)=>{
                        currentParent.length = offset + length - currentParent.offset;
                        currentParent = currentParent.parent;
                        ensurePropertyComplete(offset + length);
                    },
                    onLiteralValue: (value, offset, length)=>{
                        onValue({
                            type: getNodeType(value),
                            offset,
                            length,
                            parent: currentParent,
                            value
                        });
                        ensurePropertyComplete(offset + length);
                    },
                    onSeparator: (sep, offset, length)=>{
                        if (currentParent.type === 'property') {
                            if (sep === ':') {
                                currentParent.colonOffset = offset;
                            } else if (sep === ',') {
                                ensurePropertyComplete(offset);
                            }
                        }
                    },
                    onError: (error, offset, length)=>{
                        errors.push({
                            error,
                            offset,
                            length
                        });
                    }
                };
                visit(text, visitor, options);
                const result = currentParent.children[0];
                if (result) {
                    delete result.parent;
                }
                return result;
            }
            /**
 * Finds the node at the given path in a JSON DOM.
 */ function parser_findNodeAtLocation(root, path) {
                if (!root) {
                    return undefined;
                }
                let node = root;
                for (let segment of path){
                    if (typeof segment === 'string') {
                        if (node.type !== 'object' || !Array.isArray(node.children)) {
                            return undefined;
                        }
                        let found = false;
                        for (const propertyNode of node.children){
                            if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment && propertyNode.children.length === 2) {
                                node = propertyNode.children[1];
                                found = true;
                                break;
                            }
                        }
                        if (!found) {
                            return undefined;
                        }
                    } else {
                        const index = segment;
                        if (node.type !== 'array' || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {
                            return undefined;
                        }
                        node = node.children[index];
                    }
                }
                return node;
            }
            /**
 * Gets the JSON path of the given JSON DOM node
 */ function getNodePath(node) {
                if (!node.parent || !node.parent.children) {
                    return [];
                }
                const path = getNodePath(node.parent);
                if (node.parent.type === 'property') {
                    const key = node.parent.children[0].value;
                    path.push(key);
                } else if (node.parent.type === 'array') {
                    const index = node.parent.children.indexOf(node);
                    if (index !== -1) {
                        path.push(index);
                    }
                }
                return path;
            }
            /**
 * Evaluates the JavaScript object of the given JSON DOM node
 */ function getNodeValue(node) {
                switch(node.type){
                    case 'array':
                        return node.children.map(getNodeValue);
                    case 'object':
                        const obj = Object.create(null);
                        for (let prop of node.children){
                            const valueNode = prop.children[1];
                            if (valueNode) {
                                obj[prop.children[0].value] = getNodeValue(valueNode);
                            }
                        }
                        return obj;
                    case 'null':
                    case 'string':
                    case 'number':
                    case 'boolean':
                        return node.value;
                    default:
                        return undefined;
                }
            }
            function contains(node, offset, includeRightBound = false) {
                return offset >= node.offset && offset < node.offset + node.length || includeRightBound && offset === node.offset + node.length;
            }
            /**
 * Finds the most inner node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.
 */ function findNodeAtOffset(node, offset, includeRightBound = false) {
                if (contains(node, offset, includeRightBound)) {
                    const children = node.children;
                    if (Array.isArray(children)) {
                        for(let i = 0; i < children.length && children[i].offset <= offset; i++){
                            const item = findNodeAtOffset(children[i], offset, includeRightBound);
                            if (item) {
                                return item;
                            }
                        }
                    }
                    return node;
                }
                return undefined;
            }
            /**
 * Parses the given text and invokes the visitor functions for each object, array and literal reached.
 */ function visit(text, visitor, options = ParseOptions.DEFAULT) {
                const _scanner = createScanner(text, false);
                // Important: Only pass copies of this to visitor functions to prevent accidental modification, and
                // to not affect visitor functions which stored a reference to a previous JSONPath
                const _jsonPath = [];
                // Depth of onXXXBegin() callbacks suppressed. onXXXEnd() decrements this if it isn't 0 already.
                // Callbacks are only called when this value is 0.
                let suppressedCallbacks = 0;
                function toNoArgVisit(visitFunction) {
                    return visitFunction ? ()=>suppressedCallbacks === 0 && visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()) : ()=>true;
                }
                function toOneArgVisit(visitFunction) {
                    return visitFunction ? (arg)=>suppressedCallbacks === 0 && visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()) : ()=>true;
                }
                function toOneArgVisitWithPath(visitFunction) {
                    return visitFunction ? (arg)=>suppressedCallbacks === 0 && visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter(), ()=>_jsonPath.slice()) : ()=>true;
                }
                function toBeginVisit(visitFunction) {
                    return visitFunction ? ()=>{
                        if (suppressedCallbacks > 0) {
                            suppressedCallbacks++;
                        } else {
                            let cbReturn = visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter(), ()=>_jsonPath.slice());
                            if (cbReturn === false) {
                                suppressedCallbacks = 1;
                            }
                        }
                    } : ()=>true;
                }
                function toEndVisit(visitFunction) {
                    return visitFunction ? ()=>{
                        if (suppressedCallbacks > 0) {
                            suppressedCallbacks--;
                        }
                        if (suppressedCallbacks === 0) {
                            visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter());
                        }
                    } : ()=>true;
                }
                const onObjectBegin = toBeginVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisitWithPath(visitor.onObjectProperty), onObjectEnd = toEndVisit(visitor.onObjectEnd), onArrayBegin = toBeginVisit(visitor.onArrayBegin), onArrayEnd = toEndVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisitWithPath(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);
                const disallowComments = options && options.disallowComments;
                const allowTrailingComma = options && options.allowTrailingComma;
                function scanNext() {
                    while(true){
                        const token = _scanner.scan();
                        switch(_scanner.getTokenError()){
                            case 4 /* ScanError.InvalidUnicode */ :
                                handleError(14 /* ParseErrorCode.InvalidUnicode */ );
                                break;
                            case 5 /* ScanError.InvalidEscapeCharacter */ :
                                handleError(15 /* ParseErrorCode.InvalidEscapeCharacter */ );
                                break;
                            case 3 /* ScanError.UnexpectedEndOfNumber */ :
                                handleError(13 /* ParseErrorCode.UnexpectedEndOfNumber */ );
                                break;
                            case 1 /* ScanError.UnexpectedEndOfComment */ :
                                if (!disallowComments) {
                                    handleError(11 /* ParseErrorCode.UnexpectedEndOfComment */ );
                                }
                                break;
                            case 2 /* ScanError.UnexpectedEndOfString */ :
                                handleError(12 /* ParseErrorCode.UnexpectedEndOfString */ );
                                break;
                            case 6 /* ScanError.InvalidCharacter */ :
                                handleError(16 /* ParseErrorCode.InvalidCharacter */ );
                                break;
                        }
                        switch(token){
                            case 12 /* SyntaxKind.LineCommentTrivia */ :
                            case 13 /* SyntaxKind.BlockCommentTrivia */ :
                                if (disallowComments) {
                                    handleError(10 /* ParseErrorCode.InvalidCommentToken */ );
                                } else {
                                    onComment();
                                }
                                break;
                            case 16 /* SyntaxKind.Unknown */ :
                                handleError(1 /* ParseErrorCode.InvalidSymbol */ );
                                break;
                            case 15 /* SyntaxKind.Trivia */ :
                            case 14 /* SyntaxKind.LineBreakTrivia */ :
                                break;
                            default:
                                return token;
                        }
                    }
                }
                function handleError(error, skipUntilAfter = [], skipUntil = []) {
                    onError(error);
                    if (skipUntilAfter.length + skipUntil.length > 0) {
                        let token = _scanner.getToken();
                        while(token !== 17 /* SyntaxKind.EOF */ ){
                            if (skipUntilAfter.indexOf(token) !== -1) {
                                scanNext();
                                break;
                            } else if (skipUntil.indexOf(token) !== -1) {
                                break;
                            }
                            token = scanNext();
                        }
                    }
                }
                function parseString(isValue) {
                    const value = _scanner.getTokenValue();
                    if (isValue) {
                        onLiteralValue(value);
                    } else {
                        onObjectProperty(value);
                        // add property name afterwards
                        _jsonPath.push(value);
                    }
                    scanNext();
                    return true;
                }
                function parseLiteral() {
                    switch(_scanner.getToken()){
                        case 11 /* SyntaxKind.NumericLiteral */ :
                            const tokenValue = _scanner.getTokenValue();
                            let value = Number(tokenValue);
                            if (isNaN(value)) {
                                handleError(2 /* ParseErrorCode.InvalidNumberFormat */ );
                                value = 0;
                            }
                            onLiteralValue(value);
                            break;
                        case 7 /* SyntaxKind.NullKeyword */ :
                            onLiteralValue(null);
                            break;
                        case 8 /* SyntaxKind.TrueKeyword */ :
                            onLiteralValue(true);
                            break;
                        case 9 /* SyntaxKind.FalseKeyword */ :
                            onLiteralValue(false);
                            break;
                        default:
                            return false;
                    }
                    scanNext();
                    return true;
                }
                function parseProperty() {
                    if (_scanner.getToken() !== 10 /* SyntaxKind.StringLiteral */ ) {
                        handleError(3 /* ParseErrorCode.PropertyNameExpected */ , [], [
                            2 /* SyntaxKind.CloseBraceToken */ ,
                            5 /* SyntaxKind.CommaToken */ 
                        ]);
                        return false;
                    }
                    parseString(false);
                    if (_scanner.getToken() === 6 /* SyntaxKind.ColonToken */ ) {
                        onSeparator(':');
                        scanNext(); // consume colon
                        if (!parseValue()) {
                            handleError(4 /* ParseErrorCode.ValueExpected */ , [], [
                                2 /* SyntaxKind.CloseBraceToken */ ,
                                5 /* SyntaxKind.CommaToken */ 
                            ]);
                        }
                    } else {
                        handleError(5 /* ParseErrorCode.ColonExpected */ , [], [
                            2 /* SyntaxKind.CloseBraceToken */ ,
                            5 /* SyntaxKind.CommaToken */ 
                        ]);
                    }
                    _jsonPath.pop(); // remove processed property name
                    return true;
                }
                function parseObject() {
                    onObjectBegin();
                    scanNext(); // consume open brace
                    let needsComma = false;
                    while(_scanner.getToken() !== 2 /* SyntaxKind.CloseBraceToken */  && _scanner.getToken() !== 17 /* SyntaxKind.EOF */ ){
                        if (_scanner.getToken() === 5 /* SyntaxKind.CommaToken */ ) {
                            if (!needsComma) {
                                handleError(4 /* ParseErrorCode.ValueExpected */ , [], []);
                            }
                            onSeparator(',');
                            scanNext(); // consume comma
                            if (_scanner.getToken() === 2 /* SyntaxKind.CloseBraceToken */  && allowTrailingComma) {
                                break;
                            }
                        } else if (needsComma) {
                            handleError(6 /* ParseErrorCode.CommaExpected */ , [], []);
                        }
                        if (!parseProperty()) {
                            handleError(4 /* ParseErrorCode.ValueExpected */ , [], [
                                2 /* SyntaxKind.CloseBraceToken */ ,
                                5 /* SyntaxKind.CommaToken */ 
                            ]);
                        }
                        needsComma = true;
                    }
                    onObjectEnd();
                    if (_scanner.getToken() !== 2 /* SyntaxKind.CloseBraceToken */ ) {
                        handleError(7 /* ParseErrorCode.CloseBraceExpected */ , [
                            2 /* SyntaxKind.CloseBraceToken */ 
                        ], []);
                    } else {
                        scanNext(); // consume close brace
                    }
                    return true;
                }
                function parseArray() {
                    onArrayBegin();
                    scanNext(); // consume open bracket
                    let isFirstElement = true;
                    let needsComma = false;
                    while(_scanner.getToken() !== 4 /* SyntaxKind.CloseBracketToken */  && _scanner.getToken() !== 17 /* SyntaxKind.EOF */ ){
                        if (_scanner.getToken() === 5 /* SyntaxKind.CommaToken */ ) {
                            if (!needsComma) {
                                handleError(4 /* ParseErrorCode.ValueExpected */ , [], []);
                            }
                            onSeparator(',');
                            scanNext(); // consume comma
                            if (_scanner.getToken() === 4 /* SyntaxKind.CloseBracketToken */  && allowTrailingComma) {
                                break;
                            }
                        } else if (needsComma) {
                            handleError(6 /* ParseErrorCode.CommaExpected */ , [], []);
                        }
                        if (isFirstElement) {
                            _jsonPath.push(0);
                            isFirstElement = false;
                        } else {
                            _jsonPath[_jsonPath.length - 1]++;
                        }
                        if (!parseValue()) {
                            handleError(4 /* ParseErrorCode.ValueExpected */ , [], [
                                4 /* SyntaxKind.CloseBracketToken */ ,
                                5 /* SyntaxKind.CommaToken */ 
                            ]);
                        }
                        needsComma = true;
                    }
                    onArrayEnd();
                    if (!isFirstElement) {
                        _jsonPath.pop(); // remove array index
                    }
                    if (_scanner.getToken() !== 4 /* SyntaxKind.CloseBracketToken */ ) {
                        handleError(8 /* ParseErrorCode.CloseBracketExpected */ , [
                            4 /* SyntaxKind.CloseBracketToken */ 
                        ], []);
                    } else {
                        scanNext(); // consume close bracket
                    }
                    return true;
                }
                function parseValue() {
                    switch(_scanner.getToken()){
                        case 3 /* SyntaxKind.OpenBracketToken */ :
                            return parseArray();
                        case 1 /* SyntaxKind.OpenBraceToken */ :
                            return parseObject();
                        case 10 /* SyntaxKind.StringLiteral */ :
                            return parseString(true);
                        default:
                            return parseLiteral();
                    }
                }
                scanNext();
                if (_scanner.getToken() === 17 /* SyntaxKind.EOF */ ) {
                    if (options.allowEmptyContent) {
                        return true;
                    }
                    handleError(4 /* ParseErrorCode.ValueExpected */ , [], []);
                    return false;
                }
                if (!parseValue()) {
                    handleError(4 /* ParseErrorCode.ValueExpected */ , [], []);
                    return false;
                }
                if (_scanner.getToken() !== 17 /* SyntaxKind.EOF */ ) {
                    handleError(9 /* ParseErrorCode.EndOfFileExpected */ , [], []);
                }
                return true;
            }
            /**
 * Takes JSON with JavaScript-style comments and remove
 * them. Optionally replaces every none-newline character
 * of comments with a replaceCharacter
 */ function stripComments(text, replaceCh) {
                let _scanner = createScanner(text), parts = [], kind, offset = 0, pos;
                do {
                    pos = _scanner.getPosition();
                    kind = _scanner.scan();
                    switch(kind){
                        case 12 /* SyntaxKind.LineCommentTrivia */ :
                        case 13 /* SyntaxKind.BlockCommentTrivia */ :
                        case 17 /* SyntaxKind.EOF */ :
                            if (offset !== pos) {
                                parts.push(text.substring(offset, pos));
                            }
                            if (replaceCh !== undefined) {
                                parts.push(_scanner.getTokenValue().replace(/[^\r\n]/g, replaceCh));
                            }
                            offset = _scanner.getPosition();
                            break;
                    }
                }while (kind !== 17 /* SyntaxKind.EOF */ )
                return parts.join('');
            }
            function getNodeType(value) {
                switch(typeof value){
                    case 'boolean':
                        return 'boolean';
                    case 'number':
                        return 'number';
                    case 'string':
                        return 'string';
                    case 'object':
                        {
                            if (!value) {
                                return 'null';
                            } else if (Array.isArray(value)) {
                                return 'array';
                            }
                            return 'object';
                        }
                    default:
                        return 'null';
                }
            }
            ; // CONCATENATED MODULE: ../../node_modules/jsonc-parser/lib/esm/impl/edit.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ function removeProperty(text, path, options) {
                return setProperty(text, path, void 0, options);
            }
            function setProperty(text, originalPath, value, options) {
                const path = originalPath.slice();
                const errors = [];
                const root = parseTree(text, errors);
                let parent = void 0;
                let lastSegment = void 0;
                while(path.length > 0){
                    lastSegment = path.pop();
                    parent = findNodeAtLocation(root, path);
                    if (parent === void 0 && value !== void 0) {
                        if (typeof lastSegment === 'string') {
                            value = {
                                [lastSegment]: value
                            };
                        } else {
                            value = [
                                value
                            ];
                        }
                    } else {
                        break;
                    }
                }
                if (!parent) {
                    // empty document
                    if (value === void 0) {
                        throw new Error('Can not delete in empty document');
                    }
                    return withFormatting(text, {
                        offset: root ? root.offset : 0,
                        length: root ? root.length : 0,
                        content: JSON.stringify(value)
                    }, options);
                } else if (parent.type === 'object' && typeof lastSegment === 'string' && Array.isArray(parent.children)) {
                    const existing = findNodeAtLocation(parent, [
                        lastSegment
                    ]);
                    if (existing !== void 0) {
                        if (value === void 0) {
                            if (!existing.parent) {
                                throw new Error('Malformed AST');
                            }
                            const propertyIndex = parent.children.indexOf(existing.parent);
                            let removeBegin;
                            let removeEnd = existing.parent.offset + existing.parent.length;
                            if (propertyIndex > 0) {
                                // remove the comma of the previous node
                                let previous = parent.children[propertyIndex - 1];
                                removeBegin = previous.offset + previous.length;
                            } else {
                                removeBegin = parent.offset + 1;
                                if (parent.children.length > 1) {
                                    // remove the comma of the next node
                                    let next = parent.children[1];
                                    removeEnd = next.offset;
                                }
                            }
                            return withFormatting(text, {
                                offset: removeBegin,
                                length: removeEnd - removeBegin,
                                content: ''
                            }, options);
                        } else {
                            // set value of existing property
                            return withFormatting(text, {
                                offset: existing.offset,
                                length: existing.length,
                                content: JSON.stringify(value)
                            }, options);
                        }
                    } else {
                        if (value === void 0) {
                            return []; // property does not exist, nothing to do
                        }
                        const newProperty = `${JSON.stringify(lastSegment)}: ${JSON.stringify(value)}`;
                        const index = options.getInsertionIndex ? options.getInsertionIndex(parent.children.map((p)=>p.children[0].value)) : parent.children.length;
                        let edit1;
                        if (index > 0) {
                            let previous = parent.children[index - 1];
                            edit1 = {
                                offset: previous.offset + previous.length,
                                length: 0,
                                content: ',' + newProperty
                            };
                        } else if (parent.children.length === 0) {
                            edit1 = {
                                offset: parent.offset + 1,
                                length: 0,
                                content: newProperty
                            };
                        } else {
                            edit1 = {
                                offset: parent.offset + 1,
                                length: 0,
                                content: newProperty + ','
                            };
                        }
                        return withFormatting(text, edit1, options);
                    }
                } else if (parent.type === 'array' && typeof lastSegment === 'number' && Array.isArray(parent.children)) {
                    const insertIndex = lastSegment;
                    if (insertIndex === -1) {
                        // Insert
                        const newProperty = `${JSON.stringify(value)}`;
                        let edit1;
                        if (parent.children.length === 0) {
                            edit1 = {
                                offset: parent.offset + 1,
                                length: 0,
                                content: newProperty
                            };
                        } else {
                            const previous = parent.children[parent.children.length - 1];
                            edit1 = {
                                offset: previous.offset + previous.length,
                                length: 0,
                                content: ',' + newProperty
                            };
                        }
                        return withFormatting(text, edit1, options);
                    } else if (value === void 0 && parent.children.length >= 0) {
                        // Removal
                        const removalIndex = lastSegment;
                        const toRemove = parent.children[removalIndex];
                        let edit1;
                        if (parent.children.length === 1) {
                            // only item
                            edit1 = {
                                offset: parent.offset + 1,
                                length: parent.length - 2,
                                content: ''
                            };
                        } else if (parent.children.length - 1 === removalIndex) {
                            // last item
                            let previous = parent.children[removalIndex - 1];
                            let offset = previous.offset + previous.length;
                            let parentEndOffset = parent.offset + parent.length;
                            edit1 = {
                                offset,
                                length: parentEndOffset - 2 - offset,
                                content: ''
                            };
                        } else {
                            edit1 = {
                                offset: toRemove.offset,
                                length: parent.children[removalIndex + 1].offset - toRemove.offset,
                                content: ''
                            };
                        }
                        return withFormatting(text, edit1, options);
                    } else if (value !== void 0) {
                        let edit1;
                        const newProperty = `${JSON.stringify(value)}`;
                        if (!options.isArrayInsertion && parent.children.length > lastSegment) {
                            const toModify = parent.children[lastSegment];
                            edit1 = {
                                offset: toModify.offset,
                                length: toModify.length,
                                content: newProperty
                            };
                        } else if (parent.children.length === 0 || lastSegment === 0) {
                            edit1 = {
                                offset: parent.offset + 1,
                                length: 0,
                                content: parent.children.length === 0 ? newProperty : newProperty + ','
                            };
                        } else {
                            const index = lastSegment > parent.children.length ? parent.children.length : lastSegment;
                            const previous = parent.children[index - 1];
                            edit1 = {
                                offset: previous.offset + previous.length,
                                length: 0,
                                content: ',' + newProperty
                            };
                        }
                        return withFormatting(text, edit1, options);
                    } else {
                        throw new Error(`Can not ${value === void 0 ? 'remove' : options.isArrayInsertion ? 'insert' : 'modify'} Array index ${insertIndex} as length is not sufficient`);
                    }
                } else {
                    throw new Error(`Can not add ${typeof lastSegment !== 'number' ? 'index' : 'property'} to parent of type ${parent.type}`);
                }
            }
            function withFormatting(text, edit1, options) {
                if (!options.formattingOptions) {
                    return [
                        edit1
                    ];
                }
                // apply the edit
                let newText = applyEdit(text, edit1);
                // format the new text
                let begin = edit1.offset;
                let end = edit1.offset + edit1.content.length;
                if (edit1.length === 0 || edit1.content.length === 0) {
                    while(begin > 0 && !isEOL(newText, begin - 1)){
                        begin--;
                    }
                    while(end < newText.length && !isEOL(newText, end)){
                        end++;
                    }
                }
                const edits = format(newText, {
                    offset: begin,
                    length: end - begin
                }, {
                    ...options.formattingOptions,
                    keepLines: false
                });
                // apply the formatting edits and track the begin and end offsets of the changes
                for(let i = edits.length - 1; i >= 0; i--){
                    const edit1 = edits[i];
                    newText = applyEdit(newText, edit1);
                    begin = Math.min(begin, edit1.offset);
                    end = Math.max(end, edit1.offset + edit1.length);
                    end += edit1.content.length - edit1.length;
                }
                // create a single edit with all changes
                const editLength = text.length - (newText.length - end) - begin;
                return [
                    {
                        offset: begin,
                        length: editLength,
                        content: newText.substring(begin, end)
                    }
                ];
            }
            function applyEdit(text, edit1) {
                return text.substring(0, edit1.offset) + edit1.content + text.substring(edit1.offset + edit1.length);
            }
            function isWS(text, offset) {
                return '\r\n \t'.indexOf(text.charAt(offset)) !== -1;
            }
            ; // CONCATENATED MODULE: ../../node_modules/jsonc-parser/lib/esm/main.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ /**
 * Creates a JSON scanner on the given text.
 * If ignoreTrivia is set, whitespaces or comments are ignored.
 */ const main_createScanner = createScanner;
            var ScanError;
            (function(ScanError) {
                ScanError[ScanError["None"] = 0] = "None";
                ScanError[ScanError["UnexpectedEndOfComment"] = 1] = "UnexpectedEndOfComment";
                ScanError[ScanError["UnexpectedEndOfString"] = 2] = "UnexpectedEndOfString";
                ScanError[ScanError["UnexpectedEndOfNumber"] = 3] = "UnexpectedEndOfNumber";
                ScanError[ScanError["InvalidUnicode"] = 4] = "InvalidUnicode";
                ScanError[ScanError["InvalidEscapeCharacter"] = 5] = "InvalidEscapeCharacter";
                ScanError[ScanError["InvalidCharacter"] = 6] = "InvalidCharacter";
            })(ScanError || (ScanError = {}));
            var SyntaxKind;
            (function(SyntaxKind) {
                SyntaxKind[SyntaxKind["OpenBraceToken"] = 1] = "OpenBraceToken";
                SyntaxKind[SyntaxKind["CloseBraceToken"] = 2] = "CloseBraceToken";
                SyntaxKind[SyntaxKind["OpenBracketToken"] = 3] = "OpenBracketToken";
                SyntaxKind[SyntaxKind["CloseBracketToken"] = 4] = "CloseBracketToken";
                SyntaxKind[SyntaxKind["CommaToken"] = 5] = "CommaToken";
                SyntaxKind[SyntaxKind["ColonToken"] = 6] = "ColonToken";
                SyntaxKind[SyntaxKind["NullKeyword"] = 7] = "NullKeyword";
                SyntaxKind[SyntaxKind["TrueKeyword"] = 8] = "TrueKeyword";
                SyntaxKind[SyntaxKind["FalseKeyword"] = 9] = "FalseKeyword";
                SyntaxKind[SyntaxKind["StringLiteral"] = 10] = "StringLiteral";
                SyntaxKind[SyntaxKind["NumericLiteral"] = 11] = "NumericLiteral";
                SyntaxKind[SyntaxKind["LineCommentTrivia"] = 12] = "LineCommentTrivia";
                SyntaxKind[SyntaxKind["BlockCommentTrivia"] = 13] = "BlockCommentTrivia";
                SyntaxKind[SyntaxKind["LineBreakTrivia"] = 14] = "LineBreakTrivia";
                SyntaxKind[SyntaxKind["Trivia"] = 15] = "Trivia";
                SyntaxKind[SyntaxKind["Unknown"] = 16] = "Unknown";
                SyntaxKind[SyntaxKind["EOF"] = 17] = "EOF";
            })(SyntaxKind || (SyntaxKind = {}));
            /**
 * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.
 */ const main_getLocation = getLocation;
            /**
 * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
 * Therefore, always check the errors list to find out if the input was valid.
 */ const main_parse = parse;
            /**
 * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
 */ const main_parseTree = parser_parseTree;
            /**
 * Finds the node at the given path in a JSON DOM.
 */ const main_findNodeAtLocation = parser_findNodeAtLocation;
            /**
 * Finds the innermost node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.
 */ const main_findNodeAtOffset = findNodeAtOffset;
            /**
 * Gets the JSON path of the given JSON DOM node
 */ const main_getNodePath = getNodePath;
            /**
 * Evaluates the JavaScript object of the given JSON DOM node
 */ const main_getNodeValue = getNodeValue;
            /**
 * Parses the given text and invokes the visitor functions for each object, array and literal reached.
 */ const main_visit = visit;
            /**
 * Takes JSON with JavaScript-style comments and remove
 * them. Optionally replaces every none-newline character
 * of comments with a replaceCharacter
 */ const main_stripComments = stripComments;
            var ParseErrorCode;
            (function(ParseErrorCode) {
                ParseErrorCode[ParseErrorCode["InvalidSymbol"] = 1] = "InvalidSymbol";
                ParseErrorCode[ParseErrorCode["InvalidNumberFormat"] = 2] = "InvalidNumberFormat";
                ParseErrorCode[ParseErrorCode["PropertyNameExpected"] = 3] = "PropertyNameExpected";
                ParseErrorCode[ParseErrorCode["ValueExpected"] = 4] = "ValueExpected";
                ParseErrorCode[ParseErrorCode["ColonExpected"] = 5] = "ColonExpected";
                ParseErrorCode[ParseErrorCode["CommaExpected"] = 6] = "CommaExpected";
                ParseErrorCode[ParseErrorCode["CloseBraceExpected"] = 7] = "CloseBraceExpected";
                ParseErrorCode[ParseErrorCode["CloseBracketExpected"] = 8] = "CloseBracketExpected";
                ParseErrorCode[ParseErrorCode["EndOfFileExpected"] = 9] = "EndOfFileExpected";
                ParseErrorCode[ParseErrorCode["InvalidCommentToken"] = 10] = "InvalidCommentToken";
                ParseErrorCode[ParseErrorCode["UnexpectedEndOfComment"] = 11] = "UnexpectedEndOfComment";
                ParseErrorCode[ParseErrorCode["UnexpectedEndOfString"] = 12] = "UnexpectedEndOfString";
                ParseErrorCode[ParseErrorCode["UnexpectedEndOfNumber"] = 13] = "UnexpectedEndOfNumber";
                ParseErrorCode[ParseErrorCode["InvalidUnicode"] = 14] = "InvalidUnicode";
                ParseErrorCode[ParseErrorCode["InvalidEscapeCharacter"] = 15] = "InvalidEscapeCharacter";
                ParseErrorCode[ParseErrorCode["InvalidCharacter"] = 16] = "InvalidCharacter";
            })(ParseErrorCode || (ParseErrorCode = {}));
            function printParseErrorCode(code) {
                switch(code){
                    case 1 /* ParseErrorCode.InvalidSymbol */ :
                        return 'InvalidSymbol';
                    case 2 /* ParseErrorCode.InvalidNumberFormat */ :
                        return 'InvalidNumberFormat';
                    case 3 /* ParseErrorCode.PropertyNameExpected */ :
                        return 'PropertyNameExpected';
                    case 4 /* ParseErrorCode.ValueExpected */ :
                        return 'ValueExpected';
                    case 5 /* ParseErrorCode.ColonExpected */ :
                        return 'ColonExpected';
                    case 6 /* ParseErrorCode.CommaExpected */ :
                        return 'CommaExpected';
                    case 7 /* ParseErrorCode.CloseBraceExpected */ :
                        return 'CloseBraceExpected';
                    case 8 /* ParseErrorCode.CloseBracketExpected */ :
                        return 'CloseBracketExpected';
                    case 9 /* ParseErrorCode.EndOfFileExpected */ :
                        return 'EndOfFileExpected';
                    case 10 /* ParseErrorCode.InvalidCommentToken */ :
                        return 'InvalidCommentToken';
                    case 11 /* ParseErrorCode.UnexpectedEndOfComment */ :
                        return 'UnexpectedEndOfComment';
                    case 12 /* ParseErrorCode.UnexpectedEndOfString */ :
                        return 'UnexpectedEndOfString';
                    case 13 /* ParseErrorCode.UnexpectedEndOfNumber */ :
                        return 'UnexpectedEndOfNumber';
                    case 14 /* ParseErrorCode.InvalidUnicode */ :
                        return 'InvalidUnicode';
                    case 15 /* ParseErrorCode.InvalidEscapeCharacter */ :
                        return 'InvalidEscapeCharacter';
                    case 16 /* ParseErrorCode.InvalidCharacter */ :
                        return 'InvalidCharacter';
                }
                return '<unknown ParseErrorCode>';
            }
            /**
 * Computes the edit operations needed to format a JSON document.
 *
 * @param documentText The input text
 * @param range The range to format or `undefined` to format the full content
 * @param options The formatting options
 * @returns The edit operations describing the formatting changes to the original document following the format described in {@linkcode EditResult}.
 * To apply the edit operations to the input, use {@linkcode applyEdits}.
 */ function main_format(documentText, range, options) {
                return format_format(documentText, range, options);
            }
            /**
 * Computes the edit operations needed to modify a value in the JSON document.
 *
 * @param documentText The input text
 * @param path The path of the value to change. The path represents either to the document root, a property or an array item.
 * If the path points to an non-existing property or item, it will be created.
 * @param value The new value for the specified property or item. If the value is undefined,
 * the property or item will be removed.
 * @param options Options
 * @returns The edit operations describing the changes to the original document, following the format described in {@linkcode EditResult}.
 * To apply the edit operations to the input, use {@linkcode applyEdits}.
 */ function modify(text, path, value, options) {
                return edit.setProperty(text, path, value, options);
            }
            /**
 * Applies edits to an input string.
 * @param text The input text
 * @param edits Edit operations following the format described in {@linkcode EditResult}.
 * @returns The text with the applied edits.
 * @throws An error if the edit operations are not well-formed as described in {@linkcode EditResult}.
 */ function applyEdits(text, edits) {
                let sortedEdits = edits.slice(0).sort((a, b)=>{
                    const diff = a.offset - b.offset;
                    if (diff === 0) {
                        return a.length - b.length;
                    }
                    return diff;
                });
                let lastModifiedOffset = text.length;
                for(let i = sortedEdits.length - 1; i >= 0; i--){
                    let e = sortedEdits[i];
                    if (e.offset + e.length <= lastModifiedOffset) {
                        text = edit.applyEdit(text, e);
                    } else {
                        throw new Error('Overlapping edit');
                    }
                    lastModifiedOffset = e.offset;
                }
                return text;
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/utils/objects.js
            /*---------------------------------------------------------------------------------------------
*  Copyright (c) Microsoft Corporation. All rights reserved.
*  Licensed under the MIT License. See License.txt in the project root for license information.
*--------------------------------------------------------------------------------------------*/ function equals(one, other) {
                if (one === other) {
                    return true;
                }
                if (one === null || one === undefined || other === null || other === undefined) {
                    return false;
                }
                if (typeof one !== typeof other) {
                    return false;
                }
                if (typeof one !== 'object') {
                    return false;
                }
                if (Array.isArray(one) !== Array.isArray(other)) {
                    return false;
                }
                let i, key;
                if (Array.isArray(one)) {
                    if (one.length !== other.length) {
                        return false;
                    }
                    for(i = 0; i < one.length; i++){
                        if (!equals(one[i], other[i])) {
                            return false;
                        }
                    }
                } else {
                    const oneKeys = [];
                    for(key in one){
                        oneKeys.push(key);
                    }
                    oneKeys.sort();
                    const otherKeys = [];
                    for(key in other){
                        otherKeys.push(key);
                    }
                    otherKeys.sort();
                    if (!equals(oneKeys, otherKeys)) {
                        return false;
                    }
                    for(i = 0; i < oneKeys.length; i++){
                        if (!equals(one[oneKeys[i]], other[oneKeys[i]])) {
                            return false;
                        }
                    }
                }
                return true;
            }
            function isNumber(val) {
                return typeof val === 'number';
            }
            function isDefined(val) {
                return typeof val !== 'undefined';
            }
            function isBoolean(val) {
                return typeof val === 'boolean';
            }
            function isString(val) {
                return typeof val === 'string';
            }
            function isObject(val) {
                return typeof val === 'object' && val !== null && !Array.isArray(val);
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/utils/strings.js
            /*---------------------------------------------------------------------------------------------
*  Copyright (c) Microsoft Corporation. All rights reserved.
*  Licensed under the MIT License. See License.txt in the project root for license information.
*--------------------------------------------------------------------------------------------*/ function startsWith(haystack, needle) {
                if (haystack.length < needle.length) {
                    return false;
                }
                for(let i = 0; i < needle.length; i++){
                    if (haystack[i] !== needle[i]) {
                        return false;
                    }
                }
                return true;
            }
            /**
 * Determines if haystack ends with needle.
 */ function endsWith(haystack, needle) {
                const diff = haystack.length - needle.length;
                if (diff > 0) {
                    return haystack.lastIndexOf(needle) === diff;
                } else if (diff === 0) {
                    return haystack === needle;
                } else {
                    return false;
                }
            }
            function convertSimple2RegExpPattern(pattern) {
                return pattern.replace(/[\-\\\{\}\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, '\\$&').replace(/[\*]/g, '.*');
            }
            function strings_repeat(value, count) {
                let s = '';
                while(count > 0){
                    if ((count & 1) === 1) {
                        s += value;
                    }
                    value += value;
                    count = count >>> 1;
                }
                return s;
            }
            function extendedRegExp(pattern) {
                let flags = '';
                if (startsWith(pattern, '(?i)')) {
                    pattern = pattern.substring(4);
                    flags = 'i';
                }
                try {
                    return new RegExp(pattern, flags + 'u');
                } catch (e) {
                    // could be an exception due to the 'u ' flag
                    try {
                        return new RegExp(pattern, flags);
                    } catch (e) {
                        // invalid pattern
                        return undefined;
                    }
                }
            }
            // from https://tanishiking.github.io/posts/count-unicode-codepoint/#work-hard-with-for-statements
            function stringLength(str) {
                let count = 0;
                for(let i = 0; i < str.length; i++){
                    count++;
                    // obtain the i-th 16-bit
                    const code = str.charCodeAt(i);
                    if (0xD800 <= code && code <= 0xDBFF) {
                        // if the i-th 16bit is an upper surrogate
                        // skip the next 16 bits (lower surrogate)
                        i++;
                    }
                }
                return count;
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/node_modules/vscode-languageserver-types/lib/esm/main.js
            /* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ var DocumentUri;
            (function(DocumentUri) {
                function is(value) {
                    return typeof value === 'string';
                }
                DocumentUri.is = is;
            })(DocumentUri || (DocumentUri = {}));
            var json_service_URI;
            (function(URI1) {
                function is(value) {
                    return typeof value === 'string';
                }
                URI1.is = is;
            })(json_service_URI || (json_service_URI = {}));
            var integer;
            (function(integer) {
                integer.MIN_VALUE = -2147483648;
                integer.MAX_VALUE = 2147483647;
                function is(value) {
                    return typeof value === 'number' && integer.MIN_VALUE <= value && value <= integer.MAX_VALUE;
                }
                integer.is = is;
            })(integer || (integer = {}));
            var uinteger;
            (function(uinteger) {
                uinteger.MIN_VALUE = 0;
                uinteger.MAX_VALUE = 2147483647;
                function is(value) {
                    return typeof value === 'number' && uinteger.MIN_VALUE <= value && value <= uinteger.MAX_VALUE;
                }
                uinteger.is = is;
            })(uinteger || (uinteger = {}));
            /**
 * The Position namespace provides helper functions to work with
 * {@link Position} literals.
 */ var Position;
            (function(Position) {
                /**
     * Creates a new Position literal from the given line and character.
     * @param line The position's line.
     * @param character The position's character.
     */ function create(line, character) {
                    if (line === Number.MAX_VALUE) {
                        line = uinteger.MAX_VALUE;
                    }
                    if (character === Number.MAX_VALUE) {
                        character = uinteger.MAX_VALUE;
                    }
                    return {
                        line,
                        character
                    };
                }
                Position.create = create;
                /**
     * Checks whether the given literal conforms to the {@link Position} interface.
     */ function is(value) {
                    let candidate = value;
                    return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
                }
                Position.is = is;
            })(Position || (Position = {}));
            /**
 * The Range namespace provides helper functions to work with
 * {@link Range} literals.
 */ var Range;
            (function(Range) {
                function create(one, two, three, four) {
                    if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
                        return {
                            start: Position.create(one, two),
                            end: Position.create(three, four)
                        };
                    } else if (Position.is(one) && Position.is(two)) {
                        return {
                            start: one,
                            end: two
                        };
                    } else {
                        throw new Error(`Range#create called with invalid arguments[${one}, ${two}, ${three}, ${four}]`);
                    }
                }
                Range.create = create;
                /**
     * Checks whether the given literal conforms to the {@link Range} interface.
     */ function is(value) {
                    let candidate = value;
                    return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
                }
                Range.is = is;
            })(Range || (Range = {}));
            /**
 * The Location namespace provides helper functions to work with
 * {@link Location} literals.
 */ var Location;
            (function(Location) {
                /**
     * Creates a Location literal.
     * @param uri The location's uri.
     * @param range The location's range.
     */ function create(uri, range) {
                    return {
                        uri,
                        range
                    };
                }
                Location.create = create;
                /**
     * Checks whether the given literal conforms to the {@link Location} interface.
     */ function is(value) {
                    let candidate = value;
                    return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
                }
                Location.is = is;
            })(Location || (Location = {}));
            /**
 * The LocationLink namespace provides helper functions to work with
 * {@link LocationLink} literals.
 */ var LocationLink;
            (function(LocationLink) {
                /**
     * Creates a LocationLink literal.
     * @param targetUri The definition's uri.
     * @param targetRange The full range of the definition.
     * @param targetSelectionRange The span of the symbol definition at the target.
     * @param originSelectionRange The span of the symbol being defined in the originating source file.
     */ function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
                    return {
                        targetUri,
                        targetRange,
                        targetSelectionRange,
                        originSelectionRange
                    };
                }
                LocationLink.create = create;
                /**
     * Checks whether the given literal conforms to the {@link LocationLink} interface.
     */ function is(value) {
                    let candidate = value;
                    return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
                }
                LocationLink.is = is;
            })(LocationLink || (LocationLink = {}));
            /**
 * The Color namespace provides helper functions to work with
 * {@link Color} literals.
 */ var Color;
            (function(Color) {
                /**
     * Creates a new Color literal.
     */ function create(red, green, blue, alpha) {
                    return {
                        red,
                        green,
                        blue,
                        alpha
                    };
                }
                Color.create = create;
                /**
     * Checks whether the given literal conforms to the {@link Color} interface.
     */ function is(value) {
                    const candidate = value;
                    return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
                }
                Color.is = is;
            })(Color || (Color = {}));
            /**
 * The ColorInformation namespace provides helper functions to work with
 * {@link ColorInformation} literals.
 */ var ColorInformation;
            (function(ColorInformation) {
                /**
     * Creates a new ColorInformation literal.
     */ function create(range, color) {
                    return {
                        range,
                        color
                    };
                }
                ColorInformation.create = create;
                /**
     * Checks whether the given literal conforms to the {@link ColorInformation} interface.
     */ function is(value) {
                    const candidate = value;
                    return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
                }
                ColorInformation.is = is;
            })(ColorInformation || (ColorInformation = {}));
            /**
 * The Color namespace provides helper functions to work with
 * {@link ColorPresentation} literals.
 */ var ColorPresentation;
            (function(ColorPresentation) {
                /**
     * Creates a new ColorInformation literal.
     */ function create(label, textEdit, additionalTextEdits) {
                    return {
                        label,
                        textEdit,
                        additionalTextEdits
                    };
                }
                ColorPresentation.create = create;
                /**
     * Checks whether the given literal conforms to the {@link ColorInformation} interface.
     */ function is(value) {
                    const candidate = value;
                    return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
                }
                ColorPresentation.is = is;
            })(ColorPresentation || (ColorPresentation = {}));
            /**
 * A set of predefined range kinds.
 */ var FoldingRangeKind;
            (function(FoldingRangeKind) {
                /**
     * Folding range for a comment
     */ FoldingRangeKind.Comment = 'comment';
                /**
     * Folding range for an import or include
     */ FoldingRangeKind.Imports = 'imports';
                /**
     * Folding range for a region (e.g. `#region`)
     */ FoldingRangeKind.Region = 'region';
            })(FoldingRangeKind || (FoldingRangeKind = {}));
            /**
 * The folding range namespace provides helper functions to work with
 * {@link FoldingRange} literals.
 */ var FoldingRange;
            (function(FoldingRange) {
                /**
     * Creates a new FoldingRange literal.
     */ function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
                    const result = {
                        startLine,
                        endLine
                    };
                    if (Is.defined(startCharacter)) {
                        result.startCharacter = startCharacter;
                    }
                    if (Is.defined(endCharacter)) {
                        result.endCharacter = endCharacter;
                    }
                    if (Is.defined(kind)) {
                        result.kind = kind;
                    }
                    if (Is.defined(collapsedText)) {
                        result.collapsedText = collapsedText;
                    }
                    return result;
                }
                FoldingRange.create = create;
                /**
     * Checks whether the given literal conforms to the {@link FoldingRange} interface.
     */ function is(value) {
                    const candidate = value;
                    return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
                }
                FoldingRange.is = is;
            })(FoldingRange || (FoldingRange = {}));
            /**
 * The DiagnosticRelatedInformation namespace provides helper functions to work with
 * {@link DiagnosticRelatedInformation} literals.
 */ var DiagnosticRelatedInformation;
            (function(DiagnosticRelatedInformation) {
                /**
     * Creates a new DiagnosticRelatedInformation literal.
     */ function create(location, message) {
                    return {
                        location,
                        message
                    };
                }
                DiagnosticRelatedInformation.create = create;
                /**
     * Checks whether the given literal conforms to the {@link DiagnosticRelatedInformation} interface.
     */ function is(value) {
                    let candidate = value;
                    return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
                }
                DiagnosticRelatedInformation.is = is;
            })(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
            /**
 * The diagnostic's severity.
 */ var DiagnosticSeverity;
            (function(DiagnosticSeverity) {
                /**
     * Reports an error.
     */ DiagnosticSeverity.Error = 1;
                /**
     * Reports a warning.
     */ DiagnosticSeverity.Warning = 2;
                /**
     * Reports an information.
     */ DiagnosticSeverity.Information = 3;
                /**
     * Reports a hint.
     */ DiagnosticSeverity.Hint = 4;
            })(DiagnosticSeverity || (DiagnosticSeverity = {}));
            /**
 * The diagnostic tags.
 *
 * @since 3.15.0
 */ var DiagnosticTag;
            (function(DiagnosticTag) {
                /**
     * Unused or unnecessary code.
     *
     * Clients are allowed to render diagnostics with this tag faded out instead of having
     * an error squiggle.
     */ DiagnosticTag.Unnecessary = 1;
                /**
     * Deprecated or obsolete code.
     *
     * Clients are allowed to rendered diagnostics with this tag strike through.
     */ DiagnosticTag.Deprecated = 2;
            })(DiagnosticTag || (DiagnosticTag = {}));
            /**
 * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.
 *
 * @since 3.16.0
 */ var CodeDescription;
            (function(CodeDescription) {
                function is(value) {
                    const candidate = value;
                    return Is.objectLiteral(candidate) && Is.string(candidate.href);
                }
                CodeDescription.is = is;
            })(CodeDescription || (CodeDescription = {}));
            /**
 * The Diagnostic namespace provides helper functions to work with
 * {@link Diagnostic} literals.
 */ var Diagnostic;
            (function(Diagnostic) {
                /**
     * Creates a new Diagnostic literal.
     */ function create(range, message, severity, code, source, relatedInformation) {
                    let result = {
                        range,
                        message
                    };
                    if (Is.defined(severity)) {
                        result.severity = severity;
                    }
                    if (Is.defined(code)) {
                        result.code = code;
                    }
                    if (Is.defined(source)) {
                        result.source = source;
                    }
                    if (Is.defined(relatedInformation)) {
                        result.relatedInformation = relatedInformation;
                    }
                    return result;
                }
                Diagnostic.create = create;
                /**
     * Checks whether the given literal conforms to the {@link Diagnostic} interface.
     */ function is(value) {
                    var _a;
                    let candidate = value;
                    return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
                }
                Diagnostic.is = is;
            })(Diagnostic || (Diagnostic = {}));
            /**
 * The Command namespace provides helper functions to work with
 * {@link Command} literals.
 */ var Command;
            (function(Command) {
                /**
     * Creates a new Command literal.
     */ function create(title, command, ...args) {
                    let result = {
                        title,
                        command
                    };
                    if (Is.defined(args) && args.length > 0) {
                        result.arguments = args;
                    }
                    return result;
                }
                Command.create = create;
                /**
     * Checks whether the given literal conforms to the {@link Command} interface.
     */ function is(value) {
                    let candidate = value;
                    return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
                }
                Command.is = is;
            })(Command || (Command = {}));
            /**
 * The TextEdit namespace provides helper function to create replace,
 * insert and delete edits more easily.
 */ var TextEdit;
            (function(TextEdit) {
                /**
     * Creates a replace text edit.
     * @param range The range of text to be replaced.
     * @param newText The new text.
     */ function replace(range, newText) {
                    return {
                        range,
                        newText
                    };
                }
                TextEdit.replace = replace;
                /**
     * Creates an insert text edit.
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     */ function insert(position, newText) {
                    return {
                        range: {
                            start: position,
                            end: position
                        },
                        newText
                    };
                }
                TextEdit.insert = insert;
                /**
     * Creates a delete text edit.
     * @param range The range of text to be deleted.
     */ function del(range) {
                    return {
                        range,
                        newText: ''
                    };
                }
                TextEdit.del = del;
                function is(value) {
                    const candidate = value;
                    return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);
                }
                TextEdit.is = is;
            })(TextEdit || (TextEdit = {}));
            var ChangeAnnotation;
            (function(ChangeAnnotation) {
                function create(label, needsConfirmation, description) {
                    const result = {
                        label
                    };
                    if (needsConfirmation !== undefined) {
                        result.needsConfirmation = needsConfirmation;
                    }
                    if (description !== undefined) {
                        result.description = description;
                    }
                    return result;
                }
                ChangeAnnotation.create = create;
                function is(value) {
                    const candidate = value;
                    return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) && (Is.string(candidate.description) || candidate.description === undefined);
                }
                ChangeAnnotation.is = is;
            })(ChangeAnnotation || (ChangeAnnotation = {}));
            var ChangeAnnotationIdentifier;
            (function(ChangeAnnotationIdentifier) {
                function is(value) {
                    const candidate = value;
                    return Is.string(candidate);
                }
                ChangeAnnotationIdentifier.is = is;
            })(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
            var AnnotatedTextEdit;
            (function(AnnotatedTextEdit) {
                /**
     * Creates an annotated replace text edit.
     *
     * @param range The range of text to be replaced.
     * @param newText The new text.
     * @param annotation The annotation.
     */ function replace(range, newText, annotation) {
                    return {
                        range,
                        newText,
                        annotationId: annotation
                    };
                }
                AnnotatedTextEdit.replace = replace;
                /**
     * Creates an annotated insert text edit.
     *
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     * @param annotation The annotation.
     */ function insert(position, newText, annotation) {
                    return {
                        range: {
                            start: position,
                            end: position
                        },
                        newText,
                        annotationId: annotation
                    };
                }
                AnnotatedTextEdit.insert = insert;
                /**
     * Creates an annotated delete text edit.
     *
     * @param range The range of text to be deleted.
     * @param annotation The annotation.
     */ function del(range, annotation) {
                    return {
                        range,
                        newText: '',
                        annotationId: annotation
                    };
                }
                AnnotatedTextEdit.del = del;
                function is(value) {
                    const candidate = value;
                    return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
                }
                AnnotatedTextEdit.is = is;
            })(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
            /**
 * The TextDocumentEdit namespace provides helper function to create
 * an edit that manipulates a text document.
 */ var TextDocumentEdit;
            (function(TextDocumentEdit) {
                /**
     * Creates a new `TextDocumentEdit`
     */ function create(textDocument, edits) {
                    return {
                        textDocument,
                        edits
                    };
                }
                TextDocumentEdit.create = create;
                function is(value) {
                    let candidate = value;
                    return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
                }
                TextDocumentEdit.is = is;
            })(TextDocumentEdit || (TextDocumentEdit = {}));
            var CreateFile;
            (function(CreateFile) {
                function create(uri, options, annotation) {
                    let result = {
                        kind: 'create',
                        uri
                    };
                    if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
                        result.options = options;
                    }
                    if (annotation !== undefined) {
                        result.annotationId = annotation;
                    }
                    return result;
                }
                CreateFile.create = create;
                function is(value) {
                    let candidate = value;
                    return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined || (candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
                }
                CreateFile.is = is;
            })(CreateFile || (CreateFile = {}));
            var RenameFile;
            (function(RenameFile) {
                function create(oldUri, newUri, options, annotation) {
                    let result = {
                        kind: 'rename',
                        oldUri,
                        newUri
                    };
                    if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
                        result.options = options;
                    }
                    if (annotation !== undefined) {
                        result.annotationId = annotation;
                    }
                    return result;
                }
                RenameFile.create = create;
                function is(value) {
                    let candidate = value;
                    return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined || (candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
                }
                RenameFile.is = is;
            })(RenameFile || (RenameFile = {}));
            var DeleteFile;
            (function(DeleteFile) {
                function create(uri, options, annotation) {
                    let result = {
                        kind: 'delete',
                        uri
                    };
                    if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {
                        result.options = options;
                    }
                    if (annotation !== undefined) {
                        result.annotationId = annotation;
                    }
                    return result;
                }
                DeleteFile.create = create;
                function is(value) {
                    let candidate = value;
                    return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined || (candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
                }
                DeleteFile.is = is;
            })(DeleteFile || (DeleteFile = {}));
            var WorkspaceEdit;
            (function(WorkspaceEdit) {
                function is(value) {
                    let candidate = value;
                    return candidate && (candidate.changes !== undefined || candidate.documentChanges !== undefined) && (candidate.documentChanges === undefined || candidate.documentChanges.every((change)=>{
                        if (Is.string(change.kind)) {
                            return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
                        } else {
                            return TextDocumentEdit.is(change);
                        }
                    }));
                }
                WorkspaceEdit.is = is;
            })(WorkspaceEdit || (WorkspaceEdit = {}));
            class TextEditChangeImpl {
                insert(position, newText, annotation) {
                    let edit1;
                    let id;
                    if (annotation === undefined) {
                        edit1 = TextEdit.insert(position, newText);
                    } else if (ChangeAnnotationIdentifier.is(annotation)) {
                        id = annotation;
                        edit1 = AnnotatedTextEdit.insert(position, newText, annotation);
                    } else {
                        this.assertChangeAnnotations(this.changeAnnotations);
                        id = this.changeAnnotations.manage(annotation);
                        edit1 = AnnotatedTextEdit.insert(position, newText, id);
                    }
                    this.edits.push(edit1);
                    if (id !== undefined) {
                        return id;
                    }
                }
                replace(range, newText, annotation) {
                    let edit1;
                    let id;
                    if (annotation === undefined) {
                        edit1 = TextEdit.replace(range, newText);
                    } else if (ChangeAnnotationIdentifier.is(annotation)) {
                        id = annotation;
                        edit1 = AnnotatedTextEdit.replace(range, newText, annotation);
                    } else {
                        this.assertChangeAnnotations(this.changeAnnotations);
                        id = this.changeAnnotations.manage(annotation);
                        edit1 = AnnotatedTextEdit.replace(range, newText, id);
                    }
                    this.edits.push(edit1);
                    if (id !== undefined) {
                        return id;
                    }
                }
                delete(range, annotation) {
                    let edit1;
                    let id;
                    if (annotation === undefined) {
                        edit1 = TextEdit.del(range);
                    } else if (ChangeAnnotationIdentifier.is(annotation)) {
                        id = annotation;
                        edit1 = AnnotatedTextEdit.del(range, annotation);
                    } else {
                        this.assertChangeAnnotations(this.changeAnnotations);
                        id = this.changeAnnotations.manage(annotation);
                        edit1 = AnnotatedTextEdit.del(range, id);
                    }
                    this.edits.push(edit1);
                    if (id !== undefined) {
                        return id;
                    }
                }
                add(edit1) {
                    this.edits.push(edit1);
                }
                all() {
                    return this.edits;
                }
                clear() {
                    this.edits.splice(0, this.edits.length);
                }
                assertChangeAnnotations(value) {
                    if (value === undefined) {
                        throw new Error(`Text edit change is not configured to manage change annotations.`);
                    }
                }
                constructor(edits, changeAnnotations){
                    this.edits = edits;
                    this.changeAnnotations = changeAnnotations;
                }
            }
            /**
 * A helper class
 */ class ChangeAnnotations {
                all() {
                    return this._annotations;
                }
                get size() {
                    return this._size;
                }
                manage(idOrAnnotation, annotation) {
                    let id;
                    if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
                        id = idOrAnnotation;
                    } else {
                        id = this.nextId();
                        annotation = idOrAnnotation;
                    }
                    if (this._annotations[id] !== undefined) {
                        throw new Error(`Id ${id} is already in use.`);
                    }
                    if (annotation === undefined) {
                        throw new Error(`No annotation provided for id ${id}`);
                    }
                    this._annotations[id] = annotation;
                    this._size++;
                    return id;
                }
                nextId() {
                    this._counter++;
                    return this._counter.toString();
                }
                constructor(annotations){
                    this._annotations = annotations === undefined ? Object.create(null) : annotations;
                    this._counter = 0;
                    this._size = 0;
                }
            }
            /**
 * A workspace change helps constructing changes to a workspace.
 */ class WorkspaceChange {
                /**
     * Returns the underlying {@link WorkspaceEdit} literal
     * use to be returned from a workspace edit operation like rename.
     */ get edit() {
                    this.initDocumentChanges();
                    if (this._changeAnnotations !== undefined) {
                        if (this._changeAnnotations.size === 0) {
                            this._workspaceEdit.changeAnnotations = undefined;
                        } else {
                            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                        }
                    }
                    return this._workspaceEdit;
                }
                getTextEditChange(key) {
                    if (OptionalVersionedTextDocumentIdentifier.is(key)) {
                        this.initDocumentChanges();
                        if (this._workspaceEdit.documentChanges === undefined) {
                            throw new Error('Workspace edit is not configured for document changes.');
                        }
                        const textDocument = {
                            uri: key.uri,
                            version: key.version
                        };
                        let result = this._textEditChanges[textDocument.uri];
                        if (!result) {
                            const edits = [];
                            const textDocumentEdit = {
                                textDocument,
                                edits
                            };
                            this._workspaceEdit.documentChanges.push(textDocumentEdit);
                            result = new TextEditChangeImpl(edits, this._changeAnnotations);
                            this._textEditChanges[textDocument.uri] = result;
                        }
                        return result;
                    } else {
                        this.initChanges();
                        if (this._workspaceEdit.changes === undefined) {
                            throw new Error('Workspace edit is not configured for normal text edit changes.');
                        }
                        let result = this._textEditChanges[key];
                        if (!result) {
                            let edits = [];
                            this._workspaceEdit.changes[key] = edits;
                            result = new TextEditChangeImpl(edits);
                            this._textEditChanges[key] = result;
                        }
                        return result;
                    }
                }
                initDocumentChanges() {
                    if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
                        this._changeAnnotations = new ChangeAnnotations();
                        this._workspaceEdit.documentChanges = [];
                        this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                    }
                }
                initChanges() {
                    if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
                        this._workspaceEdit.changes = Object.create(null);
                    }
                }
                createFile(uri, optionsOrAnnotation, options) {
                    this.initDocumentChanges();
                    if (this._workspaceEdit.documentChanges === undefined) {
                        throw new Error('Workspace edit is not configured for document changes.');
                    }
                    let annotation;
                    if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
                        annotation = optionsOrAnnotation;
                    } else {
                        options = optionsOrAnnotation;
                    }
                    let operation;
                    let id;
                    if (annotation === undefined) {
                        operation = CreateFile.create(uri, options);
                    } else {
                        id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                        operation = CreateFile.create(uri, options, id);
                    }
                    this._workspaceEdit.documentChanges.push(operation);
                    if (id !== undefined) {
                        return id;
                    }
                }
                renameFile(oldUri, newUri, optionsOrAnnotation, options) {
                    this.initDocumentChanges();
                    if (this._workspaceEdit.documentChanges === undefined) {
                        throw new Error('Workspace edit is not configured for document changes.');
                    }
                    let annotation;
                    if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
                        annotation = optionsOrAnnotation;
                    } else {
                        options = optionsOrAnnotation;
                    }
                    let operation;
                    let id;
                    if (annotation === undefined) {
                        operation = RenameFile.create(oldUri, newUri, options);
                    } else {
                        id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                        operation = RenameFile.create(oldUri, newUri, options, id);
                    }
                    this._workspaceEdit.documentChanges.push(operation);
                    if (id !== undefined) {
                        return id;
                    }
                }
                deleteFile(uri, optionsOrAnnotation, options) {
                    this.initDocumentChanges();
                    if (this._workspaceEdit.documentChanges === undefined) {
                        throw new Error('Workspace edit is not configured for document changes.');
                    }
                    let annotation;
                    if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
                        annotation = optionsOrAnnotation;
                    } else {
                        options = optionsOrAnnotation;
                    }
                    let operation;
                    let id;
                    if (annotation === undefined) {
                        operation = DeleteFile.create(uri, options);
                    } else {
                        id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                        operation = DeleteFile.create(uri, options, id);
                    }
                    this._workspaceEdit.documentChanges.push(operation);
                    if (id !== undefined) {
                        return id;
                    }
                }
                constructor(workspaceEdit){
                    this._textEditChanges = Object.create(null);
                    if (workspaceEdit !== undefined) {
                        this._workspaceEdit = workspaceEdit;
                        if (workspaceEdit.documentChanges) {
                            this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                            workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                            workspaceEdit.documentChanges.forEach((change)=>{
                                if (TextDocumentEdit.is(change)) {
                                    const textEditChange = new TextEditChangeImpl(change.edits, this._changeAnnotations);
                                    this._textEditChanges[change.textDocument.uri] = textEditChange;
                                }
                            });
                        } else if (workspaceEdit.changes) {
                            Object.keys(workspaceEdit.changes).forEach((key)=>{
                                const textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                                this._textEditChanges[key] = textEditChange;
                            });
                        }
                    } else {
                        this._workspaceEdit = {};
                    }
                }
            }
            /**
 * The TextDocumentIdentifier namespace provides helper functions to work with
 * {@link TextDocumentIdentifier} literals.
 */ var TextDocumentIdentifier;
            (function(TextDocumentIdentifier) {
                /**
     * Creates a new TextDocumentIdentifier literal.
     * @param uri The document's uri.
     */ function create(uri) {
                    return {
                        uri
                    };
                }
                TextDocumentIdentifier.create = create;
                /**
     * Checks whether the given literal conforms to the {@link TextDocumentIdentifier} interface.
     */ function is(value) {
                    let candidate = value;
                    return Is.defined(candidate) && Is.string(candidate.uri);
                }
                TextDocumentIdentifier.is = is;
            })(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
            /**
 * The VersionedTextDocumentIdentifier namespace provides helper functions to work with
 * {@link VersionedTextDocumentIdentifier} literals.
 */ var VersionedTextDocumentIdentifier;
            (function(VersionedTextDocumentIdentifier) {
                /**
     * Creates a new VersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */ function create(uri, version) {
                    return {
                        uri,
                        version
                    };
                }
                VersionedTextDocumentIdentifier.create = create;
                /**
     * Checks whether the given literal conforms to the {@link VersionedTextDocumentIdentifier} interface.
     */ function is(value) {
                    let candidate = value;
                    return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
                }
                VersionedTextDocumentIdentifier.is = is;
            })(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
            /**
 * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with
 * {@link OptionalVersionedTextDocumentIdentifier} literals.
 */ var OptionalVersionedTextDocumentIdentifier;
            (function(OptionalVersionedTextDocumentIdentifier) {
                /**
     * Creates a new OptionalVersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */ function create(uri, version) {
                    return {
                        uri,
                        version
                    };
                }
                OptionalVersionedTextDocumentIdentifier.create = create;
                /**
     * Checks whether the given literal conforms to the {@link OptionalVersionedTextDocumentIdentifier} interface.
     */ function is(value) {
                    let candidate = value;
                    return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
                }
                OptionalVersionedTextDocumentIdentifier.is = is;
            })(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
            /**
 * The TextDocumentItem namespace provides helper functions to work with
 * {@link TextDocumentItem} literals.
 */ var TextDocumentItem;
            (function(TextDocumentItem) {
                /**
     * Creates a new TextDocumentItem literal.
     * @param uri The document's uri.
     * @param languageId The document's language identifier.
     * @param version The document's version number.
     * @param text The document's text.
     */ function create(uri, languageId, version, text) {
                    return {
                        uri,
                        languageId,
                        version,
                        text
                    };
                }
                TextDocumentItem.create = create;
                /**
     * Checks whether the given literal conforms to the {@link TextDocumentItem} interface.
     */ function is(value) {
                    let candidate = value;
                    return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
                }
                TextDocumentItem.is = is;
            })(TextDocumentItem || (TextDocumentItem = {}));
            /**
 * Describes the content type that a client supports in various
 * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
 *
 * Please note that `MarkupKinds` must not start with a `$`. This kinds
 * are reserved for internal usage.
 */ var MarkupKind;
            (function(MarkupKind) {
                /**
     * Plain text is supported as a content format
     */ MarkupKind.PlainText = 'plaintext';
                /**
     * Markdown is supported as a content format
     */ MarkupKind.Markdown = 'markdown';
                /**
     * Checks whether the given value is a value of the {@link MarkupKind} type.
     */ function is(value) {
                    const candidate = value;
                    return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;
                }
                MarkupKind.is = is;
            })(MarkupKind || (MarkupKind = {}));
            var main_MarkupContent;
            (function(MarkupContent1) {
                /**
     * Checks whether the given value conforms to the {@link MarkupContent} interface.
     */ function is(value) {
                    const candidate = value;
                    return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
                }
                MarkupContent1.is = is;
            })(main_MarkupContent || (main_MarkupContent = {}));
            /**
 * The kind of a completion entry.
 */ var main_CompletionItemKind;
            (function(CompletionItemKind1) {
                CompletionItemKind1.Text = 1;
                CompletionItemKind1.Method = 2;
                CompletionItemKind1.Function = 3;
                CompletionItemKind1.Constructor = 4;
                CompletionItemKind1.Field = 5;
                CompletionItemKind1.Variable = 6;
                CompletionItemKind1.Class = 7;
                CompletionItemKind1.Interface = 8;
                CompletionItemKind1.Module = 9;
                CompletionItemKind1.Property = 10;
                CompletionItemKind1.Unit = 11;
                CompletionItemKind1.Value = 12;
                CompletionItemKind1.Enum = 13;
                CompletionItemKind1.Keyword = 14;
                CompletionItemKind1.Snippet = 15;
                CompletionItemKind1.Color = 16;
                CompletionItemKind1.File = 17;
                CompletionItemKind1.Reference = 18;
                CompletionItemKind1.Folder = 19;
                CompletionItemKind1.EnumMember = 20;
                CompletionItemKind1.Constant = 21;
                CompletionItemKind1.Struct = 22;
                CompletionItemKind1.Event = 23;
                CompletionItemKind1.Operator = 24;
                CompletionItemKind1.TypeParameter = 25;
            })(main_CompletionItemKind || (main_CompletionItemKind = {}));
            /**
 * Defines whether the insert text in a completion item should be interpreted as
 * plain text or a snippet.
 */ var main_InsertTextFormat;
            (function(InsertTextFormat1) {
                /**
     * The primary text to be inserted is treated as a plain string.
     */ InsertTextFormat1.PlainText = 1;
                /**
     * The primary text to be inserted is treated as a snippet.
     *
     * A snippet can define tab stops and placeholders with `$1`, `$2`
     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
     * the end of the snippet. Placeholders with equal identifiers are linked,
     * that is typing in one will update others too.
     *
     * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax
     */ InsertTextFormat1.Snippet = 2;
            })(main_InsertTextFormat || (main_InsertTextFormat = {}));
            /**
 * Completion item tags are extra annotations that tweak the rendering of a completion
 * item.
 *
 * @since 3.15.0
 */ var CompletionItemTag;
            (function(CompletionItemTag) {
                /**
     * Render a completion as obsolete, usually using a strike-out.
     */ CompletionItemTag.Deprecated = 1;
            })(CompletionItemTag || (CompletionItemTag = {}));
            /**
 * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.
 *
 * @since 3.16.0
 */ var InsertReplaceEdit;
            (function(InsertReplaceEdit) {
                /**
     * Creates a new insert / replace edit
     */ function create(newText, insert, replace) {
                    return {
                        newText,
                        insert,
                        replace
                    };
                }
                InsertReplaceEdit.create = create;
                /**
     * Checks whether the given literal conforms to the {@link InsertReplaceEdit} interface.
     */ function is(value) {
                    const candidate = value;
                    return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
                }
                InsertReplaceEdit.is = is;
            })(InsertReplaceEdit || (InsertReplaceEdit = {}));
            /**
 * How whitespace and indentation is handled during completion
 * item insertion.
 *
 * @since 3.16.0
 */ var InsertTextMode;
            (function(InsertTextMode) {
                /**
     * The insertion or replace strings is taken as it is. If the
     * value is multi line the lines below the cursor will be
     * inserted using the indentation defined in the string value.
     * The client will not apply any kind of adjustments to the
     * string.
     */ InsertTextMode.asIs = 1;
                /**
     * The editor adjusts leading whitespace of new lines so that
     * they match the indentation up to the cursor of the line for
     * which the item is accepted.
     *
     * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a
     * multi line completion item is indented using 2 tabs and all
     * following lines inserted will be indented using 2 tabs as well.
     */ InsertTextMode.adjustIndentation = 2;
            })(InsertTextMode || (InsertTextMode = {}));
            var CompletionItemLabelDetails;
            (function(CompletionItemLabelDetails) {
                function is(value) {
                    const candidate = value;
                    return candidate && (Is.string(candidate.detail) || candidate.detail === undefined) && (Is.string(candidate.description) || candidate.description === undefined);
                }
                CompletionItemLabelDetails.is = is;
            })(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));
            /**
 * The CompletionItem namespace provides functions to deal with
 * completion items.
 */ var CompletionItem;
            (function(CompletionItem) {
                /**
     * Create a completion item and seed it with a label.
     * @param label The completion item's label
     */ function create(label) {
                    return {
                        label
                    };
                }
                CompletionItem.create = create;
            })(CompletionItem || (CompletionItem = {}));
            /**
 * The CompletionList namespace provides functions to deal with
 * completion lists.
 */ var CompletionList;
            (function(CompletionList) {
                /**
     * Creates a new completion list.
     *
     * @param items The completion items.
     * @param isIncomplete The list is not complete.
     */ function create(items, isIncomplete) {
                    return {
                        items: items ? items : [],
                        isIncomplete: !!isIncomplete
                    };
                }
                CompletionList.create = create;
            })(CompletionList || (CompletionList = {}));
            var main_MarkedString;
            (function(MarkedString1) {
                /**
     * Creates a marked string from plain text.
     *
     * @param plainText The plain text.
     */ function fromPlainText(plainText) {
                    return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
                }
                MarkedString1.fromPlainText = fromPlainText;
                /**
     * Checks whether the given value conforms to the {@link MarkedString} type.
     */ function is(value) {
                    const candidate = value;
                    return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
                }
                MarkedString1.is = is;
            })(main_MarkedString || (main_MarkedString = {}));
            var Hover;
            (function(Hover) {
                /**
     * Checks whether the given value conforms to the {@link Hover} interface.
     */ function is(value) {
                    let candidate = value;
                    return !!candidate && Is.objectLiteral(candidate) && (main_MarkupContent.is(candidate.contents) || main_MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, main_MarkedString.is)) && (value.range === undefined || Range.is(value.range));
                }
                Hover.is = is;
            })(Hover || (Hover = {}));
            /**
 * The ParameterInformation namespace provides helper functions to work with
 * {@link ParameterInformation} literals.
 */ var ParameterInformation;
            (function(ParameterInformation) {
                /**
     * Creates a new parameter information literal.
     *
     * @param label A label string.
     * @param documentation A doc string.
     */ function create(label, documentation) {
                    return documentation ? {
                        label,
                        documentation
                    } : {
                        label
                    };
                }
                ParameterInformation.create = create;
            })(ParameterInformation || (ParameterInformation = {}));
            /**
 * The SignatureInformation namespace provides helper functions to work with
 * {@link SignatureInformation} literals.
 */ var SignatureInformation;
            (function(SignatureInformation) {
                function create(label, documentation, ...parameters) {
                    let result = {
                        label
                    };
                    if (Is.defined(documentation)) {
                        result.documentation = documentation;
                    }
                    if (Is.defined(parameters)) {
                        result.parameters = parameters;
                    } else {
                        result.parameters = [];
                    }
                    return result;
                }
                SignatureInformation.create = create;
            })(SignatureInformation || (SignatureInformation = {}));
            /**
 * A document highlight kind.
 */ var DocumentHighlightKind;
            (function(DocumentHighlightKind) {
                /**
     * A textual occurrence.
     */ DocumentHighlightKind.Text = 1;
                /**
     * Read-access of a symbol, like reading a variable.
     */ DocumentHighlightKind.Read = 2;
                /**
     * Write-access of a symbol, like writing to a variable.
     */ DocumentHighlightKind.Write = 3;
            })(DocumentHighlightKind || (DocumentHighlightKind = {}));
            /**
 * DocumentHighlight namespace to provide helper functions to work with
 * {@link DocumentHighlight} literals.
 */ var DocumentHighlight;
            (function(DocumentHighlight) {
                /**
     * Create a DocumentHighlight object.
     * @param range The range the highlight applies to.
     * @param kind The highlight kind
     */ function create(range, kind) {
                    let result = {
                        range
                    };
                    if (Is.number(kind)) {
                        result.kind = kind;
                    }
                    return result;
                }
                DocumentHighlight.create = create;
            })(DocumentHighlight || (DocumentHighlight = {}));
            /**
 * A symbol kind.
 */ var SymbolKind;
            (function(SymbolKind) {
                SymbolKind.File = 1;
                SymbolKind.Module = 2;
                SymbolKind.Namespace = 3;
                SymbolKind.Package = 4;
                SymbolKind.Class = 5;
                SymbolKind.Method = 6;
                SymbolKind.Property = 7;
                SymbolKind.Field = 8;
                SymbolKind.Constructor = 9;
                SymbolKind.Enum = 10;
                SymbolKind.Interface = 11;
                SymbolKind.Function = 12;
                SymbolKind.Variable = 13;
                SymbolKind.Constant = 14;
                SymbolKind.String = 15;
                SymbolKind.Number = 16;
                SymbolKind.Boolean = 17;
                SymbolKind.Array = 18;
                SymbolKind.Object = 19;
                SymbolKind.Key = 20;
                SymbolKind.Null = 21;
                SymbolKind.EnumMember = 22;
                SymbolKind.Struct = 23;
                SymbolKind.Event = 24;
                SymbolKind.Operator = 25;
                SymbolKind.TypeParameter = 26;
            })(SymbolKind || (SymbolKind = {}));
            /**
 * Symbol tags are extra annotations that tweak the rendering of a symbol.
 *
 * @since 3.16
 */ var SymbolTag;
            (function(SymbolTag) {
                /**
     * Render a symbol as obsolete, usually using a strike-out.
     */ SymbolTag.Deprecated = 1;
            })(SymbolTag || (SymbolTag = {}));
            var SymbolInformation;
            (function(SymbolInformation) {
                /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the location of the symbol.
     * @param uri The resource of the location of symbol.
     * @param containerName The name of the symbol containing the symbol.
     */ function create(name, kind, range, uri, containerName) {
                    let result = {
                        name,
                        kind,
                        location: {
                            uri,
                            range
                        }
                    };
                    if (containerName) {
                        result.containerName = containerName;
                    }
                    return result;
                }
                SymbolInformation.create = create;
            })(SymbolInformation || (SymbolInformation = {}));
            var WorkspaceSymbol;
            (function(WorkspaceSymbol) {
                /**
     * Create a new workspace symbol.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param uri The resource of the location of the symbol.
     * @param range An options range of the location.
     * @returns A WorkspaceSymbol.
     */ function create(name, kind, uri, range) {
                    return range !== undefined ? {
                        name,
                        kind,
                        location: {
                            uri,
                            range
                        }
                    } : {
                        name,
                        kind,
                        location: {
                            uri
                        }
                    };
                }
                WorkspaceSymbol.create = create;
            })(WorkspaceSymbol || (WorkspaceSymbol = {}));
            var DocumentSymbol;
            (function(DocumentSymbol) {
                /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param detail The detail of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the symbol.
     * @param selectionRange The selectionRange of the symbol.
     * @param children Children of the symbol.
     */ function create(name, detail, kind, range, selectionRange, children) {
                    let result = {
                        name,
                        detail,
                        kind,
                        range,
                        selectionRange
                    };
                    if (children !== undefined) {
                        result.children = children;
                    }
                    return result;
                }
                DocumentSymbol.create = create;
                /**
     * Checks whether the given literal conforms to the {@link DocumentSymbol} interface.
     */ function is(value) {
                    let candidate = value;
                    return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === undefined || Is.string(candidate.detail)) && (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) && (candidate.children === undefined || Array.isArray(candidate.children)) && (candidate.tags === undefined || Array.isArray(candidate.tags));
                }
                DocumentSymbol.is = is;
            })(DocumentSymbol || (DocumentSymbol = {}));
            /**
 * A set of predefined code action kinds
 */ var CodeActionKind;
            (function(CodeActionKind) {
                /**
     * Empty kind.
     */ CodeActionKind.Empty = '';
                /**
     * Base kind for quickfix actions: 'quickfix'
     */ CodeActionKind.QuickFix = 'quickfix';
                /**
     * Base kind for refactoring actions: 'refactor'
     */ CodeActionKind.Refactor = 'refactor';
                /**
     * Base kind for refactoring extraction actions: 'refactor.extract'
     *
     * Example extract actions:
     *
     * - Extract method
     * - Extract function
     * - Extract variable
     * - Extract interface from class
     * - ...
     */ CodeActionKind.RefactorExtract = 'refactor.extract';
                /**
     * Base kind for refactoring inline actions: 'refactor.inline'
     *
     * Example inline actions:
     *
     * - Inline function
     * - Inline variable
     * - Inline constant
     * - ...
     */ CodeActionKind.RefactorInline = 'refactor.inline';
                /**
     * Base kind for refactoring rewrite actions: 'refactor.rewrite'
     *
     * Example rewrite actions:
     *
     * - Convert JavaScript function to class
     * - Add or remove parameter
     * - Encapsulate field
     * - Make method static
     * - Move method to base class
     * - ...
     */ CodeActionKind.RefactorRewrite = 'refactor.rewrite';
                /**
     * Base kind for source actions: `source`
     *
     * Source code actions apply to the entire file.
     */ CodeActionKind.Source = 'source';
                /**
     * Base kind for an organize imports source action: `source.organizeImports`
     */ CodeActionKind.SourceOrganizeImports = 'source.organizeImports';
                /**
     * Base kind for auto-fix source actions: `source.fixAll`.
     *
     * Fix all actions automatically fix errors that have a clear fix that do not require user input.
     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.
     *
     * @since 3.15.0
     */ CodeActionKind.SourceFixAll = 'source.fixAll';
            })(CodeActionKind || (CodeActionKind = {}));
            /**
 * The reason why code actions were requested.
 *
 * @since 3.17.0
 */ var CodeActionTriggerKind;
            (function(CodeActionTriggerKind) {
                /**
     * Code actions were explicitly requested by the user or by an extension.
     */ CodeActionTriggerKind.Invoked = 1;
                /**
     * Code actions were requested automatically.
     *
     * This typically happens when current selection in a file changes, but can
     * also be triggered when file content changes.
     */ CodeActionTriggerKind.Automatic = 2;
            })(CodeActionTriggerKind || (CodeActionTriggerKind = {}));
            /**
 * The CodeActionContext namespace provides helper functions to work with
 * {@link CodeActionContext} literals.
 */ var CodeActionContext;
            (function(CodeActionContext) {
                /**
     * Creates a new CodeActionContext literal.
     */ function create(diagnostics, only, triggerKind) {
                    let result = {
                        diagnostics
                    };
                    if (only !== undefined && only !== null) {
                        result.only = only;
                    }
                    if (triggerKind !== undefined && triggerKind !== null) {
                        result.triggerKind = triggerKind;
                    }
                    return result;
                }
                CodeActionContext.create = create;
                /**
     * Checks whether the given literal conforms to the {@link CodeActionContext} interface.
     */ function is(value) {
                    let candidate = value;
                    return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
                }
                CodeActionContext.is = is;
            })(CodeActionContext || (CodeActionContext = {}));
            var CodeAction;
            (function(CodeAction) {
                function create(title, kindOrCommandOrEdit, kind) {
                    let result = {
                        title
                    };
                    let checkKind = true;
                    if (typeof kindOrCommandOrEdit === 'string') {
                        checkKind = false;
                        result.kind = kindOrCommandOrEdit;
                    } else if (Command.is(kindOrCommandOrEdit)) {
                        result.command = kindOrCommandOrEdit;
                    } else {
                        result.edit = kindOrCommandOrEdit;
                    }
                    if (checkKind && kind !== undefined) {
                        result.kind = kind;
                    }
                    return result;
                }
                CodeAction.create = create;
                function is(value) {
                    let candidate = value;
                    return candidate && Is.string(candidate.title) && (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === undefined || Is.string(candidate.kind)) && (candidate.edit !== undefined || candidate.command !== undefined) && (candidate.command === undefined || Command.is(candidate.command)) && (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) && (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));
                }
                CodeAction.is = is;
            })(CodeAction || (CodeAction = {}));
            /**
 * The CodeLens namespace provides helper functions to work with
 * {@link CodeLens} literals.
 */ var CodeLens;
            (function(CodeLens) {
                /**
     * Creates a new CodeLens literal.
     */ function create(range, data) {
                    let result = {
                        range
                    };
                    if (Is.defined(data)) {
                        result.data = data;
                    }
                    return result;
                }
                CodeLens.create = create;
                /**
     * Checks whether the given literal conforms to the {@link CodeLens} interface.
     */ function is(value) {
                    let candidate = value;
                    return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
                }
                CodeLens.is = is;
            })(CodeLens || (CodeLens = {}));
            /**
 * The FormattingOptions namespace provides helper functions to work with
 * {@link FormattingOptions} literals.
 */ var FormattingOptions;
            (function(FormattingOptions) {
                /**
     * Creates a new FormattingOptions literal.
     */ function create(tabSize, insertSpaces) {
                    return {
                        tabSize,
                        insertSpaces
                    };
                }
                FormattingOptions.create = create;
                /**
     * Checks whether the given literal conforms to the {@link FormattingOptions} interface.
     */ function is(value) {
                    let candidate = value;
                    return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
                }
                FormattingOptions.is = is;
            })(FormattingOptions || (FormattingOptions = {}));
            /**
 * The DocumentLink namespace provides helper functions to work with
 * {@link DocumentLink} literals.
 */ var DocumentLink;
            (function(DocumentLink) {
                /**
     * Creates a new DocumentLink literal.
     */ function create(range, target, data) {
                    return {
                        range,
                        target,
                        data
                    };
                }
                DocumentLink.create = create;
                /**
     * Checks whether the given literal conforms to the {@link DocumentLink} interface.
     */ function is(value) {
                    let candidate = value;
                    return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
                }
                DocumentLink.is = is;
            })(DocumentLink || (DocumentLink = {}));
            /**
 * The SelectionRange namespace provides helper function to work with
 * SelectionRange literals.
 */ var SelectionRange;
            (function(SelectionRange) {
                /**
     * Creates a new SelectionRange
     * @param range the range.
     * @param parent an optional parent.
     */ function create(range, parent) {
                    return {
                        range,
                        parent
                    };
                }
                SelectionRange.create = create;
                function is(value) {
                    let candidate = value;
                    return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));
                }
                SelectionRange.is = is;
            })(SelectionRange || (SelectionRange = {}));
            /**
 * A set of predefined token types. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */ var SemanticTokenTypes;
            (function(SemanticTokenTypes) {
                SemanticTokenTypes["namespace"] = "namespace";
                /**
     * Represents a generic type. Acts as a fallback for types which can't be mapped to
     * a specific type like class or enum.
     */ SemanticTokenTypes["type"] = "type";
                SemanticTokenTypes["class"] = "class";
                SemanticTokenTypes["enum"] = "enum";
                SemanticTokenTypes["interface"] = "interface";
                SemanticTokenTypes["struct"] = "struct";
                SemanticTokenTypes["typeParameter"] = "typeParameter";
                SemanticTokenTypes["parameter"] = "parameter";
                SemanticTokenTypes["variable"] = "variable";
                SemanticTokenTypes["property"] = "property";
                SemanticTokenTypes["enumMember"] = "enumMember";
                SemanticTokenTypes["event"] = "event";
                SemanticTokenTypes["function"] = "function";
                SemanticTokenTypes["method"] = "method";
                SemanticTokenTypes["macro"] = "macro";
                SemanticTokenTypes["keyword"] = "keyword";
                SemanticTokenTypes["modifier"] = "modifier";
                SemanticTokenTypes["comment"] = "comment";
                SemanticTokenTypes["string"] = "string";
                SemanticTokenTypes["number"] = "number";
                SemanticTokenTypes["regexp"] = "regexp";
                SemanticTokenTypes["operator"] = "operator";
                /**
     * @since 3.17.0
     */ SemanticTokenTypes["decorator"] = "decorator";
            })(SemanticTokenTypes || (SemanticTokenTypes = {}));
            /**
 * A set of predefined token modifiers. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */ var SemanticTokenModifiers;
            (function(SemanticTokenModifiers) {
                SemanticTokenModifiers["declaration"] = "declaration";
                SemanticTokenModifiers["definition"] = "definition";
                SemanticTokenModifiers["readonly"] = "readonly";
                SemanticTokenModifiers["static"] = "static";
                SemanticTokenModifiers["deprecated"] = "deprecated";
                SemanticTokenModifiers["abstract"] = "abstract";
                SemanticTokenModifiers["async"] = "async";
                SemanticTokenModifiers["modification"] = "modification";
                SemanticTokenModifiers["documentation"] = "documentation";
                SemanticTokenModifiers["defaultLibrary"] = "defaultLibrary";
            })(SemanticTokenModifiers || (SemanticTokenModifiers = {}));
            /**
 * @since 3.16.0
 */ var SemanticTokens;
            (function(SemanticTokens) {
                function is(value) {
                    const candidate = value;
                    return Is.objectLiteral(candidate) && (candidate.resultId === undefined || typeof candidate.resultId === 'string') && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');
                }
                SemanticTokens.is = is;
            })(SemanticTokens || (SemanticTokens = {}));
            /**
 * The InlineValueText namespace provides functions to deal with InlineValueTexts.
 *
 * @since 3.17.0
 */ var InlineValueText;
            (function(InlineValueText) {
                /**
     * Creates a new InlineValueText literal.
     */ function create(range, text) {
                    return {
                        range,
                        text
                    };
                }
                InlineValueText.create = create;
                function is(value) {
                    const candidate = value;
                    return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
                }
                InlineValueText.is = is;
            })(InlineValueText || (InlineValueText = {}));
            /**
 * The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.
 *
 * @since 3.17.0
 */ var InlineValueVariableLookup;
            (function(InlineValueVariableLookup) {
                /**
     * Creates a new InlineValueText literal.
     */ function create(range, variableName, caseSensitiveLookup) {
                    return {
                        range,
                        variableName,
                        caseSensitiveLookup
                    };
                }
                InlineValueVariableLookup.create = create;
                function is(value) {
                    const candidate = value;
                    return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === undefined);
                }
                InlineValueVariableLookup.is = is;
            })(InlineValueVariableLookup || (InlineValueVariableLookup = {}));
            /**
 * The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.
 *
 * @since 3.17.0
 */ var InlineValueEvaluatableExpression;
            (function(InlineValueEvaluatableExpression) {
                /**
     * Creates a new InlineValueEvaluatableExpression literal.
     */ function create(range, expression) {
                    return {
                        range,
                        expression
                    };
                }
                InlineValueEvaluatableExpression.create = create;
                function is(value) {
                    const candidate = value;
                    return candidate !== undefined && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === undefined);
                }
                InlineValueEvaluatableExpression.is = is;
            })(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));
            /**
 * The InlineValueContext namespace provides helper functions to work with
 * {@link InlineValueContext} literals.
 *
 * @since 3.17.0
 */ var InlineValueContext;
            (function(InlineValueContext) {
                /**
     * Creates a new InlineValueContext literal.
     */ function create(frameId, stoppedLocation) {
                    return {
                        frameId,
                        stoppedLocation
                    };
                }
                InlineValueContext.create = create;
                /**
     * Checks whether the given literal conforms to the {@link InlineValueContext} interface.
     */ function is(value) {
                    const candidate = value;
                    return Is.defined(candidate) && Range.is(value.stoppedLocation);
                }
                InlineValueContext.is = is;
            })(InlineValueContext || (InlineValueContext = {}));
            /**
 * Inlay hint kinds.
 *
 * @since 3.17.0
 */ var InlayHintKind;
            (function(InlayHintKind) {
                /**
     * An inlay hint that for a type annotation.
     */ InlayHintKind.Type = 1;
                /**
     * An inlay hint that is for a parameter.
     */ InlayHintKind.Parameter = 2;
                function is(value) {
                    return value === 1 || value === 2;
                }
                InlayHintKind.is = is;
            })(InlayHintKind || (InlayHintKind = {}));
            var InlayHintLabelPart;
            (function(InlayHintLabelPart) {
                function create(value) {
                    return {
                        value
                    };
                }
                InlayHintLabelPart.create = create;
                function is(value) {
                    const candidate = value;
                    return Is.objectLiteral(candidate) && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || main_MarkupContent.is(candidate.tooltip)) && (candidate.location === undefined || Location.is(candidate.location)) && (candidate.command === undefined || Command.is(candidate.command));
                }
                InlayHintLabelPart.is = is;
            })(InlayHintLabelPart || (InlayHintLabelPart = {}));
            var InlayHint;
            (function(InlayHint) {
                function create(position, label, kind) {
                    const result = {
                        position,
                        label
                    };
                    if (kind !== undefined) {
                        result.kind = kind;
                    }
                    return result;
                }
                InlayHint.create = create;
                function is(value) {
                    const candidate = value;
                    return Is.objectLiteral(candidate) && Position.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === undefined || InlayHintKind.is(candidate.kind)) && candidate.textEdits === undefined || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || main_MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === undefined || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === undefined || Is.boolean(candidate.paddingRight));
                }
                InlayHint.is = is;
            })(InlayHint || (InlayHint = {}));
            var StringValue;
            (function(StringValue) {
                function createSnippet(value) {
                    return {
                        kind: 'snippet',
                        value
                    };
                }
                StringValue.createSnippet = createSnippet;
            })(StringValue || (StringValue = {}));
            var InlineCompletionItem;
            (function(InlineCompletionItem) {
                function create(insertText, filterText, range, command) {
                    return {
                        insertText,
                        filterText,
                        range,
                        command
                    };
                }
                InlineCompletionItem.create = create;
            })(InlineCompletionItem || (InlineCompletionItem = {}));
            var InlineCompletionList;
            (function(InlineCompletionList) {
                function create(items) {
                    return {
                        items
                    };
                }
                InlineCompletionList.create = create;
            })(InlineCompletionList || (InlineCompletionList = {}));
            /**
 * Describes how an {@link InlineCompletionItemProvider inline completion provider} was triggered.
 *
 * @since 3.18.0
 * @proposed
 */ var InlineCompletionTriggerKind;
            (function(InlineCompletionTriggerKind) {
                /**
     * Completion was triggered explicitly by a user gesture.
     */ InlineCompletionTriggerKind.Invoked = 0;
                /**
     * Completion was triggered automatically while editing.
     */ InlineCompletionTriggerKind.Automatic = 1;
            })(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));
            var SelectedCompletionInfo;
            (function(SelectedCompletionInfo) {
                function create(range, text) {
                    return {
                        range,
                        text
                    };
                }
                SelectedCompletionInfo.create = create;
            })(SelectedCompletionInfo || (SelectedCompletionInfo = {}));
            var InlineCompletionContext;
            (function(InlineCompletionContext) {
                function create(triggerKind, selectedCompletionInfo) {
                    return {
                        triggerKind,
                        selectedCompletionInfo
                    };
                }
                InlineCompletionContext.create = create;
            })(InlineCompletionContext || (InlineCompletionContext = {}));
            var WorkspaceFolder;
            (function(WorkspaceFolder) {
                function is(value) {
                    const candidate = value;
                    return Is.objectLiteral(candidate) && json_service_URI.is(candidate.uri) && Is.string(candidate.name);
                }
                WorkspaceFolder.is = is;
            })(WorkspaceFolder || (WorkspaceFolder = {}));
            const EOL = /* unused pure expression or super */ null && 0;
            /**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */ var TextDocument;
            (function(TextDocument) {
                /**
     * Creates a new ITextDocument literal from the given uri and content.
     * @param uri The document's uri.
     * @param languageId The document's language Id.
     * @param version The document's version.
     * @param content The document's content.
     */ function create(uri, languageId, version, content) {
                    return new FullTextDocument(uri, languageId, version, content);
                }
                TextDocument.create = create;
                /**
     * Checks whether the given literal conforms to the {@link ITextDocument} interface.
     */ function is(value) {
                    let candidate = value;
                    return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
                }
                TextDocument.is = is;
                function applyEdits(document1, edits) {
                    let text = document1.getText();
                    let sortedEdits = mergeSort(edits, (a, b)=>{
                        let diff = a.range.start.line - b.range.start.line;
                        if (diff === 0) {
                            return a.range.start.character - b.range.start.character;
                        }
                        return diff;
                    });
                    let lastModifiedOffset = text.length;
                    for(let i = sortedEdits.length - 1; i >= 0; i--){
                        let e = sortedEdits[i];
                        let startOffset = document1.offsetAt(e.range.start);
                        let endOffset = document1.offsetAt(e.range.end);
                        if (endOffset <= lastModifiedOffset) {
                            text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
                        } else {
                            throw new Error('Overlapping edit');
                        }
                        lastModifiedOffset = startOffset;
                    }
                    return text;
                }
                TextDocument.applyEdits = applyEdits;
                function mergeSort(data, compare) {
                    if (data.length <= 1) {
                        // sorted
                        return data;
                    }
                    const p = data.length / 2 | 0;
                    const left = data.slice(0, p);
                    const right = data.slice(p);
                    mergeSort(left, compare);
                    mergeSort(right, compare);
                    let leftIdx = 0;
                    let rightIdx = 0;
                    let i = 0;
                    while(leftIdx < left.length && rightIdx < right.length){
                        let ret = compare(left[leftIdx], right[rightIdx]);
                        if (ret <= 0) {
                            // smaller_equal -> take left to preserve order
                            data[i++] = left[leftIdx++];
                        } else {
                            // greater -> take right
                            data[i++] = right[rightIdx++];
                        }
                    }
                    while(leftIdx < left.length){
                        data[i++] = left[leftIdx++];
                    }
                    while(rightIdx < right.length){
                        data[i++] = right[rightIdx++];
                    }
                    return data;
                }
            })(TextDocument || (TextDocument = {}));
            /**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */ class FullTextDocument {
                get uri() {
                    return this._uri;
                }
                get languageId() {
                    return this._languageId;
                }
                get version() {
                    return this._version;
                }
                getText(range) {
                    if (range) {
                        let start = this.offsetAt(range.start);
                        let end = this.offsetAt(range.end);
                        return this._content.substring(start, end);
                    }
                    return this._content;
                }
                update(event, version) {
                    this._content = event.text;
                    this._version = version;
                    this._lineOffsets = undefined;
                }
                getLineOffsets() {
                    if (this._lineOffsets === undefined) {
                        let lineOffsets = [];
                        let text = this._content;
                        let isLineStart = true;
                        for(let i = 0; i < text.length; i++){
                            if (isLineStart) {
                                lineOffsets.push(i);
                                isLineStart = false;
                            }
                            let ch = text.charAt(i);
                            isLineStart = ch === '\r' || ch === '\n';
                            if (ch === '\r' && i + 1 < text.length && text.charAt(i + 1) === '\n') {
                                i++;
                            }
                        }
                        if (isLineStart && text.length > 0) {
                            lineOffsets.push(text.length);
                        }
                        this._lineOffsets = lineOffsets;
                    }
                    return this._lineOffsets;
                }
                positionAt(offset) {
                    offset = Math.max(Math.min(offset, this._content.length), 0);
                    let lineOffsets = this.getLineOffsets();
                    let low = 0, high = lineOffsets.length;
                    if (high === 0) {
                        return Position.create(0, offset);
                    }
                    while(low < high){
                        let mid = Math.floor((low + high) / 2);
                        if (lineOffsets[mid] > offset) {
                            high = mid;
                        } else {
                            low = mid + 1;
                        }
                    }
                    // low is the least x for which the line offset is larger than the current offset
                    // or array.length if no line offset is larger than the current offset
                    let line = low - 1;
                    return Position.create(line, offset - lineOffsets[line]);
                }
                offsetAt(position) {
                    let lineOffsets = this.getLineOffsets();
                    if (position.line >= lineOffsets.length) {
                        return this._content.length;
                    } else if (position.line < 0) {
                        return 0;
                    }
                    let lineOffset = lineOffsets[position.line];
                    let nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
                    return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
                }
                get lineCount() {
                    return this.getLineOffsets().length;
                }
                constructor(uri, languageId, version, content){
                    this._uri = uri;
                    this._languageId = languageId;
                    this._version = version;
                    this._content = content;
                    this._lineOffsets = undefined;
                }
            }
            var Is;
            (function(Is) {
                const toString = Object.prototype.toString;
                function defined(value) {
                    return typeof value !== 'undefined';
                }
                Is.defined = defined;
                function undefined1(value) {
                    return typeof value === 'undefined';
                }
                Is.undefined = undefined1;
                function boolean(value) {
                    return value === true || value === false;
                }
                Is.boolean = boolean;
                function string(value) {
                    return toString.call(value) === '[object String]';
                }
                Is.string = string;
                function number(value) {
                    return toString.call(value) === '[object Number]';
                }
                Is.number = number;
                function numberRange(value, min, max) {
                    return toString.call(value) === '[object Number]' && min <= value && value <= max;
                }
                Is.numberRange = numberRange;
                function integer(value) {
                    return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;
                }
                Is.integer = integer;
                function uinteger(value) {
                    return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;
                }
                Is.uinteger = uinteger;
                function func(value) {
                    return toString.call(value) === '[object Function]';
                }
                Is.func = func;
                function objectLiteral(value) {
                    // Strictly speaking class instances pass this check as well. Since the LSP
                    // doesn't use classes we ignore this for now. If we do we need to add something
                    // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
                    return value !== null && typeof value === 'object';
                }
                Is.objectLiteral = objectLiteral;
                function typedArray(value, check) {
                    return Array.isArray(value) && value.every(check);
                }
                Is.typedArray = typedArray;
            })(Is || (Is = {}));
            // EXTERNAL MODULE: ../../node_modules/vscode-languageserver-textdocument/lib/esm/main.js
            var main = __nested_webpack_require_714846__(8041);
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/jsonLanguageTypes.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ /**
 * Error codes used by diagnostics
 */ var ErrorCode;
            (function(ErrorCode) {
                ErrorCode[ErrorCode["Undefined"] = 0] = "Undefined";
                ErrorCode[ErrorCode["EnumValueMismatch"] = 1] = "EnumValueMismatch";
                ErrorCode[ErrorCode["Deprecated"] = 2] = "Deprecated";
                ErrorCode[ErrorCode["UnexpectedEndOfComment"] = 257] = "UnexpectedEndOfComment";
                ErrorCode[ErrorCode["UnexpectedEndOfString"] = 258] = "UnexpectedEndOfString";
                ErrorCode[ErrorCode["UnexpectedEndOfNumber"] = 259] = "UnexpectedEndOfNumber";
                ErrorCode[ErrorCode["InvalidUnicode"] = 260] = "InvalidUnicode";
                ErrorCode[ErrorCode["InvalidEscapeCharacter"] = 261] = "InvalidEscapeCharacter";
                ErrorCode[ErrorCode["InvalidCharacter"] = 262] = "InvalidCharacter";
                ErrorCode[ErrorCode["PropertyExpected"] = 513] = "PropertyExpected";
                ErrorCode[ErrorCode["CommaExpected"] = 514] = "CommaExpected";
                ErrorCode[ErrorCode["ColonExpected"] = 515] = "ColonExpected";
                ErrorCode[ErrorCode["ValueExpected"] = 516] = "ValueExpected";
                ErrorCode[ErrorCode["CommaOrCloseBacketExpected"] = 517] = "CommaOrCloseBacketExpected";
                ErrorCode[ErrorCode["CommaOrCloseBraceExpected"] = 518] = "CommaOrCloseBraceExpected";
                ErrorCode[ErrorCode["TrailingComma"] = 519] = "TrailingComma";
                ErrorCode[ErrorCode["DuplicateKey"] = 520] = "DuplicateKey";
                ErrorCode[ErrorCode["CommentNotPermitted"] = 521] = "CommentNotPermitted";
                ErrorCode[ErrorCode["PropertyKeysMustBeDoublequoted"] = 528] = "PropertyKeysMustBeDoublequoted";
                ErrorCode[ErrorCode["SchemaResolveError"] = 768] = "SchemaResolveError";
                ErrorCode[ErrorCode["SchemaUnsupportedFeature"] = 769] = "SchemaUnsupportedFeature";
            })(ErrorCode || (ErrorCode = {}));
            var SchemaDraft;
            (function(SchemaDraft) {
                SchemaDraft[SchemaDraft["v3"] = 3] = "v3";
                SchemaDraft[SchemaDraft["v4"] = 4] = "v4";
                SchemaDraft[SchemaDraft["v6"] = 6] = "v6";
                SchemaDraft[SchemaDraft["v7"] = 7] = "v7";
                SchemaDraft[SchemaDraft["v2019_09"] = 19] = "v2019_09";
                SchemaDraft[SchemaDraft["v2020_12"] = 20] = "v2020_12";
            })(SchemaDraft || (SchemaDraft = {}));
            var ClientCapabilities;
            (function(ClientCapabilities) {
                ClientCapabilities.LATEST = {
                    textDocument: {
                        completion: {
                            completionItem: {
                                documentationFormat: [
                                    MarkupKind.Markdown,
                                    MarkupKind.PlainText
                                ],
                                commitCharactersSupport: true,
                                labelDetailsSupport: true
                            }
                        }
                    }
                };
            })(ClientCapabilities || (ClientCapabilities = {}));
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/node_modules/@vscode/l10n/dist/browser.js
            // src/browser/reader.ts
            async function readFileFromUri(uri) {
                if (uri.protocol === "http:" || uri.protocol === "https:") {
                    const res = await fetch(uri);
                    return await res.text();
                }
                throw new Error("Unsupported protocol");
            }
            function readFileFromFsPath(_) {
                throw new Error("Unsupported in browser");
            }
            // src/main.ts
            var bundle;
            function config(config2) {
                if ("contents" in config2) {
                    if (typeof config2.contents === "string") {
                        bundle = JSON.parse(config2.contents);
                    } else {
                        bundle = config2.contents;
                    }
                    return;
                }
                if ("fsPath" in config2) {
                    const fileContent = readFileFromFsPath(config2.fsPath);
                    const content = JSON.parse(fileContent);
                    bundle = isBuiltinExtension(content) ? content.contents.bundle : content;
                    return;
                }
                if (config2.uri) {
                    let uri = config2.uri;
                    if (typeof config2.uri === "string") {
                        uri = new URL(config2.uri);
                    }
                    return new Promise((resolve, reject)=>{
                        readFileFromUri(uri).then((uriContent)=>{
                            try {
                                const content = JSON.parse(uriContent);
                                bundle = isBuiltinExtension(content) ? content.contents.bundle : content;
                                resolve();
                            } catch (err) {
                                reject(err);
                            }
                        }).catch((err)=>{
                            reject(err);
                        });
                    });
                }
            }
            function t(...args) {
                var _bundle;
                const firstArg = args[0];
                let key;
                let message;
                let formatArgs;
                if (typeof firstArg === "string") {
                    key = firstArg;
                    message = firstArg;
                    args.splice(0, 1);
                    formatArgs = !args || typeof args[0] !== "object" ? args : args[0];
                } else if (firstArg instanceof Array) {
                    const replacements = args.slice(1);
                    if (firstArg.length !== replacements.length + 1) {
                        throw new Error("expected a string as the first argument to l10n.t");
                    }
                    let str = firstArg[0];
                    for(let i = 1; i < firstArg.length; i++){
                        str += `{${i - 1}}` + firstArg[i];
                    }
                    return t(str, ...replacements);
                } else {
                    message = firstArg.message;
                    key = message;
                    if (firstArg.comment && firstArg.comment.length > 0) {
                        key += `/${Array.isArray(firstArg.comment) ? firstArg.comment.join("") : firstArg.comment}`;
                    }
                    var _firstArg_args;
                    formatArgs = (_firstArg_args = firstArg.args) !== null && _firstArg_args !== void 0 ? _firstArg_args : {};
                }
                const messageFromBundle = (_bundle = bundle) === null || _bundle === void 0 ? void 0 : _bundle[key];
                if (!messageFromBundle) {
                    return browser_format(message, formatArgs);
                }
                if (typeof messageFromBundle === "string") {
                    return browser_format(messageFromBundle, formatArgs);
                }
                if (messageFromBundle.comment) {
                    return browser_format(messageFromBundle.message, formatArgs);
                }
                return browser_format(message, formatArgs);
            }
            var _format2Regexp = /{([^}]+)}/g;
            function browser_format(template, values) {
                if (Object.keys(values).length === 0) {
                    return template;
                }
                var _values_group;
                return template.replace(_format2Regexp, (match, group)=>(_values_group = values[group]) !== null && _values_group !== void 0 ? _values_group : match);
            }
            function isBuiltinExtension(json) {
                var _json_contents, _json, _json1;
                return !!(typeof ((_json = json) === null || _json === void 0 ? void 0 : (_json_contents = _json.contents) === null || _json_contents === void 0 ? void 0 : _json_contents.bundle) === "object" && typeof ((_json1 = json) === null || _json1 === void 0 ? void 0 : _json1.version) === "string");
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/parser/jsonParser.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ const formats = {
                'color-hex': {
                    errorMessage: t('Invalid color format. Use #RGB, #RGBA, #RRGGBB or #RRGGBBAA.'),
                    pattern: /^#([0-9A-Fa-f]{3,4}|([0-9A-Fa-f]{2}){3,4})$/
                },
                'date-time': {
                    errorMessage: t('String is not a RFC3339 date-time.'),
                    pattern: /^(\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)([01][0-9]|2[0-3]):([0-5][0-9]))$/i
                },
                'date': {
                    errorMessage: t('String is not a RFC3339 date.'),
                    pattern: /^(\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/i
                },
                'time': {
                    errorMessage: t('String is not a RFC3339 time.'),
                    pattern: /^([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)([01][0-9]|2[0-3]):([0-5][0-9]))$/i
                },
                'email': {
                    errorMessage: t('String is not an e-mail address.'),
                    pattern: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z0-9-]+\.)+[a-zA-Z]{2,}))$/
                },
                'hostname': {
                    errorMessage: t('String is not a hostname.'),
                    pattern: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i
                },
                'ipv4': {
                    errorMessage: t('String is not an IPv4 address.'),
                    pattern: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/
                },
                'ipv6': {
                    errorMessage: t('String is not an IPv6 address.'),
                    pattern: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i
                }
            };
            class ASTNodeImpl {
                get children() {
                    return [];
                }
                toString() {
                    return 'type: ' + this.type + ' (' + this.offset + '/' + this.length + ')' + (this.parent ? ' parent: {' + this.parent.toString() + '}' : '');
                }
                constructor(parent, offset, length = 0){
                    this.offset = offset;
                    this.length = length;
                    this.parent = parent;
                }
            }
            class NullASTNodeImpl extends ASTNodeImpl {
                constructor(parent, offset){
                    super(parent, offset);
                    this.type = 'null';
                    this.value = null;
                }
            }
            class BooleanASTNodeImpl extends ASTNodeImpl {
                constructor(parent, boolValue, offset){
                    super(parent, offset);
                    this.type = 'boolean';
                    this.value = boolValue;
                }
            }
            class ArrayASTNodeImpl extends ASTNodeImpl {
                get children() {
                    return this.items;
                }
                constructor(parent, offset){
                    super(parent, offset);
                    this.type = 'array';
                    this.items = [];
                }
            }
            class NumberASTNodeImpl extends ASTNodeImpl {
                constructor(parent, offset){
                    super(parent, offset);
                    this.type = 'number';
                    this.isInteger = true;
                    this.value = Number.NaN;
                }
            }
            class StringASTNodeImpl extends ASTNodeImpl {
                constructor(parent, offset, length){
                    super(parent, offset, length);
                    this.type = 'string';
                    this.value = '';
                }
            }
            class PropertyASTNodeImpl extends ASTNodeImpl {
                get children() {
                    return this.valueNode ? [
                        this.keyNode,
                        this.valueNode
                    ] : [
                        this.keyNode
                    ];
                }
                constructor(parent, offset, keyNode){
                    super(parent, offset);
                    this.type = 'property';
                    this.colonOffset = -1;
                    this.keyNode = keyNode;
                }
            }
            class ObjectASTNodeImpl extends ASTNodeImpl {
                get children() {
                    return this.properties;
                }
                constructor(parent, offset){
                    super(parent, offset);
                    this.type = 'object';
                    this.properties = [];
                }
            }
            function asSchema(schema) {
                if (isBoolean(schema)) {
                    return schema ? {} : {
                        "not": {}
                    };
                }
                return schema;
            }
            var EnumMatch;
            (function(EnumMatch) {
                EnumMatch[EnumMatch["Key"] = 0] = "Key";
                EnumMatch[EnumMatch["Enum"] = 1] = "Enum";
            })(EnumMatch || (EnumMatch = {}));
            const schemaDraftFromId = {
                'http://json-schema.org/draft-03/schema#': SchemaDraft.v3,
                'http://json-schema.org/draft-04/schema#': SchemaDraft.v4,
                'http://json-schema.org/draft-06/schema#': SchemaDraft.v6,
                'http://json-schema.org/draft-07/schema#': SchemaDraft.v7,
                'https://json-schema.org/draft/2019-09/schema': SchemaDraft.v2019_09,
                'https://json-schema.org/draft/2020-12/schema': SchemaDraft.v2020_12
            };
            class EvaluationContext {
                constructor(schemaDraft){
                    this.schemaDraft = schemaDraft;
                }
            }
            class SchemaCollector {
                add(schema) {
                    this.schemas.push(schema);
                }
                merge(other) {
                    Array.prototype.push.apply(this.schemas, other.schemas);
                }
                include(node) {
                    return (this.focusOffset === -1 || jsonParser_contains(node, this.focusOffset)) && node !== this.exclude;
                }
                newSub() {
                    return new SchemaCollector(-1, this.exclude);
                }
                constructor(focusOffset = -1, exclude){
                    this.focusOffset = focusOffset;
                    this.exclude = exclude;
                    this.schemas = [];
                }
            }
            class NoOpSchemaCollector {
                get schemas() {
                    return [];
                }
                add(_schema) {}
                merge(_other) {}
                include(_node) {
                    return true;
                }
                newSub() {
                    return this;
                }
                constructor(){}
            }
            NoOpSchemaCollector.instance = new NoOpSchemaCollector();
            class ValidationResult {
                hasProblems() {
                    return !!this.problems.length;
                }
                merge(validationResult) {
                    this.problems = this.problems.concat(validationResult.problems);
                    this.propertiesMatches += validationResult.propertiesMatches;
                    this.propertiesValueMatches += validationResult.propertiesValueMatches;
                    this.mergeProcessedProperties(validationResult);
                }
                mergeEnumValues(validationResult) {
                    if (!this.enumValueMatch && !validationResult.enumValueMatch && this.enumValues && validationResult.enumValues) {
                        this.enumValues = this.enumValues.concat(validationResult.enumValues);
                        for (const error of this.problems){
                            if (error.code === ErrorCode.EnumValueMismatch) {
                                error.message = t('Value is not accepted. Valid values: {0}.', this.enumValues.map((v)=>JSON.stringify(v)).join(', '));
                            }
                        }
                    }
                }
                mergePropertyMatch(propertyValidationResult) {
                    this.problems = this.problems.concat(propertyValidationResult.problems);
                    this.propertiesMatches++;
                    if (propertyValidationResult.enumValueMatch || !propertyValidationResult.hasProblems() && propertyValidationResult.propertiesMatches) {
                        this.propertiesValueMatches++;
                    }
                    if (propertyValidationResult.enumValueMatch && propertyValidationResult.enumValues && propertyValidationResult.enumValues.length === 1) {
                        this.primaryValueMatches++;
                    }
                }
                mergeProcessedProperties(validationResult) {
                    validationResult.processedProperties.forEach((p)=>this.processedProperties.add(p));
                }
                compare(other) {
                    const hasProblems = this.hasProblems();
                    if (hasProblems !== other.hasProblems()) {
                        return hasProblems ? -1 : 1;
                    }
                    if (this.enumValueMatch !== other.enumValueMatch) {
                        return other.enumValueMatch ? -1 : 1;
                    }
                    if (this.primaryValueMatches !== other.primaryValueMatches) {
                        return this.primaryValueMatches - other.primaryValueMatches;
                    }
                    if (this.propertiesValueMatches !== other.propertiesValueMatches) {
                        return this.propertiesValueMatches - other.propertiesValueMatches;
                    }
                    return this.propertiesMatches - other.propertiesMatches;
                }
                constructor(){
                    this.problems = [];
                    this.propertiesMatches = 0;
                    this.processedProperties = new Set();
                    this.propertiesValueMatches = 0;
                    this.primaryValueMatches = 0;
                    this.enumValueMatch = false;
                    this.enumValues = undefined;
                }
            }
            function newJSONDocument(root, diagnostics = []) {
                return new JSONDocument(root, diagnostics, []);
            }
            function jsonParser_getNodeValue(node) {
                return main_getNodeValue(node);
            }
            function jsonParser_getNodePath(node) {
                return main_getNodePath(node);
            }
            function jsonParser_contains(node, offset, includeRightBound = false) {
                return offset >= node.offset && offset < node.offset + node.length || includeRightBound && offset === node.offset + node.length;
            }
            class JSONDocument {
                getNodeFromOffset(offset, includeRightBound = false) {
                    if (this.root) {
                        return main_findNodeAtOffset(this.root, offset, includeRightBound);
                    }
                    return undefined;
                }
                visit(visitor) {
                    if (this.root) {
                        const doVisit = (node)=>{
                            let ctn = visitor(node);
                            const children = node.children;
                            if (Array.isArray(children)) {
                                for(let i = 0; i < children.length && ctn; i++){
                                    ctn = doVisit(children[i]);
                                }
                            }
                            return ctn;
                        };
                        doVisit(this.root);
                    }
                }
                validate(textDocument, schema, severity = DiagnosticSeverity.Warning, schemaDraft) {
                    if (this.root && schema) {
                        const validationResult = new ValidationResult();
                        validate(this.root, schema, validationResult, NoOpSchemaCollector.instance, new EvaluationContext(schemaDraft !== null && schemaDraft !== void 0 ? schemaDraft : getSchemaDraft(schema)));
                        return validationResult.problems.map((p)=>{
                            const range = Range.create(textDocument.positionAt(p.location.offset), textDocument.positionAt(p.location.offset + p.location.length));
                            var _p_severity;
                            return Diagnostic.create(range, p.message, (_p_severity = p.severity) !== null && _p_severity !== void 0 ? _p_severity : severity, p.code);
                        });
                    }
                    return undefined;
                }
                getMatchingSchemas(schema, focusOffset = -1, exclude) {
                    if (this.root && schema) {
                        const matchingSchemas = new SchemaCollector(focusOffset, exclude);
                        const schemaDraft = getSchemaDraft(schema);
                        const context = new EvaluationContext(schemaDraft);
                        validate(this.root, schema, new ValidationResult(), matchingSchemas, context);
                        return matchingSchemas.schemas;
                    }
                    return [];
                }
                constructor(root, syntaxErrors = [], comments = []){
                    this.root = root;
                    this.syntaxErrors = syntaxErrors;
                    this.comments = comments;
                }
            }
            function getSchemaDraft(schema, fallBack = SchemaDraft.v2020_12) {
                let schemaId = schema.$schema;
                if (schemaId) {
                    var _schemaDraftFromId_schemaId;
                    return (_schemaDraftFromId_schemaId = schemaDraftFromId[schemaId]) !== null && _schemaDraftFromId_schemaId !== void 0 ? _schemaDraftFromId_schemaId : fallBack;
                }
                return fallBack;
            }
            function validate(n, schema, validationResult, matchingSchemas, context) {
                if (!n || !matchingSchemas.include(n)) {
                    return;
                }
                if (n.type === 'property') {
                    return validate(n.valueNode, schema, validationResult, matchingSchemas, context);
                }
                const node = n;
                _validateNode();
                switch(node.type){
                    case 'object':
                        _validateObjectNode(node);
                        break;
                    case 'array':
                        _validateArrayNode(node);
                        break;
                    case 'string':
                        _validateStringNode(node);
                        break;
                    case 'number':
                        _validateNumberNode(node);
                        break;
                }
                matchingSchemas.add({
                    node: node,
                    schema: schema
                });
                function _validateNode() {
                    function matchesType(type) {
                        return node.type === type || type === 'integer' && node.type === 'number' && node.isInteger;
                    }
                    if (Array.isArray(schema.type)) {
                        if (!schema.type.some(matchesType)) {
                            validationResult.problems.push({
                                location: {
                                    offset: node.offset,
                                    length: node.length
                                },
                                message: schema.errorMessage || t('Incorrect type. Expected one of {0}.', schema.type.join(', '))
                            });
                        }
                    } else if (schema.type) {
                        if (!matchesType(schema.type)) {
                            validationResult.problems.push({
                                location: {
                                    offset: node.offset,
                                    length: node.length
                                },
                                message: schema.errorMessage || t('Incorrect type. Expected "{0}".', schema.type)
                            });
                        }
                    }
                    if (Array.isArray(schema.allOf)) {
                        for (const subSchemaRef of schema.allOf){
                            const subValidationResult = new ValidationResult();
                            const subMatchingSchemas = matchingSchemas.newSub();
                            validate(node, asSchema(subSchemaRef), subValidationResult, subMatchingSchemas, context);
                            validationResult.merge(subValidationResult);
                            matchingSchemas.merge(subMatchingSchemas);
                        }
                    }
                    const notSchema = asSchema(schema.not);
                    if (notSchema) {
                        const subValidationResult = new ValidationResult();
                        const subMatchingSchemas = matchingSchemas.newSub();
                        validate(node, notSchema, subValidationResult, subMatchingSchemas, context);
                        if (!subValidationResult.hasProblems()) {
                            validationResult.problems.push({
                                location: {
                                    offset: node.offset,
                                    length: node.length
                                },
                                message: schema.errorMessage || t("Matches a schema that is not allowed.")
                            });
                        }
                        for (const ms of subMatchingSchemas.schemas){
                            ms.inverted = !ms.inverted;
                            matchingSchemas.add(ms);
                        }
                    }
                    const testAlternatives = (alternatives, maxOneMatch)=>{
                        const matches = [];
                        // remember the best match that is used for error messages
                        let bestMatch = undefined;
                        for (const subSchemaRef of alternatives){
                            const subSchema = asSchema(subSchemaRef);
                            const subValidationResult = new ValidationResult();
                            const subMatchingSchemas = matchingSchemas.newSub();
                            validate(node, subSchema, subValidationResult, subMatchingSchemas, context);
                            if (!subValidationResult.hasProblems()) {
                                matches.push(subSchema);
                            }
                            if (!bestMatch) {
                                bestMatch = {
                                    schema: subSchema,
                                    validationResult: subValidationResult,
                                    matchingSchemas: subMatchingSchemas
                                };
                            } else {
                                if (!maxOneMatch && !subValidationResult.hasProblems() && !bestMatch.validationResult.hasProblems()) {
                                    // no errors, both are equally good matches
                                    bestMatch.matchingSchemas.merge(subMatchingSchemas);
                                    bestMatch.validationResult.propertiesMatches += subValidationResult.propertiesMatches;
                                    bestMatch.validationResult.propertiesValueMatches += subValidationResult.propertiesValueMatches;
                                    bestMatch.validationResult.mergeProcessedProperties(subValidationResult);
                                } else {
                                    const compareResult = subValidationResult.compare(bestMatch.validationResult);
                                    if (compareResult > 0) {
                                        // our node is the best matching so far
                                        bestMatch = {
                                            schema: subSchema,
                                            validationResult: subValidationResult,
                                            matchingSchemas: subMatchingSchemas
                                        };
                                    } else if (compareResult === 0) {
                                        // there's already a best matching but we are as good
                                        bestMatch.matchingSchemas.merge(subMatchingSchemas);
                                        bestMatch.validationResult.mergeEnumValues(subValidationResult);
                                    }
                                }
                            }
                        }
                        if (matches.length > 1 && maxOneMatch) {
                            validationResult.problems.push({
                                location: {
                                    offset: node.offset,
                                    length: 1
                                },
                                message: t("Matches multiple schemas when only one must validate.")
                            });
                        }
                        if (bestMatch) {
                            validationResult.merge(bestMatch.validationResult);
                            matchingSchemas.merge(bestMatch.matchingSchemas);
                        }
                        return matches.length;
                    };
                    if (Array.isArray(schema.anyOf)) {
                        testAlternatives(schema.anyOf, false);
                    }
                    if (Array.isArray(schema.oneOf)) {
                        testAlternatives(schema.oneOf, true);
                    }
                    const testBranch = (schema)=>{
                        const subValidationResult = new ValidationResult();
                        const subMatchingSchemas = matchingSchemas.newSub();
                        validate(node, asSchema(schema), subValidationResult, subMatchingSchemas, context);
                        validationResult.merge(subValidationResult);
                        matchingSchemas.merge(subMatchingSchemas);
                    };
                    const testCondition = (ifSchema, thenSchema, elseSchema)=>{
                        const subSchema = asSchema(ifSchema);
                        const subValidationResult = new ValidationResult();
                        const subMatchingSchemas = matchingSchemas.newSub();
                        validate(node, subSchema, subValidationResult, subMatchingSchemas, context);
                        matchingSchemas.merge(subMatchingSchemas);
                        validationResult.mergeProcessedProperties(subValidationResult);
                        if (!subValidationResult.hasProblems()) {
                            if (thenSchema) {
                                testBranch(thenSchema);
                            }
                        } else if (elseSchema) {
                            testBranch(elseSchema);
                        }
                    };
                    const ifSchema = asSchema(schema.if);
                    if (ifSchema) {
                        testCondition(ifSchema, asSchema(schema.then), asSchema(schema.else));
                    }
                    if (Array.isArray(schema.enum)) {
                        const val = jsonParser_getNodeValue(node);
                        let enumValueMatch = false;
                        for (const e of schema.enum){
                            if (equals(val, e)) {
                                enumValueMatch = true;
                                break;
                            }
                        }
                        validationResult.enumValues = schema.enum;
                        validationResult.enumValueMatch = enumValueMatch;
                        if (!enumValueMatch) {
                            validationResult.problems.push({
                                location: {
                                    offset: node.offset,
                                    length: node.length
                                },
                                code: ErrorCode.EnumValueMismatch,
                                message: schema.errorMessage || t('Value is not accepted. Valid values: {0}.', schema.enum.map((v)=>JSON.stringify(v)).join(', '))
                            });
                        }
                    }
                    if (isDefined(schema.const)) {
                        const val = jsonParser_getNodeValue(node);
                        if (!equals(val, schema.const)) {
                            validationResult.problems.push({
                                location: {
                                    offset: node.offset,
                                    length: node.length
                                },
                                code: ErrorCode.EnumValueMismatch,
                                message: schema.errorMessage || t('Value must be {0}.', JSON.stringify(schema.const))
                            });
                            validationResult.enumValueMatch = false;
                        } else {
                            validationResult.enumValueMatch = true;
                        }
                        validationResult.enumValues = [
                            schema.const
                        ];
                    }
                    let deprecationMessage = schema.deprecationMessage;
                    if (deprecationMessage || schema.deprecated) {
                        var _node_parent;
                        deprecationMessage = deprecationMessage || t('Value is deprecated');
                        let targetNode = ((_node_parent = node.parent) === null || _node_parent === void 0 ? void 0 : _node_parent.type) === 'property' ? node.parent : node;
                        validationResult.problems.push({
                            location: {
                                offset: targetNode.offset,
                                length: targetNode.length
                            },
                            severity: DiagnosticSeverity.Warning,
                            message: deprecationMessage,
                            code: ErrorCode.Deprecated
                        });
                    }
                }
                function _validateNumberNode(node) {
                    const val = node.value;
                    function normalizeFloats(float) {
                        var _parts_;
                        const parts = /^(-?\d+)(?:\.(\d+))?(?:e([-+]\d+))?$/.exec(float.toString());
                        return parts && {
                            value: Number(parts[1] + (parts[2] || '')),
                            multiplier: (((_parts_ = parts[2]) === null || _parts_ === void 0 ? void 0 : _parts_.length) || 0) - (parseInt(parts[3]) || 0)
                        };
                    }
                    ;
                    if (isNumber(schema.multipleOf)) {
                        let remainder = -1;
                        if (Number.isInteger(schema.multipleOf)) {
                            remainder = val % schema.multipleOf;
                        } else {
                            let normMultipleOf = normalizeFloats(schema.multipleOf);
                            let normValue = normalizeFloats(val);
                            if (normMultipleOf && normValue) {
                                const multiplier = 10 ** Math.abs(normValue.multiplier - normMultipleOf.multiplier);
                                if (normValue.multiplier < normMultipleOf.multiplier) {
                                    normValue.value *= multiplier;
                                } else {
                                    normMultipleOf.value *= multiplier;
                                }
                                remainder = normValue.value % normMultipleOf.value;
                            }
                        }
                        if (remainder !== 0) {
                            validationResult.problems.push({
                                location: {
                                    offset: node.offset,
                                    length: node.length
                                },
                                message: t('Value is not divisible by {0}.', schema.multipleOf)
                            });
                        }
                    }
                    function getExclusiveLimit(limit, exclusive) {
                        if (isNumber(exclusive)) {
                            return exclusive;
                        }
                        if (isBoolean(exclusive) && exclusive) {
                            return limit;
                        }
                        return undefined;
                    }
                    function getLimit(limit, exclusive) {
                        if (!isBoolean(exclusive) || !exclusive) {
                            return limit;
                        }
                        return undefined;
                    }
                    const exclusiveMinimum = getExclusiveLimit(schema.minimum, schema.exclusiveMinimum);
                    if (isNumber(exclusiveMinimum) && val <= exclusiveMinimum) {
                        validationResult.problems.push({
                            location: {
                                offset: node.offset,
                                length: node.length
                            },
                            message: t('Value is below the exclusive minimum of {0}.', exclusiveMinimum)
                        });
                    }
                    const exclusiveMaximum = getExclusiveLimit(schema.maximum, schema.exclusiveMaximum);
                    if (isNumber(exclusiveMaximum) && val >= exclusiveMaximum) {
                        validationResult.problems.push({
                            location: {
                                offset: node.offset,
                                length: node.length
                            },
                            message: t('Value is above the exclusive maximum of {0}.', exclusiveMaximum)
                        });
                    }
                    const minimum = getLimit(schema.minimum, schema.exclusiveMinimum);
                    if (isNumber(minimum) && val < minimum) {
                        validationResult.problems.push({
                            location: {
                                offset: node.offset,
                                length: node.length
                            },
                            message: t('Value is below the minimum of {0}.', minimum)
                        });
                    }
                    const maximum = getLimit(schema.maximum, schema.exclusiveMaximum);
                    if (isNumber(maximum) && val > maximum) {
                        validationResult.problems.push({
                            location: {
                                offset: node.offset,
                                length: node.length
                            },
                            message: t('Value is above the maximum of {0}.', maximum)
                        });
                    }
                }
                function _validateStringNode(node) {
                    if (isNumber(schema.minLength) && stringLength(node.value) < schema.minLength) {
                        validationResult.problems.push({
                            location: {
                                offset: node.offset,
                                length: node.length
                            },
                            message: t('String is shorter than the minimum length of {0}.', schema.minLength)
                        });
                    }
                    if (isNumber(schema.maxLength) && stringLength(node.value) > schema.maxLength) {
                        validationResult.problems.push({
                            location: {
                                offset: node.offset,
                                length: node.length
                            },
                            message: t('String is longer than the maximum length of {0}.', schema.maxLength)
                        });
                    }
                    if (isString(schema.pattern)) {
                        var _regex;
                        const regex = extendedRegExp(schema.pattern);
                        if (!((_regex = regex) === null || _regex === void 0 ? void 0 : _regex.test(node.value))) {
                            validationResult.problems.push({
                                location: {
                                    offset: node.offset,
                                    length: node.length
                                },
                                message: schema.patternErrorMessage || schema.errorMessage || t('String does not match the pattern of "{0}".', schema.pattern)
                            });
                        }
                    }
                    if (schema.format) {
                        switch(schema.format){
                            case 'uri':
                            case 'uri-reference':
                                {
                                    let errorMessage;
                                    if (!node.value) {
                                        errorMessage = t('URI expected.');
                                    } else {
                                        const match = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/.exec(node.value);
                                        if (!match) {
                                            errorMessage = t('URI is expected.');
                                        } else if (!match[2] && schema.format === 'uri') {
                                            errorMessage = t('URI with a scheme is expected.');
                                        }
                                    }
                                    if (errorMessage) {
                                        validationResult.problems.push({
                                            location: {
                                                offset: node.offset,
                                                length: node.length
                                            },
                                            message: schema.patternErrorMessage || schema.errorMessage || t('String is not a URI: {0}', errorMessage)
                                        });
                                    }
                                }
                                break;
                            case 'color-hex':
                            case 'date-time':
                            case 'date':
                            case 'time':
                            case 'email':
                            case 'hostname':
                            case 'ipv4':
                            case 'ipv6':
                                const format1 = formats[schema.format];
                                if (!node.value || !format1.pattern.exec(node.value)) {
                                    validationResult.problems.push({
                                        location: {
                                            offset: node.offset,
                                            length: node.length
                                        },
                                        message: schema.patternErrorMessage || schema.errorMessage || format1.errorMessage
                                    });
                                }
                            default:
                        }
                    }
                }
                function _validateArrayNode(node) {
                    let prefixItemsSchemas;
                    let additionalItemSchema;
                    if (context.schemaDraft >= SchemaDraft.v2020_12) {
                        prefixItemsSchemas = schema.prefixItems;
                        additionalItemSchema = !Array.isArray(schema.items) ? schema.items : undefined;
                    } else {
                        prefixItemsSchemas = Array.isArray(schema.items) ? schema.items : undefined;
                        additionalItemSchema = !Array.isArray(schema.items) ? schema.items : schema.additionalItems;
                    }
                    let index = 0;
                    if (prefixItemsSchemas !== undefined) {
                        const max = Math.min(prefixItemsSchemas.length, node.items.length);
                        for(; index < max; index++){
                            const subSchemaRef = prefixItemsSchemas[index];
                            const subSchema = asSchema(subSchemaRef);
                            const itemValidationResult = new ValidationResult();
                            const item = node.items[index];
                            if (item) {
                                validate(item, subSchema, itemValidationResult, matchingSchemas, context);
                                validationResult.mergePropertyMatch(itemValidationResult);
                            }
                            validationResult.processedProperties.add(String(index));
                        }
                    }
                    if (additionalItemSchema !== undefined && index < node.items.length) {
                        if (typeof additionalItemSchema === 'boolean') {
                            if (additionalItemSchema === false) {
                                validationResult.problems.push({
                                    location: {
                                        offset: node.offset,
                                        length: node.length
                                    },
                                    message: t('Array has too many items according to schema. Expected {0} or fewer.', index)
                                });
                            }
                            for(; index < node.items.length; index++){
                                validationResult.processedProperties.add(String(index));
                                validationResult.propertiesValueMatches++;
                            }
                        } else {
                            for(; index < node.items.length; index++){
                                const itemValidationResult = new ValidationResult();
                                validate(node.items[index], additionalItemSchema, itemValidationResult, matchingSchemas, context);
                                validationResult.mergePropertyMatch(itemValidationResult);
                                validationResult.processedProperties.add(String(index));
                            }
                        }
                    }
                    const containsSchema = asSchema(schema.contains);
                    if (containsSchema) {
                        let containsCount = 0;
                        for(let index = 0; index < node.items.length; index++){
                            const item = node.items[index];
                            const itemValidationResult = new ValidationResult();
                            validate(item, containsSchema, itemValidationResult, NoOpSchemaCollector.instance, context);
                            if (!itemValidationResult.hasProblems()) {
                                containsCount++;
                                if (context.schemaDraft >= SchemaDraft.v2020_12) {
                                    validationResult.processedProperties.add(String(index));
                                }
                            }
                        }
                        if (containsCount === 0 && !isNumber(schema.minContains)) {
                            validationResult.problems.push({
                                location: {
                                    offset: node.offset,
                                    length: node.length
                                },
                                message: schema.errorMessage || t('Array does not contain required item.')
                            });
                        }
                        if (isNumber(schema.minContains) && containsCount < schema.minContains) {
                            validationResult.problems.push({
                                location: {
                                    offset: node.offset,
                                    length: node.length
                                },
                                message: schema.errorMessage || t('Array has too few items that match the contains contraint. Expected {0} or more.', schema.minContains)
                            });
                        }
                        if (isNumber(schema.maxContains) && containsCount > schema.maxContains) {
                            validationResult.problems.push({
                                location: {
                                    offset: node.offset,
                                    length: node.length
                                },
                                message: schema.errorMessage || t('Array has too many items that match the contains contraint. Expected {0} or less.', schema.maxContains)
                            });
                        }
                    }
                    const unevaluatedItems = schema.unevaluatedItems;
                    if (unevaluatedItems !== undefined) {
                        for(let i = 0; i < node.items.length; i++){
                            if (!validationResult.processedProperties.has(String(i))) {
                                if (unevaluatedItems === false) {
                                    validationResult.problems.push({
                                        location: {
                                            offset: node.offset,
                                            length: node.length
                                        },
                                        message: t('Item does not match any validation rule from the array.')
                                    });
                                } else {
                                    const itemValidationResult = new ValidationResult();
                                    validate(node.items[i], schema.unevaluatedItems, itemValidationResult, matchingSchemas, context);
                                    validationResult.mergePropertyMatch(itemValidationResult);
                                }
                            }
                            validationResult.processedProperties.add(String(i));
                            validationResult.propertiesValueMatches++;
                        }
                    }
                    if (isNumber(schema.minItems) && node.items.length < schema.minItems) {
                        validationResult.problems.push({
                            location: {
                                offset: node.offset,
                                length: node.length
                            },
                            message: t('Array has too few items. Expected {0} or more.', schema.minItems)
                        });
                    }
                    if (isNumber(schema.maxItems) && node.items.length > schema.maxItems) {
                        validationResult.problems.push({
                            location: {
                                offset: node.offset,
                                length: node.length
                            },
                            message: t('Array has too many items. Expected {0} or fewer.', schema.maxItems)
                        });
                    }
                    if (schema.uniqueItems === true) {
                        const values = jsonParser_getNodeValue(node);
                        function hasDuplicates() {
                            for(let i = 0; i < values.length - 1; i++){
                                const value = values[i];
                                for(let j = i + 1; j < values.length; j++){
                                    if (equals(value, values[j])) {
                                        return true;
                                    }
                                }
                            }
                            return false;
                        }
                        if (hasDuplicates()) {
                            validationResult.problems.push({
                                location: {
                                    offset: node.offset,
                                    length: node.length
                                },
                                message: t('Array has duplicate items.')
                            });
                        }
                    }
                }
                function _validateObjectNode(node) {
                    const seenKeys = Object.create(null);
                    const unprocessedProperties = new Set();
                    for (const propertyNode of node.properties){
                        const key = propertyNode.keyNode.value;
                        seenKeys[key] = propertyNode.valueNode;
                        unprocessedProperties.add(key);
                    }
                    if (Array.isArray(schema.required)) {
                        for (const propertyName of schema.required){
                            if (!seenKeys[propertyName]) {
                                const keyNode = node.parent && node.parent.type === 'property' && node.parent.keyNode;
                                const location = keyNode ? {
                                    offset: keyNode.offset,
                                    length: keyNode.length
                                } : {
                                    offset: node.offset,
                                    length: 1
                                };
                                validationResult.problems.push({
                                    location: location,
                                    message: t('Missing property "{0}".', propertyName)
                                });
                            }
                        }
                    }
                    const propertyProcessed = (prop)=>{
                        unprocessedProperties.delete(prop);
                        validationResult.processedProperties.add(prop);
                    };
                    if (schema.properties) {
                        for (const propertyName of Object.keys(schema.properties)){
                            propertyProcessed(propertyName);
                            const propertySchema = schema.properties[propertyName];
                            const child = seenKeys[propertyName];
                            if (child) {
                                if (isBoolean(propertySchema)) {
                                    if (!propertySchema) {
                                        const propertyNode = child.parent;
                                        validationResult.problems.push({
                                            location: {
                                                offset: propertyNode.keyNode.offset,
                                                length: propertyNode.keyNode.length
                                            },
                                            message: schema.errorMessage || t('Property {0} is not allowed.', propertyName)
                                        });
                                    } else {
                                        validationResult.propertiesMatches++;
                                        validationResult.propertiesValueMatches++;
                                    }
                                } else {
                                    const propertyValidationResult = new ValidationResult();
                                    validate(child, propertySchema, propertyValidationResult, matchingSchemas, context);
                                    validationResult.mergePropertyMatch(propertyValidationResult);
                                }
                            }
                        }
                    }
                    if (schema.patternProperties) {
                        for (const propertyPattern of Object.keys(schema.patternProperties)){
                            const regex = extendedRegExp(propertyPattern);
                            if (regex) {
                                const processed = [];
                                for (const propertyName of unprocessedProperties){
                                    if (regex.test(propertyName)) {
                                        processed.push(propertyName);
                                        const child = seenKeys[propertyName];
                                        if (child) {
                                            const propertySchema = schema.patternProperties[propertyPattern];
                                            if (isBoolean(propertySchema)) {
                                                if (!propertySchema) {
                                                    const propertyNode = child.parent;
                                                    validationResult.problems.push({
                                                        location: {
                                                            offset: propertyNode.keyNode.offset,
                                                            length: propertyNode.keyNode.length
                                                        },
                                                        message: schema.errorMessage || t('Property {0} is not allowed.', propertyName)
                                                    });
                                                } else {
                                                    validationResult.propertiesMatches++;
                                                    validationResult.propertiesValueMatches++;
                                                }
                                            } else {
                                                const propertyValidationResult = new ValidationResult();
                                                validate(child, propertySchema, propertyValidationResult, matchingSchemas, context);
                                                validationResult.mergePropertyMatch(propertyValidationResult);
                                            }
                                        }
                                    }
                                }
                                processed.forEach(propertyProcessed);
                            }
                        }
                    }
                    const additionalProperties = schema.additionalProperties;
                    if (additionalProperties !== undefined) {
                        for (const propertyName of unprocessedProperties){
                            propertyProcessed(propertyName);
                            const child = seenKeys[propertyName];
                            if (child) {
                                if (additionalProperties === false) {
                                    const propertyNode = child.parent;
                                    validationResult.problems.push({
                                        location: {
                                            offset: propertyNode.keyNode.offset,
                                            length: propertyNode.keyNode.length
                                        },
                                        message: schema.errorMessage || t('Property {0} is not allowed.', propertyName)
                                    });
                                } else if (additionalProperties !== true) {
                                    const propertyValidationResult = new ValidationResult();
                                    validate(child, additionalProperties, propertyValidationResult, matchingSchemas, context);
                                    validationResult.mergePropertyMatch(propertyValidationResult);
                                }
                            }
                        }
                    }
                    const unevaluatedProperties = schema.unevaluatedProperties;
                    if (unevaluatedProperties !== undefined) {
                        const processed = [];
                        for (const propertyName of unprocessedProperties){
                            if (!validationResult.processedProperties.has(propertyName)) {
                                processed.push(propertyName);
                                const child = seenKeys[propertyName];
                                if (child) {
                                    if (unevaluatedProperties === false) {
                                        const propertyNode = child.parent;
                                        validationResult.problems.push({
                                            location: {
                                                offset: propertyNode.keyNode.offset,
                                                length: propertyNode.keyNode.length
                                            },
                                            message: schema.errorMessage || t('Property {0} is not allowed.', propertyName)
                                        });
                                    } else if (unevaluatedProperties !== true) {
                                        const propertyValidationResult = new ValidationResult();
                                        validate(child, unevaluatedProperties, propertyValidationResult, matchingSchemas, context);
                                        validationResult.mergePropertyMatch(propertyValidationResult);
                                    }
                                }
                            }
                        }
                        processed.forEach(propertyProcessed);
                    }
                    if (isNumber(schema.maxProperties)) {
                        if (node.properties.length > schema.maxProperties) {
                            validationResult.problems.push({
                                location: {
                                    offset: node.offset,
                                    length: node.length
                                },
                                message: t('Object has more properties than limit of {0}.', schema.maxProperties)
                            });
                        }
                    }
                    if (isNumber(schema.minProperties)) {
                        if (node.properties.length < schema.minProperties) {
                            validationResult.problems.push({
                                location: {
                                    offset: node.offset,
                                    length: node.length
                                },
                                message: t('Object has fewer properties than the required number of {0}', schema.minProperties)
                            });
                        }
                    }
                    if (schema.dependentRequired) {
                        for(const key in schema.dependentRequired){
                            const prop = seenKeys[key];
                            const propertyDeps = schema.dependentRequired[key];
                            if (prop && Array.isArray(propertyDeps)) {
                                _validatePropertyDependencies(key, propertyDeps);
                            }
                        }
                    }
                    if (schema.dependentSchemas) {
                        for(const key in schema.dependentSchemas){
                            const prop = seenKeys[key];
                            const propertyDeps = schema.dependentSchemas[key];
                            if (prop && isObject(propertyDeps)) {
                                _validatePropertyDependencies(key, propertyDeps);
                            }
                        }
                    }
                    if (schema.dependencies) {
                        for(const key in schema.dependencies){
                            const prop = seenKeys[key];
                            if (prop) {
                                _validatePropertyDependencies(key, schema.dependencies[key]);
                            }
                        }
                    }
                    const propertyNames = asSchema(schema.propertyNames);
                    if (propertyNames) {
                        for (const f of node.properties){
                            const key = f.keyNode;
                            if (key) {
                                validate(key, propertyNames, validationResult, NoOpSchemaCollector.instance, context);
                            }
                        }
                    }
                    function _validatePropertyDependencies(key, propertyDep) {
                        if (Array.isArray(propertyDep)) {
                            for (const requiredProp of propertyDep){
                                if (!seenKeys[requiredProp]) {
                                    validationResult.problems.push({
                                        location: {
                                            offset: node.offset,
                                            length: node.length
                                        },
                                        message: t('Object is missing property {0} required by property {1}.', requiredProp, key)
                                    });
                                } else {
                                    validationResult.propertiesValueMatches++;
                                }
                            }
                        } else {
                            const propertySchema = asSchema(propertyDep);
                            if (propertySchema) {
                                const propertyValidationResult = new ValidationResult();
                                validate(node, propertySchema, propertyValidationResult, matchingSchemas, context);
                                validationResult.mergePropertyMatch(propertyValidationResult);
                            }
                        }
                    }
                }
            }
            function jsonParser_parse(textDocument, config) {
                const problems = [];
                let lastProblemOffset = -1;
                const text = textDocument.getText();
                const scanner = main_createScanner(text, false);
                const commentRanges = config && config.collectComments ? [] : undefined;
                function _scanNext() {
                    while(true){
                        const token = scanner.scan();
                        _checkScanError();
                        switch(token){
                            case 12 /* Json.SyntaxKind.LineCommentTrivia */ :
                            case 13 /* Json.SyntaxKind.BlockCommentTrivia */ :
                                if (Array.isArray(commentRanges)) {
                                    commentRanges.push(Range.create(textDocument.positionAt(scanner.getTokenOffset()), textDocument.positionAt(scanner.getTokenOffset() + scanner.getTokenLength())));
                                }
                                break;
                            case 15 /* Json.SyntaxKind.Trivia */ :
                            case 14 /* Json.SyntaxKind.LineBreakTrivia */ :
                                break;
                            default:
                                return token;
                        }
                    }
                }
                function _accept(token) {
                    if (scanner.getToken() === token) {
                        _scanNext();
                        return true;
                    }
                    return false;
                }
                function _errorAtRange(message, code, startOffset, endOffset, severity = DiagnosticSeverity.Error) {
                    if (problems.length === 0 || startOffset !== lastProblemOffset) {
                        const range = Range.create(textDocument.positionAt(startOffset), textDocument.positionAt(endOffset));
                        problems.push(Diagnostic.create(range, message, severity, code, textDocument.languageId));
                        lastProblemOffset = startOffset;
                    }
                }
                function _error(message, code, node = undefined, skipUntilAfter = [], skipUntil = []) {
                    let start = scanner.getTokenOffset();
                    let end = scanner.getTokenOffset() + scanner.getTokenLength();
                    if (start === end && start > 0) {
                        start--;
                        while(start > 0 && /\s/.test(text.charAt(start))){
                            start--;
                        }
                        end = start + 1;
                    }
                    _errorAtRange(message, code, start, end);
                    if (node) {
                        _finalize(node, false);
                    }
                    if (skipUntilAfter.length + skipUntil.length > 0) {
                        let token = scanner.getToken();
                        while(token !== 17 /* Json.SyntaxKind.EOF */ ){
                            if (skipUntilAfter.indexOf(token) !== -1) {
                                _scanNext();
                                break;
                            } else if (skipUntil.indexOf(token) !== -1) {
                                break;
                            }
                            token = _scanNext();
                        }
                    }
                    return node;
                }
                function _checkScanError() {
                    switch(scanner.getTokenError()){
                        case 4 /* Json.ScanError.InvalidUnicode */ :
                            _error(t('Invalid unicode sequence in string.'), ErrorCode.InvalidUnicode);
                            return true;
                        case 5 /* Json.ScanError.InvalidEscapeCharacter */ :
                            _error(t('Invalid escape character in string.'), ErrorCode.InvalidEscapeCharacter);
                            return true;
                        case 3 /* Json.ScanError.UnexpectedEndOfNumber */ :
                            _error(t('Unexpected end of number.'), ErrorCode.UnexpectedEndOfNumber);
                            return true;
                        case 1 /* Json.ScanError.UnexpectedEndOfComment */ :
                            _error(t('Unexpected end of comment.'), ErrorCode.UnexpectedEndOfComment);
                            return true;
                        case 2 /* Json.ScanError.UnexpectedEndOfString */ :
                            _error(t('Unexpected end of string.'), ErrorCode.UnexpectedEndOfString);
                            return true;
                        case 6 /* Json.ScanError.InvalidCharacter */ :
                            _error(t('Invalid characters in string. Control characters must be escaped.'), ErrorCode.InvalidCharacter);
                            return true;
                    }
                    return false;
                }
                function _finalize(node, scanNext) {
                    node.length = scanner.getTokenOffset() + scanner.getTokenLength() - node.offset;
                    if (scanNext) {
                        _scanNext();
                    }
                    return node;
                }
                function _parseArray(parent) {
                    if (scanner.getToken() !== 3 /* Json.SyntaxKind.OpenBracketToken */ ) {
                        return undefined;
                    }
                    const node = new ArrayASTNodeImpl(parent, scanner.getTokenOffset());
                    _scanNext(); // consume OpenBracketToken
                    const count = 0;
                    let needsComma = false;
                    while(scanner.getToken() !== 4 /* Json.SyntaxKind.CloseBracketToken */  && scanner.getToken() !== 17 /* Json.SyntaxKind.EOF */ ){
                        if (scanner.getToken() === 5 /* Json.SyntaxKind.CommaToken */ ) {
                            if (!needsComma) {
                                _error(t('Value expected'), ErrorCode.ValueExpected);
                            }
                            const commaOffset = scanner.getTokenOffset();
                            _scanNext(); // consume comma
                            if (scanner.getToken() === 4 /* Json.SyntaxKind.CloseBracketToken */ ) {
                                if (needsComma) {
                                    _errorAtRange(t('Trailing comma'), ErrorCode.TrailingComma, commaOffset, commaOffset + 1);
                                }
                                continue;
                            }
                        } else if (needsComma) {
                            _error(t('Expected comma'), ErrorCode.CommaExpected);
                        }
                        const item = _parseValue(node);
                        if (!item) {
                            _error(t('Value expected'), ErrorCode.ValueExpected, undefined, [], [
                                4 /* Json.SyntaxKind.CloseBracketToken */ ,
                                5 /* Json.SyntaxKind.CommaToken */ 
                            ]);
                        } else {
                            node.items.push(item);
                        }
                        needsComma = true;
                    }
                    if (scanner.getToken() !== 4 /* Json.SyntaxKind.CloseBracketToken */ ) {
                        return _error(t('Expected comma or closing bracket'), ErrorCode.CommaOrCloseBacketExpected, node);
                    }
                    return _finalize(node, true);
                }
                const keyPlaceholder = new StringASTNodeImpl(undefined, 0, 0);
                function _parseProperty(parent, keysSeen) {
                    const node = new PropertyASTNodeImpl(parent, scanner.getTokenOffset(), keyPlaceholder);
                    let key = _parseString(node);
                    if (!key) {
                        if (scanner.getToken() === 16 /* Json.SyntaxKind.Unknown */ ) {
                            // give a more helpful error message
                            _error(t('Property keys must be doublequoted'), ErrorCode.PropertyKeysMustBeDoublequoted);
                            const keyNode = new StringASTNodeImpl(node, scanner.getTokenOffset(), scanner.getTokenLength());
                            keyNode.value = scanner.getTokenValue();
                            key = keyNode;
                            _scanNext(); // consume Unknown
                        } else {
                            return undefined;
                        }
                    }
                    node.keyNode = key;
                    // For JSON files that forbid code comments, there is a convention to use the key name "//" to add comments.
                    // Multiple instances of "//" are okay.
                    if (key.value !== "//") {
                        const seen = keysSeen[key.value];
                        if (seen) {
                            _errorAtRange(t("Duplicate object key"), ErrorCode.DuplicateKey, node.keyNode.offset, node.keyNode.offset + node.keyNode.length, DiagnosticSeverity.Warning);
                            if (isObject(seen)) {
                                _errorAtRange(t("Duplicate object key"), ErrorCode.DuplicateKey, seen.keyNode.offset, seen.keyNode.offset + seen.keyNode.length, DiagnosticSeverity.Warning);
                            }
                            keysSeen[key.value] = true; // if the same key is duplicate again, avoid duplicate error reporting
                        } else {
                            keysSeen[key.value] = node;
                        }
                    }
                    if (scanner.getToken() === 6 /* Json.SyntaxKind.ColonToken */ ) {
                        node.colonOffset = scanner.getTokenOffset();
                        _scanNext(); // consume ColonToken
                    } else {
                        _error(t('Colon expected'), ErrorCode.ColonExpected);
                        if (scanner.getToken() === 10 /* Json.SyntaxKind.StringLiteral */  && textDocument.positionAt(key.offset + key.length).line < textDocument.positionAt(scanner.getTokenOffset()).line) {
                            node.length = key.length;
                            return node;
                        }
                    }
                    const value = _parseValue(node);
                    if (!value) {
                        return _error(t('Value expected'), ErrorCode.ValueExpected, node, [], [
                            2 /* Json.SyntaxKind.CloseBraceToken */ ,
                            5 /* Json.SyntaxKind.CommaToken */ 
                        ]);
                    }
                    node.valueNode = value;
                    node.length = value.offset + value.length - node.offset;
                    return node;
                }
                function _parseObject(parent) {
                    if (scanner.getToken() !== 1 /* Json.SyntaxKind.OpenBraceToken */ ) {
                        return undefined;
                    }
                    const node = new ObjectASTNodeImpl(parent, scanner.getTokenOffset());
                    const keysSeen = Object.create(null);
                    _scanNext(); // consume OpenBraceToken
                    let needsComma = false;
                    while(scanner.getToken() !== 2 /* Json.SyntaxKind.CloseBraceToken */  && scanner.getToken() !== 17 /* Json.SyntaxKind.EOF */ ){
                        if (scanner.getToken() === 5 /* Json.SyntaxKind.CommaToken */ ) {
                            if (!needsComma) {
                                _error(t('Property expected'), ErrorCode.PropertyExpected);
                            }
                            const commaOffset = scanner.getTokenOffset();
                            _scanNext(); // consume comma
                            if (scanner.getToken() === 2 /* Json.SyntaxKind.CloseBraceToken */ ) {
                                if (needsComma) {
                                    _errorAtRange(t('Trailing comma'), ErrorCode.TrailingComma, commaOffset, commaOffset + 1);
                                }
                                continue;
                            }
                        } else if (needsComma) {
                            _error(t('Expected comma'), ErrorCode.CommaExpected);
                        }
                        const property = _parseProperty(node, keysSeen);
                        if (!property) {
                            _error(t('Property expected'), ErrorCode.PropertyExpected, undefined, [], [
                                2 /* Json.SyntaxKind.CloseBraceToken */ ,
                                5 /* Json.SyntaxKind.CommaToken */ 
                            ]);
                        } else {
                            node.properties.push(property);
                        }
                        needsComma = true;
                    }
                    if (scanner.getToken() !== 2 /* Json.SyntaxKind.CloseBraceToken */ ) {
                        return _error(t('Expected comma or closing brace'), ErrorCode.CommaOrCloseBraceExpected, node);
                    }
                    return _finalize(node, true);
                }
                function _parseString(parent) {
                    if (scanner.getToken() !== 10 /* Json.SyntaxKind.StringLiteral */ ) {
                        return undefined;
                    }
                    const node = new StringASTNodeImpl(parent, scanner.getTokenOffset());
                    node.value = scanner.getTokenValue();
                    return _finalize(node, true);
                }
                function _parseNumber(parent) {
                    if (scanner.getToken() !== 11 /* Json.SyntaxKind.NumericLiteral */ ) {
                        return undefined;
                    }
                    const node = new NumberASTNodeImpl(parent, scanner.getTokenOffset());
                    if (scanner.getTokenError() === 0 /* Json.ScanError.None */ ) {
                        const tokenValue = scanner.getTokenValue();
                        try {
                            const numberValue = JSON.parse(tokenValue);
                            if (!isNumber(numberValue)) {
                                return _error(t('Invalid number format.'), ErrorCode.Undefined, node);
                            }
                            node.value = numberValue;
                        } catch (e) {
                            return _error(t('Invalid number format.'), ErrorCode.Undefined, node);
                        }
                        node.isInteger = tokenValue.indexOf('.') === -1;
                    }
                    return _finalize(node, true);
                }
                function _parseLiteral(parent) {
                    let node;
                    switch(scanner.getToken()){
                        case 7 /* Json.SyntaxKind.NullKeyword */ :
                            return _finalize(new NullASTNodeImpl(parent, scanner.getTokenOffset()), true);
                        case 8 /* Json.SyntaxKind.TrueKeyword */ :
                            return _finalize(new BooleanASTNodeImpl(parent, true, scanner.getTokenOffset()), true);
                        case 9 /* Json.SyntaxKind.FalseKeyword */ :
                            return _finalize(new BooleanASTNodeImpl(parent, false, scanner.getTokenOffset()), true);
                        default:
                            return undefined;
                    }
                }
                function _parseValue(parent) {
                    return _parseArray(parent) || _parseObject(parent) || _parseString(parent) || _parseNumber(parent) || _parseLiteral(parent);
                }
                let _root = undefined;
                const token = _scanNext();
                if (token !== 17 /* Json.SyntaxKind.EOF */ ) {
                    _root = _parseValue(_root);
                    if (!_root) {
                        _error(t('Expected a JSON object, array or literal.'), ErrorCode.Undefined);
                    } else if (scanner.getToken() !== 17 /* Json.SyntaxKind.EOF */ ) {
                        _error(t('End of file expected.'), ErrorCode.Undefined);
                    }
                }
                return new JSONDocument(_root, problems, commentRanges);
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/utils/json.js
            /*---------------------------------------------------------------------------------------------
*  Copyright (c) Microsoft Corporation. All rights reserved.
*  Licensed under the MIT License. See License.txt in the project root for license information.
*--------------------------------------------------------------------------------------------*/ function stringifyObject(obj, indent, stringifyLiteral) {
                if (obj !== null && typeof obj === 'object') {
                    const newIndent = indent + '\t';
                    if (Array.isArray(obj)) {
                        if (obj.length === 0) {
                            return '[]';
                        }
                        let result = '[\n';
                        for(let i = 0; i < obj.length; i++){
                            result += newIndent + stringifyObject(obj[i], newIndent, stringifyLiteral);
                            if (i < obj.length - 1) {
                                result += ',';
                            }
                            result += '\n';
                        }
                        result += indent + ']';
                        return result;
                    } else {
                        const keys = Object.keys(obj);
                        if (keys.length === 0) {
                            return '{}';
                        }
                        let result = '{\n';
                        for(let i = 0; i < keys.length; i++){
                            const key = keys[i];
                            result += newIndent + JSON.stringify(key) + ': ' + stringifyObject(obj[key], newIndent, stringifyLiteral);
                            if (i < keys.length - 1) {
                                result += ',';
                            }
                            result += '\n';
                        }
                        result += indent + '}';
                        return result;
                    }
                }
                return stringifyLiteral(obj);
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/services/jsonCompletion.js
            /* provided dependency */ var console = __nested_webpack_require_714846__(4364);
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ const valueCommitCharacters = [
                ',',
                '}',
                ']'
            ];
            const propertyCommitCharacters = [
                ':'
            ];
            class JSONCompletion {
                doResolve(item) {
                    for(let i = this.contributions.length - 1; i >= 0; i--){
                        const resolveCompletion = this.contributions[i].resolveCompletion;
                        if (resolveCompletion) {
                            const resolver = resolveCompletion(item);
                            if (resolver) {
                                return resolver;
                            }
                        }
                    }
                    return this.promiseConstructor.resolve(item);
                }
                doComplete(document1, position, doc) {
                    const result = {
                        items: [],
                        isIncomplete: false
                    };
                    const text = document1.getText();
                    const offset = document1.offsetAt(position);
                    let node = doc.getNodeFromOffset(offset, true);
                    if (this.isInComment(document1, node ? node.offset : 0, offset)) {
                        return Promise.resolve(result);
                    }
                    if (node && offset === node.offset + node.length && offset > 0) {
                        const ch = text[offset - 1];
                        if (node.type === 'object' && ch === '}' || node.type === 'array' && ch === ']') {
                            // after ] or }
                            node = node.parent;
                        }
                    }
                    const currentWord = this.getCurrentWord(document1, offset);
                    let overwriteRange;
                    if (node && (node.type === 'string' || node.type === 'number' || node.type === 'boolean' || node.type === 'null')) {
                        overwriteRange = Range.create(document1.positionAt(node.offset), document1.positionAt(node.offset + node.length));
                    } else {
                        let overwriteStart = offset - currentWord.length;
                        if (overwriteStart > 0 && text[overwriteStart - 1] === '"') {
                            overwriteStart--;
                        }
                        overwriteRange = Range.create(document1.positionAt(overwriteStart), position);
                    }
                    const supportsCommitCharacters = false; //this.doesSupportsCommitCharacters(); disabled for now, waiting for new API: https://github.com/microsoft/vscode/issues/42544
                    const proposed = new Map();
                    const collector = {
                        add: (suggestion)=>{
                            let label = suggestion.label;
                            const existing = proposed.get(label);
                            if (!existing) {
                                label = label.replace(/[\n]/g, '↵');
                                if (label.length > 60) {
                                    const shortendedLabel = label.substr(0, 57).trim() + '...';
                                    if (!proposed.has(shortendedLabel)) {
                                        label = shortendedLabel;
                                    }
                                }
                                suggestion.textEdit = TextEdit.replace(overwriteRange, suggestion.insertText);
                                if (supportsCommitCharacters) {
                                    suggestion.commitCharacters = suggestion.kind === main_CompletionItemKind.Property ? propertyCommitCharacters : valueCommitCharacters;
                                }
                                suggestion.label = label;
                                proposed.set(label, suggestion);
                                result.items.push(suggestion);
                            } else {
                                if (!existing.documentation) {
                                    existing.documentation = suggestion.documentation;
                                }
                                if (!existing.detail) {
                                    existing.detail = suggestion.detail;
                                }
                                if (!existing.labelDetails) {
                                    existing.labelDetails = suggestion.labelDetails;
                                }
                            }
                        },
                        setAsIncomplete: ()=>{
                            result.isIncomplete = true;
                        },
                        error: (message)=>{
                            console.error(message);
                        },
                        getNumberOfProposals: ()=>{
                            return result.items.length;
                        }
                    };
                    return this.schemaService.getSchemaForResource(document1.uri, doc).then((schema)=>{
                        const collectionPromises = [];
                        let addValue = true;
                        let currentKey = '';
                        let currentProperty = undefined;
                        if (node) {
                            if (node.type === 'string') {
                                const parent = node.parent;
                                if (parent && parent.type === 'property' && parent.keyNode === node) {
                                    addValue = !parent.valueNode;
                                    currentProperty = parent;
                                    currentKey = text.substr(node.offset + 1, node.length - 2);
                                    if (parent) {
                                        node = parent.parent;
                                    }
                                }
                            }
                        }
                        // proposals for properties
                        if (node && node.type === 'object') {
                            // don't suggest keys when the cursor is just before the opening curly brace
                            if (node.offset === offset) {
                                return result;
                            }
                            // don't suggest properties that are already present
                            const properties = node.properties;
                            properties.forEach((p)=>{
                                if (!currentProperty || currentProperty !== p) {
                                    proposed.set(p.keyNode.value, CompletionItem.create('__'));
                                }
                            });
                            let separatorAfter = '';
                            if (addValue) {
                                separatorAfter = this.evaluateSeparatorAfter(document1, document1.offsetAt(overwriteRange.end));
                            }
                            if (schema) {
                                // property proposals with schema
                                this.getPropertyCompletions(schema, doc, node, addValue, separatorAfter, collector);
                            } else {
                                // property proposals without schema
                                this.getSchemaLessPropertyCompletions(doc, node, currentKey, collector);
                            }
                            const location = jsonParser_getNodePath(node);
                            this.contributions.forEach((contribution)=>{
                                const collectPromise = contribution.collectPropertyCompletions(document1.uri, location, currentWord, addValue, separatorAfter === '', collector);
                                if (collectPromise) {
                                    collectionPromises.push(collectPromise);
                                }
                            });
                            if (!schema && currentWord.length > 0 && text.charAt(offset - currentWord.length - 1) !== '"') {
                                collector.add({
                                    kind: main_CompletionItemKind.Property,
                                    label: this.getLabelForValue(currentWord),
                                    insertText: this.getInsertTextForProperty(currentWord, undefined, false, separatorAfter),
                                    insertTextFormat: main_InsertTextFormat.Snippet,
                                    documentation: ''
                                });
                                collector.setAsIncomplete();
                            }
                        }
                        // proposals for values
                        const types = {};
                        if (schema) {
                            // value proposals with schema
                            this.getValueCompletions(schema, doc, node, offset, document1, collector, types);
                        } else {
                            // value proposals without schema
                            this.getSchemaLessValueCompletions(doc, node, offset, document1, collector);
                        }
                        if (this.contributions.length > 0) {
                            this.getContributedValueCompletions(doc, node, offset, document1, collector, collectionPromises);
                        }
                        return this.promiseConstructor.all(collectionPromises).then(()=>{
                            if (collector.getNumberOfProposals() === 0) {
                                let offsetForSeparator = offset;
                                if (node && (node.type === 'string' || node.type === 'number' || node.type === 'boolean' || node.type === 'null')) {
                                    offsetForSeparator = node.offset + node.length;
                                }
                                const separatorAfter = this.evaluateSeparatorAfter(document1, offsetForSeparator);
                                this.addFillerValueCompletions(types, separatorAfter, collector);
                            }
                            return result;
                        });
                    });
                }
                getPropertyCompletions(schema, doc, node, addValue, separatorAfter, collector) {
                    const matchingSchemas = doc.getMatchingSchemas(schema.schema, node.offset);
                    matchingSchemas.forEach((s)=>{
                        if (s.node === node && !s.inverted) {
                            const schemaProperties = s.schema.properties;
                            if (schemaProperties) {
                                Object.keys(schemaProperties).forEach((key)=>{
                                    const propertySchema = schemaProperties[key];
                                    if (typeof propertySchema === 'object' && !propertySchema.deprecationMessage && !propertySchema.doNotSuggest) {
                                        const proposal = {
                                            kind: main_CompletionItemKind.Property,
                                            label: key,
                                            insertText: this.getInsertTextForProperty(key, propertySchema, addValue, separatorAfter),
                                            insertTextFormat: main_InsertTextFormat.Snippet,
                                            filterText: this.getFilterTextForValue(key),
                                            documentation: this.fromMarkup(propertySchema.markdownDescription) || propertySchema.description || ''
                                        };
                                        if (propertySchema.suggestSortText !== undefined) {
                                            proposal.sortText = propertySchema.suggestSortText;
                                        }
                                        if (proposal.insertText && endsWith(proposal.insertText, `$1${separatorAfter}`)) {
                                            proposal.command = {
                                                title: 'Suggest',
                                                command: 'editor.action.triggerSuggest'
                                            };
                                        }
                                        collector.add(proposal);
                                    }
                                });
                            }
                            const schemaPropertyNames = s.schema.propertyNames;
                            if (typeof schemaPropertyNames === 'object' && !schemaPropertyNames.deprecationMessage && !schemaPropertyNames.doNotSuggest) {
                                const propertyNameCompletionItem = (name, enumDescription = undefined)=>{
                                    const proposal = {
                                        kind: main_CompletionItemKind.Property,
                                        label: name,
                                        insertText: this.getInsertTextForProperty(name, undefined, addValue, separatorAfter),
                                        insertTextFormat: main_InsertTextFormat.Snippet,
                                        filterText: this.getFilterTextForValue(name),
                                        documentation: enumDescription || this.fromMarkup(schemaPropertyNames.markdownDescription) || schemaPropertyNames.description || ''
                                    };
                                    if (schemaPropertyNames.suggestSortText !== undefined) {
                                        proposal.sortText = schemaPropertyNames.suggestSortText;
                                    }
                                    if (proposal.insertText && endsWith(proposal.insertText, `$1${separatorAfter}`)) {
                                        proposal.command = {
                                            title: 'Suggest',
                                            command: 'editor.action.triggerSuggest'
                                        };
                                    }
                                    collector.add(proposal);
                                };
                                if (schemaPropertyNames.enum) {
                                    for(let i = 0; i < schemaPropertyNames.enum.length; i++){
                                        let enumDescription = undefined;
                                        if (schemaPropertyNames.markdownEnumDescriptions && i < schemaPropertyNames.markdownEnumDescriptions.length) {
                                            enumDescription = this.fromMarkup(schemaPropertyNames.markdownEnumDescriptions[i]);
                                        } else if (schemaPropertyNames.enumDescriptions && i < schemaPropertyNames.enumDescriptions.length) {
                                            enumDescription = schemaPropertyNames.enumDescriptions[i];
                                        }
                                        propertyNameCompletionItem(schemaPropertyNames.enum[i], enumDescription);
                                    }
                                }
                                if (schemaPropertyNames.const) {
                                    propertyNameCompletionItem(schemaPropertyNames.const);
                                }
                            }
                        }
                    });
                }
                getSchemaLessPropertyCompletions(doc, node, currentKey, collector) {
                    const collectCompletionsForSimilarObject = (obj)=>{
                        obj.properties.forEach((p)=>{
                            const key = p.keyNode.value;
                            collector.add({
                                kind: main_CompletionItemKind.Property,
                                label: key,
                                insertText: this.getInsertTextForValue(key, ''),
                                insertTextFormat: main_InsertTextFormat.Snippet,
                                filterText: this.getFilterTextForValue(key),
                                documentation: ''
                            });
                        });
                    };
                    if (node.parent) {
                        if (node.parent.type === 'property') {
                            // if the object is a property value, check the tree for other objects that hang under a property of the same name
                            const parentKey = node.parent.keyNode.value;
                            doc.visit((n)=>{
                                if (n.type === 'property' && n !== node.parent && n.keyNode.value === parentKey && n.valueNode && n.valueNode.type === 'object') {
                                    collectCompletionsForSimilarObject(n.valueNode);
                                }
                                return true;
                            });
                        } else if (node.parent.type === 'array') {
                            // if the object is in an array, use all other array elements as similar objects
                            node.parent.items.forEach((n)=>{
                                if (n.type === 'object' && n !== node) {
                                    collectCompletionsForSimilarObject(n);
                                }
                            });
                        }
                    } else if (node.type === 'object') {
                        collector.add({
                            kind: main_CompletionItemKind.Property,
                            label: '$schema',
                            insertText: this.getInsertTextForProperty('$schema', undefined, true, ''),
                            insertTextFormat: main_InsertTextFormat.Snippet,
                            documentation: '',
                            filterText: this.getFilterTextForValue("$schema")
                        });
                    }
                }
                getSchemaLessValueCompletions(doc, node, offset, document1, collector) {
                    let offsetForSeparator = offset;
                    if (node && (node.type === 'string' || node.type === 'number' || node.type === 'boolean' || node.type === 'null')) {
                        offsetForSeparator = node.offset + node.length;
                        node = node.parent;
                    }
                    if (!node) {
                        collector.add({
                            kind: this.getSuggestionKind('object'),
                            label: 'Empty object',
                            insertText: this.getInsertTextForValue({}, ''),
                            insertTextFormat: main_InsertTextFormat.Snippet,
                            documentation: ''
                        });
                        collector.add({
                            kind: this.getSuggestionKind('array'),
                            label: 'Empty array',
                            insertText: this.getInsertTextForValue([], ''),
                            insertTextFormat: main_InsertTextFormat.Snippet,
                            documentation: ''
                        });
                        return;
                    }
                    const separatorAfter = this.evaluateSeparatorAfter(document1, offsetForSeparator);
                    const collectSuggestionsForValues = (value)=>{
                        if (value.parent && !jsonParser_contains(value.parent, offset, true)) {
                            collector.add({
                                kind: this.getSuggestionKind(value.type),
                                label: this.getLabelTextForMatchingNode(value, document1),
                                insertText: this.getInsertTextForMatchingNode(value, document1, separatorAfter),
                                insertTextFormat: main_InsertTextFormat.Snippet,
                                documentation: ''
                            });
                        }
                        if (value.type === 'boolean') {
                            this.addBooleanValueCompletion(!value.value, separatorAfter, collector);
                        }
                    };
                    if (node.type === 'property') {
                        if (offset > (node.colonOffset || 0)) {
                            const valueNode = node.valueNode;
                            if (valueNode && (offset > valueNode.offset + valueNode.length || valueNode.type === 'object' || valueNode.type === 'array')) {
                                return;
                            }
                            // suggest values at the same key
                            const parentKey = node.keyNode.value;
                            doc.visit((n)=>{
                                if (n.type === 'property' && n.keyNode.value === parentKey && n.valueNode) {
                                    collectSuggestionsForValues(n.valueNode);
                                }
                                return true;
                            });
                            if (parentKey === '$schema' && node.parent && !node.parent.parent) {
                                this.addDollarSchemaCompletions(separatorAfter, collector);
                            }
                        }
                    }
                    if (node.type === 'array') {
                        if (node.parent && node.parent.type === 'property') {
                            // suggest items of an array at the same key
                            const parentKey = node.parent.keyNode.value;
                            doc.visit((n)=>{
                                if (n.type === 'property' && n.keyNode.value === parentKey && n.valueNode && n.valueNode.type === 'array') {
                                    n.valueNode.items.forEach(collectSuggestionsForValues);
                                }
                                return true;
                            });
                        } else {
                            // suggest items in the same array
                            node.items.forEach(collectSuggestionsForValues);
                        }
                    }
                }
                getValueCompletions(schema, doc, node, offset, document1, collector, types) {
                    let offsetForSeparator = offset;
                    let parentKey = undefined;
                    let valueNode = undefined;
                    if (node && (node.type === 'string' || node.type === 'number' || node.type === 'boolean' || node.type === 'null')) {
                        offsetForSeparator = node.offset + node.length;
                        valueNode = node;
                        node = node.parent;
                    }
                    if (!node) {
                        this.addSchemaValueCompletions(schema.schema, '', collector, types);
                        return;
                    }
                    if (node.type === 'property' && offset > (node.colonOffset || 0)) {
                        const valueNode = node.valueNode;
                        if (valueNode && offset > valueNode.offset + valueNode.length) {
                            return; // we are past the value node
                        }
                        parentKey = node.keyNode.value;
                        node = node.parent;
                    }
                    if (node && (parentKey !== undefined || node.type === 'array')) {
                        const separatorAfter = this.evaluateSeparatorAfter(document1, offsetForSeparator);
                        const matchingSchemas = doc.getMatchingSchemas(schema.schema, node.offset, valueNode);
                        for (const s of matchingSchemas){
                            if (s.node === node && !s.inverted && s.schema) {
                                if (node.type === 'array' && s.schema.items) {
                                    let c = collector;
                                    if (s.schema.uniqueItems) {
                                        const existingValues = new Set();
                                        node.children.forEach((n)=>{
                                            if (n.type !== 'array' && n.type !== 'object') {
                                                existingValues.add(this.getLabelForValue(jsonParser_getNodeValue(n)));
                                            }
                                        });
                                        c = {
                                            ...collector,
                                            add (suggestion) {
                                                if (!existingValues.has(suggestion.label)) {
                                                    collector.add(suggestion);
                                                }
                                            }
                                        };
                                    }
                                    if (Array.isArray(s.schema.items)) {
                                        const index = this.findItemAtOffset(node, document1, offset);
                                        if (index < s.schema.items.length) {
                                            this.addSchemaValueCompletions(s.schema.items[index], separatorAfter, c, types);
                                        }
                                    } else {
                                        this.addSchemaValueCompletions(s.schema.items, separatorAfter, c, types);
                                    }
                                }
                                if (parentKey !== undefined) {
                                    let propertyMatched = false;
                                    if (s.schema.properties) {
                                        const propertySchema = s.schema.properties[parentKey];
                                        if (propertySchema) {
                                            propertyMatched = true;
                                            this.addSchemaValueCompletions(propertySchema, separatorAfter, collector, types);
                                        }
                                    }
                                    if (s.schema.patternProperties && !propertyMatched) {
                                        for (const pattern of Object.keys(s.schema.patternProperties)){
                                            var _regex;
                                            const regex = extendedRegExp(pattern);
                                            if ((_regex = regex) === null || _regex === void 0 ? void 0 : _regex.test(parentKey)) {
                                                propertyMatched = true;
                                                const propertySchema = s.schema.patternProperties[pattern];
                                                this.addSchemaValueCompletions(propertySchema, separatorAfter, collector, types);
                                            }
                                        }
                                    }
                                    if (s.schema.additionalProperties && !propertyMatched) {
                                        const propertySchema = s.schema.additionalProperties;
                                        this.addSchemaValueCompletions(propertySchema, separatorAfter, collector, types);
                                    }
                                }
                            }
                        }
                        if (parentKey === '$schema' && !node.parent) {
                            this.addDollarSchemaCompletions(separatorAfter, collector);
                        }
                        if (types['boolean']) {
                            this.addBooleanValueCompletion(true, separatorAfter, collector);
                            this.addBooleanValueCompletion(false, separatorAfter, collector);
                        }
                        if (types['null']) {
                            this.addNullValueCompletion(separatorAfter, collector);
                        }
                    }
                }
                getContributedValueCompletions(doc, node, offset, document1, collector, collectionPromises) {
                    if (!node) {
                        this.contributions.forEach((contribution)=>{
                            const collectPromise = contribution.collectDefaultCompletions(document1.uri, collector);
                            if (collectPromise) {
                                collectionPromises.push(collectPromise);
                            }
                        });
                    } else {
                        if (node.type === 'string' || node.type === 'number' || node.type === 'boolean' || node.type === 'null') {
                            node = node.parent;
                        }
                        if (node && node.type === 'property' && offset > (node.colonOffset || 0)) {
                            const parentKey = node.keyNode.value;
                            const valueNode = node.valueNode;
                            if ((!valueNode || offset <= valueNode.offset + valueNode.length) && node.parent) {
                                const location = jsonParser_getNodePath(node.parent);
                                this.contributions.forEach((contribution)=>{
                                    const collectPromise = contribution.collectValueCompletions(document1.uri, location, parentKey, collector);
                                    if (collectPromise) {
                                        collectionPromises.push(collectPromise);
                                    }
                                });
                            }
                        }
                    }
                }
                addSchemaValueCompletions(schema, separatorAfter, collector, types) {
                    if (typeof schema === 'object') {
                        this.addEnumValueCompletions(schema, separatorAfter, collector);
                        this.addDefaultValueCompletions(schema, separatorAfter, collector);
                        this.collectTypes(schema, types);
                        if (Array.isArray(schema.allOf)) {
                            schema.allOf.forEach((s)=>this.addSchemaValueCompletions(s, separatorAfter, collector, types));
                        }
                        if (Array.isArray(schema.anyOf)) {
                            schema.anyOf.forEach((s)=>this.addSchemaValueCompletions(s, separatorAfter, collector, types));
                        }
                        if (Array.isArray(schema.oneOf)) {
                            schema.oneOf.forEach((s)=>this.addSchemaValueCompletions(s, separatorAfter, collector, types));
                        }
                    }
                }
                addDefaultValueCompletions(schema, separatorAfter, collector, arrayDepth = 0) {
                    let hasProposals = false;
                    if (isDefined(schema.default)) {
                        let type = schema.type;
                        let value = schema.default;
                        for(let i = arrayDepth; i > 0; i--){
                            value = [
                                value
                            ];
                            type = 'array';
                        }
                        const completionItem = {
                            kind: this.getSuggestionKind(type),
                            label: this.getLabelForValue(value),
                            insertText: this.getInsertTextForValue(value, separatorAfter),
                            insertTextFormat: main_InsertTextFormat.Snippet
                        };
                        if (this.doesSupportsLabelDetails()) {
                            completionItem.labelDetails = {
                                description: t('Default value')
                            };
                        } else {
                            completionItem.detail = t('Default value');
                        }
                        collector.add(completionItem);
                        hasProposals = true;
                    }
                    if (Array.isArray(schema.examples)) {
                        schema.examples.forEach((example)=>{
                            let type = schema.type;
                            let value = example;
                            for(let i = arrayDepth; i > 0; i--){
                                value = [
                                    value
                                ];
                                type = 'array';
                            }
                            collector.add({
                                kind: this.getSuggestionKind(type),
                                label: this.getLabelForValue(value),
                                insertText: this.getInsertTextForValue(value, separatorAfter),
                                insertTextFormat: main_InsertTextFormat.Snippet
                            });
                            hasProposals = true;
                        });
                    }
                    if (Array.isArray(schema.defaultSnippets)) {
                        schema.defaultSnippets.forEach((s)=>{
                            let type = schema.type;
                            let value = s.body;
                            let label = s.label;
                            let insertText;
                            let filterText;
                            if (isDefined(value)) {
                                let type = schema.type;
                                for(let i = arrayDepth; i > 0; i--){
                                    value = [
                                        value
                                    ];
                                    type = 'array';
                                }
                                insertText = this.getInsertTextForSnippetValue(value, separatorAfter);
                                filterText = this.getFilterTextForSnippetValue(value);
                                label = label || this.getLabelForSnippetValue(value);
                            } else if (typeof s.bodyText === 'string') {
                                let prefix = '', suffix = '', indent = '';
                                for(let i = arrayDepth; i > 0; i--){
                                    prefix = prefix + indent + '[\n';
                                    suffix = suffix + '\n' + indent + ']';
                                    indent += '\t';
                                    type = 'array';
                                }
                                insertText = prefix + indent + s.bodyText.split('\n').join('\n' + indent) + suffix + separatorAfter;
                                label = label || insertText, filterText = insertText.replace(/[\n]/g, ''); // remove new lines
                            } else {
                                return;
                            }
                            collector.add({
                                kind: this.getSuggestionKind(type),
                                label,
                                documentation: this.fromMarkup(s.markdownDescription) || s.description,
                                insertText,
                                insertTextFormat: main_InsertTextFormat.Snippet,
                                filterText
                            });
                            hasProposals = true;
                        });
                    }
                    if (!hasProposals && typeof schema.items === 'object' && !Array.isArray(schema.items) && arrayDepth < 5 /* beware of recursion */ ) {
                        this.addDefaultValueCompletions(schema.items, separatorAfter, collector, arrayDepth + 1);
                    }
                }
                addEnumValueCompletions(schema, separatorAfter, collector) {
                    if (isDefined(schema.const)) {
                        collector.add({
                            kind: this.getSuggestionKind(schema.type),
                            label: this.getLabelForValue(schema.const),
                            insertText: this.getInsertTextForValue(schema.const, separatorAfter),
                            insertTextFormat: main_InsertTextFormat.Snippet,
                            documentation: this.fromMarkup(schema.markdownDescription) || schema.description
                        });
                    }
                    if (Array.isArray(schema.enum)) {
                        for(let i = 0, length = schema.enum.length; i < length; i++){
                            const enm = schema.enum[i];
                            let documentation = this.fromMarkup(schema.markdownDescription) || schema.description;
                            if (schema.markdownEnumDescriptions && i < schema.markdownEnumDescriptions.length && this.doesSupportMarkdown()) {
                                documentation = this.fromMarkup(schema.markdownEnumDescriptions[i]);
                            } else if (schema.enumDescriptions && i < schema.enumDescriptions.length) {
                                documentation = schema.enumDescriptions[i];
                            }
                            collector.add({
                                kind: this.getSuggestionKind(schema.type),
                                label: this.getLabelForValue(enm),
                                insertText: this.getInsertTextForValue(enm, separatorAfter),
                                insertTextFormat: main_InsertTextFormat.Snippet,
                                documentation
                            });
                        }
                    }
                }
                collectTypes(schema, types) {
                    if (Array.isArray(schema.enum) || isDefined(schema.const)) {
                        return;
                    }
                    const type = schema.type;
                    if (Array.isArray(type)) {
                        type.forEach((t)=>types[t] = true);
                    } else if (type) {
                        types[type] = true;
                    }
                }
                addFillerValueCompletions(types, separatorAfter, collector) {
                    if (types['object']) {
                        collector.add({
                            kind: this.getSuggestionKind('object'),
                            label: '{}',
                            insertText: this.getInsertTextForGuessedValue({}, separatorAfter),
                            insertTextFormat: main_InsertTextFormat.Snippet,
                            detail: t('New object'),
                            documentation: ''
                        });
                    }
                    if (types['array']) {
                        collector.add({
                            kind: this.getSuggestionKind('array'),
                            label: '[]',
                            insertText: this.getInsertTextForGuessedValue([], separatorAfter),
                            insertTextFormat: main_InsertTextFormat.Snippet,
                            detail: t('New array'),
                            documentation: ''
                        });
                    }
                }
                addBooleanValueCompletion(value, separatorAfter, collector) {
                    collector.add({
                        kind: this.getSuggestionKind('boolean'),
                        label: value ? 'true' : 'false',
                        insertText: this.getInsertTextForValue(value, separatorAfter),
                        insertTextFormat: main_InsertTextFormat.Snippet,
                        documentation: ''
                    });
                }
                addNullValueCompletion(separatorAfter, collector) {
                    collector.add({
                        kind: this.getSuggestionKind('null'),
                        label: 'null',
                        insertText: 'null' + separatorAfter,
                        insertTextFormat: main_InsertTextFormat.Snippet,
                        documentation: ''
                    });
                }
                addDollarSchemaCompletions(separatorAfter, collector) {
                    const schemaIds = this.schemaService.getRegisteredSchemaIds((schema)=>schema === 'http' || schema === 'https');
                    schemaIds.forEach((schemaId)=>{
                        if (schemaId.startsWith('http://json-schema.org/draft-')) {
                            schemaId = schemaId + '#';
                        }
                        collector.add({
                            kind: main_CompletionItemKind.Module,
                            label: this.getLabelForValue(schemaId),
                            filterText: this.getFilterTextForValue(schemaId),
                            insertText: this.getInsertTextForValue(schemaId, separatorAfter),
                            insertTextFormat: main_InsertTextFormat.Snippet,
                            documentation: ''
                        });
                    });
                }
                getLabelForValue(value) {
                    return JSON.stringify(value);
                }
                getValueFromLabel(value) {
                    return JSON.parse(value);
                }
                getFilterTextForValue(value) {
                    return JSON.stringify(value);
                }
                getFilterTextForSnippetValue(value) {
                    return JSON.stringify(value).replace(/\$\{\d+:([^}]+)\}|\$\d+/g, '$1');
                }
                getLabelForSnippetValue(value) {
                    const label = JSON.stringify(value);
                    return label.replace(/\$\{\d+:([^}]+)\}|\$\d+/g, '$1');
                }
                getInsertTextForPlainText(text) {
                    return text.replace(/[\\\$\}]/g, '\\$&'); // escape $, \ and }
                }
                getInsertTextForValue(value, separatorAfter) {
                    const text = JSON.stringify(value, null, '\t');
                    if (text === '{}') {
                        return '{$1}' + separatorAfter;
                    } else if (text === '[]') {
                        return '[$1]' + separatorAfter;
                    }
                    return this.getInsertTextForPlainText(text + separatorAfter);
                }
                getInsertTextForSnippetValue(value, separatorAfter) {
                    const replacer = (value)=>{
                        if (typeof value === 'string') {
                            if (value[0] === '^') {
                                return value.substr(1);
                            }
                        }
                        return JSON.stringify(value);
                    };
                    return stringifyObject(value, '', replacer) + separatorAfter;
                }
                getInsertTextForGuessedValue(value, separatorAfter) {
                    switch(typeof value){
                        case 'object':
                            if (value === null) {
                                return '${1:null}' + separatorAfter;
                            }
                            return this.getInsertTextForValue(value, separatorAfter);
                        case 'string':
                            let snippetValue = JSON.stringify(value);
                            snippetValue = snippetValue.substr(1, snippetValue.length - 2); // remove quotes
                            snippetValue = this.getInsertTextForPlainText(snippetValue); // escape \ and }
                            return '"${1:' + snippetValue + '}"' + separatorAfter;
                        case 'number':
                        case 'boolean':
                            return '${1:' + JSON.stringify(value) + '}' + separatorAfter;
                    }
                    return this.getInsertTextForValue(value, separatorAfter);
                }
                getSuggestionKind(type) {
                    if (Array.isArray(type)) {
                        const array = type;
                        type = array.length > 0 ? array[0] : undefined;
                    }
                    if (!type) {
                        return main_CompletionItemKind.Value;
                    }
                    switch(type){
                        case 'string':
                            return main_CompletionItemKind.Value;
                        case 'object':
                            return main_CompletionItemKind.Module;
                        case 'property':
                            return main_CompletionItemKind.Property;
                        default:
                            return main_CompletionItemKind.Value;
                    }
                }
                getLabelTextForMatchingNode(node, document1) {
                    switch(node.type){
                        case 'array':
                            return '[]';
                        case 'object':
                            return '{}';
                        default:
                            const content = document1.getText().substr(node.offset, node.length);
                            return content;
                    }
                }
                getInsertTextForMatchingNode(node, document1, separatorAfter) {
                    switch(node.type){
                        case 'array':
                            return this.getInsertTextForValue([], separatorAfter);
                        case 'object':
                            return this.getInsertTextForValue({}, separatorAfter);
                        default:
                            const content = document1.getText().substr(node.offset, node.length) + separatorAfter;
                            return this.getInsertTextForPlainText(content);
                    }
                }
                getInsertTextForProperty(key, propertySchema, addValue, separatorAfter) {
                    const propertyText = this.getInsertTextForValue(key, '');
                    if (!addValue) {
                        return propertyText;
                    }
                    const resultText = propertyText + ': ';
                    let value;
                    let nValueProposals = 0;
                    if (propertySchema) {
                        if (Array.isArray(propertySchema.defaultSnippets)) {
                            if (propertySchema.defaultSnippets.length === 1) {
                                const body = propertySchema.defaultSnippets[0].body;
                                if (isDefined(body)) {
                                    value = this.getInsertTextForSnippetValue(body, '');
                                }
                            }
                            nValueProposals += propertySchema.defaultSnippets.length;
                        }
                        if (propertySchema.enum) {
                            if (!value && propertySchema.enum.length === 1) {
                                value = this.getInsertTextForGuessedValue(propertySchema.enum[0], '');
                            }
                            nValueProposals += propertySchema.enum.length;
                        }
                        if (isDefined(propertySchema.const)) {
                            if (!value) {
                                value = this.getInsertTextForGuessedValue(propertySchema.const, '');
                            }
                            nValueProposals++;
                        }
                        if (isDefined(propertySchema.default)) {
                            if (!value) {
                                value = this.getInsertTextForGuessedValue(propertySchema.default, '');
                            }
                            nValueProposals++;
                        }
                        if (Array.isArray(propertySchema.examples) && propertySchema.examples.length) {
                            if (!value) {
                                value = this.getInsertTextForGuessedValue(propertySchema.examples[0], '');
                            }
                            nValueProposals += propertySchema.examples.length;
                        }
                        if (nValueProposals === 0) {
                            let type = Array.isArray(propertySchema.type) ? propertySchema.type[0] : propertySchema.type;
                            if (!type) {
                                if (propertySchema.properties) {
                                    type = 'object';
                                } else if (propertySchema.items) {
                                    type = 'array';
                                }
                            }
                            switch(type){
                                case 'boolean':
                                    value = '$1';
                                    break;
                                case 'string':
                                    value = '"$1"';
                                    break;
                                case 'object':
                                    value = '{$1}';
                                    break;
                                case 'array':
                                    value = '[$1]';
                                    break;
                                case 'number':
                                case 'integer':
                                    value = '${1:0}';
                                    break;
                                case 'null':
                                    value = '${1:null}';
                                    break;
                                default:
                                    return propertyText;
                            }
                        }
                    }
                    if (!value || nValueProposals > 1) {
                        value = '$1';
                    }
                    return resultText + value + separatorAfter;
                }
                getCurrentWord(document1, offset) {
                    let i = offset - 1;
                    const text = document1.getText();
                    while(i >= 0 && ' \t\n\r\v":{[,]}'.indexOf(text.charAt(i)) === -1){
                        i--;
                    }
                    return text.substring(i + 1, offset);
                }
                evaluateSeparatorAfter(document1, offset) {
                    const scanner = main_createScanner(document1.getText(), true);
                    scanner.setPosition(offset);
                    const token = scanner.scan();
                    switch(token){
                        case 5 /* Json.SyntaxKind.CommaToken */ :
                        case 2 /* Json.SyntaxKind.CloseBraceToken */ :
                        case 4 /* Json.SyntaxKind.CloseBracketToken */ :
                        case 17 /* Json.SyntaxKind.EOF */ :
                            return '';
                        default:
                            return ',';
                    }
                }
                findItemAtOffset(node, document1, offset) {
                    const scanner = main_createScanner(document1.getText(), true);
                    const children = node.items;
                    for(let i = children.length - 1; i >= 0; i--){
                        const child = children[i];
                        if (offset > child.offset + child.length) {
                            scanner.setPosition(child.offset + child.length);
                            const token = scanner.scan();
                            if (token === 5 /* Json.SyntaxKind.CommaToken */  && offset >= scanner.getTokenOffset() + scanner.getTokenLength()) {
                                return i + 1;
                            }
                            return i;
                        } else if (offset >= child.offset) {
                            return i;
                        }
                    }
                    return 0;
                }
                isInComment(document1, start, offset) {
                    const scanner = main_createScanner(document1.getText(), false);
                    scanner.setPosition(start);
                    let token = scanner.scan();
                    while(token !== 17 /* Json.SyntaxKind.EOF */  && scanner.getTokenOffset() + scanner.getTokenLength() < offset){
                        token = scanner.scan();
                    }
                    return (token === 12 /* Json.SyntaxKind.LineCommentTrivia */  || token === 13 /* Json.SyntaxKind.BlockCommentTrivia */ ) && scanner.getTokenOffset() <= offset;
                }
                fromMarkup(markupString) {
                    if (markupString && this.doesSupportMarkdown()) {
                        return {
                            kind: MarkupKind.Markdown,
                            value: markupString
                        };
                    }
                    return undefined;
                }
                doesSupportMarkdown() {
                    if (!isDefined(this.supportsMarkdown)) {
                        var _this_clientCapabilities_textDocument_completion_completionItem, _this_clientCapabilities_textDocument_completion, _this_clientCapabilities_textDocument;
                        const documentationFormat = (_this_clientCapabilities_textDocument = this.clientCapabilities.textDocument) === null || _this_clientCapabilities_textDocument === void 0 ? void 0 : (_this_clientCapabilities_textDocument_completion = _this_clientCapabilities_textDocument.completion) === null || _this_clientCapabilities_textDocument_completion === void 0 ? void 0 : (_this_clientCapabilities_textDocument_completion_completionItem = _this_clientCapabilities_textDocument_completion.completionItem) === null || _this_clientCapabilities_textDocument_completion_completionItem === void 0 ? void 0 : _this_clientCapabilities_textDocument_completion_completionItem.documentationFormat;
                        this.supportsMarkdown = Array.isArray(documentationFormat) && documentationFormat.indexOf(MarkupKind.Markdown) !== -1;
                    }
                    return this.supportsMarkdown;
                }
                doesSupportsCommitCharacters() {
                    if (!isDefined(this.supportsCommitCharacters)) {
                        var _this_clientCapabilities_textDocument_completion_completionItem, _this_clientCapabilities_textDocument_completion, _this_clientCapabilities_textDocument;
                        this.labelDetailsSupport = (_this_clientCapabilities_textDocument = this.clientCapabilities.textDocument) === null || _this_clientCapabilities_textDocument === void 0 ? void 0 : (_this_clientCapabilities_textDocument_completion = _this_clientCapabilities_textDocument.completion) === null || _this_clientCapabilities_textDocument_completion === void 0 ? void 0 : (_this_clientCapabilities_textDocument_completion_completionItem = _this_clientCapabilities_textDocument_completion.completionItem) === null || _this_clientCapabilities_textDocument_completion_completionItem === void 0 ? void 0 : _this_clientCapabilities_textDocument_completion_completionItem.commitCharactersSupport;
                    }
                    return this.supportsCommitCharacters;
                }
                doesSupportsLabelDetails() {
                    if (!isDefined(this.labelDetailsSupport)) {
                        var _this_clientCapabilities_textDocument_completion_completionItem, _this_clientCapabilities_textDocument_completion, _this_clientCapabilities_textDocument;
                        this.labelDetailsSupport = (_this_clientCapabilities_textDocument = this.clientCapabilities.textDocument) === null || _this_clientCapabilities_textDocument === void 0 ? void 0 : (_this_clientCapabilities_textDocument_completion = _this_clientCapabilities_textDocument.completion) === null || _this_clientCapabilities_textDocument_completion === void 0 ? void 0 : (_this_clientCapabilities_textDocument_completion_completionItem = _this_clientCapabilities_textDocument_completion.completionItem) === null || _this_clientCapabilities_textDocument_completion_completionItem === void 0 ? void 0 : _this_clientCapabilities_textDocument_completion_completionItem.labelDetailsSupport;
                    }
                    return this.labelDetailsSupport;
                }
                constructor(schemaService, contributions = [], promiseConstructor = Promise, clientCapabilities = {}){
                    this.schemaService = schemaService;
                    this.contributions = contributions;
                    this.promiseConstructor = promiseConstructor;
                    this.clientCapabilities = clientCapabilities;
                }
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/services/jsonHover.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ class JSONHover {
                doHover(document1, position, doc) {
                    const offset = document1.offsetAt(position);
                    let node = doc.getNodeFromOffset(offset);
                    if (!node || (node.type === 'object' || node.type === 'array') && offset > node.offset + 1 && offset < node.offset + node.length - 1) {
                        return this.promise.resolve(null);
                    }
                    const hoverRangeNode = node;
                    // use the property description when hovering over an object key
                    if (node.type === 'string') {
                        const parent = node.parent;
                        if (parent && parent.type === 'property' && parent.keyNode === node) {
                            node = parent.valueNode;
                            if (!node) {
                                return this.promise.resolve(null);
                            }
                        }
                    }
                    const hoverRange = Range.create(document1.positionAt(hoverRangeNode.offset), document1.positionAt(hoverRangeNode.offset + hoverRangeNode.length));
                    const createHover = (contents)=>{
                        const result = {
                            contents: contents,
                            range: hoverRange
                        };
                        return result;
                    };
                    const location = jsonParser_getNodePath(node);
                    for(let i = this.contributions.length - 1; i >= 0; i--){
                        const contribution = this.contributions[i];
                        const promise = contribution.getInfoContribution(document1.uri, location);
                        if (promise) {
                            return promise.then((htmlContent)=>createHover(htmlContent));
                        }
                    }
                    return this.schemaService.getSchemaForResource(document1.uri, doc).then((schema)=>{
                        if (schema && node) {
                            const matchingSchemas = doc.getMatchingSchemas(schema.schema, node.offset);
                            let title = undefined;
                            let markdownDescription = undefined;
                            let markdownEnumValueDescription = undefined, enumValue = undefined;
                            matchingSchemas.every((s)=>{
                                if (s.node === node && !s.inverted && s.schema) {
                                    title = title || s.schema.title;
                                    markdownDescription = markdownDescription || s.schema.markdownDescription || toMarkdown(s.schema.description);
                                    if (s.schema.enum) {
                                        const idx = s.schema.enum.indexOf(jsonParser_getNodeValue(node));
                                        if (s.schema.markdownEnumDescriptions) {
                                            markdownEnumValueDescription = s.schema.markdownEnumDescriptions[idx];
                                        } else if (s.schema.enumDescriptions) {
                                            markdownEnumValueDescription = toMarkdown(s.schema.enumDescriptions[idx]);
                                        }
                                        if (markdownEnumValueDescription) {
                                            enumValue = s.schema.enum[idx];
                                            if (typeof enumValue !== 'string') {
                                                enumValue = JSON.stringify(enumValue);
                                            }
                                        }
                                    }
                                }
                                return true;
                            });
                            let result = '';
                            if (title) {
                                result = toMarkdown(title);
                            }
                            if (markdownDescription) {
                                if (result.length > 0) {
                                    result += "\n\n";
                                }
                                result += markdownDescription;
                            }
                            if (markdownEnumValueDescription) {
                                if (result.length > 0) {
                                    result += "\n\n";
                                }
                                result += `\`${toMarkdownCodeBlock(enumValue)}\`: ${markdownEnumValueDescription}`;
                            }
                            return createHover([
                                result
                            ]);
                        }
                        return null;
                    });
                }
                constructor(schemaService, contributions = [], promiseConstructor){
                    this.schemaService = schemaService;
                    this.contributions = contributions;
                    this.promise = promiseConstructor || Promise;
                }
            }
            function toMarkdown(plain) {
                if (plain) {
                    const res = plain.replace(/([^\n\r])(\r?\n)([^\n\r])/gm, '$1\n\n$3'); // single new lines to \n\n (Markdown paragraph)
                    return res.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&"); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
                }
                return undefined;
            }
            function toMarkdownCodeBlock(content) {
                // see https://daringfireball.net/projects/markdown/syntax#precode
                if (content.indexOf('`') !== -1) {
                    return '`` ' + content + ' ``';
                }
                return content;
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/services/jsonValidation.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ class JSONValidation {
                configure(raw) {
                    if (raw) {
                        this.validationEnabled = raw.validate !== false;
                        this.commentSeverity = raw.allowComments ? undefined : DiagnosticSeverity.Error;
                    }
                }
                doValidation(textDocument, jsonDocument, documentSettings, schema) {
                    if (!this.validationEnabled) {
                        return this.promise.resolve([]);
                    }
                    const diagnostics = [];
                    const added = {};
                    const addProblem = (problem)=>{
                        // remove duplicated messages
                        const signature = problem.range.start.line + ' ' + problem.range.start.character + ' ' + problem.message;
                        if (!added[signature]) {
                            added[signature] = true;
                            diagnostics.push(problem);
                        }
                    };
                    const getDiagnostics = (schema)=>{
                        var _documentSettings, _documentSettings1, _documentSettings2, _documentSettings3;
                        let trailingCommaSeverity = ((_documentSettings = documentSettings) === null || _documentSettings === void 0 ? void 0 : _documentSettings.trailingCommas) ? toDiagnosticSeverity(documentSettings.trailingCommas) : DiagnosticSeverity.Error;
                        let commentSeverity = ((_documentSettings1 = documentSettings) === null || _documentSettings1 === void 0 ? void 0 : _documentSettings1.comments) ? toDiagnosticSeverity(documentSettings.comments) : this.commentSeverity;
                        let schemaValidation = ((_documentSettings2 = documentSettings) === null || _documentSettings2 === void 0 ? void 0 : _documentSettings2.schemaValidation) ? toDiagnosticSeverity(documentSettings.schemaValidation) : DiagnosticSeverity.Warning;
                        let schemaRequest = ((_documentSettings3 = documentSettings) === null || _documentSettings3 === void 0 ? void 0 : _documentSettings3.schemaRequest) ? toDiagnosticSeverity(documentSettings.schemaRequest) : DiagnosticSeverity.Warning;
                        if (schema) {
                            const addSchemaProblem = (errorMessage, errorCode)=>{
                                if (jsonDocument.root && schemaRequest) {
                                    const astRoot = jsonDocument.root;
                                    const property = astRoot.type === 'object' ? astRoot.properties[0] : undefined;
                                    if (property && property.keyNode.value === '$schema') {
                                        const node = property.valueNode || property;
                                        const range = Range.create(textDocument.positionAt(node.offset), textDocument.positionAt(node.offset + node.length));
                                        addProblem(Diagnostic.create(range, errorMessage, schemaRequest, errorCode));
                                    } else {
                                        const range = Range.create(textDocument.positionAt(astRoot.offset), textDocument.positionAt(astRoot.offset + 1));
                                        addProblem(Diagnostic.create(range, errorMessage, schemaRequest, errorCode));
                                    }
                                }
                            };
                            if (schema.errors.length) {
                                addSchemaProblem(schema.errors[0], ErrorCode.SchemaResolveError);
                            } else if (schemaValidation) {
                                var _documentSettings4;
                                for (const warning of schema.warnings){
                                    addSchemaProblem(warning, ErrorCode.SchemaUnsupportedFeature);
                                }
                                const semanticErrors = jsonDocument.validate(textDocument, schema.schema, schemaValidation, (_documentSettings4 = documentSettings) === null || _documentSettings4 === void 0 ? void 0 : _documentSettings4.schemaDraft);
                                if (semanticErrors) {
                                    semanticErrors.forEach(addProblem);
                                }
                            }
                            if (schemaAllowsComments(schema.schema)) {
                                commentSeverity = undefined;
                            }
                            if (schemaAllowsTrailingCommas(schema.schema)) {
                                trailingCommaSeverity = undefined;
                            }
                        }
                        for (const p of jsonDocument.syntaxErrors){
                            if (p.code === ErrorCode.TrailingComma) {
                                if (typeof trailingCommaSeverity !== 'number') {
                                    continue;
                                }
                                p.severity = trailingCommaSeverity;
                            }
                            addProblem(p);
                        }
                        if (typeof commentSeverity === 'number') {
                            const message = t('Comments are not permitted in JSON.');
                            jsonDocument.comments.forEach((c)=>{
                                addProblem(Diagnostic.create(c, message, commentSeverity, ErrorCode.CommentNotPermitted));
                            });
                        }
                        return diagnostics;
                    };
                    if (schema) {
                        const uri = schema.id || 'schemaservice://untitled/' + idCounter++;
                        const handle = this.jsonSchemaService.registerExternalSchema({
                            uri,
                            schema
                        });
                        return handle.getResolvedSchema().then((resolvedSchema)=>{
                            return getDiagnostics(resolvedSchema);
                        });
                    }
                    return this.jsonSchemaService.getSchemaForResource(textDocument.uri, jsonDocument).then((schema)=>{
                        return getDiagnostics(schema);
                    });
                }
                getLanguageStatus(textDocument, jsonDocument) {
                    return {
                        schemas: this.jsonSchemaService.getSchemaURIsForResource(textDocument.uri, jsonDocument)
                    };
                }
                constructor(jsonSchemaService, promiseConstructor){
                    this.jsonSchemaService = jsonSchemaService;
                    this.promise = promiseConstructor;
                    this.validationEnabled = true;
                }
            }
            let idCounter = 0;
            function schemaAllowsComments(schemaRef) {
                if (schemaRef && typeof schemaRef === 'object') {
                    if (isBoolean(schemaRef.allowComments)) {
                        return schemaRef.allowComments;
                    }
                    if (schemaRef.allOf) {
                        for (const schema of schemaRef.allOf){
                            const allow = schemaAllowsComments(schema);
                            if (isBoolean(allow)) {
                                return allow;
                            }
                        }
                    }
                }
                return undefined;
            }
            function schemaAllowsTrailingCommas(schemaRef) {
                if (schemaRef && typeof schemaRef === 'object') {
                    if (isBoolean(schemaRef.allowTrailingCommas)) {
                        return schemaRef.allowTrailingCommas;
                    }
                    const deprSchemaRef = schemaRef;
                    if (isBoolean(deprSchemaRef['allowsTrailingCommas'])) {
                        return deprSchemaRef['allowsTrailingCommas'];
                    }
                    if (schemaRef.allOf) {
                        for (const schema of schemaRef.allOf){
                            const allow = schemaAllowsTrailingCommas(schema);
                            if (isBoolean(allow)) {
                                return allow;
                            }
                        }
                    }
                }
                return undefined;
            }
            function toDiagnosticSeverity(severityLevel) {
                switch(severityLevel){
                    case 'error':
                        return DiagnosticSeverity.Error;
                    case 'warning':
                        return DiagnosticSeverity.Warning;
                    case 'ignore':
                        return undefined;
                }
                return undefined;
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/utils/colors.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ const Digit0 = 48;
            const Digit9 = 57;
            const A = 65;
            const a = 97;
            const f = 102;
            function hexDigit(charCode) {
                if (charCode < Digit0) {
                    return 0;
                }
                if (charCode <= Digit9) {
                    return charCode - Digit0;
                }
                if (charCode < a) {
                    charCode += a - A;
                }
                if (charCode >= a && charCode <= f) {
                    return charCode - a + 10;
                }
                return 0;
            }
            function colorFromHex(text) {
                if (text[0] !== '#') {
                    return undefined;
                }
                switch(text.length){
                    case 4:
                        return {
                            red: hexDigit(text.charCodeAt(1)) * 0x11 / 255.0,
                            green: hexDigit(text.charCodeAt(2)) * 0x11 / 255.0,
                            blue: hexDigit(text.charCodeAt(3)) * 0x11 / 255.0,
                            alpha: 1
                        };
                    case 5:
                        return {
                            red: hexDigit(text.charCodeAt(1)) * 0x11 / 255.0,
                            green: hexDigit(text.charCodeAt(2)) * 0x11 / 255.0,
                            blue: hexDigit(text.charCodeAt(3)) * 0x11 / 255.0,
                            alpha: hexDigit(text.charCodeAt(4)) * 0x11 / 255.0
                        };
                    case 7:
                        return {
                            red: (hexDigit(text.charCodeAt(1)) * 0x10 + hexDigit(text.charCodeAt(2))) / 255.0,
                            green: (hexDigit(text.charCodeAt(3)) * 0x10 + hexDigit(text.charCodeAt(4))) / 255.0,
                            blue: (hexDigit(text.charCodeAt(5)) * 0x10 + hexDigit(text.charCodeAt(6))) / 255.0,
                            alpha: 1
                        };
                    case 9:
                        return {
                            red: (hexDigit(text.charCodeAt(1)) * 0x10 + hexDigit(text.charCodeAt(2))) / 255.0,
                            green: (hexDigit(text.charCodeAt(3)) * 0x10 + hexDigit(text.charCodeAt(4))) / 255.0,
                            blue: (hexDigit(text.charCodeAt(5)) * 0x10 + hexDigit(text.charCodeAt(6))) / 255.0,
                            alpha: (hexDigit(text.charCodeAt(7)) * 0x10 + hexDigit(text.charCodeAt(8))) / 255.0
                        };
                }
                return undefined;
            }
            function colorFrom256RGB(red, green, blue, alpha = 1.0) {
                return {
                    red: red / 255.0,
                    green: green / 255.0,
                    blue: blue / 255.0,
                    alpha
                };
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/services/jsonDocumentSymbols.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ class JSONDocumentSymbols {
                findDocumentSymbols(document1, doc, context = {
                    resultLimit: Number.MAX_VALUE
                }) {
                    const root = doc.root;
                    if (!root) {
                        return [];
                    }
                    let limit = context.resultLimit || Number.MAX_VALUE;
                    // special handling for key bindings
                    const resourceString = document1.uri;
                    if (resourceString === 'vscode://defaultsettings/keybindings.json' || endsWith(resourceString.toLowerCase(), '/user/keybindings.json')) {
                        if (root.type === 'array') {
                            const result = [];
                            for (const item of root.items){
                                if (item.type === 'object') {
                                    for (const property of item.properties){
                                        if (property.keyNode.value === 'key' && property.valueNode) {
                                            const location = Location.create(document1.uri, getRange(document1, item));
                                            result.push({
                                                name: getName(property.valueNode),
                                                kind: SymbolKind.Function,
                                                location: location
                                            });
                                            limit--;
                                            if (limit <= 0) {
                                                if (context && context.onResultLimitExceeded) {
                                                    context.onResultLimitExceeded(resourceString);
                                                }
                                                return result;
                                            }
                                        }
                                    }
                                }
                            }
                            return result;
                        }
                    }
                    const toVisit = [
                        {
                            node: root,
                            containerName: ''
                        }
                    ];
                    let nextToVisit = 0;
                    let limitExceeded = false;
                    const result = [];
                    const collectOutlineEntries = (node, containerName)=>{
                        if (node.type === 'array') {
                            node.items.forEach((node)=>{
                                if (node) {
                                    toVisit.push({
                                        node,
                                        containerName
                                    });
                                }
                            });
                        } else if (node.type === 'object') {
                            node.properties.forEach((property)=>{
                                const valueNode = property.valueNode;
                                if (valueNode) {
                                    if (limit > 0) {
                                        limit--;
                                        const location = Location.create(document1.uri, getRange(document1, property));
                                        const childContainerName = containerName ? containerName + '.' + property.keyNode.value : property.keyNode.value;
                                        result.push({
                                            name: this.getKeyLabel(property),
                                            kind: this.getSymbolKind(valueNode.type),
                                            location: location,
                                            containerName: containerName
                                        });
                                        toVisit.push({
                                            node: valueNode,
                                            containerName: childContainerName
                                        });
                                    } else {
                                        limitExceeded = true;
                                    }
                                }
                            });
                        }
                    };
                    // breath first traversal
                    while(nextToVisit < toVisit.length){
                        const next = toVisit[nextToVisit++];
                        collectOutlineEntries(next.node, next.containerName);
                    }
                    if (limitExceeded && context && context.onResultLimitExceeded) {
                        context.onResultLimitExceeded(resourceString);
                    }
                    return result;
                }
                findDocumentSymbols2(document1, doc, context = {
                    resultLimit: Number.MAX_VALUE
                }) {
                    const root = doc.root;
                    if (!root) {
                        return [];
                    }
                    let limit = context.resultLimit || Number.MAX_VALUE;
                    // special handling for key bindings
                    const resourceString = document1.uri;
                    if (resourceString === 'vscode://defaultsettings/keybindings.json' || endsWith(resourceString.toLowerCase(), '/user/keybindings.json')) {
                        if (root.type === 'array') {
                            const result = [];
                            for (const item of root.items){
                                if (item.type === 'object') {
                                    for (const property of item.properties){
                                        if (property.keyNode.value === 'key' && property.valueNode) {
                                            const range = getRange(document1, item);
                                            const selectionRange = getRange(document1, property.keyNode);
                                            result.push({
                                                name: getName(property.valueNode),
                                                kind: SymbolKind.Function,
                                                range,
                                                selectionRange
                                            });
                                            limit--;
                                            if (limit <= 0) {
                                                if (context && context.onResultLimitExceeded) {
                                                    context.onResultLimitExceeded(resourceString);
                                                }
                                                return result;
                                            }
                                        }
                                    }
                                }
                            }
                            return result;
                        }
                    }
                    const result = [];
                    const toVisit = [
                        {
                            node: root,
                            result
                        }
                    ];
                    let nextToVisit = 0;
                    let limitExceeded = false;
                    const collectOutlineEntries = (node, result)=>{
                        if (node.type === 'array') {
                            node.items.forEach((node, index)=>{
                                if (node) {
                                    if (limit > 0) {
                                        limit--;
                                        const range = getRange(document1, node);
                                        const selectionRange = range;
                                        const name = String(index);
                                        const symbol = {
                                            name,
                                            kind: this.getSymbolKind(node.type),
                                            range,
                                            selectionRange,
                                            children: []
                                        };
                                        result.push(symbol);
                                        toVisit.push({
                                            result: symbol.children,
                                            node
                                        });
                                    } else {
                                        limitExceeded = true;
                                    }
                                }
                            });
                        } else if (node.type === 'object') {
                            node.properties.forEach((property)=>{
                                const valueNode = property.valueNode;
                                if (valueNode) {
                                    if (limit > 0) {
                                        limit--;
                                        const range = getRange(document1, property);
                                        const selectionRange = getRange(document1, property.keyNode);
                                        const children = [];
                                        const symbol = {
                                            name: this.getKeyLabel(property),
                                            kind: this.getSymbolKind(valueNode.type),
                                            range,
                                            selectionRange,
                                            children,
                                            detail: this.getDetail(valueNode)
                                        };
                                        result.push(symbol);
                                        toVisit.push({
                                            result: children,
                                            node: valueNode
                                        });
                                    } else {
                                        limitExceeded = true;
                                    }
                                }
                            });
                        }
                    };
                    // breath first traversal
                    while(nextToVisit < toVisit.length){
                        const next = toVisit[nextToVisit++];
                        collectOutlineEntries(next.node, next.result);
                    }
                    if (limitExceeded && context && context.onResultLimitExceeded) {
                        context.onResultLimitExceeded(resourceString);
                    }
                    return result;
                }
                getSymbolKind(nodeType) {
                    switch(nodeType){
                        case 'object':
                            return SymbolKind.Module;
                        case 'string':
                            return SymbolKind.String;
                        case 'number':
                            return SymbolKind.Number;
                        case 'array':
                            return SymbolKind.Array;
                        case 'boolean':
                            return SymbolKind.Boolean;
                        default:
                            return SymbolKind.Variable;
                    }
                }
                getKeyLabel(property) {
                    let name = property.keyNode.value;
                    if (name) {
                        name = name.replace(/[\n]/g, '↵');
                    }
                    if (name && name.trim()) {
                        return name;
                    }
                    return `"${name}"`;
                }
                getDetail(node) {
                    if (!node) {
                        return undefined;
                    }
                    if (node.type === 'boolean' || node.type === 'number' || node.type === 'null' || node.type === 'string') {
                        return String(node.value);
                    } else {
                        if (node.type === 'array') {
                            return node.children.length ? undefined : '[]';
                        } else if (node.type === 'object') {
                            return node.children.length ? undefined : '{}';
                        }
                    }
                    return undefined;
                }
                findDocumentColors(document1, doc, context) {
                    return this.schemaService.getSchemaForResource(document1.uri, doc).then((schema)=>{
                        const result = [];
                        if (schema) {
                            let limit = context && typeof context.resultLimit === 'number' ? context.resultLimit : Number.MAX_VALUE;
                            const matchingSchemas = doc.getMatchingSchemas(schema.schema);
                            const visitedNode = {};
                            for (const s of matchingSchemas){
                                if (!s.inverted && s.schema && (s.schema.format === 'color' || s.schema.format === 'color-hex') && s.node && s.node.type === 'string') {
                                    const nodeId = String(s.node.offset);
                                    if (!visitedNode[nodeId]) {
                                        const color = colorFromHex(jsonParser_getNodeValue(s.node));
                                        if (color) {
                                            const range = getRange(document1, s.node);
                                            result.push({
                                                color,
                                                range
                                            });
                                        }
                                        visitedNode[nodeId] = true;
                                        limit--;
                                        if (limit <= 0) {
                                            if (context && context.onResultLimitExceeded) {
                                                context.onResultLimitExceeded(document1.uri);
                                            }
                                            return result;
                                        }
                                    }
                                }
                            }
                        }
                        return result;
                    });
                }
                getColorPresentations(document1, doc, color, range) {
                    const result = [];
                    const red256 = Math.round(color.red * 255), green256 = Math.round(color.green * 255), blue256 = Math.round(color.blue * 255);
                    function toTwoDigitHex(n) {
                        const r = n.toString(16);
                        return r.length !== 2 ? '0' + r : r;
                    }
                    let label;
                    if (color.alpha === 1) {
                        label = `#${toTwoDigitHex(red256)}${toTwoDigitHex(green256)}${toTwoDigitHex(blue256)}`;
                    } else {
                        label = `#${toTwoDigitHex(red256)}${toTwoDigitHex(green256)}${toTwoDigitHex(blue256)}${toTwoDigitHex(Math.round(color.alpha * 255))}`;
                    }
                    result.push({
                        label: label,
                        textEdit: TextEdit.replace(range, JSON.stringify(label))
                    });
                    return result;
                }
                constructor(schemaService){
                    this.schemaService = schemaService;
                }
            }
            function getRange(document1, node) {
                return Range.create(document1.positionAt(node.offset), document1.positionAt(node.offset + node.length));
            }
            function getName(node) {
                return jsonParser_getNodeValue(node) || t('<empty>');
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/services/configuration.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ const schemaContributions = {
                schemaAssociations: [],
                schemas: {
                    // bundle the schema-schema to include (localized) descriptions
                    'http://json-schema.org/draft-04/schema#': {
                        '$schema': 'http://json-schema.org/draft-04/schema#',
                        'definitions': {
                            'schemaArray': {
                                'type': 'array',
                                'minItems': 1,
                                'items': {
                                    '$ref': '#'
                                }
                            },
                            'positiveInteger': {
                                'type': 'integer',
                                'minimum': 0
                            },
                            'positiveIntegerDefault0': {
                                'allOf': [
                                    {
                                        '$ref': '#/definitions/positiveInteger'
                                    },
                                    {
                                        'default': 0
                                    }
                                ]
                            },
                            'simpleTypes': {
                                'type': 'string',
                                'enum': [
                                    'array',
                                    'boolean',
                                    'integer',
                                    'null',
                                    'number',
                                    'object',
                                    'string'
                                ]
                            },
                            'stringArray': {
                                'type': 'array',
                                'items': {
                                    'type': 'string'
                                },
                                'minItems': 1,
                                'uniqueItems': true
                            }
                        },
                        'type': 'object',
                        'properties': {
                            'id': {
                                'type': 'string',
                                'format': 'uri'
                            },
                            '$schema': {
                                'type': 'string',
                                'format': 'uri'
                            },
                            'title': {
                                'type': 'string'
                            },
                            'description': {
                                'type': 'string'
                            },
                            'default': {},
                            'multipleOf': {
                                'type': 'number',
                                'minimum': 0,
                                'exclusiveMinimum': true
                            },
                            'maximum': {
                                'type': 'number'
                            },
                            'exclusiveMaximum': {
                                'type': 'boolean',
                                'default': false
                            },
                            'minimum': {
                                'type': 'number'
                            },
                            'exclusiveMinimum': {
                                'type': 'boolean',
                                'default': false
                            },
                            'maxLength': {
                                'allOf': [
                                    {
                                        '$ref': '#/definitions/positiveInteger'
                                    }
                                ]
                            },
                            'minLength': {
                                'allOf': [
                                    {
                                        '$ref': '#/definitions/positiveIntegerDefault0'
                                    }
                                ]
                            },
                            'pattern': {
                                'type': 'string',
                                'format': 'regex'
                            },
                            'additionalItems': {
                                'anyOf': [
                                    {
                                        'type': 'boolean'
                                    },
                                    {
                                        '$ref': '#'
                                    }
                                ],
                                'default': {}
                            },
                            'items': {
                                'anyOf': [
                                    {
                                        '$ref': '#'
                                    },
                                    {
                                        '$ref': '#/definitions/schemaArray'
                                    }
                                ],
                                'default': {}
                            },
                            'maxItems': {
                                'allOf': [
                                    {
                                        '$ref': '#/definitions/positiveInteger'
                                    }
                                ]
                            },
                            'minItems': {
                                'allOf': [
                                    {
                                        '$ref': '#/definitions/positiveIntegerDefault0'
                                    }
                                ]
                            },
                            'uniqueItems': {
                                'type': 'boolean',
                                'default': false
                            },
                            'maxProperties': {
                                'allOf': [
                                    {
                                        '$ref': '#/definitions/positiveInteger'
                                    }
                                ]
                            },
                            'minProperties': {
                                'allOf': [
                                    {
                                        '$ref': '#/definitions/positiveIntegerDefault0'
                                    }
                                ]
                            },
                            'required': {
                                'allOf': [
                                    {
                                        '$ref': '#/definitions/stringArray'
                                    }
                                ]
                            },
                            'additionalProperties': {
                                'anyOf': [
                                    {
                                        'type': 'boolean'
                                    },
                                    {
                                        '$ref': '#'
                                    }
                                ],
                                'default': {}
                            },
                            'definitions': {
                                'type': 'object',
                                'additionalProperties': {
                                    '$ref': '#'
                                },
                                'default': {}
                            },
                            'properties': {
                                'type': 'object',
                                'additionalProperties': {
                                    '$ref': '#'
                                },
                                'default': {}
                            },
                            'patternProperties': {
                                'type': 'object',
                                'additionalProperties': {
                                    '$ref': '#'
                                },
                                'default': {}
                            },
                            'dependencies': {
                                'type': 'object',
                                'additionalProperties': {
                                    'anyOf': [
                                        {
                                            '$ref': '#'
                                        },
                                        {
                                            '$ref': '#/definitions/stringArray'
                                        }
                                    ]
                                }
                            },
                            'enum': {
                                'type': 'array',
                                'minItems': 1,
                                'uniqueItems': true
                            },
                            'type': {
                                'anyOf': [
                                    {
                                        '$ref': '#/definitions/simpleTypes'
                                    },
                                    {
                                        'type': 'array',
                                        'items': {
                                            '$ref': '#/definitions/simpleTypes'
                                        },
                                        'minItems': 1,
                                        'uniqueItems': true
                                    }
                                ]
                            },
                            'format': {
                                'anyOf': [
                                    {
                                        'type': 'string',
                                        'enum': [
                                            'date-time',
                                            'uri',
                                            'email',
                                            'hostname',
                                            'ipv4',
                                            'ipv6',
                                            'regex'
                                        ]
                                    },
                                    {
                                        'type': 'string'
                                    }
                                ]
                            },
                            'allOf': {
                                'allOf': [
                                    {
                                        '$ref': '#/definitions/schemaArray'
                                    }
                                ]
                            },
                            'anyOf': {
                                'allOf': [
                                    {
                                        '$ref': '#/definitions/schemaArray'
                                    }
                                ]
                            },
                            'oneOf': {
                                'allOf': [
                                    {
                                        '$ref': '#/definitions/schemaArray'
                                    }
                                ]
                            },
                            'not': {
                                'allOf': [
                                    {
                                        '$ref': '#'
                                    }
                                ]
                            }
                        },
                        'dependencies': {
                            'exclusiveMaximum': [
                                'maximum'
                            ],
                            'exclusiveMinimum': [
                                'minimum'
                            ]
                        },
                        'default': {}
                    },
                    'http://json-schema.org/draft-07/schema#': {
                        'definitions': {
                            'schemaArray': {
                                'type': 'array',
                                'minItems': 1,
                                'items': {
                                    '$ref': '#'
                                }
                            },
                            'nonNegativeInteger': {
                                'type': 'integer',
                                'minimum': 0
                            },
                            'nonNegativeIntegerDefault0': {
                                'allOf': [
                                    {
                                        '$ref': '#/definitions/nonNegativeInteger'
                                    },
                                    {
                                        'default': 0
                                    }
                                ]
                            },
                            'simpleTypes': {
                                'enum': [
                                    'array',
                                    'boolean',
                                    'integer',
                                    'null',
                                    'number',
                                    'object',
                                    'string'
                                ]
                            },
                            'stringArray': {
                                'type': 'array',
                                'items': {
                                    'type': 'string'
                                },
                                'uniqueItems': true,
                                'default': []
                            }
                        },
                        'type': [
                            'object',
                            'boolean'
                        ],
                        'properties': {
                            '$id': {
                                'type': 'string',
                                'format': 'uri-reference'
                            },
                            '$schema': {
                                'type': 'string',
                                'format': 'uri'
                            },
                            '$ref': {
                                'type': 'string',
                                'format': 'uri-reference'
                            },
                            '$comment': {
                                'type': 'string'
                            },
                            'title': {
                                'type': 'string'
                            },
                            'description': {
                                'type': 'string'
                            },
                            'default': true,
                            'readOnly': {
                                'type': 'boolean',
                                'default': false
                            },
                            'examples': {
                                'type': 'array',
                                'items': true
                            },
                            'multipleOf': {
                                'type': 'number',
                                'exclusiveMinimum': 0
                            },
                            'maximum': {
                                'type': 'number'
                            },
                            'exclusiveMaximum': {
                                'type': 'number'
                            },
                            'minimum': {
                                'type': 'number'
                            },
                            'exclusiveMinimum': {
                                'type': 'number'
                            },
                            'maxLength': {
                                '$ref': '#/definitions/nonNegativeInteger'
                            },
                            'minLength': {
                                '$ref': '#/definitions/nonNegativeIntegerDefault0'
                            },
                            'pattern': {
                                'type': 'string',
                                'format': 'regex'
                            },
                            'additionalItems': {
                                '$ref': '#'
                            },
                            'items': {
                                'anyOf': [
                                    {
                                        '$ref': '#'
                                    },
                                    {
                                        '$ref': '#/definitions/schemaArray'
                                    }
                                ],
                                'default': true
                            },
                            'maxItems': {
                                '$ref': '#/definitions/nonNegativeInteger'
                            },
                            'minItems': {
                                '$ref': '#/definitions/nonNegativeIntegerDefault0'
                            },
                            'uniqueItems': {
                                'type': 'boolean',
                                'default': false
                            },
                            'contains': {
                                '$ref': '#'
                            },
                            'maxProperties': {
                                '$ref': '#/definitions/nonNegativeInteger'
                            },
                            'minProperties': {
                                '$ref': '#/definitions/nonNegativeIntegerDefault0'
                            },
                            'required': {
                                '$ref': '#/definitions/stringArray'
                            },
                            'additionalProperties': {
                                '$ref': '#'
                            },
                            'definitions': {
                                'type': 'object',
                                'additionalProperties': {
                                    '$ref': '#'
                                },
                                'default': {}
                            },
                            'properties': {
                                'type': 'object',
                                'additionalProperties': {
                                    '$ref': '#'
                                },
                                'default': {}
                            },
                            'patternProperties': {
                                'type': 'object',
                                'additionalProperties': {
                                    '$ref': '#'
                                },
                                'propertyNames': {
                                    'format': 'regex'
                                },
                                'default': {}
                            },
                            'dependencies': {
                                'type': 'object',
                                'additionalProperties': {
                                    'anyOf': [
                                        {
                                            '$ref': '#'
                                        },
                                        {
                                            '$ref': '#/definitions/stringArray'
                                        }
                                    ]
                                }
                            },
                            'propertyNames': {
                                '$ref': '#'
                            },
                            'const': true,
                            'enum': {
                                'type': 'array',
                                'items': true,
                                'minItems': 1,
                                'uniqueItems': true
                            },
                            'type': {
                                'anyOf': [
                                    {
                                        '$ref': '#/definitions/simpleTypes'
                                    },
                                    {
                                        'type': 'array',
                                        'items': {
                                            '$ref': '#/definitions/simpleTypes'
                                        },
                                        'minItems': 1,
                                        'uniqueItems': true
                                    }
                                ]
                            },
                            'format': {
                                'type': 'string'
                            },
                            'contentMediaType': {
                                'type': 'string'
                            },
                            'contentEncoding': {
                                'type': 'string'
                            },
                            'if': {
                                '$ref': '#'
                            },
                            'then': {
                                '$ref': '#'
                            },
                            'else': {
                                '$ref': '#'
                            },
                            'allOf': {
                                '$ref': '#/definitions/schemaArray'
                            },
                            'anyOf': {
                                '$ref': '#/definitions/schemaArray'
                            },
                            'oneOf': {
                                '$ref': '#/definitions/schemaArray'
                            },
                            'not': {
                                '$ref': '#'
                            }
                        },
                        'default': true
                    }
                }
            };
            const descriptions = {
                id: t("A unique identifier for the schema."),
                $schema: t("The schema to verify this document against."),
                title: t("A descriptive title of the element."),
                description: t("A long description of the element. Used in hover menus and suggestions."),
                default: t("A default value. Used by suggestions."),
                multipleOf: t("A number that should cleanly divide the current value (i.e. have no remainder)."),
                maximum: t("The maximum numerical value, inclusive by default."),
                exclusiveMaximum: t("Makes the maximum property exclusive."),
                minimum: t("The minimum numerical value, inclusive by default."),
                exclusiveMinimum: t("Makes the minimum property exclusive."),
                maxLength: t("The maximum length of a string."),
                minLength: t("The minimum length of a string."),
                pattern: t("A regular expression to match the string against. It is not implicitly anchored."),
                additionalItems: t("For arrays, only when items is set as an array. If it is a schema, then this schema validates items after the ones specified by the items array. If it is false, then additional items will cause validation to fail."),
                items: t("For arrays. Can either be a schema to validate every element against or an array of schemas to validate each item against in order (the first schema will validate the first element, the second schema will validate the second element, and so on."),
                maxItems: t("The maximum number of items that can be inside an array. Inclusive."),
                minItems: t("The minimum number of items that can be inside an array. Inclusive."),
                uniqueItems: t("If all of the items in the array must be unique. Defaults to false."),
                maxProperties: t("The maximum number of properties an object can have. Inclusive."),
                minProperties: t("The minimum number of properties an object can have. Inclusive."),
                required: t("An array of strings that lists the names of all properties required on this object."),
                additionalProperties: t("Either a schema or a boolean. If a schema, then used to validate all properties not matched by 'properties' or 'patternProperties'. If false, then any properties not matched by either will cause this schema to fail."),
                definitions: t("Not used for validation. Place subschemas here that you wish to reference inline with $ref."),
                properties: t("A map of property names to schemas for each property."),
                patternProperties: t("A map of regular expressions on property names to schemas for matching properties."),
                dependencies: t("A map of property names to either an array of property names or a schema. An array of property names means the property named in the key depends on the properties in the array being present in the object in order to be valid. If the value is a schema, then the schema is only applied to the object if the property in the key exists on the object."),
                enum: t("The set of literal values that are valid."),
                type: t("Either a string of one of the basic schema types (number, integer, null, array, object, boolean, string) or an array of strings specifying a subset of those types."),
                format: t("Describes the format expected for the value."),
                allOf: t("An array of schemas, all of which must match."),
                anyOf: t("An array of schemas, where at least one must match."),
                oneOf: t("An array of schemas, exactly one of which must match."),
                not: t("A schema which must not match."),
                $id: t("A unique identifier for the schema."),
                $ref: t("Reference a definition hosted on any location."),
                $comment: t("Comments from schema authors to readers or maintainers of the schema."),
                readOnly: t("Indicates that the value of the instance is managed exclusively by the owning authority."),
                examples: t("Sample JSON values associated with a particular schema, for the purpose of illustrating usage."),
                contains: t("An array instance is valid against \"contains\" if at least one of its elements is valid against the given schema."),
                propertyNames: t("If the instance is an object, this keyword validates if every property name in the instance validates against the provided schema."),
                const: t("An instance validates successfully against this keyword if its value is equal to the value of the keyword."),
                contentMediaType: t("Describes the media type of a string property."),
                contentEncoding: t("Describes the content encoding of a string property."),
                if: t("The validation outcome of the \"if\" subschema controls which of the \"then\" or \"else\" keywords are evaluated."),
                then: t("The \"if\" subschema is used for validation when the \"if\" subschema succeeds."),
                else: t("The \"else\" subschema is used for validation when the \"if\" subschema fails.")
            };
            for(const schemaName in schemaContributions.schemas){
                const schema = schemaContributions.schemas[schemaName];
                for(const property in schema.properties){
                    let propertyObject = schema.properties[property];
                    if (typeof propertyObject === 'boolean') {
                        propertyObject = schema.properties[property] = {};
                    }
                    const description = descriptions[property];
                    if (description) {
                        propertyObject['description'] = description;
                    }
                }
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-uri/lib/esm/index.mjs
            /* provided dependency */ var process = __nested_webpack_require_714846__(9907);
            var LIB;
            (()=>{
                "use strict";
                var t = {
                    470: (t)=>{
                        function e(t) {
                            if ("string" != typeof t) throw new TypeError("Path must be a string. Received " + JSON.stringify(t));
                        }
                        function r(t, e) {
                            for(var r, n = "", i = 0, o = -1, s = 0, h = 0; h <= t.length; ++h){
                                if (h < t.length) r = t.charCodeAt(h);
                                else {
                                    if (47 === r) break;
                                    r = 47;
                                }
                                if (47 === r) {
                                    if (o === h - 1 || 1 === s) ;
                                    else if (o !== h - 1 && 2 === s) {
                                        if (n.length < 2 || 2 !== i || 46 !== n.charCodeAt(n.length - 1) || 46 !== n.charCodeAt(n.length - 2)) {
                                            if (n.length > 2) {
                                                var a = n.lastIndexOf("/");
                                                if (a !== n.length - 1) {
                                                    -1 === a ? (n = "", i = 0) : i = (n = n.slice(0, a)).length - 1 - n.lastIndexOf("/"), o = h, s = 0;
                                                    continue;
                                                }
                                            } else if (2 === n.length || 1 === n.length) {
                                                n = "", i = 0, o = h, s = 0;
                                                continue;
                                            }
                                        }
                                        e && (n.length > 0 ? n += "/.." : n = "..", i = 2);
                                    } else n.length > 0 ? n += "/" + t.slice(o + 1, h) : n = t.slice(o + 1, h), i = h - o - 1;
                                    o = h, s = 0;
                                } else 46 === r && -1 !== s ? ++s : s = -1;
                            }
                            return n;
                        }
                        var n = {
                            resolve: function() {
                                for(var t, n = "", i = !1, o = arguments.length - 1; o >= -1 && !i; o--){
                                    var s;
                                    o >= 0 ? s = arguments[o] : (void 0 === t && (t = process.cwd()), s = t), e(s), 0 !== s.length && (n = s + "/" + n, i = 47 === s.charCodeAt(0));
                                }
                                return n = r(n, !i), i ? n.length > 0 ? "/" + n : "/" : n.length > 0 ? n : ".";
                            },
                            normalize: function(t) {
                                if (e(t), 0 === t.length) return ".";
                                var n = 47 === t.charCodeAt(0), i = 47 === t.charCodeAt(t.length - 1);
                                return 0 !== (t = r(t, !n)).length || n || (t = "."), t.length > 0 && i && (t += "/"), n ? "/" + t : t;
                            },
                            isAbsolute: function(t) {
                                return e(t), t.length > 0 && 47 === t.charCodeAt(0);
                            },
                            join: function() {
                                if (0 === arguments.length) return ".";
                                for(var t, r = 0; r < arguments.length; ++r){
                                    var i = arguments[r];
                                    e(i), i.length > 0 && (void 0 === t ? t = i : t += "/" + i);
                                }
                                return void 0 === t ? "." : n.normalize(t);
                            },
                            relative: function(t, r) {
                                if (e(t), e(r), t === r) return "";
                                if ((t = n.resolve(t)) === (r = n.resolve(r))) return "";
                                for(var i = 1; i < t.length && 47 === t.charCodeAt(i); ++i);
                                for(var o = t.length, s = o - i, h = 1; h < r.length && 47 === r.charCodeAt(h); ++h);
                                for(var a = r.length - h, c = s < a ? s : a, f = -1, u = 0; u <= c; ++u){
                                    if (u === c) {
                                        if (a > c) {
                                            if (47 === r.charCodeAt(h + u)) return r.slice(h + u + 1);
                                            if (0 === u) return r.slice(h + u);
                                        } else s > c && (47 === t.charCodeAt(i + u) ? f = u : 0 === u && (f = 0));
                                        break;
                                    }
                                    var l = t.charCodeAt(i + u);
                                    if (l !== r.charCodeAt(h + u)) break;
                                    47 === l && (f = u);
                                }
                                var g = "";
                                for(u = i + f + 1; u <= o; ++u)u !== o && 47 !== t.charCodeAt(u) || (0 === g.length ? g += ".." : g += "/..");
                                return g.length > 0 ? g + r.slice(h + f) : (h += f, 47 === r.charCodeAt(h) && ++h, r.slice(h));
                            },
                            _makeLong: function(t) {
                                return t;
                            },
                            dirname: function(t) {
                                if (e(t), 0 === t.length) return ".";
                                for(var r = t.charCodeAt(0), n = 47 === r, i = -1, o = !0, s = t.length - 1; s >= 1; --s)if (47 === (r = t.charCodeAt(s))) {
                                    if (!o) {
                                        i = s;
                                        break;
                                    }
                                } else o = !1;
                                return -1 === i ? n ? "/" : "." : n && 1 === i ? "//" : t.slice(0, i);
                            },
                            basename: function(t, r) {
                                if (void 0 !== r && "string" != typeof r) throw new TypeError('"ext" argument must be a string');
                                e(t);
                                var n, i = 0, o = -1, s = !0;
                                if (void 0 !== r && r.length > 0 && r.length <= t.length) {
                                    if (r.length === t.length && r === t) return "";
                                    var h = r.length - 1, a = -1;
                                    for(n = t.length - 1; n >= 0; --n){
                                        var c = t.charCodeAt(n);
                                        if (47 === c) {
                                            if (!s) {
                                                i = n + 1;
                                                break;
                                            }
                                        } else -1 === a && (s = !1, a = n + 1), h >= 0 && (c === r.charCodeAt(h) ? -1 == --h && (o = n) : (h = -1, o = a));
                                    }
                                    return i === o ? o = a : -1 === o && (o = t.length), t.slice(i, o);
                                }
                                for(n = t.length - 1; n >= 0; --n)if (47 === t.charCodeAt(n)) {
                                    if (!s) {
                                        i = n + 1;
                                        break;
                                    }
                                } else -1 === o && (s = !1, o = n + 1);
                                return -1 === o ? "" : t.slice(i, o);
                            },
                            extname: function(t) {
                                e(t);
                                for(var r = -1, n = 0, i = -1, o = !0, s = 0, h = t.length - 1; h >= 0; --h){
                                    var a = t.charCodeAt(h);
                                    if (47 !== a) -1 === i && (o = !1, i = h + 1), 46 === a ? -1 === r ? r = h : 1 !== s && (s = 1) : -1 !== r && (s = -1);
                                    else if (!o) {
                                        n = h + 1;
                                        break;
                                    }
                                }
                                return -1 === r || -1 === i || 0 === s || 1 === s && r === i - 1 && r === n + 1 ? "" : t.slice(r, i);
                            },
                            format: function(t) {
                                if (null === t || "object" != typeof t) throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t);
                                return function(t, e) {
                                    var r = e.dir || e.root, n = e.base || (e.name || "") + (e.ext || "");
                                    return r ? r === e.root ? r + n : r + "/" + n : n;
                                }(0, t);
                            },
                            parse: function(t) {
                                e(t);
                                var r = {
                                    root: "",
                                    dir: "",
                                    base: "",
                                    ext: "",
                                    name: ""
                                };
                                if (0 === t.length) return r;
                                var n, i = t.charCodeAt(0), o = 47 === i;
                                o ? (r.root = "/", n = 1) : n = 0;
                                for(var s = -1, h = 0, a = -1, c = !0, f = t.length - 1, u = 0; f >= n; --f)if (47 !== (i = t.charCodeAt(f))) -1 === a && (c = !1, a = f + 1), 46 === i ? -1 === s ? s = f : 1 !== u && (u = 1) : -1 !== s && (u = -1);
                                else if (!c) {
                                    h = f + 1;
                                    break;
                                }
                                return -1 === s || -1 === a || 0 === u || 1 === u && s === a - 1 && s === h + 1 ? -1 !== a && (r.base = r.name = 0 === h && o ? t.slice(1, a) : t.slice(h, a)) : (0 === h && o ? (r.name = t.slice(1, s), r.base = t.slice(1, a)) : (r.name = t.slice(h, s), r.base = t.slice(h, a)), r.ext = t.slice(s, a)), h > 0 ? r.dir = t.slice(0, h - 1) : o && (r.dir = "/"), r;
                            },
                            sep: "/",
                            delimiter: ":",
                            win32: null,
                            posix: null
                        };
                        n.posix = n, t.exports = n;
                    }
                }, e = {};
                function r(n) {
                    var i = e[n];
                    if (void 0 !== i) return i.exports;
                    var o = e[n] = {
                        exports: {}
                    };
                    return t[n](o, o.exports, r), o.exports;
                }
                r.d = (t, e)=>{
                    for(var n in e)r.o(e, n) && !r.o(t, n) && Object.defineProperty(t, n, {
                        enumerable: !0,
                        get: e[n]
                    });
                }, r.o = (t, e)=>Object.prototype.hasOwnProperty.call(t, e), r.r = (t)=>{
                    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
                        value: "Module"
                    }), Object.defineProperty(t, "__esModule", {
                        value: !0
                    });
                };
                var n = {};
                (()=>{
                    let t;
                    if (r.r(n), r.d(n, {
                        URI: ()=>f,
                        Utils: ()=>P
                    }), "object" == typeof process) t = "win32" === process.platform;
                    else if ("object" == typeof navigator) {
                        let e = navigator.userAgent;
                        t = e.indexOf("Windows") >= 0;
                    }
                    const e = /^\w[\w\d+.-]*$/, i = /^\//, o = /^\/\//;
                    function s(t, r) {
                        if (!t.scheme && r) throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${t.authority}", path: "${t.path}", query: "${t.query}", fragment: "${t.fragment}"}`);
                        if (t.scheme && !e.test(t.scheme)) throw new Error("[UriError]: Scheme contains illegal characters.");
                        if (t.path) {
                            if (t.authority) {
                                if (!i.test(t.path)) throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
                            } else if (o.test(t.path)) throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
                        }
                    }
                    const h = "", a = "/", c = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
                    class f {
                        static isUri(t) {
                            return t instanceof f || !!t && "string" == typeof t.authority && "string" == typeof t.fragment && "string" == typeof t.path && "string" == typeof t.query && "string" == typeof t.scheme && "string" == typeof t.fsPath && "function" == typeof t.with && "function" == typeof t.toString;
                        }
                        get fsPath() {
                            return m(this, !1);
                        }
                        with(t) {
                            if (!t) return this;
                            let { scheme: e, authority: r, path: n, query: i, fragment: o } = t;
                            return void 0 === e ? e = this.scheme : null === e && (e = h), void 0 === r ? r = this.authority : null === r && (r = h), void 0 === n ? n = this.path : null === n && (n = h), void 0 === i ? i = this.query : null === i && (i = h), void 0 === o ? o = this.fragment : null === o && (o = h), e === this.scheme && r === this.authority && n === this.path && i === this.query && o === this.fragment ? this : new l(e, r, n, i, o);
                        }
                        static parse(t, e = !1) {
                            const r = c.exec(t);
                            return r ? new l(r[2] || h, C(r[4] || h), C(r[5] || h), C(r[7] || h), C(r[9] || h), e) : new l(h, h, h, h, h);
                        }
                        static file(e) {
                            let r = h;
                            if (t && (e = e.replace(/\\/g, a)), e[0] === a && e[1] === a) {
                                const t = e.indexOf(a, 2);
                                -1 === t ? (r = e.substring(2), e = a) : (r = e.substring(2, t), e = e.substring(t) || a);
                            }
                            return new l("file", r, e, h, h);
                        }
                        static from(t) {
                            const e = new l(t.scheme, t.authority, t.path, t.query, t.fragment);
                            return s(e, !0), e;
                        }
                        toString(t = !1) {
                            return y(this, t);
                        }
                        toJSON() {
                            return this;
                        }
                        static revive(t) {
                            if (t) {
                                if (t instanceof f) return t;
                                {
                                    const e = new l(t);
                                    return e._formatted = t.external, e._fsPath = t._sep === u ? t.fsPath : null, e;
                                }
                            }
                            return t;
                        }
                        constructor(t, e, r, n, i, o = !1){
                            _define_property(this, "scheme", void 0);
                            _define_property(this, "authority", void 0);
                            _define_property(this, "path", void 0);
                            _define_property(this, "query", void 0);
                            _define_property(this, "fragment", void 0);
                            "object" == typeof t ? (this.scheme = t.scheme || h, this.authority = t.authority || h, this.path = t.path || h, this.query = t.query || h, this.fragment = t.fragment || h) : (this.scheme = function(t, e) {
                                return t || e ? t : "file";
                            }(t, o), this.authority = e || h, this.path = function(t, e) {
                                switch(t){
                                    case "https":
                                    case "http":
                                    case "file":
                                        e ? e[0] !== a && (e = a + e) : e = a;
                                }
                                return e;
                            }(this.scheme, r || h), this.query = n || h, this.fragment = i || h, s(this, o));
                        }
                    }
                    const u = t ? 1 : void 0;
                    class l extends f {
                        get fsPath() {
                            return this._fsPath || (this._fsPath = m(this, !1)), this._fsPath;
                        }
                        toString(t = !1) {
                            return t ? y(this, !0) : (this._formatted || (this._formatted = y(this, !1)), this._formatted);
                        }
                        toJSON() {
                            const t = {
                                $mid: 1
                            };
                            return this._fsPath && (t.fsPath = this._fsPath, t._sep = u), this._formatted && (t.external = this._formatted), this.path && (t.path = this.path), this.scheme && (t.scheme = this.scheme), this.authority && (t.authority = this.authority), this.query && (t.query = this.query), this.fragment && (t.fragment = this.fragment), t;
                        }
                        constructor(...args){
                            super(...args);
                            _define_property(this, "_formatted", null);
                            _define_property(this, "_fsPath", null);
                        }
                    }
                    const g = {
                        58: "%3A",
                        47: "%2F",
                        63: "%3F",
                        35: "%23",
                        91: "%5B",
                        93: "%5D",
                        64: "%40",
                        33: "%21",
                        36: "%24",
                        38: "%26",
                        39: "%27",
                        40: "%28",
                        41: "%29",
                        42: "%2A",
                        43: "%2B",
                        44: "%2C",
                        59: "%3B",
                        61: "%3D",
                        32: "%20"
                    };
                    function d(t, e, r) {
                        let n, i = -1;
                        for(let o = 0; o < t.length; o++){
                            const s = t.charCodeAt(o);
                            if (s >= 97 && s <= 122 || s >= 65 && s <= 90 || s >= 48 && s <= 57 || 45 === s || 46 === s || 95 === s || 126 === s || e && 47 === s || r && 91 === s || r && 93 === s || r && 58 === s) -1 !== i && (n += encodeURIComponent(t.substring(i, o)), i = -1), void 0 !== n && (n += t.charAt(o));
                            else {
                                void 0 === n && (n = t.substr(0, o));
                                const e = g[s];
                                void 0 !== e ? (-1 !== i && (n += encodeURIComponent(t.substring(i, o)), i = -1), n += e) : -1 === i && (i = o);
                            }
                        }
                        return -1 !== i && (n += encodeURIComponent(t.substring(i))), void 0 !== n ? n : t;
                    }
                    function p(t) {
                        let e;
                        for(let r = 0; r < t.length; r++){
                            const n = t.charCodeAt(r);
                            35 === n || 63 === n ? (void 0 === e && (e = t.substr(0, r)), e += g[n]) : void 0 !== e && (e += t[r]);
                        }
                        return void 0 !== e ? e : t;
                    }
                    function m(e, r) {
                        let n;
                        return n = e.authority && e.path.length > 1 && "file" === e.scheme ? `//${e.authority}${e.path}` : 47 === e.path.charCodeAt(0) && (e.path.charCodeAt(1) >= 65 && e.path.charCodeAt(1) <= 90 || e.path.charCodeAt(1) >= 97 && e.path.charCodeAt(1) <= 122) && 58 === e.path.charCodeAt(2) ? r ? e.path.substr(1) : e.path[1].toLowerCase() + e.path.substr(2) : e.path, t && (n = n.replace(/\//g, "\\")), n;
                    }
                    function y(t, e) {
                        const r = e ? p : d;
                        let n = "", { scheme: i, authority: o, path: s, query: h, fragment: c } = t;
                        if (i && (n += i, n += ":"), (o || "file" === i) && (n += a, n += a), o) {
                            let t = o.indexOf("@");
                            if (-1 !== t) {
                                const e = o.substr(0, t);
                                o = o.substr(t + 1), t = e.lastIndexOf(":"), -1 === t ? n += r(e, !1, !1) : (n += r(e.substr(0, t), !1, !1), n += ":", n += r(e.substr(t + 1), !1, !0)), n += "@";
                            }
                            o = o.toLowerCase(), t = o.lastIndexOf(":"), -1 === t ? n += r(o, !1, !0) : (n += r(o.substr(0, t), !1, !0), n += o.substr(t));
                        }
                        if (s) {
                            if (s.length >= 3 && 47 === s.charCodeAt(0) && 58 === s.charCodeAt(2)) {
                                const t = s.charCodeAt(1);
                                t >= 65 && t <= 90 && (s = `/${String.fromCharCode(t + 32)}:${s.substr(3)}`);
                            } else if (s.length >= 2 && 58 === s.charCodeAt(1)) {
                                const t = s.charCodeAt(0);
                                t >= 65 && t <= 90 && (s = `${String.fromCharCode(t + 32)}:${s.substr(2)}`);
                            }
                            n += r(s, !0, !1);
                        }
                        return h && (n += "?", n += r(h, !1, !1)), c && (n += "#", n += e ? c : d(c, !1, !1)), n;
                    }
                    function v(t) {
                        try {
                            return decodeURIComponent(t);
                        } catch  {
                            return t.length > 3 ? t.substr(0, 3) + v(t.substr(3)) : t;
                        }
                    }
                    const b = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
                    function C(t) {
                        return t.match(b) ? t.replace(b, (t)=>v(t)) : t;
                    }
                    var A = r(470);
                    const w = A.posix || A, x = "/";
                    var P;
                    !function(t) {
                        t.joinPath = function(t, ...e) {
                            return t.with({
                                path: w.join(t.path, ...e)
                            });
                        }, t.resolvePath = function(t, ...e) {
                            let r = t.path, n = !1;
                            r[0] !== x && (r = x + r, n = !0);
                            let i = w.resolve(r, ...e);
                            return n && i[0] === x && !t.authority && (i = i.substring(1)), t.with({
                                path: i
                            });
                        }, t.dirname = function(t) {
                            if (0 === t.path.length || t.path === x) return t;
                            let e = w.dirname(t.path);
                            return 1 === e.length && 46 === e.charCodeAt(0) && (e = ""), t.with({
                                path: e
                            });
                        }, t.basename = function(t) {
                            return w.basename(t.path);
                        }, t.extname = function(t) {
                            return w.extname(t.path);
                        };
                    }(P || (P = {}));
                })(), LIB = n;
            })();
            const { URI: esm_URI, Utils } = LIB;
            //# sourceMappingURL=index.mjs.map
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/utils/glob.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Copyright (c) 2013, Nick Fitzgerald
 *  Licensed under the MIT License. See LICENCE.md in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ function createRegex(glob, opts) {
                if (typeof glob !== 'string') {
                    throw new TypeError('Expected a string');
                }
                const str = String(glob);
                // The regexp we are building, as a string.
                let reStr = "";
                // Whether we are matching so called "extended" globs (like bash) and should
                // support single character matching, matching ranges of characters, group
                // matching, etc.
                const extended = opts ? !!opts.extended : false;
                // When globstar is _false_ (default), '/foo/*' is translated a regexp like
                // '^\/foo\/.*$' which will match any string beginning with '/foo/'
                // When globstar is _true_, '/foo/*' is translated to regexp like
                // '^\/foo\/[^/]*$' which will match any string beginning with '/foo/' BUT
                // which does not have a '/' to the right of it.
                // E.g. with '/foo/*' these will match: '/foo/bar', '/foo/bar.txt' but
                // these will not '/foo/bar/baz', '/foo/bar/baz.txt'
                // Lastely, when globstar is _true_, '/foo/**' is equivelant to '/foo/*' when
                // globstar is _false_
                const globstar = opts ? !!opts.globstar : false;
                // If we are doing extended matching, this boolean is true when we are inside
                // a group (eg {*.html,*.js}), and false otherwise.
                let inGroup = false;
                // RegExp flags (eg "i" ) to pass in to RegExp constructor.
                const flags = opts && typeof opts.flags === "string" ? opts.flags : "";
                let c;
                for(let i = 0, len = str.length; i < len; i++){
                    c = str[i];
                    switch(c){
                        case "/":
                        case "$":
                        case "^":
                        case "+":
                        case ".":
                        case "(":
                        case ")":
                        case "=":
                        case "!":
                        case "|":
                            reStr += "\\" + c;
                            break;
                        case "?":
                            if (extended) {
                                reStr += ".";
                                break;
                            }
                        case "[":
                        case "]":
                            if (extended) {
                                reStr += c;
                                break;
                            }
                        case "{":
                            if (extended) {
                                inGroup = true;
                                reStr += "(";
                                break;
                            }
                        case "}":
                            if (extended) {
                                inGroup = false;
                                reStr += ")";
                                break;
                            }
                        case ",":
                            if (inGroup) {
                                reStr += "|";
                                break;
                            }
                            reStr += "\\" + c;
                            break;
                        case "*":
                            // Move over all consecutive "*"'s.
                            // Also store the previous and next characters
                            const prevChar = str[i - 1];
                            let starCount = 1;
                            while(str[i + 1] === "*"){
                                starCount++;
                                i++;
                            }
                            const nextChar = str[i + 1];
                            if (!globstar) {
                                // globstar is disabled, so treat any number of "*" as one
                                reStr += ".*";
                            } else {
                                // globstar is enabled, so determine if this is a globstar segment
                                const isGlobstar = starCount > 1 // multiple "*"'s
                                 && (prevChar === "/" || prevChar === undefined || prevChar === '{' || prevChar === ',' // from the start of the segment
                                ) && (nextChar === "/" || nextChar === undefined || nextChar === ',' || nextChar === '}'); // to the end of the segment
                                if (isGlobstar) {
                                    if (nextChar === "/") {
                                        i++; // move over the "/"
                                    } else if (prevChar === '/' && reStr.endsWith('\\/')) {
                                        reStr = reStr.substr(0, reStr.length - 2);
                                    }
                                    // it's a globstar, so match zero or more path segments
                                    reStr += "((?:[^/]*(?:\/|$))*)";
                                } else {
                                    // it's not a globstar, so only match one path segment
                                    reStr += "([^/]*)";
                                }
                            }
                            break;
                        default:
                            reStr += c;
                    }
                }
                // When regexp 'g' flag is specified don't
                // constrain the regular expression with ^ & $
                if (!flags || !~flags.indexOf('g')) {
                    reStr = "^" + reStr + "$";
                }
                return new RegExp(reStr, flags);
            }
            ;
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/services/jsonSchemaService.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ const BANG = '!';
            const PATH_SEP = '/';
            class FilePatternAssociation {
                matchesPattern(fileName) {
                    if (this.folderUri && !fileName.startsWith(this.folderUri)) {
                        return false;
                    }
                    let match = false;
                    for (const { regexp, include } of this.globWrappers){
                        if (regexp.test(fileName)) {
                            match = include;
                        }
                    }
                    return match;
                }
                getURIs() {
                    return this.uris;
                }
                constructor(pattern, folderUri, uris){
                    this.folderUri = folderUri;
                    this.uris = uris;
                    this.globWrappers = [];
                    try {
                        for (let patternString of pattern){
                            const include = patternString[0] !== BANG;
                            if (!include) {
                                patternString = patternString.substring(1);
                            }
                            if (patternString.length > 0) {
                                if (patternString[0] === PATH_SEP) {
                                    patternString = patternString.substring(1);
                                }
                                this.globWrappers.push({
                                    regexp: createRegex('**/' + patternString, {
                                        extended: true,
                                        globstar: true
                                    }),
                                    include: include
                                });
                            }
                        }
                        ;
                        if (folderUri) {
                            folderUri = normalizeResourceForMatching(folderUri);
                            if (!folderUri.endsWith('/')) {
                                folderUri = folderUri + '/';
                            }
                            this.folderUri = folderUri;
                        }
                    } catch (e) {
                        this.globWrappers.length = 0;
                        this.uris = [];
                    }
                }
            }
            class SchemaHandle {
                getUnresolvedSchema() {
                    if (!this.unresolvedSchema) {
                        this.unresolvedSchema = this.service.loadSchema(this.uri);
                    }
                    return this.unresolvedSchema;
                }
                getResolvedSchema() {
                    if (!this.resolvedSchema) {
                        this.resolvedSchema = this.getUnresolvedSchema().then((unresolved)=>{
                            return this.service.resolveSchemaContent(unresolved, this);
                        });
                    }
                    return this.resolvedSchema;
                }
                clearSchema() {
                    const hasChanges = !!this.unresolvedSchema;
                    this.resolvedSchema = undefined;
                    this.unresolvedSchema = undefined;
                    this.dependencies.clear();
                    this.anchors = undefined;
                    return hasChanges;
                }
                constructor(service, uri, unresolvedSchemaContent){
                    this.service = service;
                    this.uri = uri;
                    this.dependencies = new Set();
                    this.anchors = undefined;
                    if (unresolvedSchemaContent) {
                        this.unresolvedSchema = this.service.promise.resolve(new UnresolvedSchema(unresolvedSchemaContent));
                    }
                }
            }
            class UnresolvedSchema {
                constructor(schema, errors = []){
                    this.schema = schema;
                    this.errors = errors;
                }
            }
            class ResolvedSchema {
                getSection(path) {
                    const schemaRef = this.getSectionRecursive(path, this.schema);
                    if (schemaRef) {
                        return asSchema(schemaRef);
                    }
                    return undefined;
                }
                getSectionRecursive(path, schema) {
                    if (!schema || typeof schema === 'boolean' || path.length === 0) {
                        return schema;
                    }
                    const next = path.shift();
                    if (schema.properties && typeof schema.properties[next]) {
                        return this.getSectionRecursive(path, schema.properties[next]);
                    } else if (schema.patternProperties) {
                        for (const pattern of Object.keys(schema.patternProperties)){
                            var _regex;
                            const regex = extendedRegExp(pattern);
                            if ((_regex = regex) === null || _regex === void 0 ? void 0 : _regex.test(next)) {
                                return this.getSectionRecursive(path, schema.patternProperties[pattern]);
                            }
                        }
                    } else if (typeof schema.additionalProperties === 'object') {
                        return this.getSectionRecursive(path, schema.additionalProperties);
                    } else if (next.match('[0-9]+')) {
                        if (Array.isArray(schema.items)) {
                            const index = parseInt(next, 10);
                            if (!isNaN(index) && schema.items[index]) {
                                return this.getSectionRecursive(path, schema.items[index]);
                            }
                        } else if (schema.items) {
                            return this.getSectionRecursive(path, schema.items);
                        }
                    }
                    return undefined;
                }
                constructor(schema, errors = [], warnings = [], schemaDraft){
                    this.schema = schema;
                    this.errors = errors;
                    this.warnings = warnings;
                    this.schemaDraft = schemaDraft;
                }
            }
            class JSONSchemaService {
                getRegisteredSchemaIds(filter) {
                    return Object.keys(this.registeredSchemasIds).filter((id)=>{
                        const scheme = esm_URI.parse(id).scheme;
                        return scheme !== 'schemaservice' && (!filter || filter(scheme));
                    });
                }
                get promise() {
                    return this.promiseConstructor;
                }
                dispose() {
                    while(this.callOnDispose.length > 0){
                        this.callOnDispose.pop()();
                    }
                }
                onResourceChange(uri) {
                    // always clear this local cache when a resource changes
                    this.cachedSchemaForResource = undefined;
                    let hasChanges = false;
                    uri = normalizeId(uri);
                    const toWalk = [
                        uri
                    ];
                    const all = Object.keys(this.schemasById).map((key)=>this.schemasById[key]);
                    while(toWalk.length){
                        const curr = toWalk.pop();
                        for(let i = 0; i < all.length; i++){
                            const handle = all[i];
                            if (handle && (handle.uri === curr || handle.dependencies.has(curr))) {
                                if (handle.uri !== curr) {
                                    toWalk.push(handle.uri);
                                }
                                if (handle.clearSchema()) {
                                    hasChanges = true;
                                }
                                all[i] = undefined;
                            }
                        }
                    }
                    return hasChanges;
                }
                setSchemaContributions(schemaContributions) {
                    if (schemaContributions.schemas) {
                        const schemas = schemaContributions.schemas;
                        for(const id in schemas){
                            const normalizedId = normalizeId(id);
                            this.contributionSchemas[normalizedId] = this.addSchemaHandle(normalizedId, schemas[id]);
                        }
                    }
                    if (Array.isArray(schemaContributions.schemaAssociations)) {
                        const schemaAssociations = schemaContributions.schemaAssociations;
                        for (let schemaAssociation of schemaAssociations){
                            const uris = schemaAssociation.uris.map(normalizeId);
                            const association = this.addFilePatternAssociation(schemaAssociation.pattern, schemaAssociation.folderUri, uris);
                            this.contributionAssociations.push(association);
                        }
                    }
                }
                addSchemaHandle(id, unresolvedSchemaContent) {
                    const schemaHandle = new SchemaHandle(this, id, unresolvedSchemaContent);
                    this.schemasById[id] = schemaHandle;
                    return schemaHandle;
                }
                getOrAddSchemaHandle(id, unresolvedSchemaContent) {
                    return this.schemasById[id] || this.addSchemaHandle(id, unresolvedSchemaContent);
                }
                addFilePatternAssociation(pattern, folderUri, uris) {
                    const fpa = new FilePatternAssociation(pattern, folderUri, uris);
                    this.filePatternAssociations.push(fpa);
                    return fpa;
                }
                registerExternalSchema(config) {
                    const id = normalizeId(config.uri);
                    this.registeredSchemasIds[id] = true;
                    this.cachedSchemaForResource = undefined;
                    if (config.fileMatch && config.fileMatch.length) {
                        this.addFilePatternAssociation(config.fileMatch, config.folderUri, [
                            id
                        ]);
                    }
                    return config.schema ? this.addSchemaHandle(id, config.schema) : this.getOrAddSchemaHandle(id);
                }
                clearExternalSchemas() {
                    this.schemasById = {};
                    this.filePatternAssociations = [];
                    this.registeredSchemasIds = {};
                    this.cachedSchemaForResource = undefined;
                    for(const id in this.contributionSchemas){
                        this.schemasById[id] = this.contributionSchemas[id];
                        this.registeredSchemasIds[id] = true;
                    }
                    for (const contributionAssociation of this.contributionAssociations){
                        this.filePatternAssociations.push(contributionAssociation);
                    }
                }
                getResolvedSchema(schemaId) {
                    const id = normalizeId(schemaId);
                    const schemaHandle = this.schemasById[id];
                    if (schemaHandle) {
                        return schemaHandle.getResolvedSchema();
                    }
                    return this.promise.resolve(undefined);
                }
                loadSchema(url) {
                    if (!this.requestService) {
                        const errorMessage = t('Unable to load schema from \'{0}\'. No schema request service available', toDisplayString(url));
                        return this.promise.resolve(new UnresolvedSchema({}, [
                            errorMessage
                        ]));
                    }
                    if (url.startsWith('http://json-schema.org/')) {
                        url = 'https' + url.substring(4); // always access json-schema.org with https. See https://github.com/microsoft/vscode/issues/195189
                    }
                    return this.requestService(url).then((content)=>{
                        if (!content) {
                            const errorMessage = t('Unable to load schema from \'{0}\': No content.', toDisplayString(url));
                            return new UnresolvedSchema({}, [
                                errorMessage
                            ]);
                        }
                        const errors = [];
                        if (content.charCodeAt(0) === 65279) {
                            errors.push(t('Problem reading content from \'{0}\': UTF-8 with BOM detected, only UTF 8 is allowed.', toDisplayString(url)));
                            content = content.trimStart();
                        }
                        let schemaContent = {};
                        const jsonErrors = [];
                        schemaContent = main_parse(content, jsonErrors);
                        if (jsonErrors.length) {
                            errors.push(t('Unable to parse content from \'{0}\': Parse error at offset {1}.', toDisplayString(url), jsonErrors[0].offset));
                        }
                        return new UnresolvedSchema(schemaContent, errors);
                    }, (error)=>{
                        let errorMessage = error.toString();
                        const errorSplit = error.toString().split('Error: ');
                        if (errorSplit.length > 1) {
                            // more concise error message, URL and context are attached by caller anyways
                            errorMessage = errorSplit[1];
                        }
                        if (endsWith(errorMessage, '.')) {
                            errorMessage = errorMessage.substr(0, errorMessage.length - 1);
                        }
                        return new UnresolvedSchema({}, [
                            t('Unable to load schema from \'{0}\': {1}.', toDisplayString(url), errorMessage)
                        ]);
                    });
                }
                resolveSchemaContent(schemaToResolve, handle) {
                    const resolveErrors = schemaToResolve.errors.slice(0);
                    const schema = schemaToResolve.schema;
                    let schemaDraft = schema.$schema ? normalizeId(schema.$schema) : undefined;
                    if (schemaDraft === 'http://json-schema.org/draft-03/schema') {
                        return this.promise.resolve(new ResolvedSchema({}, [
                            t("Draft-03 schemas are not supported.")
                        ], [], schemaDraft));
                    }
                    let usesUnsupportedFeatures = new Set();
                    const contextService = this.contextService;
                    const findSectionByJSONPointer = (schema, path)=>{
                        path = decodeURIComponent(path);
                        let current = schema;
                        if (path[0] === '/') {
                            path = path.substring(1);
                        }
                        path.split('/').some((part)=>{
                            part = part.replace(/~1/g, '/').replace(/~0/g, '~');
                            current = current[part];
                            return !current;
                        });
                        return current;
                    };
                    const findSchemaById = (schema, handle, id)=>{
                        if (!handle.anchors) {
                            handle.anchors = collectAnchors(schema);
                        }
                        return handle.anchors.get(id);
                    };
                    const merge = (target, section)=>{
                        for(const key in section){
                            if (section.hasOwnProperty(key) && key !== 'id' && key !== '$id') {
                                target[key] = section[key];
                            }
                        }
                    };
                    const mergeRef = (target, sourceRoot, sourceHandle, refSegment)=>{
                        let section;
                        if (refSegment === undefined || refSegment.length === 0) {
                            section = sourceRoot;
                        } else if (refSegment.charAt(0) === '/') {
                            // A $ref to a JSON Pointer (i.e #/definitions/foo)
                            section = findSectionByJSONPointer(sourceRoot, refSegment);
                        } else {
                            // A $ref to a sub-schema with an $id (i.e #hello)
                            section = findSchemaById(sourceRoot, sourceHandle, refSegment);
                        }
                        if (section) {
                            merge(target, section);
                        } else {
                            resolveErrors.push(t('$ref \'{0}\' in \'{1}\' can not be resolved.', refSegment || '', sourceHandle.uri));
                        }
                    };
                    const resolveExternalLink = (node, uri, refSegment, parentHandle)=>{
                        if (contextService && !/^[A-Za-z][A-Za-z0-9+\-.+]*:\/\/.*/.test(uri)) {
                            uri = contextService.resolveRelativePath(uri, parentHandle.uri);
                        }
                        uri = normalizeId(uri);
                        const referencedHandle = this.getOrAddSchemaHandle(uri);
                        return referencedHandle.getUnresolvedSchema().then((unresolvedSchema)=>{
                            parentHandle.dependencies.add(uri);
                            if (unresolvedSchema.errors.length) {
                                const loc = refSegment ? uri + '#' + refSegment : uri;
                                resolveErrors.push(t('Problems loading reference \'{0}\': {1}', loc, unresolvedSchema.errors[0]));
                            }
                            mergeRef(node, unresolvedSchema.schema, referencedHandle, refSegment);
                            return resolveRefs(node, unresolvedSchema.schema, referencedHandle);
                        });
                    };
                    const resolveRefs = (node, parentSchema, parentHandle)=>{
                        const openPromises = [];
                        this.traverseNodes(node, (next)=>{
                            const seenRefs = new Set();
                            while(next.$ref){
                                const ref = next.$ref;
                                const segments = ref.split('#', 2);
                                delete next.$ref;
                                if (segments[0].length > 0) {
                                    // This is a reference to an external schema
                                    openPromises.push(resolveExternalLink(next, segments[0], segments[1], parentHandle));
                                    return;
                                } else {
                                    // This is a reference inside the current schema
                                    if (!seenRefs.has(ref)) {
                                        const id = segments[1];
                                        mergeRef(next, parentSchema, parentHandle, id);
                                        seenRefs.add(ref);
                                    }
                                }
                            }
                            if (next.$recursiveRef) {
                                usesUnsupportedFeatures.add('$recursiveRef');
                            }
                            if (next.$dynamicRef) {
                                usesUnsupportedFeatures.add('$dynamicRef');
                            }
                        });
                        return this.promise.all(openPromises);
                    };
                    const collectAnchors = (root)=>{
                        const result = new Map();
                        this.traverseNodes(root, (next)=>{
                            const id = next.$id || next.id;
                            const anchor = isString(id) && id.charAt(0) === '#' ? id.substring(1) : next.$anchor;
                            if (anchor) {
                                if (result.has(anchor)) {
                                    resolveErrors.push(t('Duplicate anchor declaration: \'{0}\'', anchor));
                                } else {
                                    result.set(anchor, next);
                                }
                            }
                            if (next.$recursiveAnchor) {
                                usesUnsupportedFeatures.add('$recursiveAnchor');
                            }
                            if (next.$dynamicAnchor) {
                                usesUnsupportedFeatures.add('$dynamicAnchor');
                            }
                        });
                        return result;
                    };
                    return resolveRefs(schema, schema, handle).then((_)=>{
                        let resolveWarnings = [];
                        if (usesUnsupportedFeatures.size) {
                            resolveWarnings.push(t('The schema uses meta-schema features ({0}) that are not yet supported by the validator.', Array.from(usesUnsupportedFeatures.keys()).join(', ')));
                        }
                        return new ResolvedSchema(schema, resolveErrors, resolveWarnings, schemaDraft);
                    });
                }
                traverseNodes(root, handle) {
                    if (!root || typeof root !== 'object') {
                        return Promise.resolve(null);
                    }
                    const seen = new Set();
                    const collectEntries = (...entries)=>{
                        for (const entry of entries){
                            if (isObject(entry)) {
                                toWalk.push(entry);
                            }
                        }
                    };
                    const collectMapEntries = (...maps)=>{
                        for (const map of maps){
                            if (isObject(map)) {
                                for(const k in map){
                                    const key = k;
                                    const entry = map[key];
                                    if (isObject(entry)) {
                                        toWalk.push(entry);
                                    }
                                }
                            }
                        }
                    };
                    const collectArrayEntries = (...arrays)=>{
                        for (const array of arrays){
                            if (Array.isArray(array)) {
                                for (const entry of array){
                                    if (isObject(entry)) {
                                        toWalk.push(entry);
                                    }
                                }
                            }
                        }
                    };
                    const collectEntryOrArrayEntries = (items)=>{
                        if (Array.isArray(items)) {
                            for (const entry of items){
                                if (isObject(entry)) {
                                    toWalk.push(entry);
                                }
                            }
                        } else if (isObject(items)) {
                            toWalk.push(items);
                        }
                    };
                    const toWalk = [
                        root
                    ];
                    let next = toWalk.pop();
                    while(next){
                        if (!seen.has(next)) {
                            seen.add(next);
                            handle(next);
                            collectEntries(next.additionalItems, next.additionalProperties, next.not, next.contains, next.propertyNames, next.if, next.then, next.else, next.unevaluatedItems, next.unevaluatedProperties);
                            collectMapEntries(next.definitions, next.$defs, next.properties, next.patternProperties, next.dependencies, next.dependentSchemas);
                            collectArrayEntries(next.anyOf, next.allOf, next.oneOf, next.prefixItems);
                            collectEntryOrArrayEntries(next.items);
                        }
                        next = toWalk.pop();
                    }
                }
                getSchemaFromProperty(resource, document1) {
                    var _document_root;
                    if (((_document_root = document1.root) === null || _document_root === void 0 ? void 0 : _document_root.type) === 'object') {
                        for (const p of document1.root.properties){
                            var _p_valueNode;
                            if (p.keyNode.value === '$schema' && ((_p_valueNode = p.valueNode) === null || _p_valueNode === void 0 ? void 0 : _p_valueNode.type) === 'string') {
                                let schemaId = p.valueNode.value;
                                if (this.contextService && !/^\w[\w\d+.-]*:/.test(schemaId)) {
                                    schemaId = this.contextService.resolveRelativePath(schemaId, resource);
                                }
                                return schemaId;
                            }
                        }
                    }
                    return undefined;
                }
                getAssociatedSchemas(resource) {
                    const seen = Object.create(null);
                    const schemas = [];
                    const normalizedResource = normalizeResourceForMatching(resource);
                    for (const entry of this.filePatternAssociations){
                        if (entry.matchesPattern(normalizedResource)) {
                            for (const schemaId of entry.getURIs()){
                                if (!seen[schemaId]) {
                                    schemas.push(schemaId);
                                    seen[schemaId] = true;
                                }
                            }
                        }
                    }
                    return schemas;
                }
                getSchemaURIsForResource(resource, document1) {
                    let schemeId = document1 && this.getSchemaFromProperty(resource, document1);
                    if (schemeId) {
                        return [
                            schemeId
                        ];
                    }
                    return this.getAssociatedSchemas(resource);
                }
                getSchemaForResource(resource, document1) {
                    if (document1) {
                        // first use $schema if present
                        let schemeId = this.getSchemaFromProperty(resource, document1);
                        if (schemeId) {
                            const id = normalizeId(schemeId);
                            return this.getOrAddSchemaHandle(id).getResolvedSchema();
                        }
                    }
                    if (this.cachedSchemaForResource && this.cachedSchemaForResource.resource === resource) {
                        return this.cachedSchemaForResource.resolvedSchema;
                    }
                    const schemas = this.getAssociatedSchemas(resource);
                    const resolvedSchema = schemas.length > 0 ? this.createCombinedSchema(resource, schemas).getResolvedSchema() : this.promise.resolve(undefined);
                    this.cachedSchemaForResource = {
                        resource,
                        resolvedSchema
                    };
                    return resolvedSchema;
                }
                createCombinedSchema(resource, schemaIds) {
                    if (schemaIds.length === 1) {
                        return this.getOrAddSchemaHandle(schemaIds[0]);
                    } else {
                        const combinedSchemaId = 'schemaservice://combinedSchema/' + encodeURIComponent(resource);
                        const combinedSchema = {
                            allOf: schemaIds.map((schemaId)=>({
                                    $ref: schemaId
                                }))
                        };
                        return this.addSchemaHandle(combinedSchemaId, combinedSchema);
                    }
                }
                getMatchingSchemas(document1, jsonDocument, schema) {
                    if (schema) {
                        const id = schema.id || 'schemaservice://untitled/matchingSchemas/' + jsonSchemaService_idCounter++;
                        const handle = this.addSchemaHandle(id, schema);
                        return handle.getResolvedSchema().then((resolvedSchema)=>{
                            return jsonDocument.getMatchingSchemas(resolvedSchema.schema).filter((s)=>!s.inverted);
                        });
                    }
                    return this.getSchemaForResource(document1.uri, jsonDocument).then((schema)=>{
                        if (schema) {
                            return jsonDocument.getMatchingSchemas(schema.schema).filter((s)=>!s.inverted);
                        }
                        return [];
                    });
                }
                constructor(requestService, contextService, promiseConstructor){
                    this.contextService = contextService;
                    this.requestService = requestService;
                    this.promiseConstructor = promiseConstructor || Promise;
                    this.callOnDispose = [];
                    this.contributionSchemas = {};
                    this.contributionAssociations = [];
                    this.schemasById = {};
                    this.filePatternAssociations = [];
                    this.registeredSchemasIds = {};
                }
            }
            let jsonSchemaService_idCounter = 0;
            function normalizeId(id) {
                // remove trailing '#', normalize drive capitalization
                try {
                    return esm_URI.parse(id).toString(true);
                } catch (e) {
                    return id;
                }
            }
            function normalizeResourceForMatching(resource) {
                // remove queries and fragments, normalize drive capitalization
                try {
                    return esm_URI.parse(resource).with({
                        fragment: null,
                        query: null
                    }).toString(true);
                } catch (e) {
                    return resource;
                }
            }
            function toDisplayString(url) {
                try {
                    const uri = esm_URI.parse(url);
                    if (uri.scheme === 'file') {
                        return uri.fsPath;
                    }
                } catch (e) {
                // ignore
                }
                return url;
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/services/jsonFolding.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ function getFoldingRanges(document1, context) {
                const ranges = [];
                const nestingLevels = [];
                const stack = [];
                let prevStart = -1;
                const scanner = main_createScanner(document1.getText(), false);
                let token = scanner.scan();
                function addRange(range) {
                    ranges.push(range);
                    nestingLevels.push(stack.length);
                }
                while(token !== 17 /* SyntaxKind.EOF */ ){
                    switch(token){
                        case 1 /* SyntaxKind.OpenBraceToken */ :
                        case 3 /* SyntaxKind.OpenBracketToken */ :
                            {
                                const startLine = document1.positionAt(scanner.getTokenOffset()).line;
                                const range = {
                                    startLine,
                                    endLine: startLine,
                                    kind: token === 1 /* SyntaxKind.OpenBraceToken */  ? 'object' : 'array'
                                };
                                stack.push(range);
                                break;
                            }
                        case 2 /* SyntaxKind.CloseBraceToken */ :
                        case 4 /* SyntaxKind.CloseBracketToken */ :
                            {
                                const kind = token === 2 /* SyntaxKind.CloseBraceToken */  ? 'object' : 'array';
                                if (stack.length > 0 && stack[stack.length - 1].kind === kind) {
                                    const range = stack.pop();
                                    const line = document1.positionAt(scanner.getTokenOffset()).line;
                                    if (range && line > range.startLine + 1 && prevStart !== range.startLine) {
                                        range.endLine = line - 1;
                                        addRange(range);
                                        prevStart = range.startLine;
                                    }
                                }
                                break;
                            }
                        case 13 /* SyntaxKind.BlockCommentTrivia */ :
                            {
                                const startLine = document1.positionAt(scanner.getTokenOffset()).line;
                                const endLine = document1.positionAt(scanner.getTokenOffset() + scanner.getTokenLength()).line;
                                if (scanner.getTokenError() === 1 /* ScanError.UnexpectedEndOfComment */  && startLine + 1 < document1.lineCount) {
                                    scanner.setPosition(document1.offsetAt(Position.create(startLine + 1, 0)));
                                } else {
                                    if (startLine < endLine) {
                                        addRange({
                                            startLine,
                                            endLine,
                                            kind: FoldingRangeKind.Comment
                                        });
                                        prevStart = startLine;
                                    }
                                }
                                break;
                            }
                        case 12 /* SyntaxKind.LineCommentTrivia */ :
                            {
                                const text = document1.getText().substr(scanner.getTokenOffset(), scanner.getTokenLength());
                                const m = text.match(/^\/\/\s*#(region\b)|(endregion\b)/);
                                if (m) {
                                    const line = document1.positionAt(scanner.getTokenOffset()).line;
                                    if (m[1]) {
                                        const range = {
                                            startLine: line,
                                            endLine: line,
                                            kind: FoldingRangeKind.Region
                                        };
                                        stack.push(range);
                                    } else {
                                        let i = stack.length - 1;
                                        while(i >= 0 && stack[i].kind !== FoldingRangeKind.Region){
                                            i--;
                                        }
                                        if (i >= 0) {
                                            const range = stack[i];
                                            stack.length = i;
                                            if (line > range.startLine && prevStart !== range.startLine) {
                                                range.endLine = line;
                                                addRange(range);
                                                prevStart = range.startLine;
                                            }
                                        }
                                    }
                                }
                                break;
                            }
                    }
                    token = scanner.scan();
                }
                const rangeLimit = context && context.rangeLimit;
                if (typeof rangeLimit !== 'number' || ranges.length <= rangeLimit) {
                    return ranges;
                }
                if (context && context.onRangeLimitExceeded) {
                    context.onRangeLimitExceeded(document1.uri);
                }
                const counts = [];
                for (let level of nestingLevels){
                    if (level < 30) {
                        counts[level] = (counts[level] || 0) + 1;
                    }
                }
                let entries = 0;
                let maxLevel = 0;
                for(let i = 0; i < counts.length; i++){
                    const n = counts[i];
                    if (n) {
                        if (n + entries > rangeLimit) {
                            maxLevel = i;
                            break;
                        }
                        entries += n;
                    }
                }
                const result = [];
                for(let i = 0; i < ranges.length; i++){
                    const level = nestingLevels[i];
                    if (typeof level === 'number') {
                        if (level < maxLevel || level === maxLevel && entries++ < rangeLimit) {
                            result.push(ranges[i]);
                        }
                    }
                }
                return result;
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/services/jsonSelectionRanges.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ function getSelectionRanges(document1, positions, doc) {
                function getSelectionRange(position) {
                    let offset = document1.offsetAt(position);
                    let node = doc.getNodeFromOffset(offset, true);
                    const result = [];
                    while(node){
                        switch(node.type){
                            case 'string':
                            case 'object':
                            case 'array':
                                // range without ", [ or {
                                const cStart = node.offset + 1, cEnd = node.offset + node.length - 1;
                                if (cStart < cEnd && offset >= cStart && offset <= cEnd) {
                                    result.push(newRange(cStart, cEnd));
                                }
                                result.push(newRange(node.offset, node.offset + node.length));
                                break;
                            case 'number':
                            case 'boolean':
                            case 'null':
                            case 'property':
                                result.push(newRange(node.offset, node.offset + node.length));
                                break;
                        }
                        if (node.type === 'property' || node.parent && node.parent.type === 'array') {
                            const afterCommaOffset = getOffsetAfterNextToken(node.offset + node.length, 5 /* SyntaxKind.CommaToken */ );
                            if (afterCommaOffset !== -1) {
                                result.push(newRange(node.offset, afterCommaOffset));
                            }
                        }
                        node = node.parent;
                    }
                    let current = undefined;
                    for(let index = result.length - 1; index >= 0; index--){
                        current = SelectionRange.create(result[index], current);
                    }
                    if (!current) {
                        current = SelectionRange.create(Range.create(position, position));
                    }
                    return current;
                }
                function newRange(start, end) {
                    return Range.create(document1.positionAt(start), document1.positionAt(end));
                }
                const scanner = main_createScanner(document1.getText(), true);
                function getOffsetAfterNextToken(offset, expectedToken) {
                    scanner.setPosition(offset);
                    let token = scanner.scan();
                    if (token === expectedToken) {
                        return scanner.getTokenOffset() + scanner.getTokenLength();
                    }
                    return -1;
                }
                return positions.map(getSelectionRange);
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/utils/format.js
            function utils_format_format(documentToFormat, formattingOptions, formattingRange) {
                var _formattingOptions, _formattingOptions1, _formattingOptions2;
                let range = undefined;
                if (formattingRange) {
                    const offset = documentToFormat.offsetAt(formattingRange.start);
                    const length = documentToFormat.offsetAt(formattingRange.end) - offset;
                    range = {
                        offset,
                        length
                    };
                }
                const options = {
                    tabSize: formattingOptions ? formattingOptions.tabSize : 4,
                    insertSpaces: ((_formattingOptions = formattingOptions) === null || _formattingOptions === void 0 ? void 0 : _formattingOptions.insertSpaces) === true,
                    insertFinalNewline: ((_formattingOptions1 = formattingOptions) === null || _formattingOptions1 === void 0 ? void 0 : _formattingOptions1.insertFinalNewline) === true,
                    eol: '\n',
                    keepLines: ((_formattingOptions2 = formattingOptions) === null || _formattingOptions2 === void 0 ? void 0 : _formattingOptions2.keepLines) === true
                };
                return main_format(documentToFormat.getText(), range, options).map((edit1)=>{
                    return TextEdit.replace(Range.create(documentToFormat.positionAt(edit1.offset), documentToFormat.positionAt(edit1.offset + edit1.length)), edit1.content);
                });
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/utils/propertyTree.js
            /*---------------------------------------------------------------------------------------------
*  Copyright (c) Microsoft Corporation. All rights reserved.
*  Licensed under the MIT License. See License.txt in the project root for license information.
*--------------------------------------------------------------------------------------------*/ var Container;
            (function(Container) {
                Container[Container["Object"] = 0] = "Object";
                Container[Container["Array"] = 1] = "Array";
            })(Container || (Container = {}));
            class PropertyTree {
                addChildProperty(childProperty) {
                    childProperty.parent = this;
                    if (this.childrenProperties.length > 0) {
                        let insertionIndex = 0;
                        if (childProperty.noKeyName) {
                            insertionIndex = this.childrenProperties.length;
                        } else {
                            insertionIndex = binarySearchOnPropertyArray(this.childrenProperties, childProperty, compareProperties);
                        }
                        if (insertionIndex < 0) {
                            insertionIndex = insertionIndex * -1 - 1;
                        }
                        this.childrenProperties.splice(insertionIndex, 0, childProperty);
                    } else {
                        this.childrenProperties.push(childProperty);
                    }
                    return childProperty;
                }
                constructor(propertyName, beginningLineNumber){
                    this.propertyName = propertyName !== null && propertyName !== void 0 ? propertyName : '';
                    this.beginningLineNumber = beginningLineNumber;
                    this.childrenProperties = [];
                    this.lastProperty = false;
                    this.noKeyName = false;
                }
            }
            function compareProperties(propertyTree1, propertyTree2) {
                const propertyName1 = propertyTree1.propertyName.toLowerCase();
                const propertyName2 = propertyTree2.propertyName.toLowerCase();
                if (propertyName1 < propertyName2) {
                    return -1;
                } else if (propertyName1 > propertyName2) {
                    return 1;
                }
                return 0;
            }
            function binarySearchOnPropertyArray(propertyTreeArray, propertyTree, compare_fn) {
                const propertyName = propertyTree.propertyName.toLowerCase();
                const firstPropertyInArrayName = propertyTreeArray[0].propertyName.toLowerCase();
                const lastPropertyInArrayName = propertyTreeArray[propertyTreeArray.length - 1].propertyName.toLowerCase();
                if (propertyName < firstPropertyInArrayName) {
                    return 0;
                }
                if (propertyName > lastPropertyInArrayName) {
                    return propertyTreeArray.length;
                }
                let m = 0;
                let n = propertyTreeArray.length - 1;
                while(m <= n){
                    let k = n + m >> 1;
                    let cmp = compare_fn(propertyTree, propertyTreeArray[k]);
                    if (cmp > 0) {
                        m = k + 1;
                    } else if (cmp < 0) {
                        n = k - 1;
                    } else {
                        return k;
                    }
                }
                return -m - 1;
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/utils/sort.js
            /*---------------------------------------------------------------------------------------------
*  Copyright (c) Microsoft Corporation. All rights reserved.
*  Licensed under the MIT License. See License.txt in the project root for license information.
*--------------------------------------------------------------------------------------------*/ function sort(documentToSort, formattingOptions) {
                const options = {
                    ...formattingOptions,
                    keepLines: false
                };
                const formattedJsonString = main /* TextDocument */ .V.applyEdits(documentToSort, utils_format_format(documentToSort, options, undefined));
                const formattedJsonDocument = main /* TextDocument */ .V.create('test://test.json', 'json', 0, formattedJsonString);
                const jsonPropertyTree = findJsoncPropertyTree(formattedJsonDocument);
                const sortedJsonDocument = sortJsoncDocument(formattedJsonDocument, jsonPropertyTree);
                const edits = utils_format_format(sortedJsonDocument, options, undefined);
                const sortedAndFormattedJsonDocument = main /* TextDocument */ .V.applyEdits(sortedJsonDocument, edits);
                return [
                    TextEdit.replace(Range.create(Position.create(0, 0), documentToSort.positionAt(documentToSort.getText().length)), sortedAndFormattedJsonDocument)
                ];
            }
            function findJsoncPropertyTree(formattedDocument) {
                const formattedString = formattedDocument.getText();
                const scanner = main_createScanner(formattedString, false);
                // The tree that will be returned
                let rootTree = new PropertyTree();
                // The tree where the current properties can be added as children
                let currentTree = rootTree;
                // The tree representing the current property analyzed
                let currentProperty = rootTree;
                // The tree representing the previous property analyzed
                let lastProperty = rootTree;
                // The current scanned token
                let token = undefined;
                // Line number of the last token found
                let lastTokenLine = 0;
                // Total number of characters on the lines prior to current line 
                let numberOfCharactersOnPreviousLines = 0;
                // The last token scanned that is not trivial, nor a comment
                let lastNonTriviaNonCommentToken = undefined;
                // The second to last token scanned that is not trivial, nor a comment
                let secondToLastNonTriviaNonCommentToken = undefined;
                // Line number of last token that is not trivial, nor a comment
                let lineOfLastNonTriviaNonCommentToken = -1;
                // End index on its line of last token that is not trivial, nor a comment
                let endIndexOfLastNonTriviaNonCommentToken = -1;
                // Line number of the start of the range of current/next property
                let beginningLineNumber = 0;
                // Line number of the end of the range of current/next property
                let endLineNumber = 0;
                // Stack indicating whether we are inside of an object or an array
                let currentContainerStack = [];
                // Boolean indicating that the current property end line number needs to be updated. Used only when block comments are encountered.
                let updateLastPropertyEndLineNumber = false;
                // Boolean indicating that the beginning line number should be updated. Used only when block comments are encountered. 
                let updateBeginningLineNumber = false;
                while((token = scanner.scan()) !== 17 /* SyntaxKind.EOF */ ){
                    // In the case when a block comment has been encountered that starts on the same line as the comma ending a property, update the end line of that
                    // property so that it covers the block comment. For example, if we have: 
                    // 1. "key" : {}, /* some block
                    // 2. comment */
                    // Then, the end line of the property "key" should be line 2 not line 1
                    if (updateLastPropertyEndLineNumber === true && token !== 14 /* SyntaxKind.LineBreakTrivia */  && token !== 15 /* SyntaxKind.Trivia */  && token !== 12 /* SyntaxKind.LineCommentTrivia */  && token !== 13 /* SyntaxKind.BlockCommentTrivia */  && currentProperty.endLineNumber === undefined) {
                        let endLineNumber = scanner.getTokenStartLine();
                        // Update the end line number in the case when the last property visited is a container (object or array)
                        if (secondToLastNonTriviaNonCommentToken === 2 /* SyntaxKind.CloseBraceToken */  || secondToLastNonTriviaNonCommentToken === 4 /* SyntaxKind.CloseBracketToken */ ) {
                            lastProperty.endLineNumber = endLineNumber - 1;
                        } else {
                            currentProperty.endLineNumber = endLineNumber - 1;
                        }
                        beginningLineNumber = endLineNumber;
                        updateLastPropertyEndLineNumber = false;
                    }
                    // When a block comment follows an open brace or an open bracket, that block comment should be associated to that brace or bracket, not the property below it. For example, for:
                    // 1. { /*
                    // 2. ... */
                    // 3. "key" : {}
                    // 4. }
                    // Instead of associating the block comment to the property on line 3, it is associate to the property on line 1
                    if (updateBeginningLineNumber === true && token !== 14 /* SyntaxKind.LineBreakTrivia */  && token !== 15 /* SyntaxKind.Trivia */  && token !== 12 /* SyntaxKind.LineCommentTrivia */  && token !== 13 /* SyntaxKind.BlockCommentTrivia */ ) {
                        beginningLineNumber = scanner.getTokenStartLine();
                        updateBeginningLineNumber = false;
                    }
                    // Update the number of characters on all the previous lines each time the new token is on a different line to the previous token
                    if (scanner.getTokenStartLine() !== lastTokenLine) {
                        for(let i = lastTokenLine; i < scanner.getTokenStartLine(); i++){
                            const lengthOfLine = formattedDocument.getText(Range.create(Position.create(i, 0), Position.create(i + 1, 0))).length;
                            numberOfCharactersOnPreviousLines = numberOfCharactersOnPreviousLines + lengthOfLine;
                        }
                        lastTokenLine = scanner.getTokenStartLine();
                    }
                    switch(token){
                        // When a string is found, if it follows an open brace or a comma token and it is within an object, then it corresponds to a key name, not a simple string
                        case 10 /* SyntaxKind.StringLiteral */ :
                            {
                                if (lastNonTriviaNonCommentToken === undefined || lastNonTriviaNonCommentToken === 1 /* SyntaxKind.OpenBraceToken */  || lastNonTriviaNonCommentToken === 5 /* SyntaxKind.CommaToken */  && currentContainerStack[currentContainerStack.length - 1] === Container.Object) {
                                    // In that case create the child property which starts at beginningLineNumber, add it to the current tree
                                    const childProperty = new PropertyTree(scanner.getTokenValue(), beginningLineNumber);
                                    lastProperty = currentProperty;
                                    currentProperty = currentTree.addChildProperty(childProperty);
                                }
                                break;
                            }
                        // When the token is an open bracket, then we enter into an array
                        case 3 /* SyntaxKind.OpenBracketToken */ :
                            {
                                // If the root tree beginning line number is not defined, then this open bracket is the first open bracket in the document
                                if (rootTree.beginningLineNumber === undefined) {
                                    rootTree.beginningLineNumber = scanner.getTokenStartLine();
                                }
                                // Suppose we are inside of an object, then the current array is associated to a key, and has already been created
                                // We have the following configuration: {"a": "val", "array": [...], "b": "val"}
                                // In that case navigate down to the child property
                                if (currentContainerStack[currentContainerStack.length - 1] === Container.Object) {
                                    currentTree = currentProperty;
                                } else if (currentContainerStack[currentContainerStack.length - 1] === Container.Array) {
                                    const childProperty = new PropertyTree(scanner.getTokenValue(), beginningLineNumber);
                                    childProperty.noKeyName = true;
                                    lastProperty = currentProperty;
                                    currentProperty = currentTree.addChildProperty(childProperty);
                                    currentTree = currentProperty;
                                }
                                currentContainerStack.push(Container.Array);
                                currentProperty.type = Container.Array;
                                beginningLineNumber = scanner.getTokenStartLine();
                                beginningLineNumber++;
                                break;
                            }
                        // When the token is an open brace, then we enter into an object
                        case 1 /* SyntaxKind.OpenBraceToken */ :
                            {
                                // If the root tree beginning line number is not defined, then this open brace is the first open brace in the document
                                if (rootTree.beginningLineNumber === undefined) {
                                    rootTree.beginningLineNumber = scanner.getTokenStartLine();
                                } else if (currentContainerStack[currentContainerStack.length - 1] === Container.Array) {
                                    const childProperty = new PropertyTree(scanner.getTokenValue(), beginningLineNumber);
                                    childProperty.noKeyName = true;
                                    lastProperty = currentProperty;
                                    currentProperty = currentTree.addChildProperty(childProperty);
                                }
                                currentProperty.type = Container.Object;
                                currentContainerStack.push(Container.Object);
                                currentTree = currentProperty;
                                beginningLineNumber = scanner.getTokenStartLine();
                                beginningLineNumber++;
                                break;
                            }
                        case 4 /* SyntaxKind.CloseBracketToken */ :
                            {
                                endLineNumber = scanner.getTokenStartLine();
                                currentContainerStack.pop();
                                // If the last non-trivial non-comment token is a closing brace or bracket, then the currentProperty end line number has not been set yet so set it
                                // The configuration considered is: [..., {}] or [..., []]
                                if (currentProperty.endLineNumber === undefined && (lastNonTriviaNonCommentToken === 2 /* SyntaxKind.CloseBraceToken */  || lastNonTriviaNonCommentToken === 4 /* SyntaxKind.CloseBracketToken */ )) {
                                    currentProperty.endLineNumber = endLineNumber - 1;
                                    currentProperty.lastProperty = true;
                                    currentProperty.lineWhereToAddComma = lineOfLastNonTriviaNonCommentToken;
                                    currentProperty.indexWhereToAddComa = endIndexOfLastNonTriviaNonCommentToken;
                                    lastProperty = currentProperty;
                                    currentProperty = currentProperty ? currentProperty.parent : undefined;
                                    currentTree = currentProperty;
                                }
                                rootTree.endLineNumber = endLineNumber;
                                beginningLineNumber = endLineNumber + 1;
                                break;
                            }
                        case 2 /* SyntaxKind.CloseBraceToken */ :
                            {
                                endLineNumber = scanner.getTokenStartLine();
                                currentContainerStack.pop();
                                // If we are not inside of an empty object
                                if (lastNonTriviaNonCommentToken !== 1 /* SyntaxKind.OpenBraceToken */ ) {
                                    // If current property end line number has not yet been defined, define it
                                    if (currentProperty.endLineNumber === undefined) {
                                        currentProperty.endLineNumber = endLineNumber - 1;
                                        // The current property is also the last property
                                        currentProperty.lastProperty = true;
                                        // The last property of an object is associated with the line and index of where to add the comma, in case after sorting, it is no longer the last property
                                        currentProperty.lineWhereToAddComma = lineOfLastNonTriviaNonCommentToken;
                                        currentProperty.indexWhereToAddComa = endIndexOfLastNonTriviaNonCommentToken;
                                    }
                                    lastProperty = currentProperty;
                                    currentProperty = currentProperty ? currentProperty.parent : undefined;
                                    currentTree = currentProperty;
                                }
                                rootTree.endLineNumber = scanner.getTokenStartLine();
                                beginningLineNumber = endLineNumber + 1;
                                break;
                            }
                        case 5 /* SyntaxKind.CommaToken */ :
                            {
                                endLineNumber = scanner.getTokenStartLine();
                                // If the current container is an object or the current container is an array and the last non-trivia non-comment token is a closing brace or a closing bracket
                                // Then update the end line number of the current property
                                if (currentProperty.endLineNumber === undefined && (currentContainerStack[currentContainerStack.length - 1] === Container.Object || currentContainerStack[currentContainerStack.length - 1] === Container.Array && (lastNonTriviaNonCommentToken === 2 /* SyntaxKind.CloseBraceToken */  || lastNonTriviaNonCommentToken === 4 /* SyntaxKind.CloseBracketToken */ ))) {
                                    currentProperty.endLineNumber = endLineNumber;
                                    // Store the line and the index of the comma in case it needs to be removed during the sorting
                                    currentProperty.commaIndex = scanner.getTokenOffset() - numberOfCharactersOnPreviousLines;
                                    currentProperty.commaLine = endLineNumber;
                                }
                                if (lastNonTriviaNonCommentToken === 2 /* SyntaxKind.CloseBraceToken */  || lastNonTriviaNonCommentToken === 4 /* SyntaxKind.CloseBracketToken */ ) {
                                    lastProperty = currentProperty;
                                    currentProperty = currentProperty ? currentProperty.parent : undefined;
                                    currentTree = currentProperty;
                                }
                                beginningLineNumber = endLineNumber + 1;
                                break;
                            }
                        case 13 /* SyntaxKind.BlockCommentTrivia */ :
                            {
                                // If the last non trivia non-comment token is a comma and the block comment starts on the same line as the comma, then update the end line number of the current property. For example if:
                                // 1. {}, /* ...
                                // 2. ..*/
                                // The the property on line 1 shoud end on line 2, not line 1
                                // In the case we are in an array we update the end line number only if the second to last non-trivia non-comment token is a closing brace or bracket
                                if (lastNonTriviaNonCommentToken === 5 /* SyntaxKind.CommaToken */  && lineOfLastNonTriviaNonCommentToken === scanner.getTokenStartLine() && (currentContainerStack[currentContainerStack.length - 1] === Container.Array && (secondToLastNonTriviaNonCommentToken === 2 /* SyntaxKind.CloseBraceToken */  || secondToLastNonTriviaNonCommentToken === 4 /* SyntaxKind.CloseBracketToken */ ) || currentContainerStack[currentContainerStack.length - 1] === Container.Object)) {
                                    if (currentContainerStack[currentContainerStack.length - 1] === Container.Array && (secondToLastNonTriviaNonCommentToken === 2 /* SyntaxKind.CloseBraceToken */  || secondToLastNonTriviaNonCommentToken === 4 /* SyntaxKind.CloseBracketToken */ ) || currentContainerStack[currentContainerStack.length - 1] === Container.Object) {
                                        currentProperty.endLineNumber = undefined;
                                        updateLastPropertyEndLineNumber = true;
                                    }
                                }
                                // When the block comment follows an open brace or an open token, we have the following scenario:
                                // { /**
                                // ../
                                // }
                                // The block comment should be assigned to the open brace not the first property below it
                                if ((lastNonTriviaNonCommentToken === 1 /* SyntaxKind.OpenBraceToken */  || lastNonTriviaNonCommentToken === 3 /* SyntaxKind.OpenBracketToken */ ) && lineOfLastNonTriviaNonCommentToken === scanner.getTokenStartLine()) {
                                    updateBeginningLineNumber = true;
                                }
                                break;
                            }
                    }
                    // Update the last and second to last non-trivia non-comment tokens
                    if (token !== 14 /* SyntaxKind.LineBreakTrivia */  && token !== 13 /* SyntaxKind.BlockCommentTrivia */  && token !== 12 /* SyntaxKind.LineCommentTrivia */  && token !== 15 /* SyntaxKind.Trivia */ ) {
                        secondToLastNonTriviaNonCommentToken = lastNonTriviaNonCommentToken;
                        lastNonTriviaNonCommentToken = token;
                        lineOfLastNonTriviaNonCommentToken = scanner.getTokenStartLine();
                        endIndexOfLastNonTriviaNonCommentToken = scanner.getTokenOffset() + scanner.getTokenLength() - numberOfCharactersOnPreviousLines;
                    }
                }
                return rootTree;
            }
            function sortJsoncDocument(jsonDocument, propertyTree) {
                if (propertyTree.childrenProperties.length === 0) {
                    return jsonDocument;
                }
                const sortedJsonDocument = main /* TextDocument */ .V.create('test://test.json', 'json', 0, jsonDocument.getText());
                const queueToSort = [];
                updateSortingQueue(queueToSort, propertyTree, propertyTree.beginningLineNumber);
                while(queueToSort.length > 0){
                    const dataToSort = queueToSort.shift();
                    const propertyTreeArray = dataToSort.propertyTreeArray;
                    let beginningLineNumber = dataToSort.beginningLineNumber;
                    for(let i = 0; i < propertyTreeArray.length; i++){
                        const propertyTree = propertyTreeArray[i];
                        const range = Range.create(Position.create(propertyTree.beginningLineNumber, 0), Position.create(propertyTree.endLineNumber + 1, 0));
                        const jsonContentToReplace = jsonDocument.getText(range);
                        const jsonDocumentToReplace = main /* TextDocument */ .V.create('test://test.json', 'json', 0, jsonContentToReplace);
                        if (propertyTree.lastProperty === true && i !== propertyTreeArray.length - 1) {
                            const lineWhereToAddComma = propertyTree.lineWhereToAddComma - propertyTree.beginningLineNumber;
                            const indexWhereToAddComma = propertyTree.indexWhereToAddComa;
                            const edit1 = {
                                range: Range.create(Position.create(lineWhereToAddComma, indexWhereToAddComma), Position.create(lineWhereToAddComma, indexWhereToAddComma)),
                                text: ','
                            };
                            main /* TextDocument */ .V.update(jsonDocumentToReplace, [
                                edit1
                            ], 1);
                        } else if (propertyTree.lastProperty === false && i === propertyTreeArray.length - 1) {
                            const commaIndex = propertyTree.commaIndex;
                            const commaLine = propertyTree.commaLine;
                            const lineWhereToRemoveComma = commaLine - propertyTree.beginningLineNumber;
                            const edit1 = {
                                range: Range.create(Position.create(lineWhereToRemoveComma, commaIndex), Position.create(lineWhereToRemoveComma, commaIndex + 1)),
                                text: ''
                            };
                            main /* TextDocument */ .V.update(jsonDocumentToReplace, [
                                edit1
                            ], 1);
                        }
                        const length = propertyTree.endLineNumber - propertyTree.beginningLineNumber + 1;
                        const edit1 = {
                            range: Range.create(Position.create(beginningLineNumber, 0), Position.create(beginningLineNumber + length, 0)),
                            text: jsonDocumentToReplace.getText()
                        };
                        main /* TextDocument */ .V.update(sortedJsonDocument, [
                            edit1
                        ], 1);
                        updateSortingQueue(queueToSort, propertyTree, beginningLineNumber);
                        beginningLineNumber = beginningLineNumber + length;
                    }
                }
                return sortedJsonDocument;
            }
            function sortPropertiesCaseSensitive(properties) {
                properties.sort((a, b)=>{
                    var _a_propertyName;
                    const aName = (_a_propertyName = a.propertyName) !== null && _a_propertyName !== void 0 ? _a_propertyName : '';
                    var _b_propertyName;
                    const bName = (_b_propertyName = b.propertyName) !== null && _b_propertyName !== void 0 ? _b_propertyName : '';
                    return aName < bName ? -1 : aName > bName ? 1 : 0;
                });
            }
            function updateSortingQueue(queue, propertyTree, beginningLineNumber) {
                if (propertyTree.childrenProperties.length === 0) {
                    return;
                }
                if (propertyTree.type === Container.Object) {
                    let minimumBeginningLineNumber = Infinity;
                    for (const childProperty of propertyTree.childrenProperties){
                        if (childProperty.beginningLineNumber < minimumBeginningLineNumber) {
                            minimumBeginningLineNumber = childProperty.beginningLineNumber;
                        }
                    }
                    const diff = minimumBeginningLineNumber - propertyTree.beginningLineNumber;
                    beginningLineNumber = beginningLineNumber + diff;
                    sortPropertiesCaseSensitive(propertyTree.childrenProperties);
                    queue.push(new SortingRange(beginningLineNumber, propertyTree.childrenProperties));
                } else if (propertyTree.type === Container.Array) {
                    updateSortingQueueForArrayProperties(queue, propertyTree, beginningLineNumber);
                }
            }
            function updateSortingQueueForArrayProperties(queue, propertyTree, beginningLineNumber) {
                for (const subObject of propertyTree.childrenProperties){
                    // If the child property of the array is an object, then you can sort the properties within this object
                    if (subObject.type === Container.Object) {
                        let minimumBeginningLineNumber = Infinity;
                        for (const childProperty of subObject.childrenProperties){
                            if (childProperty.beginningLineNumber < minimumBeginningLineNumber) {
                                minimumBeginningLineNumber = childProperty.beginningLineNumber;
                            }
                        }
                        const diff = minimumBeginningLineNumber - subObject.beginningLineNumber;
                        queue.push(new SortingRange(beginningLineNumber + subObject.beginningLineNumber - propertyTree.beginningLineNumber + diff, subObject.childrenProperties));
                    }
                    // If the child property of the array is an array, then you need to recurse on the children properties, until you find an object to sort
                    if (subObject.type === Container.Array) {
                        updateSortingQueueForArrayProperties(queue, subObject, beginningLineNumber + subObject.beginningLineNumber - propertyTree.beginningLineNumber);
                    }
                }
            }
            class SortingRange {
                constructor(beginningLineNumber, propertyTreeArray){
                    this.beginningLineNumber = beginningLineNumber;
                    this.propertyTreeArray = propertyTreeArray;
                }
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/services/jsonLinks.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ function findLinks(document1, doc) {
                const links = [];
                doc.visit((node)=>{
                    var _node_valueNode;
                    if (node.type === "property" && node.keyNode.value === "$ref" && ((_node_valueNode = node.valueNode) === null || _node_valueNode === void 0 ? void 0 : _node_valueNode.type) === 'string') {
                        const path = node.valueNode.value;
                        const targetNode = findTargetNode(doc, path);
                        if (targetNode) {
                            const targetPos = document1.positionAt(targetNode.offset);
                            links.push({
                                target: `${document1.uri}#${targetPos.line + 1},${targetPos.character + 1}`,
                                range: createRange(document1, node.valueNode)
                            });
                        }
                    }
                    return true;
                });
                return Promise.resolve(links);
            }
            function createRange(document1, node) {
                return Range.create(document1.positionAt(node.offset + 1), document1.positionAt(node.offset + node.length - 1));
            }
            function findTargetNode(doc, path) {
                const tokens = parseJSONPointer(path);
                if (!tokens) {
                    return null;
                }
                return findNode(tokens, doc.root);
            }
            function findNode(pointer, node) {
                if (!node) {
                    return null;
                }
                if (pointer.length === 0) {
                    return node;
                }
                const token = pointer.shift();
                if (node && node.type === 'object') {
                    const propertyNode = node.properties.find((propertyNode)=>propertyNode.keyNode.value === token);
                    if (!propertyNode) {
                        return null;
                    }
                    return findNode(pointer, propertyNode.valueNode);
                } else if (node && node.type === 'array') {
                    if (token.match(/^(0|[1-9][0-9]*)$/)) {
                        const index = Number.parseInt(token);
                        const arrayItem = node.items[index];
                        if (!arrayItem) {
                            return null;
                        }
                        return findNode(pointer, arrayItem);
                    }
                }
                return null;
            }
            function parseJSONPointer(path) {
                if (path === "#") {
                    return [];
                }
                if (path[0] !== '#' || path[1] !== '/') {
                    return null;
                }
                return path.substring(2).split(/\//).map(jsonLinks_unescape);
            }
            function jsonLinks_unescape(str) {
                return str.replace(/~1/g, '/').replace(/~0/g, '~');
            }
            ; // CONCATENATED MODULE: ../../node_modules/vscode-json-languageservice/lib/esm/jsonLanguageService.js
            /*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ function getLanguageService(params) {
                const promise = params.promiseConstructor || Promise;
                const jsonSchemaService = new JSONSchemaService(params.schemaRequestService, params.workspaceContext, promise);
                jsonSchemaService.setSchemaContributions(schemaContributions);
                const jsonCompletion = new JSONCompletion(jsonSchemaService, params.contributions, promise, params.clientCapabilities);
                const jsonHover = new JSONHover(jsonSchemaService, params.contributions, promise);
                const jsonDocumentSymbols = new JSONDocumentSymbols(jsonSchemaService);
                const jsonValidation = new JSONValidation(jsonSchemaService, promise);
                return {
                    configure: (settings)=>{
                        var _settings_schemas;
                        jsonSchemaService.clearExternalSchemas();
                        (_settings_schemas = settings.schemas) === null || _settings_schemas === void 0 ? void 0 : _settings_schemas.forEach(jsonSchemaService.registerExternalSchema.bind(jsonSchemaService));
                        jsonValidation.configure(settings);
                    },
                    resetSchema: (uri)=>jsonSchemaService.onResourceChange(uri),
                    doValidation: jsonValidation.doValidation.bind(jsonValidation),
                    getLanguageStatus: jsonValidation.getLanguageStatus.bind(jsonValidation),
                    parseJSONDocument: (document1)=>jsonParser_parse(document1, {
                            collectComments: true
                        }),
                    newJSONDocument: (root, diagnostics)=>newJSONDocument(root, diagnostics),
                    getMatchingSchemas: jsonSchemaService.getMatchingSchemas.bind(jsonSchemaService),
                    doResolve: jsonCompletion.doResolve.bind(jsonCompletion),
                    doComplete: jsonCompletion.doComplete.bind(jsonCompletion),
                    findDocumentSymbols: jsonDocumentSymbols.findDocumentSymbols.bind(jsonDocumentSymbols),
                    findDocumentSymbols2: jsonDocumentSymbols.findDocumentSymbols2.bind(jsonDocumentSymbols),
                    findDocumentColors: jsonDocumentSymbols.findDocumentColors.bind(jsonDocumentSymbols),
                    getColorPresentations: jsonDocumentSymbols.getColorPresentations.bind(jsonDocumentSymbols),
                    doHover: jsonHover.doHover.bind(jsonHover),
                    getFoldingRanges: getFoldingRanges,
                    getSelectionRanges: getSelectionRanges,
                    findDefinition: ()=>Promise.resolve([]),
                    findLinks: findLinks,
                    format: (document1, range, options)=>utils_format_format(document1, options, range),
                    sort: (document1, options)=>sort(document1, options)
                };
            }
            // EXTERNAL MODULE: ../../node_modules/vscode-languageserver-protocol/lib/browser/main.js
            var browser_main = __nested_webpack_require_714846__(5501);
            // EXTERNAL MODULE: ./src/utils.ts
            var utils = __nested_webpack_require_714846__(7770);
            ; // CONCATENATED MODULE: ./src/ace/range-singleton.ts
            function _define_property1(obj, key, value) {
                if (key in obj) {
                    Object.defineProperty(obj, key, {
                        value: value,
                        enumerable: true,
                        configurable: true,
                        writable: true
                    });
                } else {
                    obj[key] = value;
                }
                return obj;
            }
            class AceRange {
                static getConstructor(editor) {
                    if (!AceRange._instance && editor) {
                        AceRange._instance = editor.getSelectionRange().constructor;
                    }
                    return AceRange._instance;
                }
            }
            _define_property1(AceRange, "_instance", void 0);
            ; // CONCATENATED MODULE: ./src/type-converters/common-converters.ts
            var common_converters_CommonConverter;
            (function(CommonConverter1) {
                function normalizeRanges(completions) {
                    return completions && completions.map((el)=>{
                        if (el["range"]) {
                            el["range"] = toRange(el["range"]);
                        }
                        return el;
                    });
                }
                CommonConverter1.normalizeRanges = normalizeRanges;
                function cleanHtml(html) {
                    return html.replace(/<a\s/, "<a target='_blank' ");
                }
                CommonConverter1.cleanHtml = cleanHtml;
                function toRange(range) {
                    if (!range || !range.start || !range.end) {
                        return;
                    }
                    let Range = AceRange.getConstructor();
                    // @ts-ignore
                    return Range.fromPoints(range.start, range.end);
                }
                CommonConverter1.toRange = toRange;
                function convertKind(kind) {
                    switch(kind){
                        case "primitiveType":
                        case "keyword":
                            return browser_main.CompletionItemKind.Keyword;
                        case "variable":
                        case "localVariable":
                            return browser_main.CompletionItemKind.Variable;
                        case "memberVariable":
                        case "memberGetAccessor":
                        case "memberSetAccessor":
                            return browser_main.CompletionItemKind.Field;
                        case "function":
                        case "memberFunction":
                        case "constructSignature":
                        case "callSignature":
                        case "indexSignature":
                            return browser_main.CompletionItemKind.Function;
                        case "enum":
                            return browser_main.CompletionItemKind.Enum;
                        case "module":
                            return browser_main.CompletionItemKind.Module;
                        case "class":
                            return browser_main.CompletionItemKind.Class;
                        case "interface":
                            return browser_main.CompletionItemKind.Interface;
                        case "warning":
                            return browser_main.CompletionItemKind.File;
                    }
                    return browser_main.CompletionItemKind.Property;
                }
                CommonConverter1.convertKind = convertKind;
                function excludeByErrorMessage(diagnostics, errorMessagesToIgnore, fieldName = "message") {
                    if (!errorMessagesToIgnore) return diagnostics;
                    return diagnostics.filter((el)=>!(0, utils /* checkValueAgainstRegexpArray */ .Tk)(el[fieldName], errorMessagesToIgnore));
                }
                CommonConverter1.excludeByErrorMessage = excludeByErrorMessage;
            })(common_converters_CommonConverter || (common_converters_CommonConverter = {}));
            ; // CONCATENATED MODULE: ./src/type-converters/lsp/lsp-converters.ts
            function fromRange(range) {
                return {
                    start: {
                        line: range.start.row,
                        character: range.start.column
                    },
                    end: {
                        line: range.end.row,
                        character: range.end.column
                    }
                };
            }
            function rangeFromPositions(start, end) {
                return {
                    start: start,
                    end: end
                };
            }
            function toRange(range) {
                return {
                    start: {
                        row: range.start.line,
                        column: range.start.character
                    },
                    end: {
                        row: range.end.line,
                        column: range.end.character
                    }
                };
            }
            function fromPoint(point) {
                return {
                    line: point.row,
                    character: point.column
                };
            }
            function toPoint(position) {
                return {
                    row: position.line,
                    column: position.character
                };
            }
            function toAnnotations(diagnostics) {
                var _diagnostics;
                return (_diagnostics = diagnostics) === null || _diagnostics === void 0 ? void 0 : _diagnostics.map((el)=>{
                    return {
                        row: el.range.start.line,
                        column: el.range.start.character,
                        text: el.message,
                        type: el.severity === 1 ? "error" : el.severity === 2 ? "warning" : "info",
                        code: el.code
                    };
                });
            }
            function fromAnnotations(annotations) {
                var _annotations;
                return (_annotations = annotations) === null || _annotations === void 0 ? void 0 : _annotations.map((el)=>{
                    return {
                        range: {
                            start: {
                                line: el.row,
                                character: el.column
                            },
                            end: {
                                line: el.row,
                                character: el.column
                            }
                        },
                        message: el.text,
                        severity: el.type === "error" ? 1 : el.type === "warning" ? 2 : 3,
                        code: el["code"]
                    };
                });
            }
            function toCompletion(item) {
                var _item_textEdit, _item_command;
                let itemKind = item.kind;
                let kind = itemKind ? Object.keys(CompletionItemKind)[Object.values(CompletionItemKind).indexOf(itemKind)] : undefined;
                var _item_textEdit_newText, _ref;
                let text = (_ref = (_item_textEdit_newText = (_item_textEdit = item.textEdit) === null || _item_textEdit === void 0 ? void 0 : _item_textEdit.newText) !== null && _item_textEdit_newText !== void 0 ? _item_textEdit_newText : item.insertText) !== null && _ref !== void 0 ? _ref : item.label;
                let filterText;
                // filtering would happen on ace editor side
                //TODO: if filtering and sorting are on server side, we should disable FilteredList in ace completer
                if (item.filterText) {
                    const firstWordMatch = item.filterText.match(/\w+/);
                    const firstWord = firstWordMatch ? firstWordMatch[0] : null;
                    if (firstWord) {
                        const wordRegex = new RegExp(`\\b${firstWord}\\b`, 'i');
                        if (!wordRegex.test(text)) {
                            text = `${item.filterText} ${text}`;
                            filterText = item.filterText;
                        }
                    } else {
                        if (!text.includes(item.filterText)) {
                            text = `${item.filterText} ${text}`;
                            filterText = item.filterText;
                        }
                    }
                }
                let command = ((_item_command = item.command) === null || _item_command === void 0 ? void 0 : _item_command.command) == "editor.action.triggerSuggest" ? "startAutocomplete" : undefined;
                let range = item.textEdit ? getTextEditRange(item.textEdit, filterText) : undefined;
                let completion = {
                    meta: kind,
                    caption: item.label,
                    score: undefined
                };
                completion["command"] = command;
                completion["range"] = range;
                completion["item"] = item;
                if (item.insertTextFormat == InsertTextFormat.Snippet) {
                    completion["snippet"] = text;
                } else {
                    completion["value"] = text !== null && text !== void 0 ? text : "";
                }
                completion["documentation"] = item.documentation; //TODO: this is workaround for services with instant completion
                completion["position"] = item["position"];
                completion["service"] = item["service"]; //TODO: since we have multiple servers, we need to determine which
                // server to use for resolving
                return completion;
            }
            function toCompletions(completions) {
                if (completions.length > 0) {
                    let combinedCompletions = completions.map((el)=>{
                        if (!el.completions) {
                            return [];
                        }
                        let allCompletions;
                        if (Array.isArray(el.completions)) {
                            allCompletions = el.completions;
                        } else {
                            allCompletions = el.completions.items;
                        }
                        return allCompletions.map((item)=>{
                            item["service"] = el.service;
                            return item;
                        });
                    }).flat();
                    return combinedCompletions.map((item)=>toCompletion(item));
                }
                return [];
            }
            function toResolvedCompletion(completion, item) {
                completion["docMarkdown"] = fromMarkupContent(item.documentation);
                return completion;
            }
            function toCompletionItem(completion) {
                let command;
                if (completion["command"]) {
                    command = {
                        title: "triggerSuggest",
                        command: completion["command"]
                    };
                }
                var _completion_caption;
                let completionItem = {
                    label: (_completion_caption = completion.caption) !== null && _completion_caption !== void 0 ? _completion_caption : "",
                    kind: CommonConverter.convertKind(completion.meta),
                    command: command,
                    insertTextFormat: completion["snippet"] ? InsertTextFormat.Snippet : InsertTextFormat.PlainText,
                    documentation: completion["documentation"]
                };
                if (completion["range"]) {
                    var _completion_snippet;
                    completionItem.textEdit = {
                        range: fromRange(completion["range"]),
                        newText: (_completion_snippet = completion["snippet"]) !== null && _completion_snippet !== void 0 ? _completion_snippet : completion["value"]
                    };
                } else {
                    var _completion_snippet1;
                    completionItem.insertText = (_completion_snippet1 = completion["snippet"]) !== null && _completion_snippet1 !== void 0 ? _completion_snippet1 : completion["value"];
                }
                completionItem["fileName"] = completion["fileName"];
                completionItem["position"] = completion["position"];
                completionItem["item"] = completion["item"];
                completionItem["service"] = completion["service"]; //TODO:
                return completionItem;
            }
            function getTextEditRange(textEdit, filterText) {
                const filterLength = filterText ? filterText.length : 0;
                if ("insert" in textEdit && "replace" in textEdit) {
                    let mergedRanges = mergeRanges([
                        toRange(textEdit.insert),
                        toRange(textEdit.replace)
                    ]);
                    return mergedRanges[0];
                } else {
                    textEdit.range.start.character -= filterLength;
                    return toRange(textEdit.range);
                }
            }
            function toTooltip(hover) {
                var _hover_find;
                if (!hover) return;
                let content = hover.map((el)=>{
                    if (!el || !el.contents) return;
                    if (MarkupContent.is(el.contents)) {
                        return fromMarkupContent(el.contents);
                    } else if (MarkedString.is(el.contents)) {
                        if (typeof el.contents === "string") {
                            return el.contents;
                        }
                        return "```" + el.contents.value + "```";
                    } else {
                        let contents = el.contents.map((el)=>{
                            if (typeof el !== "string") {
                                return `\`\`\`${el.value}\`\`\``;
                            } else {
                                return el;
                            }
                        });
                        return contents.join("\n\n");
                    }
                }).filter(notEmpty);
                if (content.length === 0) return;
                //TODO: it could be merged within all ranges in future
                let lspRange = (_hover_find = hover.find((el)=>{
                    var _el;
                    return (_el = el) === null || _el === void 0 ? void 0 : _el.range;
                })) === null || _hover_find === void 0 ? void 0 : _hover_find.range;
                let range;
                if (lspRange) range = toRange(lspRange);
                return {
                    content: {
                        type: "markdown",
                        text: content.join("\n\n")
                    },
                    range: range
                };
            }
            function fromSignatureHelp(signatureHelp) {
                if (!signatureHelp) return;
                let content = signatureHelp.map((el)=>{
                    var _el, _el1;
                    if (!el) return;
                    let signatureIndex = ((_el = el) === null || _el === void 0 ? void 0 : _el.activeSignature) || 0;
                    let activeSignature = el.signatures[signatureIndex];
                    if (!activeSignature) return;
                    let activeParam = (_el1 = el) === null || _el1 === void 0 ? void 0 : _el1.activeParameter;
                    let contents = activeSignature.label;
                    if (activeParam != undefined && activeSignature.parameters && activeSignature.parameters[activeParam]) {
                        let param = activeSignature.parameters[activeParam].label;
                        if (typeof param == "string") {
                            contents = contents.replace(param, `**${param}**`);
                        }
                    }
                    if (activeSignature.documentation) {
                        if (MarkupContent.is(activeSignature.documentation)) {
                            return contents + "\n\n" + fromMarkupContent(activeSignature.documentation);
                        } else {
                            contents += "\n\n" + activeSignature.documentation;
                            return contents;
                        }
                    } else {
                        return contents;
                    }
                }).filter(notEmpty);
                if (content.length === 0) return;
                return {
                    content: {
                        type: "markdown",
                        text: content.join("\n\n")
                    }
                };
            }
            function fromMarkupContent(content) {
                if (!content) return;
                if (typeof content === "string") {
                    return content;
                } else {
                    return content.value;
                }
            }
            function fromAceDelta(delta, eol) {
                const text = delta.lines.length > 1 ? delta.lines.join(eol) : delta.lines[0];
                return {
                    range: delta.action === "insert" ? rangeFromPositions(fromPoint(delta.start), fromPoint(delta.start)) : rangeFromPositions(fromPoint(delta.start), fromPoint(delta.end)),
                    text: delta.action === "insert" ? text : ""
                };
            }
            function filterDiagnostics(diagnostics, filterErrors) {
                return common_converters_CommonConverter.excludeByErrorMessage(diagnostics, filterErrors.errorMessagesToIgnore).map((el)=>{
                    if ((0, utils /* checkValueAgainstRegexpArray */ .Tk)(el.message, filterErrors.errorMessagesToTreatAsWarning)) {
                        el.severity = browser_main.DiagnosticSeverity.Warning;
                    } else if ((0, utils /* checkValueAgainstRegexpArray */ .Tk)(el.message, filterErrors.errorMessagesToTreatAsInfo)) {
                        el.severity = browser_main.DiagnosticSeverity.Information;
                    }
                    return el;
                });
            }
            function fromDocumentHighlights(documentHighlights) {
                return documentHighlights.map(function(el) {
                    let className = el.kind == 2 ? "language_highlight_read" : el.kind == 3 ? "language_highlight_write" : "language_highlight_text";
                    return toMarkerGroupItem(CommonConverter.toRange(toRange(el.range)), className);
                });
            }
            function toMarkerGroupItem(range, className, tooltipText) {
                let markerGroupItem = {
                    range: range,
                    className: className
                };
                if (tooltipText) {
                    markerGroupItem["tooltipText"] = tooltipText;
                }
                return markerGroupItem;
            }
            ; // CONCATENATED MODULE: ./src/services/json/json-service.ts
            function json_service_define_property(obj, key, value) {
                if (key in obj) {
                    Object.defineProperty(obj, key, {
                        value: value,
                        enumerable: true,
                        configurable: true,
                        writable: true
                    });
                } else {
                    obj[key] = value;
                }
                return obj;
            }
            class JsonService extends base_service.BaseService {
                $getJsonSchemaUri(documentUri) {
                    return this.getOption(documentUri, "schemaUri");
                }
                addDocument(document1) {
                    super.addDocument(document1);
                    this.$configureService(document1.uri);
                }
                getSchemaOption(documentUri) {
                    return this.getOption(documentUri !== null && documentUri !== void 0 ? documentUri : "", "schemas");
                }
                $configureService(documentUri) {
                    var _schemas;
                    let schemas = this.getSchemaOption(documentUri);
                    let sessionIDs = documentUri ? [] : Object.keys(this.documents);
                    (_schemas = schemas) === null || _schemas === void 0 ? void 0 : _schemas.forEach((el)=>{
                        if (documentUri) {
                            if (this.$getJsonSchemaUri(documentUri) == el.uri) {
                                var _el;
                                var _fileMatch;
                                (_fileMatch = (_el = el).fileMatch) !== null && _fileMatch !== void 0 ? _fileMatch : _el.fileMatch = [];
                                el.fileMatch.push(documentUri);
                            }
                        } else {
                            el.fileMatch = sessionIDs.filter((documentUri)=>this.$getJsonSchemaUri(documentUri) == el.uri);
                        }
                        var _el_schema;
                        let schema = (_el_schema = el.schema) !== null && _el_schema !== void 0 ? _el_schema : this.schemas[el.uri];
                        if (schema) this.schemas[el.uri] = schema;
                        this.$service.resetSchema(el.uri);
                        el.schema = undefined;
                    });
                    this.$configureJsonService(schemas);
                }
                $configureJsonService(schemas) {
                    this.$service.configure({
                        schemas: schemas,
                        allowComments: this.mode === "json5",
                        validate: true
                    });
                }
                removeDocument(document1) {
                    var _schemas;
                    super.removeDocument(document1);
                    let schemas = this.getOption(document1.uri, "schemas");
                    (_schemas = schemas) === null || _schemas === void 0 ? void 0 : _schemas.forEach((el)=>{
                        if (el.uri === this.$getJsonSchemaUri(document1.uri)) {
                            var _el_fileMatch;
                            el.fileMatch = (_el_fileMatch = el.fileMatch) === null || _el_fileMatch === void 0 ? void 0 : _el_fileMatch.filter((pattern)=>pattern != document1.uri);
                        }
                    });
                    this.$configureJsonService(schemas);
                }
                setOptions(documentUri, options, merge = false) {
                    super.setOptions(documentUri, options, merge);
                    this.$configureService(documentUri);
                }
                setGlobalOptions(options) {
                    super.setGlobalOptions(options);
                    this.$configureService();
                }
                format(document1, range, options) {
                    let fullDocument = this.getDocument(document1.uri);
                    if (!fullDocument) return Promise.resolve([]);
                    return Promise.resolve(this.$service.format(fullDocument, range, options));
                }
                async doHover(document1, position) {
                    let fullDocument = this.getDocument(document1.uri);
                    if (!fullDocument) return null;
                    let jsonDocument = this.$service.parseJSONDocument(fullDocument);
                    return this.$service.doHover(fullDocument, position, jsonDocument);
                }
                async doValidation(document1) {
                    let fullDocument = this.getDocument(document1.uri);
                    if (!fullDocument) return [];
                    let jsonDocument = this.$service.parseJSONDocument(fullDocument);
                    let diagnostics = await this.$service.doValidation(fullDocument, jsonDocument, {
                        trailingCommas: this.mode === "json5" ? "ignore" : "error"
                    });
                    return filterDiagnostics(diagnostics, this.optionsToFilterDiagnostics);
                }
                async doComplete(document1, position) {
                    let fullDocument = this.getDocument(document1.uri);
                    if (!fullDocument) return null;
                    let jsonDocument = this.$service.parseJSONDocument(fullDocument);
                    const completions = await this.$service.doComplete(fullDocument, position, jsonDocument);
                    return completions;
                }
                async doResolve(item) {
                    return this.$service.doResolve(item);
                }
                constructor(mode){
                    super(mode);
                    json_service_define_property(this, "$service", void 0);
                    json_service_define_property(this, "schemas", {});
                    json_service_define_property(this, "serviceCapabilities", {
                        completionProvider: {
                            triggerCharacters: [
                                '"',
                                ':'
                            ]
                        },
                        diagnosticProvider: {
                            interFileDependencies: true,
                            workspaceDiagnostics: true
                        },
                        documentRangeFormattingProvider: true,
                        documentFormattingProvider: true,
                        hoverProvider: true
                    });
                    this.$service = getLanguageService({
                        schemaRequestService: (uri)=>{
                            uri = uri.replace("file:///", "");
                            let jsonSchema = this.schemas[uri];
                            if (jsonSchema) return Promise.resolve(jsonSchema);
                            if (typeof fetch !== 'undefined' && /^https?:\/\//.test(uri)) {
                                return fetch(uri).then((response)=>response.text());
                            }
                            return Promise.reject(`Unable to load schema at ${uri}`);
                        }
                    });
                }
            }
        })();
        /******/ return __nested_webpack_exports__;
    /******/ })();
});


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFjLENBQUMsS0FBSyxHQUFHLEdBQUcsR0FBRztnQkFDNUNBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUc7Z0JBQzVDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHO2dCQUM1Q0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsS0FBSyxHQUFHLEdBQUcsR0FBRztnQkFDNUNBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUc7Z0JBQzVDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHO2dCQUM1Q0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsS0FBSyxHQUFHLEdBQUcsR0FBRztnQkFDNUNBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLEtBQUssR0FBRyxHQUFHLEdBQUc7Z0JBQzVDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxLQUFLLEdBQUcsR0FBRyxHQUFHO2dCQUM1Q0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRztnQkFDM0NBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUc7Z0JBQzNDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHO2dCQUMzQ0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLElBQUksR0FBRztnQkFDNUNBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxJQUFJLEdBQUc7Z0JBQzVDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsSUFBSSxHQUFHO2dCQUM1Q0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLElBQUksR0FBRztnQkFDNUNBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxJQUFJLEdBQUc7Z0JBQzVDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsSUFBSSxHQUFHO2dCQUM1Q0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLElBQUksR0FBRztnQkFDNUNBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxJQUFJLEdBQUc7Z0JBQzVDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsSUFBSSxHQUFHO2dCQUM1Q0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLElBQUksR0FBRztnQkFDNUNBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxJQUFJLEdBQUc7Z0JBQzVDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsSUFBSSxHQUFHO2dCQUM1Q0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLElBQUksR0FBRztnQkFDNUNBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxJQUFJLEdBQUc7Z0JBQzVDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsSUFBSSxHQUFHO2dCQUM1Q0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLElBQUksR0FBRztnQkFDNUNBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxJQUFJLEdBQUc7Z0JBQzVDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsSUFBSSxHQUFHO2dCQUM1Q0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLElBQUksR0FBRztnQkFDNUNBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxJQUFJLEdBQUc7Z0JBQzVDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsSUFBSSxHQUFHO2dCQUM1Q0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLElBQUksR0FBRztnQkFDNUNBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxJQUFJLEdBQUc7Z0JBQzVDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHO2dCQUMzQ0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRztnQkFDM0NBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUc7Z0JBQzNDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHO2dCQUMzQ0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRztnQkFDM0NBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUc7Z0JBQzNDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHO2dCQUMzQ0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRztnQkFDM0NBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUc7Z0JBQzNDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHO2dCQUMzQ0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRztnQkFDM0NBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUc7Z0JBQzNDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHO2dCQUMzQ0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRztnQkFDM0NBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUc7Z0JBQzNDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHO2dCQUMzQ0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRztnQkFDM0NBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUc7Z0JBQzNDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHO2dCQUMzQ0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRztnQkFDM0NBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUc7Z0JBQzNDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHO2dCQUMzQ0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRztnQkFDM0NBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLElBQUksR0FBRyxHQUFHLEdBQUc7Z0JBQzNDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHO2dCQUMzQ0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRztnQkFDM0NBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLFdBQVcsR0FBRyxHQUFHLEdBQUc7Z0JBQ2xEQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxZQUFZLEdBQUcsR0FBRyxHQUFHO2dCQUNuREEsY0FBYyxDQUFDQSxjQUFjLENBQUMsYUFBYSxHQUFHLElBQUksR0FBRztnQkFDckRBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLGVBQWUsR0FBRyxHQUFHLEdBQUc7Z0JBQ3REQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxRQUFRLEdBQUcsR0FBRyxHQUFHO2dCQUMvQ0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsUUFBUSxHQUFHLEdBQUcsR0FBRztnQkFDL0NBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLE1BQU0sR0FBRyxHQUFHLEdBQUc7Z0JBQzdDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxjQUFjLEdBQUcsR0FBRyxHQUFHO2dCQUNyREEsY0FBYyxDQUFDQSxjQUFjLENBQUMsUUFBUSxHQUFHLEdBQUcsR0FBRztnQkFDL0NBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLFlBQVksR0FBRyxJQUFJLEdBQUc7Z0JBQ3BEQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxjQUFjLEdBQUcsR0FBRyxHQUFHO2dCQUNyREEsY0FBYyxDQUFDQSxjQUFjLENBQUMsT0FBTyxHQUFHLEdBQUcsR0FBRztnQkFDOUNBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLFFBQVEsR0FBRyxHQUFH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QkFDL0JDLHNCQUFzQixDQUFDMWlFOzRCQUNuQkEsTUFBTUEsSUFBSXhjLE9BQU8sQ0FBQyxZQUFZOzRCQUM5QixJQUFJd2xGLGFBQWEsSUFBSSxDQUFDN3NCLE9BQU8sQ0FBQ244QyxJQUFJOzRCQUNsQyxJQUFJZ3BFLFlBQVksT0FBTzF3RixRQUFRQyxPQUFPLENBQUN5d0Y7NEJBQ3ZDLElBQUksT0FBTzN2QixVQUFVLGVBQWUsZUFBZS9oRSxJQUFJLENBQUMwb0IsTUFBTTtnQ0FDMUQsT0FBT3E1QyxNQUFNcjVDLEtBQUs5bkIsSUFBSSxDQUFDLENBQUMwbUMsV0FBV0EsU0FBU3plLElBQUk7NEJBQ3BEOzRCQUNBLE9BQU83bkIsUUFBUW8zQixNQUFNLENBQUMsQ0FBQyx5QkFBeUIsRUFBRTFQLElBQUksQ0FBQzt3QkFDM0Q7b0JBQ0o7Z0JBQ0o7WUFDSjtRQUVBO1FBRUEsTUFBTSxHQUFJLE9BQU9YLDBCQUFtQkE7SUFDcEMsTUFBTSxHQUFHO0FBRVQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hY2UtbGludGVycy1yb290Ly4vcGFja2FnZXMvYWNlLWxpbnRlcnMvYnVpbGQvanNvbi1zZXJ2aWNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSB7XG5cdFx0dmFyIGEgPSBmYWN0b3J5KCk7XG5cdFx0Zm9yKHZhciBpIGluIGEpICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgPyBleHBvcnRzIDogcm9vdClbaV0gPSBhW2ldO1xuXHR9XG59KSh0aGlzLCAoKSA9PiB7XG5yZXR1cm4gLyoqKioqKi8gKCgpID0+IHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIDYwOTM6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogcHJvdmlkZWQgZGVwZW5kZW5jeSAqLyB2YXIgcHJvY2VzcyA9IF9fd2VicGFja19yZXF1aXJlX18oOTkwNyk7XG4vKiBwcm92aWRlZCBkZXBlbmRlbmN5ICovIHZhciBjb25zb2xlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MzY0KTtcbi8vIEN1cnJlbnRseSBpbiBzeW5jIHdpdGggTm9kZS5qcyBsaWIvYXNzZXJ0LmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvY29tbWl0LzJhNTFhZTQyNGE1MTNlYzlhNmFhMzQ2NmJhYTBjYzFkNTVkZDRmM2Jcbi8vIE9yaWdpbmFsbHkgZnJvbSBuYXJ3aGFsLmpzIChodHRwOi8vbmFyd2hhbGpzLm9yZylcbi8vIENvcHlyaWdodCAoYykgMjAwOSBUaG9tYXMgUm9iaW5zb24gPDI4MG5vcnRoLmNvbT5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAnU29mdHdhcmUnKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4vLyBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzNDIpLFxuICAgIF9yZXF1aXJlJGNvZGVzID0gX3JlcXVpcmUuY29kZXMsXG4gICAgRVJSX0FNQklHVU9VU19BUkdVTUVOVCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9BTUJJR1VPVVNfQVJHVU1FTlQsXG4gICAgRVJSX0lOVkFMSURfQVJHX1RZUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRSxcbiAgICBFUlJfSU5WQUxJRF9BUkdfVkFMVUUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVkFMVUUsXG4gICAgRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFLFxuICAgIEVSUl9NSVNTSU5HX0FSR1MgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUlTU0lOR19BUkdTO1xuXG52YXIgQXNzZXJ0aW9uRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk4MDEpO1xuXG52YXIgX3JlcXVpcmUyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2ODI3KSxcbiAgICBpbnNwZWN0ID0gX3JlcXVpcmUyLmluc3BlY3Q7XG5cbnZhciBfcmVxdWlyZSR0eXBlcyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDY4MjcpLnR5cGVzKSxcbiAgICBpc1Byb21pc2UgPSBfcmVxdWlyZSR0eXBlcy5pc1Byb21pc2UsXG4gICAgaXNSZWdFeHAgPSBfcmVxdWlyZSR0eXBlcy5pc1JlZ0V4cDtcblxudmFyIG9iamVjdEFzc2lnbiA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduIDogKF9fd2VicGFja19yZXF1aXJlX18oMzA0NikuYXNzaWduKTtcbnZhciBvYmplY3RJcyA9IE9iamVjdC5pcyA/IE9iamVjdC5pcyA6IF9fd2VicGFja19yZXF1aXJlX18oNTk2OCk7XG52YXIgZXJyb3JDYWNoZSA9IG5ldyBNYXAoKTtcbnZhciBpc0RlZXBFcXVhbDtcbnZhciBpc0RlZXBTdHJpY3RFcXVhbDtcbnZhciBwYXJzZUV4cHJlc3Npb25BdDtcbnZhciBmaW5kTm9kZUFyb3VuZDtcbnZhciBkZWNvZGVyO1xuXG5mdW5jdGlvbiBsYXp5TG9hZENvbXBhcmlzb24oKSB7XG4gIHZhciBjb21wYXJpc29uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NjU2KTtcblxuICBpc0RlZXBFcXVhbCA9IGNvbXBhcmlzb24uaXNEZWVwRXF1YWw7XG4gIGlzRGVlcFN0cmljdEVxdWFsID0gY29tcGFyaXNvbi5pc0RlZXBTdHJpY3RFcXVhbDtcbn0gLy8gRXNjYXBlIGNvbnRyb2wgY2hhcmFjdGVycyBidXQgbm90IFxcbiBhbmQgXFx0IHRvIGtlZXAgdGhlIGxpbmUgYnJlYWtzIGFuZFxuLy8gaW5kZW50YXRpb24gaW50YWN0LlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcblxuXG52YXIgZXNjYXBlU2VxdWVuY2VzUmVnRXhwID0gL1tcXHgwMC1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZl0vZztcbnZhciBtZXRhID0gKC8qIHVudXNlZCBwdXJlIGV4cHJlc3Npb24gb3Igc3VwZXIgKi8gbnVsbCAmJiAoW1wiXFxcXHUwMDAwXCIsIFwiXFxcXHUwMDAxXCIsIFwiXFxcXHUwMDAyXCIsIFwiXFxcXHUwMDAzXCIsIFwiXFxcXHUwMDA0XCIsIFwiXFxcXHUwMDA1XCIsIFwiXFxcXHUwMDA2XCIsIFwiXFxcXHUwMDA3XCIsICdcXFxcYicsICcnLCAnJywgXCJcXFxcdTAwMGJcIiwgJ1xcXFxmJywgJycsIFwiXFxcXHUwMDBlXCIsIFwiXFxcXHUwMDBmXCIsIFwiXFxcXHUwMDEwXCIsIFwiXFxcXHUwMDExXCIsIFwiXFxcXHUwMDEyXCIsIFwiXFxcXHUwMDEzXCIsIFwiXFxcXHUwMDE0XCIsIFwiXFxcXHUwMDE1XCIsIFwiXFxcXHUwMDE2XCIsIFwiXFxcXHUwMDE3XCIsIFwiXFxcXHUwMDE4XCIsIFwiXFxcXHUwMDE5XCIsIFwiXFxcXHUwMDFhXCIsIFwiXFxcXHUwMDFiXCIsIFwiXFxcXHUwMDFjXCIsIFwiXFxcXHUwMDFkXCIsIFwiXFxcXHUwMDFlXCIsIFwiXFxcXHUwMDFmXCJdKSk7XG5cbnZhciBlc2NhcGVGbiA9IGZ1bmN0aW9uIGVzY2FwZUZuKHN0cikge1xuICByZXR1cm4gbWV0YVtzdHIuY2hhckNvZGVBdCgwKV07XG59O1xuXG52YXIgd2FybmVkID0gZmFsc2U7IC8vIFRoZSBhc3NlcnQgbW9kdWxlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0aGF0IHRocm93XG4vLyBBc3NlcnRpb25FcnJvcidzIHdoZW4gcGFydGljdWxhciBjb25kaXRpb25zIGFyZSBub3QgbWV0LiBUaGVcbi8vIGFzc2VydCBtb2R1bGUgbXVzdCBjb25mb3JtIHRvIHRoZSBmb2xsb3dpbmcgaW50ZXJmYWNlLlxuXG52YXIgYXNzZXJ0ID0gbW9kdWxlLmV4cG9ydHMgPSBvaztcbnZhciBOT19FWENFUFRJT05fU0VOVElORUwgPSB7fTsgLy8gQWxsIG9mIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIG11c3QgdGhyb3cgYW4gQXNzZXJ0aW9uRXJyb3Jcbi8vIHdoZW4gYSBjb3JyZXNwb25kaW5nIGNvbmRpdGlvbiBpcyBub3QgbWV0LCB3aXRoIGEgbWVzc2FnZSB0aGF0XG4vLyBtYXkgYmUgdW5kZWZpbmVkIGlmIG5vdCBwcm92aWRlZC4gQWxsIGFzc2VydGlvbiBtZXRob2RzIHByb3ZpZGVcbi8vIGJvdGggdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzIHRvIHRoZSBhc3NlcnRpb24gZXJyb3IgZm9yXG4vLyBkaXNwbGF5IHB1cnBvc2VzLlxuXG5mdW5jdGlvbiBpbm5lckZhaWwob2JqKSB7XG4gIGlmIChvYmoubWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB0aHJvdyBvYmoubWVzc2FnZTtcbiAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKG9iaik7XG59XG5cbmZ1bmN0aW9uIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgb3BlcmF0b3IsIHN0YWNrU3RhcnRGbikge1xuICB2YXIgYXJnc0xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbnRlcm5hbE1lc3NhZ2U7XG5cbiAgaWYgKGFyZ3NMZW4gPT09IDApIHtcbiAgICBpbnRlcm5hbE1lc3NhZ2UgPSAnRmFpbGVkJztcbiAgfSBlbHNlIGlmIChhcmdzTGVuID09PSAxKSB7XG4gICAgbWVzc2FnZSA9IGFjdHVhbDtcbiAgICBhY3R1YWwgPSB1bmRlZmluZWQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHdhcm5lZCA9PT0gZmFsc2UpIHtcbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICB2YXIgd2FybiA9IHByb2Nlc3MuZW1pdFdhcm5pbmcgPyBwcm9jZXNzLmVtaXRXYXJuaW5nIDogY29uc29sZS53YXJuLmJpbmQoY29uc29sZSk7XG4gICAgICB3YXJuKCdhc3NlcnQuZmFpbCgpIHdpdGggbW9yZSB0aGFuIG9uZSBhcmd1bWVudCBpcyBkZXByZWNhdGVkLiAnICsgJ1BsZWFzZSB1c2UgYXNzZXJ0LnN0cmljdEVxdWFsKCkgaW5zdGVhZCBvciBvbmx5IHBhc3MgYSBtZXNzYWdlLicsICdEZXByZWNhdGlvbldhcm5pbmcnLCAnREVQMDA5NCcpO1xuICAgIH1cblxuICAgIGlmIChhcmdzTGVuID09PSAyKSBvcGVyYXRvciA9ICchPSc7XG4gIH1cblxuICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB0aHJvdyBtZXNzYWdlO1xuICB2YXIgZXJyQXJncyA9IHtcbiAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgb3BlcmF0b3I6IG9wZXJhdG9yID09PSB1bmRlZmluZWQgPyAnZmFpbCcgOiBvcGVyYXRvcixcbiAgICBzdGFja1N0YXJ0Rm46IHN0YWNrU3RhcnRGbiB8fCBmYWlsXG4gIH07XG5cbiAgaWYgKG1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgIGVyckFyZ3MubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIH1cblxuICB2YXIgZXJyID0gbmV3IEFzc2VydGlvbkVycm9yKGVyckFyZ3MpO1xuXG4gIGlmIChpbnRlcm5hbE1lc3NhZ2UpIHtcbiAgICBlcnIubWVzc2FnZSA9IGludGVybmFsTWVzc2FnZTtcbiAgICBlcnIuZ2VuZXJhdGVkTWVzc2FnZSA9IHRydWU7XG4gIH1cblxuICB0aHJvdyBlcnI7XG59XG5cbmFzc2VydC5mYWlsID0gZmFpbDsgLy8gVGhlIEFzc2VydGlvbkVycm9yIGlzIGRlZmluZWQgaW4gaW50ZXJuYWwvZXJyb3IuXG5cbmFzc2VydC5Bc3NlcnRpb25FcnJvciA9IEFzc2VydGlvbkVycm9yO1xuXG5mdW5jdGlvbiBpbm5lck9rKGZuLCBhcmdMZW4sIHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICB2YXIgZ2VuZXJhdGVkTWVzc2FnZSA9IGZhbHNlO1xuXG4gICAgaWYgKGFyZ0xlbiA9PT0gMCkge1xuICAgICAgZ2VuZXJhdGVkTWVzc2FnZSA9IHRydWU7XG4gICAgICBtZXNzYWdlID0gJ05vIHZhbHVlIGFyZ3VtZW50IHBhc3NlZCB0byBgYXNzZXJ0Lm9rKClgJztcbiAgICB9IGVsc2UgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgdGhyb3cgbWVzc2FnZTtcbiAgICB9XG5cbiAgICB2YXIgZXJyID0gbmV3IEFzc2VydGlvbkVycm9yKHtcbiAgICAgIGFjdHVhbDogdmFsdWUsXG4gICAgICBleHBlY3RlZDogdHJ1ZSxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJz09JyxcbiAgICAgIHN0YWNrU3RhcnRGbjogZm5cbiAgICB9KTtcbiAgICBlcnIuZ2VuZXJhdGVkTWVzc2FnZSA9IGdlbmVyYXRlZE1lc3NhZ2U7XG4gICAgdGhyb3cgZXJyO1xuICB9XG59IC8vIFB1cmUgYXNzZXJ0aW9uIHRlc3RzIHdoZXRoZXIgYSB2YWx1ZSBpcyB0cnV0aHksIGFzIGRldGVybWluZWRcbi8vIGJ5ICEhdmFsdWUuXG5cblxuZnVuY3Rpb24gb2soKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpbm5lck9rLmFwcGx5KHZvaWQgMCwgW29rLCBhcmdzLmxlbmd0aF0uY29uY2F0KGFyZ3MpKTtcbn1cblxuYXNzZXJ0Lm9rID0gb2s7IC8vIFRoZSBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc2hhbGxvdywgY29lcmNpdmUgZXF1YWxpdHkgd2l0aCA9PS5cblxuLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzICovXG5cbmFzc2VydC5lcXVhbCA9IGZ1bmN0aW9uIGVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblxuXG4gIGlmIChhY3R1YWwgIT0gZXhwZWN0ZWQpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICc9PScsXG4gICAgICBzdGFja1N0YXJ0Rm46IGVxdWFsXG4gICAgfSk7XG4gIH1cbn07IC8vIFRoZSBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciB3aGV0aGVyIHR3byBvYmplY3RzIGFyZSBub3Rcbi8vIGVxdWFsIHdpdGggIT0uXG5cblxuYXNzZXJ0Lm5vdEVxdWFsID0gZnVuY3Rpb24gbm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXG5cbiAgaWYgKGFjdHVhbCA9PSBleHBlY3RlZCkge1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJyE9JyxcbiAgICAgIHN0YWNrU3RhcnRGbjogbm90RXF1YWxcbiAgICB9KTtcbiAgfVxufTsgLy8gVGhlIGVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBhIGRlZXAgZXF1YWxpdHkgcmVsYXRpb24uXG5cblxuYXNzZXJ0LmRlZXBFcXVhbCA9IGZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGlmIChpc0RlZXBFcXVhbCA9PT0gdW5kZWZpbmVkKSBsYXp5TG9hZENvbXBhcmlzb24oKTtcblxuICBpZiAoIWlzRGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnZGVlcEVxdWFsJyxcbiAgICAgIHN0YWNrU3RhcnRGbjogZGVlcEVxdWFsXG4gICAgfSk7XG4gIH1cbn07IC8vIFRoZSBub24tZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGZvciBhbnkgZGVlcCBpbmVxdWFsaXR5LlxuXG5cbmFzc2VydC5ub3REZWVwRXF1YWwgPSBmdW5jdGlvbiBub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnYWN0dWFsJywgJ2V4cGVjdGVkJyk7XG4gIH1cblxuICBpZiAoaXNEZWVwRXF1YWwgPT09IHVuZGVmaW5lZCkgbGF6eUxvYWRDb21wYXJpc29uKCk7XG5cbiAgaWYgKGlzRGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnbm90RGVlcEVxdWFsJyxcbiAgICAgIHN0YWNrU3RhcnRGbjogbm90RGVlcEVxdWFsXG4gICAgfSk7XG4gIH1cbn07XG4vKiBlc2xpbnQtZW5hYmxlICovXG5cblxuYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIGRlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGlmIChpc0RlZXBFcXVhbCA9PT0gdW5kZWZpbmVkKSBsYXp5TG9hZENvbXBhcmlzb24oKTtcblxuICBpZiAoIWlzRGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnZGVlcFN0cmljdEVxdWFsJyxcbiAgICAgIHN0YWNrU3RhcnRGbjogZGVlcFN0cmljdEVxdWFsXG4gICAgfSk7XG4gIH1cbn07XG5cbmFzc2VydC5ub3REZWVwU3RyaWN0RXF1YWwgPSBub3REZWVwU3RyaWN0RXF1YWw7XG5cbmZ1bmN0aW9uIG5vdERlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGlmIChpc0RlZXBFcXVhbCA9PT0gdW5kZWZpbmVkKSBsYXp5TG9hZENvbXBhcmlzb24oKTtcblxuICBpZiAoaXNEZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICdub3REZWVwU3RyaWN0RXF1YWwnLFxuICAgICAgc3RhY2tTdGFydEZuOiBub3REZWVwU3RyaWN0RXF1YWxcbiAgICB9KTtcbiAgfVxufVxuXG5hc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBzdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdhY3R1YWwnLCAnZXhwZWN0ZWQnKTtcbiAgfVxuXG4gIGlmICghb2JqZWN0SXMoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICdzdHJpY3RFcXVhbCcsXG4gICAgICBzdGFja1N0YXJ0Rm46IHN0cmljdEVxdWFsXG4gICAgfSk7XG4gIH1cbn07XG5cbmFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIG5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ2FjdHVhbCcsICdleHBlY3RlZCcpO1xuICB9XG5cbiAgaWYgKG9iamVjdElzKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgaW5uZXJGYWlsKHtcbiAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnbm90U3RyaWN0RXF1YWwnLFxuICAgICAgc3RhY2tTdGFydEZuOiBub3RTdHJpY3RFcXVhbFxuICAgIH0pO1xuICB9XG59O1xuXG52YXIgQ29tcGFyaXNvbiA9IGZ1bmN0aW9uIENvbXBhcmlzb24ob2JqLCBrZXlzLCBhY3R1YWwpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29tcGFyaXNvbik7XG5cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgaWYgKGFjdHVhbCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBhY3R1YWxba2V5XSA9PT0gJ3N0cmluZycgJiYgaXNSZWdFeHAob2JqW2tleV0pICYmIG9ialtrZXldLnRlc3QoYWN0dWFsW2tleV0pKSB7XG4gICAgICAgIF90aGlzW2tleV0gPSBhY3R1YWxba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzW2tleV0gPSBvYmpba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gY29tcGFyZUV4Y2VwdGlvbktleShhY3R1YWwsIGV4cGVjdGVkLCBrZXksIG1lc3NhZ2UsIGtleXMsIGZuKSB7XG4gIGlmICghKGtleSBpbiBhY3R1YWwpIHx8ICFpc0RlZXBTdHJpY3RFcXVhbChhY3R1YWxba2V5XSwgZXhwZWN0ZWRba2V5XSkpIHtcbiAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgIC8vIENyZWF0ZSBwbGFjZWhvbGRlciBvYmplY3RzIHRvIGNyZWF0ZSBhIG5pY2Ugb3V0cHV0LlxuICAgICAgdmFyIGEgPSBuZXcgQ29tcGFyaXNvbihhY3R1YWwsIGtleXMpO1xuICAgICAgdmFyIGIgPSBuZXcgQ29tcGFyaXNvbihleHBlY3RlZCwga2V5cywgYWN0dWFsKTtcbiAgICAgIHZhciBlcnIgPSBuZXcgQXNzZXJ0aW9uRXJyb3Ioe1xuICAgICAgICBhY3R1YWw6IGEsXG4gICAgICAgIGV4cGVjdGVkOiBiLFxuICAgICAgICBvcGVyYXRvcjogJ2RlZXBTdHJpY3RFcXVhbCcsXG4gICAgICAgIHN0YWNrU3RhcnRGbjogZm5cbiAgICAgIH0pO1xuICAgICAgZXJyLmFjdHVhbCA9IGFjdHVhbDtcbiAgICAgIGVyci5leHBlY3RlZCA9IGV4cGVjdGVkO1xuICAgICAgZXJyLm9wZXJhdG9yID0gZm4ubmFtZTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG5cbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6IGZuLm5hbWUsXG4gICAgICBzdGFja1N0YXJ0Rm46IGZuXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCwgbXNnLCBmbikge1xuICBpZiAodHlwZW9mIGV4cGVjdGVkICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKGlzUmVnRXhwKGV4cGVjdGVkKSkgcmV0dXJuIGV4cGVjdGVkLnRlc3QoYWN0dWFsKTsgLy8gYXNzZXJ0LmRvZXNOb3RUaHJvdyBkb2VzIG5vdCBhY2NlcHQgb2JqZWN0cy5cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2V4cGVjdGVkJywgWydGdW5jdGlvbicsICdSZWdFeHAnXSwgZXhwZWN0ZWQpO1xuICAgIH0gLy8gSGFuZGxlIHByaW1pdGl2ZXMgcHJvcGVybHkuXG5cblxuICAgIGlmIChfdHlwZW9mKGFjdHVhbCkgIT09ICdvYmplY3QnIHx8IGFjdHVhbCA9PT0gbnVsbCkge1xuICAgICAgdmFyIGVyciA9IG5ldyBBc3NlcnRpb25FcnJvcih7XG4gICAgICAgIGFjdHVhbDogYWN0dWFsLFxuICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgICAgIG1lc3NhZ2U6IG1zZyxcbiAgICAgICAgb3BlcmF0b3I6ICdkZWVwU3RyaWN0RXF1YWwnLFxuICAgICAgICBzdGFja1N0YXJ0Rm46IGZuXG4gICAgICB9KTtcbiAgICAgIGVyci5vcGVyYXRvciA9IGZuLm5hbWU7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhleHBlY3RlZCk7IC8vIFNwZWNpYWwgaGFuZGxlIGVycm9ycyB0byBtYWtlIHN1cmUgdGhlIG5hbWUgYW5kIHRoZSBtZXNzYWdlIGFyZSBjb21wYXJlZFxuICAgIC8vIGFzIHdlbGwuXG5cbiAgICBpZiAoZXhwZWN0ZWQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAga2V5cy5wdXNoKCduYW1lJywgJ21lc3NhZ2UnKTtcbiAgICB9IGVsc2UgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1ZBTFVFKCdlcnJvcicsIGV4cGVjdGVkLCAnbWF5IG5vdCBiZSBhbiBlbXB0eSBvYmplY3QnKTtcbiAgICB9XG5cbiAgICBpZiAoaXNEZWVwRXF1YWwgPT09IHVuZGVmaW5lZCkgbGF6eUxvYWRDb21wYXJpc29uKCk7XG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmICh0eXBlb2YgYWN0dWFsW2tleV0gPT09ICdzdHJpbmcnICYmIGlzUmVnRXhwKGV4cGVjdGVkW2tleV0pICYmIGV4cGVjdGVkW2tleV0udGVzdChhY3R1YWxba2V5XSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb21wYXJlRXhjZXB0aW9uS2V5KGFjdHVhbCwgZXhwZWN0ZWQsIGtleSwgbXNnLCBrZXlzLCBmbik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gR3VhcmQgaW5zdGFuY2VvZiBhZ2FpbnN0IGFycm93IGZ1bmN0aW9ucyBhcyB0aGV5IGRvbid0IGhhdmUgYSBwcm90b3R5cGUuXG5cblxuICBpZiAoZXhwZWN0ZWQucHJvdG90eXBlICE9PSB1bmRlZmluZWQgJiYgYWN0dWFsIGluc3RhbmNlb2YgZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChFcnJvci5pc1Byb3RvdHlwZU9mKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBleHBlY3RlZC5jYWxsKHt9LCBhY3R1YWwpID09PSB0cnVlO1xufVxuXG5mdW5jdGlvbiBnZXRBY3R1YWwoZm4pIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnZm4nLCAnRnVuY3Rpb24nLCBmbik7XG4gIH1cblxuICB0cnkge1xuICAgIGZuKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZTtcbiAgfVxuXG4gIHJldHVybiBOT19FWENFUFRJT05fU0VOVElORUw7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSXNQcm9taXNlKG9iaikge1xuICAvLyBBY2NlcHQgbmF0aXZlIEVTNiBwcm9taXNlcyBhbmQgcHJvbWlzZXMgdGhhdCBhcmUgaW1wbGVtZW50ZWQgaW4gYSBzaW1pbGFyXG4gIC8vIHdheS4gRG8gbm90IGFjY2VwdCB0aGVuYWJsZXMgdGhhdCB1c2UgYSBmdW5jdGlvbiBhcyBgb2JqYCBhbmQgdGhhdCBoYXZlIG5vXG4gIC8vIGBjYXRjaGAgaGFuZGxlci5cbiAgLy8gVE9ETzogdGhlbmFibGVzIGFyZSBjaGVja2VkIHVwIHVudGlsIHRoZXkgaGF2ZSB0aGUgY29ycmVjdCBtZXRob2RzLFxuICAvLyBidXQgYWNjb3JkaW5nIHRvIGRvY3VtZW50YXRpb24sIHRoZSBgdGhlbmAgbWV0aG9kIHNob3VsZCByZWNlaXZlXG4gIC8vIHRoZSBgZnVsZmlsbGAgYW5kIGByZWplY3RgIGFyZ3VtZW50cyBhcyB3ZWxsIG9yIGl0IG1heSBiZSBuZXZlciByZXNvbHZlZC5cbiAgcmV0dXJuIGlzUHJvbWlzZShvYmopIHx8IG9iaiAhPT0gbnVsbCAmJiBfdHlwZW9mKG9iaikgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmoudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLmNhdGNoID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiB3YWl0Rm9yQWN0dWFsKHByb21pc2VGbikge1xuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdFByb21pc2U7XG5cbiAgICBpZiAodHlwZW9mIHByb21pc2VGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gUmV0dXJuIGEgcmVqZWN0ZWQgcHJvbWlzZSBpZiBgcHJvbWlzZUZuYCB0aHJvd3Mgc3luY2hyb25vdXNseS5cbiAgICAgIHJlc3VsdFByb21pc2UgPSBwcm9taXNlRm4oKTsgLy8gRmFpbCBpbiBjYXNlIG5vIHByb21pc2UgaXMgcmV0dXJuZWQuXG5cbiAgICAgIGlmICghY2hlY2tJc1Byb21pc2UocmVzdWx0UHJvbWlzZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSgnaW5zdGFuY2Ugb2YgUHJvbWlzZScsICdwcm9taXNlRm4nLCByZXN1bHRQcm9taXNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNoZWNrSXNQcm9taXNlKHByb21pc2VGbikpIHtcbiAgICAgIHJlc3VsdFByb21pc2UgPSBwcm9taXNlRm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgncHJvbWlzZUZuJywgWydGdW5jdGlvbicsICdQcm9taXNlJ10sIHByb21pc2VGbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlc3VsdFByb21pc2U7XG4gICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gTk9fRVhDRVBUSU9OX1NFTlRJTkVMO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gZTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGV4cGVjdHNFcnJvcihzdGFja1N0YXJ0Rm4sIGFjdHVhbCwgZXJyb3IsIG1lc3NhZ2UpIHtcbiAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgdGhyb3cgbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdlcnJvcicsIFsnT2JqZWN0JywgJ0Vycm9yJywgJ0Z1bmN0aW9uJywgJ1JlZ0V4cCddLCBlcnJvcik7XG4gICAgfVxuXG4gICAgaWYgKF90eXBlb2YoYWN0dWFsKSA9PT0gJ29iamVjdCcgJiYgYWN0dWFsICE9PSBudWxsKSB7XG4gICAgICBpZiAoYWN0dWFsLm1lc3NhZ2UgPT09IGVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFUlJfQU1CSUdVT1VTX0FSR1VNRU5UKCdlcnJvci9tZXNzYWdlJywgXCJUaGUgZXJyb3IgbWVzc2FnZSBcXFwiXCIuY29uY2F0KGFjdHVhbC5tZXNzYWdlLCBcIlxcXCIgaXMgaWRlbnRpY2FsIHRvIHRoZSBtZXNzYWdlLlwiKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhY3R1YWwgPT09IGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0FNQklHVU9VU19BUkdVTUVOVCgnZXJyb3IvbWVzc2FnZScsIFwiVGhlIGVycm9yIFxcXCJcIi5jb25jYXQoYWN0dWFsLCBcIlxcXCIgaXMgaWRlbnRpY2FsIHRvIHRoZSBtZXNzYWdlLlwiKSk7XG4gICAgfVxuXG4gICAgbWVzc2FnZSA9IGVycm9yO1xuICAgIGVycm9yID0gdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYgKGVycm9yICE9IG51bGwgJiYgX3R5cGVvZihlcnJvcikgIT09ICdvYmplY3QnICYmIHR5cGVvZiBlcnJvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnZXJyb3InLCBbJ09iamVjdCcsICdFcnJvcicsICdGdW5jdGlvbicsICdSZWdFeHAnXSwgZXJyb3IpO1xuICB9XG5cbiAgaWYgKGFjdHVhbCA9PT0gTk9fRVhDRVBUSU9OX1NFTlRJTkVMKSB7XG4gICAgdmFyIGRldGFpbHMgPSAnJztcblxuICAgIGlmIChlcnJvciAmJiBlcnJvci5uYW1lKSB7XG4gICAgICBkZXRhaWxzICs9IFwiIChcIi5jb25jYXQoZXJyb3IubmFtZSwgXCIpXCIpO1xuICAgIH1cblxuICAgIGRldGFpbHMgKz0gbWVzc2FnZSA/IFwiOiBcIi5jb25jYXQobWVzc2FnZSkgOiAnLic7XG4gICAgdmFyIGZuVHlwZSA9IHN0YWNrU3RhcnRGbi5uYW1lID09PSAncmVqZWN0cycgPyAncmVqZWN0aW9uJyA6ICdleGNlcHRpb24nO1xuICAgIGlubmVyRmFpbCh7XG4gICAgICBhY3R1YWw6IHVuZGVmaW5lZCxcbiAgICAgIGV4cGVjdGVkOiBlcnJvcixcbiAgICAgIG9wZXJhdG9yOiBzdGFja1N0YXJ0Rm4ubmFtZSxcbiAgICAgIG1lc3NhZ2U6IFwiTWlzc2luZyBleHBlY3RlZCBcIi5jb25jYXQoZm5UeXBlKS5jb25jYXQoZGV0YWlscyksXG4gICAgICBzdGFja1N0YXJ0Rm46IHN0YWNrU3RhcnRGblxuICAgIH0pO1xuICB9XG5cbiAgaWYgKGVycm9yICYmICFleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGVycm9yLCBtZXNzYWdlLCBzdGFja1N0YXJ0Rm4pKSB7XG4gICAgdGhyb3cgYWN0dWFsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV4cGVjdHNOb0Vycm9yKHN0YWNrU3RhcnRGbiwgYWN0dWFsLCBlcnJvciwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09PSBOT19FWENFUFRJT05fU0VOVElORUwpIHJldHVybjtcblxuICBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xuICAgIG1lc3NhZ2UgPSBlcnJvcjtcbiAgICBlcnJvciA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICghZXJyb3IgfHwgZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBlcnJvcikpIHtcbiAgICB2YXIgZGV0YWlscyA9IG1lc3NhZ2UgPyBcIjogXCIuY29uY2F0KG1lc3NhZ2UpIDogJy4nO1xuICAgIHZhciBmblR5cGUgPSBzdGFja1N0YXJ0Rm4ubmFtZSA9PT0gJ2RvZXNOb3RSZWplY3QnID8gJ3JlamVjdGlvbicgOiAnZXhjZXB0aW9uJztcbiAgICBpbm5lckZhaWwoe1xuICAgICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXJyb3IsXG4gICAgICBvcGVyYXRvcjogc3RhY2tTdGFydEZuLm5hbWUsXG4gICAgICBtZXNzYWdlOiBcIkdvdCB1bndhbnRlZCBcIi5jb25jYXQoZm5UeXBlKS5jb25jYXQoZGV0YWlscywgXCJcXG5cIikgKyBcIkFjdHVhbCBtZXNzYWdlOiBcXFwiXCIuY29uY2F0KGFjdHVhbCAmJiBhY3R1YWwubWVzc2FnZSwgXCJcXFwiXCIpLFxuICAgICAgc3RhY2tTdGFydEZuOiBzdGFja1N0YXJ0Rm5cbiAgICB9KTtcbiAgfVxuXG4gIHRocm93IGFjdHVhbDtcbn1cblxuYXNzZXJ0LnRocm93cyA9IGZ1bmN0aW9uIHRocm93cyhwcm9taXNlRm4pIHtcbiAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICB9XG5cbiAgZXhwZWN0c0Vycm9yLmFwcGx5KHZvaWQgMCwgW3Rocm93cywgZ2V0QWN0dWFsKHByb21pc2VGbildLmNvbmNhdChhcmdzKSk7XG59O1xuXG5hc3NlcnQucmVqZWN0cyA9IGZ1bmN0aW9uIHJlamVjdHMocHJvbWlzZUZuKSB7XG4gIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMyA+IDEgPyBfbGVuMyAtIDEgOiAwKSwgX2tleTMgPSAxOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgYXJnc1tfa2V5MyAtIDFdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgfVxuXG4gIHJldHVybiB3YWl0Rm9yQWN0dWFsKHByb21pc2VGbikudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgcmV0dXJuIGV4cGVjdHNFcnJvci5hcHBseSh2b2lkIDAsIFtyZWplY3RzLCByZXN1bHRdLmNvbmNhdChhcmdzKSk7XG4gIH0pO1xufTtcblxuYXNzZXJ0LmRvZXNOb3RUaHJvdyA9IGZ1bmN0aW9uIGRvZXNOb3RUaHJvdyhmbikge1xuICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQgPiAxID8gX2xlbjQgLSAxIDogMCksIF9rZXk0ID0gMTsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykge1xuICAgIGFyZ3NbX2tleTQgLSAxXSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gIH1cblxuICBleHBlY3RzTm9FcnJvci5hcHBseSh2b2lkIDAsIFtkb2VzTm90VGhyb3csIGdldEFjdHVhbChmbildLmNvbmNhdChhcmdzKSk7XG59O1xuXG5hc3NlcnQuZG9lc05vdFJlamVjdCA9IGZ1bmN0aW9uIGRvZXNOb3RSZWplY3QoZm4pIHtcbiAgZm9yICh2YXIgX2xlbjUgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW41ID4gMSA/IF9sZW41IC0gMSA6IDApLCBfa2V5NSA9IDE7IF9rZXk1IDwgX2xlbjU7IF9rZXk1KyspIHtcbiAgICBhcmdzW19rZXk1IC0gMV0gPSBhcmd1bWVudHNbX2tleTVdO1xuICB9XG5cbiAgcmV0dXJuIHdhaXRGb3JBY3R1YWwoZm4pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHJldHVybiBleHBlY3RzTm9FcnJvci5hcHBseSh2b2lkIDAsIFtkb2VzTm90UmVqZWN0LCByZXN1bHRdLmNvbmNhdChhcmdzKSk7XG4gIH0pO1xufTtcblxuYXNzZXJ0LmlmRXJyb3IgPSBmdW5jdGlvbiBpZkVycm9yKGVycikge1xuICBpZiAoZXJyICE9PSBudWxsICYmIGVyciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnaWZFcnJvciBnb3QgdW53YW50ZWQgZXhjZXB0aW9uOiAnO1xuXG4gICAgaWYgKF90eXBlb2YoZXJyKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGVyci5tZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKGVyci5tZXNzYWdlLmxlbmd0aCA9PT0gMCAmJiBlcnIuY29uc3RydWN0b3IpIHtcbiAgICAgICAgbWVzc2FnZSArPSBlcnIuY29uc3RydWN0b3IubmFtZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gZXJyLm1lc3NhZ2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2UgKz0gaW5zcGVjdChlcnIpO1xuICAgIH1cblxuICAgIHZhciBuZXdFcnIgPSBuZXcgQXNzZXJ0aW9uRXJyb3Ioe1xuICAgICAgYWN0dWFsOiBlcnIsXG4gICAgICBleHBlY3RlZDogbnVsbCxcbiAgICAgIG9wZXJhdG9yOiAnaWZFcnJvcicsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgc3RhY2tTdGFydEZuOiBpZkVycm9yXG4gICAgfSk7IC8vIE1ha2Ugc3VyZSB3ZSBhY3R1YWxseSBoYXZlIGEgc3RhY2sgdHJhY2UhXG5cbiAgICB2YXIgb3JpZ1N0YWNrID0gZXJyLnN0YWNrO1xuXG4gICAgaWYgKHR5cGVvZiBvcmlnU3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIHdpbGwgcmVtb3ZlIGFueSBkdXBsaWNhdGVkIGZyYW1lcyBmcm9tIHRoZSBlcnJvciBmcmFtZXMgdGFrZW5cbiAgICAgIC8vIGZyb20gd2l0aGluIGBpZkVycm9yYCBhbmQgYWRkIHRoZSBvcmlnaW5hbCBlcnJvciBmcmFtZXMgdG8gdGhlIG5ld2x5XG4gICAgICAvLyBjcmVhdGVkIG9uZXMuXG4gICAgICB2YXIgdG1wMiA9IG9yaWdTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB0bXAyLnNoaWZ0KCk7IC8vIEZpbHRlciBhbGwgZnJhbWVzIGV4aXN0aW5nIGluIGVyci5zdGFjay5cblxuICAgICAgdmFyIHRtcDEgPSBuZXdFcnIuc3RhY2suc3BsaXQoJ1xcbicpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRtcDIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gRmluZCB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiB0aGUgZnJhbWUuXG4gICAgICAgIHZhciBwb3MgPSB0bXAxLmluZGV4T2YodG1wMltpXSk7XG5cbiAgICAgICAgaWYgKHBvcyAhPT0gLTEpIHtcbiAgICAgICAgICAvLyBPbmx5IGtlZXAgbmV3IGZyYW1lcy5cbiAgICAgICAgICB0bXAxID0gdG1wMS5zbGljZSgwLCBwb3MpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5ld0Vyci5zdGFjayA9IFwiXCIuY29uY2F0KHRtcDEuam9pbignXFxuJyksIFwiXFxuXCIpLmNvbmNhdCh0bXAyLmpvaW4oJ1xcbicpKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXdFcnI7XG4gIH1cbn07IC8vIEV4cG9zZSBhIHN0cmljdCBvbmx5IHZhcmlhbnQgb2YgYXNzZXJ0XG5cblxuZnVuY3Rpb24gc3RyaWN0KCkge1xuICBmb3IgKHZhciBfbGVuNiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjYpLCBfa2V5NiA9IDA7IF9rZXk2IDwgX2xlbjY7IF9rZXk2KyspIHtcbiAgICBhcmdzW19rZXk2XSA9IGFyZ3VtZW50c1tfa2V5Nl07XG4gIH1cblxuICBpbm5lck9rLmFwcGx5KHZvaWQgMCwgW3N0cmljdCwgYXJncy5sZW5ndGhdLmNvbmNhdChhcmdzKSk7XG59XG5cbmFzc2VydC5zdHJpY3QgPSBvYmplY3RBc3NpZ24oc3RyaWN0LCBhc3NlcnQsIHtcbiAgZXF1YWw6IGFzc2VydC5zdHJpY3RFcXVhbCxcbiAgZGVlcEVxdWFsOiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsLFxuICBub3RFcXVhbDogYXNzZXJ0Lm5vdFN0cmljdEVxdWFsLFxuICBub3REZWVwRXF1YWw6IGFzc2VydC5ub3REZWVwU3RyaWN0RXF1YWxcbn0pO1xuYXNzZXJ0LnN0cmljdC5zdHJpY3QgPSBhc3NlcnQuc3RyaWN0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gOTgwMTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBwcm92aWRlZCBkZXBlbmRlbmN5ICovIHZhciBwcm9jZXNzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OTA3KTtcbi8vIEN1cnJlbnRseSBpbiBzeW5jIHdpdGggTm9kZS5qcyBsaWIvaW50ZXJuYWwvYXNzZXJ0L2Fzc2VydGlvbl9lcnJvci5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC8wODE3ODQwZjc3NTAzMjE2OWRkZDcwYzg1YWMwNTlmMThmZmNjODFjXG5cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTsgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nKSB7IG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBzeW0pLmVudW1lcmFibGU7IH0pKTsgfSBvd25LZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDsgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgaWYgKENsYXNzID09PSBudWxsIHx8ICFfaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzczsgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikgeyBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTsgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7IH0gZnVuY3Rpb24gV3JhcHBlcigpIHsgcmV0dXJuIF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTsgfSBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBXcmFwcGVyLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTsgfTsgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgaWYgKGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7IF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDsgfSBlbHNlIHsgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykgeyB2YXIgYSA9IFtudWxsXTsgYS5wdXNoLmFwcGx5KGEsIGFyZ3MpOyB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7IHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpOyBpZiAoQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTsgcmV0dXJuIGluc3RhbmNlOyB9OyB9IHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHsgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjgyNyksXG4gICAgaW5zcGVjdCA9IF9yZXF1aXJlLmluc3BlY3Q7XG5cbnZhciBfcmVxdWlyZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzNDIpLFxuICAgIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUyLmNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFOyAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvZW5kc1dpdGhcblxuXG5mdW5jdGlvbiBlbmRzV2l0aChzdHIsIHNlYXJjaCwgdGhpc19sZW4pIHtcbiAgaWYgKHRoaXNfbGVuID09PSB1bmRlZmluZWQgfHwgdGhpc19sZW4gPiBzdHIubGVuZ3RoKSB7XG4gICAgdGhpc19sZW4gPSBzdHIubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHN0ci5zdWJzdHJpbmcodGhpc19sZW4gLSBzZWFyY2gubGVuZ3RoLCB0aGlzX2xlbikgPT09IHNlYXJjaDtcbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3JlcGVhdFxuXG5cbmZ1bmN0aW9uIHJlcGVhdChzdHIsIGNvdW50KSB7XG4gIGNvdW50ID0gTWF0aC5mbG9vcihjb3VudCk7XG4gIGlmIChzdHIubGVuZ3RoID09IDAgfHwgY291bnQgPT0gMCkgcmV0dXJuICcnO1xuICB2YXIgbWF4Q291bnQgPSBzdHIubGVuZ3RoICogY291bnQ7XG4gIGNvdW50ID0gTWF0aC5mbG9vcihNYXRoLmxvZyhjb3VudCkgLyBNYXRoLmxvZygyKSk7XG5cbiAgd2hpbGUgKGNvdW50KSB7XG4gICAgc3RyICs9IHN0cjtcbiAgICBjb3VudC0tO1xuICB9XG5cbiAgc3RyICs9IHN0ci5zdWJzdHJpbmcoMCwgbWF4Q291bnQgLSBzdHIubGVuZ3RoKTtcbiAgcmV0dXJuIHN0cjtcbn1cblxudmFyIGJsdWUgPSAnJztcbnZhciBncmVlbiA9ICcnO1xudmFyIHJlZCA9ICcnO1xudmFyIHdoaXRlID0gJyc7XG52YXIga1JlYWRhYmxlT3BlcmF0b3IgPSB7XG4gIGRlZXBTdHJpY3RFcXVhbDogJ0V4cGVjdGVkIHZhbHVlcyB0byBiZSBzdHJpY3RseSBkZWVwLWVxdWFsOicsXG4gIHN0cmljdEVxdWFsOiAnRXhwZWN0ZWQgdmFsdWVzIHRvIGJlIHN0cmljdGx5IGVxdWFsOicsXG4gIHN0cmljdEVxdWFsT2JqZWN0OiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiB0byBiZSByZWZlcmVuY2UtZXF1YWwgdG8gXCJleHBlY3RlZFwiOicsXG4gIGRlZXBFcXVhbDogJ0V4cGVjdGVkIHZhbHVlcyB0byBiZSBsb29zZWx5IGRlZXAtZXF1YWw6JyxcbiAgZXF1YWw6ICdFeHBlY3RlZCB2YWx1ZXMgdG8gYmUgbG9vc2VseSBlcXVhbDonLFxuICBub3REZWVwU3RyaWN0RXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIG5vdCB0byBiZSBzdHJpY3RseSBkZWVwLWVxdWFsIHRvOicsXG4gIG5vdFN0cmljdEVxdWFsOiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiB0byBiZSBzdHJpY3RseSB1bmVxdWFsIHRvOicsXG4gIG5vdFN0cmljdEVxdWFsT2JqZWN0OiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiBub3QgdG8gYmUgcmVmZXJlbmNlLWVxdWFsIHRvIFwiZXhwZWN0ZWRcIjonLFxuICBub3REZWVwRXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIG5vdCB0byBiZSBsb29zZWx5IGRlZXAtZXF1YWwgdG86JyxcbiAgbm90RXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIHRvIGJlIGxvb3NlbHkgdW5lcXVhbCB0bzonLFxuICBub3RJZGVudGljYWw6ICdWYWx1ZXMgaWRlbnRpY2FsIGJ1dCBub3QgcmVmZXJlbmNlLWVxdWFsOidcbn07IC8vIENvbXBhcmluZyBzaG9ydCBwcmltaXRpdmVzIHNob3VsZCBqdXN0IHNob3cgPT09IC8gIT09IGluc3RlYWQgb2YgdXNpbmcgdGhlXG4vLyBkaWZmLlxuXG52YXIga01heFNob3J0TGVuZ3RoID0gMTA7XG5cbmZ1bmN0aW9uIGNvcHlFcnJvcihzb3VyY2UpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIgdGFyZ2V0ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc291cmNlKSk7XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsICdtZXNzYWdlJywge1xuICAgIHZhbHVlOiBzb3VyY2UubWVzc2FnZVxuICB9KTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gaW5zcGVjdFZhbHVlKHZhbCkge1xuICAvLyBUaGUgdXRpbC5pbnNwZWN0IGRlZmF1bHQgdmFsdWVzIGNvdWxkIGJlIGNoYW5nZWQuIFRoaXMgbWFrZXMgc3VyZSB0aGVcbiAgLy8gZXJyb3IgbWVzc2FnZXMgY29udGFpbiB0aGUgbmVjZXNzYXJ5IGluZm9ybWF0aW9uIG5ldmVydGhlbGVzcy5cbiAgcmV0dXJuIGluc3BlY3QodmFsLCB7XG4gICAgY29tcGFjdDogZmFsc2UsXG4gICAgY3VzdG9tSW5zcGVjdDogZmFsc2UsXG4gICAgZGVwdGg6IDEwMDAsXG4gICAgbWF4QXJyYXlMZW5ndGg6IEluZmluaXR5LFxuICAgIC8vIEFzc2VydCBjb21wYXJlcyBvbmx5IGVudW1lcmFibGUgcHJvcGVydGllcyAod2l0aCBhIGZldyBleGNlcHRpb25zKS5cbiAgICBzaG93SGlkZGVuOiBmYWxzZSxcbiAgICAvLyBIYXZpbmcgYSBsb25nIGxpbmUgYXMgZXJyb3IgaXMgYmV0dGVyIHRoYW4gd3JhcHBpbmcgdGhlIGxpbmUgZm9yXG4gICAgLy8gY29tcGFyaXNvbiBmb3Igbm93LlxuICAgIC8vIFRPRE8oQnJpZGdlQVIpOiBgYnJlYWtMZW5ndGhgIHNob3VsZCBiZSBsaW1pdGVkIGFzIHNvb24gYXMgc29vbiBhcyB3ZVxuICAgIC8vIGhhdmUgbWV0YSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgaW5zcGVjdGVkIHByb3BlcnRpZXMgKGkuZS4sIGtub3cgd2hlcmVcbiAgICAvLyBpbiB3aGF0IGxpbmUgdGhlIHByb3BlcnR5IHN0YXJ0cyBhbmQgZW5kcykuXG4gICAgYnJlYWtMZW5ndGg6IEluZmluaXR5LFxuICAgIC8vIEFzc2VydCBkb2VzIG5vdCBkZXRlY3QgcHJveGllcyBjdXJyZW50bHkuXG4gICAgc2hvd1Byb3h5OiBmYWxzZSxcbiAgICBzb3J0ZWQ6IHRydWUsXG4gICAgLy8gSW5zcGVjdCBnZXR0ZXJzIGFzIHdlIGFsc28gY2hlY2sgdGhlbSB3aGVuIGNvbXBhcmluZyBlbnRyaWVzLlxuICAgIGdldHRlcnM6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVyckRpZmYoYWN0dWFsLCBleHBlY3RlZCwgb3BlcmF0b3IpIHtcbiAgdmFyIG90aGVyID0gJyc7XG4gIHZhciByZXMgPSAnJztcbiAgdmFyIGxhc3RQb3MgPSAwO1xuICB2YXIgZW5kID0gJyc7XG4gIHZhciBza2lwcGVkID0gZmFsc2U7XG4gIHZhciBhY3R1YWxJbnNwZWN0ZWQgPSBpbnNwZWN0VmFsdWUoYWN0dWFsKTtcbiAgdmFyIGFjdHVhbExpbmVzID0gYWN0dWFsSW5zcGVjdGVkLnNwbGl0KCdcXG4nKTtcbiAgdmFyIGV4cGVjdGVkTGluZXMgPSBpbnNwZWN0VmFsdWUoZXhwZWN0ZWQpLnNwbGl0KCdcXG4nKTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgaW5kaWNhdG9yID0gJyc7IC8vIEluIGNhc2UgYm90aCB2YWx1ZXMgYXJlIG9iamVjdHMgZXhwbGljaXRseSBtYXJrIHRoZW0gYXMgbm90IHJlZmVyZW5jZSBlcXVhbFxuICAvLyBmb3IgdGhlIGBzdHJpY3RFcXVhbGAgb3BlcmF0b3IuXG5cbiAgaWYgKG9wZXJhdG9yID09PSAnc3RyaWN0RXF1YWwnICYmIF90eXBlb2YoYWN0dWFsKSA9PT0gJ29iamVjdCcgJiYgX3R5cGVvZihleHBlY3RlZCkgPT09ICdvYmplY3QnICYmIGFjdHVhbCAhPT0gbnVsbCAmJiBleHBlY3RlZCAhPT0gbnVsbCkge1xuICAgIG9wZXJhdG9yID0gJ3N0cmljdEVxdWFsT2JqZWN0JztcbiAgfSAvLyBJZiBcImFjdHVhbFwiIGFuZCBcImV4cGVjdGVkXCIgZml0IG9uIGEgc2luZ2xlIGxpbmUgYW5kIHRoZXkgYXJlIG5vdCBzdHJpY3RseVxuICAvLyBlcXVhbCwgY2hlY2sgZnVydGhlciBzcGVjaWFsIGhhbmRsaW5nLlxuXG5cbiAgaWYgKGFjdHVhbExpbmVzLmxlbmd0aCA9PT0gMSAmJiBleHBlY3RlZExpbmVzLmxlbmd0aCA9PT0gMSAmJiBhY3R1YWxMaW5lc1swXSAhPT0gZXhwZWN0ZWRMaW5lc1swXSkge1xuICAgIHZhciBpbnB1dExlbmd0aCA9IGFjdHVhbExpbmVzWzBdLmxlbmd0aCArIGV4cGVjdGVkTGluZXNbMF0ubGVuZ3RoOyAvLyBJZiB0aGUgY2hhcmFjdGVyIGxlbmd0aCBvZiBcImFjdHVhbFwiIGFuZCBcImV4cGVjdGVkXCIgdG9nZXRoZXIgaXMgbGVzcyB0aGFuXG4gICAgLy8ga01heFNob3J0TGVuZ3RoIGFuZCBpZiBuZWl0aGVyIGlzIGFuIG9iamVjdCBhbmQgYXQgbGVhc3Qgb25lIG9mIHRoZW0gaXNcbiAgICAvLyBub3QgYHplcm9gLCB1c2UgdGhlIHN0cmljdCBlcXVhbCBjb21wYXJpc29uIHRvIHZpc3VhbGl6ZSB0aGUgb3V0cHV0LlxuXG4gICAgaWYgKGlucHV0TGVuZ3RoIDw9IGtNYXhTaG9ydExlbmd0aCkge1xuICAgICAgaWYgKChfdHlwZW9mKGFjdHVhbCkgIT09ICdvYmplY3QnIHx8IGFjdHVhbCA9PT0gbnVsbCkgJiYgKF90eXBlb2YoZXhwZWN0ZWQpICE9PSAnb2JqZWN0JyB8fCBleHBlY3RlZCA9PT0gbnVsbCkgJiYgKGFjdHVhbCAhPT0gMCB8fCBleHBlY3RlZCAhPT0gMCkpIHtcbiAgICAgICAgLy8gLTAgPT09ICswXG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChrUmVhZGFibGVPcGVyYXRvcltvcGVyYXRvcl0sIFwiXFxuXFxuXCIpICsgXCJcIi5jb25jYXQoYWN0dWFsTGluZXNbMF0sIFwiICE9PSBcIikuY29uY2F0KGV4cGVjdGVkTGluZXNbMF0sIFwiXFxuXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3BlcmF0b3IgIT09ICdzdHJpY3RFcXVhbE9iamVjdCcpIHtcbiAgICAgIC8vIElmIHRoZSBzdGRlcnIgaXMgYSB0dHkgYW5kIHRoZSBpbnB1dCBsZW5ndGggaXMgbG93ZXIgdGhhbiB0aGUgY3VycmVudFxuICAgICAgLy8gY29sdW1ucyBwZXIgbGluZSwgYWRkIGEgbWlzbWF0Y2ggaW5kaWNhdG9yIGJlbG93IHRoZSBvdXRwdXQuIElmIGl0IGlzXG4gICAgICAvLyBub3QgYSB0dHksIHVzZSBhIGRlZmF1bHQgdmFsdWUgb2YgODAgY2hhcmFjdGVycy5cbiAgICAgIHZhciBtYXhMZW5ndGggPSBwcm9jZXNzLnN0ZGVyciAmJiBwcm9jZXNzLnN0ZGVyci5pc1RUWSA/IHByb2Nlc3Muc3RkZXJyLmNvbHVtbnMgOiA4MDtcblxuICAgICAgaWYgKGlucHV0TGVuZ3RoIDwgbWF4TGVuZ3RoKSB7XG4gICAgICAgIHdoaWxlIChhY3R1YWxMaW5lc1swXVtpXSA9PT0gZXhwZWN0ZWRMaW5lc1swXVtpXSkge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfSAvLyBJZ25vcmUgdGhlIGZpcnN0IGNoYXJhY3RlcnMuXG5cblxuICAgICAgICBpZiAoaSA+IDIpIHtcbiAgICAgICAgICAvLyBBZGQgcG9zaXRpb24gaW5kaWNhdG9yIGZvciB0aGUgZmlyc3QgbWlzbWF0Y2ggaW4gY2FzZSBpdCBpcyBhXG4gICAgICAgICAgLy8gc2luZ2xlIGxpbmUgYW5kIHRoZSBpbnB1dCBsZW5ndGggaXMgbGVzcyB0aGFuIHRoZSBjb2x1bW4gbGVuZ3RoLlxuICAgICAgICAgIGluZGljYXRvciA9IFwiXFxuICBcIi5jb25jYXQocmVwZWF0KCcgJywgaSksIFwiXlwiKTtcbiAgICAgICAgICBpID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSAvLyBSZW1vdmUgYWxsIGVuZGluZyBsaW5lcyB0aGF0IG1hdGNoICh0aGlzIG9wdGltaXplcyB0aGUgb3V0cHV0IGZvclxuICAvLyByZWFkYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgbnVtYmVyIG9mIHRvdGFsIGNoYW5nZWQgbGluZXMpLlxuXG5cbiAgdmFyIGEgPSBhY3R1YWxMaW5lc1thY3R1YWxMaW5lcy5sZW5ndGggLSAxXTtcbiAgdmFyIGIgPSBleHBlY3RlZExpbmVzW2V4cGVjdGVkTGluZXMubGVuZ3RoIC0gMV07XG5cbiAgd2hpbGUgKGEgPT09IGIpIHtcbiAgICBpZiAoaSsrIDwgMikge1xuICAgICAgZW5kID0gXCJcXG4gIFwiLmNvbmNhdChhKS5jb25jYXQoZW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3RoZXIgPSBhO1xuICAgIH1cblxuICAgIGFjdHVhbExpbmVzLnBvcCgpO1xuICAgIGV4cGVjdGVkTGluZXMucG9wKCk7XG4gICAgaWYgKGFjdHVhbExpbmVzLmxlbmd0aCA9PT0gMCB8fCBleHBlY3RlZExpbmVzLmxlbmd0aCA9PT0gMCkgYnJlYWs7XG4gICAgYSA9IGFjdHVhbExpbmVzW2FjdHVhbExpbmVzLmxlbmd0aCAtIDFdO1xuICAgIGIgPSBleHBlY3RlZExpbmVzW2V4cGVjdGVkTGluZXMubGVuZ3RoIC0gMV07XG4gIH1cblxuICB2YXIgbWF4TGluZXMgPSBNYXRoLm1heChhY3R1YWxMaW5lcy5sZW5ndGgsIGV4cGVjdGVkTGluZXMubGVuZ3RoKTsgLy8gU3RyaWN0IGVxdWFsIHdpdGggaWRlbnRpY2FsIG9iamVjdHMgdGhhdCBhcmUgbm90IGlkZW50aWNhbCBieSByZWZlcmVuY2UuXG4gIC8vIEUuZy4sIGFzc2VydC5kZWVwU3RyaWN0RXF1YWwoeyBhOiBTeW1ib2woKSB9LCB7IGE6IFN5bWJvbCgpIH0pXG5cbiAgaWYgKG1heExpbmVzID09PSAwKSB7XG4gICAgLy8gV2UgaGF2ZSB0byBnZXQgdGhlIHJlc3VsdCBhZ2Fpbi4gVGhlIGxpbmVzIHdlcmUgYWxsIHJlbW92ZWQgYmVmb3JlLlxuICAgIHZhciBfYWN0dWFsTGluZXMgPSBhY3R1YWxJbnNwZWN0ZWQuc3BsaXQoJ1xcbicpOyAvLyBPbmx5IHJlbW92ZSBsaW5lcyBpbiBjYXNlIGl0IG1ha2VzIHNlbnNlIHRvIGNvbGxhcHNlIHRob3NlLlxuICAgIC8vIFRPRE86IEFjY2VwdCBlbnYgdG8gYWx3YXlzIHNob3cgdGhlIGZ1bGwgZXJyb3IuXG5cblxuICAgIGlmIChfYWN0dWFsTGluZXMubGVuZ3RoID4gMzApIHtcbiAgICAgIF9hY3R1YWxMaW5lc1syNl0gPSBcIlwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuXG4gICAgICB3aGlsZSAoX2FjdHVhbExpbmVzLmxlbmd0aCA+IDI3KSB7XG4gICAgICAgIF9hY3R1YWxMaW5lcy5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gXCJcIi5jb25jYXQoa1JlYWRhYmxlT3BlcmF0b3Iubm90SWRlbnRpY2FsLCBcIlxcblxcblwiKS5jb25jYXQoX2FjdHVhbExpbmVzLmpvaW4oJ1xcbicpLCBcIlxcblwiKTtcbiAgfVxuXG4gIGlmIChpID4gMykge1xuICAgIGVuZCA9IFwiXFxuXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSkuY29uY2F0KGVuZCk7XG4gICAgc2tpcHBlZCA9IHRydWU7XG4gIH1cblxuICBpZiAob3RoZXIgIT09ICcnKSB7XG4gICAgZW5kID0gXCJcXG4gIFwiLmNvbmNhdChvdGhlcikuY29uY2F0KGVuZCk7XG4gICAgb3RoZXIgPSAnJztcbiAgfVxuXG4gIHZhciBwcmludGVkTGluZXMgPSAwO1xuICB2YXIgbXNnID0ga1JlYWRhYmxlT3BlcmF0b3Jbb3BlcmF0b3JdICsgXCJcXG5cIi5jb25jYXQoZ3JlZW4sIFwiKyBhY3R1YWxcIikuY29uY2F0KHdoaXRlLCBcIiBcIikuY29uY2F0KHJlZCwgXCItIGV4cGVjdGVkXCIpLmNvbmNhdCh3aGl0ZSk7XG4gIHZhciBza2lwcGVkTXNnID0gXCIgXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSwgXCIgTGluZXMgc2tpcHBlZFwiKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbWF4TGluZXM7IGkrKykge1xuICAgIC8vIE9ubHkgZXh0cmEgZXhwZWN0ZWQgbGluZXMgZXhpc3RcbiAgICB2YXIgY3VyID0gaSAtIGxhc3RQb3M7XG5cbiAgICBpZiAoYWN0dWFsTGluZXMubGVuZ3RoIDwgaSArIDEpIHtcbiAgICAgIC8vIElmIHRoZSBsYXN0IGRpdmVyZ2luZyBsaW5lIGlzIG1vcmUgdGhhbiBvbmUgbGluZSBhYm92ZSBhbmQgdGhlXG4gICAgICAvLyBjdXJyZW50IGxpbmUgaXMgYXQgbGVhc3QgbGluZSB0aHJlZSwgYWRkIHNvbWUgb2YgdGhlIGZvcm1lciBsaW5lcyBhbmRcbiAgICAgIC8vIGFsc28gYWRkIGRvdHMgdG8gaW5kaWNhdGUgc2tpcHBlZCBlbnRyaWVzLlxuICAgICAgaWYgKGN1ciA+IDEgJiYgaSA+IDIpIHtcbiAgICAgICAgaWYgKGN1ciA+IDQpIHtcbiAgICAgICAgICByZXMgKz0gXCJcXG5cIi5jb25jYXQoYmx1ZSwgXCIuLi5cIikuY29uY2F0KHdoaXRlKTtcbiAgICAgICAgICBza2lwcGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXIgPiAzKSB7XG4gICAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoZXhwZWN0ZWRMaW5lc1tpIC0gMl0pO1xuICAgICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoZXhwZWN0ZWRMaW5lc1tpIC0gMV0pO1xuICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgIH0gLy8gTWFyayB0aGUgY3VycmVudCBsaW5lIGFzIHRoZSBsYXN0IGRpdmVyZ2luZyBvbmUuXG5cblxuICAgICAgbGFzdFBvcyA9IGk7IC8vIEFkZCB0aGUgZXhwZWN0ZWQgbGluZSB0byB0aGUgY2FjaGUuXG5cbiAgICAgIG90aGVyICs9IFwiXFxuXCIuY29uY2F0KHJlZCwgXCItXCIpLmNvbmNhdCh3aGl0ZSwgXCIgXCIpLmNvbmNhdChleHBlY3RlZExpbmVzW2ldKTtcbiAgICAgIHByaW50ZWRMaW5lcysrOyAvLyBPbmx5IGV4dHJhIGFjdHVhbCBsaW5lcyBleGlzdFxuICAgIH0gZWxzZSBpZiAoZXhwZWN0ZWRMaW5lcy5sZW5ndGggPCBpICsgMSkge1xuICAgICAgLy8gSWYgdGhlIGxhc3QgZGl2ZXJnaW5nIGxpbmUgaXMgbW9yZSB0aGFuIG9uZSBsaW5lIGFib3ZlIGFuZCB0aGVcbiAgICAgIC8vIGN1cnJlbnQgbGluZSBpcyBhdCBsZWFzdCBsaW5lIHRocmVlLCBhZGQgc29tZSBvZiB0aGUgZm9ybWVyIGxpbmVzIGFuZFxuICAgICAgLy8gYWxzbyBhZGQgZG90cyB0byBpbmRpY2F0ZSBza2lwcGVkIGVudHJpZXMuXG4gICAgICBpZiAoY3VyID4gMSAmJiBpID4gMikge1xuICAgICAgICBpZiAoY3VyID4gNCkge1xuICAgICAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuICAgICAgICAgIHNraXBwZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGN1ciA+IDMpIHtcbiAgICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChhY3R1YWxMaW5lc1tpIC0gMl0pO1xuICAgICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoYWN0dWFsTGluZXNbaSAtIDFdKTtcbiAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICB9IC8vIE1hcmsgdGhlIGN1cnJlbnQgbGluZSBhcyB0aGUgbGFzdCBkaXZlcmdpbmcgb25lLlxuXG5cbiAgICAgIGxhc3RQb3MgPSBpOyAvLyBBZGQgdGhlIGFjdHVhbCBsaW5lIHRvIHRoZSByZXN1bHQuXG5cbiAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChncmVlbiwgXCIrXCIpLmNvbmNhdCh3aGl0ZSwgXCIgXCIpLmNvbmNhdChhY3R1YWxMaW5lc1tpXSk7XG4gICAgICBwcmludGVkTGluZXMrKzsgLy8gTGluZXMgZGl2ZXJnZVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZXhwZWN0ZWRMaW5lID0gZXhwZWN0ZWRMaW5lc1tpXTtcbiAgICAgIHZhciBhY3R1YWxMaW5lID0gYWN0dWFsTGluZXNbaV07IC8vIElmIHRoZSBsaW5lcyBkaXZlcmdlLCBzcGVjaWZpY2FsbHkgY2hlY2sgZm9yIGxpbmVzIHRoYXQgb25seSBkaXZlcmdlIGJ5XG4gICAgICAvLyBhIHRyYWlsaW5nIGNvbW1hLiBJbiB0aGF0IGNhc2UgaXQgaXMgYWN0dWFsbHkgaWRlbnRpY2FsIGFuZCB3ZSBzaG91bGRcbiAgICAgIC8vIG1hcmsgaXQgYXMgc3VjaC5cblxuICAgICAgdmFyIGRpdmVyZ2luZ0xpbmVzID0gYWN0dWFsTGluZSAhPT0gZXhwZWN0ZWRMaW5lICYmICghZW5kc1dpdGgoYWN0dWFsTGluZSwgJywnKSB8fCBhY3R1YWxMaW5lLnNsaWNlKDAsIC0xKSAhPT0gZXhwZWN0ZWRMaW5lKTsgLy8gSWYgdGhlIGV4cGVjdGVkIGxpbmUgaGFzIGEgdHJhaWxpbmcgY29tbWEgYnV0IGlzIG90aGVyd2lzZSBpZGVudGljYWwsXG4gICAgICAvLyBhZGQgYSBjb21tYSBhdCB0aGUgZW5kIG9mIHRoZSBhY3R1YWwgbGluZS4gT3RoZXJ3aXNlIHRoZSBvdXRwdXQgY291bGRcbiAgICAgIC8vIGxvb2sgd2VpcmQgYXMgaW46XG4gICAgICAvL1xuICAgICAgLy8gICBbXG4gICAgICAvLyAgICAgMSAgICAgICAgIC8vIE5vIGNvbW1hIGF0IHRoZSBlbmQhXG4gICAgICAvLyArICAgMlxuICAgICAgLy8gICBdXG4gICAgICAvL1xuXG4gICAgICBpZiAoZGl2ZXJnaW5nTGluZXMgJiYgZW5kc1dpdGgoZXhwZWN0ZWRMaW5lLCAnLCcpICYmIGV4cGVjdGVkTGluZS5zbGljZSgwLCAtMSkgPT09IGFjdHVhbExpbmUpIHtcbiAgICAgICAgZGl2ZXJnaW5nTGluZXMgPSBmYWxzZTtcbiAgICAgICAgYWN0dWFsTGluZSArPSAnLCc7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaXZlcmdpbmdMaW5lcykge1xuICAgICAgICAvLyBJZiB0aGUgbGFzdCBkaXZlcmdpbmcgbGluZSBpcyBtb3JlIHRoYW4gb25lIGxpbmUgYWJvdmUgYW5kIHRoZVxuICAgICAgICAvLyBjdXJyZW50IGxpbmUgaXMgYXQgbGVhc3QgbGluZSB0aHJlZSwgYWRkIHNvbWUgb2YgdGhlIGZvcm1lciBsaW5lcyBhbmRcbiAgICAgICAgLy8gYWxzbyBhZGQgZG90cyB0byBpbmRpY2F0ZSBza2lwcGVkIGVudHJpZXMuXG4gICAgICAgIGlmIChjdXIgPiAxICYmIGkgPiAyKSB7XG4gICAgICAgICAgaWYgKGN1ciA+IDQpIHtcbiAgICAgICAgICAgIHJlcyArPSBcIlxcblwiLmNvbmNhdChibHVlLCBcIi4uLlwiKS5jb25jYXQod2hpdGUpO1xuICAgICAgICAgICAgc2tpcHBlZCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChjdXIgPiAzKSB7XG4gICAgICAgICAgICByZXMgKz0gXCJcXG4gIFwiLmNvbmNhdChhY3R1YWxMaW5lc1tpIC0gMl0pO1xuICAgICAgICAgICAgcHJpbnRlZExpbmVzKys7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzICs9IFwiXFxuICBcIi5jb25jYXQoYWN0dWFsTGluZXNbaSAtIDFdKTtcbiAgICAgICAgICBwcmludGVkTGluZXMrKztcbiAgICAgICAgfSAvLyBNYXJrIHRoZSBjdXJyZW50IGxpbmUgYXMgdGhlIGxhc3QgZGl2ZXJnaW5nIG9uZS5cblxuXG4gICAgICAgIGxhc3RQb3MgPSBpOyAvLyBBZGQgdGhlIGFjdHVhbCBsaW5lIHRvIHRoZSByZXN1bHQgYW5kIGNhY2hlIHRoZSBleHBlY3RlZCBkaXZlcmdpbmdcbiAgICAgICAgLy8gbGluZSBzbyBjb25zZWN1dGl2ZSBkaXZlcmdpbmcgbGluZXMgc2hvdyB1cCBhcyArKystLS0gYW5kIG5vdCArLSstKy0uXG5cbiAgICAgICAgcmVzICs9IFwiXFxuXCIuY29uY2F0KGdyZWVuLCBcIitcIikuY29uY2F0KHdoaXRlLCBcIiBcIikuY29uY2F0KGFjdHVhbExpbmUpO1xuICAgICAgICBvdGhlciArPSBcIlxcblwiLmNvbmNhdChyZWQsIFwiLVwiKS5jb25jYXQod2hpdGUsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRMaW5lKTtcbiAgICAgICAgcHJpbnRlZExpbmVzICs9IDI7IC8vIExpbmVzIGFyZSBpZGVudGljYWxcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFkZCBhbGwgY2FjaGVkIGluZm9ybWF0aW9uIHRvIHRoZSByZXN1bHQgYmVmb3JlIGFkZGluZyBvdGhlciB0aGluZ3NcbiAgICAgICAgLy8gYW5kIHJlc2V0IHRoZSBjYWNoZS5cbiAgICAgICAgcmVzICs9IG90aGVyO1xuICAgICAgICBvdGhlciA9ICcnOyAvLyBJZiB0aGUgbGFzdCBkaXZlcmdpbmcgbGluZSBpcyBleGFjdGx5IG9uZSBsaW5lIGFib3ZlIG9yIGlmIGl0IGlzIHRoZVxuICAgICAgICAvLyB2ZXJ5IGZpcnN0IGxpbmUsIGFkZCB0aGUgbGluZSB0byB0aGUgcmVzdWx0LlxuXG4gICAgICAgIGlmIChjdXIgPT09IDEgfHwgaSA9PT0gMCkge1xuICAgICAgICAgIHJlcyArPSBcIlxcbiAgXCIuY29uY2F0KGFjdHVhbExpbmUpO1xuICAgICAgICAgIHByaW50ZWRMaW5lcysrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBJbnNwZWN0ZWQgb2JqZWN0IHRvIGJpZyAoU2hvdyB+MjAgcm93cyBtYXgpXG5cblxuICAgIGlmIChwcmludGVkTGluZXMgPiAyMCAmJiBpIDwgbWF4TGluZXMgLSAyKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQobXNnKS5jb25jYXQoc2tpcHBlZE1zZywgXCJcXG5cIikuY29uY2F0KHJlcywgXCJcXG5cIikuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSkuY29uY2F0KG90aGVyLCBcIlxcblwiKSArIFwiXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFwiXCIuY29uY2F0KG1zZykuY29uY2F0KHNraXBwZWQgPyBza2lwcGVkTXNnIDogJycsIFwiXFxuXCIpLmNvbmNhdChyZXMpLmNvbmNhdChvdGhlcikuY29uY2F0KGVuZCkuY29uY2F0KGluZGljYXRvcik7XG59XG5cbnZhciBBc3NlcnRpb25FcnJvciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Vycm9yKSB7XG4gIF9pbmhlcml0cyhBc3NlcnRpb25FcnJvciwgX0Vycm9yKTtcblxuICBmdW5jdGlvbiBBc3NlcnRpb25FcnJvcihvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFzc2VydGlvbkVycm9yKTtcblxuICAgIGlmIChfdHlwZW9mKG9wdGlvbnMpICE9PSAnb2JqZWN0JyB8fCBvcHRpb25zID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ29wdGlvbnMnLCAnT2JqZWN0Jywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdmFyIG1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2UsXG4gICAgICAgIG9wZXJhdG9yID0gb3B0aW9ucy5vcGVyYXRvcixcbiAgICAgICAgc3RhY2tTdGFydEZuID0gb3B0aW9ucy5zdGFja1N0YXJ0Rm47XG4gICAgdmFyIGFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsLFxuICAgICAgICBleHBlY3RlZCA9IG9wdGlvbnMuZXhwZWN0ZWQ7XG4gICAgdmFyIGxpbWl0ID0gRXJyb3Iuc3RhY2tUcmFjZUxpbWl0O1xuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IDA7XG5cbiAgICBpZiAobWVzc2FnZSAhPSBudWxsKSB7XG4gICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihBc3NlcnRpb25FcnJvcikuY2FsbCh0aGlzLCBTdHJpbmcobWVzc2FnZSkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3Muc3RkZXJyICYmIHByb2Nlc3Muc3RkZXJyLmlzVFRZKSB7XG4gICAgICAgIC8vIFJlc2V0IG9uIGVhY2ggY2FsbCB0byBtYWtlIHN1cmUgd2UgaGFuZGxlIGR5bmFtaWNhbGx5IHNldCBlbnZpcm9ubWVudFxuICAgICAgICAvLyB2YXJpYWJsZXMgY29ycmVjdC5cbiAgICAgICAgaWYgKHByb2Nlc3Muc3RkZXJyICYmIHByb2Nlc3Muc3RkZXJyLmdldENvbG9yRGVwdGggJiYgcHJvY2Vzcy5zdGRlcnIuZ2V0Q29sb3JEZXB0aCgpICE9PSAxKSB7XG4gICAgICAgICAgYmx1ZSA9IFwiXFx4MUJbMzRtXCI7XG4gICAgICAgICAgZ3JlZW4gPSBcIlxceDFCWzMybVwiO1xuICAgICAgICAgIHdoaXRlID0gXCJcXHgxQlszOW1cIjtcbiAgICAgICAgICByZWQgPSBcIlxceDFCWzMxbVwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJsdWUgPSAnJztcbiAgICAgICAgICBncmVlbiA9ICcnO1xuICAgICAgICAgIHdoaXRlID0gJyc7XG4gICAgICAgICAgcmVkID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUHJldmVudCB0aGUgZXJyb3Igc3RhY2sgZnJvbSBiZWluZyB2aXNpYmxlIGJ5IGR1cGxpY2F0aW5nIHRoZSBlcnJvclxuICAgICAgLy8gaW4gYSB2ZXJ5IGNsb3NlIHdheSB0byB0aGUgb3JpZ2luYWwgaW4gY2FzZSBib3RoIHNpZGVzIGFyZSBhY3R1YWxseVxuICAgICAgLy8gaW5zdGFuY2VzIG9mIEVycm9yLlxuXG5cbiAgICAgIGlmIChfdHlwZW9mKGFjdHVhbCkgPT09ICdvYmplY3QnICYmIGFjdHVhbCAhPT0gbnVsbCAmJiBfdHlwZW9mKGV4cGVjdGVkKSA9PT0gJ29iamVjdCcgJiYgZXhwZWN0ZWQgIT09IG51bGwgJiYgJ3N0YWNrJyBpbiBhY3R1YWwgJiYgYWN0dWFsIGluc3RhbmNlb2YgRXJyb3IgJiYgJ3N0YWNrJyBpbiBleHBlY3RlZCAmJiBleHBlY3RlZCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGFjdHVhbCA9IGNvcHlFcnJvcihhY3R1YWwpO1xuICAgICAgICBleHBlY3RlZCA9IGNvcHlFcnJvcihleHBlY3RlZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcGVyYXRvciA9PT0gJ2RlZXBTdHJpY3RFcXVhbCcgfHwgb3BlcmF0b3IgPT09ICdzdHJpY3RFcXVhbCcpIHtcbiAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQXNzZXJ0aW9uRXJyb3IpLmNhbGwodGhpcywgY3JlYXRlRXJyRGlmZihhY3R1YWwsIGV4cGVjdGVkLCBvcGVyYXRvcikpKTtcbiAgICAgIH0gZWxzZSBpZiAob3BlcmF0b3IgPT09ICdub3REZWVwU3RyaWN0RXF1YWwnIHx8IG9wZXJhdG9yID09PSAnbm90U3RyaWN0RXF1YWwnKSB7XG4gICAgICAgIC8vIEluIGNhc2UgdGhlIG9iamVjdHMgYXJlIGVxdWFsIGJ1dCB0aGUgb3BlcmF0b3IgcmVxdWlyZXMgdW5lcXVhbCwgc2hvd1xuICAgICAgICAvLyB0aGUgZmlyc3Qgb2JqZWN0IGFuZCBzYXkgQSBlcXVhbHMgQlxuICAgICAgICB2YXIgYmFzZSA9IGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXTtcbiAgICAgICAgdmFyIHJlcyA9IGluc3BlY3RWYWx1ZShhY3R1YWwpLnNwbGl0KCdcXG4nKTsgLy8gSW4gY2FzZSBcImFjdHVhbFwiIGlzIGFuIG9iamVjdCwgaXQgc2hvdWxkIG5vdCBiZSByZWZlcmVuY2UgZXF1YWwuXG5cbiAgICAgICAgaWYgKG9wZXJhdG9yID09PSAnbm90U3RyaWN0RXF1YWwnICYmIF90eXBlb2YoYWN0dWFsKSA9PT0gJ29iamVjdCcgJiYgYWN0dWFsICE9PSBudWxsKSB7XG4gICAgICAgICAgYmFzZSA9IGtSZWFkYWJsZU9wZXJhdG9yLm5vdFN0cmljdEVxdWFsT2JqZWN0O1xuICAgICAgICB9IC8vIE9ubHkgcmVtb3ZlIGxpbmVzIGluIGNhc2UgaXQgbWFrZXMgc2Vuc2UgdG8gY29sbGFwc2UgdGhvc2UuXG4gICAgICAgIC8vIFRPRE86IEFjY2VwdCBlbnYgdG8gYWx3YXlzIHNob3cgdGhlIGZ1bGwgZXJyb3IuXG5cblxuICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDMwKSB7XG4gICAgICAgICAgcmVzWzI2XSA9IFwiXCIuY29uY2F0KGJsdWUsIFwiLi4uXCIpLmNvbmNhdCh3aGl0ZSk7XG5cbiAgICAgICAgICB3aGlsZSAocmVzLmxlbmd0aCA+IDI3KSB7XG4gICAgICAgICAgICByZXMucG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIE9ubHkgcHJpbnQgYSBzaW5nbGUgaW5wdXQuXG5cblxuICAgICAgICBpZiAocmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEFzc2VydGlvbkVycm9yKS5jYWxsKHRoaXMsIFwiXCIuY29uY2F0KGJhc2UsIFwiIFwiKS5jb25jYXQocmVzWzBdKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKEFzc2VydGlvbkVycm9yKS5jYWxsKHRoaXMsIFwiXCIuY29uY2F0KGJhc2UsIFwiXFxuXFxuXCIpLmNvbmNhdChyZXMuam9pbignXFxuJyksIFwiXFxuXCIpKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfcmVzID0gaW5zcGVjdFZhbHVlKGFjdHVhbCk7XG5cbiAgICAgICAgdmFyIG90aGVyID0gJyc7XG4gICAgICAgIHZhciBrbm93bk9wZXJhdG9ycyA9IGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXTtcblxuICAgICAgICBpZiAob3BlcmF0b3IgPT09ICdub3REZWVwRXF1YWwnIHx8IG9wZXJhdG9yID09PSAnbm90RXF1YWwnKSB7XG4gICAgICAgICAgX3JlcyA9IFwiXCIuY29uY2F0KGtSZWFkYWJsZU9wZXJhdG9yW29wZXJhdG9yXSwgXCJcXG5cXG5cIikuY29uY2F0KF9yZXMpO1xuXG4gICAgICAgICAgaWYgKF9yZXMubGVuZ3RoID4gMTAyNCkge1xuICAgICAgICAgICAgX3JlcyA9IFwiXCIuY29uY2F0KF9yZXMuc2xpY2UoMCwgMTAyMSksIFwiLi4uXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdGhlciA9IFwiXCIuY29uY2F0KGluc3BlY3RWYWx1ZShleHBlY3RlZCkpO1xuXG4gICAgICAgICAgaWYgKF9yZXMubGVuZ3RoID4gNTEyKSB7XG4gICAgICAgICAgICBfcmVzID0gXCJcIi5jb25jYXQoX3Jlcy5zbGljZSgwLCA1MDkpLCBcIi4uLlwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3RoZXIubGVuZ3RoID4gNTEyKSB7XG4gICAgICAgICAgICBvdGhlciA9IFwiXCIuY29uY2F0KG90aGVyLnNsaWNlKDAsIDUwOSksIFwiLi4uXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcGVyYXRvciA9PT0gJ2RlZXBFcXVhbCcgfHwgb3BlcmF0b3IgPT09ICdlcXVhbCcpIHtcbiAgICAgICAgICAgIF9yZXMgPSBcIlwiLmNvbmNhdChrbm93bk9wZXJhdG9ycywgXCJcXG5cXG5cIikuY29uY2F0KF9yZXMsIFwiXFxuXFxuc2hvdWxkIGVxdWFsXFxuXFxuXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdGhlciA9IFwiIFwiLmNvbmNhdChvcGVyYXRvciwgXCIgXCIpLmNvbmNhdChvdGhlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoQXNzZXJ0aW9uRXJyb3IpLmNhbGwodGhpcywgXCJcIi5jb25jYXQoX3JlcykuY29uY2F0KG90aGVyKSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IGxpbWl0O1xuICAgIF90aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSAhbWVzc2FnZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksICduYW1lJywge1xuICAgICAgdmFsdWU6ICdBc3NlcnRpb25FcnJvciBbRVJSX0FTU0VSVElPTl0nLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIF90aGlzLmNvZGUgPSAnRVJSX0FTU0VSVElPTic7XG4gICAgX3RoaXMuYWN0dWFsID0gYWN0dWFsO1xuICAgIF90aGlzLmV4cGVjdGVkID0gZXhwZWN0ZWQ7XG4gICAgX3RoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcblxuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgc3RhY2tTdGFydEZuKTtcbiAgICB9IC8vIENyZWF0ZSBlcnJvciBtZXNzYWdlIGluY2x1ZGluZyB0aGUgZXJyb3IgY29kZSBpbiB0aGUgbmFtZS5cblxuXG4gICAgX3RoaXMuc3RhY2s7IC8vIFJlc2V0IHRoZSBuYW1lLlxuXG4gICAgX3RoaXMubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7XG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhBc3NlcnRpb25FcnJvciwgW3tcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQodGhpcy5uYW1lLCBcIiBbXCIpLmNvbmNhdCh0aGlzLmNvZGUsIFwiXTogXCIpLmNvbmNhdCh0aGlzLm1lc3NhZ2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogaW5zcGVjdC5jdXN0b20sXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHJlY3Vyc2VUaW1lcywgY3R4KSB7XG4gICAgICAvLyBUaGlzIGxpbWl0cyB0aGUgYGFjdHVhbGAgYW5kIGBleHBlY3RlZGAgcHJvcGVydHkgZGVmYXVsdCBpbnNwZWN0aW9uIHRvXG4gICAgICAvLyB0aGUgbWluaW11bSBkZXB0aC4gT3RoZXJ3aXNlIHRob3NlIHZhbHVlcyB3b3VsZCBiZSB0b28gdmVyYm9zZSBjb21wYXJlZFxuICAgICAgLy8gdG8gdGhlIGFjdHVhbCBlcnJvciBtZXNzYWdlIHdoaWNoIGNvbnRhaW5zIGEgY29tYmluZWQgdmlldyBvZiB0aGVzZSB0d29cbiAgICAgIC8vIGlucHV0IHZhbHVlcy5cbiAgICAgIHJldHVybiBpbnNwZWN0KHRoaXMsIF9vYmplY3RTcHJlYWQoe30sIGN0eCwge1xuICAgICAgICBjdXN0b21JbnNwZWN0OiBmYWxzZSxcbiAgICAgICAgZGVwdGg6IDBcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQXNzZXJ0aW9uRXJyb3I7XG59KF93cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBc3NlcnRpb25FcnJvcjtcblxuLyoqKi8gfSksXG5cbi8qKiovIDEzNDI6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLy8gQ3VycmVudGx5IGluIHN5bmMgd2l0aCBOb2RlLmpzIGxpYi9pbnRlcm5hbC9lcnJvcnMuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvM2IwNDQ5NjJjNDhmZTMxMzkwNTg3N2E5NmI1ZDA4OTRhNTQwNGY2ZlxuXG4vKiBlc2xpbnQgbm9kZS1jb3JlL2RvY3VtZW50ZWQtZXJyb3JzOiBcImVycm9yXCIgKi9cblxuLyogZXNsaW50IG5vZGUtY29yZS9hbHBoYWJldGl6ZS1lcnJvcnM6IFwiZXJyb3JcIiAqL1xuXG4vKiBlc2xpbnQgbm9kZS1jb3JlL3ByZWZlci11dGlsLWZvcm1hdC1lcnJvcnM6IFwiZXJyb3JcIiAqL1xuIC8vIFRoZSB3aG9sZSBwb2ludCBiZWhpbmQgdGhpcyBpbnRlcm5hbCBtb2R1bGUgaXMgdG8gYWxsb3cgTm9kZS5qcyB0byBub1xuLy8gbG9uZ2VyIGJlIGZvcmNlZCB0byB0cmVhdCBldmVyeSBlcnJvciBtZXNzYWdlIGNoYW5nZSBhcyBhIHNlbXZlci1tYWpvclxuLy8gY2hhbmdlLiBUaGUgTm9kZUVycm9yIGNsYXNzZXMgaGVyZSBhbGwgZXhwb3NlIGEgYGNvZGVgIHByb3BlcnR5IHdob3NlXG4vLyB2YWx1ZSBzdGF0aWNhbGx5IGFuZCBwZXJtYW5lbnRseSBpZGVudGlmaWVzIHRoZSBlcnJvci4gV2hpbGUgdGhlIGVycm9yXG4vLyBtZXNzYWdlIG1heSBjaGFuZ2UsIHRoZSBjb2RlIHNob3VsZCBub3QuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxudmFyIGNvZGVzID0ge307IC8vIExhenkgbG9hZGVkXG5cbnZhciBhc3NlcnQ7XG52YXIgdXRpbDtcblxuZnVuY3Rpb24gY3JlYXRlRXJyb3JUeXBlKGNvZGUsIG1lc3NhZ2UsIEJhc2UpIHtcbiAgaWYgKCFCYXNlKSB7XG4gICAgQmFzZSA9IEVycm9yO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBOb2RlRXJyb3IgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uIChfQmFzZSkge1xuICAgIF9pbmhlcml0cyhOb2RlRXJyb3IsIF9CYXNlKTtcblxuICAgIGZ1bmN0aW9uIE5vZGVFcnJvcihhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb2RlRXJyb3IpO1xuXG4gICAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihOb2RlRXJyb3IpLmNhbGwodGhpcywgZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKSkpO1xuICAgICAgX3RoaXMuY29kZSA9IGNvZGU7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIE5vZGVFcnJvcjtcbiAgfShCYXNlKTtcblxuICBjb2Rlc1tjb2RlXSA9IE5vZGVFcnJvcjtcbn0gLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjEwLjguMC9saWIvaW50ZXJuYWwvZXJyb3JzLmpzXG5cblxuZnVuY3Rpb24gb25lT2YoZXhwZWN0ZWQsIHRoaW5nKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGV4cGVjdGVkKSkge1xuICAgIHZhciBsZW4gPSBleHBlY3RlZC5sZW5ndGg7XG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaSk7XG4gICAgfSk7XG5cbiAgICBpZiAobGVuID4gMikge1xuICAgICAgcmV0dXJuIFwib25lIG9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZC5zbGljZSgwLCBsZW4gLSAxKS5qb2luKCcsICcpLCBcIiwgb3IgXCIpICsgZXhwZWN0ZWRbbGVuIC0gMV07XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDIpIHtcbiAgICAgIHJldHVybiBcIm9uZSBvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0sIFwiIG9yIFwiKS5jb25jYXQoZXhwZWN0ZWRbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoU3RyaW5nKGV4cGVjdGVkKSk7XG4gIH1cbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3N0YXJ0c1dpdGhcblxuXG5mdW5jdGlvbiBzdGFydHNXaXRoKHN0ciwgc2VhcmNoLCBwb3MpIHtcbiAgcmV0dXJuIHN0ci5zdWJzdHIoIXBvcyB8fCBwb3MgPCAwID8gMCA6ICtwb3MsIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9lbmRzV2l0aFxuXG5cbmZ1bmN0aW9uIGVuZHNXaXRoKHN0ciwgc2VhcmNoLCB0aGlzX2xlbikge1xuICBpZiAodGhpc19sZW4gPT09IHVuZGVmaW5lZCB8fCB0aGlzX2xlbiA+IHN0ci5sZW5ndGgpIHtcbiAgICB0aGlzX2xlbiA9IHN0ci5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gc3RyLnN1YnN0cmluZyh0aGlzX2xlbiAtIHNlYXJjaC5sZW5ndGgsIHRoaXNfbGVuKSA9PT0gc2VhcmNoO1xufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvaW5jbHVkZXNcblxuXG5mdW5jdGlvbiBpbmNsdWRlcyhzdHIsIHNlYXJjaCwgc3RhcnQpIHtcbiAgaWYgKHR5cGVvZiBzdGFydCAhPT0gJ251bWJlcicpIHtcbiAgICBzdGFydCA9IDA7XG4gIH1cblxuICBpZiAoc3RhcnQgKyBzZWFyY2gubGVuZ3RoID4gc3RyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyLmluZGV4T2Yoc2VhcmNoLCBzdGFydCkgIT09IC0xO1xuICB9XG59XG5cbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0FNQklHVU9VU19BUkdVTUVOVCcsICdUaGUgXCIlc1wiIGFyZ3VtZW50IGlzIGFtYmlndW91cy4gJXMnLCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfSU5WQUxJRF9BUkdfVFlQRScsIGZ1bmN0aW9uIChuYW1lLCBleHBlY3RlZCwgYWN0dWFsKSB7XG4gIGlmIChhc3NlcnQgPT09IHVuZGVmaW5lZCkgYXNzZXJ0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MDkzKTtcbiAgYXNzZXJ0KHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJywgXCInbmFtZScgbXVzdCBiZSBhIHN0cmluZ1wiKTsgLy8gZGV0ZXJtaW5lcjogJ211c3QgYmUnIG9yICdtdXN0IG5vdCBiZSdcblxuICB2YXIgZGV0ZXJtaW5lcjtcblxuICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnc3RyaW5nJyAmJiBzdGFydHNXaXRoKGV4cGVjdGVkLCAnbm90ICcpKSB7XG4gICAgZGV0ZXJtaW5lciA9ICdtdXN0IG5vdCBiZSc7XG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5yZXBsYWNlKC9ebm90IC8sICcnKTtcbiAgfSBlbHNlIHtcbiAgICBkZXRlcm1pbmVyID0gJ211c3QgYmUnO1xuICB9XG5cbiAgdmFyIG1zZztcblxuICBpZiAoZW5kc1dpdGgobmFtZSwgJyBhcmd1bWVudCcpKSB7XG4gICAgLy8gRm9yIGNhc2VzIGxpa2UgJ2ZpcnN0IGFyZ3VtZW50J1xuICAgIG1zZyA9IFwiVGhlIFwiLmNvbmNhdChuYW1lLCBcIiBcIikuY29uY2F0KGRldGVybWluZXIsIFwiIFwiKS5jb25jYXQob25lT2YoZXhwZWN0ZWQsICd0eXBlJykpO1xuICB9IGVsc2Uge1xuICAgIHZhciB0eXBlID0gaW5jbHVkZXMobmFtZSwgJy4nKSA/ICdwcm9wZXJ0eScgOiAnYXJndW1lbnQnO1xuICAgIG1zZyA9IFwiVGhlIFxcXCJcIi5jb25jYXQobmFtZSwgXCJcXFwiIFwiKS5jb25jYXQodHlwZSwgXCIgXCIpLmNvbmNhdChkZXRlcm1pbmVyLCBcIiBcIikuY29uY2F0KG9uZU9mKGV4cGVjdGVkLCAndHlwZScpKTtcbiAgfSAvLyBUT0RPKEJyaWRnZUFSKTogSW1wcm92ZSB0aGUgb3V0cHV0IGJ5IHNob3dpbmcgYG51bGxgIGFuZCBzaW1pbGFyLlxuXG5cbiAgbXNnICs9IFwiLiBSZWNlaXZlZCB0eXBlIFwiLmNvbmNhdChfdHlwZW9mKGFjdHVhbCkpO1xuICByZXR1cm4gbXNnO1xufSwgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0lOVkFMSURfQVJHX1ZBTFVFJywgZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gIHZhciByZWFzb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICdpcyBpbnZhbGlkJztcbiAgaWYgKHV0aWwgPT09IHVuZGVmaW5lZCkgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oNjgyNyk7XG4gIHZhciBpbnNwZWN0ZWQgPSB1dGlsLmluc3BlY3QodmFsdWUpO1xuXG4gIGlmIChpbnNwZWN0ZWQubGVuZ3RoID4gMTI4KSB7XG4gICAgaW5zcGVjdGVkID0gXCJcIi5jb25jYXQoaW5zcGVjdGVkLnNsaWNlKDAsIDEyOCksIFwiLi4uXCIpO1xuICB9XG5cbiAgcmV0dXJuIFwiVGhlIGFyZ3VtZW50ICdcIi5jb25jYXQobmFtZSwgXCInIFwiKS5jb25jYXQocmVhc29uLCBcIi4gUmVjZWl2ZWQgXCIpLmNvbmNhdChpbnNwZWN0ZWQpO1xufSwgVHlwZUVycm9yLCBSYW5nZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0lOVkFMSURfUkVUVVJOX1ZBTFVFJywgZnVuY3Rpb24gKGlucHV0LCBuYW1lLCB2YWx1ZSkge1xuICB2YXIgdHlwZTtcblxuICBpZiAodmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgIHR5cGUgPSBcImluc3RhbmNlIG9mIFwiLmNvbmNhdCh2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgfSBlbHNlIHtcbiAgICB0eXBlID0gXCJ0eXBlIFwiLmNvbmNhdChfdHlwZW9mKHZhbHVlKSk7XG4gIH1cblxuICByZXR1cm4gXCJFeHBlY3RlZCBcIi5jb25jYXQoaW5wdXQsIFwiIHRvIGJlIHJldHVybmVkIGZyb20gdGhlIFxcXCJcIikuY29uY2F0KG5hbWUsIFwiXFxcIlwiKSArIFwiIGZ1bmN0aW9uIGJ1dCBnb3QgXCIuY29uY2F0KHR5cGUsIFwiLlwiKTtcbn0sIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9NSVNTSU5HX0FSR1MnLCBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpZiAoYXNzZXJ0ID09PSB1bmRlZmluZWQpIGFzc2VydCA9IF9fd2VicGFja19yZXF1aXJlX18oNjA5Myk7XG4gIGFzc2VydChhcmdzLmxlbmd0aCA+IDAsICdBdCBsZWFzdCBvbmUgYXJnIG5lZWRzIHRvIGJlIHNwZWNpZmllZCcpO1xuICB2YXIgbXNnID0gJ1RoZSAnO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIGFyZ3MgPSBhcmdzLm1hcChmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiBcIlxcXCJcIi5jb25jYXQoYSwgXCJcXFwiXCIpO1xuICB9KTtcblxuICBzd2l0Y2ggKGxlbikge1xuICAgIGNhc2UgMTpcbiAgICAgIG1zZyArPSBcIlwiLmNvbmNhdChhcmdzWzBdLCBcIiBhcmd1bWVudFwiKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAyOlxuICAgICAgbXNnICs9IFwiXCIuY29uY2F0KGFyZ3NbMF0sIFwiIGFuZCBcIikuY29uY2F0KGFyZ3NbMV0sIFwiIGFyZ3VtZW50c1wiKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIG1zZyArPSBhcmdzLnNsaWNlKDAsIGxlbiAtIDEpLmpvaW4oJywgJyk7XG4gICAgICBtc2cgKz0gXCIsIGFuZCBcIi5jb25jYXQoYXJnc1tsZW4gLSAxXSwgXCIgYXJndW1lbnRzXCIpO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gXCJcIi5jb25jYXQobXNnLCBcIiBtdXN0IGJlIHNwZWNpZmllZFwiKTtcbn0sIFR5cGVFcnJvcik7XG5tb2R1bGUuZXhwb3J0cy5jb2RlcyA9IGNvZGVzO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNTY1Njpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2ludGVybmFsL3V0aWwvY29tcGFyaXNvbnMuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvMTEyY2M3YzI3NTUxMjU0YWEyYjE3MDk4ZmI3NzQ4NjdmMDVlZDBkOVxuXG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG52YXIgcmVnZXhGbGFnc1N1cHBvcnRlZCA9IC9hL2cuZmxhZ3MgIT09IHVuZGVmaW5lZDtcblxudmFyIGFycmF5RnJvbVNldCA9IGZ1bmN0aW9uIGFycmF5RnJvbVNldChzZXQpIHtcbiAgdmFyIGFycmF5ID0gW107XG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBhcnJheS5wdXNoKHZhbHVlKTtcbiAgfSk7XG4gIHJldHVybiBhcnJheTtcbn07XG5cbnZhciBhcnJheUZyb21NYXAgPSBmdW5jdGlvbiBhcnJheUZyb21NYXAobWFwKSB7XG4gIHZhciBhcnJheSA9IFtdO1xuICBtYXAuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgIHJldHVybiBhcnJheS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0pO1xuICByZXR1cm4gYXJyYXk7XG59O1xuXG52YXIgb2JqZWN0SXMgPSBPYmplY3QuaXMgPyBPYmplY3QuaXMgOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5NjgpO1xudmFyIG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzIDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gW107XG59O1xudmFyIG51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOID8gTnVtYmVyLmlzTmFOIDogX193ZWJwYWNrX3JlcXVpcmVfXyg3ODM4KTtcblxuZnVuY3Rpb24gdW5jdXJyeVRoaXMoZikge1xuICByZXR1cm4gZi5jYWxsLmJpbmQoZik7XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSk7XG52YXIgb2JqZWN0VG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKTtcblxudmFyIF9yZXF1aXJlJHR5cGVzID0gKF9fd2VicGFja19yZXF1aXJlX18oNjgyNykudHlwZXMpLFxuICAgIGlzQW55QXJyYXlCdWZmZXIgPSBfcmVxdWlyZSR0eXBlcy5pc0FueUFycmF5QnVmZmVyLFxuICAgIGlzQXJyYXlCdWZmZXJWaWV3ID0gX3JlcXVpcmUkdHlwZXMuaXNBcnJheUJ1ZmZlclZpZXcsXG4gICAgaXNEYXRlID0gX3JlcXVpcmUkdHlwZXMuaXNEYXRlLFxuICAgIGlzTWFwID0gX3JlcXVpcmUkdHlwZXMuaXNNYXAsXG4gICAgaXNSZWdFeHAgPSBfcmVxdWlyZSR0eXBlcy5pc1JlZ0V4cCxcbiAgICBpc1NldCA9IF9yZXF1aXJlJHR5cGVzLmlzU2V0LFxuICAgIGlzTmF0aXZlRXJyb3IgPSBfcmVxdWlyZSR0eXBlcy5pc05hdGl2ZUVycm9yLFxuICAgIGlzQm94ZWRQcmltaXRpdmUgPSBfcmVxdWlyZSR0eXBlcy5pc0JveGVkUHJpbWl0aXZlLFxuICAgIGlzTnVtYmVyT2JqZWN0ID0gX3JlcXVpcmUkdHlwZXMuaXNOdW1iZXJPYmplY3QsXG4gICAgaXNTdHJpbmdPYmplY3QgPSBfcmVxdWlyZSR0eXBlcy5pc1N0cmluZ09iamVjdCxcbiAgICBpc0Jvb2xlYW5PYmplY3QgPSBfcmVxdWlyZSR0eXBlcy5pc0Jvb2xlYW5PYmplY3QsXG4gICAgaXNCaWdJbnRPYmplY3QgPSBfcmVxdWlyZSR0eXBlcy5pc0JpZ0ludE9iamVjdCxcbiAgICBpc1N5bWJvbE9iamVjdCA9IF9yZXF1aXJlJHR5cGVzLmlzU3ltYm9sT2JqZWN0LFxuICAgIGlzRmxvYXQzMkFycmF5ID0gX3JlcXVpcmUkdHlwZXMuaXNGbG9hdDMyQXJyYXksXG4gICAgaXNGbG9hdDY0QXJyYXkgPSBfcmVxdWlyZSR0eXBlcy5pc0Zsb2F0NjRBcnJheTtcblxuZnVuY3Rpb24gaXNOb25JbmRleChrZXkpIHtcbiAgaWYgKGtleS5sZW5ndGggPT09IDAgfHwga2V5Lmxlbmd0aCA+IDEwKSByZXR1cm4gdHJ1ZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjb2RlID0ga2V5LmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPCA0OCB8fCBjb2RlID4gNTcpIHJldHVybiB0cnVlO1xuICB9IC8vIFRoZSBtYXhpbXVtIHNpemUgZm9yIGFuIGFycmF5IGlzIDIgKiogMzIgLTEuXG5cblxuICByZXR1cm4ga2V5Lmxlbmd0aCA9PT0gMTAgJiYga2V5ID49IE1hdGgucG93KDIsIDMyKTtcbn1cblxuZnVuY3Rpb24gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZSkuZmlsdGVyKGlzTm9uSW5kZXgpLmNvbmNhdChvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsdWUpLmZpbHRlcihPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmJpbmQodmFsdWUpKSk7XG59IC8vIFRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvYmxvYi82ODBlOWU1ZTQ4OGYyMmFhYzI3NTk5YTU3ZGM4NDRhNjMxNTkyOGRkL2luZGV4LmpzXG4vLyBvcmlnaW5hbCBub3RpY2U6XG5cbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxuXG5mdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciB4ID0gYS5sZW5ndGg7XG4gIHZhciB5ID0gYi5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV07XG4gICAgICB5ID0gYltpXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGlmICh5IDwgeCkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbnZhciBPTkxZX0VOVU1FUkFCTEUgPSB1bmRlZmluZWQ7XG52YXIga1N0cmljdCA9IHRydWU7XG52YXIga0xvb3NlID0gZmFsc2U7XG52YXIga05vSXRlcmF0b3IgPSAwO1xudmFyIGtJc0FycmF5ID0gMTtcbnZhciBrSXNTZXQgPSAyO1xudmFyIGtJc01hcCA9IDM7IC8vIENoZWNrIGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSBzb3VyY2UgYW5kIGZsYWdzXG5cbmZ1bmN0aW9uIGFyZVNpbWlsYXJSZWdFeHBzKGEsIGIpIHtcbiAgcmV0dXJuIHJlZ2V4RmxhZ3NTdXBwb3J0ZWQgPyBhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiYgYS5mbGFncyA9PT0gYi5mbGFncyA6IFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKSA9PT0gUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGIpO1xufVxuXG5mdW5jdGlvbiBhcmVTaW1pbGFyRmxvYXRBcnJheXMoYSwgYikge1xuICBpZiAoYS5ieXRlTGVuZ3RoICE9PSBiLmJ5dGVMZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBvZmZzZXQgPSAwOyBvZmZzZXQgPCBhLmJ5dGVMZW5ndGg7IG9mZnNldCsrKSB7XG4gICAgaWYgKGFbb2Zmc2V0XSAhPT0gYltvZmZzZXRdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGFyZVNpbWlsYXJUeXBlZEFycmF5cyhhLCBiKSB7XG4gIGlmIChhLmJ5dGVMZW5ndGggIT09IGIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBjb21wYXJlKG5ldyBVaW50OEFycmF5KGEuYnVmZmVyLCBhLmJ5dGVPZmZzZXQsIGEuYnl0ZUxlbmd0aCksIG5ldyBVaW50OEFycmF5KGIuYnVmZmVyLCBiLmJ5dGVPZmZzZXQsIGIuYnl0ZUxlbmd0aCkpID09PSAwO1xufVxuXG5mdW5jdGlvbiBhcmVFcXVhbEFycmF5QnVmZmVycyhidWYxLCBidWYyKSB7XG4gIHJldHVybiBidWYxLmJ5dGVMZW5ndGggPT09IGJ1ZjIuYnl0ZUxlbmd0aCAmJiBjb21wYXJlKG5ldyBVaW50OEFycmF5KGJ1ZjEpLCBuZXcgVWludDhBcnJheShidWYyKSkgPT09IDA7XG59XG5cbmZ1bmN0aW9uIGlzRXF1YWxCb3hlZFByaW1pdGl2ZSh2YWwxLCB2YWwyKSB7XG4gIGlmIChpc051bWJlck9iamVjdCh2YWwxKSkge1xuICAgIHJldHVybiBpc051bWJlck9iamVjdCh2YWwyKSAmJiBvYmplY3RJcyhOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwxKSwgTnVtYmVyLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMikpO1xuICB9XG5cbiAgaWYgKGlzU3RyaW5nT2JqZWN0KHZhbDEpKSB7XG4gICAgcmV0dXJuIGlzU3RyaW5nT2JqZWN0KHZhbDIpICYmIFN0cmluZy5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpID09PSBTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwyKTtcbiAgfVxuXG4gIGlmIChpc0Jvb2xlYW5PYmplY3QodmFsMSkpIHtcbiAgICByZXR1cm4gaXNCb29sZWFuT2JqZWN0KHZhbDIpICYmIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwxKSA9PT0gQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDIpO1xuICB9XG5cbiAgaWYgKGlzQmlnSW50T2JqZWN0KHZhbDEpKSB7XG4gICAgcmV0dXJuIGlzQmlnSW50T2JqZWN0KHZhbDIpICYmIEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZi5jYWxsKHZhbDEpID09PSBCaWdJbnQucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwyKTtcbiAgfVxuXG4gIHJldHVybiBpc1N5bWJvbE9iamVjdCh2YWwyKSAmJiBTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh2YWwxKSA9PT0gU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwodmFsMik7XG59IC8vIE5vdGVzOiBUeXBlIHRhZ3MgYXJlIGhpc3RvcmljYWwgW1tDbGFzc11dIHByb3BlcnRpZXMgdGhhdCBjYW4gYmUgc2V0IGJ5XG4vLyBGdW5jdGlvblRlbXBsYXRlOjpTZXRDbGFzc05hbWUoKSBpbiBDKysgb3IgU3ltYm9sLnRvU3RyaW5nVGFnIGluIEpTXG4vLyBhbmQgcmV0cmlldmVkIHVzaW5nIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopIGluIEpTXG4vLyBTZWUgaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZ1xuLy8gZm9yIGEgbGlzdCBvZiB0YWdzIHByZS1kZWZpbmVkIGluIHRoZSBzcGVjLlxuLy8gVGhlcmUgYXJlIHNvbWUgdW5zcGVjaWZpZWQgdGFncyBpbiB0aGUgd2lsZCB0b28gKGUuZy4gdHlwZWQgYXJyYXkgdGFncykuXG4vLyBTaW5jZSB0YWdzIGNhbiBiZSBhbHRlcmVkLCB0aGV5IG9ubHkgc2VydmUgZmFzdCBmYWlsdXJlc1xuLy9cbi8vIFR5cGVkIGFycmF5cyBhbmQgYnVmZmVycyBhcmUgY2hlY2tlZCBieSBjb21wYXJpbmcgdGhlIGNvbnRlbnQgaW4gdGhlaXJcbi8vIHVuZGVybHlpbmcgQXJyYXlCdWZmZXIuIFRoaXMgb3B0aW1pemF0aW9uIHJlcXVpcmVzIHRoYXQgaXQnc1xuLy8gcmVhc29uYWJsZSB0byBpbnRlcnByZXQgdGhlaXIgdW5kZXJseWluZyBtZW1vcnkgaW4gdGhlIHNhbWUgd2F5LFxuLy8gd2hpY2ggaXMgY2hlY2tlZCBieSBjb21wYXJpbmcgdGhlaXIgdHlwZSB0YWdzLlxuLy8gKGUuZy4gYSBVaW50OEFycmF5IGFuZCBhIFVpbnQxNkFycmF5IHdpdGggdGhlIHNhbWUgbWVtb3J5IGNvbnRlbnRcbi8vIGNvdWxkIHN0aWxsIGJlIGRpZmZlcmVudCBiZWNhdXNlIHRoZXkgd2lsbCBiZSBpbnRlcnByZXRlZCBkaWZmZXJlbnRseSkuXG4vL1xuLy8gRm9yIHN0cmljdCBjb21wYXJpc29uLCBvYmplY3RzIHNob3VsZCBoYXZlXG4vLyBhKSBUaGUgc2FtZSBidWlsdC1pbiB0eXBlIHRhZ3Ncbi8vIGIpIFRoZSBzYW1lIHByb3RvdHlwZXMuXG5cblxuZnVuY3Rpb24gaW5uZXJEZWVwRXF1YWwodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcykge1xuICAvLyBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmICh2YWwxID09PSB2YWwyKSB7XG4gICAgaWYgKHZhbDEgIT09IDApIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBzdHJpY3QgPyBvYmplY3RJcyh2YWwxLCB2YWwyKSA6IHRydWU7XG4gIH0gLy8gQ2hlY2sgbW9yZSBjbG9zZWx5IGlmIHZhbDEgYW5kIHZhbDIgYXJlIGVxdWFsLlxuXG5cbiAgaWYgKHN0cmljdCkge1xuICAgIGlmIChfdHlwZW9mKHZhbDEpICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWwxID09PSAnbnVtYmVyJyAmJiBudW1iZXJJc05hTih2YWwxKSAmJiBudW1iZXJJc05hTih2YWwyKTtcbiAgICB9XG5cbiAgICBpZiAoX3R5cGVvZih2YWwyKSAhPT0gJ29iamVjdCcgfHwgdmFsMSA9PT0gbnVsbCB8fCB2YWwyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWwxKSAhPT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2YWwxID09PSBudWxsIHx8IF90eXBlb2YodmFsMSkgIT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAodmFsMiA9PT0gbnVsbCB8fCBfdHlwZW9mKHZhbDIpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG4gICAgICAgIHJldHVybiB2YWwxID09IHZhbDI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodmFsMiA9PT0gbnVsbCB8fCBfdHlwZW9mKHZhbDIpICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHZhciB2YWwxVGFnID0gb2JqZWN0VG9TdHJpbmcodmFsMSk7XG4gIHZhciB2YWwyVGFnID0gb2JqZWN0VG9TdHJpbmcodmFsMik7XG5cbiAgaWYgKHZhbDFUYWcgIT09IHZhbDJUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwxKSkge1xuICAgIC8vIENoZWNrIGZvciBzcGFyc2UgYXJyYXlzIGFuZCBnZW5lcmFsIGZhc3QgcGF0aFxuICAgIGlmICh2YWwxLmxlbmd0aCAhPT0gdmFsMi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIga2V5czEgPSBnZXRPd25Ob25JbmRleFByb3BlcnRpZXModmFsMSwgT05MWV9FTlVNRVJBQkxFKTtcbiAgICB2YXIga2V5czIgPSBnZXRPd25Ob25JbmRleFByb3BlcnRpZXModmFsMiwgT05MWV9FTlVNRVJBQkxFKTtcblxuICAgIGlmIChrZXlzMS5sZW5ndGggIT09IGtleXMyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrSXNBcnJheSwga2V5czEpO1xuICB9IC8vIFticm93c2VyaWZ5XSBUaGlzIHRyaWdnZXJzIG9uIGNlcnRhaW4gdHlwZXMgaW4gSUUgKE1hcC9TZXQpIHNvIHdlIGRvbid0XG4gIC8vIHdhbid0IHRvIGVhcmx5IHJldHVybiBvdXQgb2YgdGhlIHJlc3Qgb2YgdGhlIGNoZWNrcy4gSG93ZXZlciB3ZSBjYW4gY2hlY2tcbiAgLy8gaWYgdGhlIHNlY29uZCB2YWx1ZSBpcyBvbmUgb2YgdGhlc2UgdmFsdWVzIGFuZCB0aGUgZmlyc3QgaXNuJ3QuXG5cblxuICBpZiAodmFsMVRhZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAvLyByZXR1cm4ga2V5Q2hlY2sodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vcywga05vSXRlcmF0b3IpO1xuICAgIGlmICghaXNNYXAodmFsMSkgJiYgaXNNYXAodmFsMikgfHwgIWlzU2V0KHZhbDEpICYmIGlzU2V0KHZhbDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzRGF0ZSh2YWwxKSkge1xuICAgIGlmICghaXNEYXRlKHZhbDIpIHx8IERhdGUucHJvdG90eXBlLmdldFRpbWUuY2FsbCh2YWwxKSAhPT0gRGF0ZS5wcm90b3R5cGUuZ2V0VGltZS5jYWxsKHZhbDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUmVnRXhwKHZhbDEpKSB7XG4gICAgaWYgKCFpc1JlZ0V4cCh2YWwyKSB8fCAhYXJlU2ltaWxhclJlZ0V4cHModmFsMSwgdmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNOYXRpdmVFcnJvcih2YWwxKSB8fCB2YWwxIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAvLyBEbyBub3QgY29tcGFyZSB0aGUgc3RhY2sgYXMgaXQgbWlnaHQgZGlmZmVyIGV2ZW4gdGhvdWdoIHRoZSBlcnJvciBpdHNlbGZcbiAgICAvLyBpcyBvdGhlcndpc2UgaWRlbnRpY2FsLlxuICAgIGlmICh2YWwxLm1lc3NhZ2UgIT09IHZhbDIubWVzc2FnZSB8fCB2YWwxLm5hbWUgIT09IHZhbDIubmFtZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0FycmF5QnVmZmVyVmlldyh2YWwxKSkge1xuICAgIGlmICghc3RyaWN0ICYmIChpc0Zsb2F0MzJBcnJheSh2YWwxKSB8fCBpc0Zsb2F0NjRBcnJheSh2YWwxKSkpIHtcbiAgICAgIGlmICghYXJlU2ltaWxhckZsb2F0QXJyYXlzKHZhbDEsIHZhbDIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhcmVTaW1pbGFyVHlwZWRBcnJheXModmFsMSwgdmFsMikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIEJ1ZmZlci5jb21wYXJlIHJldHVybnMgdHJ1ZSwgc28gdmFsMS5sZW5ndGggPT09IHZhbDIubGVuZ3RoLiBJZiB0aGV5IGJvdGhcbiAgICAvLyBvbmx5IGNvbnRhaW4gbnVtZXJpYyBrZXlzLCB3ZSBkb24ndCBuZWVkIHRvIGV4YW0gZnVydGhlciB0aGFuIGNoZWNraW5nXG4gICAgLy8gdGhlIHN5bWJvbHMuXG5cblxuICAgIHZhciBfa2V5cyA9IGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWwxLCBPTkxZX0VOVU1FUkFCTEUpO1xuXG4gICAgdmFyIF9rZXlzMiA9IGdldE93bk5vbkluZGV4UHJvcGVydGllcyh2YWwyLCBPTkxZX0VOVU1FUkFCTEUpO1xuXG4gICAgaWYgKF9rZXlzLmxlbmd0aCAhPT0gX2tleXMyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrTm9JdGVyYXRvciwgX2tleXMpO1xuICB9IGVsc2UgaWYgKGlzU2V0KHZhbDEpKSB7XG4gICAgaWYgKCFpc1NldCh2YWwyKSB8fCB2YWwxLnNpemUgIT09IHZhbDIuc2l6ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrSXNTZXQpO1xuICB9IGVsc2UgaWYgKGlzTWFwKHZhbDEpKSB7XG4gICAgaWYgKCFpc01hcCh2YWwyKSB8fCB2YWwxLnNpemUgIT09IHZhbDIuc2l6ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrSXNNYXApO1xuICB9IGVsc2UgaWYgKGlzQW55QXJyYXlCdWZmZXIodmFsMSkpIHtcbiAgICBpZiAoIWFyZUVxdWFsQXJyYXlCdWZmZXJzKHZhbDEsIHZhbDIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzQm94ZWRQcmltaXRpdmUodmFsMSkgJiYgIWlzRXF1YWxCb3hlZFByaW1pdGl2ZSh2YWwxLCB2YWwyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBrZXlDaGVjayh2YWwxLCB2YWwyLCBzdHJpY3QsIG1lbW9zLCBrTm9JdGVyYXRvcik7XG59XG5cbmZ1bmN0aW9uIGdldEVudW1lcmFibGVzKHZhbCwga2V5cykge1xuICByZXR1cm4ga2V5cy5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUodmFsLCBrKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGtleUNoZWNrKHZhbDEsIHZhbDIsIHN0cmljdCwgbWVtb3MsIGl0ZXJhdGlvblR5cGUsIGFLZXlzKSB7XG4gIC8vIEZvciBhbGwgcmVtYWluaW5nIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5LCBvYmplY3RzIGFuZCBNYXBzLFxuICAvLyBlcXVpdmFsZW5jZSBpcyBkZXRlcm1pbmVkIGJ5IGhhdmluZzpcbiAgLy8gYSkgVGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIGVudW1lcmFibGUgcHJvcGVydGllc1xuICAvLyBiKSBUaGUgc2FtZSBzZXQgb2Yga2V5cy9pbmRleGVzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpXG4gIC8vIGMpIEVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleS9pbmRleFxuICAvLyBkKSBGb3IgU2V0cyBhbmQgTWFwcywgZXF1YWwgY29udGVudHNcbiAgLy8gTm90ZTogdGhpcyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDUpIHtcbiAgICBhS2V5cyA9IE9iamVjdC5rZXlzKHZhbDEpO1xuICAgIHZhciBiS2V5cyA9IE9iamVjdC5rZXlzKHZhbDIpOyAvLyBUaGUgcGFpciBtdXN0IGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMuXG5cbiAgICBpZiAoYUtleXMubGVuZ3RoICE9PSBiS2V5cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gLy8gQ2hlYXAga2V5IHRlc3RcblxuXG4gIHZhciBpID0gMDtcblxuICBmb3IgKDsgaSA8IGFLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2YWwyLCBhS2V5c1tpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RyaWN0ICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDUpIHtcbiAgICB2YXIgc3ltYm9sS2V5c0EgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsMSk7XG5cbiAgICBpZiAoc3ltYm9sS2V5c0EubGVuZ3RoICE9PSAwKSB7XG4gICAgICB2YXIgY291bnQgPSAwO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc3ltYm9sS2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IHN5bWJvbEtleXNBW2ldO1xuXG4gICAgICAgIGlmIChwcm9wZXJ0eUlzRW51bWVyYWJsZSh2YWwxLCBrZXkpKSB7XG4gICAgICAgICAgaWYgKCFwcm9wZXJ0eUlzRW51bWVyYWJsZSh2YWwyLCBrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYUtleXMucHVzaChrZXkpO1xuICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlJc0VudW1lcmFibGUodmFsMiwga2V5KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgc3ltYm9sS2V5c0IgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsMik7XG5cbiAgICAgIGlmIChzeW1ib2xLZXlzQS5sZW5ndGggIT09IHN5bWJvbEtleXNCLmxlbmd0aCAmJiBnZXRFbnVtZXJhYmxlcyh2YWwyLCBzeW1ib2xLZXlzQikubGVuZ3RoICE9PSBjb3VudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfc3ltYm9sS2V5c0IgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsMik7XG5cbiAgICAgIGlmIChfc3ltYm9sS2V5c0IubGVuZ3RoICE9PSAwICYmIGdldEVudW1lcmFibGVzKHZhbDIsIF9zeW1ib2xLZXlzQikubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoYUtleXMubGVuZ3RoID09PSAwICYmIChpdGVyYXRpb25UeXBlID09PSBrTm9JdGVyYXRvciB8fCBpdGVyYXRpb25UeXBlID09PSBrSXNBcnJheSAmJiB2YWwxLmxlbmd0aCA9PT0gMCB8fCB2YWwxLnNpemUgPT09IDApKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gVXNlIG1lbW9zIHRvIGhhbmRsZSBjeWNsZXMuXG5cblxuICBpZiAobWVtb3MgPT09IHVuZGVmaW5lZCkge1xuICAgIG1lbW9zID0ge1xuICAgICAgdmFsMTogbmV3IE1hcCgpLFxuICAgICAgdmFsMjogbmV3IE1hcCgpLFxuICAgICAgcG9zaXRpb246IDBcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIFdlIHByZXZlbnQgdXAgdG8gdHdvIG1hcC5oYXMoeCkgY2FsbHMgYnkgZGlyZWN0bHkgcmV0cmlldmluZyB0aGUgdmFsdWVcbiAgICAvLyBhbmQgY2hlY2tpbmcgZm9yIHVuZGVmaW5lZC4gVGhlIG1hcCBjYW4gb25seSBjb250YWluIG51bWJlcnMsIHNvIGl0IGlzXG4gICAgLy8gc2FmZSB0byBjaGVjayBmb3IgdW5kZWZpbmVkIG9ubHkuXG4gICAgdmFyIHZhbDJNZW1vQSA9IG1lbW9zLnZhbDEuZ2V0KHZhbDEpO1xuXG4gICAgaWYgKHZhbDJNZW1vQSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgdmFsMk1lbW9CID0gbWVtb3MudmFsMi5nZXQodmFsMik7XG5cbiAgICAgIGlmICh2YWwyTWVtb0IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdmFsMk1lbW9BID09PSB2YWwyTWVtb0I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWVtb3MucG9zaXRpb24rKztcbiAgfVxuXG4gIG1lbW9zLnZhbDEuc2V0KHZhbDEsIG1lbW9zLnBvc2l0aW9uKTtcbiAgbWVtb3MudmFsMi5zZXQodmFsMiwgbWVtb3MucG9zaXRpb24pO1xuICB2YXIgYXJlRXEgPSBvYmpFcXVpdih2YWwxLCB2YWwyLCBzdHJpY3QsIGFLZXlzLCBtZW1vcywgaXRlcmF0aW9uVHlwZSk7XG4gIG1lbW9zLnZhbDEuZGVsZXRlKHZhbDEpO1xuICBtZW1vcy52YWwyLmRlbGV0ZSh2YWwyKTtcbiAgcmV0dXJuIGFyZUVxO1xufVxuXG5mdW5jdGlvbiBzZXRIYXNFcXVhbEVsZW1lbnQoc2V0LCB2YWwxLCBzdHJpY3QsIG1lbW8pIHtcbiAgLy8gR28gbG9va2luZy5cbiAgdmFyIHNldFZhbHVlcyA9IGFycmF5RnJvbVNldChzZXQpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0VmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHZhbDIgPSBzZXRWYWx1ZXNbaV07XG5cbiAgICBpZiAoaW5uZXJEZWVwRXF1YWwodmFsMSwgdmFsMiwgc3RyaWN0LCBtZW1vKSkge1xuICAgICAgLy8gUmVtb3ZlIHRoZSBtYXRjaGluZyBlbGVtZW50IHRvIG1ha2Ugc3VyZSB3ZSBkbyBub3QgY2hlY2sgdGhhdCBhZ2Fpbi5cbiAgICAgIHNldC5kZWxldGUodmFsMik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59IC8vIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L0VxdWFsaXR5X2NvbXBhcmlzb25zX2FuZF9zYW1lbmVzcyNMb29zZV9lcXVhbGl0eV91c2luZ1xuLy8gU2FkbHkgaXQgaXMgbm90IHBvc3NpYmxlIHRvIGRldGVjdCBjb3JyZXNwb25kaW5nIHZhbHVlcyBwcm9wZXJseSBpbiBjYXNlIHRoZVxuLy8gdHlwZSBpcyBhIHN0cmluZywgbnVtYmVyLCBiaWdpbnQgb3IgYm9vbGVhbi4gVGhlIHJlYXNvbiBpcyB0aGF0IHRob3NlIHZhbHVlc1xuLy8gY2FuIG1hdGNoIGxvdHMgb2YgZGlmZmVyZW50IHN0cmluZyB2YWx1ZXMgKGUuZy4sIDFuID09ICcrMDAwMDEnKS5cblxuXG5mdW5jdGlvbiBmaW5kTG9vc2VNYXRjaGluZ1ByaW1pdGl2ZXMocHJpbSkge1xuICBzd2l0Y2ggKF90eXBlb2YocHJpbSkpIHtcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgLy8gT25seSBwYXNzIGluIG51bGwgYXMgb2JqZWN0IVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcHJpbSA9ICtwcmltO1xuICAgIC8vIExvb3NlIGVxdWFsIGVudHJpZXMgZXhpc3Qgb25seSBpZiB0aGUgc3RyaW5nIGlzIHBvc3NpYmxlIHRvIGNvbnZlcnQgdG9cbiAgICAvLyBhIHJlZ3VsYXIgbnVtYmVyIGFuZCBub3QgTmFOLlxuICAgIC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGlmIChudW1iZXJJc05hTihwcmltKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBzZXRNaWdodEhhdmVMb29zZVByaW0oYSwgYiwgcHJpbSkge1xuICB2YXIgYWx0VmFsdWUgPSBmaW5kTG9vc2VNYXRjaGluZ1ByaW1pdGl2ZXMocHJpbSk7XG4gIGlmIChhbHRWYWx1ZSAhPSBudWxsKSByZXR1cm4gYWx0VmFsdWU7XG4gIHJldHVybiBiLmhhcyhhbHRWYWx1ZSkgJiYgIWEuaGFzKGFsdFZhbHVlKTtcbn1cblxuZnVuY3Rpb24gbWFwTWlnaHRIYXZlTG9vc2VQcmltKGEsIGIsIHByaW0sIGl0ZW0sIG1lbW8pIHtcbiAgdmFyIGFsdFZhbHVlID0gZmluZExvb3NlTWF0Y2hpbmdQcmltaXRpdmVzKHByaW0pO1xuXG4gIGlmIChhbHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIGFsdFZhbHVlO1xuICB9XG5cbiAgdmFyIGN1ckIgPSBiLmdldChhbHRWYWx1ZSk7XG5cbiAgaWYgKGN1ckIgPT09IHVuZGVmaW5lZCAmJiAhYi5oYXMoYWx0VmFsdWUpIHx8ICFpbm5lckRlZXBFcXVhbChpdGVtLCBjdXJCLCBmYWxzZSwgbWVtbykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gIWEuaGFzKGFsdFZhbHVlKSAmJiBpbm5lckRlZXBFcXVhbChpdGVtLCBjdXJCLCBmYWxzZSwgbWVtbyk7XG59XG5cbmZ1bmN0aW9uIHNldEVxdWl2KGEsIGIsIHN0cmljdCwgbWVtbykge1xuICAvLyBUaGlzIGlzIGEgbGF6aWx5IGluaXRpYXRlZCBTZXQgb2YgZW50cmllcyB3aGljaCBoYXZlIHRvIGJlIGNvbXBhcmVkXG4gIC8vIHBhaXJ3aXNlLlxuICB2YXIgc2V0ID0gbnVsbDtcbiAgdmFyIGFWYWx1ZXMgPSBhcnJheUZyb21TZXQoYSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHZhbCA9IGFWYWx1ZXNbaV07IC8vIE5vdGU6IENoZWNraW5nIGZvciB0aGUgb2JqZWN0cyBmaXJzdCBpbXByb3ZlcyB0aGUgcGVyZm9ybWFuY2UgZm9yIG9iamVjdFxuICAgIC8vIGhlYXZ5IHNldHMgYnV0IGl0IGlzIGEgbWlub3Igc2xvdyBkb3duIGZvciBwcmltaXRpdmVzLiBBcyB0aGV5IGFyZSBmYXN0XG4gICAgLy8gdG8gY2hlY2sgdGhpcyBpbXByb3ZlcyB0aGUgd29yc3QgY2FzZSBzY2VuYXJpbyBpbnN0ZWFkLlxuXG4gICAgaWYgKF90eXBlb2YodmFsKSA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgICBpZiAoc2V0ID09PSBudWxsKSB7XG4gICAgICAgIHNldCA9IG5ldyBTZXQoKTtcbiAgICAgIH0gLy8gSWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBkb2Vzbid0IGV4aXN0IGluIHRoZSBzZWNvbmQgc2V0IGl0cyBhbiBub3QgbnVsbFxuICAgICAgLy8gb2JqZWN0IChvciBub24gc3RyaWN0IG9ubHk6IGEgbm90IG1hdGNoaW5nIHByaW1pdGl2ZSkgd2UnbGwgbmVlZCB0byBnb1xuICAgICAgLy8gaHVudGluZyBmb3Igc29tZXRoaW5nIHRoYXRzIGRlZXAtKHN0cmljdC0pZXF1YWwgdG8gaXQuIFRvIG1ha2UgdGhpc1xuICAgICAgLy8gTyhuIGxvZyBuKSBjb21wbGV4aXR5IHdlIGhhdmUgdG8gY29weSB0aGVzZSB2YWx1ZXMgaW4gYSBuZXcgc2V0IGZpcnN0LlxuXG5cbiAgICAgIHNldC5hZGQodmFsKTtcbiAgICB9IGVsc2UgaWYgKCFiLmhhcyh2YWwpKSB7XG4gICAgICBpZiAoc3RyaWN0KSByZXR1cm4gZmFsc2U7IC8vIEZhc3QgcGF0aCB0byBkZXRlY3QgbWlzc2luZyBzdHJpbmcsIHN5bWJvbCwgdW5kZWZpbmVkIGFuZCBudWxsIHZhbHVlcy5cblxuICAgICAgaWYgKCFzZXRNaWdodEhhdmVMb29zZVByaW0oYSwgYiwgdmFsKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZXQgPT09IG51bGwpIHtcbiAgICAgICAgc2V0ID0gbmV3IFNldCgpO1xuICAgICAgfVxuXG4gICAgICBzZXQuYWRkKHZhbCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHNldCAhPT0gbnVsbCkge1xuICAgIHZhciBiVmFsdWVzID0gYXJyYXlGcm9tU2V0KGIpO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGJWYWx1ZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX3ZhbCA9IGJWYWx1ZXNbX2ldOyAvLyBXZSBoYXZlIHRvIGNoZWNrIGlmIGEgcHJpbWl0aXZlIHZhbHVlIGlzIGFscmVhZHlcbiAgICAgIC8vIG1hdGNoaW5nIGFuZCBvbmx5IGlmIGl0J3Mgbm90LCBnbyBodW50aW5nIGZvciBpdC5cblxuICAgICAgaWYgKF90eXBlb2YoX3ZhbCkgPT09ICdvYmplY3QnICYmIF92YWwgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKCFzZXRIYXNFcXVhbEVsZW1lbnQoc2V0LCBfdmFsLCBzdHJpY3QsIG1lbW8pKSByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgIWEuaGFzKF92YWwpICYmICFzZXRIYXNFcXVhbEVsZW1lbnQoc2V0LCBfdmFsLCBzdHJpY3QsIG1lbW8pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2V0LnNpemUgPT09IDA7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gbWFwSGFzRXF1YWxFbnRyeShzZXQsIG1hcCwga2V5MSwgaXRlbTEsIHN0cmljdCwgbWVtbykge1xuICAvLyBUbyBiZSBhYmxlIHRvIGhhbmRsZSBjYXNlcyBsaWtlOlxuICAvLyAgIE1hcChbW3t9LCAnYSddLCBbe30sICdiJ11dKSB2cyBNYXAoW1t7fSwgJ2InXSwgW3t9LCAnYSddXSlcbiAgLy8gLi4uIHdlIG5lZWQgdG8gY29uc2lkZXIgKmFsbCogbWF0Y2hpbmcga2V5cywgbm90IGp1c3QgdGhlIGZpcnN0IHdlIGZpbmQuXG4gIHZhciBzZXRWYWx1ZXMgPSBhcnJheUZyb21TZXQoc2V0KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNldFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkyID0gc2V0VmFsdWVzW2ldO1xuXG4gICAgaWYgKGlubmVyRGVlcEVxdWFsKGtleTEsIGtleTIsIHN0cmljdCwgbWVtbykgJiYgaW5uZXJEZWVwRXF1YWwoaXRlbTEsIG1hcC5nZXQoa2V5MiksIHN0cmljdCwgbWVtbykpIHtcbiAgICAgIHNldC5kZWxldGUoa2V5Mik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG1hcEVxdWl2KGEsIGIsIHN0cmljdCwgbWVtbykge1xuICB2YXIgc2V0ID0gbnVsbDtcbiAgdmFyIGFFbnRyaWVzID0gYXJyYXlGcm9tTWFwKGEpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYUVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgX2FFbnRyaWVzJGkgPSBfc2xpY2VkVG9BcnJheShhRW50cmllc1tpXSwgMiksXG4gICAgICAgIGtleSA9IF9hRW50cmllcyRpWzBdLFxuICAgICAgICBpdGVtMSA9IF9hRW50cmllcyRpWzFdO1xuXG4gICAgaWYgKF90eXBlb2Yoa2V5KSA9PT0gJ29iamVjdCcgJiYga2V5ICE9PSBudWxsKSB7XG4gICAgICBpZiAoc2V0ID09PSBudWxsKSB7XG4gICAgICAgIHNldCA9IG5ldyBTZXQoKTtcbiAgICAgIH1cblxuICAgICAgc2V0LmFkZChrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCeSBkaXJlY3RseSByZXRyaWV2aW5nIHRoZSB2YWx1ZSB3ZSBwcmV2ZW50IGFub3RoZXIgYi5oYXMoa2V5KSBjaGVjayBpblxuICAgICAgLy8gYWxtb3N0IGFsbCBwb3NzaWJsZSBjYXNlcy5cbiAgICAgIHZhciBpdGVtMiA9IGIuZ2V0KGtleSk7XG5cbiAgICAgIGlmIChpdGVtMiA9PT0gdW5kZWZpbmVkICYmICFiLmhhcyhrZXkpIHx8ICFpbm5lckRlZXBFcXVhbChpdGVtMSwgaXRlbTIsIHN0cmljdCwgbWVtbykpIHtcbiAgICAgICAgaWYgKHN0cmljdCkgcmV0dXJuIGZhbHNlOyAvLyBGYXN0IHBhdGggdG8gZGV0ZWN0IG1pc3Npbmcgc3RyaW5nLCBzeW1ib2wsIHVuZGVmaW5lZCBhbmQgbnVsbFxuICAgICAgICAvLyBrZXlzLlxuXG4gICAgICAgIGlmICghbWFwTWlnaHRIYXZlTG9vc2VQcmltKGEsIGIsIGtleSwgaXRlbTEsIG1lbW8pKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgaWYgKHNldCA9PT0gbnVsbCkge1xuICAgICAgICAgIHNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldC5hZGQoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoc2V0ICE9PSBudWxsKSB7XG4gICAgdmFyIGJFbnRyaWVzID0gYXJyYXlGcm9tTWFwKGIpO1xuXG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgYkVudHJpZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgdmFyIF9iRW50cmllcyRfaSA9IF9zbGljZWRUb0FycmF5KGJFbnRyaWVzW19pMl0sIDIpLFxuICAgICAgICAgIGtleSA9IF9iRW50cmllcyRfaVswXSxcbiAgICAgICAgICBpdGVtID0gX2JFbnRyaWVzJF9pWzFdO1xuXG4gICAgICBpZiAoX3R5cGVvZihrZXkpID09PSAnb2JqZWN0JyAmJiBrZXkgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKCFtYXBIYXNFcXVhbEVudHJ5KHNldCwgYSwga2V5LCBpdGVtLCBzdHJpY3QsIG1lbW8pKSByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgKCFhLmhhcyhrZXkpIHx8ICFpbm5lckRlZXBFcXVhbChhLmdldChrZXkpLCBpdGVtLCBmYWxzZSwgbWVtbykpICYmICFtYXBIYXNFcXVhbEVudHJ5KHNldCwgYSwga2V5LCBpdGVtLCBmYWxzZSwgbWVtbykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzZXQuc2l6ZSA9PT0gMDtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiLCBzdHJpY3QsIGtleXMsIG1lbW9zLCBpdGVyYXRpb25UeXBlKSB7XG4gIC8vIFNldHMgYW5kIG1hcHMgZG9uJ3QgaGF2ZSB0aGVpciBlbnRyaWVzIGFjY2Vzc2libGUgdmlhIG5vcm1hbCBvYmplY3RcbiAgLy8gcHJvcGVydGllcy5cbiAgdmFyIGkgPSAwO1xuXG4gIGlmIChpdGVyYXRpb25UeXBlID09PSBrSXNTZXQpIHtcbiAgICBpZiAoIXNldEVxdWl2KGEsIGIsIHN0cmljdCwgbWVtb3MpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKGl0ZXJhdGlvblR5cGUgPT09IGtJc01hcCkge1xuICAgIGlmICghbWFwRXF1aXYoYSwgYiwgc3RyaWN0LCBtZW1vcykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXRlcmF0aW9uVHlwZSA9PT0ga0lzQXJyYXkpIHtcbiAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShhLCBpKSkge1xuICAgICAgICBpZiAoIWhhc093blByb3BlcnR5KGIsIGkpIHx8ICFpbm5lckRlZXBFcXVhbChhW2ldLCBiW2ldLCBzdHJpY3QsIG1lbW9zKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChoYXNPd25Qcm9wZXJ0eShiLCBpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBcnJheSBpcyBzcGFyc2UuXG4gICAgICAgIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKGEpO1xuXG4gICAgICAgIGZvciAoOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIga2V5ID0ga2V5c0FbaV07XG5cbiAgICAgICAgICBpZiAoIWhhc093blByb3BlcnR5KGIsIGtleSkgfHwgIWlubmVyRGVlcEVxdWFsKGFba2V5XSwgYltrZXldLCBzdHJpY3QsIG1lbW9zKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrZXlzQS5sZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBUaGUgcGFpciBtdXN0IGhhdmUgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LlxuICAvLyBQb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0OlxuXG5cbiAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgX2tleSA9IGtleXNbaV07XG5cbiAgICBpZiAoIWlubmVyRGVlcEVxdWFsKGFbX2tleV0sIGJbX2tleV0sIHN0cmljdCwgbWVtb3MpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzRGVlcEVxdWFsKHZhbDEsIHZhbDIpIHtcbiAgcmV0dXJuIGlubmVyRGVlcEVxdWFsKHZhbDEsIHZhbDIsIGtMb29zZSk7XG59XG5cbmZ1bmN0aW9uIGlzRGVlcFN0cmljdEVxdWFsKHZhbDEsIHZhbDIpIHtcbiAgcmV0dXJuIGlubmVyRGVlcEVxdWFsKHZhbDEsIHZhbDIsIGtTdHJpY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNEZWVwRXF1YWw6IGlzRGVlcEVxdWFsLFxuICBpc0RlZXBTdHJpY3RFcXVhbDogaXNEZWVwU3RyaWN0RXF1YWxcbn07XG5cbi8qKiovIH0pLFxuXG4vKioqLyA5ODE4OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgR2V0SW50cmluc2ljID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MjgpO1xuXG52YXIgY2FsbEJpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0OTgpO1xuXG52YXIgJGluZGV4T2YgPSBjYWxsQmluZChHZXRJbnRyaW5zaWMoJ1N0cmluZy5wcm90b3R5cGUuaW5kZXhPZicpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQm91bmRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdHZhciBpbnRyaW5zaWMgPSBHZXRJbnRyaW5zaWMobmFtZSwgISFhbGxvd01pc3NpbmcpO1xuXHRpZiAodHlwZW9mIGludHJpbnNpYyA9PT0gJ2Z1bmN0aW9uJyAmJiAkaW5kZXhPZihuYW1lLCAnLnByb3RvdHlwZS4nKSA+IC0xKSB7XG5cdFx0cmV0dXJuIGNhbGxCaW5kKGludHJpbnNpYyk7XG5cdH1cblx0cmV0dXJuIGludHJpbnNpYztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDg0OTg6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBiaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MTM4KTtcbnZhciBHZXRJbnRyaW5zaWMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyOCk7XG52YXIgc2V0RnVuY3Rpb25MZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxMDgpO1xuXG52YXIgJFR5cGVFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oMzQ2OCk7XG52YXIgJGFwcGx5ID0gR2V0SW50cmluc2ljKCclRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5JScpO1xudmFyICRjYWxsID0gR2V0SW50cmluc2ljKCclRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwlJyk7XG52YXIgJHJlZmxlY3RBcHBseSA9IEdldEludHJpbnNpYygnJVJlZmxlY3QuYXBwbHklJywgdHJ1ZSkgfHwgYmluZC5jYWxsKCRjYWxsLCAkYXBwbHkpO1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OTQwKTtcbnZhciAkbWF4ID0gR2V0SW50cmluc2ljKCclTWF0aC5tYXglJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2FsbEJpbmQob3JpZ2luYWxGdW5jdGlvbikge1xuXHRpZiAodHlwZW9mIG9yaWdpbmFsRnVuY3Rpb24gIT09ICdmdW5jdGlvbicpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYSBmdW5jdGlvbiBpcyByZXF1aXJlZCcpO1xuXHR9XG5cdHZhciBmdW5jID0gJHJlZmxlY3RBcHBseShiaW5kLCAkY2FsbCwgYXJndW1lbnRzKTtcblx0cmV0dXJuIHNldEZ1bmN0aW9uTGVuZ3RoKFxuXHRcdGZ1bmMsXG5cdFx0MSArICRtYXgoMCwgb3JpZ2luYWxGdW5jdGlvbi5sZW5ndGggLSAoYXJndW1lbnRzLmxlbmd0aCAtIDEpKSxcblx0XHR0cnVlXG5cdCk7XG59O1xuXG52YXIgYXBwbHlCaW5kID0gZnVuY3Rpb24gYXBwbHlCaW5kKCkge1xuXHRyZXR1cm4gJHJlZmxlY3RBcHBseShiaW5kLCAkYXBwbHksIGFyZ3VtZW50cyk7XG59O1xuXG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdCRkZWZpbmVQcm9wZXJ0eShtb2R1bGUuZXhwb3J0cywgJ2FwcGx5JywgeyB2YWx1ZTogYXBwbHlCaW5kIH0pO1xufSBlbHNlIHtcblx0bW9kdWxlLmV4cG9ydHMuYXBwbHkgPSBhcHBseUJpbmQ7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQzNjQ6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8qZ2xvYmFsIHdpbmRvdywgZ2xvYmFsKi9cbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2ODI3KVxudmFyIGFzc2VydCA9IF9fd2VicGFja19yZXF1aXJlX18oNjA5MylcbmZ1bmN0aW9uIG5vdygpIHsgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpIH1cblxudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlXG52YXIgY29uc29sZVxudmFyIHRpbWVzID0ge31cblxuaWYgKHR5cGVvZiBfX3dlYnBhY2tfcmVxdWlyZV9fLmcgIT09IFwidW5kZWZpbmVkXCIgJiYgX193ZWJwYWNrX3JlcXVpcmVfXy5nLmNvbnNvbGUpIHtcbiAgICBjb25zb2xlID0gX193ZWJwYWNrX3JlcXVpcmVfXy5nLmNvbnNvbGVcbn0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuY29uc29sZSkge1xuICAgIGNvbnNvbGUgPSB3aW5kb3cuY29uc29sZVxufSBlbHNlIHtcbiAgICBjb25zb2xlID0ge31cbn1cblxudmFyIGZ1bmN0aW9ucyA9IFtcbiAgICBbbG9nLCBcImxvZ1wiXSxcbiAgICBbaW5mbywgXCJpbmZvXCJdLFxuICAgIFt3YXJuLCBcIndhcm5cIl0sXG4gICAgW2Vycm9yLCBcImVycm9yXCJdLFxuICAgIFt0aW1lLCBcInRpbWVcIl0sXG4gICAgW3RpbWVFbmQsIFwidGltZUVuZFwiXSxcbiAgICBbdHJhY2UsIFwidHJhY2VcIl0sXG4gICAgW2RpciwgXCJkaXJcIl0sXG4gICAgW2NvbnNvbGVBc3NlcnQsIFwiYXNzZXJ0XCJdXG5dXG5cbmZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHR1cGxlID0gZnVuY3Rpb25zW2ldXG4gICAgdmFyIGYgPSB0dXBsZVswXVxuICAgIHZhciBuYW1lID0gdHVwbGVbMV1cblxuICAgIGlmICghY29uc29sZVtuYW1lXSkge1xuICAgICAgICBjb25zb2xlW25hbWVdID0gZlxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25zb2xlXG5cbmZ1bmN0aW9uIGxvZygpIHt9XG5cbmZ1bmN0aW9uIGluZm8oKSB7XG4gICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxufVxuXG5mdW5jdGlvbiB3YXJuKCkge1xuICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cylcbn1cblxuZnVuY3Rpb24gZXJyb3IoKSB7XG4gICAgY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cylcbn1cblxuZnVuY3Rpb24gdGltZShsYWJlbCkge1xuICAgIHRpbWVzW2xhYmVsXSA9IG5vdygpXG59XG5cbmZ1bmN0aW9uIHRpbWVFbmQobGFiZWwpIHtcbiAgICB2YXIgdGltZSA9IHRpbWVzW2xhYmVsXVxuICAgIGlmICghdGltZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzdWNoIGxhYmVsOiBcIiArIGxhYmVsKVxuICAgIH1cblxuICAgIGRlbGV0ZSB0aW1lc1tsYWJlbF1cbiAgICB2YXIgZHVyYXRpb24gPSBub3coKSAtIHRpbWVcbiAgICBjb25zb2xlLmxvZyhsYWJlbCArIFwiOiBcIiArIGR1cmF0aW9uICsgXCJtc1wiKVxufVxuXG5mdW5jdGlvbiB0cmFjZSgpIHtcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKClcbiAgICBlcnIubmFtZSA9IFwiVHJhY2VcIlxuICAgIGVyci5tZXNzYWdlID0gdXRpbC5mb3JtYXQuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgIGNvbnNvbGUuZXJyb3IoZXJyLnN0YWNrKVxufVxuXG5mdW5jdGlvbiBkaXIob2JqZWN0KSB7XG4gICAgY29uc29sZS5sb2codXRpbC5pbnNwZWN0KG9iamVjdCkgKyBcIlxcblwiKVxufVxuXG5mdW5jdGlvbiBjb25zb2xlQXNzZXJ0KGV4cHJlc3Npb24pIHtcbiAgICBpZiAoIWV4cHJlc3Npb24pIHtcbiAgICAgICAgdmFyIGFyciA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuICAgICAgICBhc3NlcnQub2soZmFsc2UsIHV0aWwuZm9ybWF0LmFwcGx5KG51bGwsIGFycikpXG4gICAgfVxufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2ODY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5NDApO1xuXG52YXIgJFN5bnRheEVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NzMxKTtcbnZhciAkVHlwZUVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNDY4KTtcblxudmFyIGdvcGQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkzMzYpO1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZpbmVEYXRhUHJvcGVydHkoXG5cdG9iaixcblx0cHJvcGVydHksXG5cdHZhbHVlXG4pIHtcblx0aWYgKCFvYmogfHwgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmogIT09ICdmdW5jdGlvbicpKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2BvYmpgIG11c3QgYmUgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb25gJyk7XG5cdH1cblx0aWYgKHR5cGVvZiBwcm9wZXJ0eSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHByb3BlcnR5ICE9PSAnc3ltYm9sJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgcHJvcGVydHlgIG11c3QgYmUgYSBzdHJpbmcgb3IgYSBzeW1ib2xgJyk7XG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIHR5cGVvZiBhcmd1bWVudHNbM10gIT09ICdib29sZWFuJyAmJiBhcmd1bWVudHNbM10gIT09IG51bGwpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYG5vbkVudW1lcmFibGVgLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBhIGJvb2xlYW4gb3IgbnVsbCcpO1xuXHR9XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gNCAmJiB0eXBlb2YgYXJndW1lbnRzWzRdICE9PSAnYm9vbGVhbicgJiYgYXJndW1lbnRzWzRdICE9PSBudWxsKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2Bub25Xcml0YWJsZWAsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGEgYm9vbGVhbiBvciBudWxsJyk7XG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIHR5cGVvZiBhcmd1bWVudHNbNV0gIT09ICdib29sZWFuJyAmJiBhcmd1bWVudHNbNV0gIT09IG51bGwpIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYG5vbkNvbmZpZ3VyYWJsZWAsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGEgYm9vbGVhbiBvciBudWxsJyk7XG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiA2ICYmIHR5cGVvZiBhcmd1bWVudHNbNl0gIT09ICdib29sZWFuJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgbG9vc2VgLCBpZiBwcm92aWRlZCwgbXVzdCBiZSBhIGJvb2xlYW4nKTtcblx0fVxuXG5cdHZhciBub25FbnVtZXJhYmxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuXHR2YXIgbm9uV3JpdGFibGUgPSBhcmd1bWVudHMubGVuZ3RoID4gNCA/IGFyZ3VtZW50c1s0XSA6IG51bGw7XG5cdHZhciBub25Db25maWd1cmFibGUgPSBhcmd1bWVudHMubGVuZ3RoID4gNSA/IGFyZ3VtZW50c1s1XSA6IG51bGw7XG5cdHZhciBsb29zZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA2ID8gYXJndW1lbnRzWzZdIDogZmFsc2U7XG5cblx0LyogQHR5cGUge2ZhbHNlIHwgVHlwZWRQcm9wZXJ0eURlc2NyaXB0b3I8dW5rbm93bj59ICovXG5cdHZhciBkZXNjID0gISFnb3BkICYmIGdvcGQob2JqLCBwcm9wZXJ0eSk7XG5cblx0aWYgKCRkZWZpbmVQcm9wZXJ0eSkge1xuXHRcdCRkZWZpbmVQcm9wZXJ0eShvYmosIHByb3BlcnR5LCB7XG5cdFx0XHRjb25maWd1cmFibGU6IG5vbkNvbmZpZ3VyYWJsZSA9PT0gbnVsbCAmJiBkZXNjID8gZGVzYy5jb25maWd1cmFibGUgOiAhbm9uQ29uZmlndXJhYmxlLFxuXHRcdFx0ZW51bWVyYWJsZTogbm9uRW51bWVyYWJsZSA9PT0gbnVsbCAmJiBkZXNjID8gZGVzYy5lbnVtZXJhYmxlIDogIW5vbkVudW1lcmFibGUsXG5cdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHR3cml0YWJsZTogbm9uV3JpdGFibGUgPT09IG51bGwgJiYgZGVzYyA/IGRlc2Mud3JpdGFibGUgOiAhbm9uV3JpdGFibGVcblx0XHR9KTtcblx0fSBlbHNlIGlmIChsb29zZSB8fCAoIW5vbkVudW1lcmFibGUgJiYgIW5vbldyaXRhYmxlICYmICFub25Db25maWd1cmFibGUpKSB7XG5cdFx0Ly8gbXVzdCBmYWxsIGJhY2sgdG8gW1tTZXRdXSwgYW5kIHdhcyBub3QgZXhwbGljaXRseSBhc2tlZCB0byBtYWtlIG5vbi1lbnVtZXJhYmxlLCBub24td3JpdGFibGUsIG9yIG5vbi1jb25maWd1cmFibGVcblx0XHRvYmpbcHJvcGVydHldID0gdmFsdWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdUaGlzIGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgZGVmaW5pbmcgYSBwcm9wZXJ0eSBhcyBub24tY29uZmlndXJhYmxlLCBub24td3JpdGFibGUsIG9yIG5vbi1lbnVtZXJhYmxlLicpO1xuXHR9XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxODU3OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIga2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oOTIyOCk7XG52YXIgaGFzU3ltYm9scyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbCgnZm9vJykgPT09ICdzeW1ib2wnO1xuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGNvbmNhdCA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQ7XG52YXIgb3JpZ0RlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIChmbikge1xuXHRyZXR1cm4gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nICYmIHRvU3RyLmNhbGwoZm4pID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxudmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcyMzkpKCk7XG5cbnZhciBzdXBwb3J0c0Rlc2NyaXB0b3JzID0gb3JpZ0RlZmluZVByb3BlcnR5ICYmIGhhc1Byb3BlcnR5RGVzY3JpcHRvcnM7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIHZhbHVlLCBwcmVkaWNhdGUpIHtcblx0aWYgKG5hbWUgaW4gb2JqZWN0KSB7XG5cdFx0aWYgKHByZWRpY2F0ZSA9PT0gdHJ1ZSkge1xuXHRcdFx0aWYgKG9iamVjdFtuYW1lXSA9PT0gdmFsdWUpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoIWlzRnVuY3Rpb24ocHJlZGljYXRlKSB8fCAhcHJlZGljYXRlKCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdH1cblx0aWYgKHN1cHBvcnRzRGVzY3JpcHRvcnMpIHtcblx0XHRvcmlnRGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB7XG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdHdyaXRhYmxlOiB0cnVlXG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0b2JqZWN0W25hbWVdID0gdmFsdWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cblx0fVxufTtcblxudmFyIGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAob2JqZWN0LCBtYXApIHtcblx0dmFyIHByZWRpY2F0ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXHR2YXIgcHJvcHMgPSBrZXlzKG1hcCk7XG5cdGlmIChoYXNTeW1ib2xzKSB7XG5cdFx0cHJvcHMgPSBjb25jYXQuY2FsbChwcm9wcywgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhtYXApKTtcblx0fVxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0ZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wc1tpXSwgbWFwW3Byb3BzW2ldXSwgcHJlZGljYXRlc1twcm9wc1tpXV0pO1xuXHR9XG59O1xuXG5kZWZpbmVQcm9wZXJ0aWVzLnN1cHBvcnRzRGVzY3JpcHRvcnMgPSAhIXN1cHBvcnRzRGVzY3JpcHRvcnM7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lUHJvcGVydGllcztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDk0MDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIEdldEludHJpbnNpYyA9IF9fd2VicGFja19yZXF1aXJlX18oNTI4KTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4nKX0gKi9cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZGVmaW5lUHJvcGVydHklJywgdHJ1ZSkgfHwgZmFsc2U7XG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdHRyeSB7XG5cdFx0JGRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgdmFsdWU6IDEgfSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBkZWZpbmVQcm9wZXJ0eVxuXHRcdCRkZWZpbmVQcm9wZXJ0eSA9IGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gJGRlZmluZVByb3BlcnR5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2NzI5OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vZXZhbCcpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBFdmFsRXJyb3I7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDk4Mzg6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKiogQHR5cGUge2ltcG9ydCgnLicpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBFcnJvcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTE1NTpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL3JhbmdlJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmdlRXJyb3I7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQ5NDM6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9yZWYnKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gUmVmZXJlbmNlRXJyb3I7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDU3MzE6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9zeW50YXgnKX0gKi9cbm1vZHVsZS5leHBvcnRzID0gU3ludGF4RXJyb3I7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM0Njg6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKiogQHR5cGUge2ltcG9ydCgnLi90eXBlJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IFR5cGVFcnJvcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjE0MDpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL3VyaScpfSAqL1xubW9kdWxlLmV4cG9ydHMgPSBVUklFcnJvcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzA0Njpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb2RlIHJlZmFjdG9yZWQgZnJvbSBNb3ppbGxhIERldmVsb3BlciBOZXR3b3JrOlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2Fzc2lnblxuICovXG5cblxuXG5mdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBmaXJzdFNvdXJjZSkge1xuICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgZmlyc3QgYXJndW1lbnQgdG8gb2JqZWN0Jyk7XG4gIH1cblxuICB2YXIgdG8gPSBPYmplY3QodGFyZ2V0KTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbmV4dFNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICBpZiAobmV4dFNvdXJjZSA9PT0gdW5kZWZpbmVkIHx8IG5leHRTb3VyY2UgPT09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBrZXlzQXJyYXkgPSBPYmplY3Qua2V5cyhPYmplY3QobmV4dFNvdXJjZSkpO1xuICAgIGZvciAodmFyIG5leHRJbmRleCA9IDAsIGxlbiA9IGtleXNBcnJheS5sZW5ndGg7IG5leHRJbmRleCA8IGxlbjsgbmV4dEluZGV4KyspIHtcbiAgICAgIHZhciBuZXh0S2V5ID0ga2V5c0FycmF5W25leHRJbmRleF07XG4gICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobmV4dFNvdXJjZSwgbmV4dEtleSk7XG4gICAgICBpZiAoZGVzYyAhPT0gdW5kZWZpbmVkICYmIGRlc2MuZW51bWVyYWJsZSkge1xuICAgICAgICB0b1tuZXh0S2V5XSA9IG5leHRTb3VyY2VbbmV4dEtleV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0bztcbn1cblxuZnVuY3Rpb24gcG9seWZpbGwoKSB7XG4gIGlmICghT2JqZWN0LmFzc2lnbikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3QsICdhc3NpZ24nLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGFzc2lnblxuICAgIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhc3NpZ246IGFzc2lnbixcbiAgcG9seWZpbGw6IHBvbHlmaWxsXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3MDU6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NjE3KTtcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBmb3JFYWNoQXJyYXkgPSBmdW5jdGlvbiBmb3JFYWNoQXJyYXkoYXJyYXksIGl0ZXJhdG9yLCByZWNlaXZlcikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgaSkpIHtcbiAgICAgICAgICAgIGlmIChyZWNlaXZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IoYXJyYXlbaV0sIGksIGFycmF5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChyZWNlaXZlciwgYXJyYXlbaV0sIGksIGFycmF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBmb3JFYWNoU3RyaW5nID0gZnVuY3Rpb24gZm9yRWFjaFN0cmluZyhzdHJpbmcsIGl0ZXJhdG9yLCByZWNlaXZlcikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLy8gbm8gc3VjaCB0aGluZyBhcyBhIHNwYXJzZSBzdHJpbmcuXG4gICAgICAgIGlmIChyZWNlaXZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihzdHJpbmcuY2hhckF0KGkpLCBpLCBzdHJpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChyZWNlaXZlciwgc3RyaW5nLmNoYXJBdChpKSwgaSwgc3RyaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBmb3JFYWNoT2JqZWN0ID0gZnVuY3Rpb24gZm9yRWFjaE9iamVjdChvYmplY3QsIGl0ZXJhdG9yLCByZWNlaXZlcikge1xuICAgIGZvciAodmFyIGsgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgaykpIHtcbiAgICAgICAgICAgIGlmIChyZWNlaXZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3Iob2JqZWN0W2tdLCBrLCBvYmplY3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5jYWxsKHJlY2VpdmVyLCBvYmplY3Rba10sIGssIG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2gobGlzdCwgaXRlcmF0b3IsIHRoaXNBcmcpIHtcbiAgICBpZiAoIWlzQ2FsbGFibGUoaXRlcmF0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2l0ZXJhdG9yIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIHZhciByZWNlaXZlcjtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgIHJlY2VpdmVyID0gdGhpc0FyZztcbiAgICB9XG5cbiAgICBpZiAodG9TdHIuY2FsbChsaXN0KSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICBmb3JFYWNoQXJyYXkobGlzdCwgaXRlcmF0b3IsIHJlY2VpdmVyKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBmb3JFYWNoU3RyaW5nKGxpc3QsIGl0ZXJhdG9yLCByZWNlaXZlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yRWFjaE9iamVjdChsaXN0LCBpdGVyYXRvciwgcmVjZWl2ZXIpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODc5NDpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qIGVzbGludCBuby1pbnZhbGlkLXRoaXM6IDEgKi9cblxudmFyIEVSUk9SX01FU1NBR0UgPSAnRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSAnO1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBmdW5jVHlwZSA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cbnZhciBjb25jYXR0eSA9IGZ1bmN0aW9uIGNvbmNhdHR5KGEsIGIpIHtcbiAgICB2YXIgYXJyID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgYXJyW2ldID0gYVtpXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBiLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgIGFycltqICsgYS5sZW5ndGhdID0gYltqXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyO1xufTtcblxudmFyIHNsaWN5ID0gZnVuY3Rpb24gc2xpY3koYXJyTGlrZSwgb2Zmc2V0KSB7XG4gICAgdmFyIGFyciA9IFtdO1xuICAgIGZvciAodmFyIGkgPSBvZmZzZXQgfHwgMCwgaiA9IDA7IGkgPCBhcnJMaWtlLmxlbmd0aDsgaSArPSAxLCBqICs9IDEpIHtcbiAgICAgICAgYXJyW2pdID0gYXJyTGlrZVtpXTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn07XG5cbnZhciBqb2lueSA9IGZ1bmN0aW9uIChhcnIsIGpvaW5lcikge1xuICAgIHZhciBzdHIgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBzdHIgKz0gYXJyW2ldO1xuICAgICAgICBpZiAoaSArIDEgPCBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICBzdHIgKz0gam9pbmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQodGhhdCkge1xuICAgIHZhciB0YXJnZXQgPSB0aGlzO1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnZnVuY3Rpb24nIHx8IHRvU3RyLmFwcGx5KHRhcmdldCkgIT09IGZ1bmNUeXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRVJST1JfTUVTU0FHRSArIHRhcmdldCk7XG4gICAgfVxuICAgIHZhciBhcmdzID0gc2xpY3koYXJndW1lbnRzLCAxKTtcblxuICAgIHZhciBib3VuZDtcbiAgICB2YXIgYmluZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgY29uY2F0dHkoYXJncywgYXJndW1lbnRzKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICB0aGF0LFxuICAgICAgICAgICAgY29uY2F0dHkoYXJncywgYXJndW1lbnRzKVxuICAgICAgICApO1xuXG4gICAgfTtcblxuICAgIHZhciBib3VuZExlbmd0aCA9IG1heCgwLCB0YXJnZXQubGVuZ3RoIC0gYXJncy5sZW5ndGgpO1xuICAgIHZhciBib3VuZEFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYm91bmRBcmdzW2ldID0gJyQnICsgaTtcbiAgICB9XG5cbiAgICBib3VuZCA9IEZ1bmN0aW9uKCdiaW5kZXInLCAncmV0dXJuIGZ1bmN0aW9uICgnICsgam9pbnkoYm91bmRBcmdzLCAnLCcpICsgJyl7IHJldHVybiBiaW5kZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpOyB9JykoYmluZGVyKTtcblxuICAgIGlmICh0YXJnZXQucHJvdG90eXBlKSB7XG4gICAgICAgIHZhciBFbXB0eSA9IGZ1bmN0aW9uIEVtcHR5KCkge307XG4gICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IHRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgIGJvdW5kLnByb3RvdHlwZSA9IG5ldyBFbXB0eSgpO1xuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBib3VuZDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkxMzg6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oODc5NCk7XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgfHwgaW1wbGVtZW50YXRpb247XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDUyODpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIHVuZGVmaW5lZDtcblxudmFyICRFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oOTgzOCk7XG52YXIgJEV2YWxFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNjcyOSk7XG52YXIgJFJhbmdlRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExNTUpO1xudmFyICRSZWZlcmVuY2VFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNDk0Myk7XG52YXIgJFN5bnRheEVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NzMxKTtcbnZhciAkVHlwZUVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNDY4KTtcbnZhciAkVVJJRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxNDApO1xuXG52YXIgJEZ1bmN0aW9uID0gRnVuY3Rpb247XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxudmFyIGdldEV2YWxsZWRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChleHByZXNzaW9uU3ludGF4KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuICRGdW5jdGlvbignXCJ1c2Ugc3RyaWN0XCI7IHJldHVybiAoJyArIGV4cHJlc3Npb25TeW50YXggKyAnKS5jb25zdHJ1Y3RvcjsnKSgpO1xuXHR9IGNhdGNoIChlKSB7fVxufTtcblxudmFyICRnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbmlmICgkZ09QRCkge1xuXHR0cnkge1xuXHRcdCRnT1BEKHt9LCAnJyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQkZ09QRCA9IG51bGw7IC8vIHRoaXMgaXMgSUUgOCwgd2hpY2ggaGFzIGEgYnJva2VuIGdPUERcblx0fVxufVxuXG52YXIgdGhyb3dUeXBlRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cdHRocm93IG5ldyAkVHlwZUVycm9yKCk7XG59O1xudmFyIFRocm93VHlwZUVycm9yID0gJGdPUERcblx0PyAoZnVuY3Rpb24gKCkge1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zLCBuby1jYWxsZXIsIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllc1xuXHRcdFx0YXJndW1lbnRzLmNhbGxlZTsgLy8gSUUgOCBkb2VzIG5vdCB0aHJvdyBoZXJlXG5cdFx0XHRyZXR1cm4gdGhyb3dUeXBlRXJyb3I7XG5cdFx0fSBjYXRjaCAoY2FsbGVlVGhyb3dzKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHQvLyBJRSA4IHRocm93cyBvbiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGFyZ3VtZW50cywgJycpXG5cdFx0XHRcdHJldHVybiAkZ09QRChhcmd1bWVudHMsICdjYWxsZWUnKS5nZXQ7XG5cdFx0XHR9IGNhdGNoIChnT1BEdGhyb3dzKSB7XG5cdFx0XHRcdHJldHVybiB0aHJvd1R5cGVFcnJvcjtcblx0XHRcdH1cblx0XHR9XG5cdH0oKSlcblx0OiB0aHJvd1R5cGVFcnJvcjtcblxudmFyIGhhc1N5bWJvbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1NTgpKCk7XG52YXIgaGFzUHJvdG8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4NjkpKCk7XG5cbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCAoXG5cdGhhc1Byb3RvXG5cdFx0PyBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5fX3Byb3RvX187IH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b1xuXHRcdDogbnVsbFxuKTtcblxudmFyIG5lZWRzRXZhbCA9IHt9O1xuXG52YXIgVHlwZWRBcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyB8fCAhZ2V0UHJvdG8gPyB1bmRlZmluZWQgOiBnZXRQcm90byhVaW50OEFycmF5KTtcblxudmFyIElOVFJJTlNJQ1MgPSB7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0JyVBZ2dyZWdhdGVFcnJvciUnOiB0eXBlb2YgQWdncmVnYXRlRXJyb3IgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQWdncmVnYXRlRXJyb3IsXG5cdCclQXJyYXklJzogQXJyYXksXG5cdCclQXJyYXlCdWZmZXIlJzogdHlwZW9mIEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEFycmF5QnVmZmVyLFxuXHQnJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyAmJiBnZXRQcm90byA/IGdldFByb3RvKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkgOiB1bmRlZmluZWQsXG5cdCclQXN5bmNGcm9tU3luY0l0ZXJhdG9yUHJvdG90eXBlJSc6IHVuZGVmaW5lZCxcblx0JyVBc3luY0Z1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0dlbmVyYXRvciUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNJdGVyYXRvclByb3RvdHlwZSUnOiBuZWVkc0V2YWwsXG5cdCclQXRvbWljcyUnOiB0eXBlb2YgQXRvbWljcyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBdG9taWNzLFxuXHQnJUJpZ0ludCUnOiB0eXBlb2YgQmlnSW50ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEJpZ0ludCxcblx0JyVCaWdJbnQ2NEFycmF5JSc6IHR5cGVvZiBCaWdJbnQ2NEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEJpZ0ludDY0QXJyYXksXG5cdCclQmlnVWludDY0QXJyYXklJzogdHlwZW9mIEJpZ1VpbnQ2NEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEJpZ1VpbnQ2NEFycmF5LFxuXHQnJUJvb2xlYW4lJzogQm9vbGVhbixcblx0JyVEYXRhVmlldyUnOiB0eXBlb2YgRGF0YVZpZXcgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRGF0YVZpZXcsXG5cdCclRGF0ZSUnOiBEYXRlLFxuXHQnJWRlY29kZVVSSSUnOiBkZWNvZGVVUkksXG5cdCclZGVjb2RlVVJJQ29tcG9uZW50JSc6IGRlY29kZVVSSUNvbXBvbmVudCxcblx0JyVlbmNvZGVVUkklJzogZW5jb2RlVVJJLFxuXHQnJWVuY29kZVVSSUNvbXBvbmVudCUnOiBlbmNvZGVVUklDb21wb25lbnQsXG5cdCclRXJyb3IlJzogJEVycm9yLFxuXHQnJWV2YWwlJzogZXZhbCwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1ldmFsXG5cdCclRXZhbEVycm9yJSc6ICRFdmFsRXJyb3IsXG5cdCclRmxvYXQzMkFycmF5JSc6IHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQzMkFycmF5LFxuXHQnJUZsb2F0NjRBcnJheSUnOiB0eXBlb2YgRmxvYXQ2NEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZsb2F0NjRBcnJheSxcblx0JyVGaW5hbGl6YXRpb25SZWdpc3RyeSUnOiB0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmluYWxpemF0aW9uUmVnaXN0cnksXG5cdCclRnVuY3Rpb24lJzogJEZ1bmN0aW9uLFxuXHQnJUdlbmVyYXRvckZ1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVJbnQ4QXJyYXklJzogdHlwZW9mIEludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQ4QXJyYXksXG5cdCclSW50MTZBcnJheSUnOiB0eXBlb2YgSW50MTZBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQxNkFycmF5LFxuXHQnJUludDMyQXJyYXklJzogdHlwZW9mIEludDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50MzJBcnJheSxcblx0JyVpc0Zpbml0ZSUnOiBpc0Zpbml0ZSxcblx0JyVpc05hTiUnOiBpc05hTixcblx0JyVJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzICYmIGdldFByb3RvID8gZ2V0UHJvdG8oZ2V0UHJvdG8oW11bU3ltYm9sLml0ZXJhdG9yXSgpKSkgOiB1bmRlZmluZWQsXG5cdCclSlNPTiUnOiB0eXBlb2YgSlNPTiA9PT0gJ29iamVjdCcgPyBKU09OIDogdW5kZWZpbmVkLFxuXHQnJU1hcCUnOiB0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IE1hcCxcblx0JyVNYXBJdGVyYXRvclByb3RvdHlwZSUnOiB0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJyB8fCAhaGFzU3ltYm9scyB8fCAhZ2V0UHJvdG8gPyB1bmRlZmluZWQgOiBnZXRQcm90byhuZXcgTWFwKClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcblx0JyVNYXRoJSc6IE1hdGgsXG5cdCclTnVtYmVyJSc6IE51bWJlcixcblx0JyVPYmplY3QlJzogT2JqZWN0LFxuXHQnJXBhcnNlRmxvYXQlJzogcGFyc2VGbG9hdCxcblx0JyVwYXJzZUludCUnOiBwYXJzZUludCxcblx0JyVQcm9taXNlJSc6IHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFByb21pc2UsXG5cdCclUHJveHklJzogdHlwZW9mIFByb3h5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFByb3h5LFxuXHQnJVJhbmdlRXJyb3IlJzogJFJhbmdlRXJyb3IsXG5cdCclUmVmZXJlbmNlRXJyb3IlJzogJFJlZmVyZW5jZUVycm9yLFxuXHQnJVJlZmxlY3QlJzogdHlwZW9mIFJlZmxlY3QgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUmVmbGVjdCxcblx0JyVSZWdFeHAlJzogUmVnRXhwLFxuXHQnJVNldCUnOiB0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFNldCxcblx0JyVTZXRJdGVyYXRvclByb3RvdHlwZSUnOiB0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJyB8fCAhaGFzU3ltYm9scyB8fCAhZ2V0UHJvdG8gPyB1bmRlZmluZWQgOiBnZXRQcm90byhuZXcgU2V0KClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcblx0JyVTaGFyZWRBcnJheUJ1ZmZlciUnOiB0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogU2hhcmVkQXJyYXlCdWZmZXIsXG5cdCclU3RyaW5nJSc6IFN0cmluZyxcblx0JyVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzICYmIGdldFByb3RvID8gZ2V0UHJvdG8oJydbU3ltYm9sLml0ZXJhdG9yXSgpKSA6IHVuZGVmaW5lZCxcblx0JyVTeW1ib2wlJzogaGFzU3ltYm9scyA/IFN5bWJvbCA6IHVuZGVmaW5lZCxcblx0JyVTeW50YXhFcnJvciUnOiAkU3ludGF4RXJyb3IsXG5cdCclVGhyb3dUeXBlRXJyb3IlJzogVGhyb3dUeXBlRXJyb3IsXG5cdCclVHlwZWRBcnJheSUnOiBUeXBlZEFycmF5LFxuXHQnJVR5cGVFcnJvciUnOiAkVHlwZUVycm9yLFxuXHQnJVVpbnQ4QXJyYXklJzogdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDhBcnJheSxcblx0JyVVaW50OENsYW1wZWRBcnJheSUnOiB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDhDbGFtcGVkQXJyYXksXG5cdCclVWludDE2QXJyYXklJzogdHlwZW9mIFVpbnQxNkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQxNkFycmF5LFxuXHQnJVVpbnQzMkFycmF5JSc6IHR5cGVvZiBVaW50MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50MzJBcnJheSxcblx0JyVVUklFcnJvciUnOiAkVVJJRXJyb3IsXG5cdCclV2Vha01hcCUnOiB0eXBlb2YgV2Vha01hcCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrTWFwLFxuXHQnJVdlYWtSZWYlJzogdHlwZW9mIFdlYWtSZWYgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha1JlZixcblx0JyVXZWFrU2V0JSc6IHR5cGVvZiBXZWFrU2V0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtTZXRcbn07XG5cbmlmIChnZXRQcm90bykge1xuXHR0cnkge1xuXHRcdG51bGwuZXJyb3I7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zaGFkb3dyZWFsbS9wdWxsLzM4NCNpc3N1ZWNvbW1lbnQtMTM2NDI2NDIyOVxuXHRcdHZhciBlcnJvclByb3RvID0gZ2V0UHJvdG8oZ2V0UHJvdG8oZSkpO1xuXHRcdElOVFJJTlNJQ1NbJyVFcnJvci5wcm90b3R5cGUlJ10gPSBlcnJvclByb3RvO1xuXHR9XG59XG5cbnZhciBkb0V2YWwgPSBmdW5jdGlvbiBkb0V2YWwobmFtZSkge1xuXHR2YXIgdmFsdWU7XG5cdGlmIChuYW1lID09PSAnJUFzeW5jRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdhc3luYyBmdW5jdGlvbiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclR2VuZXJhdG9yRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdmdW5jdGlvbiogKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdhc3luYyBmdW5jdGlvbiogKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jR2VuZXJhdG9yJScpIHtcblx0XHR2YXIgZm4gPSBkb0V2YWwoJyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJScpO1xuXHRcdGlmIChmbikge1xuXHRcdFx0dmFsdWUgPSBmbi5wcm90b3R5cGU7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNJdGVyYXRvclByb3RvdHlwZSUnKSB7XG5cdFx0dmFyIGdlbiA9IGRvRXZhbCgnJUFzeW5jR2VuZXJhdG9yJScpO1xuXHRcdGlmIChnZW4gJiYgZ2V0UHJvdG8pIHtcblx0XHRcdHZhbHVlID0gZ2V0UHJvdG8oZ2VuLnByb3RvdHlwZSk7XG5cdFx0fVxuXHR9XG5cblx0SU5UUklOU0lDU1tuYW1lXSA9IHZhbHVlO1xuXG5cdHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciBMRUdBQ1lfQUxJQVNFUyA9IHtcblx0X19wcm90b19fOiBudWxsLFxuXHQnJUFycmF5QnVmZmVyUHJvdG90eXBlJSc6IFsnQXJyYXlCdWZmZXInLCAncHJvdG90eXBlJ10sXG5cdCclQXJyYXlQcm90b3R5cGUlJzogWydBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVBcnJheVByb3RvX2VudHJpZXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAnZW50cmllcyddLFxuXHQnJUFycmF5UHJvdG9fZm9yRWFjaCUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdmb3JFYWNoJ10sXG5cdCclQXJyYXlQcm90b19rZXlzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2tleXMnXSxcblx0JyVBcnJheVByb3RvX3ZhbHVlcyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICd2YWx1ZXMnXSxcblx0JyVBc3luY0Z1bmN0aW9uUHJvdG90eXBlJSc6IFsnQXN5bmNGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVBc3luY0dlbmVyYXRvciUnOiBbJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclQXN5bmNHZW5lcmF0b3JQcm90b3R5cGUlJzogWydBc3luY0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZScsICdwcm90b3R5cGUnXSxcblx0JyVCb29sZWFuUHJvdG90eXBlJSc6IFsnQm9vbGVhbicsICdwcm90b3R5cGUnXSxcblx0JyVEYXRhVmlld1Byb3RvdHlwZSUnOiBbJ0RhdGFWaWV3JywgJ3Byb3RvdHlwZSddLFxuXHQnJURhdGVQcm90b3R5cGUlJzogWydEYXRlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUVycm9yUHJvdG90eXBlJSc6IFsnRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclRXZhbEVycm9yUHJvdG90eXBlJSc6IFsnRXZhbEVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJUZsb2F0MzJBcnJheVByb3RvdHlwZSUnOiBbJ0Zsb2F0MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVGbG9hdDY0QXJyYXlQcm90b3R5cGUlJzogWydGbG9hdDY0QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclRnVuY3Rpb25Qcm90b3R5cGUlJzogWydGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVHZW5lcmF0b3IlJzogWydHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVHZW5lcmF0b3JQcm90b3R5cGUlJzogWydHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnLCAncHJvdG90eXBlJ10sXG5cdCclSW50OEFycmF5UHJvdG90eXBlJSc6IFsnSW50OEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDE2QXJyYXlQcm90b3R5cGUlJzogWydJbnQxNkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDMyQXJyYXlQcm90b3R5cGUlJzogWydJbnQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUpTT05QYXJzZSUnOiBbJ0pTT04nLCAncGFyc2UnXSxcblx0JyVKU09OU3RyaW5naWZ5JSc6IFsnSlNPTicsICdzdHJpbmdpZnknXSxcblx0JyVNYXBQcm90b3R5cGUlJzogWydNYXAnLCAncHJvdG90eXBlJ10sXG5cdCclTnVtYmVyUHJvdG90eXBlJSc6IFsnTnVtYmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJU9iamVjdFByb3RvdHlwZSUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnXSxcblx0JyVPYmpQcm90b190b1N0cmluZyUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnLCAndG9TdHJpbmcnXSxcblx0JyVPYmpQcm90b192YWx1ZU9mJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZScsICd2YWx1ZU9mJ10sXG5cdCclUHJvbWlzZVByb3RvdHlwZSUnOiBbJ1Byb21pc2UnLCAncHJvdG90eXBlJ10sXG5cdCclUHJvbWlzZVByb3RvX3RoZW4lJzogWydQcm9taXNlJywgJ3Byb3RvdHlwZScsICd0aGVuJ10sXG5cdCclUHJvbWlzZV9hbGwlJzogWydQcm9taXNlJywgJ2FsbCddLFxuXHQnJVByb21pc2VfcmVqZWN0JSc6IFsnUHJvbWlzZScsICdyZWplY3QnXSxcblx0JyVQcm9taXNlX3Jlc29sdmUlJzogWydQcm9taXNlJywgJ3Jlc29sdmUnXSxcblx0JyVSYW5nZUVycm9yUHJvdG90eXBlJSc6IFsnUmFuZ2VFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVSZWZlcmVuY2VFcnJvclByb3RvdHlwZSUnOiBbJ1JlZmVyZW5jZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVJlZ0V4cFByb3RvdHlwZSUnOiBbJ1JlZ0V4cCcsICdwcm90b3R5cGUnXSxcblx0JyVTZXRQcm90b3R5cGUlJzogWydTZXQnLCAncHJvdG90eXBlJ10sXG5cdCclU2hhcmVkQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogWydTaGFyZWRBcnJheUJ1ZmZlcicsICdwcm90b3R5cGUnXSxcblx0JyVTdHJpbmdQcm90b3R5cGUlJzogWydTdHJpbmcnLCAncHJvdG90eXBlJ10sXG5cdCclU3ltYm9sUHJvdG90eXBlJSc6IFsnU3ltYm9sJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN5bnRheEVycm9yUHJvdG90eXBlJSc6IFsnU3ludGF4RXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclVHlwZWRBcnJheVByb3RvdHlwZSUnOiBbJ1R5cGVkQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVHlwZUVycm9yUHJvdG90eXBlJSc6IFsnVHlwZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQ4QXJyYXlQcm90b3R5cGUlJzogWydVaW50OEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQ4Q2xhbXBlZEFycmF5UHJvdG90eXBlJSc6IFsnVWludDhDbGFtcGVkQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDE2QXJyYXlQcm90b3R5cGUlJzogWydVaW50MTZBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50MzJBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVSSUVycm9yUHJvdG90eXBlJSc6IFsnVVJJRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclV2Vha01hcFByb3RvdHlwZSUnOiBbJ1dlYWtNYXAnLCAncHJvdG90eXBlJ10sXG5cdCclV2Vha1NldFByb3RvdHlwZSUnOiBbJ1dlYWtTZXQnLCAncHJvdG90eXBlJ11cbn07XG5cbnZhciBiaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MTM4KTtcbnZhciBoYXNPd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1NTQpO1xudmFyICRjb25jYXQgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgQXJyYXkucHJvdG90eXBlLmNvbmNhdCk7XG52YXIgJHNwbGljZUFwcGx5ID0gYmluZC5jYWxsKEZ1bmN0aW9uLmFwcGx5LCBBcnJheS5wcm90b3R5cGUuc3BsaWNlKTtcbnZhciAkcmVwbGFjZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO1xudmFyICRzdHJTbGljZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBTdHJpbmcucHJvdG90eXBlLnNsaWNlKTtcbnZhciAkZXhlYyA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBSZWdFeHAucHJvdG90eXBlLmV4ZWMpO1xuXG4vKiBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi80LjE3LjE1L2Rpc3QvbG9kYXNoLmpzI0w2NzM1LUw2NzQ0ICovXG52YXIgcmVQcm9wTmFtZSA9IC9bXiUuW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JSQpKS9nO1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nOyAvKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBmdW5jdGlvbiBzdHJpbmdUb1BhdGgoc3RyaW5nKSB7XG5cdHZhciBmaXJzdCA9ICRzdHJTbGljZShzdHJpbmcsIDAsIDEpO1xuXHR2YXIgbGFzdCA9ICRzdHJTbGljZShzdHJpbmcsIC0xKTtcblx0aWYgKGZpcnN0ID09PSAnJScgJiYgbGFzdCAhPT0gJyUnKSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBjbG9zaW5nIGAlYCcpO1xuXHR9IGVsc2UgaWYgKGxhc3QgPT09ICclJyAmJiBmaXJzdCAhPT0gJyUnKSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBvcGVuaW5nIGAlYCcpO1xuXHR9XG5cdHZhciByZXN1bHQgPSBbXTtcblx0JHJlcGxhY2Uoc3RyaW5nLCByZVByb3BOYW1lLCBmdW5jdGlvbiAobWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuXHRcdHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHF1b3RlID8gJHJlcGxhY2Uoc3ViU3RyaW5nLCByZUVzY2FwZUNoYXIsICckMScpIDogbnVtYmVyIHx8IG1hdGNoO1xuXHR9KTtcblx0cmV0dXJuIHJlc3VsdDtcbn07XG4vKiBlbmQgYWRhcHRhdGlvbiAqL1xuXG52YXIgZ2V0QmFzZUludHJpbnNpYyA9IGZ1bmN0aW9uIGdldEJhc2VJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdHZhciBpbnRyaW5zaWNOYW1lID0gbmFtZTtcblx0dmFyIGFsaWFzO1xuXHRpZiAoaGFzT3duKExFR0FDWV9BTElBU0VTLCBpbnRyaW5zaWNOYW1lKSkge1xuXHRcdGFsaWFzID0gTEVHQUNZX0FMSUFTRVNbaW50cmluc2ljTmFtZV07XG5cdFx0aW50cmluc2ljTmFtZSA9ICclJyArIGFsaWFzWzBdICsgJyUnO1xuXHR9XG5cblx0aWYgKGhhc093bihJTlRSSU5TSUNTLCBpbnRyaW5zaWNOYW1lKSkge1xuXHRcdHZhciB2YWx1ZSA9IElOVFJJTlNJQ1NbaW50cmluc2ljTmFtZV07XG5cdFx0aWYgKHZhbHVlID09PSBuZWVkc0V2YWwpIHtcblx0XHRcdHZhbHVlID0gZG9FdmFsKGludHJpbnNpY05hbWUpO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyAmJiAhYWxsb3dNaXNzaW5nKSB7XG5cdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignaW50cmluc2ljICcgKyBuYW1lICsgJyBleGlzdHMsIGJ1dCBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSEnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0YWxpYXM6IGFsaWFzLFxuXHRcdFx0bmFtZTogaW50cmluc2ljTmFtZSxcblx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdH07XG5cdH1cblxuXHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnRyaW5zaWMgJyArIG5hbWUgKyAnIGRvZXMgbm90IGV4aXN0IScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBHZXRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycgfHwgbmFtZS5sZW5ndGggPT09IDApIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignaW50cmluc2ljIG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdHlwZW9mIGFsbG93TWlzc2luZyAhPT0gJ2Jvb2xlYW4nKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ1wiYWxsb3dNaXNzaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBhIGJvb2xlYW4nKTtcblx0fVxuXG5cdGlmICgkZXhlYygvXiU/W14lXSolPyQvLCBuYW1lKSA9PT0gbnVsbCkge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2AlYCBtYXkgbm90IGJlIHByZXNlbnQgYW55d2hlcmUgYnV0IGF0IHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgaW50cmluc2ljIG5hbWUnKTtcblx0fVxuXHR2YXIgcGFydHMgPSBzdHJpbmdUb1BhdGgobmFtZSk7XG5cdHZhciBpbnRyaW5zaWNCYXNlTmFtZSA9IHBhcnRzLmxlbmd0aCA+IDAgPyBwYXJ0c1swXSA6ICcnO1xuXG5cdHZhciBpbnRyaW5zaWMgPSBnZXRCYXNlSW50cmluc2ljKCclJyArIGludHJpbnNpY0Jhc2VOYW1lICsgJyUnLCBhbGxvd01pc3NpbmcpO1xuXHR2YXIgaW50cmluc2ljUmVhbE5hbWUgPSBpbnRyaW5zaWMubmFtZTtcblx0dmFyIHZhbHVlID0gaW50cmluc2ljLnZhbHVlO1xuXHR2YXIgc2tpcEZ1cnRoZXJDYWNoaW5nID0gZmFsc2U7XG5cblx0dmFyIGFsaWFzID0gaW50cmluc2ljLmFsaWFzO1xuXHRpZiAoYWxpYXMpIHtcblx0XHRpbnRyaW5zaWNCYXNlTmFtZSA9IGFsaWFzWzBdO1xuXHRcdCRzcGxpY2VBcHBseShwYXJ0cywgJGNvbmNhdChbMCwgMV0sIGFsaWFzKSk7XG5cdH1cblxuXHRmb3IgKHZhciBpID0gMSwgaXNPd24gPSB0cnVlOyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDEpIHtcblx0XHR2YXIgcGFydCA9IHBhcnRzW2ldO1xuXHRcdHZhciBmaXJzdCA9ICRzdHJTbGljZShwYXJ0LCAwLCAxKTtcblx0XHR2YXIgbGFzdCA9ICRzdHJTbGljZShwYXJ0LCAtMSk7XG5cdFx0aWYgKFxuXHRcdFx0KFxuXHRcdFx0XHQoZmlyc3QgPT09ICdcIicgfHwgZmlyc3QgPT09IFwiJ1wiIHx8IGZpcnN0ID09PSAnYCcpXG5cdFx0XHRcdHx8IChsYXN0ID09PSAnXCInIHx8IGxhc3QgPT09IFwiJ1wiIHx8IGxhc3QgPT09ICdgJylcblx0XHRcdClcblx0XHRcdCYmIGZpcnN0ICE9PSBsYXN0XG5cdFx0KSB7XG5cdFx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdwcm9wZXJ0eSBuYW1lcyB3aXRoIHF1b3RlcyBtdXN0IGhhdmUgbWF0Y2hpbmcgcXVvdGVzJyk7XG5cdFx0fVxuXHRcdGlmIChwYXJ0ID09PSAnY29uc3RydWN0b3InIHx8ICFpc093bikge1xuXHRcdFx0c2tpcEZ1cnRoZXJDYWNoaW5nID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpbnRyaW5zaWNCYXNlTmFtZSArPSAnLicgKyBwYXJ0O1xuXHRcdGludHJpbnNpY1JlYWxOYW1lID0gJyUnICsgaW50cmluc2ljQmFzZU5hbWUgKyAnJSc7XG5cblx0XHRpZiAoaGFzT3duKElOVFJJTlNJQ1MsIGludHJpbnNpY1JlYWxOYW1lKSkge1xuXHRcdFx0dmFsdWUgPSBJTlRSSU5TSUNTW2ludHJpbnNpY1JlYWxOYW1lXTtcblx0XHR9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcblx0XHRcdGlmICghKHBhcnQgaW4gdmFsdWUpKSB7XG5cdFx0XHRcdGlmICghYWxsb3dNaXNzaW5nKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2Jhc2UgaW50cmluc2ljIGZvciAnICsgbmFtZSArICcgZXhpc3RzLCBidXQgdGhlIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUuJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZvaWQgdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCRnT1BEICYmIChpICsgMSkgPj0gcGFydHMubGVuZ3RoKSB7XG5cdFx0XHRcdHZhciBkZXNjID0gJGdPUEQodmFsdWUsIHBhcnQpO1xuXHRcdFx0XHRpc093biA9ICEhZGVzYztcblxuXHRcdFx0XHQvLyBCeSBjb252ZW50aW9uLCB3aGVuIGEgZGF0YSBwcm9wZXJ0eSBpcyBjb252ZXJ0ZWQgdG8gYW4gYWNjZXNzb3Jcblx0XHRcdFx0Ly8gcHJvcGVydHkgdG8gZW11bGF0ZSBhIGRhdGEgcHJvcGVydHkgdGhhdCBkb2VzIG5vdCBzdWZmZXIgZnJvbVxuXHRcdFx0XHQvLyB0aGUgb3ZlcnJpZGUgbWlzdGFrZSwgdGhhdCBhY2Nlc3NvcidzIGdldHRlciBpcyBtYXJrZWQgd2l0aFxuXHRcdFx0XHQvLyBhbiBgb3JpZ2luYWxWYWx1ZWAgcHJvcGVydHkuIEhlcmUsIHdoZW4gd2UgZGV0ZWN0IHRoaXMsIHdlXG5cdFx0XHRcdC8vIHVwaG9sZCB0aGUgaWxsdXNpb24gYnkgcHJldGVuZGluZyB0byBzZWUgdGhhdCBvcmlnaW5hbCBkYXRhXG5cdFx0XHRcdC8vIHByb3BlcnR5LCBpLmUuLCByZXR1cm5pbmcgdGhlIHZhbHVlIHJhdGhlciB0aGFuIHRoZSBnZXR0ZXJcblx0XHRcdFx0Ly8gaXRzZWxmLlxuXHRcdFx0XHRpZiAoaXNPd24gJiYgJ2dldCcgaW4gZGVzYyAmJiAhKCdvcmlnaW5hbFZhbHVlJyBpbiBkZXNjLmdldCkpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGRlc2MuZ2V0O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhbHVlID0gdmFsdWVbcGFydF07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlzT3duID0gaGFzT3duKHZhbHVlLCBwYXJ0KTtcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtwYXJ0XTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGlzT3duICYmICFza2lwRnVydGhlckNhY2hpbmcpIHtcblx0XHRcdFx0SU5UUklOU0lDU1tpbnRyaW5zaWNSZWFsTmFtZV0gPSB2YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHZhbHVlO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTMzNjpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIEdldEludHJpbnNpYyA9IF9fd2VicGFja19yZXF1aXJlX18oNTI4KTtcblxudmFyICRnT1BEID0gR2V0SW50cmluc2ljKCclT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciUnLCB0cnVlKTtcblxuaWYgKCRnT1BEKSB7XG5cdHRyeSB7XG5cdFx0JGdPUEQoW10sICdsZW5ndGgnKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIElFIDggaGFzIGEgYnJva2VuIGdPUERcblx0XHQkZ09QRCA9IG51bGw7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSAkZ09QRDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzIzOTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oNDk0MCk7XG5cbnZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3JzID0gZnVuY3Rpb24gaGFzUHJvcGVydHlEZXNjcmlwdG9ycygpIHtcblx0cmV0dXJuICEhJGRlZmluZVByb3BlcnR5O1xufTtcblxuaGFzUHJvcGVydHlEZXNjcmlwdG9ycy5oYXNBcnJheUxlbmd0aERlZmluZUJ1ZyA9IGZ1bmN0aW9uIGhhc0FycmF5TGVuZ3RoRGVmaW5lQnVnKCkge1xuXHQvLyBub2RlIHYwLjYgaGFzIGEgYnVnIHdoZXJlIGFycmF5IGxlbmd0aHMgY2FuIGJlIFNldCBidXQgbm90IERlZmluZWRcblx0aWYgKCEkZGVmaW5lUHJvcGVydHkpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHR0cnkge1xuXHRcdHJldHVybiAkZGVmaW5lUHJvcGVydHkoW10sICdsZW5ndGgnLCB7IHZhbHVlOiAxIH0pLmxlbmd0aCAhPT0gMTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIEluIEZpcmVmb3ggNC0yMiwgZGVmaW5pbmcgbGVuZ3RoIG9uIGFuIGFycmF5IHRocm93cyBhbiBleGNlcHRpb24uXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzUHJvcGVydHlEZXNjcmlwdG9ycztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjg2OTpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciB0ZXN0ID0ge1xuXHRmb286IHt9XG59O1xuXG52YXIgJE9iamVjdCA9IE9iamVjdDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNQcm90bygpIHtcblx0cmV0dXJuIHsgX19wcm90b19fOiB0ZXN0IH0uZm9vID09PSB0ZXN0LmZvbyAmJiAhKHsgX19wcm90b19fOiBudWxsIH0gaW5zdGFuY2VvZiAkT2JqZWN0KTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM1NTg6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBvcmlnU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sO1xudmFyIGhhc1N5bWJvbFNoYW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5MDgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc05hdGl2ZVN5bWJvbHMoKSB7XG5cdGlmICh0eXBlb2Ygb3JpZ1N5bWJvbCAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2wgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2Ygb3JpZ1N5bWJvbCgnZm9vJykgIT09ICdzeW1ib2wnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbCgnYmFyJykgIT09ICdzeW1ib2wnKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHJldHVybiBoYXNTeW1ib2xTaGFtKCk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyOTA4OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyogZXNsaW50IGNvbXBsZXhpdHk6IFsyLCAxOF0sIG1heC1zdGF0ZW1lbnRzOiBbMiwgMzNdICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc1N5bWJvbHMoKSB7XG5cdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCcpIHsgcmV0dXJuIHRydWU7IH1cblxuXHR2YXIgb2JqID0ge307XG5cdHZhciBzeW0gPSBTeW1ib2woJ3Rlc3QnKTtcblx0dmFyIHN5bU9iaiA9IE9iamVjdChzeW0pO1xuXHRpZiAodHlwZW9mIHN5bSA9PT0gJ3N0cmluZycpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW0pICE9PSAnW29iamVjdCBTeW1ib2xdJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW1PYmopICE9PSAnW29iamVjdCBTeW1ib2xdJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL29iamVjdC5hc3NpZ24vaXNzdWVzLzE3XG5cdC8vIGlmIChzeW0gaW5zdGFuY2VvZiBTeW1ib2wpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdC8vIHRlbXAgZGlzYWJsZWQgcGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9XZWJSZWZsZWN0aW9uL2dldC1vd24tcHJvcGVydHktc3ltYm9scy9pc3N1ZXMvNFxuXHQvLyBpZiAoIShzeW1PYmogaW5zdGFuY2VvZiBTeW1ib2wpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdC8vIGlmICh0eXBlb2YgU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZyAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0Ly8gaWYgKFN0cmluZyhzeW0pICE9PSBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHR2YXIgc3ltVmFsID0gNDI7XG5cdG9ialtzeW1dID0gc3ltVmFsO1xuXHRmb3IgKHN5bSBpbiBvYmopIHsgcmV0dXJuIGZhbHNlOyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXgsIG5vLXVucmVhY2hhYmxlLWxvb3Bcblx0aWYgKHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCAhPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzID09PSAnZnVuY3Rpb24nICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubGVuZ3RoICE9PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHZhciBzeW1zID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmopO1xuXHRpZiAoc3ltcy5sZW5ndGggIT09IDEgfHwgc3ltc1swXSAhPT0gc3ltKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iaiwgc3ltKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBzeW0pO1xuXHRcdGlmIChkZXNjcmlwdG9yLnZhbHVlICE9PSBzeW1WYWwgfHwgZGVzY3JpcHRvci5lbnVtZXJhYmxlICE9PSB0cnVlKSB7IHJldHVybiBmYWxzZTsgfVxuXHR9XG5cblx0cmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxOTEzOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgaGFzU3ltYm9scyA9IF9fd2VicGFja19yZXF1aXJlX18oMjkwOCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzVG9TdHJpbmdUYWdTaGFtcygpIHtcblx0cmV0dXJuIGhhc1N5bWJvbHMoKSAmJiAhIVN5bWJvbC50b1N0cmluZ1RhZztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDg1NTQ6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBjYWxsID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGw7XG52YXIgJGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgYmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oOTEzOCk7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IGJpbmQuY2FsbChjYWxsLCAkaGFzT3duKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTYxNTpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbmlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgICB9XG4gIH1cbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTM4Nzpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGhhc1RvU3RyaW5nVGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOTEzKSgpO1xudmFyIGNhbGxCb3VuZCA9IF9fd2VicGFja19yZXF1aXJlX18oOTgxOCk7XG5cbnZhciAkdG9TdHJpbmcgPSBjYWxsQm91bmQoJ09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcnKTtcblxudmFyIGlzU3RhbmRhcmRBcmd1bWVudHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuXHRpZiAoaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiBTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsdWUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0cmV0dXJuICR0b1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufTtcblxudmFyIGlzTGVnYWN5QXJndW1lbnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcblx0aWYgKGlzU3RhbmRhcmRBcmd1bWVudHModmFsdWUpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0cmV0dXJuIHZhbHVlICE9PSBudWxsICYmXG5cdFx0dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuXHRcdHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICdudW1iZXInICYmXG5cdFx0dmFsdWUubGVuZ3RoID49IDAgJiZcblx0XHQkdG9TdHJpbmcodmFsdWUpICE9PSAnW29iamVjdCBBcnJheV0nICYmXG5cdFx0JHRvU3RyaW5nKHZhbHVlLmNhbGxlZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59O1xuXG52YXIgc3VwcG9ydHNTdGFuZGFyZEFyZ3VtZW50cyA9IChmdW5jdGlvbiAoKSB7XG5cdHJldHVybiBpc1N0YW5kYXJkQXJndW1lbnRzKGFyZ3VtZW50cyk7XG59KCkpO1xuXG5pc1N0YW5kYXJkQXJndW1lbnRzLmlzTGVnYWN5QXJndW1lbnRzID0gaXNMZWdhY3lBcmd1bWVudHM7IC8vIGZvciB0ZXN0c1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN1cHBvcnRzU3RhbmRhcmRBcmd1bWVudHMgPyBpc1N0YW5kYXJkQXJndW1lbnRzIDogaXNMZWdhY3lBcmd1bWVudHM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDk2MTc6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgZm5Ub1N0ciA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcbnZhciByZWZsZWN0QXBwbHkgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdCAhPT0gbnVsbCAmJiBSZWZsZWN0LmFwcGx5O1xudmFyIGJhZEFycmF5TGlrZTtcbnZhciBpc0NhbGxhYmxlTWFya2VyO1xuaWYgKHR5cGVvZiByZWZsZWN0QXBwbHkgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJykge1xuXHR0cnkge1xuXHRcdGJhZEFycmF5TGlrZSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2xlbmd0aCcsIHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aHJvdyBpc0NhbGxhYmxlTWFya2VyO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGlzQ2FsbGFibGVNYXJrZXIgPSB7fTtcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuXHRcdHJlZmxlY3RBcHBseShmdW5jdGlvbiAoKSB7IHRocm93IDQyOyB9LCBudWxsLCBiYWRBcnJheUxpa2UpO1xuXHR9IGNhdGNoIChfKSB7XG5cdFx0aWYgKF8gIT09IGlzQ2FsbGFibGVNYXJrZXIpIHtcblx0XHRcdHJlZmxlY3RBcHBseSA9IG51bGw7XG5cdFx0fVxuXHR9XG59IGVsc2Uge1xuXHRyZWZsZWN0QXBwbHkgPSBudWxsO1xufVxuXG52YXIgY29uc3RydWN0b3JSZWdleCA9IC9eXFxzKmNsYXNzXFxiLztcbnZhciBpc0VTNkNsYXNzRm4gPSBmdW5jdGlvbiBpc0VTNkNsYXNzRnVuY3Rpb24odmFsdWUpIHtcblx0dHJ5IHtcblx0XHR2YXIgZm5TdHIgPSBmblRvU3RyLmNhbGwodmFsdWUpO1xuXHRcdHJldHVybiBjb25zdHJ1Y3RvclJlZ2V4LnRlc3QoZm5TdHIpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlOyAvLyBub3QgYSBmdW5jdGlvblxuXHR9XG59O1xuXG52YXIgdHJ5RnVuY3Rpb25PYmplY3QgPSBmdW5jdGlvbiB0cnlGdW5jdGlvblRvU3RyKHZhbHVlKSB7XG5cdHRyeSB7XG5cdFx0aWYgKGlzRVM2Q2xhc3NGbih2YWx1ZSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0Zm5Ub1N0ci5jYWxsKHZhbHVlKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgb2JqZWN0Q2xhc3MgPSAnW29iamVjdCBPYmplY3RdJztcbnZhciBmbkNsYXNzID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbnZhciBnZW5DbGFzcyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXSc7XG52YXIgZGRhQ2xhc3MgPSAnW29iamVjdCBIVE1MQWxsQ29sbGVjdGlvbl0nOyAvLyBJRSAxMVxudmFyIGRkYUNsYXNzMiA9ICdbb2JqZWN0IEhUTUwgZG9jdW1lbnQuYWxsIGNsYXNzXSc7XG52YXIgZGRhQ2xhc3MzID0gJ1tvYmplY3QgSFRNTENvbGxlY3Rpb25dJzsgLy8gSUUgOS0xMFxudmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiAhIVN5bWJvbC50b1N0cmluZ1RhZzsgLy8gYmV0dGVyOiB1c2UgYGhhcy10b3N0cmluZ3RhZ2BcblxudmFyIGlzSUU2OCA9ICEoMCBpbiBbLF0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNwYXJzZS1hcnJheXMsIGNvbW1hLXNwYWNpbmdcblxudmFyIGlzRERBID0gZnVuY3Rpb24gaXNEb2N1bWVudERvdEFsbCgpIHsgcmV0dXJuIGZhbHNlOyB9O1xuaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ29iamVjdCcpIHtcblx0Ly8gRmlyZWZveCAzIGNhbm9uaWNhbGl6ZXMgRERBIHRvIHVuZGVmaW5lZCB3aGVuIGl0J3Mgbm90IGFjY2Vzc2VkIGRpcmVjdGx5XG5cdHZhciBhbGwgPSBkb2N1bWVudC5hbGw7XG5cdGlmICh0b1N0ci5jYWxsKGFsbCkgPT09IHRvU3RyLmNhbGwoZG9jdW1lbnQuYWxsKSkge1xuXHRcdGlzRERBID0gZnVuY3Rpb24gaXNEb2N1bWVudERvdEFsbCh2YWx1ZSkge1xuXHRcdFx0LyogZ2xvYmFscyBkb2N1bWVudDogZmFsc2UgKi9cblx0XHRcdC8vIGluIElFIDYtOCwgdHlwZW9mIGRvY3VtZW50LmFsbCBpcyBcIm9iamVjdFwiIGFuZCBpdCdzIHRydXRoeVxuXHRcdFx0aWYgKChpc0lFNjggfHwgIXZhbHVlKSAmJiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHZhciBzdHIgPSB0b1N0ci5jYWxsKHZhbHVlKTtcblx0XHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdFx0c3RyID09PSBkZGFDbGFzc1xuXHRcdFx0XHRcdFx0fHwgc3RyID09PSBkZGFDbGFzczJcblx0XHRcdFx0XHRcdHx8IHN0ciA9PT0gZGRhQ2xhc3MzIC8vIG9wZXJhIDEyLjE2XG5cdFx0XHRcdFx0XHR8fCBzdHIgPT09IG9iamVjdENsYXNzIC8vIElFIDYtOFxuXHRcdFx0XHRcdCkgJiYgdmFsdWUoJycpID09IG51bGw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHsgLyoqLyB9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlZmxlY3RBcHBseVxuXHQ/IGZ1bmN0aW9uIGlzQ2FsbGFibGUodmFsdWUpIHtcblx0XHRpZiAoaXNEREEodmFsdWUpKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0aWYgKCF2YWx1ZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0dHJ5IHtcblx0XHRcdHJlZmxlY3RBcHBseSh2YWx1ZSwgbnVsbCwgYmFkQXJyYXlMaWtlKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRpZiAoZSAhPT0gaXNDYWxsYWJsZU1hcmtlcikgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR9XG5cdFx0cmV0dXJuICFpc0VTNkNsYXNzRm4odmFsdWUpICYmIHRyeUZ1bmN0aW9uT2JqZWN0KHZhbHVlKTtcblx0fVxuXHQ6IGZ1bmN0aW9uIGlzQ2FsbGFibGUodmFsdWUpIHtcblx0XHRpZiAoaXNEREEodmFsdWUpKSB7IHJldHVybiB0cnVlOyB9XG5cdFx0aWYgKCF2YWx1ZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHRpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0aWYgKGhhc1RvU3RyaW5nVGFnKSB7IHJldHVybiB0cnlGdW5jdGlvbk9iamVjdCh2YWx1ZSk7IH1cblx0XHRpZiAoaXNFUzZDbGFzc0ZuKHZhbHVlKSkgeyByZXR1cm4gZmFsc2U7IH1cblx0XHR2YXIgc3RyQ2xhc3MgPSB0b1N0ci5jYWxsKHZhbHVlKTtcblx0XHRpZiAoc3RyQ2xhc3MgIT09IGZuQ2xhc3MgJiYgc3RyQ2xhc3MgIT09IGdlbkNsYXNzICYmICEoL15cXFtvYmplY3QgSFRNTC8pLnRlc3Qoc3RyQ2xhc3MpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdHJldHVybiB0cnlGdW5jdGlvbk9iamVjdCh2YWx1ZSk7XG5cdH07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI2MjU6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZm5Ub1N0ciA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcbnZhciBpc0ZuUmVnZXggPSAvXlxccyooPzpmdW5jdGlvbik/XFwqLztcbnZhciBoYXNUb1N0cmluZ1RhZyA9IF9fd2VicGFja19yZXF1aXJlX18oMTkxMykoKTtcbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBnZXRHZW5lcmF0b3JGdW5jID0gZnVuY3Rpb24gKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG5cdGlmICghaGFzVG9TdHJpbmdUYWcpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0dHJ5IHtcblx0XHRyZXR1cm4gRnVuY3Rpb24oJ3JldHVybiBmdW5jdGlvbiooKSB7fScpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0fVxufTtcbnZhciBHZW5lcmF0b3JGdW5jdGlvbjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0dlbmVyYXRvckZ1bmN0aW9uKGZuKSB7XG5cdGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0aWYgKGlzRm5SZWdleC50ZXN0KGZuVG9TdHIuY2FsbChmbikpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0aWYgKCFoYXNUb1N0cmluZ1RhZykge1xuXHRcdHZhciBzdHIgPSB0b1N0ci5jYWxsKGZuKTtcblx0XHRyZXR1cm4gc3RyID09PSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nO1xuXHR9XG5cdGlmICghZ2V0UHJvdG8pIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0aWYgKHR5cGVvZiBHZW5lcmF0b3JGdW5jdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHR2YXIgZ2VuZXJhdG9yRnVuYyA9IGdldEdlbmVyYXRvckZ1bmMoKTtcblx0XHRHZW5lcmF0b3JGdW5jdGlvbiA9IGdlbmVyYXRvckZ1bmMgPyBnZXRQcm90byhnZW5lcmF0b3JGdW5jKSA6IGZhbHNlO1xuXHR9XG5cdHJldHVybiBnZXRQcm90byhmbikgPT09IEdlbmVyYXRvckZ1bmN0aW9uO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODAwNjpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIuaXNuYW4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc05hTih2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzgzODpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGNhbGxCaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDk4KTtcbnZhciBkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4NTcpO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgwMDYpO1xudmFyIGdldFBvbHlmaWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTkxKTtcbnZhciBzaGltID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNjQxKTtcblxudmFyIHBvbHlmaWxsID0gY2FsbEJpbmQoZ2V0UG9seWZpbGwoKSwgTnVtYmVyKTtcblxuLyogaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW51bWJlci5pc25hbiAqL1xuXG5kZWZpbmUocG9seWZpbGwsIHtcblx0Z2V0UG9seWZpbGw6IGdldFBvbHlmaWxsLFxuXHRpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb24sXG5cdHNoaW06IHNoaW1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBvbHlmaWxsO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxNTkxOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgaW1wbGVtZW50YXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgwMDYpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFBvbHlmaWxsKCkge1xuXHRpZiAoTnVtYmVyLmlzTmFOICYmIE51bWJlci5pc05hTihOYU4pICYmICFOdW1iZXIuaXNOYU4oJ2EnKSkge1xuXHRcdHJldHVybiBOdW1iZXIuaXNOYU47XG5cdH1cblx0cmV0dXJuIGltcGxlbWVudGF0aW9uO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTY0MTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTg1Nyk7XG52YXIgZ2V0UG9seWZpbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1OTEpO1xuXG4vKiBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLmlzbmFuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2hpbU51bWJlcklzTmFOKCkge1xuXHR2YXIgcG9seWZpbGwgPSBnZXRQb2x5ZmlsbCgpO1xuXHRkZWZpbmUoTnVtYmVyLCB7IGlzTmFOOiBwb2x5ZmlsbCB9LCB7XG5cdFx0aXNOYU46IGZ1bmN0aW9uIHRlc3RJc05hTigpIHtcblx0XHRcdHJldHVybiBOdW1iZXIuaXNOYU4gIT09IHBvbHlmaWxsO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBwb2x5ZmlsbDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDU5NDM6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciB3aGljaFR5cGVkQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3MzApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzVHlwZWRBcnJheSh2YWx1ZSkge1xuXHRyZXR1cm4gISF3aGljaFR5cGVkQXJyYXkodmFsdWUpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjM3Mjpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBudW1iZXJJc05hTiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpcyhhLCBiKSB7XG5cdGlmIChhID09PSAwICYmIGIgPT09IDApIHtcblx0XHRyZXR1cm4gMSAvIGEgPT09IDEgLyBiO1xuXHR9XG5cdGlmIChhID09PSBiKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0aWYgKG51bWJlcklzTmFOKGEpICYmIG51bWJlcklzTmFOKGIpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufTtcblxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1OTY4OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgZGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygxODU3KTtcbnZhciBjYWxsQmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oODQ5OCk7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMjM3Mik7XG52YXIgZ2V0UG9seWZpbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5MzcpO1xudmFyIHNoaW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwODcpO1xuXG52YXIgcG9seWZpbGwgPSBjYWxsQmluZChnZXRQb2x5ZmlsbCgpLCBPYmplY3QpO1xuXG5kZWZpbmUocG9seWZpbGwsIHtcblx0Z2V0UG9seWZpbGw6IGdldFBvbHlmaWxsLFxuXHRpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb24sXG5cdHNoaW06IHNoaW1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBvbHlmaWxsO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxOTM3OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgaW1wbGVtZW50YXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzNzIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFBvbHlmaWxsKCkge1xuXHRyZXR1cm4gdHlwZW9mIE9iamVjdC5pcyA9PT0gJ2Z1bmN0aW9uJyA/IE9iamVjdC5pcyA6IGltcGxlbWVudGF0aW9uO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTA4Nzpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGdldFBvbHlmaWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOTM3KTtcbnZhciBkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4NTcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNoaW1PYmplY3RJcygpIHtcblx0dmFyIHBvbHlmaWxsID0gZ2V0UG9seWZpbGwoKTtcblx0ZGVmaW5lKE9iamVjdCwgeyBpczogcG9seWZpbGwgfSwge1xuXHRcdGlzOiBmdW5jdGlvbiB0ZXN0T2JqZWN0SXMoKSB7XG5cdFx0XHRyZXR1cm4gT2JqZWN0LmlzICE9PSBwb2x5ZmlsbDtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gcG9seWZpbGw7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4MTYwOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIga2V5c1NoaW07XG5pZiAoIU9iamVjdC5rZXlzKSB7XG5cdC8vIG1vZGlmaWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltXG5cdHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXHR2YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXHR2YXIgaXNBcmdzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NjgpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGdsb2JhbC1yZXF1aXJlXG5cdHZhciBpc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXHR2YXIgaGFzRG9udEVudW1CdWcgPSAhaXNFbnVtZXJhYmxlLmNhbGwoeyB0b1N0cmluZzogbnVsbCB9LCAndG9TdHJpbmcnKTtcblx0dmFyIGhhc1Byb3RvRW51bUJ1ZyA9IGlzRW51bWVyYWJsZS5jYWxsKGZ1bmN0aW9uICgpIHt9LCAncHJvdG90eXBlJyk7XG5cdHZhciBkb250RW51bXMgPSBbXG5cdFx0J3RvU3RyaW5nJyxcblx0XHQndG9Mb2NhbGVTdHJpbmcnLFxuXHRcdCd2YWx1ZU9mJyxcblx0XHQnaGFzT3duUHJvcGVydHknLFxuXHRcdCdpc1Byb3RvdHlwZU9mJyxcblx0XHQncHJvcGVydHlJc0VudW1lcmFibGUnLFxuXHRcdCdjb25zdHJ1Y3Rvcidcblx0XTtcblx0dmFyIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlID0gZnVuY3Rpb24gKG8pIHtcblx0XHR2YXIgY3RvciA9IG8uY29uc3RydWN0b3I7XG5cdFx0cmV0dXJuIGN0b3IgJiYgY3Rvci5wcm90b3R5cGUgPT09IG87XG5cdH07XG5cdHZhciBleGNsdWRlZEtleXMgPSB7XG5cdFx0JGFwcGxpY2F0aW9uQ2FjaGU6IHRydWUsXG5cdFx0JGNvbnNvbGU6IHRydWUsXG5cdFx0JGV4dGVybmFsOiB0cnVlLFxuXHRcdCRmcmFtZTogdHJ1ZSxcblx0XHQkZnJhbWVFbGVtZW50OiB0cnVlLFxuXHRcdCRmcmFtZXM6IHRydWUsXG5cdFx0JGlubmVySGVpZ2h0OiB0cnVlLFxuXHRcdCRpbm5lcldpZHRoOiB0cnVlLFxuXHRcdCRvbm1vemZ1bGxzY3JlZW5jaGFuZ2U6IHRydWUsXG5cdFx0JG9ubW96ZnVsbHNjcmVlbmVycm9yOiB0cnVlLFxuXHRcdCRvdXRlckhlaWdodDogdHJ1ZSxcblx0XHQkb3V0ZXJXaWR0aDogdHJ1ZSxcblx0XHQkcGFnZVhPZmZzZXQ6IHRydWUsXG5cdFx0JHBhZ2VZT2Zmc2V0OiB0cnVlLFxuXHRcdCRwYXJlbnQ6IHRydWUsXG5cdFx0JHNjcm9sbExlZnQ6IHRydWUsXG5cdFx0JHNjcm9sbFRvcDogdHJ1ZSxcblx0XHQkc2Nyb2xsWDogdHJ1ZSxcblx0XHQkc2Nyb2xsWTogdHJ1ZSxcblx0XHQkc2VsZjogdHJ1ZSxcblx0XHQkd2Via2l0SW5kZXhlZERCOiB0cnVlLFxuXHRcdCR3ZWJraXRTdG9yYWdlSW5mbzogdHJ1ZSxcblx0XHQkd2luZG93OiB0cnVlXG5cdH07XG5cdHZhciBoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWcgPSAoZnVuY3Rpb24gKCkge1xuXHRcdC8qIGdsb2JhbCB3aW5kb3cgKi9cblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0Zm9yICh2YXIgayBpbiB3aW5kb3cpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGlmICghZXhjbHVkZWRLZXlzWyckJyArIGtdICYmIGhhcy5jYWxsKHdpbmRvdywgaykgJiYgd2luZG93W2tdICE9PSBudWxsICYmIHR5cGVvZiB3aW5kb3dba10gPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKHdpbmRvd1trXSk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0oKSk7XG5cdHZhciBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZUlmTm90QnVnZ3kgPSBmdW5jdGlvbiAobykge1xuXHRcdC8qIGdsb2JhbCB3aW5kb3cgKi9cblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc0F1dG9tYXRpb25FcXVhbGl0eUJ1Zykge1xuXHRcdFx0cmV0dXJuIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKG8pO1xuXHRcdH1cblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlKG8pO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH07XG5cblx0a2V5c1NoaW0gPSBmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuXHRcdHZhciBpc09iamVjdCA9IG9iamVjdCAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0Jztcblx0XHR2YXIgaXNGdW5jdGlvbiA9IHRvU3RyLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblx0XHR2YXIgaXNBcmd1bWVudHMgPSBpc0FyZ3Mob2JqZWN0KTtcblx0XHR2YXIgaXNTdHJpbmcgPSBpc09iamVjdCAmJiB0b1N0ci5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xuXHRcdHZhciB0aGVLZXlzID0gW107XG5cblx0XHRpZiAoIWlzT2JqZWN0ICYmICFpc0Z1bmN0aW9uICYmICFpc0FyZ3VtZW50cykge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmtleXMgY2FsbGVkIG9uIGEgbm9uLW9iamVjdCcpO1xuXHRcdH1cblxuXHRcdHZhciBza2lwUHJvdG8gPSBoYXNQcm90b0VudW1CdWcgJiYgaXNGdW5jdGlvbjtcblx0XHRpZiAoaXNTdHJpbmcgJiYgb2JqZWN0Lmxlbmd0aCA+IDAgJiYgIWhhcy5jYWxsKG9iamVjdCwgMCkpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0Lmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcoaSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChpc0FyZ3VtZW50cyAmJiBvYmplY3QubGVuZ3RoID4gMCkge1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBvYmplY3QubGVuZ3RoOyArK2opIHtcblx0XHRcdFx0dGhlS2V5cy5wdXNoKFN0cmluZyhqKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAodmFyIG5hbWUgaW4gb2JqZWN0KSB7XG5cdFx0XHRcdGlmICghKHNraXBQcm90byAmJiBuYW1lID09PSAncHJvdG90eXBlJykgJiYgaGFzLmNhbGwob2JqZWN0LCBuYW1lKSkge1xuXHRcdFx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcobmFtZSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGhhc0RvbnRFbnVtQnVnKSB7XG5cdFx0XHR2YXIgc2tpcENvbnN0cnVjdG9yID0gZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGVJZk5vdEJ1Z2d5KG9iamVjdCk7XG5cblx0XHRcdGZvciAodmFyIGsgPSAwOyBrIDwgZG9udEVudW1zLmxlbmd0aDsgKytrKSB7XG5cdFx0XHRcdGlmICghKHNraXBDb25zdHJ1Y3RvciAmJiBkb250RW51bXNba10gPT09ICdjb25zdHJ1Y3RvcicpICYmIGhhcy5jYWxsKG9iamVjdCwgZG9udEVudW1zW2tdKSkge1xuXHRcdFx0XHRcdHRoZUtleXMucHVzaChkb250RW51bXNba10pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGVLZXlzO1xuXHR9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBrZXlzU2hpbTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTIyODpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGlzQXJncyA9IF9fd2VicGFja19yZXF1aXJlX18oOTY4KTtcblxudmFyIG9yaWdLZXlzID0gT2JqZWN0LmtleXM7XG52YXIga2V5c1NoaW0gPSBvcmlnS2V5cyA/IGZ1bmN0aW9uIGtleXMobykgeyByZXR1cm4gb3JpZ0tleXMobyk7IH0gOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDgxNjApO1xuXG52YXIgb3JpZ2luYWxLZXlzID0gT2JqZWN0LmtleXM7XG5cbmtleXNTaGltLnNoaW0gPSBmdW5jdGlvbiBzaGltT2JqZWN0S2V5cygpIHtcblx0aWYgKE9iamVjdC5rZXlzKSB7XG5cdFx0dmFyIGtleXNXb3Jrc1dpdGhBcmd1bWVudHMgPSAoZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly8gU2FmYXJpIDUuMCBidWdcblx0XHRcdHZhciBhcmdzID0gT2JqZWN0LmtleXMoYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiBhcmdzICYmIGFyZ3MubGVuZ3RoID09PSBhcmd1bWVudHMubGVuZ3RoO1xuXHRcdH0oMSwgMikpO1xuXHRcdGlmICgha2V5c1dvcmtzV2l0aEFyZ3VtZW50cykge1xuXHRcdFx0T2JqZWN0LmtleXMgPSBmdW5jdGlvbiBrZXlzKG9iamVjdCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmMtbmFtZS1tYXRjaGluZ1xuXHRcdFx0XHRpZiAoaXNBcmdzKG9iamVjdCkpIHtcblx0XHRcdFx0XHRyZXR1cm4gb3JpZ2luYWxLZXlzKHNsaWNlLmNhbGwob2JqZWN0KSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG9yaWdpbmFsS2V5cyhvYmplY3QpO1xuXHRcdFx0fTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0T2JqZWN0LmtleXMgPSBrZXlzU2hpbTtcblx0fVxuXHRyZXR1cm4gT2JqZWN0LmtleXMgfHwga2V5c1NoaW07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXNTaGltO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5Njg6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdHZhciBzdHIgPSB0b1N0ci5jYWxsKHZhbHVlKTtcblx0dmFyIGlzQXJncyA9IHN0ciA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cdGlmICghaXNBcmdzKSB7XG5cdFx0aXNBcmdzID0gc3RyICE9PSAnW29iamVjdCBBcnJheV0nICYmXG5cdFx0XHR2YWx1ZSAhPT0gbnVsbCAmJlxuXHRcdFx0dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuXHRcdFx0dHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcicgJiZcblx0XHRcdHZhbHVlLmxlbmd0aCA+PSAwICYmXG5cdFx0XHR0b1N0ci5jYWxsKHZhbHVlLmNhbGxlZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cdH1cblx0cmV0dXJuIGlzQXJncztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDk5MDc6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG4vLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2MTA4OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgR2V0SW50cmluc2ljID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MjgpO1xudmFyIGRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjg2KTtcbnZhciBoYXNEZXNjcmlwdG9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oNzIzOSkoKTtcbnZhciBnT1BEID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MzM2KTtcblxudmFyICRUeXBlRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0NjgpO1xudmFyICRmbG9vciA9IEdldEludHJpbnNpYygnJU1hdGguZmxvb3IlJyk7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuJyl9ICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNldEZ1bmN0aW9uTGVuZ3RoKGZuLCBsZW5ndGgpIHtcblx0aWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdgZm5gIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG5cdH1cblx0aWYgKHR5cGVvZiBsZW5ndGggIT09ICdudW1iZXInIHx8IGxlbmd0aCA8IDAgfHwgbGVuZ3RoID4gMHhGRkZGRkZGRiB8fCAkZmxvb3IobGVuZ3RoKSAhPT0gbGVuZ3RoKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2BsZW5ndGhgIG11c3QgYmUgYSBwb3NpdGl2ZSAzMi1iaXQgaW50ZWdlcicpO1xuXHR9XG5cblx0dmFyIGxvb3NlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgISFhcmd1bWVudHNbMl07XG5cblx0dmFyIGZ1bmN0aW9uTGVuZ3RoSXNDb25maWd1cmFibGUgPSB0cnVlO1xuXHR2YXIgZnVuY3Rpb25MZW5ndGhJc1dyaXRhYmxlID0gdHJ1ZTtcblx0aWYgKCdsZW5ndGgnIGluIGZuICYmIGdPUEQpIHtcblx0XHR2YXIgZGVzYyA9IGdPUEQoZm4sICdsZW5ndGgnKTtcblx0XHRpZiAoZGVzYyAmJiAhZGVzYy5jb25maWd1cmFibGUpIHtcblx0XHRcdGZ1bmN0aW9uTGVuZ3RoSXNDb25maWd1cmFibGUgPSBmYWxzZTtcblx0XHR9XG5cdFx0aWYgKGRlc2MgJiYgIWRlc2Mud3JpdGFibGUpIHtcblx0XHRcdGZ1bmN0aW9uTGVuZ3RoSXNXcml0YWJsZSA9IGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdGlmIChmdW5jdGlvbkxlbmd0aElzQ29uZmlndXJhYmxlIHx8IGZ1bmN0aW9uTGVuZ3RoSXNXcml0YWJsZSB8fCAhbG9vc2UpIHtcblx0XHRpZiAoaGFzRGVzY3JpcHRvcnMpIHtcblx0XHRcdGRlZmluZSgvKiogQHR5cGUge1BhcmFtZXRlcnM8ZGVmaW5lPlswXX0gKi8gKGZuKSwgJ2xlbmd0aCcsIGxlbmd0aCwgdHJ1ZSwgdHJ1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlZmluZSgvKiogQHR5cGUge1BhcmFtZXRlcnM8ZGVmaW5lPlswXX0gKi8gKGZuKSwgJ2xlbmd0aCcsIGxlbmd0aCk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBmbjtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDIxMjU6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQmFzZVNlcnZpY2U6ICgpID0+ICgvKiBiaW5kaW5nICovIEJhc2VTZXJ2aWNlKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MDEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNzc3MCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3RleHRkb2N1bWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MDQxKTtcbmZ1bmN0aW9uIF9kZWZpbmVfcHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cblxuXG5cbmNsYXNzIEJhc2VTZXJ2aWNlIHtcbiAgICBhZGREb2N1bWVudChkb2N1bWVudCkge1xuICAgICAgICB0aGlzLmRvY3VtZW50c1tkb2N1bWVudC51cmldID0gdnNjb2RlX2xhbmd1YWdlc2VydmVyX3RleHRkb2N1bWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLyogLlRleHREb2N1bWVudCAqLyAuVi5jcmVhdGUoZG9jdW1lbnQudXJpLCBkb2N1bWVudC5sYW5ndWFnZUlkLCBkb2N1bWVudC52ZXJzaW9uLCBkb2N1bWVudC50ZXh0KTtcbiAgICB9XG4gICAgZ2V0RG9jdW1lbnQodXJpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50c1t1cmldO1xuICAgIH1cbiAgICByZW1vdmVEb2N1bWVudChkb2N1bWVudCkge1xuICAgICAgICBkZWxldGUgdGhpcy5kb2N1bWVudHNbZG9jdW1lbnQudXJpXTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc1tkb2N1bWVudC51cmldKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5vcHRpb25zW2RvY3VtZW50LnVyaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RG9jdW1lbnRWYWx1ZSh1cmkpIHtcbiAgICAgICAgdmFyIF90aGlzX2dldERvY3VtZW50O1xuICAgICAgICByZXR1cm4gKF90aGlzX2dldERvY3VtZW50ID0gdGhpcy5nZXREb2N1bWVudCh1cmkpKSA9PT0gbnVsbCB8fCBfdGhpc19nZXREb2N1bWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXNfZ2V0RG9jdW1lbnQuZ2V0VGV4dCgpO1xuICAgIH1cbiAgICBzZXRWYWx1ZShpZGVudGlmaWVyLCB2YWx1ZSkge1xuICAgICAgICBsZXQgZG9jdW1lbnQgPSB0aGlzLmdldERvY3VtZW50KGlkZW50aWZpZXIudXJpKTtcbiAgICAgICAgaWYgKGRvY3VtZW50KSB7XG4gICAgICAgICAgICBkb2N1bWVudCA9IHZzY29kZV9sYW5ndWFnZXNlcnZlcl90ZXh0ZG9jdW1lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy8qIC5UZXh0RG9jdW1lbnQgKi8gLlYuY3JlYXRlKGRvY3VtZW50LnVyaSwgZG9jdW1lbnQubGFuZ3VhZ2VJZCwgZG9jdW1lbnQudmVyc2lvbiwgdmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudHNbZG9jdW1lbnQudXJpXSA9IGRvY3VtZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldEdsb2JhbE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLmdsb2JhbE9wdGlvbnMgPSBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fTtcbiAgICB9XG4gICAgc2V0V29ya3NwYWNlKHdvcmtzcGFjZVVyaSkge1xuICAgICAgICB0aGlzLndvcmtzcGFjZVVyaSA9IHdvcmtzcGFjZVVyaTtcbiAgICB9XG4gICAgc2V0T3B0aW9ucyhkb2N1bWVudFVyaSwgb3B0aW9ucywgbWVyZ2UgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLm9wdGlvbnNbZG9jdW1lbnRVcmldID0gbWVyZ2UgPyAoMCxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy8qIC5tZXJnZU9iamVjdHMgKi8gLnJMKShvcHRpb25zLCB0aGlzLm9wdGlvbnNbZG9jdW1lbnRVcmldKSA6IG9wdGlvbnM7XG4gICAgfVxuICAgIGdldE9wdGlvbihkb2N1bWVudFVyaSwgb3B0aW9uTmFtZSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zW2RvY3VtZW50VXJpXSAmJiB0aGlzLm9wdGlvbnNbZG9jdW1lbnRVcmldW29wdGlvbk5hbWVdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW2RvY3VtZW50VXJpXVtvcHRpb25OYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdsb2JhbE9wdGlvbnNbb3B0aW9uTmFtZV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXBwbHlEZWx0YXMoaWRlbnRpZmllciwgZGVsdGFzKSB7XG4gICAgICAgIGxldCBkb2N1bWVudCA9IHRoaXMuZ2V0RG9jdW1lbnQoaWRlbnRpZmllci51cmkpO1xuICAgICAgICBpZiAoZG9jdW1lbnQpIHZzY29kZV9sYW5ndWFnZXNlcnZlcl90ZXh0ZG9jdW1lbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy8qIC5UZXh0RG9jdW1lbnQgKi8gLlYudXBkYXRlKGRvY3VtZW50LCBkZWx0YXMsIGlkZW50aWZpZXIudmVyc2lvbik7XG4gICAgfVxuICAgIGFzeW5jIGRvQ29tcGxldGUoZG9jdW1lbnQsIHBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhc3luYyBkb0hvdmVyKGRvY3VtZW50LCBwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgZG9SZXNvbHZlKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFzeW5jIGRvVmFsaWRhdGlvbihkb2N1bWVudCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGZvcm1hdChkb2N1bWVudCwgcmFuZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgfVxuICAgIGFzeW5jIHByb3ZpZGVTaWduYXR1cmVIZWxwKGRvY3VtZW50LCBwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgZmluZERvY3VtZW50SGlnaGxpZ2h0cyhkb2N1bWVudCwgcG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBnZXQgb3B0aW9uc1RvRmlsdGVyRGlhZ25vc3RpY3MoKSB7XG4gICAgICAgIHZhciBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb0lnbm9yZSwgX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvckNvZGVzVG9UcmVhdEFzV2FybmluZywgX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvckNvZGVzVG9UcmVhdEFzSW5mbywgX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9JZ25vcmUsIF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc1dhcm5pbmcsIF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc0luZm87XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvckNvZGVzVG9JZ25vcmU6IChfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb0lnbm9yZSA9IHRoaXMuZ2xvYmFsT3B0aW9ucy5lcnJvckNvZGVzVG9JZ25vcmUpICE9PSBudWxsICYmIF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JDb2Rlc1RvSWdub3JlICE9PSB2b2lkIDAgPyBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb0lnbm9yZSA6IFtdLFxuICAgICAgICAgICAgZXJyb3JDb2Rlc1RvVHJlYXRBc1dhcm5pbmc6IChfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb1RyZWF0QXNXYXJuaW5nID0gdGhpcy5nbG9iYWxPcHRpb25zLmVycm9yQ29kZXNUb1RyZWF0QXNXYXJuaW5nKSAhPT0gbnVsbCAmJiBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb1RyZWF0QXNXYXJuaW5nICE9PSB2b2lkIDAgPyBfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yQ29kZXNUb1RyZWF0QXNXYXJuaW5nIDogW10sXG4gICAgICAgICAgICBlcnJvckNvZGVzVG9UcmVhdEFzSW5mbzogKF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JDb2Rlc1RvVHJlYXRBc0luZm8gPSB0aGlzLmdsb2JhbE9wdGlvbnMuZXJyb3JDb2Rlc1RvVHJlYXRBc0luZm8pICE9PSBudWxsICYmIF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JDb2Rlc1RvVHJlYXRBc0luZm8gIT09IHZvaWQgMCA/IF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JDb2Rlc1RvVHJlYXRBc0luZm8gOiBbXSxcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZXNUb0lnbm9yZTogKF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvSWdub3JlID0gdGhpcy5nbG9iYWxPcHRpb25zLmVycm9yTWVzc2FnZXNUb0lnbm9yZSkgIT09IG51bGwgJiYgX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9JZ25vcmUgIT09IHZvaWQgMCA/IF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvSWdub3JlIDogW10sXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2VzVG9UcmVhdEFzV2FybmluZzogKF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc1dhcm5pbmcgPSB0aGlzLmdsb2JhbE9wdGlvbnMuZXJyb3JNZXNzYWdlc1RvVHJlYXRBc1dhcm5pbmcpICE9PSBudWxsICYmIF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc1dhcm5pbmcgIT09IHZvaWQgMCA/IF90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc1dhcm5pbmcgOiBbXSxcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZXNUb1RyZWF0QXNJbmZvOiAoX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9UcmVhdEFzSW5mbyA9IHRoaXMuZ2xvYmFsT3B0aW9ucy5lcnJvck1lc3NhZ2VzVG9UcmVhdEFzSW5mbykgIT09IG51bGwgJiYgX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9UcmVhdEFzSW5mbyAhPT0gdm9pZCAwID8gX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvck1lc3NhZ2VzVG9UcmVhdEFzSW5mbyA6IFtdXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldFNlbWFudGljVG9rZW5zKGRvY3VtZW50LCByYW5nZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNsb3NlQ29ubmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBnZXRDb2RlQWN0aW9ucyhkb2N1bWVudCwgcmFuZ2UsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICB9XG4gICAgZXhlY3V0ZUNvbW1hbmQoY29tbWFuZCwgYXJncykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgIH1cbiAgICBzZW5kQXBwbGllZFJlc3VsdChyZXN1bHQsIGNhbGxiYWNrSWQpIHt9XG4gICAgY29uc3RydWN0b3IobW9kZSwgd29ya3NwYWNlVXJpKXtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInNlcnZpY2VOYW1lXCIsIHZvaWQgMCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJtb2RlXCIsIHZvaWQgMCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJkb2N1bWVudHNcIiwge30pO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwib3B0aW9uc1wiLCB7fSk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJnbG9iYWxPcHRpb25zXCIsIHt9KTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInNlcnZpY2VEYXRhXCIsIHZvaWQgMCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJzZXJ2aWNlQ2FwYWJpbGl0aWVzXCIsIHt9KTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcIndvcmtzcGFjZVVyaVwiLCB2b2lkIDApO1xuICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRoaXMsIFwiY2xpZW50Q2FwYWJpbGl0aWVzXCIsIHtcbiAgICAgICAgICAgIHRleHREb2N1bWVudDoge1xuICAgICAgICAgICAgICAgIGRpYWdub3N0aWM6IHtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pY1JlZ2lzdHJhdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRlZERvY3VtZW50U3VwcG9ydDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcHVibGlzaERpYWdub3N0aWNzOiB7XG4gICAgICAgICAgICAgICAgICAgIHJlbGF0ZWRJbmZvcm1hdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvblN1cHBvcnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB0YWdTdXBwb3J0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVNldDogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLkRpYWdub3N0aWNUYWcuVW5uZWNlc3NhcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3Byb3RvY29sX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uRGlhZ25vc3RpY1RhZy5EZXByZWNhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhvdmVyOiB7XG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWNSZWdpc3RyYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRGb3JtYXQ6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXJrZG93bicsXG4gICAgICAgICAgICAgICAgICAgICAgICAncGxhaW50ZXh0J1xuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzeW5jaHJvbml6YXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pY1JlZ2lzdHJhdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgd2lsbFNhdmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBkaWRTYXZlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgd2lsbFNhdmVXYWl0VW50aWw6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmb3JtYXR0aW5nOiB7XG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWNSZWdpc3RyYXRpb246IHRydWVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvbXBsZXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pY1JlZ2lzdHJhdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGlvbkl0ZW06IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNuaXBwZXRTdXBwb3J0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWl0Q2hhcmFjdGVyc1N1cHBvcnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRhdGlvbkZvcm1hdDogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdtYXJrZG93bicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3BsYWludGV4dCdcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXByZWNhdGVkU3VwcG9ydDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVzZWxlY3RTdXBwb3J0OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0U3VwcG9ydDogZmFsc2VcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZUhlbHA6IHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlSW5mb3JtYXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50YXRpb25Gb3JtYXQ6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbWFya2Rvd24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwbGFpbnRleHQnXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlUGFyYW1ldGVyU3VwcG9ydDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkb2N1bWVudEhpZ2hsaWdodDoge1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljUmVnaXN0cmF0aW9uOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZW1hbnRpY1Rva2Vuczoge1xuICAgICAgICAgICAgICAgICAgICBtdWx0aWxpbmVUb2tlblN1cHBvcnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBvdmVybGFwcGluZ1Rva2VuU3VwcG9ydDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHRva2VuVHlwZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbk1vZGlmaWVyczogW10sXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwicmVsYXRpdmVcIlxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVsbDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGF1Z21lbnRzU3ludGF4VG9rZW5zOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb2RlQWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWNSZWdpc3RyYXRpb246IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd29ya3NwYWNlOiB7XG4gICAgICAgICAgICAgICAgZGlkQ2hhbmdlQ29uZmlndXJhdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljUmVnaXN0cmF0aW9uOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBleGVjdXRlQ29tbWFuZDoge1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljUmVnaXN0cmF0aW9uOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhcHBseUVkaXQ6IHRydWUsXG4gICAgICAgICAgICAgICAgd29ya3NwYWNlRWRpdDoge1xuICAgICAgICAgICAgICAgICAgICBmYWlsdXJlSGFuZGxpbmc6IFwiYWJvcnRcIixcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplc0xpbmVFbmRpbmdzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRDaGFuZ2VzOiBmYWxzZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgICAgIHRoaXMud29ya3NwYWNlVXJpID0gd29ya3NwYWNlVXJpO1xuICAgIH1cbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzc3MDpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBUazogKCkgPT4gKC8qIGJpbmRpbmcgKi8gY2hlY2tWYWx1ZUFnYWluc3RSZWdleHBBcnJheSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIHJMOiAoKSA9PiAoLyogYmluZGluZyAqLyBtZXJnZU9iamVjdHMpXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIHVudXNlZCBoYXJtb255IGV4cG9ydHMgbm90RW1wdHksIG1lcmdlUmFuZ2VzLCBjb252ZXJ0VG9VcmkgKi9cblxuZnVuY3Rpb24gbWVyZ2VPYmplY3RzKG9iajEsIG9iajIsIGV4Y2x1ZGVVbmRlZmluZWQgPSBmYWxzZSkge1xuICAgIGlmICghb2JqMSkgcmV0dXJuIG9iajI7XG4gICAgaWYgKCFvYmoyKSByZXR1cm4gb2JqMTtcbiAgICBpZiAoZXhjbHVkZVVuZGVmaW5lZCkge1xuICAgICAgICBvYmoxID0gZXhjbHVkZVVuZGVmaW5lZFZhbHVlcyhvYmoxKTtcbiAgICAgICAgb2JqMiA9IGV4Y2x1ZGVVbmRlZmluZWRWYWx1ZXMob2JqMik7XG4gICAgfVxuICAgIGNvbnN0IG1lcmdlZE9iamVjdHMgPSB7XG4gICAgICAgIC4uLm9iajIsXG4gICAgICAgIC4uLm9iajFcbiAgICB9OyAvLyBHaXZlIHByaW9yaXR5IHRvIG9iajEgdmFsdWVzIGJ5IHNwcmVhZGluZyBvYmoyIGZpcnN0LCB0aGVuIG9iajFcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhtZXJnZWRPYmplY3RzKSl7XG4gICAgICAgIGlmIChvYmoxW2tleV0gJiYgb2JqMltrZXldKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmoxW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkT2JqZWN0c1trZXldID0gb2JqMVtrZXldLmNvbmNhdChvYmoyW2tleV0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iajJba2V5XSkpIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRPYmplY3RzW2tleV0gPSBvYmoyW2tleV0uY29uY2F0KG9iajFba2V5XSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmoxW2tleV0gPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmoyW2tleV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkT2JqZWN0c1trZXldID0gbWVyZ2VPYmplY3RzKG9iajFba2V5XSwgb2JqMltrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VkT2JqZWN0cztcbn1cbmZ1bmN0aW9uIGV4Y2x1ZGVVbmRlZmluZWRWYWx1ZXMob2JqKSB7XG4gICAgY29uc3QgZmlsdGVyZWRFbnRyaWVzID0gT2JqZWN0LmVudHJpZXMob2JqKS5maWx0ZXIoKFtfLCB2YWx1ZV0pPT52YWx1ZSAhPT0gdW5kZWZpbmVkKTtcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKGZpbHRlcmVkRW50cmllcyk7XG59XG5mdW5jdGlvbiBub3RFbXB0eSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xufVxuLy90YWtlbiB3aXRoIHNtYWxsIGNoYW5nZXMgZnJvbSBhY2UtY29kZVxuZnVuY3Rpb24gbWVyZ2VSYW5nZXMocmFuZ2VzKSB7XG4gICAgdmFyIGxpc3QgPSByYW5nZXM7XG4gICAgbGlzdCA9IGxpc3Quc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBjb21wYXJlUG9pbnRzKGEuc3RhcnQsIGIuc3RhcnQpO1xuICAgIH0pO1xuICAgIHZhciBuZXh0ID0gbGlzdFswXSwgcmFuZ2U7XG4gICAgZm9yKHZhciBpID0gMTsgaSA8IGxpc3QubGVuZ3RoOyBpKyspe1xuICAgICAgICByYW5nZSA9IG5leHQ7XG4gICAgICAgIG5leHQgPSBsaXN0W2ldO1xuICAgICAgICB2YXIgY21wID0gY29tcGFyZVBvaW50cyhyYW5nZS5lbmQsIG5leHQuc3RhcnQpO1xuICAgICAgICBpZiAoY21wIDwgMCkgY29udGludWU7XG4gICAgICAgIGlmIChjbXAgPT0gMCAmJiAhcmFuZ2UuaXNFbXB0eSgpICYmICFuZXh0LmlzRW1wdHkoKSkgY29udGludWU7XG4gICAgICAgIGlmIChjb21wYXJlUG9pbnRzKHJhbmdlLmVuZCwgbmV4dC5lbmQpIDwgMCkge1xuICAgICAgICAgICAgcmFuZ2UuZW5kLnJvdyA9IG5leHQuZW5kLnJvdztcbiAgICAgICAgICAgIHJhbmdlLmVuZC5jb2x1bW4gPSBuZXh0LmVuZC5jb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIG5leHQgPSByYW5nZTtcbiAgICAgICAgaS0tO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdDtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVQb2ludHMocDEsIHAyKSB7XG4gICAgcmV0dXJuIHAxLnJvdyAtIHAyLnJvdyB8fCBwMS5jb2x1bW4gLSBwMi5jb2x1bW47XG59XG5mdW5jdGlvbiBjaGVja1ZhbHVlQWdhaW5zdFJlZ2V4cEFycmF5KHZhbHVlLCByZWdleHBBcnJheSkge1xuICAgIGlmICghcmVnZXhwQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgcmVnZXhwQXJyYXkubGVuZ3RoOyBpKyspe1xuICAgICAgICBpZiAocmVnZXhwQXJyYXlbaV0udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb1VyaShmaWxlUGF0aCkge1xuICAgIC8vYWxyZWFkeSBVUklcbiAgICBpZiAoZmlsZVBhdGguc3RhcnRzV2l0aChcImZpbGU6Ly8vXCIpKSB7XG4gICAgICAgIHJldHVybiBmaWxlUGF0aDtcbiAgICB9XG4gICAgcmV0dXJuIFVSSS5maWxlKGZpbGVQYXRoKS50b1N0cmluZygpO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1MjcyOlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTUzMTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBDdXJyZW50bHkgaW4gc3luYyB3aXRoIE5vZGUuanMgbGliL2ludGVybmFsL3V0aWwvdHlwZXMuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvMTEyY2M3YzI3NTUxMjU0YWEyYjE3MDk4ZmI3NzQ4NjdmMDVlZDBkOVxuXG5cblxudmFyIGlzQXJndW1lbnRzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Mzg3KTtcbnZhciBpc0dlbmVyYXRvckZ1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjI1KTtcbnZhciB3aGljaFR5cGVkQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3MzApO1xudmFyIGlzVHlwZWRBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oNTk0Myk7XG5cbmZ1bmN0aW9uIHVuY3VycnlUaGlzKGYpIHtcbiAgcmV0dXJuIGYuY2FsbC5iaW5kKGYpO1xufVxuXG52YXIgQmlnSW50U3VwcG9ydGVkID0gdHlwZW9mIEJpZ0ludCAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgU3ltYm9sU3VwcG9ydGVkID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCc7XG5cbnZhciBPYmplY3RUb1N0cmluZyA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpO1xuXG52YXIgbnVtYmVyVmFsdWUgPSB1bmN1cnJ5VGhpcyhOdW1iZXIucHJvdG90eXBlLnZhbHVlT2YpO1xudmFyIHN0cmluZ1ZhbHVlID0gdW5jdXJyeVRoaXMoU3RyaW5nLnByb3RvdHlwZS52YWx1ZU9mKTtcbnZhciBib29sZWFuVmFsdWUgPSB1bmN1cnJ5VGhpcyhCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mKTtcblxuaWYgKEJpZ0ludFN1cHBvcnRlZCkge1xuICB2YXIgYmlnSW50VmFsdWUgPSB1bmN1cnJ5VGhpcyhCaWdJbnQucHJvdG90eXBlLnZhbHVlT2YpO1xufVxuXG5pZiAoU3ltYm9sU3VwcG9ydGVkKSB7XG4gIHZhciBzeW1ib2xWYWx1ZSA9IHVuY3VycnlUaGlzKFN5bWJvbC5wcm90b3R5cGUudmFsdWVPZik7XG59XG5cbmZ1bmN0aW9uIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIHByb3RvdHlwZVZhbHVlT2YpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICBwcm90b3R5cGVWYWx1ZU9mKHZhbHVlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydHMuaXNBcmd1bWVudHNPYmplY3QgPSBpc0FyZ3VtZW50c09iamVjdDtcbmV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGlzR2VuZXJhdG9yRnVuY3Rpb247XG5leHBvcnRzLmlzVHlwZWRBcnJheSA9IGlzVHlwZWRBcnJheTtcblxuLy8gVGFrZW4gZnJvbSBoZXJlIGFuZCBtb2RpZmllZCBmb3IgYmV0dGVyIGJyb3dzZXIgc3VwcG9ydFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9wLWlzLXByb21pc2UvYmxvYi9jZGEzNWE1MTNiZGEwM2Y5NzdhZDVjZGUzYTA3OWQyMzdlODJkN2VmL2luZGV4LmpzXG5mdW5jdGlvbiBpc1Byb21pc2UoaW5wdXQpIHtcblx0cmV0dXJuIChcblx0XHQoXG5cdFx0XHR0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiZcblx0XHRcdGlucHV0IGluc3RhbmNlb2YgUHJvbWlzZVxuXHRcdCkgfHxcblx0XHQoXG5cdFx0XHRpbnB1dCAhPT0gbnVsbCAmJlxuXHRcdFx0dHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJlxuXHRcdFx0dHlwZW9mIGlucHV0LnRoZW4gPT09ICdmdW5jdGlvbicgJiZcblx0XHRcdHR5cGVvZiBpbnB1dC5jYXRjaCA9PT0gJ2Z1bmN0aW9uJ1xuXHRcdClcblx0KTtcbn1cbmV4cG9ydHMuaXNQcm9taXNlID0gaXNQcm9taXNlO1xuXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyh2YWx1ZSkge1xuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcpIHtcbiAgICByZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgaXNUeXBlZEFycmF5KHZhbHVlKSB8fFxuICAgIGlzRGF0YVZpZXcodmFsdWUpXG4gICk7XG59XG5leHBvcnRzLmlzQXJyYXlCdWZmZXJWaWV3ID0gaXNBcnJheUJ1ZmZlclZpZXc7XG5cblxuZnVuY3Rpb24gaXNVaW50OEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDhBcnJheSc7XG59XG5leHBvcnRzLmlzVWludDhBcnJheSA9IGlzVWludDhBcnJheTtcblxuZnVuY3Rpb24gaXNVaW50OENsYW1wZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQ4Q2xhbXBlZEFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50OENsYW1wZWRBcnJheSA9IGlzVWludDhDbGFtcGVkQXJyYXk7XG5cbmZ1bmN0aW9uIGlzVWludDE2QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50MTZBcnJheSc7XG59XG5leHBvcnRzLmlzVWludDE2QXJyYXkgPSBpc1VpbnQxNkFycmF5O1xuXG5mdW5jdGlvbiBpc1VpbnQzMkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDMyQXJyYXknO1xufVxuZXhwb3J0cy5pc1VpbnQzMkFycmF5ID0gaXNVaW50MzJBcnJheTtcblxuZnVuY3Rpb24gaXNJbnQ4QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdJbnQ4QXJyYXknO1xufVxuZXhwb3J0cy5pc0ludDhBcnJheSA9IGlzSW50OEFycmF5O1xuXG5mdW5jdGlvbiBpc0ludDE2QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdJbnQxNkFycmF5Jztcbn1cbmV4cG9ydHMuaXNJbnQxNkFycmF5ID0gaXNJbnQxNkFycmF5O1xuXG5mdW5jdGlvbiBpc0ludDMyQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdJbnQzMkFycmF5Jztcbn1cbmV4cG9ydHMuaXNJbnQzMkFycmF5ID0gaXNJbnQzMkFycmF5O1xuXG5mdW5jdGlvbiBpc0Zsb2F0MzJBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0Zsb2F0MzJBcnJheSc7XG59XG5leHBvcnRzLmlzRmxvYXQzMkFycmF5ID0gaXNGbG9hdDMyQXJyYXk7XG5cbmZ1bmN0aW9uIGlzRmxvYXQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnRmxvYXQ2NEFycmF5Jztcbn1cbmV4cG9ydHMuaXNGbG9hdDY0QXJyYXkgPSBpc0Zsb2F0NjRBcnJheTtcblxuZnVuY3Rpb24gaXNCaWdJbnQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnQmlnSW50NjRBcnJheSc7XG59XG5leHBvcnRzLmlzQmlnSW50NjRBcnJheSA9IGlzQmlnSW50NjRBcnJheTtcblxuZnVuY3Rpb24gaXNCaWdVaW50NjRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0JpZ1VpbnQ2NEFycmF5Jztcbn1cbmV4cG9ydHMuaXNCaWdVaW50NjRBcnJheSA9IGlzQmlnVWludDY0QXJyYXk7XG5cbmZ1bmN0aW9uIGlzTWFwVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgTWFwXSc7XG59XG5pc01hcFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBNYXAgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzTWFwVG9TdHJpbmcobmV3IE1hcCgpKVxuKTtcblxuZnVuY3Rpb24gaXNNYXAodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzTWFwVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNNYXBUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgTWFwO1xufVxuZXhwb3J0cy5pc01hcCA9IGlzTWFwO1xuXG5mdW5jdGlvbiBpc1NldFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFNldF0nO1xufVxuaXNTZXRUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc1NldFRvU3RyaW5nKG5ldyBTZXQoKSlcbik7XG5mdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNTZXRUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc1NldFRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBTZXQ7XG59XG5leHBvcnRzLmlzU2V0ID0gaXNTZXQ7XG5cbmZ1bmN0aW9uIGlzV2Vha01hcFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFdlYWtNYXBdJztcbn1cbmlzV2Vha01hcFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBXZWFrTWFwICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc1dlYWtNYXBUb1N0cmluZyhuZXcgV2Vha01hcCgpKVxuKTtcbmZ1bmN0aW9uIGlzV2Vha01hcCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIFdlYWtNYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzV2Vha01hcFRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzV2Vha01hcFRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBXZWFrTWFwO1xufVxuZXhwb3J0cy5pc1dlYWtNYXAgPSBpc1dlYWtNYXA7XG5cbmZ1bmN0aW9uIGlzV2Vha1NldFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFdlYWtTZXRdJztcbn1cbmlzV2Vha1NldFRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBXZWFrU2V0ICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc1dlYWtTZXRUb1N0cmluZyhuZXcgV2Vha1NldCgpKVxuKTtcbmZ1bmN0aW9uIGlzV2Vha1NldCh2YWx1ZSkge1xuICByZXR1cm4gaXNXZWFrU2V0VG9TdHJpbmcodmFsdWUpO1xufVxuZXhwb3J0cy5pc1dlYWtTZXQgPSBpc1dlYWtTZXQ7XG5cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nO1xufVxuaXNBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmcgPSAoXG4gIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNBcnJheUJ1ZmZlclRvU3RyaW5nKG5ldyBBcnJheUJ1ZmZlcigpKVxuKTtcbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzQXJyYXlCdWZmZXJUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI7XG59XG5leHBvcnRzLmlzQXJyYXlCdWZmZXIgPSBpc0FycmF5QnVmZmVyO1xuXG5mdW5jdGlvbiBpc0RhdGFWaWV3VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgRGF0YVZpZXddJztcbn1cbmlzRGF0YVZpZXdUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gIHR5cGVvZiBEYXRhVmlldyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNEYXRhVmlld1RvU3RyaW5nKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSksIDAsIDEpKVxuKTtcbmZ1bmN0aW9uIGlzRGF0YVZpZXcodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBEYXRhVmlldyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNEYXRhVmlld1RvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzRGF0YVZpZXdUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgRGF0YVZpZXc7XG59XG5leHBvcnRzLmlzRGF0YVZpZXcgPSBpc0RhdGFWaWV3O1xuXG4vLyBTdG9yZSBhIGNvcHkgb2YgU2hhcmVkQXJyYXlCdWZmZXIgaW4gY2FzZSBpdCdzIGRlbGV0ZWQgZWxzZXdoZXJlXG52YXIgU2hhcmVkQXJyYXlCdWZmZXJDb3B5ID0gdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyA/IFNoYXJlZEFycmF5QnVmZmVyIDogdW5kZWZpbmVkO1xuZnVuY3Rpb24gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFNoYXJlZEFycmF5QnVmZmVyXSc7XG59XG5mdW5jdGlvbiBpc1NoYXJlZEFycmF5QnVmZmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXJDb3B5ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmcgPSBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcobmV3IFNoYXJlZEFycmF5QnVmZmVyQ29weSgpKTtcbiAgfVxuXG4gIHJldHVybiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlckNvcHk7XG59XG5leHBvcnRzLmlzU2hhcmVkQXJyYXlCdWZmZXIgPSBpc1NoYXJlZEFycmF5QnVmZmVyO1xuXG5mdW5jdGlvbiBpc0FzeW5jRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nO1xufVxuZXhwb3J0cy5pc0FzeW5jRnVuY3Rpb24gPSBpc0FzeW5jRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzTWFwSXRlcmF0b3IodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgTWFwIEl0ZXJhdG9yXSc7XG59XG5leHBvcnRzLmlzTWFwSXRlcmF0b3IgPSBpc01hcEl0ZXJhdG9yO1xuXG5mdW5jdGlvbiBpc1NldEl0ZXJhdG9yKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFNldCBJdGVyYXRvcl0nO1xufVxuZXhwb3J0cy5pc1NldEl0ZXJhdG9yID0gaXNTZXRJdGVyYXRvcjtcblxuZnVuY3Rpb24gaXNHZW5lcmF0b3JPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgR2VuZXJhdG9yXSc7XG59XG5leHBvcnRzLmlzR2VuZXJhdG9yT2JqZWN0ID0gaXNHZW5lcmF0b3JPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZSh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBXZWJBc3NlbWJseS5Nb2R1bGVdJztcbn1cbmV4cG9ydHMuaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlID0gaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlO1xuXG5mdW5jdGlvbiBpc051bWJlck9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgbnVtYmVyVmFsdWUpO1xufVxuZXhwb3J0cy5pc051bWJlck9iamVjdCA9IGlzTnVtYmVyT2JqZWN0O1xuXG5mdW5jdGlvbiBpc1N0cmluZ09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgc3RyaW5nVmFsdWUpO1xufVxuZXhwb3J0cy5pc1N0cmluZ09iamVjdCA9IGlzU3RyaW5nT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW5PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIGJvb2xlYW5WYWx1ZSk7XG59XG5leHBvcnRzLmlzQm9vbGVhbk9iamVjdCA9IGlzQm9vbGVhbk9iamVjdDtcblxuZnVuY3Rpb24gaXNCaWdJbnRPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIEJpZ0ludFN1cHBvcnRlZCAmJiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBiaWdJbnRWYWx1ZSk7XG59XG5leHBvcnRzLmlzQmlnSW50T2JqZWN0ID0gaXNCaWdJbnRPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBTeW1ib2xTdXBwb3J0ZWQgJiYgY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgc3ltYm9sVmFsdWUpO1xufVxuZXhwb3J0cy5pc1N5bWJvbE9iamVjdCA9IGlzU3ltYm9sT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0JveGVkUHJpbWl0aXZlKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgaXNOdW1iZXJPYmplY3QodmFsdWUpIHx8XG4gICAgaXNTdHJpbmdPYmplY3QodmFsdWUpIHx8XG4gICAgaXNCb29sZWFuT2JqZWN0KHZhbHVlKSB8fFxuICAgIGlzQmlnSW50T2JqZWN0KHZhbHVlKSB8fFxuICAgIGlzU3ltYm9sT2JqZWN0KHZhbHVlKVxuICApO1xufVxuZXhwb3J0cy5pc0JveGVkUHJpbWl0aXZlID0gaXNCb3hlZFByaW1pdGl2ZTtcblxuZnVuY3Rpb24gaXNBbnlBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnICYmIChcbiAgICBpc0FycmF5QnVmZmVyKHZhbHVlKSB8fFxuICAgIGlzU2hhcmVkQXJyYXlCdWZmZXIodmFsdWUpXG4gICk7XG59XG5leHBvcnRzLmlzQW55QXJyYXlCdWZmZXIgPSBpc0FueUFycmF5QnVmZmVyO1xuXG5bJ2lzUHJveHknLCAnaXNFeHRlcm5hbCcsICdpc01vZHVsZU5hbWVzcGFjZU9iamVjdCddLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBtZXRob2QsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWV0aG9kICsgJyBpcyBub3Qgc3VwcG9ydGVkIGluIHVzZXJsYW5kJyk7XG4gICAgfVxuICB9KTtcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2ODI3OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vKiBwcm92aWRlZCBkZXBlbmRlbmN5ICovIHZhciBwcm9jZXNzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OTA3KTtcbi8qIHByb3ZpZGVkIGRlcGVuZGVuY3kgKi8gdmFyIGNvbnNvbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzNjQpO1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgfHxcbiAgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmopIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgdmFyIGRlc2NyaXB0b3JzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZXNjcmlwdG9yc1trZXlzW2ldXSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXlzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc2NyaXB0b3JzO1xuICB9O1xuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0VudlJlZ2V4ID0gL14kLztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfREVCVUcpIHtcbiAgdmFyIGRlYnVnRW52ID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRztcbiAgZGVidWdFbnYgPSBkZWJ1Z0Vudi5yZXBsYWNlKC9bfFxcXFx7fSgpW1xcXV4kKz8uXS9nLCAnXFxcXCQmJylcbiAgICAucmVwbGFjZSgvXFwqL2csICcuKicpXG4gICAgLnJlcGxhY2UoLywvZywgJyR8XicpXG4gICAgLnRvVXBwZXJDYXNlKCk7XG4gIGRlYnVnRW52UmVnZXggPSBuZXcgUmVnRXhwKCdeJyArIGRlYnVnRW52ICsgJyQnLCAnaScpO1xufVxuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChkZWJ1Z0VudlJlZ2V4LnRlc3Qoc2V0KSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zbGljZSgyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEsIC0xKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5leHBvcnRzLnR5cGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTMxKTtcblxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcbmV4cG9ydHMudHlwZXMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5leHBvcnRzLnR5cGVzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuZXhwb3J0cy50eXBlcy5pc05hdGl2ZUVycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IF9fd2VicGFja19yZXF1aXJlX18oNTI3Mik7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IF9fd2VicGFja19yZXF1aXJlX18oNTYxNSk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG52YXIga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgPyBTeW1ib2woJ3V0aWwucHJvbWlzaWZ5LmN1c3RvbScpIDogdW5kZWZpbmVkO1xuXG5leHBvcnRzLnByb21pc2lmeSA9IGZ1bmN0aW9uIHByb21pc2lmeShvcmlnaW5hbCkge1xuICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG5cbiAgaWYgKGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCAmJiBvcmlnaW5hbFtrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xdKSB7XG4gICAgdmFyIGZuID0gb3JpZ2luYWxba0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXTtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJ1dGlsLnByb21pc2lmeS5jdXN0b21cIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wsIHtcbiAgICAgIHZhbHVlOiBmbiwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgZnVuY3Rpb24gZm4oKSB7XG4gICAgdmFyIHByb21pc2VSZXNvbHZlLCBwcm9taXNlUmVqZWN0O1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgcHJvbWlzZVJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcblxuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cbiAgICBhcmdzLnB1c2goZnVuY3Rpb24gKGVyciwgdmFsdWUpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcHJvbWlzZVJlamVjdChlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZVJlc29sdmUodmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcHJvbWlzZVJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGZuLCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3JpZ2luYWwpKTtcblxuICBpZiAoa0N1c3RvbVByb21pc2lmaWVkU3ltYm9sKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCwge1xuICAgIHZhbHVlOiBmbiwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoXG4gICAgZm4sXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvcmlnaW5hbClcbiAgKTtcbn1cblxuZXhwb3J0cy5wcm9taXNpZnkuY3VzdG9tID0ga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXG5cbmZ1bmN0aW9uIGNhbGxiYWNraWZ5T25SZWplY3RlZChyZWFzb24sIGNiKSB7XG4gIC8vIGAhcmVhc29uYCBndWFyZCBpbnNwaXJlZCBieSBibHVlYmlyZCAoUmVmOiBodHRwczovL2dvby5nbC90NUlTNk0pLlxuICAvLyBCZWNhdXNlIGBudWxsYCBpcyBhIHNwZWNpYWwgZXJyb3IgdmFsdWUgaW4gY2FsbGJhY2tzIHdoaWNoIG1lYW5zIFwibm8gZXJyb3JcbiAgLy8gb2NjdXJyZWRcIiwgd2UgZXJyb3Itd3JhcCBzbyB0aGUgY2FsbGJhY2sgY29uc3VtZXIgY2FuIGRpc3Rpbmd1aXNoIGJldHdlZW5cbiAgLy8gXCJ0aGUgcHJvbWlzZSByZWplY3RlZCB3aXRoIG51bGxcIiBvciBcInRoZSBwcm9taXNlIGZ1bGZpbGxlZCB3aXRoIHVuZGVmaW5lZFwiLlxuICBpZiAoIXJlYXNvbikge1xuICAgIHZhciBuZXdSZWFzb24gPSBuZXcgRXJyb3IoJ1Byb21pc2Ugd2FzIHJlamVjdGVkIHdpdGggYSBmYWxzeSB2YWx1ZScpO1xuICAgIG5ld1JlYXNvbi5yZWFzb24gPSByZWFzb247XG4gICAgcmVhc29uID0gbmV3UmVhc29uO1xuICB9XG4gIHJldHVybiBjYihyZWFzb24pO1xufVxuXG5mdW5jdGlvbiBjYWxsYmFja2lmeShvcmlnaW5hbCkge1xuICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwib3JpZ2luYWxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgfVxuXG4gIC8vIFdlIERPIE5PVCByZXR1cm4gdGhlIHByb21pc2UgYXMgaXQgZ2l2ZXMgdGhlIHVzZXIgYSBmYWxzZSBzZW5zZSB0aGF0XG4gIC8vIHRoZSBwcm9taXNlIGlzIGFjdHVhbGx5IHNvbWVob3cgcmVsYXRlZCB0byB0aGUgY2FsbGJhY2sncyBleGVjdXRpb25cbiAgLy8gYW5kIHRoYXQgdGhlIGNhbGxiYWNrIHRocm93aW5nIHdpbGwgcmVqZWN0IHRoZSBwcm9taXNlLlxuICBmdW5jdGlvbiBjYWxsYmFja2lmaWVkKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cblxuICAgIHZhciBtYXliZUNiID0gYXJncy5wb3AoKTtcbiAgICBpZiAodHlwZW9mIG1heWJlQ2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBsYXN0IGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICAgIH1cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNiID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbWF5YmVDYi5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgLy8gSW4gdHJ1ZSBub2RlIHN0eWxlIHdlIHByb2Nlc3MgdGhlIGNhbGxiYWNrIG9uIGBuZXh0VGlja2Agd2l0aCBhbGwgdGhlXG4gICAgLy8gaW1wbGljYXRpb25zIChzdGFjaywgYHVuY2F1Z2h0RXhjZXB0aW9uYCwgYGFzeW5jX2hvb2tzYClcbiAgICBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKVxuICAgICAgLnRoZW4oZnVuY3Rpb24ocmV0KSB7IHByb2Nlc3MubmV4dFRpY2soY2IuYmluZChudWxsLCBudWxsLCByZXQpKSB9LFxuICAgICAgICAgICAgZnVuY3Rpb24ocmVqKSB7IHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2tpZnlPblJlamVjdGVkLmJpbmQobnVsbCwgcmVqLCBjYikpIH0pO1xuICB9XG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGNhbGxiYWNraWZpZWQsIE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbCkpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjYWxsYmFja2lmaWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9yaWdpbmFsKSk7XG4gIHJldHVybiBjYWxsYmFja2lmaWVkO1xufVxuZXhwb3J0cy5jYWxsYmFja2lmeSA9IGNhbGxiYWNraWZ5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5MjA4OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MTEwKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDkxMTA6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLmNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uID0gZXhwb3J0cy5Ccm93c2VyTWVzc2FnZVdyaXRlciA9IGV4cG9ydHMuQnJvd3Nlck1lc3NhZ2VSZWFkZXIgPSB2b2lkIDA7XG5jb25zdCByaWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzMxMik7XG4vLyBJbnN0YWxsIHRoZSBicm93c2VyIHJ1bnRpbWUgYWJzdHJhY3QuXG5yaWxfMS5kZWZhdWx0Lmluc3RhbGwoKTtcbmNvbnN0IGFwaV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NjcyKTtcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDc2NzIpLCBleHBvcnRzKTtcbmNsYXNzIEJyb3dzZXJNZXNzYWdlUmVhZGVyIGV4dGVuZHMgYXBpXzEuQWJzdHJhY3RNZXNzYWdlUmVhZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihwb3J0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX29uRGF0YSA9IG5ldyBhcGlfMS5FbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VMaXN0ZW5lciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fb25EYXRhLmZpcmUoZXZlbnQuZGF0YSk7XG4gICAgICAgIH07XG4gICAgICAgIHBvcnQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZXZlbnQpID0+IHRoaXMuZmlyZUVycm9yKGV2ZW50KSk7XG4gICAgICAgIHBvcnQub25tZXNzYWdlID0gdGhpcy5fbWVzc2FnZUxpc3RlbmVyO1xuICAgIH1cbiAgICBsaXN0ZW4oY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uRGF0YS5ldmVudChjYWxsYmFjayk7XG4gICAgfVxufVxuZXhwb3J0cy5Ccm93c2VyTWVzc2FnZVJlYWRlciA9IEJyb3dzZXJNZXNzYWdlUmVhZGVyO1xuY2xhc3MgQnJvd3Nlck1lc3NhZ2VXcml0ZXIgZXh0ZW5kcyBhcGlfMS5BYnN0cmFjdE1lc3NhZ2VXcml0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHBvcnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wb3J0ID0gcG9ydDtcbiAgICAgICAgdGhpcy5lcnJvckNvdW50ID0gMDtcbiAgICAgICAgcG9ydC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIChldmVudCkgPT4gdGhpcy5maXJlRXJyb3IoZXZlbnQpKTtcbiAgICB9XG4gICAgd3JpdGUobXNnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnBvcnQucG9zdE1lc3NhZ2UobXNnKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IsIG1zZyk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUVycm9yKGVycm9yLCBtc2cpIHtcbiAgICAgICAgdGhpcy5lcnJvckNvdW50Kys7XG4gICAgICAgIHRoaXMuZmlyZUVycm9yKGVycm9yLCBtc2csIHRoaXMuZXJyb3JDb3VudCk7XG4gICAgfVxuICAgIGVuZCgpIHtcbiAgICB9XG59XG5leHBvcnRzLkJyb3dzZXJNZXNzYWdlV3JpdGVyID0gQnJvd3Nlck1lc3NhZ2VXcml0ZXI7XG5mdW5jdGlvbiBjcmVhdGVNZXNzYWdlQ29ubmVjdGlvbihyZWFkZXIsIHdyaXRlciwgbG9nZ2VyLCBvcHRpb25zKSB7XG4gICAgaWYgKGxvZ2dlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvZ2dlciA9IGFwaV8xLk51bGxMb2dnZXI7XG4gICAgfVxuICAgIGlmIChhcGlfMS5Db25uZWN0aW9uU3RyYXRlZ3kuaXMob3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucyA9IHsgY29ubmVjdGlvblN0cmF0ZWd5OiBvcHRpb25zIH07XG4gICAgfVxuICAgIHJldHVybiAoMCwgYXBpXzEuY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb24pKHJlYWRlciwgd3JpdGVyLCBsb2dnZXIsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbiA9IGNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzMzEyOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIHByb3ZpZGVkIGRlcGVuZGVuY3kgKi8gdmFyIGNvbnNvbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzNjQpO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmNvbnN0IGFwaV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NjcyKTtcbmNsYXNzIE1lc3NhZ2VCdWZmZXIgZXh0ZW5kcyBhcGlfMS5BYnN0cmFjdE1lc3NhZ2VCdWZmZXIge1xuICAgIGNvbnN0cnVjdG9yKGVuY29kaW5nID0gJ3V0Zi04Jykge1xuICAgICAgICBzdXBlcihlbmNvZGluZyk7XG4gICAgICAgIHRoaXMuYXNjaWlEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCdhc2NpaScpO1xuICAgIH1cbiAgICBlbXB0eUJ1ZmZlcigpIHtcbiAgICAgICAgcmV0dXJuIE1lc3NhZ2VCdWZmZXIuZW1wdHlCdWZmZXI7XG4gICAgfVxuICAgIGZyb21TdHJpbmcodmFsdWUsIF9lbmNvZGluZykge1xuICAgICAgICByZXR1cm4gKG5ldyBUZXh0RW5jb2RlcigpKS5lbmNvZGUodmFsdWUpO1xuICAgIH1cbiAgICB0b1N0cmluZyh2YWx1ZSwgZW5jb2RpbmcpIHtcbiAgICAgICAgaWYgKGVuY29kaW5nID09PSAnYXNjaWknKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hc2NpaURlY29kZXIuZGVjb2RlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAobmV3IFRleHREZWNvZGVyKGVuY29kaW5nKSkuZGVjb2RlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc05hdGl2ZShidWZmZXIsIGxlbmd0aCkge1xuICAgICAgICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWxsb2NOYXRpdmUobGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIH1cbn1cbk1lc3NhZ2VCdWZmZXIuZW1wdHlCdWZmZXIgPSBuZXcgVWludDhBcnJheSgwKTtcbmNsYXNzIFJlYWRhYmxlU3RyZWFtV3JhcHBlciB7XG4gICAgY29uc3RydWN0b3Ioc29ja2V0KSB7XG4gICAgICAgIHRoaXMuc29ja2V0ID0gc29ja2V0O1xuICAgICAgICB0aGlzLl9vbkRhdGEgPSBuZXcgYXBpXzEuRW1pdHRlcigpO1xuICAgICAgICB0aGlzLl9tZXNzYWdlTGlzdGVuZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2IgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgYmxvYi5hcnJheUJ1ZmZlcigpLnRoZW4oKGJ1ZmZlcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uRGF0YS5maXJlKG5ldyBVaW50OEFycmF5KGJ1ZmZlcikpO1xuICAgICAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICgwLCBhcGlfMS5SQUwpKCkuY29uc29sZS5lcnJvcihgQ29udmVydGluZyBibG9iIHRvIGFycmF5IGJ1ZmZlciBmYWlsZWQuYCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMuX21lc3NhZ2VMaXN0ZW5lcik7XG4gICAgfVxuICAgIG9uQ2xvc2UobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiBhcGlfMS5EaXNwb3NhYmxlLmNyZWF0ZSgoKSA9PiB0aGlzLnNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbG9zZScsIGxpc3RlbmVyKSk7XG4gICAgfVxuICAgIG9uRXJyb3IobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiBhcGlfMS5EaXNwb3NhYmxlLmNyZWF0ZSgoKSA9PiB0aGlzLnNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGxpc3RlbmVyKSk7XG4gICAgfVxuICAgIG9uRW5kKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2VuZCcsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIGFwaV8xLkRpc3Bvc2FibGUuY3JlYXRlKCgpID0+IHRoaXMuc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZCcsIGxpc3RlbmVyKSk7XG4gICAgfVxuICAgIG9uRGF0YShsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fb25EYXRhLmV2ZW50KGxpc3RlbmVyKTtcbiAgICB9XG59XG5jbGFzcyBXcml0YWJsZVN0cmVhbVdyYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKHNvY2tldCkge1xuICAgICAgICB0aGlzLnNvY2tldCA9IHNvY2tldDtcbiAgICB9XG4gICAgb25DbG9zZShsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIGFwaV8xLkRpc3Bvc2FibGUuY3JlYXRlKCgpID0+IHRoaXMuc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgbGlzdGVuZXIpKTtcbiAgICB9XG4gICAgb25FcnJvcihsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIGFwaV8xLkRpc3Bvc2FibGUuY3JlYXRlKCgpID0+IHRoaXMuc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgbGlzdGVuZXIpKTtcbiAgICB9XG4gICAgb25FbmQobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignZW5kJywgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gYXBpXzEuRGlzcG9zYWJsZS5jcmVhdGUoKCkgPT4gdGhpcy5zb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kJywgbGlzdGVuZXIpKTtcbiAgICB9XG4gICAgd3JpdGUoZGF0YSwgZW5jb2RpbmcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgZW5jb2RpbmcgIT09ICd1dGYtOCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluIGEgQnJvd3NlciBlbnZpcm9ubWVudHMgb25seSB1dGYtOCB0ZXh0IGVuY29kaW5nIGlzIHN1cHBvcnRlZC4gQnV0IGdvdCBlbmNvZGluZzogJHtlbmNvZGluZ31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc29ja2V0LnNlbmQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5zZW5kKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgZW5kKCkge1xuICAgICAgICB0aGlzLnNvY2tldC5jbG9zZSgpO1xuICAgIH1cbn1cbmNvbnN0IF90ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuY29uc3QgX3JpbCA9IE9iamVjdC5mcmVlemUoe1xuICAgIG1lc3NhZ2VCdWZmZXI6IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBjcmVhdGU6IChlbmNvZGluZykgPT4gbmV3IE1lc3NhZ2VCdWZmZXIoZW5jb2RpbmcpXG4gICAgfSksXG4gICAgYXBwbGljYXRpb25Kc29uOiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgZW5jb2RlcjogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgICBuYW1lOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICBlbmNvZGU6IChtc2csIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jaGFyc2V0ICE9PSAndXRmLTgnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW4gYSBCcm93c2VyIGVudmlyb25tZW50cyBvbmx5IHV0Zi04IHRleHQgZW5jb2RpbmcgaXMgc3VwcG9ydGVkLiBCdXQgZ290IGVuY29kaW5nOiAke29wdGlvbnMuY2hhcnNldH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShfdGV4dEVuY29kZXIuZW5jb2RlKEpTT04uc3RyaW5naWZ5KG1zZywgdW5kZWZpbmVkLCAwKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgZGVjb2RlcjogT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgICBuYW1lOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICBkZWNvZGU6IChidWZmZXIsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIShidWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluIGEgQnJvd3NlciBlbnZpcm9ubWVudHMgb25seSBVaW50OEFycmF5cyBhcmUgc3VwcG9ydGVkLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKEpTT04ucGFyc2UobmV3IFRleHREZWNvZGVyKG9wdGlvbnMuY2hhcnNldCkuZGVjb2RlKGJ1ZmZlcikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9KSxcbiAgICBzdHJlYW06IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBhc1JlYWRhYmxlU3RyZWFtOiAoc29ja2V0KSA9PiBuZXcgUmVhZGFibGVTdHJlYW1XcmFwcGVyKHNvY2tldCksXG4gICAgICAgIGFzV3JpdGFibGVTdHJlYW06IChzb2NrZXQpID0+IG5ldyBXcml0YWJsZVN0cmVhbVdyYXBwZXIoc29ja2V0KVxuICAgIH0pLFxuICAgIGNvbnNvbGU6IGNvbnNvbGUsXG4gICAgdGltZXI6IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCBtcywgLi4uYXJncykge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dChjYWxsYmFjaywgbXMsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZGlzcG9zZTogKCkgPT4gY2xlYXJUaW1lb3V0KGhhbmRsZSkgfTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0SW1tZWRpYXRlKGNhbGxiYWNrLCAuLi5hcmdzKSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBzZXRUaW1lb3V0KGNhbGxiYWNrLCAwLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHJldHVybiB7IGRpc3Bvc2U6ICgpID0+IGNsZWFyVGltZW91dChoYW5kbGUpIH07XG4gICAgICAgIH0sXG4gICAgICAgIHNldEludGVydmFsKGNhbGxiYWNrLCBtcywgLi4uYXJncykge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0SW50ZXJ2YWwoY2FsbGJhY2ssIG1zLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIHJldHVybiB7IGRpc3Bvc2U6ICgpID0+IGNsZWFySW50ZXJ2YWwoaGFuZGxlKSB9O1xuICAgICAgICB9LFxuICAgIH0pXG59KTtcbmZ1bmN0aW9uIFJJTCgpIHtcbiAgICByZXR1cm4gX3JpbDtcbn1cbihmdW5jdGlvbiAoUklMKSB7XG4gICAgZnVuY3Rpb24gaW5zdGFsbCgpIHtcbiAgICAgICAgYXBpXzEuUkFMLmluc3RhbGwoX3JpbCk7XG4gICAgfVxuICAgIFJJTC5pbnN0YWxsID0gaW5zdGFsbDtcbn0pKFJJTCB8fCAoUklMID0ge30pKTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUklMO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3NjcyOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uLy4uL3R5cGluZ3MvdGhlbmFibGUuZC50c1wiIC8+XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuUHJvZ3Jlc3NUeXBlID0gZXhwb3J0cy5Qcm9ncmVzc1Rva2VuID0gZXhwb3J0cy5jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbiA9IGV4cG9ydHMuTnVsbExvZ2dlciA9IGV4cG9ydHMuQ29ubmVjdGlvbk9wdGlvbnMgPSBleHBvcnRzLkNvbm5lY3Rpb25TdHJhdGVneSA9IGV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlQnVmZmVyID0gZXhwb3J0cy5Xcml0ZWFibGVTdHJlYW1NZXNzYWdlV3JpdGVyID0gZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VXcml0ZXIgPSBleHBvcnRzLk1lc3NhZ2VXcml0ZXIgPSBleHBvcnRzLlJlYWRhYmxlU3RyZWFtTWVzc2FnZVJlYWRlciA9IGV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlUmVhZGVyID0gZXhwb3J0cy5NZXNzYWdlUmVhZGVyID0gZXhwb3J0cy5TaGFyZWRBcnJheVJlY2VpdmVyU3RyYXRlZ3kgPSBleHBvcnRzLlNoYXJlZEFycmF5U2VuZGVyU3RyYXRlZ3kgPSBleHBvcnRzLkNhbmNlbGxhdGlvblRva2VuID0gZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlblNvdXJjZSA9IGV4cG9ydHMuRW1pdHRlciA9IGV4cG9ydHMuRXZlbnQgPSBleHBvcnRzLkRpc3Bvc2FibGUgPSBleHBvcnRzLkxSVUNhY2hlID0gZXhwb3J0cy5Ub3VjaCA9IGV4cG9ydHMuTGlua2VkTWFwID0gZXhwb3J0cy5QYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlOSA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTggPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU3ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNiA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTUgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU0ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMyA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTIgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGUxID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMCA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZSA9IGV4cG9ydHMuRXJyb3JDb2RlcyA9IGV4cG9ydHMuUmVzcG9uc2VFcnJvciA9IGV4cG9ydHMuUmVxdWVzdFR5cGU5ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTggPSBleHBvcnRzLlJlcXVlc3RUeXBlNyA9IGV4cG9ydHMuUmVxdWVzdFR5cGU2ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTUgPSBleHBvcnRzLlJlcXVlc3RUeXBlNCA9IGV4cG9ydHMuUmVxdWVzdFR5cGUzID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTIgPSBleHBvcnRzLlJlcXVlc3RUeXBlMSA9IGV4cG9ydHMuUmVxdWVzdFR5cGUwID0gZXhwb3J0cy5SZXF1ZXN0VHlwZSA9IGV4cG9ydHMuTWVzc2FnZSA9IGV4cG9ydHMuUkFMID0gdm9pZCAwO1xuZXhwb3J0cy5NZXNzYWdlU3RyYXRlZ3kgPSBleHBvcnRzLkNhbmNlbGxhdGlvblN0cmF0ZWd5ID0gZXhwb3J0cy5DYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneSA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSA9IGV4cG9ydHMuQ29ubmVjdGlvbkVycm9yID0gZXhwb3J0cy5Db25uZWN0aW9uRXJyb3JzID0gZXhwb3J0cy5Mb2dUcmFjZU5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuU2V0VHJhY2VOb3RpZmljYXRpb24gPSBleHBvcnRzLlRyYWNlRm9ybWF0ID0gZXhwb3J0cy5UcmFjZVZhbHVlcyA9IGV4cG9ydHMuVHJhY2UgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MTYyKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1lc3NhZ2VcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk1lc3NhZ2U7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdFR5cGVcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLlJlcXVlc3RUeXBlOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlMFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGUwOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlMVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGUxOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlMlwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGUyOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlM1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGUzOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlNFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlNVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU1OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlNlwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU2OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlN1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU3OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlOFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU4OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RUeXBlOVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuUmVxdWVzdFR5cGU5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlc3BvbnNlRXJyb3JcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3I7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXJyb3JDb2Rlc1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuRXJyb3JDb2RlczsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGUwXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlMDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlMVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZTE7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90aWZpY2F0aW9uVHlwZTJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGUyOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGUzXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlMzsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlNFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZTQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90aWZpY2F0aW9uVHlwZTVcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGU1OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGU2XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlNjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb3RpZmljYXRpb25UeXBlN1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZTc7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90aWZpY2F0aW9uVHlwZThcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGU4OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGlmaWNhdGlvblR5cGU5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlOTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQYXJhbWV0ZXJTdHJ1Y3R1cmVzXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzOyB9IH0pKTtcbmNvbnN0IGxpbmtlZE1hcF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTA5KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxpbmtlZE1hcFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpbmtlZE1hcF8xLkxpbmtlZE1hcDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMUlVDYWNoZVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpbmtlZE1hcF8xLkxSVUNhY2hlOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRvdWNoXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbGlua2VkTWFwXzEuVG91Y2g7IH0gfSkpO1xuY29uc3QgZGlzcG9zYWJsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4ODQ0KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRpc3Bvc2FibGVcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkaXNwb3NhYmxlXzEuRGlzcG9zYWJsZTsgfSB9KSk7XG5jb25zdCBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjQ3OSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFdmVudFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV2ZW50c18xLkV2ZW50OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVtaXR0ZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBldmVudHNfMS5FbWl0dGVyOyB9IH0pKTtcbmNvbnN0IGNhbmNlbGxhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OTU3KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhbmNlbGxhdGlvblRva2VuU291cmNlXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FuY2VsbGF0aW9uXzEuQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2U7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FuY2VsbGF0aW9uVG9rZW5cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjYW5jZWxsYXRpb25fMS5DYW5jZWxsYXRpb25Ub2tlbjsgfSB9KSk7XG5jb25zdCBzaGFyZWRBcnJheUNhbmNlbGxhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNDg5KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNoYXJlZEFycmF5U2VuZGVyU3RyYXRlZ3lcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaGFyZWRBcnJheUNhbmNlbGxhdGlvbl8xLlNoYXJlZEFycmF5U2VuZGVyU3RyYXRlZ3k7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2hhcmVkQXJyYXlSZWNlaXZlclN0cmF0ZWd5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2hhcmVkQXJyYXlDYW5jZWxsYXRpb25fMS5TaGFyZWRBcnJheVJlY2VpdmVyU3RyYXRlZ3k7IH0gfSkpO1xuY29uc3QgbWVzc2FnZVJlYWRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NTYpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWVzc2FnZVJlYWRlclwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VSZWFkZXJfMS5NZXNzYWdlUmVhZGVyOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFic3RyYWN0TWVzc2FnZVJlYWRlclwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VSZWFkZXJfMS5BYnN0cmFjdE1lc3NhZ2VSZWFkZXI7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVhZGFibGVTdHJlYW1NZXNzYWdlUmVhZGVyXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVzc2FnZVJlYWRlcl8xLlJlYWRhYmxlU3RyZWFtTWVzc2FnZVJlYWRlcjsgfSB9KSk7XG5jb25zdCBtZXNzYWdlV3JpdGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkwMzYpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWVzc2FnZVdyaXRlclwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VXcml0ZXJfMS5NZXNzYWdlV3JpdGVyOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFic3RyYWN0TWVzc2FnZVdyaXRlclwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VXcml0ZXJfMS5BYnN0cmFjdE1lc3NhZ2VXcml0ZXI7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV3JpdGVhYmxlU3RyZWFtTWVzc2FnZVdyaXRlclwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2VXcml0ZXJfMS5Xcml0ZWFibGVTdHJlYW1NZXNzYWdlV3JpdGVyOyB9IH0pKTtcbmNvbnN0IG1lc3NhZ2VCdWZmZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOTgwNSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBYnN0cmFjdE1lc3NhZ2VCdWZmZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlQnVmZmVyXzEuQWJzdHJhY3RNZXNzYWdlQnVmZmVyOyB9IH0pKTtcbmNvbnN0IGNvbm5lY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDA1NCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb25uZWN0aW9uU3RyYXRlZ3lcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuQ29ubmVjdGlvblN0cmF0ZWd5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbm5lY3Rpb25PcHRpb25zXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLkNvbm5lY3Rpb25PcHRpb25zOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk51bGxMb2dnZXJcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuTnVsbExvZ2dlcjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVNZXNzYWdlQ29ubmVjdGlvblwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQcm9ncmVzc1Rva2VuXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLlByb2dyZXNzVG9rZW47IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUHJvZ3Jlc3NUeXBlXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLlByb2dyZXNzVHlwZTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUcmFjZVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5UcmFjZTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUcmFjZVZhbHVlc1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5UcmFjZVZhbHVlczsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUcmFjZUZvcm1hdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5UcmFjZUZvcm1hdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTZXRUcmFjZU5vdGlmaWNhdGlvblwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5TZXRUcmFjZU5vdGlmaWNhdGlvbjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMb2dUcmFjZU5vdGlmaWNhdGlvblwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5Mb2dUcmFjZU5vdGlmaWNhdGlvbjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb25uZWN0aW9uRXJyb3JzXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLkNvbm5lY3Rpb25FcnJvcnM7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29ubmVjdGlvbkVycm9yXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLkNvbm5lY3Rpb25FcnJvcjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLkNhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3k7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3lcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3k7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FuY2VsbGF0aW9uU3RyYXRlZ3lcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aW9uXzEuQ2FuY2VsbGF0aW9uU3RyYXRlZ3k7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWVzc2FnZVN0cmF0ZWd5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLk1lc3NhZ2VTdHJhdGVneTsgfSB9KSk7XG5jb25zdCByYWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTA5MSk7XG5leHBvcnRzLlJBTCA9IHJhbF8xLmRlZmF1bHQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDY5NTc6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlblNvdXJjZSA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uVG9rZW4gPSB2b2lkIDA7XG5jb25zdCByYWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTA5MSk7XG5jb25zdCBJcyA9IF9fd2VicGFja19yZXF1aXJlX18oNjYxOCk7XG5jb25zdCBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjQ3OSk7XG52YXIgQ2FuY2VsbGF0aW9uVG9rZW47XG4oZnVuY3Rpb24gKENhbmNlbGxhdGlvblRva2VuKSB7XG4gICAgQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZSA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBpc0NhbmNlbGxhdGlvblJlcXVlc3RlZDogZmFsc2UsXG4gICAgICAgIG9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkOiBldmVudHNfMS5FdmVudC5Ob25lXG4gICAgfSk7XG4gICAgQ2FuY2VsbGF0aW9uVG9rZW4uQ2FuY2VsbGVkID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIGlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkOiB0cnVlLFxuICAgICAgICBvbkNhbmNlbGxhdGlvblJlcXVlc3RlZDogZXZlbnRzXzEuRXZlbnQuTm9uZVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIChjYW5kaWRhdGUgPT09IENhbmNlbGxhdGlvblRva2VuLk5vbmVcbiAgICAgICAgICAgIHx8IGNhbmRpZGF0ZSA9PT0gQ2FuY2VsbGF0aW9uVG9rZW4uQ2FuY2VsbGVkXG4gICAgICAgICAgICB8fCAoSXMuYm9vbGVhbihjYW5kaWRhdGUuaXNDYW5jZWxsYXRpb25SZXF1ZXN0ZWQpICYmICEhY2FuZGlkYXRlLm9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKSk7XG4gICAgfVxuICAgIENhbmNlbGxhdGlvblRva2VuLmlzID0gaXM7XG59KShDYW5jZWxsYXRpb25Ub2tlbiA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uVG9rZW4gfHwgKGV4cG9ydHMuQ2FuY2VsbGF0aW9uVG9rZW4gPSB7fSkpO1xuY29uc3Qgc2hvcnRjdXRFdmVudCA9IE9iamVjdC5mcmVlemUoZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgY29uc3QgaGFuZGxlID0gKDAsIHJhbF8xLmRlZmF1bHQpKCkudGltZXIuc2V0VGltZW91dChjYWxsYmFjay5iaW5kKGNvbnRleHQpLCAwKTtcbiAgICByZXR1cm4geyBkaXNwb3NlKCkgeyBoYW5kbGUuZGlzcG9zZSgpOyB9IH07XG59KTtcbmNsYXNzIE11dGFibGVUb2tlbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2lzQ2FuY2VsbGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc0NhbmNlbGxlZCkge1xuICAgICAgICAgICAgdGhpcy5faXNDYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2VtaXR0ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0dGVyLmZpcmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaXNDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0NhbmNlbGxlZDtcbiAgICB9XG4gICAgZ2V0IG9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKCkge1xuICAgICAgICBpZiAodGhpcy5faXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzaG9ydGN1dEV2ZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fZW1pdHRlcikge1xuICAgICAgICAgICAgdGhpcy5fZW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2VtaXR0ZXIuZXZlbnQ7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9lbWl0dGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0dGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX2VtaXR0ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSB7XG4gICAgZ2V0IHRva2VuKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Rva2VuKSB7XG4gICAgICAgICAgICAvLyBiZSBsYXp5IGFuZCBjcmVhdGUgdGhlIHRva2VuIG9ubHkgd2hlblxuICAgICAgICAgICAgLy8gYWN0dWFsbHkgbmVlZGVkXG4gICAgICAgICAgICB0aGlzLl90b2tlbiA9IG5ldyBNdXRhYmxlVG9rZW4oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdG9rZW47XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90b2tlbikge1xuICAgICAgICAgICAgLy8gc2F2ZSBhbiBvYmplY3QgYnkgcmV0dXJuaW5nIHRoZSBkZWZhdWx0XG4gICAgICAgICAgICAvLyBjYW5jZWxsZWQgdG9rZW4gd2hlbiBjYW5jZWxsYXRpb24gaGFwcGVuc1xuICAgICAgICAgICAgLy8gYmVmb3JlIHNvbWVvbmUgYXNrcyBmb3IgdGhlIHRva2VuXG4gICAgICAgICAgICB0aGlzLl90b2tlbiA9IENhbmNlbGxhdGlvblRva2VuLkNhbmNlbGxlZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5fdG9rZW4pIHtcbiAgICAgICAgICAgIC8vIGVuc3VyZSB0byBpbml0aWFsaXplIHdpdGggYW4gZW1wdHkgdG9rZW4gaWYgd2UgaGFkIG5vbmVcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuID0gQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl90b2tlbiBpbnN0YW5jZW9mIE11dGFibGVUb2tlbikge1xuICAgICAgICAgICAgLy8gYWN0dWFsbHkgZGlzcG9zZVxuICAgICAgICAgICAgdGhpcy5fdG9rZW4uZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlblNvdXJjZSA9IENhbmNlbGxhdGlvblRva2VuU291cmNlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0MDU0OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLmNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uID0gZXhwb3J0cy5Db25uZWN0aW9uT3B0aW9ucyA9IGV4cG9ydHMuTWVzc2FnZVN0cmF0ZWd5ID0gZXhwb3J0cy5DYW5jZWxsYXRpb25TdHJhdGVneSA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3kgPSBleHBvcnRzLkNhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSBleHBvcnRzLlJlcXVlc3RDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5ID0gZXhwb3J0cy5JZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSBleHBvcnRzLkNvbm5lY3Rpb25TdHJhdGVneSA9IGV4cG9ydHMuQ29ubmVjdGlvbkVycm9yID0gZXhwb3J0cy5Db25uZWN0aW9uRXJyb3JzID0gZXhwb3J0cy5Mb2dUcmFjZU5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuU2V0VHJhY2VOb3RpZmljYXRpb24gPSBleHBvcnRzLlRyYWNlRm9ybWF0ID0gZXhwb3J0cy5UcmFjZVZhbHVlcyA9IGV4cG9ydHMuVHJhY2UgPSBleHBvcnRzLk51bGxMb2dnZXIgPSBleHBvcnRzLlByb2dyZXNzVHlwZSA9IGV4cG9ydHMuUHJvZ3Jlc3NUb2tlbiA9IHZvaWQgMDtcbmNvbnN0IHJhbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MDkxKTtcbmNvbnN0IElzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NjE4KTtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxNjIpO1xuY29uc3QgbGlua2VkTWFwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExMDkpO1xuY29uc3QgZXZlbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0NzkpO1xuY29uc3QgY2FuY2VsbGF0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5NTcpO1xudmFyIENhbmNlbE5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoQ2FuY2VsTm90aWZpY2F0aW9uKSB7XG4gICAgQ2FuY2VsTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Ob3RpZmljYXRpb25UeXBlKCckL2NhbmNlbFJlcXVlc3QnKTtcbn0pKENhbmNlbE5vdGlmaWNhdGlvbiB8fCAoQ2FuY2VsTm90aWZpY2F0aW9uID0ge30pKTtcbnZhciBQcm9ncmVzc1Rva2VuO1xuKGZ1bmN0aW9uIChQcm9ncmVzc1Rva2VuKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbiAgICB9XG4gICAgUHJvZ3Jlc3NUb2tlbi5pcyA9IGlzO1xufSkoUHJvZ3Jlc3NUb2tlbiA9IGV4cG9ydHMuUHJvZ3Jlc3NUb2tlbiB8fCAoZXhwb3J0cy5Qcm9ncmVzc1Rva2VuID0ge30pKTtcbnZhciBQcm9ncmVzc05vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoUHJvZ3Jlc3NOb3RpZmljYXRpb24pIHtcbiAgICBQcm9ncmVzc05vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuTm90aWZpY2F0aW9uVHlwZSgnJC9wcm9ncmVzcycpO1xufSkoUHJvZ3Jlc3NOb3RpZmljYXRpb24gfHwgKFByb2dyZXNzTm90aWZpY2F0aW9uID0ge30pKTtcbmNsYXNzIFByb2dyZXNzVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgfVxufVxuZXhwb3J0cy5Qcm9ncmVzc1R5cGUgPSBQcm9ncmVzc1R5cGU7XG52YXIgU3RhclJlcXVlc3RIYW5kbGVyO1xuKGZ1bmN0aW9uIChTdGFyUmVxdWVzdEhhbmRsZXIpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gSXMuZnVuYyh2YWx1ZSk7XG4gICAgfVxuICAgIFN0YXJSZXF1ZXN0SGFuZGxlci5pcyA9IGlzO1xufSkoU3RhclJlcXVlc3RIYW5kbGVyIHx8IChTdGFyUmVxdWVzdEhhbmRsZXIgPSB7fSkpO1xuZXhwb3J0cy5OdWxsTG9nZ2VyID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgZXJyb3I6ICgpID0+IHsgfSxcbiAgICB3YXJuOiAoKSA9PiB7IH0sXG4gICAgaW5mbzogKCkgPT4geyB9LFxuICAgIGxvZzogKCkgPT4geyB9XG59KTtcbnZhciBUcmFjZTtcbihmdW5jdGlvbiAoVHJhY2UpIHtcbiAgICBUcmFjZVtUcmFjZVtcIk9mZlwiXSA9IDBdID0gXCJPZmZcIjtcbiAgICBUcmFjZVtUcmFjZVtcIk1lc3NhZ2VzXCJdID0gMV0gPSBcIk1lc3NhZ2VzXCI7XG4gICAgVHJhY2VbVHJhY2VbXCJDb21wYWN0XCJdID0gMl0gPSBcIkNvbXBhY3RcIjtcbiAgICBUcmFjZVtUcmFjZVtcIlZlcmJvc2VcIl0gPSAzXSA9IFwiVmVyYm9zZVwiO1xufSkoVHJhY2UgPSBleHBvcnRzLlRyYWNlIHx8IChleHBvcnRzLlRyYWNlID0ge30pKTtcbnZhciBUcmFjZVZhbHVlcztcbihmdW5jdGlvbiAoVHJhY2VWYWx1ZXMpIHtcbiAgICAvKipcbiAgICAgKiBUdXJuIHRyYWNpbmcgb2ZmLlxuICAgICAqL1xuICAgIFRyYWNlVmFsdWVzLk9mZiA9ICdvZmYnO1xuICAgIC8qKlxuICAgICAqIFRyYWNlIG1lc3NhZ2VzIG9ubHkuXG4gICAgICovXG4gICAgVHJhY2VWYWx1ZXMuTWVzc2FnZXMgPSAnbWVzc2FnZXMnO1xuICAgIC8qKlxuICAgICAqIENvbXBhY3QgbWVzc2FnZSB0cmFjaW5nLlxuICAgICAqL1xuICAgIFRyYWNlVmFsdWVzLkNvbXBhY3QgPSAnY29tcGFjdCc7XG4gICAgLyoqXG4gICAgICogVmVyYm9zZSBtZXNzYWdlIHRyYWNpbmcuXG4gICAgICovXG4gICAgVHJhY2VWYWx1ZXMuVmVyYm9zZSA9ICd2ZXJib3NlJztcbn0pKFRyYWNlVmFsdWVzID0gZXhwb3J0cy5UcmFjZVZhbHVlcyB8fCAoZXhwb3J0cy5UcmFjZVZhbHVlcyA9IHt9KSk7XG4oZnVuY3Rpb24gKFRyYWNlKSB7XG4gICAgZnVuY3Rpb24gZnJvbVN0cmluZyh2YWx1ZSkge1xuICAgICAgICBpZiAoIUlzLnN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBUcmFjZS5PZmY7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlICdvZmYnOlxuICAgICAgICAgICAgICAgIHJldHVybiBUcmFjZS5PZmY7XG4gICAgICAgICAgICBjYXNlICdtZXNzYWdlcyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRyYWNlLk1lc3NhZ2VzO1xuICAgICAgICAgICAgY2FzZSAnY29tcGFjdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRyYWNlLkNvbXBhY3Q7XG4gICAgICAgICAgICBjYXNlICd2ZXJib3NlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJhY2UuVmVyYm9zZTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRyYWNlLk9mZjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBUcmFjZS5mcm9tU3RyaW5nID0gZnJvbVN0cmluZztcbiAgICBmdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlIFRyYWNlLk9mZjpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ29mZic7XG4gICAgICAgICAgICBjYXNlIFRyYWNlLk1lc3NhZ2VzOlxuICAgICAgICAgICAgICAgIHJldHVybiAnbWVzc2FnZXMnO1xuICAgICAgICAgICAgY2FzZSBUcmFjZS5Db21wYWN0OlxuICAgICAgICAgICAgICAgIHJldHVybiAnY29tcGFjdCc7XG4gICAgICAgICAgICBjYXNlIFRyYWNlLlZlcmJvc2U6XG4gICAgICAgICAgICAgICAgcmV0dXJuICd2ZXJib3NlJztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdvZmYnO1xuICAgICAgICB9XG4gICAgfVxuICAgIFRyYWNlLnRvU3RyaW5nID0gdG9TdHJpbmc7XG59KShUcmFjZSA9IGV4cG9ydHMuVHJhY2UgfHwgKGV4cG9ydHMuVHJhY2UgPSB7fSkpO1xudmFyIFRyYWNlRm9ybWF0O1xuKGZ1bmN0aW9uIChUcmFjZUZvcm1hdCkge1xuICAgIFRyYWNlRm9ybWF0W1wiVGV4dFwiXSA9IFwidGV4dFwiO1xuICAgIFRyYWNlRm9ybWF0W1wiSlNPTlwiXSA9IFwianNvblwiO1xufSkoVHJhY2VGb3JtYXQgPSBleHBvcnRzLlRyYWNlRm9ybWF0IHx8IChleHBvcnRzLlRyYWNlRm9ybWF0ID0ge30pKTtcbihmdW5jdGlvbiAoVHJhY2VGb3JtYXQpIHtcbiAgICBmdW5jdGlvbiBmcm9tU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIGlmICghSXMuc3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFRyYWNlRm9ybWF0LlRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAodmFsdWUgPT09ICdqc29uJykge1xuICAgICAgICAgICAgcmV0dXJuIFRyYWNlRm9ybWF0LkpTT047XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gVHJhY2VGb3JtYXQuVGV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBUcmFjZUZvcm1hdC5mcm9tU3RyaW5nID0gZnJvbVN0cmluZztcbn0pKFRyYWNlRm9ybWF0ID0gZXhwb3J0cy5UcmFjZUZvcm1hdCB8fCAoZXhwb3J0cy5UcmFjZUZvcm1hdCA9IHt9KSk7XG52YXIgU2V0VHJhY2VOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKFNldFRyYWNlTm90aWZpY2F0aW9uKSB7XG4gICAgU2V0VHJhY2VOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGUoJyQvc2V0VHJhY2UnKTtcbn0pKFNldFRyYWNlTm90aWZpY2F0aW9uID0gZXhwb3J0cy5TZXRUcmFjZU5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5TZXRUcmFjZU5vdGlmaWNhdGlvbiA9IHt9KSk7XG52YXIgTG9nVHJhY2VOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKExvZ1RyYWNlTm90aWZpY2F0aW9uKSB7XG4gICAgTG9nVHJhY2VOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLk5vdGlmaWNhdGlvblR5cGUoJyQvbG9nVHJhY2UnKTtcbn0pKExvZ1RyYWNlTm90aWZpY2F0aW9uID0gZXhwb3J0cy5Mb2dUcmFjZU5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5Mb2dUcmFjZU5vdGlmaWNhdGlvbiA9IHt9KSk7XG52YXIgQ29ubmVjdGlvbkVycm9ycztcbihmdW5jdGlvbiAoQ29ubmVjdGlvbkVycm9ycykge1xuICAgIC8qKlxuICAgICAqIFRoZSBjb25uZWN0aW9uIGlzIGNsb3NlZC5cbiAgICAgKi9cbiAgICBDb25uZWN0aW9uRXJyb3JzW0Nvbm5lY3Rpb25FcnJvcnNbXCJDbG9zZWRcIl0gPSAxXSA9IFwiQ2xvc2VkXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbm5lY3Rpb24gZ290IGRpc3Bvc2VkLlxuICAgICAqL1xuICAgIENvbm5lY3Rpb25FcnJvcnNbQ29ubmVjdGlvbkVycm9yc1tcIkRpc3Bvc2VkXCJdID0gMl0gPSBcIkRpc3Bvc2VkXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbm5lY3Rpb24gaXMgYWxyZWFkeSBpbiBsaXN0ZW5pbmcgbW9kZS5cbiAgICAgKi9cbiAgICBDb25uZWN0aW9uRXJyb3JzW0Nvbm5lY3Rpb25FcnJvcnNbXCJBbHJlYWR5TGlzdGVuaW5nXCJdID0gM10gPSBcIkFscmVhZHlMaXN0ZW5pbmdcIjtcbn0pKENvbm5lY3Rpb25FcnJvcnMgPSBleHBvcnRzLkNvbm5lY3Rpb25FcnJvcnMgfHwgKGV4cG9ydHMuQ29ubmVjdGlvbkVycm9ycyA9IHt9KSk7XG5jbGFzcyBDb25uZWN0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY29kZSwgbWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIENvbm5lY3Rpb25FcnJvci5wcm90b3R5cGUpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29ubmVjdGlvbkVycm9yID0gQ29ubmVjdGlvbkVycm9yO1xudmFyIENvbm5lY3Rpb25TdHJhdGVneTtcbihmdW5jdGlvbiAoQ29ubmVjdGlvblN0cmF0ZWd5KSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuZnVuYyhjYW5kaWRhdGUuY2FuY2VsVW5kaXNwYXRjaGVkKTtcbiAgICB9XG4gICAgQ29ubmVjdGlvblN0cmF0ZWd5LmlzID0gaXM7XG59KShDb25uZWN0aW9uU3RyYXRlZ3kgPSBleHBvcnRzLkNvbm5lY3Rpb25TdHJhdGVneSB8fCAoZXhwb3J0cy5Db25uZWN0aW9uU3RyYXRlZ3kgPSB7fSkpO1xudmFyIElkQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneTtcbihmdW5jdGlvbiAoSWRDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5KSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgKGNhbmRpZGF0ZS5raW5kID09PSB1bmRlZmluZWQgfHwgY2FuZGlkYXRlLmtpbmQgPT09ICdpZCcpICYmIElzLmZ1bmMoY2FuZGlkYXRlLmNyZWF0ZUNhbmNlbGxhdGlvblRva2VuU291cmNlKSAmJiAoY2FuZGlkYXRlLmRpc3Bvc2UgPT09IHVuZGVmaW5lZCB8fCBJcy5mdW5jKGNhbmRpZGF0ZS5kaXNwb3NlKSk7XG4gICAgfVxuICAgIElkQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneS5pcyA9IGlzO1xufSkoSWRDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5ID0gZXhwb3J0cy5JZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgfHwgKGV4cG9ydHMuSWRDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5ID0ge30pKTtcbnZhciBSZXF1ZXN0Q2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneTtcbihmdW5jdGlvbiAoUmVxdWVzdENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBjYW5kaWRhdGUua2luZCA9PT0gJ3JlcXVlc3QnICYmIElzLmZ1bmMoY2FuZGlkYXRlLmNyZWF0ZUNhbmNlbGxhdGlvblRva2VuU291cmNlKSAmJiAoY2FuZGlkYXRlLmRpc3Bvc2UgPT09IHVuZGVmaW5lZCB8fCBJcy5mdW5jKGNhbmRpZGF0ZS5kaXNwb3NlKSk7XG4gICAgfVxuICAgIFJlcXVlc3RDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5LmlzID0gaXM7XG59KShSZXF1ZXN0Q2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneSA9IGV4cG9ydHMuUmVxdWVzdENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgfHwgKGV4cG9ydHMuUmVxdWVzdENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSB7fSkpO1xudmFyIENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3k7XG4oZnVuY3Rpb24gKENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kpIHtcbiAgICBDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5Lk1lc3NhZ2UgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgY3JlYXRlQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UoXykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBjYW5jZWxsYXRpb25fMS5DYW5jZWxsYXRpb25Ub2tlblNvdXJjZSgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIElkQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneS5pcyh2YWx1ZSkgfHwgUmVxdWVzdENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kuaXModmFsdWUpO1xuICAgIH1cbiAgICBDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5LmlzID0gaXM7XG59KShDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5ID0gZXhwb3J0cy5DYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5IHx8IChleHBvcnRzLkNhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kgPSB7fSkpO1xudmFyIENhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5O1xuKGZ1bmN0aW9uIChDYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneSkge1xuICAgIENhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5Lk1lc3NhZ2UgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgc2VuZENhbmNlbGxhdGlvbihjb25uLCBpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbm4uc2VuZE5vdGlmaWNhdGlvbihDYW5jZWxOb3RpZmljYXRpb24udHlwZSwgeyBpZCB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYW51cChfKSB7IH1cbiAgICB9KTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5zZW5kQ2FuY2VsbGF0aW9uKSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5jbGVhbnVwKTtcbiAgICB9XG4gICAgQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3kuaXMgPSBpcztcbn0pKENhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5ID0gZXhwb3J0cy5DYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneSB8fCAoZXhwb3J0cy5DYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneSA9IHt9KSk7XG52YXIgQ2FuY2VsbGF0aW9uU3RyYXRlZ3k7XG4oZnVuY3Rpb24gKENhbmNlbGxhdGlvblN0cmF0ZWd5KSB7XG4gICAgQ2FuY2VsbGF0aW9uU3RyYXRlZ3kuTWVzc2FnZSA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICByZWNlaXZlcjogQ2FuY2VsbGF0aW9uUmVjZWl2ZXJTdHJhdGVneS5NZXNzYWdlLFxuICAgICAgICBzZW5kZXI6IENhbmNlbGxhdGlvblNlbmRlclN0cmF0ZWd5Lk1lc3NhZ2VcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5LmlzKGNhbmRpZGF0ZS5yZWNlaXZlcikgJiYgQ2FuY2VsbGF0aW9uU2VuZGVyU3RyYXRlZ3kuaXMoY2FuZGlkYXRlLnNlbmRlcik7XG4gICAgfVxuICAgIENhbmNlbGxhdGlvblN0cmF0ZWd5LmlzID0gaXM7XG59KShDYW5jZWxsYXRpb25TdHJhdGVneSA9IGV4cG9ydHMuQ2FuY2VsbGF0aW9uU3RyYXRlZ3kgfHwgKGV4cG9ydHMuQ2FuY2VsbGF0aW9uU3RyYXRlZ3kgPSB7fSkpO1xudmFyIE1lc3NhZ2VTdHJhdGVneTtcbihmdW5jdGlvbiAoTWVzc2FnZVN0cmF0ZWd5KSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuZnVuYyhjYW5kaWRhdGUuaGFuZGxlTWVzc2FnZSk7XG4gICAgfVxuICAgIE1lc3NhZ2VTdHJhdGVneS5pcyA9IGlzO1xufSkoTWVzc2FnZVN0cmF0ZWd5ID0gZXhwb3J0cy5NZXNzYWdlU3RyYXRlZ3kgfHwgKGV4cG9ydHMuTWVzc2FnZVN0cmF0ZWd5ID0ge30pKTtcbnZhciBDb25uZWN0aW9uT3B0aW9ucztcbihmdW5jdGlvbiAoQ29ubmVjdGlvbk9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiAoQ2FuY2VsbGF0aW9uU3RyYXRlZ3kuaXMoY2FuZGlkYXRlLmNhbmNlbGxhdGlvblN0cmF0ZWd5KSB8fCBDb25uZWN0aW9uU3RyYXRlZ3kuaXMoY2FuZGlkYXRlLmNvbm5lY3Rpb25TdHJhdGVneSkgfHwgTWVzc2FnZVN0cmF0ZWd5LmlzKGNhbmRpZGF0ZS5tZXNzYWdlU3RyYXRlZ3kpKTtcbiAgICB9XG4gICAgQ29ubmVjdGlvbk9wdGlvbnMuaXMgPSBpcztcbn0pKENvbm5lY3Rpb25PcHRpb25zID0gZXhwb3J0cy5Db25uZWN0aW9uT3B0aW9ucyB8fCAoZXhwb3J0cy5Db25uZWN0aW9uT3B0aW9ucyA9IHt9KSk7XG52YXIgQ29ubmVjdGlvblN0YXRlO1xuKGZ1bmN0aW9uIChDb25uZWN0aW9uU3RhdGUpIHtcbiAgICBDb25uZWN0aW9uU3RhdGVbQ29ubmVjdGlvblN0YXRlW1wiTmV3XCJdID0gMV0gPSBcIk5ld1wiO1xuICAgIENvbm5lY3Rpb25TdGF0ZVtDb25uZWN0aW9uU3RhdGVbXCJMaXN0ZW5pbmdcIl0gPSAyXSA9IFwiTGlzdGVuaW5nXCI7XG4gICAgQ29ubmVjdGlvblN0YXRlW0Nvbm5lY3Rpb25TdGF0ZVtcIkNsb3NlZFwiXSA9IDNdID0gXCJDbG9zZWRcIjtcbiAgICBDb25uZWN0aW9uU3RhdGVbQ29ubmVjdGlvblN0YXRlW1wiRGlzcG9zZWRcIl0gPSA0XSA9IFwiRGlzcG9zZWRcIjtcbn0pKENvbm5lY3Rpb25TdGF0ZSB8fCAoQ29ubmVjdGlvblN0YXRlID0ge30pKTtcbmZ1bmN0aW9uIGNyZWF0ZU1lc3NhZ2VDb25uZWN0aW9uKG1lc3NhZ2VSZWFkZXIsIG1lc3NhZ2VXcml0ZXIsIF9sb2dnZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsb2dnZXIgPSBfbG9nZ2VyICE9PSB1bmRlZmluZWQgPyBfbG9nZ2VyIDogZXhwb3J0cy5OdWxsTG9nZ2VyO1xuICAgIGxldCBzZXF1ZW5jZU51bWJlciA9IDA7XG4gICAgbGV0IG5vdGlmaWNhdGlvblNlcXVlbmNlTnVtYmVyID0gMDtcbiAgICBsZXQgdW5rbm93blJlc3BvbnNlU2VxdWVuY2VOdW1iZXIgPSAwO1xuICAgIGNvbnN0IHZlcnNpb24gPSAnMi4wJztcbiAgICBsZXQgc3RhclJlcXVlc3RIYW5kbGVyID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHJlcXVlc3RIYW5kbGVycyA9IG5ldyBNYXAoKTtcbiAgICBsZXQgc3Rhck5vdGlmaWNhdGlvbkhhbmRsZXIgPSB1bmRlZmluZWQ7XG4gICAgY29uc3Qgbm90aWZpY2F0aW9uSGFuZGxlcnMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgcHJvZ3Jlc3NIYW5kbGVycyA9IG5ldyBNYXAoKTtcbiAgICBsZXQgdGltZXI7XG4gICAgbGV0IG1lc3NhZ2VRdWV1ZSA9IG5ldyBsaW5rZWRNYXBfMS5MaW5rZWRNYXAoKTtcbiAgICBsZXQgcmVzcG9uc2VQcm9taXNlcyA9IG5ldyBNYXAoKTtcbiAgICBsZXQga25vd25DYW5jZWxlZFJlcXVlc3RzID0gbmV3IFNldCgpO1xuICAgIGxldCByZXF1ZXN0VG9rZW5zID0gbmV3IE1hcCgpO1xuICAgIGxldCB0cmFjZSA9IFRyYWNlLk9mZjtcbiAgICBsZXQgdHJhY2VGb3JtYXQgPSBUcmFjZUZvcm1hdC5UZXh0O1xuICAgIGxldCB0cmFjZXI7XG4gICAgbGV0IHN0YXRlID0gQ29ubmVjdGlvblN0YXRlLk5ldztcbiAgICBjb25zdCBlcnJvckVtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xuICAgIGNvbnN0IGNsb3NlRW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgY29uc3QgdW5oYW5kbGVkTm90aWZpY2F0aW9uRW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgY29uc3QgdW5oYW5kbGVkUHJvZ3Jlc3NFbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICBjb25zdCBkaXNwb3NlRW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgY29uc3QgY2FuY2VsbGF0aW9uU3RyYXRlZ3kgPSAob3B0aW9ucyAmJiBvcHRpb25zLmNhbmNlbGxhdGlvblN0cmF0ZWd5KSA/IG9wdGlvbnMuY2FuY2VsbGF0aW9uU3RyYXRlZ3kgOiBDYW5jZWxsYXRpb25TdHJhdGVneS5NZXNzYWdlO1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlcXVlc3RRdWV1ZUtleShpZCkge1xuICAgICAgICBpZiAoaWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3Qgc2VuZCByZXF1ZXN0cyB3aXRoIGlkIG51bGwgc2luY2UgdGhlIHJlc3BvbnNlIGNhbid0IGJlIGNvcnJlbGF0ZWQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdyZXEtJyArIGlkLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlc3BvbnNlUXVldWVLZXkoaWQpIHtcbiAgICAgICAgaWYgKGlkID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3Jlcy11bmtub3duLScgKyAoKyt1bmtub3duUmVzcG9uc2VTZXF1ZW5jZU51bWJlcikudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAncmVzLScgKyBpZC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZU5vdGlmaWNhdGlvblF1ZXVlS2V5KCkge1xuICAgICAgICByZXR1cm4gJ25vdC0nICsgKCsrbm90aWZpY2F0aW9uU2VxdWVuY2VOdW1iZXIpLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZE1lc3NhZ2VUb1F1ZXVlKHF1ZXVlLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlc18xLk1lc3NhZ2UuaXNSZXF1ZXN0KG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICBxdWV1ZS5zZXQoY3JlYXRlUmVxdWVzdFF1ZXVlS2V5KG1lc3NhZ2UuaWQpLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtZXNzYWdlc18xLk1lc3NhZ2UuaXNSZXNwb25zZShtZXNzYWdlKSkge1xuICAgICAgICAgICAgcXVldWUuc2V0KGNyZWF0ZVJlc3BvbnNlUXVldWVLZXkobWVzc2FnZS5pZCksIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcXVldWUuc2V0KGNyZWF0ZU5vdGlmaWNhdGlvblF1ZXVlS2V5KCksIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbmNlbFVuZGlzcGF0Y2hlZChfbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0xpc3RlbmluZygpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuTGlzdGVuaW5nO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0Nsb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuQ2xvc2VkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0Rpc3Bvc2VkKCkge1xuICAgICAgICByZXR1cm4gc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5EaXNwb3NlZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xvc2VIYW5kbGVyKCkge1xuICAgICAgICBpZiAoc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5OZXcgfHwgc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5MaXN0ZW5pbmcpIHtcbiAgICAgICAgICAgIHN0YXRlID0gQ29ubmVjdGlvblN0YXRlLkNsb3NlZDtcbiAgICAgICAgICAgIGNsb3NlRW1pdHRlci5maXJlKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGNvbm5lY3Rpb24gaXMgZGlzcG9zZWQgZG9uJ3Qgc2VudCBjbG9zZSBldmVudHMuXG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWRFcnJvckhhbmRsZXIoZXJyb3IpIHtcbiAgICAgICAgZXJyb3JFbWl0dGVyLmZpcmUoW2Vycm9yLCB1bmRlZmluZWQsIHVuZGVmaW5lZF0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZUVycm9ySGFuZGxlcihkYXRhKSB7XG4gICAgICAgIGVycm9yRW1pdHRlci5maXJlKGRhdGEpO1xuICAgIH1cbiAgICBtZXNzYWdlUmVhZGVyLm9uQ2xvc2UoY2xvc2VIYW5kbGVyKTtcbiAgICBtZXNzYWdlUmVhZGVyLm9uRXJyb3IocmVhZEVycm9ySGFuZGxlcik7XG4gICAgbWVzc2FnZVdyaXRlci5vbkNsb3NlKGNsb3NlSGFuZGxlcik7XG4gICAgbWVzc2FnZVdyaXRlci5vbkVycm9yKHdyaXRlRXJyb3JIYW5kbGVyKTtcbiAgICBmdW5jdGlvbiB0cmlnZ2VyTWVzc2FnZVF1ZXVlKCkge1xuICAgICAgICBpZiAodGltZXIgfHwgbWVzc2FnZVF1ZXVlLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aW1lciA9ICgwLCByYWxfMS5kZWZhdWx0KSgpLnRpbWVyLnNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgICB0aW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHByb2Nlc3NNZXNzYWdlUXVldWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICBpZiAobWVzc2FnZXNfMS5NZXNzYWdlLmlzUmVxdWVzdChtZXNzYWdlKSkge1xuICAgICAgICAgICAgaGFuZGxlUmVxdWVzdChtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtZXNzYWdlc18xLk1lc3NhZ2UuaXNOb3RpZmljYXRpb24obWVzc2FnZSkpIHtcbiAgICAgICAgICAgIGhhbmRsZU5vdGlmaWNhdGlvbihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtZXNzYWdlc18xLk1lc3NhZ2UuaXNSZXNwb25zZShtZXNzYWdlKSkge1xuICAgICAgICAgICAgaGFuZGxlUmVzcG9uc2UobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVJbnZhbGlkTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9jZXNzTWVzc2FnZVF1ZXVlKCkge1xuICAgICAgICBpZiAobWVzc2FnZVF1ZXVlLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXNzYWdlID0gbWVzc2FnZVF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlU3RyYXRlZ3kgPSBvcHRpb25zPy5tZXNzYWdlU3RyYXRlZ3k7XG4gICAgICAgICAgICBpZiAoTWVzc2FnZVN0cmF0ZWd5LmlzKG1lc3NhZ2VTdHJhdGVneSkpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlU3RyYXRlZ3kuaGFuZGxlTWVzc2FnZShtZXNzYWdlLCBoYW5kbGVNZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhhbmRsZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cmlnZ2VyTWVzc2FnZVF1ZXVlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY2FsbGJhY2sgPSAobWVzc2FnZSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2UgaGF2ZSByZWNlaXZlZCBhIGNhbmNlbGxhdGlvbiBtZXNzYWdlLiBDaGVjayBpZiB0aGUgbWVzc2FnZSBpcyBzdGlsbCBpbiB0aGUgcXVldWVcbiAgICAgICAgICAgIC8vIGFuZCBjYW5jZWwgaXQgaWYgYWxsb3dlZCB0byBkbyBzby5cbiAgICAgICAgICAgIGlmIChtZXNzYWdlc18xLk1lc3NhZ2UuaXNOb3RpZmljYXRpb24obWVzc2FnZSkgJiYgbWVzc2FnZS5tZXRob2QgPT09IENhbmNlbE5vdGlmaWNhdGlvbi50eXBlLm1ldGhvZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbmNlbElkID0gbWVzc2FnZS5wYXJhbXMuaWQ7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gY3JlYXRlUmVxdWVzdFF1ZXVlS2V5KGNhbmNlbElkKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0b0NhbmNlbCA9IG1lc3NhZ2VRdWV1ZS5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZXNfMS5NZXNzYWdlLmlzUmVxdWVzdCh0b0NhbmNlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RyYXRlZ3kgPSBvcHRpb25zPy5jb25uZWN0aW9uU3RyYXRlZ3k7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gKHN0cmF0ZWd5ICYmIHN0cmF0ZWd5LmNhbmNlbFVuZGlzcGF0Y2hlZCkgPyBzdHJhdGVneS5jYW5jZWxVbmRpc3BhdGNoZWQodG9DYW5jZWwsIGNhbmNlbFVuZGlzcGF0Y2hlZCkgOiBjYW5jZWxVbmRpc3BhdGNoZWQodG9DYW5jZWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgJiYgKHJlc3BvbnNlLmVycm9yICE9PSB1bmRlZmluZWQgfHwgcmVzcG9uc2UucmVzdWx0ICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlUXVldWUuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0VG9rZW5zLmRlbGV0ZShjYW5jZWxJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5pZCA9IHRvQ2FuY2VsLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2VTZW5kaW5nUmVzcG9uc2UocmVzcG9uc2UsIG1lc3NhZ2UubWV0aG9kLCBEYXRlLm5vdygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VXcml0ZXIud3JpdGUocmVzcG9uc2UpLmNhdGNoKCgpID0+IGxvZ2dlci5lcnJvcihgU2VuZGluZyByZXNwb25zZSBmb3IgY2FuY2VsZWQgbWVzc2FnZSBmYWlsZWQuYCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNhbmNlbGxhdGlvblRva2VuID0gcmVxdWVzdFRva2Vucy5nZXQoY2FuY2VsSWQpO1xuICAgICAgICAgICAgICAgIC8vIFRoZSByZXF1ZXN0IGlzIGFscmVhZHkgcnVubmluZy4gQ2FuY2VsIHRoZSB0b2tlblxuICAgICAgICAgICAgICAgIGlmIChjYW5jZWxsYXRpb25Ub2tlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbGxhdGlvblRva2VuLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICB0cmFjZVJlY2VpdmVkTm90aWZpY2F0aW9uKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGUgY2FuY2VsIGJ1dCBzdGlsbCBxdWV1ZSB0aGUgbWVzc2FnZSB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBjbGVhbiB1cCBzdGF0ZSBpbiBwcm9jZXNzIG1lc3NhZ2UuXG4gICAgICAgICAgICAgICAgICAgIGtub3duQ2FuY2VsZWRSZXF1ZXN0cy5hZGQoY2FuY2VsSWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZE1lc3NhZ2VUb1F1ZXVlKG1lc3NhZ2VRdWV1ZSwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cmlnZ2VyTWVzc2FnZVF1ZXVlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGhhbmRsZVJlcXVlc3QocmVxdWVzdE1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKGlzRGlzcG9zZWQoKSkge1xuICAgICAgICAgICAgLy8gd2UgcmV0dXJuIGhlcmUgc2lsZW50bHkgc2luY2Ugd2UgZmlyZWQgYW4gZXZlbnQgd2hlbiB0aGVcbiAgICAgICAgICAgIC8vIGNvbm5lY3Rpb24gZ290IGRpc3Bvc2VkLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlcGx5KHJlc3VsdE9yRXJyb3IsIG1ldGhvZCwgc3RhcnRUaW1lKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgIGpzb25ycGM6IHZlcnNpb24sXG4gICAgICAgICAgICAgICAgaWQ6IHJlcXVlc3RNZXNzYWdlLmlkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHJlc3VsdE9yRXJyb3IgaW5zdGFuY2VvZiBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmVycm9yID0gcmVzdWx0T3JFcnJvci50b0pzb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVzdWx0ID0gcmVzdWx0T3JFcnJvciA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHJlc3VsdE9yRXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFjZVNlbmRpbmdSZXNwb25zZShtZXNzYWdlLCBtZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICBtZXNzYWdlV3JpdGVyLndyaXRlKG1lc3NhZ2UpLmNhdGNoKCgpID0+IGxvZ2dlci5lcnJvcihgU2VuZGluZyByZXNwb25zZSBmYWlsZWQuYCkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlcGx5RXJyb3IoZXJyb3IsIG1ldGhvZCwgc3RhcnRUaW1lKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgIGpzb25ycGM6IHZlcnNpb24sXG4gICAgICAgICAgICAgICAgaWQ6IHJlcXVlc3RNZXNzYWdlLmlkLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci50b0pzb24oKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRyYWNlU2VuZGluZ1Jlc3BvbnNlKG1lc3NhZ2UsIG1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgIG1lc3NhZ2VXcml0ZXIud3JpdGUobWVzc2FnZSkuY2F0Y2goKCkgPT4gbG9nZ2VyLmVycm9yKGBTZW5kaW5nIHJlc3BvbnNlIGZhaWxlZC5gKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVwbHlTdWNjZXNzKHJlc3VsdCwgbWV0aG9kLCBzdGFydFRpbWUpIHtcbiAgICAgICAgICAgIC8vIFRoZSBKU09OIFJQQyBkZWZpbmVzIHRoYXQgYSByZXNwb25zZSBtdXN0IGVpdGhlciBoYXZlIGEgcmVzdWx0IG9yIGFuIGVycm9yXG4gICAgICAgICAgICAvLyBTbyB3ZSBjYW4ndCB0cmVhdCB1bmRlZmluZWQgYXMgYSB2YWxpZCByZXNwb25zZSByZXN1bHQuXG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICBqc29ucnBjOiB2ZXJzaW9uLFxuICAgICAgICAgICAgICAgIGlkOiByZXF1ZXN0TWVzc2FnZS5pZCxcbiAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRyYWNlU2VuZGluZ1Jlc3BvbnNlKG1lc3NhZ2UsIG1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgIG1lc3NhZ2VXcml0ZXIud3JpdGUobWVzc2FnZSkuY2F0Y2goKCkgPT4gbG9nZ2VyLmVycm9yKGBTZW5kaW5nIHJlc3BvbnNlIGZhaWxlZC5gKSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2VSZWNlaXZlZFJlcXVlc3QocmVxdWVzdE1lc3NhZ2UpO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gcmVxdWVzdEhhbmRsZXJzLmdldChyZXF1ZXN0TWVzc2FnZS5tZXRob2QpO1xuICAgICAgICBsZXQgdHlwZTtcbiAgICAgICAgbGV0IHJlcXVlc3RIYW5kbGVyO1xuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgdHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgICAgICAgICAgIHJlcXVlc3RIYW5kbGVyID0gZWxlbWVudC5oYW5kbGVyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGlmIChyZXF1ZXN0SGFuZGxlciB8fCBzdGFyUmVxdWVzdEhhbmRsZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuS2V5ID0gcmVxdWVzdE1lc3NhZ2UuaWQgPz8gU3RyaW5nKERhdGUubm93KCkpOyAvL1xuICAgICAgICAgICAgY29uc3QgY2FuY2VsbGF0aW9uU291cmNlID0gSWRDYW5jZWxsYXRpb25SZWNlaXZlclN0cmF0ZWd5LmlzKGNhbmNlbGxhdGlvblN0cmF0ZWd5LnJlY2VpdmVyKVxuICAgICAgICAgICAgICAgID8gY2FuY2VsbGF0aW9uU3RyYXRlZ3kucmVjZWl2ZXIuY3JlYXRlQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UodG9rZW5LZXkpXG4gICAgICAgICAgICAgICAgOiBjYW5jZWxsYXRpb25TdHJhdGVneS5yZWNlaXZlci5jcmVhdGVDYW5jZWxsYXRpb25Ub2tlblNvdXJjZShyZXF1ZXN0TWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAocmVxdWVzdE1lc3NhZ2UuaWQgIT09IG51bGwgJiYga25vd25DYW5jZWxlZFJlcXVlc3RzLmhhcyhyZXF1ZXN0TWVzc2FnZS5pZCkpIHtcbiAgICAgICAgICAgICAgICBjYW5jZWxsYXRpb25Tb3VyY2UuY2FuY2VsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxdWVzdE1lc3NhZ2UuaWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0VG9rZW5zLnNldCh0b2tlbktleSwgY2FuY2VsbGF0aW9uU291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IGhhbmRsZXJSZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3RIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0TWVzc2FnZS5wYXJhbXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLm51bWJlck9mUGFyYW1zICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbHlFcnJvcihuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5JbnZhbGlkUGFyYW1zLCBgUmVxdWVzdCAke3JlcXVlc3RNZXNzYWdlLm1ldGhvZH0gZGVmaW5lcyAke3R5cGUubnVtYmVyT2ZQYXJhbXN9IHBhcmFtcyBidXQgcmVjZWl2ZWQgbm9uZS5gKSwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJSZXN1bHQgPSByZXF1ZXN0SGFuZGxlcihjYW5jZWxsYXRpb25Tb3VyY2UudG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVxdWVzdE1lc3NhZ2UucGFyYW1zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLnBhcmFtZXRlclN0cnVjdHVyZXMgPT09IG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5ieU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBseUVycm9yKG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLkludmFsaWRQYXJhbXMsIGBSZXF1ZXN0ICR7cmVxdWVzdE1lc3NhZ2UubWV0aG9kfSBkZWZpbmVzIHBhcmFtZXRlcnMgYnkgbmFtZSBidXQgcmVjZWl2ZWQgcGFyYW1ldGVycyBieSBwb3NpdGlvbmApLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlclJlc3VsdCA9IHJlcXVlc3RIYW5kbGVyKC4uLnJlcXVlc3RNZXNzYWdlLnBhcmFtcywgY2FuY2VsbGF0aW9uU291cmNlLnRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS5wYXJhbWV0ZXJTdHJ1Y3R1cmVzID09PSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYnlQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGx5RXJyb3IobmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihtZXNzYWdlc18xLkVycm9yQ29kZXMuSW52YWxpZFBhcmFtcywgYFJlcXVlc3QgJHtyZXF1ZXN0TWVzc2FnZS5tZXRob2R9IGRlZmluZXMgcGFyYW1ldGVycyBieSBwb3NpdGlvbiBidXQgcmVjZWl2ZWQgcGFyYW1ldGVycyBieSBuYW1lYCksIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyUmVzdWx0ID0gcmVxdWVzdEhhbmRsZXIocmVxdWVzdE1lc3NhZ2UucGFyYW1zLCBjYW5jZWxsYXRpb25Tb3VyY2UudG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJSZXF1ZXN0SGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyUmVzdWx0ID0gc3RhclJlcXVlc3RIYW5kbGVyKHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgcmVxdWVzdE1lc3NhZ2UucGFyYW1zLCBjYW5jZWxsYXRpb25Tb3VyY2UudG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlID0gaGFuZGxlclJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoIWhhbmRsZXJSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFRva2Vucy5kZWxldGUodG9rZW5LZXkpO1xuICAgICAgICAgICAgICAgICAgICByZXBseVN1Y2Nlc3MoaGFuZGxlclJlc3VsdCwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm9taXNlLnRoZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS50aGVuKChyZXN1bHRPckVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0VG9rZW5zLmRlbGV0ZSh0b2tlbktleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXBseShyZXN1bHRPckVycm9yLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RUb2tlbnMuZGVsZXRlKHRva2VuS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGx5RXJyb3IoZXJyb3IsIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yICYmIElzLnN0cmluZyhlcnJvci5tZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGx5RXJyb3IobmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihtZXNzYWdlc18xLkVycm9yQ29kZXMuSW50ZXJuYWxFcnJvciwgYFJlcXVlc3QgJHtyZXF1ZXN0TWVzc2FnZS5tZXRob2R9IGZhaWxlZCB3aXRoIG1lc3NhZ2U6ICR7ZXJyb3IubWVzc2FnZX1gKSwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbHlFcnJvcihuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5JbnRlcm5hbEVycm9yLCBgUmVxdWVzdCAke3JlcXVlc3RNZXNzYWdlLm1ldGhvZH0gZmFpbGVkIHVuZXhwZWN0ZWRseSB3aXRob3V0IHByb3ZpZGluZyBhbnkgZGV0YWlscy5gKSwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RUb2tlbnMuZGVsZXRlKHRva2VuS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgcmVwbHkoaGFuZGxlclJlc3VsdCwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RUb2tlbnMuZGVsZXRlKHRva2VuS2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVwbHkoZXJyb3IsIHJlcXVlc3RNZXNzYWdlLm1ldGhvZCwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IgJiYgSXMuc3RyaW5nKGVycm9yLm1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcGx5RXJyb3IobmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihtZXNzYWdlc18xLkVycm9yQ29kZXMuSW50ZXJuYWxFcnJvciwgYFJlcXVlc3QgJHtyZXF1ZXN0TWVzc2FnZS5tZXRob2R9IGZhaWxlZCB3aXRoIG1lc3NhZ2U6ICR7ZXJyb3IubWVzc2FnZX1gKSwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVwbHlFcnJvcihuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5JbnRlcm5hbEVycm9yLCBgUmVxdWVzdCAke3JlcXVlc3RNZXNzYWdlLm1ldGhvZH0gZmFpbGVkIHVuZXhwZWN0ZWRseSB3aXRob3V0IHByb3ZpZGluZyBhbnkgZGV0YWlscy5gKSwgcmVxdWVzdE1lc3NhZ2UubWV0aG9kLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcGx5RXJyb3IobmV3IG1lc3NhZ2VzXzEuUmVzcG9uc2VFcnJvcihtZXNzYWdlc18xLkVycm9yQ29kZXMuTWV0aG9kTm90Rm91bmQsIGBVbmhhbmRsZWQgbWV0aG9kICR7cmVxdWVzdE1lc3NhZ2UubWV0aG9kfWApLCByZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHN0YXJ0VGltZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlUmVzcG9uc2UocmVzcG9uc2VNZXNzYWdlKSB7XG4gICAgICAgIGlmIChpc0Rpc3Bvc2VkKCkpIHtcbiAgICAgICAgICAgIC8vIFNlZSBoYW5kbGUgcmVxdWVzdC5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzcG9uc2VNZXNzYWdlLmlkID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VNZXNzYWdlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBSZWNlaXZlZCByZXNwb25zZSBtZXNzYWdlIHdpdGhvdXQgaWQ6IEVycm9yIGlzOiBcXG4ke0pTT04uc3RyaW5naWZ5KHJlc3BvbnNlTWVzc2FnZS5lcnJvciwgdW5kZWZpbmVkLCA0KX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgUmVjZWl2ZWQgcmVzcG9uc2UgbWVzc2FnZSB3aXRob3V0IGlkLiBObyBmdXJ0aGVyIGVycm9yIGluZm9ybWF0aW9uIHByb3ZpZGVkLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gcmVzcG9uc2VNZXNzYWdlLmlkO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VQcm9taXNlID0gcmVzcG9uc2VQcm9taXNlcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIHRyYWNlUmVjZWl2ZWRSZXNwb25zZShyZXNwb25zZU1lc3NhZ2UsIHJlc3BvbnNlUHJvbWlzZSk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VQcm9taXNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZVByb21pc2VzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZU1lc3NhZ2UuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gcmVzcG9uc2VNZXNzYWdlLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlLnJlamVjdChuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKGVycm9yLmNvZGUsIGVycm9yLm1lc3NhZ2UsIGVycm9yLmRhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXNwb25zZU1lc3NhZ2UucmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZS5yZXNvbHZlKHJlc3BvbnNlTWVzc2FnZS5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbmV2ZXIgaGFwcGVuLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBSZXNwb25zZSBoYW5kbGVyICcke3Jlc3BvbnNlUHJvbWlzZS5tZXRob2R9JyBmYWlsZWQgd2l0aCBtZXNzYWdlOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYFJlc3BvbnNlIGhhbmRsZXIgJyR7cmVzcG9uc2VQcm9taXNlLm1ldGhvZH0nIGZhaWxlZCB1bmV4cGVjdGVkbHkuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlTm90aWZpY2F0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKGlzRGlzcG9zZWQoKSkge1xuICAgICAgICAgICAgLy8gU2VlIGhhbmRsZSByZXF1ZXN0LlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0eXBlID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgbm90aWZpY2F0aW9uSGFuZGxlcjtcbiAgICAgICAgaWYgKG1lc3NhZ2UubWV0aG9kID09PSBDYW5jZWxOb3RpZmljYXRpb24udHlwZS5tZXRob2QpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbElkID0gbWVzc2FnZS5wYXJhbXMuaWQ7XG4gICAgICAgICAgICBrbm93bkNhbmNlbGVkUmVxdWVzdHMuZGVsZXRlKGNhbmNlbElkKTtcbiAgICAgICAgICAgIHRyYWNlUmVjZWl2ZWROb3RpZmljYXRpb24obWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gbm90aWZpY2F0aW9uSGFuZGxlcnMuZ2V0KG1lc3NhZ2UubWV0aG9kKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uSGFuZGxlciA9IGVsZW1lbnQuaGFuZGxlcjtcbiAgICAgICAgICAgICAgICB0eXBlID0gZWxlbWVudC50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub3RpZmljYXRpb25IYW5kbGVyIHx8IHN0YXJOb3RpZmljYXRpb25IYW5kbGVyKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRyYWNlUmVjZWl2ZWROb3RpZmljYXRpb24obWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5vdGlmaWNhdGlvbkhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UucGFyYW1zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZS5udW1iZXJPZlBhcmFtcyAhPT0gMCAmJiB0eXBlLnBhcmFtZXRlclN0cnVjdHVyZXMgIT09IG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5ieU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBOb3RpZmljYXRpb24gJHttZXNzYWdlLm1ldGhvZH0gZGVmaW5lcyAke3R5cGUubnVtYmVyT2ZQYXJhbXN9IHBhcmFtcyBidXQgcmVjZWl2ZWQgbm9uZS5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb25IYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShtZXNzYWdlLnBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGFyZSBKU09OLVJQQyBsaWJyYXJpZXMgdGhhdCBzZW5kIHByb2dyZXNzIG1lc3NhZ2UgYXMgcG9zaXRpb25hbCBwYXJhbXMgYWx0aG91Z2hcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZCBhcyBuYW1lZC4gU28gY29udmVydCB0aGVtIGlmIHRoaXMgaXMgdGhlIGNhc2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBtZXNzYWdlLnBhcmFtcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLm1ldGhvZCA9PT0gUHJvZ3Jlc3NOb3RpZmljYXRpb24udHlwZS5tZXRob2QgJiYgcGFyYW1zLmxlbmd0aCA9PT0gMiAmJiBQcm9ncmVzc1Rva2VuLmlzKHBhcmFtc1swXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb25IYW5kbGVyKHsgdG9rZW46IHBhcmFtc1swXSwgdmFsdWU6IHBhcmFtc1sxXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUucGFyYW1ldGVyU3RydWN0dXJlcyA9PT0gbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBOb3RpZmljYXRpb24gJHttZXNzYWdlLm1ldGhvZH0gZGVmaW5lcyBwYXJhbWV0ZXJzIGJ5IG5hbWUgYnV0IHJlY2VpdmVkIHBhcmFtZXRlcnMgYnkgcG9zaXRpb25gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZS5udW1iZXJPZlBhcmFtcyAhPT0gbWVzc2FnZS5wYXJhbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYE5vdGlmaWNhdGlvbiAke21lc3NhZ2UubWV0aG9kfSBkZWZpbmVzICR7dHlwZS5udW1iZXJPZlBhcmFtc30gcGFyYW1zIGJ1dCByZWNlaXZlZCAke3BhcmFtcy5sZW5ndGh9IGFyZ3VtZW50c2ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbkhhbmRsZXIoLi4ucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS5wYXJhbWV0ZXJTdHJ1Y3R1cmVzID09PSBtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuYnlQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgTm90aWZpY2F0aW9uICR7bWVzc2FnZS5tZXRob2R9IGRlZmluZXMgcGFyYW1ldGVycyBieSBwb3NpdGlvbiBidXQgcmVjZWl2ZWQgcGFyYW1ldGVycyBieSBuYW1lYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb25IYW5kbGVyKG1lc3NhZ2UucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGFyTm90aWZpY2F0aW9uSGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICBzdGFyTm90aWZpY2F0aW9uSGFuZGxlcihtZXNzYWdlLm1ldGhvZCwgbWVzc2FnZS5wYXJhbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgTm90aWZpY2F0aW9uIGhhbmRsZXIgJyR7bWVzc2FnZS5tZXRob2R9JyBmYWlsZWQgd2l0aCBtZXNzYWdlOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYE5vdGlmaWNhdGlvbiBoYW5kbGVyICcke21lc3NhZ2UubWV0aG9kfScgZmFpbGVkIHVuZXhwZWN0ZWRseS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1bmhhbmRsZWROb3RpZmljYXRpb25FbWl0dGVyLmZpcmUobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlSW52YWxpZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcignUmVjZWl2ZWQgZW1wdHkgbWVzc2FnZS4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZXJyb3IoYFJlY2VpdmVkIG1lc3NhZ2Ugd2hpY2ggaXMgbmVpdGhlciBhIHJlc3BvbnNlIG5vciBhIG5vdGlmaWNhdGlvbiBtZXNzYWdlOlxcbiR7SlNPTi5zdHJpbmdpZnkobWVzc2FnZSwgbnVsbCwgNCl9YCk7XG4gICAgICAgIC8vIFRlc3Qgd2hldGhlciB3ZSBmaW5kIGFuIGlkIHRvIHJlamVjdCB0aGUgcHJvbWlzZVxuICAgICAgICBjb25zdCByZXNwb25zZU1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICBpZiAoSXMuc3RyaW5nKHJlc3BvbnNlTWVzc2FnZS5pZCkgfHwgSXMubnVtYmVyKHJlc3BvbnNlTWVzc2FnZS5pZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHJlc3BvbnNlTWVzc2FnZS5pZDtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlSGFuZGxlciA9IHJlc3BvbnNlUHJvbWlzZXMuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VIYW5kbGVyLnJlamVjdChuZXcgRXJyb3IoJ1RoZSByZWNlaXZlZCByZXNwb25zZSBoYXMgbmVpdGhlciBhIHJlc3VsdCBub3IgYW4gZXJyb3IgcHJvcGVydHkuJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0cmluZ2lmeVRyYWNlKHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zID09PSB1bmRlZmluZWQgfHwgcGFyYW1zID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodHJhY2UpIHtcbiAgICAgICAgICAgIGNhc2UgVHJhY2UuVmVyYm9zZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGFyYW1zLCBudWxsLCA0KTtcbiAgICAgICAgICAgIGNhc2UgVHJhY2UuQ29tcGFjdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGFyYW1zKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFjZVNlbmRpbmdSZXF1ZXN0KG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5PZmYgfHwgIXRyYWNlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFjZUZvcm1hdCA9PT0gVHJhY2VGb3JtYXQuVGV4dCkge1xuICAgICAgICAgICAgbGV0IGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoKHRyYWNlID09PSBUcmFjZS5WZXJib3NlIHx8IHRyYWNlID09PSBUcmFjZS5Db21wYWN0KSAmJiBtZXNzYWdlLnBhcmFtcykge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBgUGFyYW1zOiAke3N0cmluZ2lmeVRyYWNlKG1lc3NhZ2UucGFyYW1zKX1cXG5cXG5gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2VyLmxvZyhgU2VuZGluZyByZXF1ZXN0ICcke21lc3NhZ2UubWV0aG9kfSAtICgke21lc3NhZ2UuaWR9KScuYCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dMU1BNZXNzYWdlKCdzZW5kLXJlcXVlc3QnLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFjZVNlbmRpbmdOb3RpZmljYXRpb24obWVzc2FnZSkge1xuICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLk9mZiB8fCAhdHJhY2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNlRm9ybWF0ID09PSBUcmFjZUZvcm1hdC5UZXh0KSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuVmVyYm9zZSB8fCB0cmFjZSA9PT0gVHJhY2UuQ29tcGFjdCkge1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gYFBhcmFtczogJHtzdHJpbmdpZnlUcmFjZShtZXNzYWdlLnBhcmFtcyl9XFxuXFxuYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSAnTm8gcGFyYW1ldGVycyBwcm92aWRlZC5cXG5cXG4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNlci5sb2coYFNlbmRpbmcgbm90aWZpY2F0aW9uICcke21lc3NhZ2UubWV0aG9kfScuYCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dMU1BNZXNzYWdlKCdzZW5kLW5vdGlmaWNhdGlvbicsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYWNlU2VuZGluZ1Jlc3BvbnNlKG1lc3NhZ2UsIG1ldGhvZCwgc3RhcnRUaW1lKSB7XG4gICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuT2ZmIHx8ICF0cmFjZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhY2VGb3JtYXQgPT09IFRyYWNlRm9ybWF0LlRleHQpIHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5WZXJib3NlIHx8IHRyYWNlID09PSBUcmFjZS5Db21wYWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZXJyb3IgJiYgbWVzc2FnZS5lcnJvci5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBgRXJyb3IgZGF0YTogJHtzdHJpbmdpZnlUcmFjZShtZXNzYWdlLmVycm9yLmRhdGEpfVxcblxcbmA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBgUmVzdWx0OiAke3N0cmluZ2lmeVRyYWNlKG1lc3NhZ2UucmVzdWx0KX1cXG5cXG5gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1lc3NhZ2UuZXJyb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9ICdObyByZXN1bHQgcmV0dXJuZWQuXFxuXFxuJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNlci5sb2coYFNlbmRpbmcgcmVzcG9uc2UgJyR7bWV0aG9kfSAtICgke21lc3NhZ2UuaWR9KScuIFByb2Nlc3NpbmcgcmVxdWVzdCB0b29rICR7RGF0ZS5ub3coKSAtIHN0YXJ0VGltZX1tc2AsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nTFNQTWVzc2FnZSgnc2VuZC1yZXNwb25zZScsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYWNlUmVjZWl2ZWRSZXF1ZXN0KG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5PZmYgfHwgIXRyYWNlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFjZUZvcm1hdCA9PT0gVHJhY2VGb3JtYXQuVGV4dCkge1xuICAgICAgICAgICAgbGV0IGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoKHRyYWNlID09PSBUcmFjZS5WZXJib3NlIHx8IHRyYWNlID09PSBUcmFjZS5Db21wYWN0KSAmJiBtZXNzYWdlLnBhcmFtcykge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBgUGFyYW1zOiAke3N0cmluZ2lmeVRyYWNlKG1lc3NhZ2UucGFyYW1zKX1cXG5cXG5gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2VyLmxvZyhgUmVjZWl2ZWQgcmVxdWVzdCAnJHttZXNzYWdlLm1ldGhvZH0gLSAoJHttZXNzYWdlLmlkfSknLmAsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nTFNQTWVzc2FnZSgncmVjZWl2ZS1yZXF1ZXN0JywgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhY2VSZWNlaXZlZE5vdGlmaWNhdGlvbihtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuT2ZmIHx8ICF0cmFjZXIgfHwgbWVzc2FnZS5tZXRob2QgPT09IExvZ1RyYWNlTm90aWZpY2F0aW9uLnR5cGUubWV0aG9kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYWNlRm9ybWF0ID09PSBUcmFjZUZvcm1hdC5UZXh0KSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuVmVyYm9zZSB8fCB0cmFjZSA9PT0gVHJhY2UuQ29tcGFjdCkge1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gYFBhcmFtczogJHtzdHJpbmdpZnlUcmFjZShtZXNzYWdlLnBhcmFtcyl9XFxuXFxuYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSAnTm8gcGFyYW1ldGVycyBwcm92aWRlZC5cXG5cXG4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNlci5sb2coYFJlY2VpdmVkIG5vdGlmaWNhdGlvbiAnJHttZXNzYWdlLm1ldGhvZH0nLmAsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nTFNQTWVzc2FnZSgncmVjZWl2ZS1ub3RpZmljYXRpb24nLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFjZVJlY2VpdmVkUmVzcG9uc2UobWVzc2FnZSwgcmVzcG9uc2VQcm9taXNlKSB7XG4gICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuT2ZmIHx8ICF0cmFjZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhY2VGb3JtYXQgPT09IFRyYWNlRm9ybWF0LlRleHQpIHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHRyYWNlID09PSBUcmFjZS5WZXJib3NlIHx8IHRyYWNlID09PSBUcmFjZS5Db21wYWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZXJyb3IgJiYgbWVzc2FnZS5lcnJvci5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBgRXJyb3IgZGF0YTogJHtzdHJpbmdpZnlUcmFjZShtZXNzYWdlLmVycm9yLmRhdGEpfVxcblxcbmA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBgUmVzdWx0OiAke3N0cmluZ2lmeVRyYWNlKG1lc3NhZ2UucmVzdWx0KX1cXG5cXG5gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1lc3NhZ2UuZXJyb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9ICdObyByZXN1bHQgcmV0dXJuZWQuXFxuXFxuJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXNwb25zZVByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG1lc3NhZ2UuZXJyb3IgPyBgIFJlcXVlc3QgZmFpbGVkOiAke21lc3NhZ2UuZXJyb3IubWVzc2FnZX0gKCR7bWVzc2FnZS5lcnJvci5jb2RlfSkuYCA6ICcnO1xuICAgICAgICAgICAgICAgIHRyYWNlci5sb2coYFJlY2VpdmVkIHJlc3BvbnNlICcke3Jlc3BvbnNlUHJvbWlzZS5tZXRob2R9IC0gKCR7bWVzc2FnZS5pZH0pJyBpbiAke0RhdGUubm93KCkgLSByZXNwb25zZVByb21pc2UudGltZXJTdGFydH1tcy4ke2Vycm9yfWAsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhY2VyLmxvZyhgUmVjZWl2ZWQgcmVzcG9uc2UgJHttZXNzYWdlLmlkfSB3aXRob3V0IGFjdGl2ZSByZXNwb25zZSBwcm9taXNlLmAsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nTFNQTWVzc2FnZSgncmVjZWl2ZS1yZXNwb25zZScsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxvZ0xTUE1lc3NhZ2UodHlwZSwgbWVzc2FnZSkge1xuICAgICAgICBpZiAoIXRyYWNlciB8fCB0cmFjZSA9PT0gVHJhY2UuT2ZmKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbHNwTWVzc2FnZSA9IHtcbiAgICAgICAgICAgIGlzTFNQTWVzc2FnZTogdHJ1ZSxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXG4gICAgICAgIH07XG4gICAgICAgIHRyYWNlci5sb2cobHNwTWVzc2FnZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRocm93SWZDbG9zZWRPckRpc3Bvc2VkKCkge1xuICAgICAgICBpZiAoaXNDbG9zZWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENvbm5lY3Rpb25FcnJvcihDb25uZWN0aW9uRXJyb3JzLkNsb3NlZCwgJ0Nvbm5lY3Rpb24gaXMgY2xvc2VkLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Rpc3Bvc2VkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDb25uZWN0aW9uRXJyb3IoQ29ubmVjdGlvbkVycm9ycy5EaXNwb3NlZCwgJ0Nvbm5lY3Rpb24gaXMgZGlzcG9zZWQuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdGhyb3dJZkxpc3RlbmluZygpIHtcbiAgICAgICAgaWYgKGlzTGlzdGVuaW5nKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDb25uZWN0aW9uRXJyb3IoQ29ubmVjdGlvbkVycm9ycy5BbHJlYWR5TGlzdGVuaW5nLCAnQ29ubmVjdGlvbiBpcyBhbHJlYWR5IGxpc3RlbmluZycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRocm93SWZOb3RMaXN0ZW5pbmcoKSB7XG4gICAgICAgIGlmICghaXNMaXN0ZW5pbmcoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYWxsIGxpc3RlbigpIGZpcnN0LicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuZGVmaW5lZFRvTnVsbChwYXJhbSkge1xuICAgICAgICBpZiAocGFyYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbnVsbFRvVW5kZWZpbmVkKHBhcmFtKSB7XG4gICAgICAgIGlmIChwYXJhbSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpc05hbWVkUGFyYW0ocGFyYW0pIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtICE9PSB1bmRlZmluZWQgJiYgcGFyYW0gIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkocGFyYW0pICYmIHR5cGVvZiBwYXJhbSA9PT0gJ29iamVjdCc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXB1dGVTaW5nbGVQYXJhbShwYXJhbWV0ZXJTdHJ1Y3R1cmVzLCBwYXJhbSkge1xuICAgICAgICBzd2l0Y2ggKHBhcmFtZXRlclN0cnVjdHVyZXMpIHtcbiAgICAgICAgICAgIGNhc2UgbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG86XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFtZWRQYXJhbShwYXJhbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGxUb1VuZGVmaW5lZChwYXJhbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3VuZGVmaW5lZFRvTnVsbChwYXJhbSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5TmFtZTpcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFtZWRQYXJhbShwYXJhbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWNlaXZlZCBwYXJhbWV0ZXJzIGJ5IG5hbWUgYnV0IHBhcmFtIGlzIG5vdCBhbiBvYmplY3QgbGl0ZXJhbC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGxUb1VuZGVmaW5lZChwYXJhbSk7XG4gICAgICAgICAgICBjYXNlIG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5ieVBvc2l0aW9uOlxuICAgICAgICAgICAgICAgIHJldHVybiBbdW5kZWZpbmVkVG9OdWxsKHBhcmFtKV07XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBwYXJhbWV0ZXIgc3RydWN0dXJlICR7cGFyYW1ldGVyU3RydWN0dXJlcy50b1N0cmluZygpfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXB1dGVNZXNzYWdlUGFyYW1zKHR5cGUsIHBhcmFtcykge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBjb25zdCBudW1iZXJPZlBhcmFtcyA9IHR5cGUubnVtYmVyT2ZQYXJhbXM7XG4gICAgICAgIHN3aXRjaCAobnVtYmVyT2ZQYXJhbXMpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gY29tcHV0ZVNpbmdsZVBhcmFtKHR5cGUucGFyYW1ldGVyU3RydWN0dXJlcywgcGFyYW1zWzBdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoICYmIGkgPCBudW1iZXJPZlBhcmFtczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHVuZGVmaW5lZFRvTnVsbChwYXJhbXNbaV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPCBudW1iZXJPZlBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gcGFyYW1zLmxlbmd0aDsgaSA8IG51bWJlck9mUGFyYW1zOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB7XG4gICAgICAgIHNlbmROb3RpZmljYXRpb246ICh0eXBlLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICB0aHJvd0lmQ2xvc2VkT3JEaXNwb3NlZCgpO1xuICAgICAgICAgICAgbGV0IG1ldGhvZDtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlUGFyYW1zO1xuICAgICAgICAgICAgaWYgKElzLnN0cmluZyh0eXBlKSkge1xuICAgICAgICAgICAgICAgIG1ldGhvZCA9IHR5cGU7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3QgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIGxldCBwYXJhbVN0YXJ0ID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgcGFyYW1ldGVyU3RydWN0dXJlcyA9IG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5hdXRvO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlc18xLlBhcmFtZXRlclN0cnVjdHVyZXMuaXMoZmlyc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtU3RhcnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gZmlyc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBwYXJhbUVuZCA9IGFyZ3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnN0IG51bWJlck9mUGFyYW1zID0gcGFyYW1FbmQgLSBwYXJhbVN0YXJ0O1xuICAgICAgICAgICAgICAgIHN3aXRjaCAobnVtYmVyT2ZQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlUGFyYW1zID0gY29tcHV0ZVNpbmdsZVBhcmFtKHBhcmFtZXRlclN0cnVjdHVyZXMsIGFyZ3NbcGFyYW1TdGFydF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1ldGVyU3RydWN0dXJlcyA9PT0gbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVjZWl2ZWQgJHtudW1iZXJPZlBhcmFtc30gcGFyYW1ldGVycyBmb3IgJ2J5IE5hbWUnIG5vdGlmaWNhdGlvbiBwYXJhbWV0ZXIgc3RydWN0dXJlLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyA9IGFyZ3Muc2xpY2UocGFyYW1TdGFydCwgcGFyYW1FbmQpLm1hcCh2YWx1ZSA9PiB1bmRlZmluZWRUb051bGwodmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gdHlwZS5tZXRob2Q7XG4gICAgICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyA9IGNvbXB1dGVNZXNzYWdlUGFyYW1zKHR5cGUsIHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBub3RpZmljYXRpb25NZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgIGpzb25ycGM6IHZlcnNpb24sXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBtZXNzYWdlUGFyYW1zXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJhY2VTZW5kaW5nTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbk1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2VXcml0ZXIud3JpdGUobm90aWZpY2F0aW9uTWVzc2FnZSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBTZW5kaW5nIG5vdGlmaWNhdGlvbiBmYWlsZWQuYCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Ob3RpZmljYXRpb246ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICB0aHJvd0lmQ2xvc2VkT3JEaXNwb3NlZCgpO1xuICAgICAgICAgICAgbGV0IG1ldGhvZDtcbiAgICAgICAgICAgIGlmIChJcy5mdW5jKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgc3Rhck5vdGlmaWNhdGlvbkhhbmRsZXIgPSB0eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGlmIChJcy5zdHJpbmcodHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kID0gdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uSGFuZGxlcnMuc2V0KHR5cGUsIHsgdHlwZTogdW5kZWZpbmVkLCBoYW5kbGVyIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kID0gdHlwZS5tZXRob2Q7XG4gICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbkhhbmRsZXJzLnNldCh0eXBlLm1ldGhvZCwgeyB0eXBlLCBoYW5kbGVyIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGlzcG9zZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbkhhbmRsZXJzLmRlbGV0ZShtZXRob2QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Rhck5vdGlmaWNhdGlvbkhhbmRsZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBvblByb2dyZXNzOiAoX3R5cGUsIHRva2VuLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICBpZiAocHJvZ3Jlc3NIYW5kbGVycy5oYXModG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm9ncmVzcyBoYW5kbGVyIGZvciB0b2tlbiAke3Rva2VufSBhbHJlYWR5IHJlZ2lzdGVyZWRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb2dyZXNzSGFuZGxlcnMuc2V0KHRva2VuLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGlzcG9zZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc0hhbmRsZXJzLmRlbGV0ZSh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgc2VuZFByb2dyZXNzOiAoX3R5cGUsIHRva2VuLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgbm90IGF3YWl0IGJ1dCBzaW1wbGUgcmV0dXJuIHRvIGVuc3VyZSB0aGF0IHdlIGRvbid0IGhhdmUgYW5vdGhlclxuICAgICAgICAgICAgLy8gYXN5bmMgc2NoZWR1bGluZy4gT3RoZXJ3aXNlIG9uZSBzZW5kIGNvdWxkIG92ZXJ0YWtlIGFub3RoZXIgc2VuZC5cbiAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uLnNlbmROb3RpZmljYXRpb24oUHJvZ3Jlc3NOb3RpZmljYXRpb24udHlwZSwgeyB0b2tlbiwgdmFsdWUgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uVW5oYW5kbGVkUHJvZ3Jlc3M6IHVuaGFuZGxlZFByb2dyZXNzRW1pdHRlci5ldmVudCxcbiAgICAgICAgc2VuZFJlcXVlc3Q6ICh0eXBlLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICB0aHJvd0lmQ2xvc2VkT3JEaXNwb3NlZCgpO1xuICAgICAgICAgICAgdGhyb3dJZk5vdExpc3RlbmluZygpO1xuICAgICAgICAgICAgbGV0IG1ldGhvZDtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlUGFyYW1zO1xuICAgICAgICAgICAgbGV0IHRva2VuID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKElzLnN0cmluZyh0eXBlKSkge1xuICAgICAgICAgICAgICAgIG1ldGhvZCA9IHR5cGU7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3QgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3QgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtU3RhcnQgPSAwO1xuICAgICAgICAgICAgICAgIGxldCBwYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG87XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VzXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5pcyhmaXJzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1TdGFydCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlclN0cnVjdHVyZXMgPSBmaXJzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtRW5kID0gYXJncy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGNhbmNlbGxhdGlvbl8xLkNhbmNlbGxhdGlvblRva2VuLmlzKGxhc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtRW5kID0gcGFyYW1FbmQgLSAxO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IGxhc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG51bWJlck9mUGFyYW1zID0gcGFyYW1FbmQgLSBwYXJhbVN0YXJ0O1xuICAgICAgICAgICAgICAgIHN3aXRjaCAobnVtYmVyT2ZQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlUGFyYW1zID0gY29tcHV0ZVNpbmdsZVBhcmFtKHBhcmFtZXRlclN0cnVjdHVyZXMsIGFyZ3NbcGFyYW1TdGFydF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1ldGVyU3RydWN0dXJlcyA9PT0gbWVzc2FnZXNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVjZWl2ZWQgJHtudW1iZXJPZlBhcmFtc30gcGFyYW1ldGVycyBmb3IgJ2J5IE5hbWUnIHJlcXVlc3QgcGFyYW1ldGVyIHN0cnVjdHVyZS5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJhbXMgPSBhcmdzLnNsaWNlKHBhcmFtU3RhcnQsIHBhcmFtRW5kKS5tYXAodmFsdWUgPT4gdW5kZWZpbmVkVG9OdWxsKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBhcmdzO1xuICAgICAgICAgICAgICAgIG1ldGhvZCA9IHR5cGUubWV0aG9kO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJhbXMgPSBjb21wdXRlTWVzc2FnZVBhcmFtcyh0eXBlLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG51bWJlck9mUGFyYW1zID0gdHlwZS5udW1iZXJPZlBhcmFtcztcbiAgICAgICAgICAgICAgICB0b2tlbiA9IGNhbmNlbGxhdGlvbl8xLkNhbmNlbGxhdGlvblRva2VuLmlzKHBhcmFtc1tudW1iZXJPZlBhcmFtc10pID8gcGFyYW1zW251bWJlck9mUGFyYW1zXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlkID0gc2VxdWVuY2VOdW1iZXIrKztcbiAgICAgICAgICAgIGxldCBkaXNwb3NhYmxlO1xuICAgICAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgZGlzcG9zYWJsZSA9IHRva2VuLm9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IGNhbmNlbGxhdGlvblN0cmF0ZWd5LnNlbmRlci5zZW5kQ2FuY2VsbGF0aW9uKGNvbm5lY3Rpb24sIGlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgUmVjZWl2ZWQgbm8gcHJvbWlzZSBmcm9tIGNhbmNlbGxhdGlvbiBzdHJhdGVneSB3aGVuIGNhbmNlbGxpbmcgaWQgJHtpZH1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGBTZW5kaW5nIGNhbmNlbGxhdGlvbiBtZXNzYWdlcyBmb3IgaWQgJHtpZH0gZmFpbGVkYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdE1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAganNvbnJwYzogdmVyc2lvbixcbiAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBtZXNzYWdlUGFyYW1zXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJhY2VTZW5kaW5nUmVxdWVzdChyZXF1ZXN0TWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhbmNlbGxhdGlvblN0cmF0ZWd5LnNlbmRlci5lbmFibGVDYW5jZWxsYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjYW5jZWxsYXRpb25TdHJhdGVneS5zZW5kZXIuZW5hYmxlQ2FuY2VsbGF0aW9uKHJlcXVlc3RNZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZVdpdGhDbGVhbnVwID0gKHIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyKTtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsbGF0aW9uU3RyYXRlZ3kuc2VuZGVyLmNsZWFudXAoaWQpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwb3NhYmxlPy5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCByZWplY3RXaXRoQ2xlYW51cCA9IChyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChyKTtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsbGF0aW9uU3RyYXRlZ3kuc2VuZGVyLmNsZWFudXAoaWQpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwb3NhYmxlPy5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZVByb21pc2UgPSB7IG1ldGhvZDogbWV0aG9kLCB0aW1lclN0YXJ0OiBEYXRlLm5vdygpLCByZXNvbHZlOiByZXNvbHZlV2l0aENsZWFudXAsIHJlamVjdDogcmVqZWN0V2l0aENsZWFudXAgfTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBtZXNzYWdlV3JpdGVyLndyaXRlKHJlcXVlc3RNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlcy5zZXQoaWQsIHJlc3BvbnNlUHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYFNlbmRpbmcgcmVxdWVzdCBmYWlsZWQuYCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdyaXRpbmcgdGhlIG1lc3NhZ2UgZmFpbGVkLiBTbyB3ZSBuZWVkIHRvIHJlamVjdCB0aGUgcHJvbWlzZS5cbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlLnJlamVjdChuZXcgbWVzc2FnZXNfMS5SZXNwb25zZUVycm9yKG1lc3NhZ2VzXzEuRXJyb3JDb2Rlcy5NZXNzYWdlV3JpdGVFcnJvciwgZXJyb3IubWVzc2FnZSA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biByZWFzb24nKSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvblJlcXVlc3Q6ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICB0aHJvd0lmQ2xvc2VkT3JEaXNwb3NlZCgpO1xuICAgICAgICAgICAgbGV0IG1ldGhvZCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoU3RhclJlcXVlc3RIYW5kbGVyLmlzKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHN0YXJSZXF1ZXN0SGFuZGxlciA9IHR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChJcy5zdHJpbmcodHlwZSkpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kID0gdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEhhbmRsZXJzLnNldCh0eXBlLCB7IGhhbmRsZXI6IGhhbmRsZXIsIHR5cGU6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZCA9IHR5cGUubWV0aG9kO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SGFuZGxlcnMuc2V0KHR5cGUubWV0aG9kLCB7IHR5cGUsIGhhbmRsZXIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkaXNwb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RIYW5kbGVycy5kZWxldGUobWV0aG9kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJSZXF1ZXN0SGFuZGxlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGhhc1BlbmRpbmdSZXNwb25zZTogKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlUHJvbWlzZXMuc2l6ZSA+IDA7XG4gICAgICAgIH0sXG4gICAgICAgIHRyYWNlOiBhc3luYyAoX3ZhbHVlLCBfdHJhY2VyLCBzZW5kTm90aWZpY2F0aW9uT3JUcmFjZU9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIGxldCBfc2VuZE5vdGlmaWNhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IF90cmFjZUZvcm1hdCA9IFRyYWNlRm9ybWF0LlRleHQ7XG4gICAgICAgICAgICBpZiAoc2VuZE5vdGlmaWNhdGlvbk9yVHJhY2VPcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoSXMuYm9vbGVhbihzZW5kTm90aWZpY2F0aW9uT3JUcmFjZU9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIF9zZW5kTm90aWZpY2F0aW9uID0gc2VuZE5vdGlmaWNhdGlvbk9yVHJhY2VPcHRpb25zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3NlbmROb3RpZmljYXRpb24gPSBzZW5kTm90aWZpY2F0aW9uT3JUcmFjZU9wdGlvbnMuc2VuZE5vdGlmaWNhdGlvbiB8fCBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgX3RyYWNlRm9ybWF0ID0gc2VuZE5vdGlmaWNhdGlvbk9yVHJhY2VPcHRpb25zLnRyYWNlRm9ybWF0IHx8IFRyYWNlRm9ybWF0LlRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2UgPSBfdmFsdWU7XG4gICAgICAgICAgICB0cmFjZUZvcm1hdCA9IF90cmFjZUZvcm1hdDtcbiAgICAgICAgICAgIGlmICh0cmFjZSA9PT0gVHJhY2UuT2ZmKSB7XG4gICAgICAgICAgICAgICAgdHJhY2VyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhY2VyID0gX3RyYWNlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfc2VuZE5vdGlmaWNhdGlvbiAmJiAhaXNDbG9zZWQoKSAmJiAhaXNEaXNwb3NlZCgpKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgY29ubmVjdGlvbi5zZW5kTm90aWZpY2F0aW9uKFNldFRyYWNlTm90aWZpY2F0aW9uLnR5cGUsIHsgdmFsdWU6IFRyYWNlLnRvU3RyaW5nKF92YWx1ZSkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uRXJyb3I6IGVycm9yRW1pdHRlci5ldmVudCxcbiAgICAgICAgb25DbG9zZTogY2xvc2VFbWl0dGVyLmV2ZW50LFxuICAgICAgICBvblVuaGFuZGxlZE5vdGlmaWNhdGlvbjogdW5oYW5kbGVkTm90aWZpY2F0aW9uRW1pdHRlci5ldmVudCxcbiAgICAgICAgb25EaXNwb3NlOiBkaXNwb3NlRW1pdHRlci5ldmVudCxcbiAgICAgICAgZW5kOiAoKSA9PiB7XG4gICAgICAgICAgICBtZXNzYWdlV3JpdGVyLmVuZCgpO1xuICAgICAgICB9LFxuICAgICAgICBkaXNwb3NlOiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNEaXNwb3NlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUgPSBDb25uZWN0aW9uU3RhdGUuRGlzcG9zZWQ7XG4gICAgICAgICAgICBkaXNwb3NlRW1pdHRlci5maXJlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBtZXNzYWdlc18xLlJlc3BvbnNlRXJyb3IobWVzc2FnZXNfMS5FcnJvckNvZGVzLlBlbmRpbmdSZXNwb25zZVJlamVjdGVkLCAnUGVuZGluZyByZXNwb25zZSByZWplY3RlZCBzaW5jZSBjb25uZWN0aW9uIGdvdCBkaXNwb3NlZCcpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9taXNlIG9mIHJlc3BvbnNlUHJvbWlzZXMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNwb25zZVByb21pc2VzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgcmVxdWVzdFRva2VucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGtub3duQ2FuY2VsZWRSZXF1ZXN0cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIG1lc3NhZ2VRdWV1ZSA9IG5ldyBsaW5rZWRNYXBfMS5MaW5rZWRNYXAoKTtcbiAgICAgICAgICAgIC8vIFRlc3QgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICBpZiAoSXMuZnVuYyhtZXNzYWdlV3JpdGVyLmRpc3Bvc2UpKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZVdyaXRlci5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoSXMuZnVuYyhtZXNzYWdlUmVhZGVyLmRpc3Bvc2UpKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZVJlYWRlci5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGxpc3RlbjogKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3dJZkNsb3NlZE9yRGlzcG9zZWQoKTtcbiAgICAgICAgICAgIHRocm93SWZMaXN0ZW5pbmcoKTtcbiAgICAgICAgICAgIHN0YXRlID0gQ29ubmVjdGlvblN0YXRlLkxpc3RlbmluZztcbiAgICAgICAgICAgIG1lc3NhZ2VSZWFkZXIubGlzdGVuKGNhbGxiYWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5zcGVjdDogKCkgPT4ge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICgwLCByYWxfMS5kZWZhdWx0KSgpLmNvbnNvbGUubG9nKCdpbnNwZWN0Jyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbm5lY3Rpb24ub25Ob3RpZmljYXRpb24oTG9nVHJhY2VOb3RpZmljYXRpb24udHlwZSwgKHBhcmFtcykgPT4ge1xuICAgICAgICBpZiAodHJhY2UgPT09IFRyYWNlLk9mZiB8fCAhdHJhY2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmVyYm9zZSA9IHRyYWNlID09PSBUcmFjZS5WZXJib3NlIHx8IHRyYWNlID09PSBUcmFjZS5Db21wYWN0O1xuICAgICAgICB0cmFjZXIubG9nKHBhcmFtcy5tZXNzYWdlLCB2ZXJib3NlID8gcGFyYW1zLnZlcmJvc2UgOiB1bmRlZmluZWQpO1xuICAgIH0pO1xuICAgIGNvbm5lY3Rpb24ub25Ob3RpZmljYXRpb24oUHJvZ3Jlc3NOb3RpZmljYXRpb24udHlwZSwgKHBhcmFtcykgPT4ge1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gcHJvZ3Jlc3NIYW5kbGVycy5nZXQocGFyYW1zLnRva2VuKTtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGhhbmRsZXIocGFyYW1zLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVuaGFuZGxlZFByb2dyZXNzRW1pdHRlci5maXJlKHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY29ubmVjdGlvbjtcbn1cbmV4cG9ydHMuY3JlYXRlTWVzc2FnZUNvbm5lY3Rpb24gPSBjcmVhdGVNZXNzYWdlQ29ubmVjdGlvbjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODg0NDpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkRpc3Bvc2FibGUgPSB2b2lkIDA7XG52YXIgRGlzcG9zYWJsZTtcbihmdW5jdGlvbiAoRGlzcG9zYWJsZSkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShmdW5jKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaXNwb3NlOiBmdW5jXG4gICAgICAgIH07XG4gICAgfVxuICAgIERpc3Bvc2FibGUuY3JlYXRlID0gY3JlYXRlO1xufSkoRGlzcG9zYWJsZSA9IGV4cG9ydHMuRGlzcG9zYWJsZSB8fCAoZXhwb3J0cy5EaXNwb3NhYmxlID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjQ3OTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5FbWl0dGVyID0gZXhwb3J0cy5FdmVudCA9IHZvaWQgMDtcbmNvbnN0IHJhbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MDkxKTtcbnZhciBFdmVudDtcbihmdW5jdGlvbiAoRXZlbnQpIHtcbiAgICBjb25zdCBfZGlzcG9zYWJsZSA9IHsgZGlzcG9zZSgpIHsgfSB9O1xuICAgIEV2ZW50Lk5vbmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfZGlzcG9zYWJsZTsgfTtcbn0pKEV2ZW50ID0gZXhwb3J0cy5FdmVudCB8fCAoZXhwb3J0cy5FdmVudCA9IHt9KSk7XG5jbGFzcyBDYWxsYmFja0xpc3Qge1xuICAgIGFkZChjYWxsYmFjaywgY29udGV4dCA9IG51bGwsIGJ1Y2tldCkge1xuICAgICAgICBpZiAoIXRoaXMuX2NhbGxiYWNrcykge1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzID0gW107XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgdGhpcy5fY29udGV4dHMucHVzaChjb250ZXh0KTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYnVja2V0KSkge1xuICAgICAgICAgICAgYnVja2V0LnB1c2goeyBkaXNwb3NlOiAoKSA9PiB0aGlzLnJlbW92ZShjYWxsYmFjaywgY29udGV4dCkgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlKGNhbGxiYWNrLCBjb250ZXh0ID0gbnVsbCkge1xuICAgICAgICBpZiAoIXRoaXMuX2NhbGxiYWNrcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmb3VuZENhbGxiYWNrV2l0aERpZmZlcmVudENvbnRleHQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMuX2NhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NhbGxiYWNrc1tpXSA9PT0gY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY29udGV4dHNbaV0gPT09IGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsbGJhY2sgJiBjb250ZXh0IG1hdGNoID0+IHJlbW92ZSBpdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWxsYmFja3Muc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kQ2FsbGJhY2tXaXRoRGlmZmVyZW50Q29udGV4dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmb3VuZENhbGxiYWNrV2l0aERpZmZlcmVudENvbnRleHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2hlbiBhZGRpbmcgYSBsaXN0ZW5lciB3aXRoIGEgY29udGV4dCwgeW91IHNob3VsZCByZW1vdmUgaXQgd2l0aCB0aGUgc2FtZSBjb250ZXh0Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW52b2tlKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSBbXSwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzLnNsaWNlKDApLCBjb250ZXh0cyA9IHRoaXMuX2NvbnRleHRzLnNsaWNlKDApO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldC5wdXNoKGNhbGxiYWNrc1tpXS5hcHBseShjb250ZXh0c1tpXSwgYXJncykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgICgwLCByYWxfMS5kZWZhdWx0KSgpLmNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLl9jYWxsYmFja3MgfHwgdGhpcy5fY2FsbGJhY2tzLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9jb250ZXh0cyA9IHVuZGVmaW5lZDtcbiAgICB9XG59XG5jbGFzcyBFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihfb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gX29wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvciB0aGUgcHVibGljIHRvIGFsbG93IHRvIHN1YnNjcmliZVxuICAgICAqIHRvIGV2ZW50cyBmcm9tIHRoaXMgRW1pdHRlclxuICAgICAqL1xuICAgIGdldCBldmVudCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9ldmVudCkge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnQgPSAobGlzdGVuZXIsIHRoaXNBcmdzLCBkaXNwb3NhYmxlcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IG5ldyBDYWxsYmFja0xpc3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMgJiYgdGhpcy5fb3B0aW9ucy5vbkZpcnN0TGlzdGVuZXJBZGQgJiYgdGhpcy5fY2FsbGJhY2tzLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zLm9uRmlyc3RMaXN0ZW5lckFkZCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzLmFkZChsaXN0ZW5lciwgdGhpc0FyZ3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcG9zZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkaXNwb3NhYmxlIGlzIGRpc3Bvc2VkIGFmdGVyIGVtaXR0ZXIgaXMgZGlzcG9zZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzLnJlbW92ZShsaXN0ZW5lciwgdGhpc0FyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmRpc3Bvc2UgPSBFbWl0dGVyLl9ub29wO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMgJiYgdGhpcy5fb3B0aW9ucy5vbkxhc3RMaXN0ZW5lclJlbW92ZSAmJiB0aGlzLl9jYWxsYmFja3MuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5vbkxhc3RMaXN0ZW5lclJlbW92ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGlzcG9zYWJsZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2FibGVzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUbyBiZSBrZXB0IHByaXZhdGUgdG8gZmlyZSBhbiBldmVudCB0b1xuICAgICAqIHN1YnNjcmliZXJzXG4gICAgICovXG4gICAgZmlyZShldmVudCkge1xuICAgICAgICBpZiAodGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MuaW52b2tlLmNhbGwodGhpcy5fY2FsbGJhY2tzLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NhbGxiYWNrcykge1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRW1pdHRlciA9IEVtaXR0ZXI7XG5FbWl0dGVyLl9ub29wID0gZnVuY3Rpb24gKCkgeyB9O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2NjE4OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLnN0cmluZ0FycmF5ID0gZXhwb3J0cy5hcnJheSA9IGV4cG9ydHMuZnVuYyA9IGV4cG9ydHMuZXJyb3IgPSBleHBvcnRzLm51bWJlciA9IGV4cG9ydHMuc3RyaW5nID0gZXhwb3J0cy5ib29sZWFuID0gdm9pZCAwO1xuZnVuY3Rpb24gYm9vbGVhbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2U7XG59XG5leHBvcnRzLmJvb2xlYW4gPSBib29sZWFuO1xuZnVuY3Rpb24gc3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmc7XG59XG5leHBvcnRzLnN0cmluZyA9IHN0cmluZztcbmZ1bmN0aW9uIG51bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyO1xufVxuZXhwb3J0cy5udW1iZXIgPSBudW1iZXI7XG5mdW5jdGlvbiBlcnJvcih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEVycm9yO1xufVxuZXhwb3J0cy5lcnJvciA9IGVycm9yO1xuZnVuY3Rpb24gZnVuYyh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmZ1bmMgPSBmdW5jO1xuZnVuY3Rpb24gYXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG5leHBvcnRzLmFycmF5ID0gYXJyYXk7XG5mdW5jdGlvbiBzdHJpbmdBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBhcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkoZWxlbSA9PiBzdHJpbmcoZWxlbSkpO1xufVxuZXhwb3J0cy5zdHJpbmdBcnJheSA9IHN0cmluZ0FycmF5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxMTA5OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG52YXIgX2E7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuTFJVQ2FjaGUgPSBleHBvcnRzLkxpbmtlZE1hcCA9IGV4cG9ydHMuVG91Y2ggPSB2b2lkIDA7XG52YXIgVG91Y2g7XG4oZnVuY3Rpb24gKFRvdWNoKSB7XG4gICAgVG91Y2guTm9uZSA9IDA7XG4gICAgVG91Y2guRmlyc3QgPSAxO1xuICAgIFRvdWNoLkFzT2xkID0gVG91Y2guRmlyc3Q7XG4gICAgVG91Y2guTGFzdCA9IDI7XG4gICAgVG91Y2guQXNOZXcgPSBUb3VjaC5MYXN0O1xufSkoVG91Y2ggPSBleHBvcnRzLlRvdWNoIHx8IChleHBvcnRzLlRvdWNoID0ge30pKTtcbmNsYXNzIExpbmtlZE1hcCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXNbX2FdID0gJ0xpbmtlZE1hcCc7XG4gICAgICAgIHRoaXMuX21hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5faGVhZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fdGFpbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gMDtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuX21hcC5jbGVhcigpO1xuICAgICAgICB0aGlzLl9oZWFkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl90YWlsID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9zaXplID0gMDtcbiAgICAgICAgdGhpcy5fc3RhdGUrKztcbiAgICB9XG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLl9oZWFkICYmICF0aGlzLl90YWlsO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gICAgfVxuICAgIGdldCBmaXJzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlYWQ/LnZhbHVlO1xuICAgIH1cbiAgICBnZXQgbGFzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhaWw/LnZhbHVlO1xuICAgIH1cbiAgICBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAuaGFzKGtleSk7XG4gICAgfVxuICAgIGdldChrZXksIHRvdWNoID0gVG91Y2guTm9uZSkge1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvdWNoICE9PSBUb3VjaC5Ob25lKSB7XG4gICAgICAgICAgICB0aGlzLnRvdWNoKGl0ZW0sIHRvdWNoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbS52YWx1ZTtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUsIHRvdWNoID0gVG91Y2guTm9uZSkge1xuICAgICAgICBsZXQgaXRlbSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIGl0ZW0udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh0b3VjaCAhPT0gVG91Y2guTm9uZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudG91Y2goaXRlbSwgdG91Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaXRlbSA9IHsga2V5LCB2YWx1ZSwgbmV4dDogdW5kZWZpbmVkLCBwcmV2aW91czogdW5kZWZpbmVkIH07XG4gICAgICAgICAgICBzd2l0Y2ggKHRvdWNoKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBUb3VjaC5Ob25lOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEl0ZW1MYXN0KGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFRvdWNoLkZpcnN0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEl0ZW1GaXJzdChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBUb3VjaC5MYXN0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEl0ZW1MYXN0KGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEl0ZW1MYXN0KGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX21hcC5zZXQoa2V5LCBpdGVtKTtcbiAgICAgICAgICAgIHRoaXMuX3NpemUrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICByZXR1cm4gISF0aGlzLnJlbW92ZShrZXkpO1xuICAgIH1cbiAgICByZW1vdmUoa2V5KSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tYXAuZGVsZXRlKGtleSk7XG4gICAgICAgIHRoaXMucmVtb3ZlSXRlbShpdGVtKTtcbiAgICAgICAgdGhpcy5fc2l6ZS0tO1xuICAgICAgICByZXR1cm4gaXRlbS52YWx1ZTtcbiAgICB9XG4gICAgc2hpZnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5faGVhZCAmJiAhdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2hlYWQgfHwgIXRoaXMuX3RhaWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsaXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIHRoaXMuX21hcC5kZWxldGUoaXRlbS5rZXkpO1xuICAgICAgICB0aGlzLnJlbW92ZUl0ZW0oaXRlbSk7XG4gICAgICAgIHRoaXMuX3NpemUtLTtcbiAgICAgICAgcmV0dXJuIGl0ZW0udmFsdWU7XG4gICAgfVxuICAgIGZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZykge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpc0FyZykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrZm4uYmluZCh0aGlzQXJnKShjdXJyZW50LnZhbHVlLCBjdXJyZW50LmtleSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja2ZuKGN1cnJlbnQudmFsdWUsIGN1cnJlbnQua2V5LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gc3RhdGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExpbmtlZE1hcCBnb3QgbW9kaWZpZWQgZHVyaW5nIGl0ZXJhdGlvbi5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAga2V5cygpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLl9oZWFkO1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHtcbiAgICAgICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgIT09IHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGlua2VkTWFwIGdvdCBtb2RpZmllZCBkdXJpbmcgaXRlcmF0aW9uLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7IHZhbHVlOiBjdXJyZW50LmtleSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICB9XG4gICAgdmFsdWVzKCkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0ge1xuICAgICAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl06ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMaW5rZWRNYXAgZ290IG1vZGlmaWVkIGR1cmluZyBpdGVyYXRpb24uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgdmFsdWU6IGN1cnJlbnQudmFsdWUsIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgfVxuICAgIGVudHJpZXMoKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5faGVhZDtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSB7XG4gICAgICAgICAgICBbU3ltYm9sLml0ZXJhdG9yXTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExpbmtlZE1hcCBnb3QgbW9kaWZpZWQgZHVyaW5nIGl0ZXJhdGlvbi5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geyB2YWx1ZTogW2N1cnJlbnQua2V5LCBjdXJyZW50LnZhbHVlXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICB9XG4gICAgWyhfYSA9IFN5bWJvbC50b1N0cmluZ1RhZywgU3ltYm9sLml0ZXJhdG9yKV0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVudHJpZXMoKTtcbiAgICB9XG4gICAgdHJpbU9sZChuZXdTaXplKSB7XG4gICAgICAgIGlmIChuZXdTaXplID49IHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdTaXplID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLl9oZWFkO1xuICAgICAgICBsZXQgY3VycmVudFNpemUgPSB0aGlzLnNpemU7XG4gICAgICAgIHdoaWxlIChjdXJyZW50ICYmIGN1cnJlbnRTaXplID4gbmV3U2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5fbWFwLmRlbGV0ZShjdXJyZW50LmtleSk7XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgY3VycmVudFNpemUtLTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9oZWFkID0gY3VycmVudDtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IGN1cnJlbnRTaXplO1xuICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgICAgY3VycmVudC5wcmV2aW91cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdGF0ZSsrO1xuICAgIH1cbiAgICBhZGRJdGVtRmlyc3QoaXRlbSkge1xuICAgICAgICAvLyBGaXJzdCB0aW1lIEluc2VydFxuICAgICAgICBpZiAoIXRoaXMuX2hlYWQgJiYgIXRoaXMuX3RhaWwpIHtcbiAgICAgICAgICAgIHRoaXMuX3RhaWwgPSBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLl9oZWFkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGlzdCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaXRlbS5uZXh0ID0gdGhpcy5faGVhZDtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQucHJldmlvdXMgPSBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2hlYWQgPSBpdGVtO1xuICAgICAgICB0aGlzLl9zdGF0ZSsrO1xuICAgIH1cbiAgICBhZGRJdGVtTGFzdChpdGVtKSB7XG4gICAgICAgIC8vIEZpcnN0IHRpbWUgSW5zZXJ0XG4gICAgICAgIGlmICghdGhpcy5faGVhZCAmJiAhdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgdGhpcy5faGVhZCA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuX3RhaWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsaXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpdGVtLnByZXZpb3VzID0gdGhpcy5fdGFpbDtcbiAgICAgICAgICAgIHRoaXMuX3RhaWwubmV4dCA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGFpbCA9IGl0ZW07XG4gICAgICAgIHRoaXMuX3N0YXRlKys7XG4gICAgfVxuICAgIHJlbW92ZUl0ZW0oaXRlbSkge1xuICAgICAgICBpZiAoaXRlbSA9PT0gdGhpcy5faGVhZCAmJiBpdGVtID09PSB0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5fdGFpbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpdGVtID09PSB0aGlzLl9oZWFkKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGNhbiBvbmx5IGhhcHBlbmVkIGlmIHNpemUgPT09IDEgd2hpY2ggaXMgaGFuZGxlXG4gICAgICAgICAgICAvLyBieSB0aGUgY2FzZSBhYm92ZS5cbiAgICAgICAgICAgIGlmICghaXRlbS5uZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW0ubmV4dC5wcmV2aW91cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQgPSBpdGVtLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXRlbSA9PT0gdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgLy8gVGhpcyBjYW4gb25seSBoYXBwZW5lZCBpZiBzaXplID09PSAxIHdoaWNoIGlzIGhhbmRsZVxuICAgICAgICAgICAgLy8gYnkgdGhlIGNhc2UgYWJvdmUuXG4gICAgICAgICAgICBpZiAoIWl0ZW0ucHJldmlvdXMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGlzdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbS5wcmV2aW91cy5uZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5fdGFpbCA9IGl0ZW0ucHJldmlvdXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gaXRlbS5uZXh0O1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXMgPSBpdGVtLnByZXZpb3VzO1xuICAgICAgICAgICAgaWYgKCFuZXh0IHx8ICFwcmV2aW91cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsaXN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0LnByZXZpb3VzID0gcHJldmlvdXM7XG4gICAgICAgICAgICBwcmV2aW91cy5uZXh0ID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBpdGVtLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGl0ZW0ucHJldmlvdXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3N0YXRlKys7XG4gICAgfVxuICAgIHRvdWNoKGl0ZW0sIHRvdWNoKSB7XG4gICAgICAgIGlmICghdGhpcy5faGVhZCB8fCAhdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHRvdWNoICE9PSBUb3VjaC5GaXJzdCAmJiB0b3VjaCAhPT0gVG91Y2guTGFzdCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG91Y2ggPT09IFRvdWNoLkZpcnN0KSB7XG4gICAgICAgICAgICBpZiAoaXRlbSA9PT0gdGhpcy5faGVhZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBpdGVtLm5leHQ7XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91cyA9IGl0ZW0ucHJldmlvdXM7XG4gICAgICAgICAgICAvLyBVbmxpbmsgdGhlIGl0ZW1cbiAgICAgICAgICAgIGlmIChpdGVtID09PSB0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICAgICAgLy8gcHJldmlvdXMgbXVzdCBiZSBkZWZpbmVkIHNpbmNlIGl0ZW0gd2FzIG5vdCBoZWFkIGJ1dCBpcyB0YWlsXG4gICAgICAgICAgICAgICAgLy8gU28gdGhlcmUgYXJlIG1vcmUgdGhhbiBvbiBpdGVtIGluIHRoZSBtYXBcbiAgICAgICAgICAgICAgICBwcmV2aW91cy5uZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RhaWwgPSBwcmV2aW91cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEJvdGggbmV4dCBhbmQgcHJldmlvdXMgYXJlIG5vdCB1bmRlZmluZWQgc2luY2UgaXRlbSB3YXMgbmVpdGhlciBoZWFkIG5vciB0YWlsLlxuICAgICAgICAgICAgICAgIG5leHQucHJldmlvdXMgPSBwcmV2aW91cztcbiAgICAgICAgICAgICAgICBwcmV2aW91cy5uZXh0ID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEluc2VydCB0aGUgbm9kZSBhdCBoZWFkXG4gICAgICAgICAgICBpdGVtLnByZXZpb3VzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaXRlbS5uZXh0ID0gdGhpcy5faGVhZDtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQucHJldmlvdXMgPSBpdGVtO1xuICAgICAgICAgICAgdGhpcy5faGVhZCA9IGl0ZW07XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRvdWNoID09PSBUb3VjaC5MYXN0KSB7XG4gICAgICAgICAgICBpZiAoaXRlbSA9PT0gdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBpdGVtLm5leHQ7XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91cyA9IGl0ZW0ucHJldmlvdXM7XG4gICAgICAgICAgICAvLyBVbmxpbmsgdGhlIGl0ZW0uXG4gICAgICAgICAgICBpZiAoaXRlbSA9PT0gdGhpcy5faGVhZCkge1xuICAgICAgICAgICAgICAgIC8vIG5leHQgbXVzdCBiZSBkZWZpbmVkIHNpbmNlIGl0ZW0gd2FzIG5vdCB0YWlsIGJ1dCBpcyBoZWFkXG4gICAgICAgICAgICAgICAgLy8gU28gdGhlcmUgYXJlIG1vcmUgdGhhbiBvbiBpdGVtIGluIHRoZSBtYXBcbiAgICAgICAgICAgICAgICBuZXh0LnByZXZpb3VzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMuX2hlYWQgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQm90aCBuZXh0IGFuZCBwcmV2aW91cyBhcmUgbm90IHVuZGVmaW5lZCBzaW5jZSBpdGVtIHdhcyBuZWl0aGVyIGhlYWQgbm9yIHRhaWwuXG4gICAgICAgICAgICAgICAgbmV4dC5wcmV2aW91cyA9IHByZXZpb3VzO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzLm5leHQgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbS5uZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaXRlbS5wcmV2aW91cyA9IHRoaXMuX3RhaWw7XG4gICAgICAgICAgICB0aGlzLl90YWlsLm5leHQgPSBpdGVtO1xuICAgICAgICAgICAgdGhpcy5fdGFpbCA9IGl0ZW07XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IFtdO1xuICAgICAgICB0aGlzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGZyb21KU09OKGRhdGEpIHtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuTGlua2VkTWFwID0gTGlua2VkTWFwO1xuY2xhc3MgTFJVQ2FjaGUgZXh0ZW5kcyBMaW5rZWRNYXAge1xuICAgIGNvbnN0cnVjdG9yKGxpbWl0LCByYXRpbyA9IDEpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fbGltaXQgPSBsaW1pdDtcbiAgICAgICAgdGhpcy5fcmF0aW8gPSBNYXRoLm1pbihNYXRoLm1heCgwLCByYXRpbyksIDEpO1xuICAgIH1cbiAgICBnZXQgbGltaXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saW1pdDtcbiAgICB9XG4gICAgc2V0IGxpbWl0KGxpbWl0KSB7XG4gICAgICAgIHRoaXMuX2xpbWl0ID0gbGltaXQ7XG4gICAgICAgIHRoaXMuY2hlY2tUcmltKCk7XG4gICAgfVxuICAgIGdldCByYXRpbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JhdGlvO1xuICAgIH1cbiAgICBzZXQgcmF0aW8ocmF0aW8pIHtcbiAgICAgICAgdGhpcy5fcmF0aW8gPSBNYXRoLm1pbihNYXRoLm1heCgwLCByYXRpbyksIDEpO1xuICAgICAgICB0aGlzLmNoZWNrVHJpbSgpO1xuICAgIH1cbiAgICBnZXQoa2V5LCB0b3VjaCA9IFRvdWNoLkFzTmV3KSB7XG4gICAgICAgIHJldHVybiBzdXBlci5nZXQoa2V5LCB0b3VjaCk7XG4gICAgfVxuICAgIHBlZWsoa2V5KSB7XG4gICAgICAgIHJldHVybiBzdXBlci5nZXQoa2V5LCBUb3VjaC5Ob25lKTtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgc3VwZXIuc2V0KGtleSwgdmFsdWUsIFRvdWNoLkxhc3QpO1xuICAgICAgICB0aGlzLmNoZWNrVHJpbSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY2hlY2tUcmltKCkge1xuICAgICAgICBpZiAodGhpcy5zaXplID4gdGhpcy5fbGltaXQpIHtcbiAgICAgICAgICAgIHRoaXMudHJpbU9sZChNYXRoLnJvdW5kKHRoaXMuX2xpbWl0ICogdGhpcy5fcmF0aW8pKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuTFJVQ2FjaGUgPSBMUlVDYWNoZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTgwNTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkFic3RyYWN0TWVzc2FnZUJ1ZmZlciA9IHZvaWQgMDtcbmNvbnN0IENSID0gMTM7XG5jb25zdCBMRiA9IDEwO1xuY29uc3QgQ1JMRiA9ICdcXHJcXG4nO1xuY2xhc3MgQWJzdHJhY3RNZXNzYWdlQnVmZmVyIHtcbiAgICBjb25zdHJ1Y3RvcihlbmNvZGluZyA9ICd1dGYtOCcpIHtcbiAgICAgICAgdGhpcy5fZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgICAgICAgdGhpcy5fY2h1bmtzID0gW107XG4gICAgICAgIHRoaXMuX3RvdGFsTGVuZ3RoID0gMDtcbiAgICB9XG4gICAgZ2V0IGVuY29kaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5jb2Rpbmc7XG4gICAgfVxuICAgIGFwcGVuZChjaHVuaykge1xuICAgICAgICBjb25zdCB0b0FwcGVuZCA9IHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycgPyB0aGlzLmZyb21TdHJpbmcoY2h1bmssIHRoaXMuX2VuY29kaW5nKSA6IGNodW5rO1xuICAgICAgICB0aGlzLl9jaHVua3MucHVzaCh0b0FwcGVuZCk7XG4gICAgICAgIHRoaXMuX3RvdGFsTGVuZ3RoICs9IHRvQXBwZW5kLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIHRyeVJlYWRIZWFkZXJzKGxvd2VyQ2FzZUtleXMgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5fY2h1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhdGUgPSAwO1xuICAgICAgICBsZXQgY2h1bmtJbmRleCA9IDA7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBsZXQgY2h1bmtCeXRlc1JlYWQgPSAwO1xuICAgICAgICByb3c6IHdoaWxlIChjaHVua0luZGV4IDwgdGhpcy5fY2h1bmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9jaHVua3NbY2h1bmtJbmRleF07XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgY29sdW1uOiB3aGlsZSAob2Zmc2V0IDwgY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjaHVua1tvZmZzZXRdO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBDUjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIExGOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHJvdztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaHVua0J5dGVzUmVhZCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgY2h1bmtJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZSAhPT0gNCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgYnVmZmVyIGNvbnRhaW5zIHRoZSB0d28gQ1JMRiBhdCB0aGUgZW5kLiBTbyB3ZSB3aWxsXG4gICAgICAgIC8vIGhhdmUgdHdvIGVtcHR5IGxpbmVzIGFmdGVyIHRoZSBzcGxpdCBhdCB0aGUgZW5kIGFzIHdlbGwuXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuX3JlYWQoY2h1bmtCeXRlc1JlYWQgKyBvZmZzZXQpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLnRvU3RyaW5nKGJ1ZmZlciwgJ2FzY2lpJykuc3BsaXQoQ1JMRik7XG4gICAgICAgIGlmIChoZWFkZXJzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXJzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyID0gaGVhZGVyc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gaGVhZGVyLmluZGV4T2YoJzonKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01lc3NhZ2UgaGVhZGVyIG11c3Qgc2VwYXJhdGUga2V5IGFuZCB2YWx1ZSB1c2luZyA6Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBoZWFkZXIuc3Vic3RyKDAsIGluZGV4KTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gaGVhZGVyLnN1YnN0cihpbmRleCArIDEpLnRyaW0oKTtcbiAgICAgICAgICAgIHJlc3VsdC5zZXQobG93ZXJDYXNlS2V5cyA/IGtleS50b0xvd2VyQ2FzZSgpIDoga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdHJ5UmVhZEJvZHkobGVuZ3RoKSB7XG4gICAgICAgIGlmICh0aGlzLl90b3RhbExlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZChsZW5ndGgpO1xuICAgIH1cbiAgICBnZXQgbnVtYmVyT2ZCeXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvdGFsTGVuZ3RoO1xuICAgIH1cbiAgICBfcmVhZChieXRlQ291bnQpIHtcbiAgICAgICAgaWYgKGJ5dGVDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1wdHlCdWZmZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnl0ZUNvdW50ID4gdGhpcy5fdG90YWxMZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlYWQgc28gbWFueSBieXRlcyFgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY2h1bmtzWzBdLmJ5dGVMZW5ndGggPT09IGJ5dGVDb3VudCkge1xuICAgICAgICAgICAgLy8gc3VwZXIgZmFzdCBwYXRoLCBwcmVjaXNlbHkgZmlyc3QgY2h1bmsgbXVzdCBiZSByZXR1cm5lZFxuICAgICAgICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9jaHVua3NbMF07XG4gICAgICAgICAgICB0aGlzLl9jaHVua3Muc2hpZnQoKTtcbiAgICAgICAgICAgIHRoaXMuX3RvdGFsTGVuZ3RoIC09IGJ5dGVDb3VudDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFzTmF0aXZlKGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY2h1bmtzWzBdLmJ5dGVMZW5ndGggPiBieXRlQ291bnQpIHtcbiAgICAgICAgICAgIC8vIGZhc3QgcGF0aCwgdGhlIHJlYWRpbmcgaXMgZW50aXJlbHkgd2l0aGluIHRoZSBmaXJzdCBjaHVua1xuICAgICAgICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9jaHVua3NbMF07XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmFzTmF0aXZlKGNodW5rLCBieXRlQ291bnQpO1xuICAgICAgICAgICAgdGhpcy5fY2h1bmtzWzBdID0gY2h1bmsuc2xpY2UoYnl0ZUNvdW50KTtcbiAgICAgICAgICAgIHRoaXMuX3RvdGFsTGVuZ3RoIC09IGJ5dGVDb3VudDtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5hbGxvY05hdGl2ZShieXRlQ291bnQpO1xuICAgICAgICBsZXQgcmVzdWx0T2Zmc2V0ID0gMDtcbiAgICAgICAgbGV0IGNodW5rSW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoYnl0ZUNvdW50ID4gMCkge1xuICAgICAgICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9jaHVua3NbY2h1bmtJbmRleF07XG4gICAgICAgICAgICBpZiAoY2h1bmsuYnl0ZUxlbmd0aCA+IGJ5dGVDb3VudCkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgY2h1bmsgd2lsbCBzdXJ2aXZlXG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmtQYXJ0ID0gY2h1bmsuc2xpY2UoMCwgYnl0ZUNvdW50KTtcbiAgICAgICAgICAgICAgICByZXN1bHQuc2V0KGNodW5rUGFydCwgcmVzdWx0T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICByZXN1bHRPZmZzZXQgKz0gYnl0ZUNvdW50O1xuICAgICAgICAgICAgICAgIHRoaXMuX2NodW5rc1tjaHVua0luZGV4XSA9IGNodW5rLnNsaWNlKGJ5dGVDb3VudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG90YWxMZW5ndGggLT0gYnl0ZUNvdW50O1xuICAgICAgICAgICAgICAgIGJ5dGVDb3VudCAtPSBieXRlQ291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNodW5rIHdpbGwgYmUgZW50aXJlbHkgcmVhZFxuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoY2h1bmssIHJlc3VsdE9mZnNldCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0T2Zmc2V0ICs9IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2h1bmtzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdG90YWxMZW5ndGggLT0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICBieXRlQ291bnQgLT0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlQnVmZmVyID0gQWJzdHJhY3RNZXNzYWdlQnVmZmVyO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2NTY6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuUmVhZGFibGVTdHJlYW1NZXNzYWdlUmVhZGVyID0gZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VSZWFkZXIgPSBleHBvcnRzLk1lc3NhZ2VSZWFkZXIgPSB2b2lkIDA7XG5jb25zdCByYWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTA5MSk7XG5jb25zdCBJcyA9IF9fd2VicGFja19yZXF1aXJlX18oNjYxOCk7XG5jb25zdCBldmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjQ3OSk7XG5jb25zdCBzZW1hcGhvcmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDE4KTtcbnZhciBNZXNzYWdlUmVhZGVyO1xuKGZ1bmN0aW9uIChNZXNzYWdlUmVhZGVyKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIElzLmZ1bmMoY2FuZGlkYXRlLmxpc3RlbikgJiYgSXMuZnVuYyhjYW5kaWRhdGUuZGlzcG9zZSkgJiZcbiAgICAgICAgICAgIElzLmZ1bmMoY2FuZGlkYXRlLm9uRXJyb3IpICYmIElzLmZ1bmMoY2FuZGlkYXRlLm9uQ2xvc2UpICYmIElzLmZ1bmMoY2FuZGlkYXRlLm9uUGFydGlhbE1lc3NhZ2UpO1xuICAgIH1cbiAgICBNZXNzYWdlUmVhZGVyLmlzID0gaXM7XG59KShNZXNzYWdlUmVhZGVyID0gZXhwb3J0cy5NZXNzYWdlUmVhZGVyIHx8IChleHBvcnRzLk1lc3NhZ2VSZWFkZXIgPSB7fSkpO1xuY2xhc3MgQWJzdHJhY3RNZXNzYWdlUmVhZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5lcnJvckVtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xuICAgICAgICB0aGlzLmNsb3NlRW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgICAgIHRoaXMucGFydGlhbE1lc3NhZ2VFbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5lcnJvckVtaXR0ZXIuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmNsb3NlRW1pdHRlci5kaXNwb3NlKCk7XG4gICAgfVxuICAgIGdldCBvbkVycm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lcnJvckVtaXR0ZXIuZXZlbnQ7XG4gICAgfVxuICAgIGZpcmVFcnJvcihlcnJvcikge1xuICAgICAgICB0aGlzLmVycm9yRW1pdHRlci5maXJlKHRoaXMuYXNFcnJvcihlcnJvcikpO1xuICAgIH1cbiAgICBnZXQgb25DbG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2VFbWl0dGVyLmV2ZW50O1xuICAgIH1cbiAgICBmaXJlQ2xvc2UoKSB7XG4gICAgICAgIHRoaXMuY2xvc2VFbWl0dGVyLmZpcmUodW5kZWZpbmVkKTtcbiAgICB9XG4gICAgZ2V0IG9uUGFydGlhbE1lc3NhZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnRpYWxNZXNzYWdlRW1pdHRlci5ldmVudDtcbiAgICB9XG4gICAgZmlyZVBhcnRpYWxNZXNzYWdlKGluZm8pIHtcbiAgICAgICAgdGhpcy5wYXJ0aWFsTWVzc2FnZUVtaXR0ZXIuZmlyZShpbmZvKTtcbiAgICB9XG4gICAgYXNFcnJvcihlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgUmVhZGVyIHJlY2VpdmVkIGVycm9yLiBSZWFzb246ICR7SXMuc3RyaW5nKGVycm9yLm1lc3NhZ2UpID8gZXJyb3IubWVzc2FnZSA6ICd1bmtub3duJ31gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlUmVhZGVyID0gQWJzdHJhY3RNZXNzYWdlUmVhZGVyO1xudmFyIFJlc29sdmVkTWVzc2FnZVJlYWRlck9wdGlvbnM7XG4oZnVuY3Rpb24gKFJlc29sdmVkTWVzc2FnZVJlYWRlck9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiBmcm9tT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGxldCBjaGFyc2V0O1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBsZXQgY29udGVudERlY29kZXI7XG4gICAgICAgIGNvbnN0IGNvbnRlbnREZWNvZGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgbGV0IGNvbnRlbnRUeXBlRGVjb2RlcjtcbiAgICAgICAgY29uc3QgY29udGVudFR5cGVEZWNvZGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNoYXJzZXQgPSBvcHRpb25zID8/ICd1dGYtOCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaGFyc2V0ID0gb3B0aW9ucy5jaGFyc2V0ID8/ICd1dGYtOCc7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jb250ZW50RGVjb2RlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGVudERlY29kZXIgPSBvcHRpb25zLmNvbnRlbnREZWNvZGVyO1xuICAgICAgICAgICAgICAgIGNvbnRlbnREZWNvZGVycy5zZXQoY29udGVudERlY29kZXIubmFtZSwgY29udGVudERlY29kZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY29udGVudERlY29kZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRlY29kZXIgb2Ygb3B0aW9ucy5jb250ZW50RGVjb2RlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudERlY29kZXJzLnNldChkZWNvZGVyLm5hbWUsIGRlY29kZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNvbnRlbnRUeXBlRGVjb2RlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGVudFR5cGVEZWNvZGVyID0gb3B0aW9ucy5jb250ZW50VHlwZURlY29kZXI7XG4gICAgICAgICAgICAgICAgY29udGVudFR5cGVEZWNvZGVycy5zZXQoY29udGVudFR5cGVEZWNvZGVyLm5hbWUsIGNvbnRlbnRUeXBlRGVjb2Rlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jb250ZW50VHlwZURlY29kZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRlY29kZXIgb2Ygb3B0aW9ucy5jb250ZW50VHlwZURlY29kZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlRGVjb2RlcnMuc2V0KGRlY29kZXIubmFtZSwgZGVjb2Rlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZW50VHlwZURlY29kZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGVudFR5cGVEZWNvZGVyID0gKDAsIHJhbF8xLmRlZmF1bHQpKCkuYXBwbGljYXRpb25Kc29uLmRlY29kZXI7XG4gICAgICAgICAgICBjb250ZW50VHlwZURlY29kZXJzLnNldChjb250ZW50VHlwZURlY29kZXIubmFtZSwgY29udGVudFR5cGVEZWNvZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBjaGFyc2V0LCBjb250ZW50RGVjb2RlciwgY29udGVudERlY29kZXJzLCBjb250ZW50VHlwZURlY29kZXIsIGNvbnRlbnRUeXBlRGVjb2RlcnMgfTtcbiAgICB9XG4gICAgUmVzb2x2ZWRNZXNzYWdlUmVhZGVyT3B0aW9ucy5mcm9tT3B0aW9ucyA9IGZyb21PcHRpb25zO1xufSkoUmVzb2x2ZWRNZXNzYWdlUmVhZGVyT3B0aW9ucyB8fCAoUmVzb2x2ZWRNZXNzYWdlUmVhZGVyT3B0aW9ucyA9IHt9KSk7XG5jbGFzcyBSZWFkYWJsZVN0cmVhbU1lc3NhZ2VSZWFkZXIgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VSZWFkZXIge1xuICAgIGNvbnN0cnVjdG9yKHJlYWRhYmxlLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucmVhZGFibGUgPSByZWFkYWJsZTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gUmVzb2x2ZWRNZXNzYWdlUmVhZGVyT3B0aW9ucy5mcm9tT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSAoMCwgcmFsXzEuZGVmYXVsdCkoKS5tZXNzYWdlQnVmZmVyLmNyZWF0ZSh0aGlzLm9wdGlvbnMuY2hhcnNldCk7XG4gICAgICAgIHRoaXMuX3BhcnRpYWxNZXNzYWdlVGltZW91dCA9IDEwMDAwO1xuICAgICAgICB0aGlzLm5leHRNZXNzYWdlTGVuZ3RoID0gLTE7XG4gICAgICAgIHRoaXMubWVzc2FnZVRva2VuID0gMDtcbiAgICAgICAgdGhpcy5yZWFkU2VtYXBob3JlID0gbmV3IHNlbWFwaG9yZV8xLlNlbWFwaG9yZSgxKTtcbiAgICB9XG4gICAgc2V0IHBhcnRpYWxNZXNzYWdlVGltZW91dCh0aW1lb3V0KSB7XG4gICAgICAgIHRoaXMuX3BhcnRpYWxNZXNzYWdlVGltZW91dCA9IHRpbWVvdXQ7XG4gICAgfVxuICAgIGdldCBwYXJ0aWFsTWVzc2FnZVRpbWVvdXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJ0aWFsTWVzc2FnZVRpbWVvdXQ7XG4gICAgfVxuICAgIGxpc3RlbihjYWxsYmFjaykge1xuICAgICAgICB0aGlzLm5leHRNZXNzYWdlTGVuZ3RoID0gLTE7XG4gICAgICAgIHRoaXMubWVzc2FnZVRva2VuID0gMDtcbiAgICAgICAgdGhpcy5wYXJ0aWFsTWVzc2FnZVRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucmVhZGFibGUub25EYXRhKChkYXRhKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uRGF0YShkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVhZGFibGUub25FcnJvcigoZXJyb3IpID0+IHRoaXMuZmlyZUVycm9yKGVycm9yKSk7XG4gICAgICAgIHRoaXMucmVhZGFibGUub25DbG9zZSgoKSA9PiB0aGlzLmZpcmVDbG9zZSgpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgb25EYXRhKGRhdGEpIHtcbiAgICAgICAgdGhpcy5idWZmZXIuYXBwZW5kKGRhdGEpO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubmV4dE1lc3NhZ2VMZW5ndGggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IHRoaXMuYnVmZmVyLnRyeVJlYWRIZWFkZXJzKHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICghaGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBoZWFkZXJzLmdldCgnY29udGVudC1sZW5ndGgnKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRlbnRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJlRXJyb3IobmV3IEVycm9yKCdIZWFkZXIgbXVzdCBwcm92aWRlIGEgQ29udGVudC1MZW5ndGggcHJvcGVydHkuJykpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KGNvbnRlbnRMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmIChpc05hTihsZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZUVycm9yKG5ldyBFcnJvcignQ29udGVudC1MZW5ndGggdmFsdWUgbXVzdCBiZSBhIG51bWJlci4nKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0TWVzc2FnZUxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSB0aGlzLmJ1ZmZlci50cnlSZWFkQm9keSh0aGlzLm5leHRNZXNzYWdlTGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChib2R5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvKiogV2UgaGF2ZW4ndCByZWNlaXZlZCB0aGUgZnVsbCBtZXNzYWdlIHlldC4gKi9cbiAgICAgICAgICAgICAgICB0aGlzLnNldFBhcnRpYWxNZXNzYWdlVGltZXIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNsZWFyUGFydGlhbE1lc3NhZ2VUaW1lcigpO1xuICAgICAgICAgICAgdGhpcy5uZXh0TWVzc2FnZUxlbmd0aCA9IC0xO1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgd2UgY29udmVydCBvbmUgcmVjZWl2ZWQgbWVzc2FnZSBhZnRlciB0aGVcbiAgICAgICAgICAgIC8vIG90aGVyLiBPdGhlcndpc2UgaXQgY291bGQgaGFwcGVuIHRoYXQgYSBkZWNvZGluZyBvZiBhIHNlY29uZFxuICAgICAgICAgICAgLy8gc21hbGxlciBtZXNzYWdlIGZpbmlzaGVkIGJlZm9yZSB0aGUgZGVjb2Rpbmcgb2YgYSBmaXJzdCBsYXJnZXJcbiAgICAgICAgICAgIC8vIG1lc3NhZ2UgYW5kIHRoZW4gd2Ugd291bGQgZGVsaXZlciB0aGUgc2Vjb25kIG1lc3NhZ2UgZmlyc3QuXG4gICAgICAgICAgICB0aGlzLnJlYWRTZW1hcGhvcmUubG9jayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSB0aGlzLm9wdGlvbnMuY29udGVudERlY29kZXIgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA/IGF3YWl0IHRoaXMub3B0aW9ucy5jb250ZW50RGVjb2Rlci5kZWNvZGUoYm9keSlcbiAgICAgICAgICAgICAgICAgICAgOiBib2R5O1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBhd2FpdCB0aGlzLm9wdGlvbnMuY29udGVudFR5cGVEZWNvZGVyLmRlY29kZShieXRlcywgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYXJQYXJ0aWFsTWVzc2FnZVRpbWVyKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJ0aWFsTWVzc2FnZVRpbWVyKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnRpYWxNZXNzYWdlVGltZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5wYXJ0aWFsTWVzc2FnZVRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFBhcnRpYWxNZXNzYWdlVGltZXIoKSB7XG4gICAgICAgIHRoaXMuY2xlYXJQYXJ0aWFsTWVzc2FnZVRpbWVyKCk7XG4gICAgICAgIGlmICh0aGlzLl9wYXJ0aWFsTWVzc2FnZVRpbWVvdXQgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFydGlhbE1lc3NhZ2VUaW1lciA9ICgwLCByYWxfMS5kZWZhdWx0KSgpLnRpbWVyLnNldFRpbWVvdXQoKHRva2VuLCB0aW1lb3V0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhcnRpYWxNZXNzYWdlVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodG9rZW4gPT09IHRoaXMubWVzc2FnZVRva2VuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlUGFydGlhbE1lc3NhZ2UoeyBtZXNzYWdlVG9rZW46IHRva2VuLCB3YWl0aW5nVGltZTogdGltZW91dCB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFBhcnRpYWxNZXNzYWdlVGltZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcy5fcGFydGlhbE1lc3NhZ2VUaW1lb3V0LCB0aGlzLm1lc3NhZ2VUb2tlbiwgdGhpcy5fcGFydGlhbE1lc3NhZ2VUaW1lb3V0KTtcbiAgICB9XG59XG5leHBvcnRzLlJlYWRhYmxlU3RyZWFtTWVzc2FnZVJlYWRlciA9IFJlYWRhYmxlU3RyZWFtTWVzc2FnZVJlYWRlcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTAzNjpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5Xcml0ZWFibGVTdHJlYW1NZXNzYWdlV3JpdGVyID0gZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VXcml0ZXIgPSBleHBvcnRzLk1lc3NhZ2VXcml0ZXIgPSB2b2lkIDA7XG5jb25zdCByYWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTA5MSk7XG5jb25zdCBJcyA9IF9fd2VicGFja19yZXF1aXJlX18oNjYxOCk7XG5jb25zdCBzZW1hcGhvcmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDE4KTtcbmNvbnN0IGV2ZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNDc5KTtcbmNvbnN0IENvbnRlbnRMZW5ndGggPSAnQ29udGVudC1MZW5ndGg6ICc7XG5jb25zdCBDUkxGID0gJ1xcclxcbic7XG52YXIgTWVzc2FnZVdyaXRlcjtcbihmdW5jdGlvbiAoTWVzc2FnZVdyaXRlcikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5kaXNwb3NlKSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5vbkNsb3NlKSAmJlxuICAgICAgICAgICAgSXMuZnVuYyhjYW5kaWRhdGUub25FcnJvcikgJiYgSXMuZnVuYyhjYW5kaWRhdGUud3JpdGUpO1xuICAgIH1cbiAgICBNZXNzYWdlV3JpdGVyLmlzID0gaXM7XG59KShNZXNzYWdlV3JpdGVyID0gZXhwb3J0cy5NZXNzYWdlV3JpdGVyIHx8IChleHBvcnRzLk1lc3NhZ2VXcml0ZXIgPSB7fSkpO1xuY2xhc3MgQWJzdHJhY3RNZXNzYWdlV3JpdGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5lcnJvckVtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRW1pdHRlcigpO1xuICAgICAgICB0aGlzLmNsb3NlRW1pdHRlciA9IG5ldyBldmVudHNfMS5FbWl0dGVyKCk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuZXJyb3JFbWl0dGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5jbG9zZUVtaXR0ZXIuZGlzcG9zZSgpO1xuICAgIH1cbiAgICBnZXQgb25FcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JFbWl0dGVyLmV2ZW50O1xuICAgIH1cbiAgICBmaXJlRXJyb3IoZXJyb3IsIG1lc3NhZ2UsIGNvdW50KSB7XG4gICAgICAgIHRoaXMuZXJyb3JFbWl0dGVyLmZpcmUoW3RoaXMuYXNFcnJvcihlcnJvciksIG1lc3NhZ2UsIGNvdW50XSk7XG4gICAgfVxuICAgIGdldCBvbkNsb3NlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9zZUVtaXR0ZXIuZXZlbnQ7XG4gICAgfVxuICAgIGZpcmVDbG9zZSgpIHtcbiAgICAgICAgdGhpcy5jbG9zZUVtaXR0ZXIuZmlyZSh1bmRlZmluZWQpO1xuICAgIH1cbiAgICBhc0Vycm9yKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKGBXcml0ZXIgcmVjZWl2ZWQgZXJyb3IuIFJlYXNvbjogJHtJcy5zdHJpbmcoZXJyb3IubWVzc2FnZSkgPyBlcnJvci5tZXNzYWdlIDogJ3Vua25vd24nfWApO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VXcml0ZXIgPSBBYnN0cmFjdE1lc3NhZ2VXcml0ZXI7XG52YXIgUmVzb2x2ZWRNZXNzYWdlV3JpdGVyT3B0aW9ucztcbihmdW5jdGlvbiAoUmVzb2x2ZWRNZXNzYWdlV3JpdGVyT3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIGZyb21PcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNoYXJzZXQ6IG9wdGlvbnMgPz8gJ3V0Zi04JywgY29udGVudFR5cGVFbmNvZGVyOiAoMCwgcmFsXzEuZGVmYXVsdCkoKS5hcHBsaWNhdGlvbkpzb24uZW5jb2RlciB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsgY2hhcnNldDogb3B0aW9ucy5jaGFyc2V0ID8/ICd1dGYtOCcsIGNvbnRlbnRFbmNvZGVyOiBvcHRpb25zLmNvbnRlbnRFbmNvZGVyLCBjb250ZW50VHlwZUVuY29kZXI6IG9wdGlvbnMuY29udGVudFR5cGVFbmNvZGVyID8/ICgwLCByYWxfMS5kZWZhdWx0KSgpLmFwcGxpY2F0aW9uSnNvbi5lbmNvZGVyIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgUmVzb2x2ZWRNZXNzYWdlV3JpdGVyT3B0aW9ucy5mcm9tT3B0aW9ucyA9IGZyb21PcHRpb25zO1xufSkoUmVzb2x2ZWRNZXNzYWdlV3JpdGVyT3B0aW9ucyB8fCAoUmVzb2x2ZWRNZXNzYWdlV3JpdGVyT3B0aW9ucyA9IHt9KSk7XG5jbGFzcyBXcml0ZWFibGVTdHJlYW1NZXNzYWdlV3JpdGVyIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlV3JpdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih3cml0YWJsZSwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLndyaXRhYmxlID0gd3JpdGFibGU7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IFJlc29sdmVkTWVzc2FnZVdyaXRlck9wdGlvbnMuZnJvbU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZXJyb3JDb3VudCA9IDA7XG4gICAgICAgIHRoaXMud3JpdGVTZW1hcGhvcmUgPSBuZXcgc2VtYXBob3JlXzEuU2VtYXBob3JlKDEpO1xuICAgICAgICB0aGlzLndyaXRhYmxlLm9uRXJyb3IoKGVycm9yKSA9PiB0aGlzLmZpcmVFcnJvcihlcnJvcikpO1xuICAgICAgICB0aGlzLndyaXRhYmxlLm9uQ2xvc2UoKCkgPT4gdGhpcy5maXJlQ2xvc2UoKSk7XG4gICAgfVxuICAgIGFzeW5jIHdyaXRlKG1zZykge1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZVNlbWFwaG9yZS5sb2NrKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB0aGlzLm9wdGlvbnMuY29udGVudFR5cGVFbmNvZGVyLmVuY29kZShtc2csIHRoaXMub3B0aW9ucykudGhlbigoYnVmZmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb250ZW50RW5jb2RlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuY29udGVudEVuY29kZXIuZW5jb2RlKGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQudGhlbigoYnVmZmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IFtdO1xuICAgICAgICAgICAgICAgIGhlYWRlcnMucHVzaChDb250ZW50TGVuZ3RoLCBidWZmZXIuYnl0ZUxlbmd0aC50b1N0cmluZygpLCBDUkxGKTtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLnB1c2goQ1JMRik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9Xcml0ZShtc2csIGhlYWRlcnMsIGJ1ZmZlcik7XG4gICAgICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGRvV3JpdGUobXNnLCBoZWFkZXJzLCBkYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLndyaXRhYmxlLndyaXRlKGhlYWRlcnMuam9pbignJyksICdhc2NpaScpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud3JpdGFibGUud3JpdGUoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUVycm9yKGVycm9yLCBtc2cpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVFcnJvcihlcnJvciwgbXNnKSB7XG4gICAgICAgIHRoaXMuZXJyb3JDb3VudCsrO1xuICAgICAgICB0aGlzLmZpcmVFcnJvcihlcnJvciwgbXNnLCB0aGlzLmVycm9yQ291bnQpO1xuICAgIH1cbiAgICBlbmQoKSB7XG4gICAgICAgIHRoaXMud3JpdGFibGUuZW5kKCk7XG4gICAgfVxufVxuZXhwb3J0cy5Xcml0ZWFibGVTdHJlYW1NZXNzYWdlV3JpdGVyID0gV3JpdGVhYmxlU3RyZWFtTWVzc2FnZVdyaXRlcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzE2Mjpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5NZXNzYWdlID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlOSA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTggPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU3ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNiA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTUgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGU0ID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMyA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTIgPSBleHBvcnRzLk5vdGlmaWNhdGlvblR5cGUxID0gZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMCA9IGV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZSA9IGV4cG9ydHMuUmVxdWVzdFR5cGU5ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTggPSBleHBvcnRzLlJlcXVlc3RUeXBlNyA9IGV4cG9ydHMuUmVxdWVzdFR5cGU2ID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTUgPSBleHBvcnRzLlJlcXVlc3RUeXBlNCA9IGV4cG9ydHMuUmVxdWVzdFR5cGUzID0gZXhwb3J0cy5SZXF1ZXN0VHlwZTIgPSBleHBvcnRzLlJlcXVlc3RUeXBlMSA9IGV4cG9ydHMuUmVxdWVzdFR5cGUgPSBleHBvcnRzLlJlcXVlc3RUeXBlMCA9IGV4cG9ydHMuQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlID0gZXhwb3J0cy5QYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gZXhwb3J0cy5SZXNwb25zZUVycm9yID0gZXhwb3J0cy5FcnJvckNvZGVzID0gdm9pZCAwO1xuY29uc3QgaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2MTgpO1xuLyoqXG4gKiBQcmVkZWZpbmVkIGVycm9yIGNvZGVzLlxuICovXG52YXIgRXJyb3JDb2RlcztcbihmdW5jdGlvbiAoRXJyb3JDb2Rlcykge1xuICAgIC8vIERlZmluZWQgYnkgSlNPTiBSUENcbiAgICBFcnJvckNvZGVzLlBhcnNlRXJyb3IgPSAtMzI3MDA7XG4gICAgRXJyb3JDb2Rlcy5JbnZhbGlkUmVxdWVzdCA9IC0zMjYwMDtcbiAgICBFcnJvckNvZGVzLk1ldGhvZE5vdEZvdW5kID0gLTMyNjAxO1xuICAgIEVycm9yQ29kZXMuSW52YWxpZFBhcmFtcyA9IC0zMjYwMjtcbiAgICBFcnJvckNvZGVzLkludGVybmFsRXJyb3IgPSAtMzI2MDM7XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgc3RhcnQgcmFuZ2Ugb2YgSlNPTiBSUEMgcmVzZXJ2ZWQgZXJyb3IgY29kZXMuXG4gICAgICogSXQgZG9lc24ndCBkZW5vdGUgYSByZWFsIGVycm9yIGNvZGUuIE5vIGFwcGxpY2F0aW9uIGVycm9yIGNvZGVzIHNob3VsZFxuICAgICAqIGJlIGRlZmluZWQgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCByYW5nZS4gRm9yIGJhY2t3YXJkc1xuICAgICAqIGNvbXBhdGliaWxpdHkgdGhlIGBTZXJ2ZXJOb3RJbml0aWFsaXplZGAgYW5kIHRoZSBgVW5rbm93bkVycm9yQ29kZWBcbiAgICAgKiBhcmUgbGVmdCBpbiB0aGUgcmFuZ2UuXG4gICAgICpcbiAgICAgKiBAc2luY2UgMy4xNi4wXG4gICAgKi9cbiAgICBFcnJvckNvZGVzLmpzb25ycGNSZXNlcnZlZEVycm9yUmFuZ2VTdGFydCA9IC0zMjA5OTtcbiAgICAvKiogQGRlcHJlY2F0ZWQgdXNlICBqc29ucnBjUmVzZXJ2ZWRFcnJvclJhbmdlU3RhcnQgKi9cbiAgICBFcnJvckNvZGVzLnNlcnZlckVycm9yU3RhcnQgPSAtMzIwOTk7XG4gICAgLyoqXG4gICAgICogQW4gZXJyb3Igb2NjdXJyZWQgd2hlbiB3cml0ZSBhIG1lc3NhZ2UgdG8gdGhlIHRyYW5zcG9ydCBsYXllci5cbiAgICAgKi9cbiAgICBFcnJvckNvZGVzLk1lc3NhZ2VXcml0ZUVycm9yID0gLTMyMDk5O1xuICAgIC8qKlxuICAgICAqIEFuIGVycm9yIG9jY3VycmVkIHdoZW4gcmVhZGluZyBhIG1lc3NhZ2UgZnJvbSB0aGUgdHJhbnNwb3J0IGxheWVyLlxuICAgICAqL1xuICAgIEVycm9yQ29kZXMuTWVzc2FnZVJlYWRFcnJvciA9IC0zMjA5ODtcbiAgICAvKipcbiAgICAgKiBUaGUgY29ubmVjdGlvbiBnb3QgZGlzcG9zZWQgb3IgbG9zdCBhbmQgYWxsIHBlbmRpbmcgcmVzcG9uc2VzIGdvdFxuICAgICAqIHJlamVjdGVkLlxuICAgICAqL1xuICAgIEVycm9yQ29kZXMuUGVuZGluZ1Jlc3BvbnNlUmVqZWN0ZWQgPSAtMzIwOTc7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbm5lY3Rpb24gaXMgaW5hY3RpdmUgYW5kIGEgdXNlIG9mIGl0IGZhaWxlZC5cbiAgICAgKi9cbiAgICBFcnJvckNvZGVzLkNvbm5lY3Rpb25JbmFjdGl2ZSA9IC0zMjA5NjtcbiAgICAvKipcbiAgICAgKiBFcnJvciBjb2RlIGluZGljYXRpbmcgdGhhdCBhIHNlcnZlciByZWNlaXZlZCBhIG5vdGlmaWNhdGlvbiBvclxuICAgICAqIHJlcXVlc3QgYmVmb3JlIHRoZSBzZXJ2ZXIgaGFzIHJlY2VpdmVkIHRoZSBgaW5pdGlhbGl6ZWAgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBFcnJvckNvZGVzLlNlcnZlck5vdEluaXRpYWxpemVkID0gLTMyMDAyO1xuICAgIEVycm9yQ29kZXMuVW5rbm93bkVycm9yQ29kZSA9IC0zMjAwMTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBlbmQgcmFuZ2Ugb2YgSlNPTiBSUEMgcmVzZXJ2ZWQgZXJyb3IgY29kZXMuXG4gICAgICogSXQgZG9lc24ndCBkZW5vdGUgYSByZWFsIGVycm9yIGNvZGUuXG4gICAgICpcbiAgICAgKiBAc2luY2UgMy4xNi4wXG4gICAgKi9cbiAgICBFcnJvckNvZGVzLmpzb25ycGNSZXNlcnZlZEVycm9yUmFuZ2VFbmQgPSAtMzIwMDA7XG4gICAgLyoqIEBkZXByZWNhdGVkIHVzZSAganNvbnJwY1Jlc2VydmVkRXJyb3JSYW5nZUVuZCAqL1xuICAgIEVycm9yQ29kZXMuc2VydmVyRXJyb3JFbmQgPSAtMzIwMDA7XG59KShFcnJvckNvZGVzID0gZXhwb3J0cy5FcnJvckNvZGVzIHx8IChleHBvcnRzLkVycm9yQ29kZXMgPSB7fSkpO1xuLyoqXG4gKiBBbiBlcnJvciBvYmplY3QgcmV0dXJuIGluIGEgcmVzcG9uc2UgaW4gY2FzZSBhIHJlcXVlc3RcbiAqIGhhcyBmYWlsZWQuXG4gKi9cbmNsYXNzIFJlc3BvbnNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY29kZSwgbWVzc2FnZSwgZGF0YSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jb2RlID0gaXMubnVtYmVyKGNvZGUpID8gY29kZSA6IEVycm9yQ29kZXMuVW5rbm93bkVycm9yQ29kZTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFJlc3BvbnNlRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG4gICAgdG9Kc29uKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICBjb2RlOiB0aGlzLmNvZGUsXG4gICAgICAgICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2VcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQuZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmV4cG9ydHMuUmVzcG9uc2VFcnJvciA9IFJlc3BvbnNlRXJyb3I7XG5jbGFzcyBQYXJhbWV0ZXJTdHJ1Y3R1cmVzIHtcbiAgICBjb25zdHJ1Y3RvcihraW5kKSB7XG4gICAgICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgfVxuICAgIHN0YXRpYyBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IFBhcmFtZXRlclN0cnVjdHVyZXMuYXV0byB8fCB2YWx1ZSA9PT0gUGFyYW1ldGVyU3RydWN0dXJlcy5ieU5hbWUgfHwgdmFsdWUgPT09IFBhcmFtZXRlclN0cnVjdHVyZXMuYnlQb3NpdGlvbjtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtpbmQ7XG4gICAgfVxufVxuZXhwb3J0cy5QYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gUGFyYW1ldGVyU3RydWN0dXJlcztcbi8qKlxuICogVGhlIHBhcmFtZXRlciBzdHJ1Y3R1cmUgaXMgYXV0b21hdGljYWxseSBpbmZlcnJlZCBvbiB0aGUgbnVtYmVyIG9mIHBhcmFtZXRlcnNcbiAqIGFuZCB0aGUgcGFyYW1ldGVyIHR5cGUgaW4gY2FzZSBvZiBhIHNpbmdsZSBwYXJhbS5cbiAqL1xuUGFyYW1ldGVyU3RydWN0dXJlcy5hdXRvID0gbmV3IFBhcmFtZXRlclN0cnVjdHVyZXMoJ2F1dG8nKTtcbi8qKlxuICogRm9yY2VzIGBieVBvc2l0aW9uYCBwYXJhbWV0ZXIgc3RydWN0dXJlLiBUaGlzIGlzIHVzZWZ1bCBpZiB5b3UgaGF2ZSBhIHNpbmdsZVxuICogcGFyYW1ldGVyIHdoaWNoIGhhcyBhIGxpdGVyYWwgdHlwZS5cbiAqL1xuUGFyYW1ldGVyU3RydWN0dXJlcy5ieVBvc2l0aW9uID0gbmV3IFBhcmFtZXRlclN0cnVjdHVyZXMoJ2J5UG9zaXRpb24nKTtcbi8qKlxuICogRm9yY2VzIGBieU5hbWVgIHBhcmFtZXRlciBzdHJ1Y3R1cmUuIFRoaXMgaXMgb25seSB1c2VmdWwgd2hlbiBoYXZpbmcgYSBzaW5nbGVcbiAqIHBhcmFtZXRlci4gVGhlIGxpYnJhcnkgd2lsbCByZXBvcnQgZXJyb3JzIGlmIHVzZWQgd2l0aCBhIGRpZmZlcmVudCBudW1iZXIgb2ZcbiAqIHBhcmFtZXRlcnMuXG4gKi9cblBhcmFtZXRlclN0cnVjdHVyZXMuYnlOYW1lID0gbmV3IFBhcmFtZXRlclN0cnVjdHVyZXMoJ2J5TmFtZScpO1xuLyoqXG4gKiBBbiBhYnN0cmFjdCBpbXBsZW1lbnRhdGlvbiBvZiBhIE1lc3NhZ2VUeXBlLlxuICovXG5jbGFzcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCwgbnVtYmVyT2ZQYXJhbXMpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgIHRoaXMubnVtYmVyT2ZQYXJhbXMgPSBudW1iZXJPZlBhcmFtcztcbiAgICB9XG4gICAgZ2V0IHBhcmFtZXRlclN0cnVjdHVyZXMoKSB7XG4gICAgICAgIHJldHVybiBQYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG87XG4gICAgfVxufVxuZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUgPSBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmU7XG4vKipcbiAqIENsYXNzZXMgdG8gdHlwZSByZXF1ZXN0IHJlc3BvbnNlIHBhaXJzXG4gKi9cbmNsYXNzIFJlcXVlc3RUeXBlMCBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgMCk7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZTAgPSBSZXF1ZXN0VHlwZTA7XG5jbGFzcyBSZXF1ZXN0VHlwZSBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kLCBfcGFyYW1ldGVyU3RydWN0dXJlcyA9IFBhcmFtZXRlclN0cnVjdHVyZXMuYXV0bykge1xuICAgICAgICBzdXBlcihtZXRob2QsIDEpO1xuICAgICAgICB0aGlzLl9wYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gX3BhcmFtZXRlclN0cnVjdHVyZXM7XG4gICAgfVxuICAgIGdldCBwYXJhbWV0ZXJTdHJ1Y3R1cmVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW1ldGVyU3RydWN0dXJlcztcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlID0gUmVxdWVzdFR5cGU7XG5jbGFzcyBSZXF1ZXN0VHlwZTEgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCwgX3BhcmFtZXRlclN0cnVjdHVyZXMgPSBQYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG8pIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAxKTtcbiAgICAgICAgdGhpcy5fcGFyYW1ldGVyU3RydWN0dXJlcyA9IF9wYXJhbWV0ZXJTdHJ1Y3R1cmVzO1xuICAgIH1cbiAgICBnZXQgcGFyYW1ldGVyU3RydWN0dXJlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtZXRlclN0cnVjdHVyZXM7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZTEgPSBSZXF1ZXN0VHlwZTE7XG5jbGFzcyBSZXF1ZXN0VHlwZTIgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDIpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdFR5cGUyID0gUmVxdWVzdFR5cGUyO1xuY2xhc3MgUmVxdWVzdFR5cGUzIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAzKTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlMyA9IFJlcXVlc3RUeXBlMztcbmNsYXNzIFJlcXVlc3RUeXBlNCBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgNCk7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZTQgPSBSZXF1ZXN0VHlwZTQ7XG5jbGFzcyBSZXF1ZXN0VHlwZTUgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDUpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdFR5cGU1ID0gUmVxdWVzdFR5cGU1O1xuY2xhc3MgUmVxdWVzdFR5cGU2IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA2KTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlNiA9IFJlcXVlc3RUeXBlNjtcbmNsYXNzIFJlcXVlc3RUeXBlNyBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgNyk7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0VHlwZTcgPSBSZXF1ZXN0VHlwZTc7XG5jbGFzcyBSZXF1ZXN0VHlwZTggZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDgpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdFR5cGU4ID0gUmVxdWVzdFR5cGU4O1xuY2xhc3MgUmVxdWVzdFR5cGU5IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA5KTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RUeXBlOSA9IFJlcXVlc3RUeXBlOTtcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGUgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCwgX3BhcmFtZXRlclN0cnVjdHVyZXMgPSBQYXJhbWV0ZXJTdHJ1Y3R1cmVzLmF1dG8pIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAxKTtcbiAgICAgICAgdGhpcy5fcGFyYW1ldGVyU3RydWN0dXJlcyA9IF9wYXJhbWV0ZXJTdHJ1Y3R1cmVzO1xuICAgIH1cbiAgICBnZXQgcGFyYW1ldGVyU3RydWN0dXJlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtZXRlclN0cnVjdHVyZXM7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlID0gTm90aWZpY2F0aW9uVHlwZTtcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGUwIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCAwKTtcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGUwID0gTm90aWZpY2F0aW9uVHlwZTA7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlMSBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kLCBfcGFyYW1ldGVyU3RydWN0dXJlcyA9IFBhcmFtZXRlclN0cnVjdHVyZXMuYXV0bykge1xuICAgICAgICBzdXBlcihtZXRob2QsIDEpO1xuICAgICAgICB0aGlzLl9wYXJhbWV0ZXJTdHJ1Y3R1cmVzID0gX3BhcmFtZXRlclN0cnVjdHVyZXM7XG4gICAgfVxuICAgIGdldCBwYXJhbWV0ZXJTdHJ1Y3R1cmVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW1ldGVyU3RydWN0dXJlcztcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGUxID0gTm90aWZpY2F0aW9uVHlwZTE7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlMiBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgMik7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlMiA9IE5vdGlmaWNhdGlvblR5cGUyO1xuY2xhc3MgTm90aWZpY2F0aW9uVHlwZTMgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDMpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTMgPSBOb3RpZmljYXRpb25UeXBlMztcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGU0IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA0KTtcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGU0ID0gTm90aWZpY2F0aW9uVHlwZTQ7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlNSBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgNSk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlNSA9IE5vdGlmaWNhdGlvblR5cGU1O1xuY2xhc3MgTm90aWZpY2F0aW9uVHlwZTYgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDYpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTYgPSBOb3RpZmljYXRpb25UeXBlNjtcbmNsYXNzIE5vdGlmaWNhdGlvblR5cGU3IGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICAgICAgc3VwZXIobWV0aG9kLCA3KTtcbiAgICB9XG59XG5leHBvcnRzLk5vdGlmaWNhdGlvblR5cGU3ID0gTm90aWZpY2F0aW9uVHlwZTc7XG5jbGFzcyBOb3RpZmljYXRpb25UeXBlOCBleHRlbmRzIEFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgOCk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3RpZmljYXRpb25UeXBlOCA9IE5vdGlmaWNhdGlvblR5cGU4O1xuY2xhc3MgTm90aWZpY2F0aW9uVHlwZTkgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIDkpO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uVHlwZTkgPSBOb3RpZmljYXRpb25UeXBlOTtcbnZhciBNZXNzYWdlO1xuKGZ1bmN0aW9uIChNZXNzYWdlKSB7XG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhlIGdpdmVuIG1lc3NhZ2UgaXMgYSByZXF1ZXN0IG1lc3NhZ2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1JlcXVlc3QobWVzc2FnZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSBtZXNzYWdlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIGlzLnN0cmluZyhjYW5kaWRhdGUubWV0aG9kKSAmJiAoaXMuc3RyaW5nKGNhbmRpZGF0ZS5pZCkgfHwgaXMubnVtYmVyKGNhbmRpZGF0ZS5pZCkpO1xuICAgIH1cbiAgICBNZXNzYWdlLmlzUmVxdWVzdCA9IGlzUmVxdWVzdDtcbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGUgZ2l2ZW4gbWVzc2FnZSBpcyBhIG5vdGlmaWNhdGlvbiBtZXNzYWdlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOb3RpZmljYXRpb24obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSBtZXNzYWdlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIGlzLnN0cmluZyhjYW5kaWRhdGUubWV0aG9kKSAmJiBtZXNzYWdlLmlkID09PSB2b2lkIDA7XG4gICAgfVxuICAgIE1lc3NhZ2UuaXNOb3RpZmljYXRpb24gPSBpc05vdGlmaWNhdGlvbjtcbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGUgZ2l2ZW4gbWVzc2FnZSBpcyBhIHJlc3BvbnNlIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1Jlc3BvbnNlKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gbWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiAoY2FuZGlkYXRlLnJlc3VsdCAhPT0gdm9pZCAwIHx8ICEhY2FuZGlkYXRlLmVycm9yKSAmJiAoaXMuc3RyaW5nKGNhbmRpZGF0ZS5pZCkgfHwgaXMubnVtYmVyKGNhbmRpZGF0ZS5pZCkgfHwgY2FuZGlkYXRlLmlkID09PSBudWxsKTtcbiAgICB9XG4gICAgTWVzc2FnZS5pc1Jlc3BvbnNlID0gaXNSZXNwb25zZTtcbn0pKE1lc3NhZ2UgPSBleHBvcnRzLk1lc3NhZ2UgfHwgKGV4cG9ydHMuTWVzc2FnZSA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDUwOTE6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmxldCBfcmFsO1xuZnVuY3Rpb24gUkFMKCkge1xuICAgIGlmIChfcmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBydW50aW1lIGFic3RyYWN0aW9uIGxheWVyIGluc3RhbGxlZGApO1xuICAgIH1cbiAgICByZXR1cm4gX3JhbDtcbn1cbihmdW5jdGlvbiAoUkFMKSB7XG4gICAgZnVuY3Rpb24gaW5zdGFsbChyYWwpIHtcbiAgICAgICAgaWYgKHJhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHJ1bnRpbWUgYWJzdHJhY3Rpb24gbGF5ZXIgcHJvdmlkZWRgKTtcbiAgICAgICAgfVxuICAgICAgICBfcmFsID0gcmFsO1xuICAgIH1cbiAgICBSQUwuaW5zdGFsbCA9IGluc3RhbGw7XG59KShSQUwgfHwgKFJBTCA9IHt9KSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFJBTDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDE4OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLlNlbWFwaG9yZSA9IHZvaWQgMDtcbmNvbnN0IHJhbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MDkxKTtcbmNsYXNzIFNlbWFwaG9yZSB7XG4gICAgY29uc3RydWN0b3IoY2FwYWNpdHkgPSAxKSB7XG4gICAgICAgIGlmIChjYXBhY2l0eSA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhcGFjaXR5IG11c3QgYmUgZ3JlYXRlciB0aGFuIDAnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jYXBhY2l0eSA9IGNhcGFjaXR5O1xuICAgICAgICB0aGlzLl9hY3RpdmUgPSAwO1xuICAgICAgICB0aGlzLl93YWl0aW5nID0gW107XG4gICAgfVxuICAgIGxvY2sodGh1bmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3dhaXRpbmcucHVzaCh7IHRodW5rLCByZXNvbHZlLCByZWplY3QgfSk7XG4gICAgICAgICAgICB0aGlzLnJ1bk5leHQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBhY3RpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gICAgfVxuICAgIHJ1bk5leHQoKSB7XG4gICAgICAgIGlmICh0aGlzLl93YWl0aW5nLmxlbmd0aCA9PT0gMCB8fCB0aGlzLl9hY3RpdmUgPT09IHRoaXMuX2NhcGFjaXR5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgKDAsIHJhbF8xLmRlZmF1bHQpKCkudGltZXIuc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuZG9SdW5OZXh0KCkpO1xuICAgIH1cbiAgICBkb1J1bk5leHQoKSB7XG4gICAgICAgIGlmICh0aGlzLl93YWl0aW5nLmxlbmd0aCA9PT0gMCB8fCB0aGlzLl9hY3RpdmUgPT09IHRoaXMuX2NhcGFjaXR5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMuX3dhaXRpbmcuc2hpZnQoKTtcbiAgICAgICAgdGhpcy5fYWN0aXZlKys7XG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmUgPiB0aGlzLl9jYXBhY2l0eSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUbyBtYW55IHRodW5rcyBhY3RpdmVgKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV4dC50aHVuaygpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudGhlbigodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlLS07XG4gICAgICAgICAgICAgICAgICAgIG5leHQucmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucnVuTmV4dCgpO1xuICAgICAgICAgICAgICAgIH0sIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlLS07XG4gICAgICAgICAgICAgICAgICAgIG5leHQucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucnVuTmV4dCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlLS07XG4gICAgICAgICAgICAgICAgbmV4dC5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5OZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZlLS07XG4gICAgICAgICAgICBuZXh0LnJlamVjdChlcnIpO1xuICAgICAgICAgICAgdGhpcy5ydW5OZXh0KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlNlbWFwaG9yZSA9IFNlbWFwaG9yZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzQ4OTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5TaGFyZWRBcnJheVJlY2VpdmVyU3RyYXRlZ3kgPSBleHBvcnRzLlNoYXJlZEFycmF5U2VuZGVyU3RyYXRlZ3kgPSB2b2lkIDA7XG5jb25zdCBjYW5jZWxsYXRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjk1Nyk7XG52YXIgQ2FuY2VsbGF0aW9uU3RhdGU7XG4oZnVuY3Rpb24gKENhbmNlbGxhdGlvblN0YXRlKSB7XG4gICAgQ2FuY2VsbGF0aW9uU3RhdGUuQ29udGludWUgPSAwO1xuICAgIENhbmNlbGxhdGlvblN0YXRlLkNhbmNlbGxlZCA9IDE7XG59KShDYW5jZWxsYXRpb25TdGF0ZSB8fCAoQ2FuY2VsbGF0aW9uU3RhdGUgPSB7fSkpO1xuY2xhc3MgU2hhcmVkQXJyYXlTZW5kZXJTdHJhdGVneSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYnVmZmVycyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgZW5hYmxlQ2FuY2VsbGF0aW9uKHJlcXVlc3QpIHtcbiAgICAgICAgaWYgKHJlcXVlc3QuaWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWZmZXIgPSBuZXcgU2hhcmVkQXJyYXlCdWZmZXIoNCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgSW50MzJBcnJheShidWZmZXIsIDAsIDEpO1xuICAgICAgICBkYXRhWzBdID0gQ2FuY2VsbGF0aW9uU3RhdGUuQ29udGludWU7XG4gICAgICAgIHRoaXMuYnVmZmVycy5zZXQocmVxdWVzdC5pZCwgYnVmZmVyKTtcbiAgICAgICAgcmVxdWVzdC4kY2FuY2VsbGF0aW9uRGF0YSA9IGJ1ZmZlcjtcbiAgICB9XG4gICAgYXN5bmMgc2VuZENhbmNlbGxhdGlvbihfY29ubiwgaWQpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5idWZmZXJzLmdldChpZCk7XG4gICAgICAgIGlmIChidWZmZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgSW50MzJBcnJheShidWZmZXIsIDAsIDEpO1xuICAgICAgICBBdG9taWNzLnN0b3JlKGRhdGEsIDAsIENhbmNlbGxhdGlvblN0YXRlLkNhbmNlbGxlZCk7XG4gICAgfVxuICAgIGNsZWFudXAoaWQpIHtcbiAgICAgICAgdGhpcy5idWZmZXJzLmRlbGV0ZShpZCk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuYnVmZmVycy5jbGVhcigpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2hhcmVkQXJyYXlTZW5kZXJTdHJhdGVneSA9IFNoYXJlZEFycmF5U2VuZGVyU3RyYXRlZ3k7XG5jbGFzcyBTaGFyZWRBcnJheUJ1ZmZlckNhbmNlbGxhdGlvblRva2VuIHtcbiAgICBjb25zdHJ1Y3RvcihidWZmZXIpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gbmV3IEludDMyQXJyYXkoYnVmZmVyLCAwLCAxKTtcbiAgICB9XG4gICAgZ2V0IGlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKCkge1xuICAgICAgICByZXR1cm4gQXRvbWljcy5sb2FkKHRoaXMuZGF0YSwgMCkgPT09IENhbmNlbGxhdGlvblN0YXRlLkNhbmNlbGxlZDtcbiAgICB9XG4gICAgZ2V0IG9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbmNlbGxhdGlvbiBvdmVyIFNoYXJlZEFycmF5QnVmZmVyIGRvZXNuJ3Qgc3VwcG9ydCBjYW5jZWxsYXRpb24gZXZlbnRzYCk7XG4gICAgfVxufVxuY2xhc3MgU2hhcmVkQXJyYXlCdWZmZXJDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSB7XG4gICAgY29uc3RydWN0b3IoYnVmZmVyKSB7XG4gICAgICAgIHRoaXMudG9rZW4gPSBuZXcgU2hhcmVkQXJyYXlCdWZmZXJDYW5jZWxsYXRpb25Ub2tlbihidWZmZXIpO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgfVxufVxuY2xhc3MgU2hhcmVkQXJyYXlSZWNlaXZlclN0cmF0ZWd5IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5raW5kID0gJ3JlcXVlc3QnO1xuICAgIH1cbiAgICBjcmVhdGVDYW5jZWxsYXRpb25Ub2tlblNvdXJjZShyZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHJlcXVlc3QuJGNhbmNlbGxhdGlvbkRhdGE7XG4gICAgICAgIGlmIChidWZmZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBjYW5jZWxsYXRpb25fMS5DYW5jZWxsYXRpb25Ub2tlblNvdXJjZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU2hhcmVkQXJyYXlCdWZmZXJDYW5jZWxsYXRpb25Ub2tlblNvdXJjZShidWZmZXIpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2hhcmVkQXJyYXlSZWNlaXZlclN0cmF0ZWd5ID0gU2hhcmVkQXJyYXlSZWNlaXZlclN0cmF0ZWd5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1NTAxOlxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5jcmVhdGVQcm90b2NvbENvbm5lY3Rpb24gPSB2b2lkIDA7XG5jb25zdCBicm93c2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyMDgpO1xuX19leHBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oOTIwOCksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMzE0NyksIGV4cG9ydHMpO1xuZnVuY3Rpb24gY3JlYXRlUHJvdG9jb2xDb25uZWN0aW9uKHJlYWRlciwgd3JpdGVyLCBsb2dnZXIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKDAsIGJyb3dzZXJfMS5jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbikocmVhZGVyLCB3cml0ZXIsIGxvZ2dlciwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmNyZWF0ZVByb3RvY29sQ29ubmVjdGlvbiA9IGNyZWF0ZVByb3RvY29sQ29ubmVjdGlvbjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzE0Nzpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuTFNQRXJyb3JDb2RlcyA9IGV4cG9ydHMuY3JlYXRlUHJvdG9jb2xDb25uZWN0aW9uID0gdm9pZCAwO1xuX19leHBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oOTExMCksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oNzcxNyksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oODQzMSksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMTgxNSksIGV4cG9ydHMpO1xudmFyIGNvbm5lY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjkxKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZVByb3RvY29sQ29ubmVjdGlvblwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5jcmVhdGVQcm90b2NvbENvbm5lY3Rpb247IH0gfSkpO1xudmFyIExTUEVycm9yQ29kZXM7XG4oZnVuY3Rpb24gKExTUEVycm9yQ29kZXMpIHtcbiAgICAvKipcbiAgICAqIFRoaXMgaXMgdGhlIHN0YXJ0IHJhbmdlIG9mIExTUCByZXNlcnZlZCBlcnJvciBjb2Rlcy5cbiAgICAqIEl0IGRvZXNuJ3QgZGVub3RlIGEgcmVhbCBlcnJvciBjb2RlLlxuICAgICpcbiAgICAqIEBzaW5jZSAzLjE2LjBcbiAgICAqL1xuICAgIExTUEVycm9yQ29kZXMubHNwUmVzZXJ2ZWRFcnJvclJhbmdlU3RhcnQgPSAtMzI4OTk7XG4gICAgLyoqXG4gICAgICogQSByZXF1ZXN0IGZhaWxlZCBidXQgaXQgd2FzIHN5bnRhY3RpY2FsbHkgY29ycmVjdCwgZS5nIHRoZVxuICAgICAqIG1ldGhvZCBuYW1lIHdhcyBrbm93biBhbmQgdGhlIHBhcmFtZXRlcnMgd2VyZSB2YWxpZC4gVGhlIGVycm9yXG4gICAgICogbWVzc2FnZSBzaG91bGQgY29udGFpbiBodW1hbiByZWFkYWJsZSBpbmZvcm1hdGlvbiBhYm91dCB3aHlcbiAgICAgKiB0aGUgcmVxdWVzdCBmYWlsZWQuXG4gICAgICpcbiAgICAgKiBAc2luY2UgMy4xNy4wXG4gICAgICovXG4gICAgTFNQRXJyb3JDb2Rlcy5SZXF1ZXN0RmFpbGVkID0gLTMyODAzO1xuICAgIC8qKlxuICAgICAqIFRoZSBzZXJ2ZXIgY2FuY2VsbGVkIHRoZSByZXF1ZXN0LiBUaGlzIGVycm9yIGNvZGUgc2hvdWxkXG4gICAgICogb25seSBiZSB1c2VkIGZvciByZXF1ZXN0cyB0aGF0IGV4cGxpY2l0bHkgc3VwcG9ydCBiZWluZ1xuICAgICAqIHNlcnZlciBjYW5jZWxsYWJsZS5cbiAgICAgKlxuICAgICAqIEBzaW5jZSAzLjE3LjBcbiAgICAgKi9cbiAgICBMU1BFcnJvckNvZGVzLlNlcnZlckNhbmNlbGxlZCA9IC0zMjgwMjtcbiAgICAvKipcbiAgICAgKiBUaGUgc2VydmVyIGRldGVjdGVkIHRoYXQgdGhlIGNvbnRlbnQgb2YgYSBkb2N1bWVudCBnb3RcbiAgICAgKiBtb2RpZmllZCBvdXRzaWRlIG5vcm1hbCBjb25kaXRpb25zLiBBIHNlcnZlciBzaG91bGRcbiAgICAgKiBOT1Qgc2VuZCB0aGlzIGVycm9yIGNvZGUgaWYgaXQgZGV0ZWN0cyBhIGNvbnRlbnQgY2hhbmdlXG4gICAgICogaW4gaXQgdW5wcm9jZXNzZWQgbWVzc2FnZXMuIFRoZSByZXN1bHQgZXZlbiBjb21wdXRlZFxuICAgICAqIG9uIGFuIG9sZGVyIHN0YXRlIG1pZ2h0IHN0aWxsIGJlIHVzZWZ1bCBmb3IgdGhlIGNsaWVudC5cbiAgICAgKlxuICAgICAqIElmIGEgY2xpZW50IGRlY2lkZXMgdGhhdCBhIHJlc3VsdCBpcyBub3Qgb2YgYW55IHVzZSBhbnltb3JlXG4gICAgICogdGhlIGNsaWVudCBzaG91bGQgY2FuY2VsIHRoZSByZXF1ZXN0LlxuICAgICAqL1xuICAgIExTUEVycm9yQ29kZXMuQ29udGVudE1vZGlmaWVkID0gLTMyODAxO1xuICAgIC8qKlxuICAgICAqIFRoZSBjbGllbnQgaGFzIGNhbmNlbGVkIGEgcmVxdWVzdCBhbmQgYSBzZXJ2ZXIgYXMgZGV0ZWN0ZWRcbiAgICAgKiB0aGUgY2FuY2VsLlxuICAgICAqL1xuICAgIExTUEVycm9yQ29kZXMuUmVxdWVzdENhbmNlbGxlZCA9IC0zMjgwMDtcbiAgICAvKipcbiAgICAqIFRoaXMgaXMgdGhlIGVuZCByYW5nZSBvZiBMU1AgcmVzZXJ2ZWQgZXJyb3IgY29kZXMuXG4gICAgKiBJdCBkb2Vzbid0IGRlbm90ZSBhIHJlYWwgZXJyb3IgY29kZS5cbiAgICAqXG4gICAgKiBAc2luY2UgMy4xNi4wXG4gICAgKi9cbiAgICBMU1BFcnJvckNvZGVzLmxzcFJlc2VydmVkRXJyb3JSYW5nZUVuZCA9IC0zMjgwMDtcbn0pKExTUEVycm9yQ29kZXMgPSBleHBvcnRzLkxTUEVycm9yQ29kZXMgfHwgKGV4cG9ydHMuTFNQRXJyb3JDb2RlcyA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI5MTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5jcmVhdGVQcm90b2NvbENvbm5lY3Rpb24gPSB2b2lkIDA7XG5jb25zdCB2c2NvZGVfanNvbnJwY18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MTEwKTtcbmZ1bmN0aW9uIGNyZWF0ZVByb3RvY29sQ29ubmVjdGlvbihpbnB1dCwgb3V0cHV0LCBsb2dnZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAodnNjb2RlX2pzb25ycGNfMS5Db25uZWN0aW9uU3RyYXRlZ3kuaXMob3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucyA9IHsgY29ubmVjdGlvblN0cmF0ZWd5OiBvcHRpb25zIH07XG4gICAgfVxuICAgIHJldHVybiAoMCwgdnNjb2RlX2pzb25ycGNfMS5jcmVhdGVNZXNzYWdlQ29ubmVjdGlvbikoaW5wdXQsIG91dHB1dCwgbG9nZ2VyLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuY3JlYXRlUHJvdG9jb2xDb25uZWN0aW9uID0gY3JlYXRlUHJvdG9jb2xDb25uZWN0aW9uO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4NDMxOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZSA9IGV4cG9ydHMuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlMCA9IGV4cG9ydHMuUHJvdG9jb2xSZXF1ZXN0VHlwZSA9IGV4cG9ydHMuUHJvdG9jb2xSZXF1ZXN0VHlwZTAgPSBleHBvcnRzLlJlZ2lzdHJhdGlvblR5cGUgPSBleHBvcnRzLk1lc3NhZ2VEaXJlY3Rpb24gPSB2b2lkIDA7XG5jb25zdCB2c2NvZGVfanNvbnJwY18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MTEwKTtcbnZhciBNZXNzYWdlRGlyZWN0aW9uO1xuKGZ1bmN0aW9uIChNZXNzYWdlRGlyZWN0aW9uKSB7XG4gICAgTWVzc2FnZURpcmVjdGlvbltcImNsaWVudFRvU2VydmVyXCJdID0gXCJjbGllbnRUb1NlcnZlclwiO1xuICAgIE1lc3NhZ2VEaXJlY3Rpb25bXCJzZXJ2ZXJUb0NsaWVudFwiXSA9IFwic2VydmVyVG9DbGllbnRcIjtcbiAgICBNZXNzYWdlRGlyZWN0aW9uW1wiYm90aFwiXSA9IFwiYm90aFwiO1xufSkoTWVzc2FnZURpcmVjdGlvbiA9IGV4cG9ydHMuTWVzc2FnZURpcmVjdGlvbiB8fCAoZXhwb3J0cy5NZXNzYWdlRGlyZWN0aW9uID0ge30pKTtcbmNsYXNzIFJlZ2lzdHJhdGlvblR5cGUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgICB9XG59XG5leHBvcnRzLlJlZ2lzdHJhdGlvblR5cGUgPSBSZWdpc3RyYXRpb25UeXBlO1xuY2xhc3MgUHJvdG9jb2xSZXF1ZXN0VHlwZTAgZXh0ZW5kcyB2c2NvZGVfanNvbnJwY18xLlJlcXVlc3RUeXBlMCB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCk7XG4gICAgfVxufVxuZXhwb3J0cy5Qcm90b2NvbFJlcXVlc3RUeXBlMCA9IFByb3RvY29sUmVxdWVzdFR5cGUwO1xuY2xhc3MgUHJvdG9jb2xSZXF1ZXN0VHlwZSBleHRlbmRzIHZzY29kZV9qc29ucnBjXzEuUmVxdWVzdFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgICAgICBzdXBlcihtZXRob2QsIHZzY29kZV9qc29ucnBjXzEuUGFyYW1ldGVyU3RydWN0dXJlcy5ieU5hbWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuUHJvdG9jb2xSZXF1ZXN0VHlwZSA9IFByb3RvY29sUmVxdWVzdFR5cGU7XG5jbGFzcyBQcm90b2NvbE5vdGlmaWNhdGlvblR5cGUwIGV4dGVuZHMgdnNjb2RlX2pzb25ycGNfMS5Ob3RpZmljYXRpb25UeXBlMCB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCk7XG4gICAgfVxufVxuZXhwb3J0cy5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUwID0gUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlMDtcbmNsYXNzIFByb3RvY29sTm90aWZpY2F0aW9uVHlwZSBleHRlbmRzIHZzY29kZV9qc29ucnBjXzEuTm90aWZpY2F0aW9uVHlwZSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgICAgIHN1cGVyKG1ldGhvZCwgdnNjb2RlX2pzb25ycGNfMS5QYXJhbWV0ZXJTdHJ1Y3R1cmVzLmJ5TmFtZSk7XG4gICAgfVxufVxuZXhwb3J0cy5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUgPSBQcm90b2NvbE5vdGlmaWNhdGlvblR5cGU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDc2MDI6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBUeXBlRm94LCBNaWNyb3NvZnQgYW5kIG90aGVycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5DYWxsSGllcmFyY2h5T3V0Z29pbmdDYWxsc1JlcXVlc3QgPSBleHBvcnRzLkNhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdCA9IGV4cG9ydHMuQ2FsbEhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0ID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODQzMSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXN1bHQgYSBgQ2FsbEhpZXJhcmNoeUl0ZW1gIGluIGEgZG9jdW1lbnQgYXQgYSBnaXZlbiBwb3NpdGlvbi5cbiAqIENhbiBiZSB1c2VkIGFzIGFuIGlucHV0IHRvIGFuIGluY29taW5nIG9yIG91dGdvaW5nIGNhbGwgaGllcmFyY2h5LlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIENhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdDtcbihmdW5jdGlvbiAoQ2FsbEhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0KSB7XG4gICAgQ2FsbEhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvcHJlcGFyZUNhbGxIaWVyYXJjaHknO1xuICAgIENhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIENhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShDYWxsSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QubWV0aG9kKTtcbn0pKENhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCA9IGV4cG9ydHMuQ2FsbEhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0IHx8IChleHBvcnRzLkNhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIHRoZSBpbmNvbWluZyBjYWxscyBmb3IgYSBnaXZlbiBgQ2FsbEhpZXJhcmNoeUl0ZW1gLlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIENhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdDtcbihmdW5jdGlvbiAoQ2FsbEhpZXJhcmNoeUluY29taW5nQ2FsbHNSZXF1ZXN0KSB7XG4gICAgQ2FsbEhpZXJhcmNoeUluY29taW5nQ2FsbHNSZXF1ZXN0Lm1ldGhvZCA9ICdjYWxsSGllcmFyY2h5L2luY29taW5nQ2FsbHMnO1xuICAgIENhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIENhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShDYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3QubWV0aG9kKTtcbn0pKENhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdCA9IGV4cG9ydHMuQ2FsbEhpZXJhcmNoeUluY29taW5nQ2FsbHNSZXF1ZXN0IHx8IChleHBvcnRzLkNhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIHRoZSBvdXRnb2luZyBjYWxscyBmb3IgYSBnaXZlbiBgQ2FsbEhpZXJhcmNoeUl0ZW1gLlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIENhbGxIaWVyYXJjaHlPdXRnb2luZ0NhbGxzUmVxdWVzdDtcbihmdW5jdGlvbiAoQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0KSB7XG4gICAgQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0Lm1ldGhvZCA9ICdjYWxsSGllcmFyY2h5L291dGdvaW5nQ2FsbHMnO1xuICAgIENhbGxIaWVyYXJjaHlPdXRnb2luZ0NhbGxzUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIENhbGxIaWVyYXJjaHlPdXRnb2luZ0NhbGxzUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShDYWxsSGllcmFyY2h5T3V0Z29pbmdDYWxsc1JlcXVlc3QubWV0aG9kKTtcbn0pKENhbGxIaWVyYXJjaHlPdXRnb2luZ0NhbGxzUmVxdWVzdCA9IGV4cG9ydHMuQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0IHx8IChleHBvcnRzLkNhbGxIaWVyYXJjaHlPdXRnb2luZ0NhbGxzUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM3NDc6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudENvbG9yUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gbGlzdCBhbGwgY29sb3Igc3ltYm9scyBmb3VuZCBpbiBhIGdpdmVuIHRleHQgZG9jdW1lbnQuIFRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBEb2N1bWVudENvbG9yUGFyYW1zfSB0aGVcbiAqIHJlc3BvbnNlIGlzIG9mIHR5cGUge0BsaW5rIENvbG9ySW5mb3JtYXRpb24gQ29sb3JJbmZvcm1hdGlvbltdfSBvciBhIFRoZW5hYmxlXG4gKiB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBEb2N1bWVudENvbG9yUmVxdWVzdDtcbihmdW5jdGlvbiAoRG9jdW1lbnRDb2xvclJlcXVlc3QpIHtcbiAgICBEb2N1bWVudENvbG9yUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2RvY3VtZW50Q29sb3InO1xuICAgIERvY3VtZW50Q29sb3JSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRG9jdW1lbnRDb2xvclJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRG9jdW1lbnRDb2xvclJlcXVlc3QubWV0aG9kKTtcbn0pKERvY3VtZW50Q29sb3JSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudENvbG9yUmVxdWVzdCB8fCAoZXhwb3J0cy5Eb2N1bWVudENvbG9yUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBsaXN0IGFsbCBwcmVzZW50YXRpb24gZm9yIGEgY29sb3IuIFRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBDb2xvclByZXNlbnRhdGlvblBhcmFtc30gdGhlXG4gKiByZXNwb25zZSBpcyBvZiB0eXBlIHtAbGluayBDb2xvckluZm9ybWF0aW9uIENvbG9ySW5mb3JtYXRpb25bXX0gb3IgYSBUaGVuYWJsZVxuICogdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0O1xuKGZ1bmN0aW9uIChDb2xvclByZXNlbnRhdGlvblJlcXVlc3QpIHtcbiAgICBDb2xvclByZXNlbnRhdGlvblJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9jb2xvclByZXNlbnRhdGlvbic7XG4gICAgQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKENvbG9yUHJlc2VudGF0aW9uUmVxdWVzdC5tZXRob2QpO1xufSkoQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5Db2xvclByZXNlbnRhdGlvblJlcXVlc3QgfHwgKGV4cG9ydHMuQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzYzOTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5Db25maWd1cmF0aW9uUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuLy8tLS0tIEdldCBDb25maWd1cmF0aW9uIHJlcXVlc3QgLS0tLVxuLyoqXG4gKiBUaGUgJ3dvcmtzcGFjZS9jb25maWd1cmF0aW9uJyByZXF1ZXN0IGlzIHNlbnQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQgdG8gZmV0Y2ggYSBjZXJ0YWluXG4gKiBjb25maWd1cmF0aW9uIHNldHRpbmcuXG4gKlxuICogVGhpcyBwdWxsIG1vZGVsIHJlcGxhY2VzIHRoZSBvbGQgcHVzaCBtb2RlbCB3ZXJlIHRoZSBjbGllbnQgc2lnbmFsZWQgY29uZmlndXJhdGlvbiBjaGFuZ2UgdmlhIGFuXG4gKiBldmVudC4gSWYgdGhlIHNlcnZlciBzdGlsbCBuZWVkcyB0byByZWFjdCB0byBjb25maWd1cmF0aW9uIGNoYW5nZXMgKHNpbmNlIHRoZSBzZXJ2ZXIgY2FjaGVzIHRoZVxuICogcmVzdWx0IG9mIGB3b3Jrc3BhY2UvY29uZmlndXJhdGlvbmAgcmVxdWVzdHMpIHRoZSBzZXJ2ZXIgc2hvdWxkIHJlZ2lzdGVyIGZvciBhbiBlbXB0eSBjb25maWd1cmF0aW9uXG4gKiBjaGFuZ2UgZXZlbnQgYW5kIGVtcHR5IHRoZSBjYWNoZSBpZiBzdWNoIGFuIGV2ZW50IGlzIHJlY2VpdmVkLlxuICovXG52YXIgQ29uZmlndXJhdGlvblJlcXVlc3Q7XG4oZnVuY3Rpb24gKENvbmZpZ3VyYXRpb25SZXF1ZXN0KSB7XG4gICAgQ29uZmlndXJhdGlvblJlcXVlc3QubWV0aG9kID0gJ3dvcmtzcGFjZS9jb25maWd1cmF0aW9uJztcbiAgICBDb25maWd1cmF0aW9uUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIENvbmZpZ3VyYXRpb25SZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKENvbmZpZ3VyYXRpb25SZXF1ZXN0Lm1ldGhvZCk7XG59KShDb25maWd1cmF0aW9uUmVxdWVzdCA9IGV4cG9ydHMuQ29uZmlndXJhdGlvblJlcXVlc3QgfHwgKGV4cG9ydHMuQ29uZmlndXJhdGlvblJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1NTgxOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkRlY2xhcmF0aW9uUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuLy8gQHRzLWlnbm9yZTogdG8gYXZvaWQgaW5saW5pbmcgTG9jYXRpb25MaW5rIGFzIGR5bmFtaWMgaW1wb3J0XG5sZXQgX19ub0R5bmFtaWNJbXBvcnQ7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIHRoZSB0eXBlIGRlZmluaXRpb24gbG9jYXRpb25zIG9mIGEgc3ltYm9sIGF0IGEgZ2l2ZW4gdGV4dFxuICogZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mIHR5cGUgW1RleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zXVxuICogKCNUZXh0RG9jdW1lbnRQb3NpdGlvblBhcmFtcykgdGhlIHJlc3BvbnNlIGlzIG9mIHR5cGUge0BsaW5rIERlY2xhcmF0aW9ufVxuICogb3IgYSB0eXBlZCBhcnJheSBvZiB7QGxpbmsgRGVjbGFyYXRpb25MaW5rfSBvciBhIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXNcbiAqIHRvIHN1Y2guXG4gKi9cbnZhciBEZWNsYXJhdGlvblJlcXVlc3Q7XG4oZnVuY3Rpb24gKERlY2xhcmF0aW9uUmVxdWVzdCkge1xuICAgIERlY2xhcmF0aW9uUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2RlY2xhcmF0aW9uJztcbiAgICBEZWNsYXJhdGlvblJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEZWNsYXJhdGlvblJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRGVjbGFyYXRpb25SZXF1ZXN0Lm1ldGhvZCk7XG59KShEZWNsYXJhdGlvblJlcXVlc3QgPSBleHBvcnRzLkRlY2xhcmF0aW9uUmVxdWVzdCB8fCAoZXhwb3J0cy5EZWNsYXJhdGlvblJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxNDk0OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkRpYWdub3N0aWNSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50RGlhZ25vc3RpY1JlcG9ydEtpbmQgPSBleHBvcnRzLkRpYWdub3N0aWNTZXJ2ZXJDYW5jZWxsYXRpb25EYXRhID0gdm9pZCAwO1xuY29uc3QgdnNjb2RlX2pzb25ycGNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOTExMCk7XG5jb25zdCBJcyA9IF9fd2VicGFja19yZXF1aXJlX18oODYzMyk7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8qKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgRGlhZ25vc3RpY1NlcnZlckNhbmNlbGxhdGlvbkRhdGE7XG4oZnVuY3Rpb24gKERpYWdub3N0aWNTZXJ2ZXJDYW5jZWxsYXRpb25EYXRhKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuYm9vbGVhbihjYW5kaWRhdGUucmV0cmlnZ2VyUmVxdWVzdCk7XG4gICAgfVxuICAgIERpYWdub3N0aWNTZXJ2ZXJDYW5jZWxsYXRpb25EYXRhLmlzID0gaXM7XG59KShEaWFnbm9zdGljU2VydmVyQ2FuY2VsbGF0aW9uRGF0YSA9IGV4cG9ydHMuRGlhZ25vc3RpY1NlcnZlckNhbmNlbGxhdGlvbkRhdGEgfHwgKGV4cG9ydHMuRGlhZ25vc3RpY1NlcnZlckNhbmNlbGxhdGlvbkRhdGEgPSB7fSkpO1xuLyoqXG4gKiBUaGUgZG9jdW1lbnQgZGlhZ25vc3RpYyByZXBvcnQga2luZHMuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgRG9jdW1lbnREaWFnbm9zdGljUmVwb3J0S2luZDtcbihmdW5jdGlvbiAoRG9jdW1lbnREaWFnbm9zdGljUmVwb3J0S2luZCkge1xuICAgIC8qKlxuICAgICAqIEEgZGlhZ25vc3RpYyByZXBvcnQgd2l0aCBhIGZ1bGxcbiAgICAgKiBzZXQgb2YgcHJvYmxlbXMuXG4gICAgICovXG4gICAgRG9jdW1lbnREaWFnbm9zdGljUmVwb3J0S2luZC5GdWxsID0gJ2Z1bGwnO1xuICAgIC8qKlxuICAgICAqIEEgcmVwb3J0IGluZGljYXRpbmcgdGhhdCB0aGUgbGFzdFxuICAgICAqIHJldHVybmVkIHJlcG9ydCBpcyBzdGlsbCBhY2N1cmF0ZS5cbiAgICAgKi9cbiAgICBEb2N1bWVudERpYWdub3N0aWNSZXBvcnRLaW5kLlVuY2hhbmdlZCA9ICd1bmNoYW5nZWQnO1xufSkoRG9jdW1lbnREaWFnbm9zdGljUmVwb3J0S2luZCA9IGV4cG9ydHMuRG9jdW1lbnREaWFnbm9zdGljUmVwb3J0S2luZCB8fCAoZXhwb3J0cy5Eb2N1bWVudERpYWdub3N0aWNSZXBvcnRLaW5kID0ge30pKTtcbi8qKlxuICogVGhlIGRvY3VtZW50IGRpYWdub3N0aWMgcmVxdWVzdCBkZWZpbml0aW9uLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIERvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3Q7XG4oZnVuY3Rpb24gKERvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3QpIHtcbiAgICBEb2N1bWVudERpYWdub3N0aWNSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvZGlhZ25vc3RpYyc7XG4gICAgRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdC5tZXRob2QpO1xuICAgIERvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3QucGFydGlhbFJlc3VsdCA9IG5ldyB2c2NvZGVfanNvbnJwY18xLlByb2dyZXNzVHlwZSgpO1xufSkoRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdCB8fCAoZXhwb3J0cy5Eb2N1bWVudERpYWdub3N0aWNSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogVGhlIHdvcmtzcGFjZSBkaWFnbm9zdGljIHJlcXVlc3QgZGVmaW5pdGlvbi5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBXb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdDtcbihmdW5jdGlvbiAoV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QpIHtcbiAgICBXb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdC5tZXRob2QgPSAnd29ya3NwYWNlL2RpYWdub3N0aWMnO1xuICAgIFdvcmtzcGFjZURpYWdub3N0aWNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QubWV0aG9kKTtcbiAgICBXb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdC5wYXJ0aWFsUmVzdWx0ID0gbmV3IHZzY29kZV9qc29ucnBjXzEuUHJvZ3Jlc3NUeXBlKCk7XG59KShXb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdCA9IGV4cG9ydHMuV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QgfHwgKGV4cG9ydHMuV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBUaGUgZGlhZ25vc3RpYyByZWZyZXNoIHJlcXVlc3QgZGVmaW5pdGlvbi5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBEaWFnbm9zdGljUmVmcmVzaFJlcXVlc3Q7XG4oZnVuY3Rpb24gKERpYWdub3N0aWNSZWZyZXNoUmVxdWVzdCkge1xuICAgIERpYWdub3N0aWNSZWZyZXNoUmVxdWVzdC5tZXRob2QgPSBgd29ya3NwYWNlL2RpYWdub3N0aWMvcmVmcmVzaGA7XG4gICAgRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlMChEaWFnbm9zdGljUmVmcmVzaFJlcXVlc3QubWV0aG9kKTtcbn0pKERpYWdub3N0aWNSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0IHx8IChleHBvcnRzLkRpYWdub3N0aWNSZWZyZXNoUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQ3ODE6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuV2lsbERlbGV0ZUZpbGVzUmVxdWVzdCA9IGV4cG9ydHMuRGlkRGVsZXRlRmlsZXNOb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZFJlbmFtZUZpbGVzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5XaWxsUmVuYW1lRmlsZXNSZXF1ZXN0ID0gZXhwb3J0cy5EaWRDcmVhdGVGaWxlc05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuV2lsbENyZWF0ZUZpbGVzUmVxdWVzdCA9IGV4cG9ydHMuRmlsZU9wZXJhdGlvblBhdHRlcm5LaW5kID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODQzMSk7XG4vKipcbiAqIEEgcGF0dGVybiBraW5kIGRlc2NyaWJpbmcgaWYgYSBnbG9iIHBhdHRlcm4gbWF0Y2hlcyBhIGZpbGUgYSBmb2xkZXIgb3JcbiAqIGJvdGguXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgRmlsZU9wZXJhdGlvblBhdHRlcm5LaW5kO1xuKGZ1bmN0aW9uIChGaWxlT3BlcmF0aW9uUGF0dGVybktpbmQpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgcGF0dGVybiBtYXRjaGVzIGEgZmlsZSBvbmx5LlxuICAgICAqL1xuICAgIEZpbGVPcGVyYXRpb25QYXR0ZXJuS2luZC5maWxlID0gJ2ZpbGUnO1xuICAgIC8qKlxuICAgICAqIFRoZSBwYXR0ZXJuIG1hdGNoZXMgYSBmb2xkZXIgb25seS5cbiAgICAgKi9cbiAgICBGaWxlT3BlcmF0aW9uUGF0dGVybktpbmQuZm9sZGVyID0gJ2ZvbGRlcic7XG59KShGaWxlT3BlcmF0aW9uUGF0dGVybktpbmQgPSBleHBvcnRzLkZpbGVPcGVyYXRpb25QYXR0ZXJuS2luZCB8fCAoZXhwb3J0cy5GaWxlT3BlcmF0aW9uUGF0dGVybktpbmQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgd2lsbCBjcmVhdGUgZmlsZXMgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIGJlZm9yZSBmaWxlcyBhcmUgYWN0dWFsbHlcbiAqIGNyZWF0ZWQgYXMgbG9uZyBhcyB0aGUgY3JlYXRpb24gaXMgdHJpZ2dlcmVkIGZyb20gd2l0aGluIHRoZSBjbGllbnQuXG4gKlxuICogVGhlIHJlcXVlc3QgY2FuIHJldHVybiBhIGBXb3Jrc3BhY2VFZGl0YCB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gd29ya3NwYWNlIGJlZm9yZSB0aGVcbiAqIGZpbGVzIGFyZSBjcmVhdGVkLiBIZW5jZSB0aGUgYFdvcmtzcGFjZUVkaXRgIGNhbiBub3QgbWFuaXB1bGF0ZSB0aGUgY29udGVudCBvZiB0aGUgZmlsZVxuICogdG8gYmUgY3JlYXRlZC5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBXaWxsQ3JlYXRlRmlsZXNSZXF1ZXN0O1xuKGZ1bmN0aW9uIChXaWxsQ3JlYXRlRmlsZXNSZXF1ZXN0KSB7XG4gICAgV2lsbENyZWF0ZUZpbGVzUmVxdWVzdC5tZXRob2QgPSAnd29ya3NwYWNlL3dpbGxDcmVhdGVGaWxlcyc7XG4gICAgV2lsbENyZWF0ZUZpbGVzUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFdpbGxDcmVhdGVGaWxlc1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoV2lsbENyZWF0ZUZpbGVzUmVxdWVzdC5tZXRob2QpO1xufSkoV2lsbENyZWF0ZUZpbGVzUmVxdWVzdCA9IGV4cG9ydHMuV2lsbENyZWF0ZUZpbGVzUmVxdWVzdCB8fCAoZXhwb3J0cy5XaWxsQ3JlYXRlRmlsZXNSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogVGhlIGRpZCBjcmVhdGUgZmlsZXMgbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgd2hlblxuICogZmlsZXMgd2VyZSBjcmVhdGVkIGZyb20gd2l0aGluIHRoZSBjbGllbnQuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKERpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uKSB7XG4gICAgRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb24ubWV0aG9kID0gJ3dvcmtzcGFjZS9kaWRDcmVhdGVGaWxlcyc7XG4gICAgRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRDcmVhdGVGaWxlc05vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShEaWRDcmVhdGVGaWxlc05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgd2lsbCByZW5hbWUgZmlsZXMgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIGJlZm9yZSBmaWxlcyBhcmUgYWN0dWFsbHlcbiAqIHJlbmFtZWQgYXMgbG9uZyBhcyB0aGUgcmVuYW1lIGlzIHRyaWdnZXJlZCBmcm9tIHdpdGhpbiB0aGUgY2xpZW50LlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIFdpbGxSZW5hbWVGaWxlc1JlcXVlc3Q7XG4oZnVuY3Rpb24gKFdpbGxSZW5hbWVGaWxlc1JlcXVlc3QpIHtcbiAgICBXaWxsUmVuYW1lRmlsZXNSZXF1ZXN0Lm1ldGhvZCA9ICd3b3Jrc3BhY2Uvd2lsbFJlbmFtZUZpbGVzJztcbiAgICBXaWxsUmVuYW1lRmlsZXNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgV2lsbFJlbmFtZUZpbGVzUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShXaWxsUmVuYW1lRmlsZXNSZXF1ZXN0Lm1ldGhvZCk7XG59KShXaWxsUmVuYW1lRmlsZXNSZXF1ZXN0ID0gZXhwb3J0cy5XaWxsUmVuYW1lRmlsZXNSZXF1ZXN0IHx8IChleHBvcnRzLldpbGxSZW5hbWVGaWxlc1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBUaGUgZGlkIHJlbmFtZSBmaWxlcyBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB3aGVuXG4gKiBmaWxlcyB3ZXJlIHJlbmFtZWQgZnJvbSB3aXRoaW4gdGhlIGNsaWVudC5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBEaWRSZW5hbWVGaWxlc05vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb24pIHtcbiAgICBEaWRSZW5hbWVGaWxlc05vdGlmaWNhdGlvbi5tZXRob2QgPSAnd29ya3NwYWNlL2RpZFJlbmFtZUZpbGVzJztcbiAgICBEaWRSZW5hbWVGaWxlc05vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZFJlbmFtZUZpbGVzTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKERpZFJlbmFtZUZpbGVzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRSZW5hbWVGaWxlc05vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5EaWRSZW5hbWVGaWxlc05vdGlmaWNhdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSB3aWxsIGRlbGV0ZSBmaWxlcyByZXF1ZXN0IGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgYmVmb3JlIGZpbGVzIGFyZSBhY3R1YWxseVxuICogZGVsZXRlZCBhcyBsb25nIGFzIHRoZSBkZWxldGlvbiBpcyB0cmlnZ2VyZWQgZnJvbSB3aXRoaW4gdGhlIGNsaWVudC5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBEaWREZWxldGVGaWxlc05vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoRGlkRGVsZXRlRmlsZXNOb3RpZmljYXRpb24pIHtcbiAgICBEaWREZWxldGVGaWxlc05vdGlmaWNhdGlvbi5tZXRob2QgPSAnd29ya3NwYWNlL2RpZERlbGV0ZUZpbGVzJztcbiAgICBEaWREZWxldGVGaWxlc05vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkRGVsZXRlRmlsZXNOb3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKERpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWREZWxldGVGaWxlc05vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5EaWREZWxldGVGaWxlc05vdGlmaWNhdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBkaWQgZGVsZXRlIGZpbGVzIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHdoZW5cbiAqIGZpbGVzIHdlcmUgZGVsZXRlZCBmcm9tIHdpdGhpbiB0aGUgY2xpZW50LlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIFdpbGxEZWxldGVGaWxlc1JlcXVlc3Q7XG4oZnVuY3Rpb24gKFdpbGxEZWxldGVGaWxlc1JlcXVlc3QpIHtcbiAgICBXaWxsRGVsZXRlRmlsZXNSZXF1ZXN0Lm1ldGhvZCA9ICd3b3Jrc3BhY2Uvd2lsbERlbGV0ZUZpbGVzJztcbiAgICBXaWxsRGVsZXRlRmlsZXNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgV2lsbERlbGV0ZUZpbGVzUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShXaWxsRGVsZXRlRmlsZXNSZXF1ZXN0Lm1ldGhvZCk7XG59KShXaWxsRGVsZXRlRmlsZXNSZXF1ZXN0ID0gZXhwb3J0cy5XaWxsRGVsZXRlRmlsZXNSZXF1ZXN0IHx8IChleHBvcnRzLldpbGxEZWxldGVGaWxlc1JlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxMjAzOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuRm9sZGluZ1JhbmdlUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcHJvdmlkZSBmb2xkaW5nIHJhbmdlcyBpbiBhIGRvY3VtZW50LiBUaGUgcmVxdWVzdCdzXG4gKiBwYXJhbWV0ZXIgaXMgb2YgdHlwZSB7QGxpbmsgRm9sZGluZ1JhbmdlUGFyYW1zfSwgdGhlXG4gKiByZXNwb25zZSBpcyBvZiB0eXBlIHtAbGluayBGb2xkaW5nUmFuZ2VMaXN0fSBvciBhIFRoZW5hYmxlXG4gKiB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBGb2xkaW5nUmFuZ2VSZXF1ZXN0O1xuKGZ1bmN0aW9uIChGb2xkaW5nUmFuZ2VSZXF1ZXN0KSB7XG4gICAgRm9sZGluZ1JhbmdlUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2ZvbGRpbmdSYW5nZSc7XG4gICAgRm9sZGluZ1JhbmdlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIEZvbGRpbmdSYW5nZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRm9sZGluZ1JhbmdlUmVxdWVzdC5tZXRob2QpO1xufSkoRm9sZGluZ1JhbmdlUmVxdWVzdCA9IGV4cG9ydHMuRm9sZGluZ1JhbmdlUmVxdWVzdCB8fCAoZXhwb3J0cy5Gb2xkaW5nUmFuZ2VSZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzI4Nzpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5JbXBsZW1lbnRhdGlvblJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8vIEB0cy1pZ25vcmU6IHRvIGF2b2lkIGlubGluaW5nIExvY2F0aW9uTGluayBhcyBkeW5hbWljIGltcG9ydFxubGV0IF9fbm9EeW5hbWljSW1wb3J0O1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVzb2x2ZSB0aGUgaW1wbGVtZW50YXRpb24gbG9jYXRpb25zIG9mIGEgc3ltYm9sIGF0IGEgZ2l2ZW4gdGV4dFxuICogZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mIHR5cGUgW1RleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zXVxuICogKCNUZXh0RG9jdW1lbnRQb3NpdGlvblBhcmFtcykgdGhlIHJlc3BvbnNlIGlzIG9mIHR5cGUge0BsaW5rIERlZmluaXRpb259IG9yIGFcbiAqIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqL1xudmFyIEltcGxlbWVudGF0aW9uUmVxdWVzdDtcbihmdW5jdGlvbiAoSW1wbGVtZW50YXRpb25SZXF1ZXN0KSB7XG4gICAgSW1wbGVtZW50YXRpb25SZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvaW1wbGVtZW50YXRpb24nO1xuICAgIEltcGxlbWVudGF0aW9uUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIEltcGxlbWVudGF0aW9uUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShJbXBsZW1lbnRhdGlvblJlcXVlc3QubWV0aG9kKTtcbn0pKEltcGxlbWVudGF0aW9uUmVxdWVzdCA9IGV4cG9ydHMuSW1wbGVtZW50YXRpb25SZXF1ZXN0IHx8IChleHBvcnRzLkltcGxlbWVudGF0aW9uUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkzODM6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5JbmxheUhpbnRSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3QgPSBleHBvcnRzLklubGF5SGludFJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHByb3ZpZGUgaW5sYXkgaGludHMgaW4gYSBkb2N1bWVudC4gVGhlIHJlcXVlc3QncyBwYXJhbWV0ZXIgaXMgb2ZcbiAqIHR5cGUge0BsaW5rIElubGF5SGludHNQYXJhbXN9LCB0aGUgcmVzcG9uc2UgaXMgb2YgdHlwZVxuICoge0BsaW5rIElubGF5SGludCBJbmxheUhpbnRbXX0gb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgSW5sYXlIaW50UmVxdWVzdDtcbihmdW5jdGlvbiAoSW5sYXlIaW50UmVxdWVzdCkge1xuICAgIElubGF5SGludFJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9pbmxheUhpbnQnO1xuICAgIElubGF5SGludFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBJbmxheUhpbnRSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKElubGF5SGludFJlcXVlc3QubWV0aG9kKTtcbn0pKElubGF5SGludFJlcXVlc3QgPSBleHBvcnRzLklubGF5SGludFJlcXVlc3QgfHwgKGV4cG9ydHMuSW5sYXlIaW50UmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIGFkZGl0aW9uYWwgcHJvcGVydGllcyBmb3IgYW4gaW5sYXkgaGludC5cbiAqIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mIHR5cGUge0BsaW5rIElubGF5SGludH0sIHRoZSByZXNwb25zZSBpc1xuICogb2YgdHlwZSB7QGxpbmsgSW5sYXlIaW50fSBvciBhIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBJbmxheUhpbnRSZXNvbHZlUmVxdWVzdDtcbihmdW5jdGlvbiAoSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3QpIHtcbiAgICBJbmxheUhpbnRSZXNvbHZlUmVxdWVzdC5tZXRob2QgPSAnaW5sYXlIaW50L3Jlc29sdmUnO1xuICAgIElubGF5SGludFJlc29sdmVSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3QubWV0aG9kKTtcbn0pKElubGF5SGludFJlc29sdmVSZXF1ZXN0ID0gZXhwb3J0cy5JbmxheUhpbnRSZXNvbHZlUmVxdWVzdCB8fCAoZXhwb3J0cy5JbmxheUhpbnRSZXNvbHZlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIElubGF5SGludFJlZnJlc2hSZXF1ZXN0O1xuKGZ1bmN0aW9uIChJbmxheUhpbnRSZWZyZXNoUmVxdWVzdCkge1xuICAgIElubGF5SGludFJlZnJlc2hSZXF1ZXN0Lm1ldGhvZCA9IGB3b3Jrc3BhY2UvaW5sYXlIaW50L3JlZnJlc2hgO1xuICAgIElubGF5SGludFJlZnJlc2hSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgSW5sYXlIaW50UmVmcmVzaFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUwKElubGF5SGludFJlZnJlc2hSZXF1ZXN0Lm1ldGhvZCk7XG59KShJbmxheUhpbnRSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuSW5sYXlIaW50UmVmcmVzaFJlcXVlc3QgfHwgKGV4cG9ydHMuSW5sYXlIaW50UmVmcmVzaFJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzNDkxOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuSW5saW5lVmFsdWVSZXF1ZXN0ID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODQzMSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBwcm92aWRlIGlubGluZSB2YWx1ZXMgaW4gYSBkb2N1bWVudC4gVGhlIHJlcXVlc3QncyBwYXJhbWV0ZXIgaXMgb2ZcbiAqIHR5cGUge0BsaW5rIElubGluZVZhbHVlUGFyYW1zfSwgdGhlIHJlc3BvbnNlIGlzIG9mIHR5cGVcbiAqIHtAbGluayBJbmxpbmVWYWx1ZSBJbmxpbmVWYWx1ZVtdfSBvciBhIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBJbmxpbmVWYWx1ZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKElubGluZVZhbHVlUmVxdWVzdCkge1xuICAgIElubGluZVZhbHVlUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2lubGluZVZhbHVlJztcbiAgICBJbmxpbmVWYWx1ZVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBJbmxpbmVWYWx1ZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoSW5saW5lVmFsdWVSZXF1ZXN0Lm1ldGhvZCk7XG59KShJbmxpbmVWYWx1ZVJlcXVlc3QgPSBleHBvcnRzLklubGluZVZhbHVlUmVxdWVzdCB8fCAoZXhwb3J0cy5JbmxpbmVWYWx1ZVJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBJbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0O1xuKGZ1bmN0aW9uIChJbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0KSB7XG4gICAgSW5saW5lVmFsdWVSZWZyZXNoUmVxdWVzdC5tZXRob2QgPSBgd29ya3NwYWNlL2lubGluZVZhbHVlL3JlZnJlc2hgO1xuICAgIElubGluZVZhbHVlUmVmcmVzaFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5zZXJ2ZXJUb0NsaWVudDtcbiAgICBJbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlMChJbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0Lm1ldGhvZCk7XG59KShJbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0ID0gZXhwb3J0cy5JbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0IHx8IChleHBvcnRzLklubGluZVZhbHVlUmVmcmVzaFJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxODE1OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLldvcmtzcGFjZVN5bWJvbFJlcXVlc3QgPSBleHBvcnRzLkNvZGVBY3Rpb25SZXNvbHZlUmVxdWVzdCA9IGV4cG9ydHMuQ29kZUFjdGlvblJlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50U3ltYm9sUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0ID0gZXhwb3J0cy5SZWZlcmVuY2VzUmVxdWVzdCA9IGV4cG9ydHMuRGVmaW5pdGlvblJlcXVlc3QgPSBleHBvcnRzLlNpZ25hdHVyZUhlbHBSZXF1ZXN0ID0gZXhwb3J0cy5TaWduYXR1cmVIZWxwVHJpZ2dlcktpbmQgPSBleHBvcnRzLkhvdmVyUmVxdWVzdCA9IGV4cG9ydHMuQ29tcGxldGlvblJlc29sdmVSZXF1ZXN0ID0gZXhwb3J0cy5Db21wbGV0aW9uUmVxdWVzdCA9IGV4cG9ydHMuQ29tcGxldGlvblRyaWdnZXJLaW5kID0gZXhwb3J0cy5QdWJsaXNoRGlhZ25vc3RpY3NOb3RpZmljYXRpb24gPSBleHBvcnRzLldhdGNoS2luZCA9IGV4cG9ydHMuUmVsYXRpdmVQYXR0ZXJuID0gZXhwb3J0cy5GaWxlQ2hhbmdlVHlwZSA9IGV4cG9ydHMuRGlkQ2hhbmdlV2F0Y2hlZEZpbGVzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5XaWxsU2F2ZVRleHREb2N1bWVudFdhaXRVbnRpbFJlcXVlc3QgPSBleHBvcnRzLldpbGxTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5UZXh0RG9jdW1lbnRTYXZlUmVhc29uID0gZXhwb3J0cy5EaWRTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRDbG9zZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkQ2hhbmdlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5UZXh0RG9jdW1lbnRDb250ZW50Q2hhbmdlRXZlbnQgPSBleHBvcnRzLkRpZE9wZW5UZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLlRleHREb2N1bWVudFN5bmNLaW5kID0gZXhwb3J0cy5UZWxlbWV0cnlFdmVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuTG9nTWVzc2FnZU5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuU2hvd01lc3NhZ2VSZXF1ZXN0ID0gZXhwb3J0cy5TaG93TWVzc2FnZU5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuTWVzc2FnZVR5cGUgPSBleHBvcnRzLkRpZENoYW5nZUNvbmZpZ3VyYXRpb25Ob3RpZmljYXRpb24gPSBleHBvcnRzLkV4aXROb3RpZmljYXRpb24gPSBleHBvcnRzLlNodXRkb3duUmVxdWVzdCA9IGV4cG9ydHMuSW5pdGlhbGl6ZWROb3RpZmljYXRpb24gPSBleHBvcnRzLkluaXRpYWxpemVFcnJvckNvZGVzID0gZXhwb3J0cy5Jbml0aWFsaXplUmVxdWVzdCA9IGV4cG9ydHMuV29ya0RvbmVQcm9ncmVzc09wdGlvbnMgPSBleHBvcnRzLlRleHREb2N1bWVudFJlZ2lzdHJhdGlvbk9wdGlvbnMgPSBleHBvcnRzLlN0YXRpY1JlZ2lzdHJhdGlvbk9wdGlvbnMgPSBleHBvcnRzLlBvc2l0aW9uRW5jb2RpbmdLaW5kID0gZXhwb3J0cy5GYWlsdXJlSGFuZGxpbmdLaW5kID0gZXhwb3J0cy5SZXNvdXJjZU9wZXJhdGlvbktpbmQgPSBleHBvcnRzLlVucmVnaXN0cmF0aW9uUmVxdWVzdCA9IGV4cG9ydHMuUmVnaXN0cmF0aW9uUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnRTZWxlY3RvciA9IGV4cG9ydHMuTm90ZWJvb2tDZWxsVGV4dERvY3VtZW50RmlsdGVyID0gZXhwb3J0cy5Ob3RlYm9va0RvY3VtZW50RmlsdGVyID0gZXhwb3J0cy5UZXh0RG9jdW1lbnRGaWx0ZXIgPSB2b2lkIDA7XG5leHBvcnRzLlR5cGVIaWVyYXJjaHlTdWJ0eXBlc1JlcXVlc3QgPSBleHBvcnRzLlR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCA9IGV4cG9ydHMuTW9uaWtlclJlcXVlc3QgPSBleHBvcnRzLk1vbmlrZXJLaW5kID0gZXhwb3J0cy5VbmlxdWVuZXNzTGV2ZWwgPSBleHBvcnRzLldpbGxEZWxldGVGaWxlc1JlcXVlc3QgPSBleHBvcnRzLkRpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5XaWxsUmVuYW1lRmlsZXNSZXF1ZXN0ID0gZXhwb3J0cy5EaWRSZW5hbWVGaWxlc05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuV2lsbENyZWF0ZUZpbGVzUmVxdWVzdCA9IGV4cG9ydHMuRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb24gPSBleHBvcnRzLkZpbGVPcGVyYXRpb25QYXR0ZXJuS2luZCA9IGV4cG9ydHMuTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdCA9IGV4cG9ydHMuU2hvd0RvY3VtZW50UmVxdWVzdCA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlID0gZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JlZnJlc2hSZXF1ZXN0ID0gZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdCA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3QgPSBleHBvcnRzLlNlbWFudGljVG9rZW5zUmVxdWVzdCA9IGV4cG9ydHMuVG9rZW5Gb3JtYXQgPSBleHBvcnRzLkNhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCA9IGV4cG9ydHMuQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0ID0gZXhwb3J0cy5DYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3QgPSBleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NDYW5jZWxOb3RpZmljYXRpb24gPSBleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0ID0gZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzID0gZXhwb3J0cy5TZWxlY3Rpb25SYW5nZVJlcXVlc3QgPSBleHBvcnRzLkRlY2xhcmF0aW9uUmVxdWVzdCA9IGV4cG9ydHMuRm9sZGluZ1JhbmdlUmVxdWVzdCA9IGV4cG9ydHMuQ29sb3JQcmVzZW50YXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudENvbG9yUmVxdWVzdCA9IGV4cG9ydHMuQ29uZmlndXJhdGlvblJlcXVlc3QgPSBleHBvcnRzLkRpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb24gPSBleHBvcnRzLldvcmtzcGFjZUZvbGRlcnNSZXF1ZXN0ID0gZXhwb3J0cy5UeXBlRGVmaW5pdGlvblJlcXVlc3QgPSBleHBvcnRzLkltcGxlbWVudGF0aW9uUmVxdWVzdCA9IGV4cG9ydHMuQXBwbHlXb3Jrc3BhY2VFZGl0UmVxdWVzdCA9IGV4cG9ydHMuRXhlY3V0ZUNvbW1hbmRSZXF1ZXN0ID0gZXhwb3J0cy5QcmVwYXJlUmVuYW1lUmVxdWVzdCA9IGV4cG9ydHMuUmVuYW1lUmVxdWVzdCA9IGV4cG9ydHMuUHJlcGFyZVN1cHBvcnREZWZhdWx0QmVoYXZpb3IgPSBleHBvcnRzLkRvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnRGb3JtYXR0aW5nUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnRMaW5rUmVzb2x2ZVJlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50TGlua1JlcXVlc3QgPSBleHBvcnRzLkNvZGVMZW5zUmVmcmVzaFJlcXVlc3QgPSBleHBvcnRzLkNvZGVMZW5zUmVzb2x2ZVJlcXVlc3QgPSBleHBvcnRzLkNvZGVMZW5zUmVxdWVzdCA9IGV4cG9ydHMuV29ya3NwYWNlU3ltYm9sUmVzb2x2ZVJlcXVlc3QgPSB2b2lkIDA7XG5leHBvcnRzLkRpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkU2F2ZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLk5vdGVib29rQ2VsbEFycmF5Q2hhbmdlID0gZXhwb3J0cy5EaWRPcGVuTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlID0gZXhwb3J0cy5Ob3RlYm9va0RvY3VtZW50ID0gZXhwb3J0cy5Ob3RlYm9va0NlbGwgPSBleHBvcnRzLkV4ZWN1dGlvblN1bW1hcnkgPSBleHBvcnRzLk5vdGVib29rQ2VsbEtpbmQgPSBleHBvcnRzLkRpYWdub3N0aWNSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuV29ya3NwYWNlRGlhZ25vc3RpY1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50RGlhZ25vc3RpY1JlcG9ydEtpbmQgPSBleHBvcnRzLkRpYWdub3N0aWNTZXJ2ZXJDYW5jZWxsYXRpb25EYXRhID0gZXhwb3J0cy5JbmxheUhpbnRSZWZyZXNoUmVxdWVzdCA9IGV4cG9ydHMuSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3QgPSBleHBvcnRzLklubGF5SGludFJlcXVlc3QgPSBleHBvcnRzLklubGluZVZhbHVlUmVmcmVzaFJlcXVlc3QgPSBleHBvcnRzLklubGluZVZhbHVlUmVxdWVzdCA9IGV4cG9ydHMuVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0ID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODQzMSk7XG5jb25zdCB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfdHlwZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNzcxNyk7XG5jb25zdCBJcyA9IF9fd2VicGFja19yZXF1aXJlX18oODYzMyk7XG5jb25zdCBwcm90b2NvbF9pbXBsZW1lbnRhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Mjg3KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkltcGxlbWVudGF0aW9uUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2ltcGxlbWVudGF0aW9uXzEuSW1wbGVtZW50YXRpb25SZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX3R5cGVEZWZpbml0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyNjQpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHlwZURlZmluaXRpb25SZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfdHlwZURlZmluaXRpb25fMS5UeXBlRGVmaW5pdGlvblJlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfd29ya3NwYWNlRm9sZGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4NjApO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV29ya3NwYWNlRm9sZGVyc1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF93b3Jrc3BhY2VGb2xkZXJfMS5Xb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfd29ya3NwYWNlRm9sZGVyXzEuRGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVyc05vdGlmaWNhdGlvbjsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF9jb25maWd1cmF0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2MzkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29uZmlndXJhdGlvblJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9jb25maWd1cmF0aW9uXzEuQ29uZmlndXJhdGlvblJlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfY29sb3JQcm92aWRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNzQ3KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRvY3VtZW50Q29sb3JSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfY29sb3JQcm92aWRlcl8xLkRvY3VtZW50Q29sb3JSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbG9yUHJlc2VudGF0aW9uUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2NvbG9yUHJvdmlkZXJfMS5Db2xvclByZXNlbnRhdGlvblJlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfZm9sZGluZ1JhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyMDMpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRm9sZGluZ1JhbmdlUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2ZvbGRpbmdSYW5nZV8xLkZvbGRpbmdSYW5nZVJlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfZGVjbGFyYXRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTU4MSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEZWNsYXJhdGlvblJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9kZWNsYXJhdGlvbl8xLkRlY2xhcmF0aW9uUmVxdWVzdDsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF9zZWxlY3Rpb25SYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTMwKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlbGVjdGlvblJhbmdlUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3NlbGVjdGlvblJhbmdlXzEuU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX3Byb2dyZXNzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxNjYpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV29ya0RvbmVQcm9ncmVzc1wiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3Byb2dyZXNzXzEuV29ya0RvbmVQcm9ncmVzczsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXb3JrRG9uZVByb2dyZXNzQ3JlYXRlUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3Byb2dyZXNzXzEuV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvblwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3Byb2dyZXNzXzEuV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvbjsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF9jYWxsSGllcmFyY2h5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2MDIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FsbEhpZXJhcmNoeUluY29taW5nQ2FsbHNSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfY2FsbEhpZXJhcmNoeV8xLkNhbGxIaWVyYXJjaHlJbmNvbWluZ0NhbGxzUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYWxsSGllcmFyY2h5T3V0Z29pbmdDYWxsc1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9jYWxsSGllcmFyY2h5XzEuQ2FsbEhpZXJhcmNoeU91dGdvaW5nQ2FsbHNSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhbGxIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2NhbGxIaWVyYXJjaHlfMS5DYWxsSGllcmFyY2h5UHJlcGFyZVJlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfc2VtYW50aWNUb2tlbnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjA2Nyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUb2tlbkZvcm1hdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3NlbWFudGljVG9rZW5zXzEuVG9rZW5Gb3JtYXQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2VtYW50aWNUb2tlbnNSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfc2VtYW50aWNUb2tlbnNfMS5TZW1hbnRpY1Rva2Vuc1JlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9zZW1hbnRpY1Rva2Vuc18xLlNlbWFudGljVG9rZW5zRGVsdGFSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlbWFudGljVG9rZW5zUmFuZ2VSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfc2VtYW50aWNUb2tlbnNfMS5TZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTZW1hbnRpY1Rva2Vuc1JlZnJlc2hSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfc2VtYW50aWNUb2tlbnNfMS5TZW1hbnRpY1Rva2Vuc1JlZnJlc2hSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZVwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3NlbWFudGljVG9rZW5zXzEuU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlOyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX3Nob3dEb2N1bWVudF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MzMzKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNob3dEb2N1bWVudFJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9zaG93RG9jdW1lbnRfMS5TaG93RG9jdW1lbnRSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX2xpbmtlZEVkaXRpbmdSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMjQ5KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxpbmtlZEVkaXRpbmdSYW5nZVJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9saW5rZWRFZGl0aW5nUmFuZ2VfMS5MaW5rZWRFZGl0aW5nUmFuZ2VSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX2ZpbGVPcGVyYXRpb25zXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3ODEpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmlsZU9wZXJhdGlvblBhdHRlcm5LaW5kXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfZmlsZU9wZXJhdGlvbnNfMS5GaWxlT3BlcmF0aW9uUGF0dGVybktpbmQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlkQ3JlYXRlRmlsZXNOb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLkRpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldpbGxDcmVhdGVGaWxlc1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLldpbGxDcmVhdGVGaWxlc1JlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlkUmVuYW1lRmlsZXNOb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLkRpZFJlbmFtZUZpbGVzTm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldpbGxSZW5hbWVGaWxlc1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLldpbGxSZW5hbWVGaWxlc1JlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlkRGVsZXRlRmlsZXNOb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLkRpZERlbGV0ZUZpbGVzTm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldpbGxEZWxldGVGaWxlc1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9maWxlT3BlcmF0aW9uc18xLldpbGxEZWxldGVGaWxlc1JlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfbW9uaWtlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Njg0KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVuaXF1ZW5lc3NMZXZlbFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX21vbmlrZXJfMS5VbmlxdWVuZXNzTGV2ZWw7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTW9uaWtlcktpbmRcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9tb25pa2VyXzEuTW9uaWtlcktpbmQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTW9uaWtlclJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9tb25pa2VyXzEuTW9uaWtlclJlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfdHlwZUhpZXJhcmNoeV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MDYyKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3R5cGVIaWVyYXJjaHlfMS5UeXBlSGllcmFyY2h5UHJlcGFyZVJlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHlwZUhpZXJhcmNoeVN1YnR5cGVzUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3R5cGVIaWVyYXJjaHlfMS5UeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlR5cGVIaWVyYXJjaHlTdXBlcnR5cGVzUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX3R5cGVIaWVyYXJjaHlfMS5UeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3Q7IH0gfSkpO1xuY29uc3QgcHJvdG9jb2xfaW5saW5lVmFsdWVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzQ5MSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbmxpbmVWYWx1ZVJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9pbmxpbmVWYWx1ZV8xLklubGluZVZhbHVlUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfaW5saW5lVmFsdWVfMS5JbmxpbmVWYWx1ZVJlZnJlc2hSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX2lubGF5SGludF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MzgzKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIklubGF5SGludFJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9pbmxheUhpbnRfMS5JbmxheUhpbnRSZXF1ZXN0OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIklubGF5SGludFJlc29sdmVSZXF1ZXN0XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfaW5sYXlIaW50XzEuSW5sYXlIaW50UmVzb2x2ZVJlcXVlc3Q7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW5sYXlIaW50UmVmcmVzaFJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9pbmxheUhpbnRfMS5JbmxheUhpbnRSZWZyZXNoUmVxdWVzdDsgfSB9KSk7XG5jb25zdCBwcm90b2NvbF9kaWFnbm9zdGljXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0OTQpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlhZ25vc3RpY1NlcnZlckNhbmNlbGxhdGlvbkRhdGFcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9kaWFnbm9zdGljXzEuRGlhZ25vc3RpY1NlcnZlckNhbmNlbGxhdGlvbkRhdGE7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRG9jdW1lbnREaWFnbm9zdGljUmVwb3J0S2luZFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2RpYWdub3N0aWNfMS5Eb2N1bWVudERpYWdub3N0aWNSZXBvcnRLaW5kOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRvY3VtZW50RGlhZ25vc3RpY1JlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9kaWFnbm9zdGljXzEuRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX2RpYWdub3N0aWNfMS5Xb3Jrc3BhY2VEaWFnbm9zdGljUmVxdWVzdDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEaWFnbm9zdGljUmVmcmVzaFJlcXVlc3RcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9kaWFnbm9zdGljXzEuRGlhZ25vc3RpY1JlZnJlc2hSZXF1ZXN0OyB9IH0pKTtcbmNvbnN0IHByb3RvY29sX25vdGVib29rXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3OTIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90ZWJvb2tDZWxsS2luZFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX25vdGVib29rXzEuTm90ZWJvb2tDZWxsS2luZDsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFeGVjdXRpb25TdW1tYXJ5XCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5FeGVjdXRpb25TdW1tYXJ5OyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGVib29rQ2VsbFwiLCAoeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb3RvY29sX25vdGVib29rXzEuTm90ZWJvb2tDZWxsOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGVib29rRG9jdW1lbnRcIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9ub3RlYm9va18xLk5vdGVib29rRG9jdW1lbnQ7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5Ob3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGU7IH0gfSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9ub3RlYm9va18xLkRpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vdGVib29rQ2VsbEFycmF5Q2hhbmdlXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5Ob3RlYm9va0NlbGxBcnJheUNoYW5nZTsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5EaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uOyB9IH0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRpZFNhdmVOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uXCIsICh7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfbm90ZWJvb2tfMS5EaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbjsgfSB9KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEaWRDbG9zZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb25cIiwgKHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF9ub3RlYm9va18xLkRpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbjsgfSB9KSk7XG4vLyBAdHMtaWdub3JlOiB0byBhdm9pZCBpbmxpbmluZyBMb2NhdGlvbkxpbmsgYXMgZHluYW1pYyBpbXBvcnRcbmxldCBfX25vRHluYW1pY0ltcG9ydDtcbi8qKlxuICogVGhlIFRleHREb2N1bWVudEZpbHRlciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBUZXh0RG9jdW1lbnRGaWx0ZXJ9IGxpdGVyYWxzLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIFRleHREb2N1bWVudEZpbHRlcjtcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50RmlsdGVyKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5zdHJpbmcoY2FuZGlkYXRlLmxhbmd1YWdlKSB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLnNjaGVtZSkgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5wYXR0ZXJuKTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50RmlsdGVyLmlzID0gaXM7XG59KShUZXh0RG9jdW1lbnRGaWx0ZXIgPSBleHBvcnRzLlRleHREb2N1bWVudEZpbHRlciB8fCAoZXhwb3J0cy5UZXh0RG9jdW1lbnRGaWx0ZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgTm90ZWJvb2tEb2N1bWVudEZpbHRlciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBOb3RlYm9va0RvY3VtZW50RmlsdGVyfSBsaXRlcmFscy5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBOb3RlYm9va0RvY3VtZW50RmlsdGVyO1xuKGZ1bmN0aW9uIChOb3RlYm9va0RvY3VtZW50RmlsdGVyKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgKElzLnN0cmluZyhjYW5kaWRhdGUubm90ZWJvb2tUeXBlKSB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLnNjaGVtZSkgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5wYXR0ZXJuKSk7XG4gICAgfVxuICAgIE5vdGVib29rRG9jdW1lbnRGaWx0ZXIuaXMgPSBpcztcbn0pKE5vdGVib29rRG9jdW1lbnRGaWx0ZXIgPSBleHBvcnRzLk5vdGVib29rRG9jdW1lbnRGaWx0ZXIgfHwgKGV4cG9ydHMuTm90ZWJvb2tEb2N1bWVudEZpbHRlciA9IHt9KSk7XG4vKipcbiAqIFRoZSBOb3RlYm9va0NlbGxUZXh0RG9jdW1lbnRGaWx0ZXIgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgTm90ZWJvb2tDZWxsVGV4dERvY3VtZW50RmlsdGVyfSBsaXRlcmFscy5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBOb3RlYm9va0NlbGxUZXh0RG9jdW1lbnRGaWx0ZXI7XG4oZnVuY3Rpb24gKE5vdGVib29rQ2VsbFRleHREb2N1bWVudEZpbHRlcikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpXG4gICAgICAgICAgICAmJiAoSXMuc3RyaW5nKGNhbmRpZGF0ZS5ub3RlYm9vaykgfHwgTm90ZWJvb2tEb2N1bWVudEZpbHRlci5pcyhjYW5kaWRhdGUubm90ZWJvb2spKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS5sYW5ndWFnZSA9PT0gdW5kZWZpbmVkIHx8IElzLnN0cmluZyhjYW5kaWRhdGUubGFuZ3VhZ2UpKTtcbiAgICB9XG4gICAgTm90ZWJvb2tDZWxsVGV4dERvY3VtZW50RmlsdGVyLmlzID0gaXM7XG59KShOb3RlYm9va0NlbGxUZXh0RG9jdW1lbnRGaWx0ZXIgPSBleHBvcnRzLk5vdGVib29rQ2VsbFRleHREb2N1bWVudEZpbHRlciB8fCAoZXhwb3J0cy5Ob3RlYm9va0NlbGxUZXh0RG9jdW1lbnRGaWx0ZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgRG9jdW1lbnRTZWxlY3RvciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBEb2N1bWVudFNlbGVjdG9yfXMuXG4gKi9cbnZhciBEb2N1bWVudFNlbGVjdG9yO1xuKGZ1bmN0aW9uIChEb2N1bWVudFNlbGVjdG9yKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGVsZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghSXMuc3RyaW5nKGVsZW0pICYmICFUZXh0RG9jdW1lbnRGaWx0ZXIuaXMoZWxlbSkgJiYgIU5vdGVib29rQ2VsbFRleHREb2N1bWVudEZpbHRlci5pcyhlbGVtKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgRG9jdW1lbnRTZWxlY3Rvci5pcyA9IGlzO1xufSkoRG9jdW1lbnRTZWxlY3RvciA9IGV4cG9ydHMuRG9jdW1lbnRTZWxlY3RvciB8fCAoZXhwb3J0cy5Eb2N1bWVudFNlbGVjdG9yID0ge30pKTtcbi8qKlxuICogVGhlIGBjbGllbnQvcmVnaXN0ZXJDYXBhYmlsaXR5YCByZXF1ZXN0IGlzIHNlbnQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQgdG8gcmVnaXN0ZXIgYSBuZXcgY2FwYWJpbGl0eVxuICogaGFuZGxlciBvbiB0aGUgY2xpZW50IHNpZGUuXG4gKi9cbnZhciBSZWdpc3RyYXRpb25SZXF1ZXN0O1xuKGZ1bmN0aW9uIChSZWdpc3RyYXRpb25SZXF1ZXN0KSB7XG4gICAgUmVnaXN0cmF0aW9uUmVxdWVzdC5tZXRob2QgPSAnY2xpZW50L3JlZ2lzdGVyQ2FwYWJpbGl0eSc7XG4gICAgUmVnaXN0cmF0aW9uUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIFJlZ2lzdHJhdGlvblJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoUmVnaXN0cmF0aW9uUmVxdWVzdC5tZXRob2QpO1xufSkoUmVnaXN0cmF0aW9uUmVxdWVzdCA9IGV4cG9ydHMuUmVnaXN0cmF0aW9uUmVxdWVzdCB8fCAoZXhwb3J0cy5SZWdpc3RyYXRpb25SZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogVGhlIGBjbGllbnQvdW5yZWdpc3RlckNhcGFiaWxpdHlgIHJlcXVlc3QgaXMgc2VudCBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudCB0byB1bnJlZ2lzdGVyIGEgcHJldmlvdXNseSByZWdpc3RlcmVkIGNhcGFiaWxpdHlcbiAqIGhhbmRsZXIgb24gdGhlIGNsaWVudCBzaWRlLlxuICovXG52YXIgVW5yZWdpc3RyYXRpb25SZXF1ZXN0O1xuKGZ1bmN0aW9uIChVbnJlZ2lzdHJhdGlvblJlcXVlc3QpIHtcbiAgICBVbnJlZ2lzdHJhdGlvblJlcXVlc3QubWV0aG9kID0gJ2NsaWVudC91bnJlZ2lzdGVyQ2FwYWJpbGl0eSc7XG4gICAgVW5yZWdpc3RyYXRpb25SZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgVW5yZWdpc3RyYXRpb25SZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFVucmVnaXN0cmF0aW9uUmVxdWVzdC5tZXRob2QpO1xufSkoVW5yZWdpc3RyYXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5VbnJlZ2lzdHJhdGlvblJlcXVlc3QgfHwgKGV4cG9ydHMuVW5yZWdpc3RyYXRpb25SZXF1ZXN0ID0ge30pKTtcbnZhciBSZXNvdXJjZU9wZXJhdGlvbktpbmQ7XG4oZnVuY3Rpb24gKFJlc291cmNlT3BlcmF0aW9uS2luZCkge1xuICAgIC8qKlxuICAgICAqIFN1cHBvcnRzIGNyZWF0aW5nIG5ldyBmaWxlcyBhbmQgZm9sZGVycy5cbiAgICAgKi9cbiAgICBSZXNvdXJjZU9wZXJhdGlvbktpbmQuQ3JlYXRlID0gJ2NyZWF0ZSc7XG4gICAgLyoqXG4gICAgICogU3VwcG9ydHMgcmVuYW1pbmcgZXhpc3RpbmcgZmlsZXMgYW5kIGZvbGRlcnMuXG4gICAgICovXG4gICAgUmVzb3VyY2VPcGVyYXRpb25LaW5kLlJlbmFtZSA9ICdyZW5hbWUnO1xuICAgIC8qKlxuICAgICAqIFN1cHBvcnRzIGRlbGV0aW5nIGV4aXN0aW5nIGZpbGVzIGFuZCBmb2xkZXJzLlxuICAgICAqL1xuICAgIFJlc291cmNlT3BlcmF0aW9uS2luZC5EZWxldGUgPSAnZGVsZXRlJztcbn0pKFJlc291cmNlT3BlcmF0aW9uS2luZCA9IGV4cG9ydHMuUmVzb3VyY2VPcGVyYXRpb25LaW5kIHx8IChleHBvcnRzLlJlc291cmNlT3BlcmF0aW9uS2luZCA9IHt9KSk7XG52YXIgRmFpbHVyZUhhbmRsaW5nS2luZDtcbihmdW5jdGlvbiAoRmFpbHVyZUhhbmRsaW5nS2luZCkge1xuICAgIC8qKlxuICAgICAqIEFwcGx5aW5nIHRoZSB3b3Jrc3BhY2UgY2hhbmdlIGlzIHNpbXBseSBhYm9ydGVkIGlmIG9uZSBvZiB0aGUgY2hhbmdlcyBwcm92aWRlZFxuICAgICAqIGZhaWxzLiBBbGwgb3BlcmF0aW9ucyBleGVjdXRlZCBiZWZvcmUgdGhlIGZhaWxpbmcgb3BlcmF0aW9uIHN0YXkgZXhlY3V0ZWQuXG4gICAgICovXG4gICAgRmFpbHVyZUhhbmRsaW5nS2luZC5BYm9ydCA9ICdhYm9ydCc7XG4gICAgLyoqXG4gICAgICogQWxsIG9wZXJhdGlvbnMgYXJlIGV4ZWN1dGVkIHRyYW5zYWN0aW9uYWwuIFRoYXQgbWVhbnMgdGhleSBlaXRoZXIgYWxsXG4gICAgICogc3VjY2VlZCBvciBubyBjaGFuZ2VzIGF0IGFsbCBhcmUgYXBwbGllZCB0byB0aGUgd29ya3NwYWNlLlxuICAgICAqL1xuICAgIEZhaWx1cmVIYW5kbGluZ0tpbmQuVHJhbnNhY3Rpb25hbCA9ICd0cmFuc2FjdGlvbmFsJztcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgd29ya3NwYWNlIGVkaXQgY29udGFpbnMgb25seSB0ZXh0dWFsIGZpbGUgY2hhbmdlcyB0aGV5IGFyZSBleGVjdXRlZCB0cmFuc2FjdGlvbmFsLlxuICAgICAqIElmIHJlc291cmNlIGNoYW5nZXMgKGNyZWF0ZSwgcmVuYW1lIG9yIGRlbGV0ZSBmaWxlKSBhcmUgcGFydCBvZiB0aGUgY2hhbmdlIHRoZSBmYWlsdXJlXG4gICAgICogaGFuZGxpbmcgc3RyYXRlZ3kgaXMgYWJvcnQuXG4gICAgICovXG4gICAgRmFpbHVyZUhhbmRsaW5nS2luZC5UZXh0T25seVRyYW5zYWN0aW9uYWwgPSAndGV4dE9ubHlUcmFuc2FjdGlvbmFsJztcbiAgICAvKipcbiAgICAgKiBUaGUgY2xpZW50IHRyaWVzIHRvIHVuZG8gdGhlIG9wZXJhdGlvbnMgYWxyZWFkeSBleGVjdXRlZC4gQnV0IHRoZXJlIGlzIG5vXG4gICAgICogZ3VhcmFudGVlIHRoYXQgdGhpcyBpcyBzdWNjZWVkaW5nLlxuICAgICAqL1xuICAgIEZhaWx1cmVIYW5kbGluZ0tpbmQuVW5kbyA9ICd1bmRvJztcbn0pKEZhaWx1cmVIYW5kbGluZ0tpbmQgPSBleHBvcnRzLkZhaWx1cmVIYW5kbGluZ0tpbmQgfHwgKGV4cG9ydHMuRmFpbHVyZUhhbmRsaW5nS2luZCA9IHt9KSk7XG4vKipcbiAqIEEgc2V0IG9mIHByZWRlZmluZWQgcG9zaXRpb24gZW5jb2Rpbmcga2luZHMuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgUG9zaXRpb25FbmNvZGluZ0tpbmQ7XG4oZnVuY3Rpb24gKFBvc2l0aW9uRW5jb2RpbmdLaW5kKSB7XG4gICAgLyoqXG4gICAgICogQ2hhcmFjdGVyIG9mZnNldHMgY291bnQgVVRGLTggY29kZSB1bml0cyAoZS5nLiBieXRlcykuXG4gICAgICovXG4gICAgUG9zaXRpb25FbmNvZGluZ0tpbmQuVVRGOCA9ICd1dGYtOCc7XG4gICAgLyoqXG4gICAgICogQ2hhcmFjdGVyIG9mZnNldHMgY291bnQgVVRGLTE2IGNvZGUgdW5pdHMuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHRoZSBkZWZhdWx0IGFuZCBtdXN0IGFsd2F5cyBiZSBzdXBwb3J0ZWRcbiAgICAgKiBieSBzZXJ2ZXJzXG4gICAgICovXG4gICAgUG9zaXRpb25FbmNvZGluZ0tpbmQuVVRGMTYgPSAndXRmLTE2JztcbiAgICAvKipcbiAgICAgKiBDaGFyYWN0ZXIgb2Zmc2V0cyBjb3VudCBVVEYtMzIgY29kZSB1bml0cy5cbiAgICAgKlxuICAgICAqIEltcGxlbWVudGF0aW9uIG5vdGU6IHRoZXNlIGFyZSB0aGUgc2FtZSBhcyBVbmljb2RlIGNvZGVwb2ludHMsXG4gICAgICogc28gdGhpcyBgUG9zaXRpb25FbmNvZGluZ0tpbmRgIG1heSBhbHNvIGJlIHVzZWQgZm9yIGFuXG4gICAgICogZW5jb2RpbmctYWdub3N0aWMgcmVwcmVzZW50YXRpb24gb2YgY2hhcmFjdGVyIG9mZnNldHMuXG4gICAgICovXG4gICAgUG9zaXRpb25FbmNvZGluZ0tpbmQuVVRGMzIgPSAndXRmLTMyJztcbn0pKFBvc2l0aW9uRW5jb2RpbmdLaW5kID0gZXhwb3J0cy5Qb3NpdGlvbkVuY29kaW5nS2luZCB8fCAoZXhwb3J0cy5Qb3NpdGlvbkVuY29kaW5nS2luZCA9IHt9KSk7XG4vKipcbiAqIFRoZSBTdGF0aWNSZWdpc3RyYXRpb25PcHRpb25zIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIFN0YXRpY1JlZ2lzdHJhdGlvbk9wdGlvbnN9IGxpdGVyYWxzLlxuICovXG52YXIgU3RhdGljUmVnaXN0cmF0aW9uT3B0aW9ucztcbihmdW5jdGlvbiAoU3RhdGljUmVnaXN0cmF0aW9uT3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIGhhc0lkKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIElzLnN0cmluZyhjYW5kaWRhdGUuaWQpICYmIGNhbmRpZGF0ZS5pZC5sZW5ndGggPiAwO1xuICAgIH1cbiAgICBTdGF0aWNSZWdpc3RyYXRpb25PcHRpb25zLmhhc0lkID0gaGFzSWQ7XG59KShTdGF0aWNSZWdpc3RyYXRpb25PcHRpb25zID0gZXhwb3J0cy5TdGF0aWNSZWdpc3RyYXRpb25PcHRpb25zIHx8IChleHBvcnRzLlN0YXRpY1JlZ2lzdHJhdGlvbk9wdGlvbnMgPSB7fSkpO1xuLyoqXG4gKiBUaGUgVGV4dERvY3VtZW50UmVnaXN0cmF0aW9uT3B0aW9ucyBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBUZXh0RG9jdW1lbnRSZWdpc3RyYXRpb25PcHRpb25zfSBsaXRlcmFscy5cbiAqL1xudmFyIFRleHREb2N1bWVudFJlZ2lzdHJhdGlvbk9wdGlvbnM7XG4oZnVuY3Rpb24gKFRleHREb2N1bWVudFJlZ2lzdHJhdGlvbk9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiAoY2FuZGlkYXRlLmRvY3VtZW50U2VsZWN0b3IgPT09IG51bGwgfHwgRG9jdW1lbnRTZWxlY3Rvci5pcyhjYW5kaWRhdGUuZG9jdW1lbnRTZWxlY3RvcikpO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnRSZWdpc3RyYXRpb25PcHRpb25zLmlzID0gaXM7XG59KShUZXh0RG9jdW1lbnRSZWdpc3RyYXRpb25PcHRpb25zID0gZXhwb3J0cy5UZXh0RG9jdW1lbnRSZWdpc3RyYXRpb25PcHRpb25zIHx8IChleHBvcnRzLlRleHREb2N1bWVudFJlZ2lzdHJhdGlvbk9wdGlvbnMgPSB7fSkpO1xuLyoqXG4gKiBUaGUgV29ya0RvbmVQcm9ncmVzc09wdGlvbnMgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgV29ya0RvbmVQcm9ncmVzc09wdGlvbnN9IGxpdGVyYWxzLlxuICovXG52YXIgV29ya0RvbmVQcm9ncmVzc09wdGlvbnM7XG4oZnVuY3Rpb24gKFdvcmtEb25lUHJvZ3Jlc3NPcHRpb25zKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgKGNhbmRpZGF0ZS53b3JrRG9uZVByb2dyZXNzID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUud29ya0RvbmVQcm9ncmVzcykpO1xuICAgIH1cbiAgICBXb3JrRG9uZVByb2dyZXNzT3B0aW9ucy5pcyA9IGlzO1xuICAgIGZ1bmN0aW9uIGhhc1dvcmtEb25lUHJvZ3Jlc3ModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuYm9vbGVhbihjYW5kaWRhdGUud29ya0RvbmVQcm9ncmVzcyk7XG4gICAgfVxuICAgIFdvcmtEb25lUHJvZ3Jlc3NPcHRpb25zLmhhc1dvcmtEb25lUHJvZ3Jlc3MgPSBoYXNXb3JrRG9uZVByb2dyZXNzO1xufSkoV29ya0RvbmVQcm9ncmVzc09wdGlvbnMgPSBleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NPcHRpb25zIHx8IChleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NPcHRpb25zID0ge30pKTtcbi8qKlxuICogVGhlIGluaXRpYWxpemUgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyLlxuICogSXQgaXMgc2VudCBvbmNlIGFzIHRoZSByZXF1ZXN0IGFmdGVyIHN0YXJ0aW5nIHVwIHRoZSBzZXJ2ZXIuXG4gKiBUaGUgcmVxdWVzdHMgcGFyYW1ldGVyIGlzIG9mIHR5cGUge0BsaW5rIEluaXRpYWxpemVQYXJhbXN9XG4gKiB0aGUgcmVzcG9uc2UgaWYgb2YgdHlwZSB7QGxpbmsgSW5pdGlhbGl6ZVJlc3VsdH0gb2YgYSBUaGVuYWJsZSB0aGF0XG4gKiByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgSW5pdGlhbGl6ZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKEluaXRpYWxpemVSZXF1ZXN0KSB7XG4gICAgSW5pdGlhbGl6ZVJlcXVlc3QubWV0aG9kID0gJ2luaXRpYWxpemUnO1xuICAgIEluaXRpYWxpemVSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgSW5pdGlhbGl6ZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoSW5pdGlhbGl6ZVJlcXVlc3QubWV0aG9kKTtcbn0pKEluaXRpYWxpemVSZXF1ZXN0ID0gZXhwb3J0cy5Jbml0aWFsaXplUmVxdWVzdCB8fCAoZXhwb3J0cy5Jbml0aWFsaXplUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEtub3duIGVycm9yIGNvZGVzIGZvciBhbiBgSW5pdGlhbGl6ZUVycm9yQ29kZXNgO1xuICovXG52YXIgSW5pdGlhbGl6ZUVycm9yQ29kZXM7XG4oZnVuY3Rpb24gKEluaXRpYWxpemVFcnJvckNvZGVzKSB7XG4gICAgLyoqXG4gICAgICogSWYgdGhlIHByb3RvY29sIHZlcnNpb24gcHJvdmlkZWQgYnkgdGhlIGNsaWVudCBjYW4ndCBiZSBoYW5kbGVkIGJ5IHRoZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIGluaXRpYWxpemUgZXJyb3IgZ290IHJlcGxhY2VkIGJ5IGNsaWVudCBjYXBhYmlsaXRpZXMuIFRoZXJlIGlzXG4gICAgICogbm8gdmVyc2lvbiBoYW5kc2hha2UgaW4gdmVyc2lvbiAzLjB4XG4gICAgICovXG4gICAgSW5pdGlhbGl6ZUVycm9yQ29kZXMudW5rbm93blByb3RvY29sVmVyc2lvbiA9IDE7XG59KShJbml0aWFsaXplRXJyb3JDb2RlcyA9IGV4cG9ydHMuSW5pdGlhbGl6ZUVycm9yQ29kZXMgfHwgKGV4cG9ydHMuSW5pdGlhbGl6ZUVycm9yQ29kZXMgPSB7fSkpO1xuLyoqXG4gKiBUaGUgaW5pdGlhbGl6ZWQgbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZVxuICogc2VydmVyIGFmdGVyIHRoZSBjbGllbnQgaXMgZnVsbHkgaW5pdGlhbGl6ZWQgYW5kIHRoZSBzZXJ2ZXJcbiAqIGlzIGFsbG93ZWQgdG8gc2VuZCByZXF1ZXN0cyBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudC5cbiAqL1xudmFyIEluaXRpYWxpemVkTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChJbml0aWFsaXplZE5vdGlmaWNhdGlvbikge1xuICAgIEluaXRpYWxpemVkTm90aWZpY2F0aW9uLm1ldGhvZCA9ICdpbml0aWFsaXplZCc7XG4gICAgSW5pdGlhbGl6ZWROb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBJbml0aWFsaXplZE5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKEluaXRpYWxpemVkTm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShJbml0aWFsaXplZE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuSW5pdGlhbGl6ZWROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuSW5pdGlhbGl6ZWROb3RpZmljYXRpb24gPSB7fSkpO1xuLy8tLS0tIFNodXRkb3duIE1ldGhvZCAtLS0tXG4vKipcbiAqIEEgc2h1dGRvd24gcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyLlxuICogSXQgaXMgc2VudCBvbmNlIHdoZW4gdGhlIGNsaWVudCBkZWNpZGVzIHRvIHNodXRkb3duIHRoZVxuICogc2VydmVyLiBUaGUgb25seSBub3RpZmljYXRpb24gdGhhdCBpcyBzZW50IGFmdGVyIGEgc2h1dGRvd24gcmVxdWVzdFxuICogaXMgdGhlIGV4aXQgZXZlbnQuXG4gKi9cbnZhciBTaHV0ZG93blJlcXVlc3Q7XG4oZnVuY3Rpb24gKFNodXRkb3duUmVxdWVzdCkge1xuICAgIFNodXRkb3duUmVxdWVzdC5tZXRob2QgPSAnc2h1dGRvd24nO1xuICAgIFNodXRkb3duUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFNodXRkb3duUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZTAoU2h1dGRvd25SZXF1ZXN0Lm1ldGhvZCk7XG59KShTaHV0ZG93blJlcXVlc3QgPSBleHBvcnRzLlNodXRkb3duUmVxdWVzdCB8fCAoZXhwb3J0cy5TaHV0ZG93blJlcXVlc3QgPSB7fSkpO1xuLy8tLS0tIEV4aXQgTm90aWZpY2F0aW9uIC0tLS1cbi8qKlxuICogVGhlIGV4aXQgZXZlbnQgaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB0b1xuICogYXNrIHRoZSBzZXJ2ZXIgdG8gZXhpdCBpdHMgcHJvY2Vzcy5cbiAqL1xudmFyIEV4aXROb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKEV4aXROb3RpZmljYXRpb24pIHtcbiAgICBFeGl0Tm90aWZpY2F0aW9uLm1ldGhvZCA9ICdleGl0JztcbiAgICBFeGl0Tm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRXhpdE5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlMChFeGl0Tm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShFeGl0Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5FeGl0Tm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkV4aXROb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgY29uZmlndXJhdGlvbiBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXJcbiAqIHdoZW4gdGhlIGNsaWVudCdzIGNvbmZpZ3VyYXRpb24gaGFzIGNoYW5nZWQuIFRoZSBub3RpZmljYXRpb24gY29udGFpbnNcbiAqIHRoZSBjaGFuZ2VkIGNvbmZpZ3VyYXRpb24gYXMgZGVmaW5lZCBieSB0aGUgbGFuZ3VhZ2UgY2xpZW50LlxuICovXG52YXIgRGlkQ2hhbmdlQ29uZmlndXJhdGlvbk5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoRGlkQ2hhbmdlQ29uZmlndXJhdGlvbk5vdGlmaWNhdGlvbikge1xuICAgIERpZENoYW5nZUNvbmZpZ3VyYXRpb25Ob3RpZmljYXRpb24ubWV0aG9kID0gJ3dvcmtzcGFjZS9kaWRDaGFuZ2VDb25maWd1cmF0aW9uJztcbiAgICBEaWRDaGFuZ2VDb25maWd1cmF0aW9uTm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRGlkQ2hhbmdlQ29uZmlndXJhdGlvbk5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZENoYW5nZUNvbmZpZ3VyYXRpb25Ob3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKERpZENoYW5nZUNvbmZpZ3VyYXRpb25Ob3RpZmljYXRpb24gPSBleHBvcnRzLkRpZENoYW5nZUNvbmZpZ3VyYXRpb25Ob3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ2hhbmdlQ29uZmlndXJhdGlvbk5vdGlmaWNhdGlvbiA9IHt9KSk7XG4vLy0tLS0gTWVzc2FnZSBzaG93IGFuZCBsb2cgbm90aWZpY2F0aW9ucyAtLS0tXG4vKipcbiAqIFRoZSBtZXNzYWdlIHR5cGVcbiAqL1xudmFyIE1lc3NhZ2VUeXBlO1xuKGZ1bmN0aW9uIChNZXNzYWdlVHlwZSkge1xuICAgIC8qKlxuICAgICAqIEFuIGVycm9yIG1lc3NhZ2UuXG4gICAgICovXG4gICAgTWVzc2FnZVR5cGUuRXJyb3IgPSAxO1xuICAgIC8qKlxuICAgICAqIEEgd2FybmluZyBtZXNzYWdlLlxuICAgICAqL1xuICAgIE1lc3NhZ2VUeXBlLldhcm5pbmcgPSAyO1xuICAgIC8qKlxuICAgICAqIEFuIGluZm9ybWF0aW9uIG1lc3NhZ2UuXG4gICAgICovXG4gICAgTWVzc2FnZVR5cGUuSW5mbyA9IDM7XG4gICAgLyoqXG4gICAgICogQSBsb2cgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBNZXNzYWdlVHlwZS5Mb2cgPSA0O1xufSkoTWVzc2FnZVR5cGUgPSBleHBvcnRzLk1lc3NhZ2VUeXBlIHx8IChleHBvcnRzLk1lc3NhZ2VUeXBlID0ge30pKTtcbi8qKlxuICogVGhlIHNob3cgbWVzc2FnZSBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIGEgc2VydmVyIHRvIGEgY2xpZW50IHRvIGFza1xuICogdGhlIGNsaWVudCB0byBkaXNwbGF5IGEgcGFydGljdWxhciBtZXNzYWdlIGluIHRoZSB1c2VyIGludGVyZmFjZS5cbiAqL1xudmFyIFNob3dNZXNzYWdlTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChTaG93TWVzc2FnZU5vdGlmaWNhdGlvbikge1xuICAgIFNob3dNZXNzYWdlTm90aWZpY2F0aW9uLm1ldGhvZCA9ICd3aW5kb3cvc2hvd01lc3NhZ2UnO1xuICAgIFNob3dNZXNzYWdlTm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgU2hvd01lc3NhZ2VOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShTaG93TWVzc2FnZU5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoU2hvd01lc3NhZ2VOb3RpZmljYXRpb24gPSBleHBvcnRzLlNob3dNZXNzYWdlTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLlNob3dNZXNzYWdlTm90aWZpY2F0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIHNob3cgbWVzc2FnZSByZXF1ZXN0IGlzIHNlbnQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQgdG8gc2hvdyBhIG1lc3NhZ2VcbiAqIGFuZCBhIHNldCBvZiBvcHRpb25zIGFjdGlvbnMgdG8gdGhlIHVzZXIuXG4gKi9cbnZhciBTaG93TWVzc2FnZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKFNob3dNZXNzYWdlUmVxdWVzdCkge1xuICAgIFNob3dNZXNzYWdlUmVxdWVzdC5tZXRob2QgPSAnd2luZG93L3Nob3dNZXNzYWdlUmVxdWVzdCc7XG4gICAgU2hvd01lc3NhZ2VSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgU2hvd01lc3NhZ2VSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFNob3dNZXNzYWdlUmVxdWVzdC5tZXRob2QpO1xufSkoU2hvd01lc3NhZ2VSZXF1ZXN0ID0gZXhwb3J0cy5TaG93TWVzc2FnZVJlcXVlc3QgfHwgKGV4cG9ydHMuU2hvd01lc3NhZ2VSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogVGhlIGxvZyBtZXNzYWdlIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50IHRvIGFza1xuICogdGhlIGNsaWVudCB0byBsb2cgYSBwYXJ0aWN1bGFyIG1lc3NhZ2UuXG4gKi9cbnZhciBMb2dNZXNzYWdlTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChMb2dNZXNzYWdlTm90aWZpY2F0aW9uKSB7XG4gICAgTG9nTWVzc2FnZU5vdGlmaWNhdGlvbi5tZXRob2QgPSAnd2luZG93L2xvZ01lc3NhZ2UnO1xuICAgIExvZ01lc3NhZ2VOb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5zZXJ2ZXJUb0NsaWVudDtcbiAgICBMb2dNZXNzYWdlTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoTG9nTWVzc2FnZU5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoTG9nTWVzc2FnZU5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuTG9nTWVzc2FnZU5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5Mb2dNZXNzYWdlTm90aWZpY2F0aW9uID0ge30pKTtcbi8vLS0tLSBUZWxlbWV0cnkgbm90aWZpY2F0aW9uXG4vKipcbiAqIFRoZSB0ZWxlbWV0cnkgZXZlbnQgbm90aWZpY2F0aW9uIGlzIHNlbnQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQgdG8gYXNrXG4gKiB0aGUgY2xpZW50IHRvIGxvZyB0ZWxlbWV0cnkgZGF0YS5cbiAqL1xudmFyIFRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChUZWxlbWV0cnlFdmVudE5vdGlmaWNhdGlvbikge1xuICAgIFRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uLm1ldGhvZCA9ICd0ZWxlbWV0cnkvZXZlbnQnO1xuICAgIFRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgVGVsZW1ldHJ5RXZlbnROb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShUZWxlbWV0cnlFdmVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoVGVsZW1ldHJ5RXZlbnROb3RpZmljYXRpb24gPSBleHBvcnRzLlRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uIHx8IChleHBvcnRzLlRlbGVtZXRyeUV2ZW50Tm90aWZpY2F0aW9uID0ge30pKTtcbi8qKlxuICogRGVmaW5lcyBob3cgdGhlIGhvc3QgKGVkaXRvcikgc2hvdWxkIHN5bmNcbiAqIGRvY3VtZW50IGNoYW5nZXMgdG8gdGhlIGxhbmd1YWdlIHNlcnZlci5cbiAqL1xudmFyIFRleHREb2N1bWVudFN5bmNLaW5kO1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnRTeW5jS2luZCkge1xuICAgIC8qKlxuICAgICAqIERvY3VtZW50cyBzaG91bGQgbm90IGJlIHN5bmNlZCBhdCBhbGwuXG4gICAgICovXG4gICAgVGV4dERvY3VtZW50U3luY0tpbmQuTm9uZSA9IDA7XG4gICAgLyoqXG4gICAgICogRG9jdW1lbnRzIGFyZSBzeW5jZWQgYnkgYWx3YXlzIHNlbmRpbmcgdGhlIGZ1bGwgY29udGVudFxuICAgICAqIG9mIHRoZSBkb2N1bWVudC5cbiAgICAgKi9cbiAgICBUZXh0RG9jdW1lbnRTeW5jS2luZC5GdWxsID0gMTtcbiAgICAvKipcbiAgICAgKiBEb2N1bWVudHMgYXJlIHN5bmNlZCBieSBzZW5kaW5nIHRoZSBmdWxsIGNvbnRlbnQgb24gb3Blbi5cbiAgICAgKiBBZnRlciB0aGF0IG9ubHkgaW5jcmVtZW50YWwgdXBkYXRlcyB0byB0aGUgZG9jdW1lbnQgYXJlXG4gICAgICogc2VuZC5cbiAgICAgKi9cbiAgICBUZXh0RG9jdW1lbnRTeW5jS2luZC5JbmNyZW1lbnRhbCA9IDI7XG59KShUZXh0RG9jdW1lbnRTeW5jS2luZCA9IGV4cG9ydHMuVGV4dERvY3VtZW50U3luY0tpbmQgfHwgKGV4cG9ydHMuVGV4dERvY3VtZW50U3luY0tpbmQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgZG9jdW1lbnQgb3BlbiBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB0byBzaWduYWxcbiAqIG5ld2x5IG9wZW5lZCB0ZXh0IGRvY3VtZW50cy4gVGhlIGRvY3VtZW50J3MgdHJ1dGggaXMgbm93IG1hbmFnZWQgYnkgdGhlIGNsaWVudFxuICogYW5kIHRoZSBzZXJ2ZXIgbXVzdCBub3QgdHJ5IHRvIHJlYWQgdGhlIGRvY3VtZW50J3MgdHJ1dGggdXNpbmcgdGhlIGRvY3VtZW50J3NcbiAqIHVyaS4gT3BlbiBpbiB0aGlzIHNlbnNlIG1lYW5zIGl0IGlzIG1hbmFnZWQgYnkgdGhlIGNsaWVudC4gSXQgZG9lc24ndCBuZWNlc3NhcmlseVxuICogbWVhbiB0aGF0IGl0cyBjb250ZW50IGlzIHByZXNlbnRlZCBpbiBhbiBlZGl0b3IuIEFuIG9wZW4gbm90aWZpY2F0aW9uIG11c3Qgbm90XG4gKiBiZSBzZW50IG1vcmUgdGhhbiBvbmNlIHdpdGhvdXQgYSBjb3JyZXNwb25kaW5nIGNsb3NlIG5vdGlmaWNhdGlvbiBzZW5kIGJlZm9yZS5cbiAqIFRoaXMgbWVhbnMgb3BlbiBhbmQgY2xvc2Ugbm90aWZpY2F0aW9uIG11c3QgYmUgYmFsYW5jZWQgYW5kIHRoZSBtYXggb3BlbiBjb3VudFxuICogaXMgb25lLlxuICovXG52YXIgRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbikge1xuICAgIERpZE9wZW5UZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kID0gJ3RleHREb2N1bWVudC9kaWRPcGVuJztcbiAgICBEaWRPcGVuVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZE9wZW5UZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kKTtcbn0pKERpZE9wZW5UZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZE9wZW5UZXh0RG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IHt9KSk7XG52YXIgVGV4dERvY3VtZW50Q29udGVudENoYW5nZUV2ZW50O1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnRDb250ZW50Q2hhbmdlRXZlbnQpIHtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgaW5mb3JtYXRpb24gZGVzY3JpYmVzIGEgZGVsdGEgZXZlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJbmNyZW1lbnRhbChldmVudCkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gZXZlbnQ7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjYW5kaWRhdGUudGV4dCA9PT0gJ3N0cmluZycgJiYgY2FuZGlkYXRlLnJhbmdlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUucmFuZ2VMZW5ndGggPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgY2FuZGlkYXRlLnJhbmdlTGVuZ3RoID09PSAnbnVtYmVyJyk7XG4gICAgfVxuICAgIFRleHREb2N1bWVudENvbnRlbnRDaGFuZ2VFdmVudC5pc0luY3JlbWVudGFsID0gaXNJbmNyZW1lbnRhbDtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgaW5mb3JtYXRpb24gZGVzY3JpYmVzIGEgZnVsbCByZXBsYWNlbWVudCBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Z1bGwoZXZlbnQpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IGV2ZW50O1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICE9PSB1bmRlZmluZWQgJiYgY2FuZGlkYXRlICE9PSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2YgY2FuZGlkYXRlLnRleHQgPT09ICdzdHJpbmcnICYmIGNhbmRpZGF0ZS5yYW5nZSA9PT0gdW5kZWZpbmVkICYmIGNhbmRpZGF0ZS5yYW5nZUxlbmd0aCA9PT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnRDb250ZW50Q2hhbmdlRXZlbnQuaXNGdWxsID0gaXNGdWxsO1xufSkoVGV4dERvY3VtZW50Q29udGVudENoYW5nZUV2ZW50ID0gZXhwb3J0cy5UZXh0RG9jdW1lbnRDb250ZW50Q2hhbmdlRXZlbnQgfHwgKGV4cG9ydHMuVGV4dERvY3VtZW50Q29udGVudENoYW5nZUV2ZW50ID0ge30pKTtcbi8qKlxuICogVGhlIGRvY3VtZW50IGNoYW5nZSBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB0byBzaWduYWxcbiAqIGNoYW5nZXMgdG8gYSB0ZXh0IGRvY3VtZW50LlxuICovXG52YXIgRGlkQ2hhbmdlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24pIHtcbiAgICBEaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kID0gJ3RleHREb2N1bWVudC9kaWRDaGFuZ2UnO1xuICAgIERpZENoYW5nZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZENoYW5nZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZENoYW5nZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoRGlkQ2hhbmdlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRDaGFuZ2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ2hhbmdlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIGRvY3VtZW50IGNsb3NlIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHdoZW5cbiAqIHRoZSBkb2N1bWVudCBnb3QgY2xvc2VkIGluIHRoZSBjbGllbnQuIFRoZSBkb2N1bWVudCdzIHRydXRoIG5vdyBleGlzdHMgd2hlcmVcbiAqIHRoZSBkb2N1bWVudCdzIHVyaSBwb2ludHMgdG8gKGUuZy4gaWYgdGhlIGRvY3VtZW50J3MgdXJpIGlzIGEgZmlsZSB1cmkgdGhlXG4gKiB0cnV0aCBub3cgZXhpc3RzIG9uIGRpc2spLiBBcyB3aXRoIHRoZSBvcGVuIG5vdGlmaWNhdGlvbiB0aGUgY2xvc2Ugbm90aWZpY2F0aW9uXG4gKiBpcyBhYm91dCBtYW5hZ2luZyB0aGUgZG9jdW1lbnQncyBjb250ZW50LiBSZWNlaXZpbmcgYSBjbG9zZSBub3RpZmljYXRpb25cbiAqIGRvZXNuJ3QgbWVhbiB0aGF0IHRoZSBkb2N1bWVudCB3YXMgb3BlbiBpbiBhbiBlZGl0b3IgYmVmb3JlLiBBIGNsb3NlXG4gKiBub3RpZmljYXRpb24gcmVxdWlyZXMgYSBwcmV2aW91cyBvcGVuIG5vdGlmaWNhdGlvbiB0byBiZSBzZW50LlxuICovXG52YXIgRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKERpZENsb3NlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uKSB7XG4gICAgRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kID0gJ3RleHREb2N1bWVudC9kaWRDbG9zZSc7XG4gICAgRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRDbG9zZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZENsb3NlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShEaWRDbG9zZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ2xvc2VUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgZG9jdW1lbnQgc2F2ZSBub3RpZmljYXRpb24gaXMgc2VudCBmcm9tIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB3aGVuXG4gKiB0aGUgZG9jdW1lbnQgZ290IHNhdmVkIGluIHRoZSBjbGllbnQuXG4gKi9cbnZhciBEaWRTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uKSB7XG4gICAgRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QgPSAndGV4dERvY3VtZW50L2RpZFNhdmUnO1xuICAgIERpZFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5EaWRTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uID0ge30pKTtcbi8qKlxuICogUmVwcmVzZW50cyByZWFzb25zIHdoeSBhIHRleHQgZG9jdW1lbnQgaXMgc2F2ZWQuXG4gKi9cbnZhciBUZXh0RG9jdW1lbnRTYXZlUmVhc29uO1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnRTYXZlUmVhc29uKSB7XG4gICAgLyoqXG4gICAgICogTWFudWFsbHkgdHJpZ2dlcmVkLCBlLmcuIGJ5IHRoZSB1c2VyIHByZXNzaW5nIHNhdmUsIGJ5IHN0YXJ0aW5nIGRlYnVnZ2luZyxcbiAgICAgKiBvciBieSBhbiBBUEkgY2FsbC5cbiAgICAgKi9cbiAgICBUZXh0RG9jdW1lbnRTYXZlUmVhc29uLk1hbnVhbCA9IDE7XG4gICAgLyoqXG4gICAgICogQXV0b21hdGljIGFmdGVyIGEgZGVsYXkuXG4gICAgICovXG4gICAgVGV4dERvY3VtZW50U2F2ZVJlYXNvbi5BZnRlckRlbGF5ID0gMjtcbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSBlZGl0b3IgbG9zdCBmb2N1cy5cbiAgICAgKi9cbiAgICBUZXh0RG9jdW1lbnRTYXZlUmVhc29uLkZvY3VzT3V0ID0gMztcbn0pKFRleHREb2N1bWVudFNhdmVSZWFzb24gPSBleHBvcnRzLlRleHREb2N1bWVudFNhdmVSZWFzb24gfHwgKGV4cG9ydHMuVGV4dERvY3VtZW50U2F2ZVJlYXNvbiA9IHt9KSk7XG4vKipcbiAqIEEgZG9jdW1lbnQgd2lsbCBzYXZlIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIGJlZm9yZVxuICogdGhlIGRvY3VtZW50IGlzIGFjdHVhbGx5IHNhdmVkLlxuICovXG52YXIgV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKFdpbGxTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uKSB7XG4gICAgV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kID0gJ3RleHREb2N1bWVudC93aWxsU2F2ZSc7XG4gICAgV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBXaWxsU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKFdpbGxTYXZlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShXaWxsU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBBIGRvY3VtZW50IHdpbGwgc2F2ZSByZXF1ZXN0IGlzIHNlbnQgZnJvbSB0aGUgY2xpZW50IHRvIHRoZSBzZXJ2ZXIgYmVmb3JlXG4gKiB0aGUgZG9jdW1lbnQgaXMgYWN0dWFsbHkgc2F2ZWQuIFRoZSByZXF1ZXN0IGNhbiByZXR1cm4gYW4gYXJyYXkgb2YgVGV4dEVkaXRzXG4gKiB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHRleHQgZG9jdW1lbnQgYmVmb3JlIGl0IGlzIHNhdmVkLiBQbGVhc2Ugbm90ZSB0aGF0XG4gKiBjbGllbnRzIG1pZ2h0IGRyb3AgcmVzdWx0cyBpZiBjb21wdXRpbmcgdGhlIHRleHQgZWRpdHMgdG9vayB0b28gbG9uZyBvciBpZiBhXG4gKiBzZXJ2ZXIgY29uc3RhbnRseSBmYWlscyBvbiB0aGlzIHJlcXVlc3QuIFRoaXMgaXMgZG9uZSB0byBrZWVwIHRoZSBzYXZlIGZhc3QgYW5kXG4gKiByZWxpYWJsZS5cbiAqL1xudmFyIFdpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdDtcbihmdW5jdGlvbiAoV2lsbFNhdmVUZXh0RG9jdW1lbnRXYWl0VW50aWxSZXF1ZXN0KSB7XG4gICAgV2lsbFNhdmVUZXh0RG9jdW1lbnRXYWl0VW50aWxSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvd2lsbFNhdmVXYWl0VW50aWwnO1xuICAgIFdpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFdpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShXaWxsU2F2ZVRleHREb2N1bWVudFdhaXRVbnRpbFJlcXVlc3QubWV0aG9kKTtcbn0pKFdpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdCA9IGV4cG9ydHMuV2lsbFNhdmVUZXh0RG9jdW1lbnRXYWl0VW50aWxSZXF1ZXN0IHx8IChleHBvcnRzLldpbGxTYXZlVGV4dERvY3VtZW50V2FpdFVudGlsUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFRoZSB3YXRjaGVkIGZpbGVzIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHdoZW5cbiAqIHRoZSBjbGllbnQgZGV0ZWN0cyBjaGFuZ2VzIHRvIGZpbGUgd2F0Y2hlZCBieSB0aGUgbGFuZ3VhZ2UgY2xpZW50LlxuICovXG52YXIgRGlkQ2hhbmdlV2F0Y2hlZEZpbGVzTm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRDaGFuZ2VXYXRjaGVkRmlsZXNOb3RpZmljYXRpb24pIHtcbiAgICBEaWRDaGFuZ2VXYXRjaGVkRmlsZXNOb3RpZmljYXRpb24ubWV0aG9kID0gJ3dvcmtzcGFjZS9kaWRDaGFuZ2VXYXRjaGVkRmlsZXMnO1xuICAgIERpZENoYW5nZVdhdGNoZWRGaWxlc05vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZENoYW5nZVdhdGNoZWRGaWxlc05vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZENoYW5nZVdhdGNoZWRGaWxlc05vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoRGlkQ2hhbmdlV2F0Y2hlZEZpbGVzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRDaGFuZ2VXYXRjaGVkRmlsZXNOb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ2hhbmdlV2F0Y2hlZEZpbGVzTm90aWZpY2F0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIGZpbGUgZXZlbnQgdHlwZVxuICovXG52YXIgRmlsZUNoYW5nZVR5cGU7XG4oZnVuY3Rpb24gKEZpbGVDaGFuZ2VUeXBlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGZpbGUgZ290IGNyZWF0ZWQuXG4gICAgICovXG4gICAgRmlsZUNoYW5nZVR5cGUuQ3JlYXRlZCA9IDE7XG4gICAgLyoqXG4gICAgICogVGhlIGZpbGUgZ290IGNoYW5nZWQuXG4gICAgICovXG4gICAgRmlsZUNoYW5nZVR5cGUuQ2hhbmdlZCA9IDI7XG4gICAgLyoqXG4gICAgICogVGhlIGZpbGUgZ290IGRlbGV0ZWQuXG4gICAgICovXG4gICAgRmlsZUNoYW5nZVR5cGUuRGVsZXRlZCA9IDM7XG59KShGaWxlQ2hhbmdlVHlwZSA9IGV4cG9ydHMuRmlsZUNoYW5nZVR5cGUgfHwgKGV4cG9ydHMuRmlsZUNoYW5nZVR5cGUgPSB7fSkpO1xudmFyIFJlbGF0aXZlUGF0dGVybjtcbihmdW5jdGlvbiAoUmVsYXRpdmVQYXR0ZXJuKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgKHZzY29kZV9sYW5ndWFnZXNlcnZlcl90eXBlc18xLlVSSS5pcyhjYW5kaWRhdGUuYmFzZVVyaSkgfHwgdnNjb2RlX2xhbmd1YWdlc2VydmVyX3R5cGVzXzEuV29ya3NwYWNlRm9sZGVyLmlzKGNhbmRpZGF0ZS5iYXNlVXJpKSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5wYXR0ZXJuKTtcbiAgICB9XG4gICAgUmVsYXRpdmVQYXR0ZXJuLmlzID0gaXM7XG59KShSZWxhdGl2ZVBhdHRlcm4gPSBleHBvcnRzLlJlbGF0aXZlUGF0dGVybiB8fCAoZXhwb3J0cy5SZWxhdGl2ZVBhdHRlcm4gPSB7fSkpO1xudmFyIFdhdGNoS2luZDtcbihmdW5jdGlvbiAoV2F0Y2hLaW5kKSB7XG4gICAgLyoqXG4gICAgICogSW50ZXJlc3RlZCBpbiBjcmVhdGUgZXZlbnRzLlxuICAgICAqL1xuICAgIFdhdGNoS2luZC5DcmVhdGUgPSAxO1xuICAgIC8qKlxuICAgICAqIEludGVyZXN0ZWQgaW4gY2hhbmdlIGV2ZW50c1xuICAgICAqL1xuICAgIFdhdGNoS2luZC5DaGFuZ2UgPSAyO1xuICAgIC8qKlxuICAgICAqIEludGVyZXN0ZWQgaW4gZGVsZXRlIGV2ZW50c1xuICAgICAqL1xuICAgIFdhdGNoS2luZC5EZWxldGUgPSA0O1xufSkoV2F0Y2hLaW5kID0gZXhwb3J0cy5XYXRjaEtpbmQgfHwgKGV4cG9ydHMuV2F0Y2hLaW5kID0ge30pKTtcbi8qKlxuICogRGlhZ25vc3RpY3Mgbm90aWZpY2F0aW9uIGFyZSBzZW50IGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50IHRvIHNpZ25hbFxuICogcmVzdWx0cyBvZiB2YWxpZGF0aW9uIHJ1bnMuXG4gKi9cbnZhciBQdWJsaXNoRGlhZ25vc3RpY3NOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKFB1Ymxpc2hEaWFnbm9zdGljc05vdGlmaWNhdGlvbikge1xuICAgIFB1Ymxpc2hEaWFnbm9zdGljc05vdGlmaWNhdGlvbi5tZXRob2QgPSAndGV4dERvY3VtZW50L3B1Ymxpc2hEaWFnbm9zdGljcyc7XG4gICAgUHVibGlzaERpYWdub3N0aWNzTm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgUHVibGlzaERpYWdub3N0aWNzTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoUHVibGlzaERpYWdub3N0aWNzTm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShQdWJsaXNoRGlhZ25vc3RpY3NOb3RpZmljYXRpb24gPSBleHBvcnRzLlB1Ymxpc2hEaWFnbm9zdGljc05vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5QdWJsaXNoRGlhZ25vc3RpY3NOb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBIb3cgYSBjb21wbGV0aW9uIHdhcyB0cmlnZ2VyZWRcbiAqL1xudmFyIENvbXBsZXRpb25UcmlnZ2VyS2luZDtcbihmdW5jdGlvbiAoQ29tcGxldGlvblRyaWdnZXJLaW5kKSB7XG4gICAgLyoqXG4gICAgICogQ29tcGxldGlvbiB3YXMgdHJpZ2dlcmVkIGJ5IHR5cGluZyBhbiBpZGVudGlmaWVyICgyNHg3IGNvZGVcbiAgICAgKiBjb21wbGV0ZSksIG1hbnVhbCBpbnZvY2F0aW9uIChlLmcgQ3RybCtTcGFjZSkgb3IgdmlhIEFQSS5cbiAgICAgKi9cbiAgICBDb21wbGV0aW9uVHJpZ2dlcktpbmQuSW52b2tlZCA9IDE7XG4gICAgLyoqXG4gICAgICogQ29tcGxldGlvbiB3YXMgdHJpZ2dlcmVkIGJ5IGEgdHJpZ2dlciBjaGFyYWN0ZXIgc3BlY2lmaWVkIGJ5XG4gICAgICogdGhlIGB0cmlnZ2VyQ2hhcmFjdGVyc2AgcHJvcGVydGllcyBvZiB0aGUgYENvbXBsZXRpb25SZWdpc3RyYXRpb25PcHRpb25zYC5cbiAgICAgKi9cbiAgICBDb21wbGV0aW9uVHJpZ2dlcktpbmQuVHJpZ2dlckNoYXJhY3RlciA9IDI7XG4gICAgLyoqXG4gICAgICogQ29tcGxldGlvbiB3YXMgcmUtdHJpZ2dlcmVkIGFzIGN1cnJlbnQgY29tcGxldGlvbiBsaXN0IGlzIGluY29tcGxldGVcbiAgICAgKi9cbiAgICBDb21wbGV0aW9uVHJpZ2dlcktpbmQuVHJpZ2dlckZvckluY29tcGxldGVDb21wbGV0aW9ucyA9IDM7XG59KShDb21wbGV0aW9uVHJpZ2dlcktpbmQgPSBleHBvcnRzLkNvbXBsZXRpb25UcmlnZ2VyS2luZCB8fCAoZXhwb3J0cy5Db21wbGV0aW9uVHJpZ2dlcktpbmQgPSB7fSkpO1xuLyoqXG4gKiBSZXF1ZXN0IHRvIHJlcXVlc3QgY29tcGxldGlvbiBhdCBhIGdpdmVuIHRleHQgZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBUZXh0RG9jdW1lbnRQb3NpdGlvbn0gdGhlIHJlc3BvbnNlXG4gKiBpcyBvZiB0eXBlIHtAbGluayBDb21wbGV0aW9uSXRlbSBDb21wbGV0aW9uSXRlbVtdfSBvciB7QGxpbmsgQ29tcGxldGlvbkxpc3R9XG4gKiBvciBhIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqXG4gKiBUaGUgcmVxdWVzdCBjYW4gZGVsYXkgdGhlIGNvbXB1dGF0aW9uIG9mIHRoZSB7QGxpbmsgQ29tcGxldGlvbkl0ZW0uZGV0YWlsIGBkZXRhaWxgfVxuICogYW5kIHtAbGluayBDb21wbGV0aW9uSXRlbS5kb2N1bWVudGF0aW9uIGBkb2N1bWVudGF0aW9uYH0gcHJvcGVydGllcyB0byB0aGUgYGNvbXBsZXRpb25JdGVtL3Jlc29sdmVgXG4gKiByZXF1ZXN0LiBIb3dldmVyLCBwcm9wZXJ0aWVzIHRoYXQgYXJlIG5lZWRlZCBmb3IgdGhlIGluaXRpYWwgc29ydGluZyBhbmQgZmlsdGVyaW5nLCBsaWtlIGBzb3J0VGV4dGAsXG4gKiBgZmlsdGVyVGV4dGAsIGBpbnNlcnRUZXh0YCwgYW5kIGB0ZXh0RWRpdGAsIG11c3Qgbm90IGJlIGNoYW5nZWQgZHVyaW5nIHJlc29sdmUuXG4gKi9cbnZhciBDb21wbGV0aW9uUmVxdWVzdDtcbihmdW5jdGlvbiAoQ29tcGxldGlvblJlcXVlc3QpIHtcbiAgICBDb21wbGV0aW9uUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2NvbXBsZXRpb24nO1xuICAgIENvbXBsZXRpb25SZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgQ29tcGxldGlvblJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoQ29tcGxldGlvblJlcXVlc3QubWV0aG9kKTtcbn0pKENvbXBsZXRpb25SZXF1ZXN0ID0gZXhwb3J0cy5Db21wbGV0aW9uUmVxdWVzdCB8fCAoZXhwb3J0cy5Db21wbGV0aW9uUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFJlcXVlc3QgdG8gcmVzb2x2ZSBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGZvciBhIGdpdmVuIGNvbXBsZXRpb24gaXRlbS5UaGUgcmVxdWVzdCdzXG4gKiBwYXJhbWV0ZXIgaXMgb2YgdHlwZSB7QGxpbmsgQ29tcGxldGlvbkl0ZW19IHRoZSByZXNwb25zZVxuICogaXMgb2YgdHlwZSB7QGxpbmsgQ29tcGxldGlvbkl0ZW19IG9yIGEgVGhlbmFibGUgdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgQ29tcGxldGlvblJlc29sdmVSZXF1ZXN0O1xuKGZ1bmN0aW9uIChDb21wbGV0aW9uUmVzb2x2ZVJlcXVlc3QpIHtcbiAgICBDb21wbGV0aW9uUmVzb2x2ZVJlcXVlc3QubWV0aG9kID0gJ2NvbXBsZXRpb25JdGVtL3Jlc29sdmUnO1xuICAgIENvbXBsZXRpb25SZXNvbHZlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIENvbXBsZXRpb25SZXNvbHZlUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShDb21wbGV0aW9uUmVzb2x2ZVJlcXVlc3QubWV0aG9kKTtcbn0pKENvbXBsZXRpb25SZXNvbHZlUmVxdWVzdCA9IGV4cG9ydHMuQ29tcGxldGlvblJlc29sdmVSZXF1ZXN0IHx8IChleHBvcnRzLkNvbXBsZXRpb25SZXNvbHZlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFJlcXVlc3QgdG8gcmVxdWVzdCBob3ZlciBpbmZvcm1hdGlvbiBhdCBhIGdpdmVuIHRleHQgZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBUZXh0RG9jdW1lbnRQb3NpdGlvbn0gdGhlIHJlc3BvbnNlIGlzIG9mXG4gKiB0eXBlIHtAbGluayBIb3Zlcn0gb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBIb3ZlclJlcXVlc3Q7XG4oZnVuY3Rpb24gKEhvdmVyUmVxdWVzdCkge1xuICAgIEhvdmVyUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2hvdmVyJztcbiAgICBIb3ZlclJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBIb3ZlclJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoSG92ZXJSZXF1ZXN0Lm1ldGhvZCk7XG59KShIb3ZlclJlcXVlc3QgPSBleHBvcnRzLkhvdmVyUmVxdWVzdCB8fCAoZXhwb3J0cy5Ib3ZlclJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBIb3cgYSBzaWduYXR1cmUgaGVscCB3YXMgdHJpZ2dlcmVkLlxuICpcbiAqIEBzaW5jZSAzLjE1LjBcbiAqL1xudmFyIFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZDtcbihmdW5jdGlvbiAoU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kKSB7XG4gICAgLyoqXG4gICAgICogU2lnbmF0dXJlIGhlbHAgd2FzIGludm9rZWQgbWFudWFsbHkgYnkgdGhlIHVzZXIgb3IgYnkgYSBjb21tYW5kLlxuICAgICAqL1xuICAgIFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZC5JbnZva2VkID0gMTtcbiAgICAvKipcbiAgICAgKiBTaWduYXR1cmUgaGVscCB3YXMgdHJpZ2dlcmVkIGJ5IGEgdHJpZ2dlciBjaGFyYWN0ZXIuXG4gICAgICovXG4gICAgU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kLlRyaWdnZXJDaGFyYWN0ZXIgPSAyO1xuICAgIC8qKlxuICAgICAqIFNpZ25hdHVyZSBoZWxwIHdhcyB0cmlnZ2VyZWQgYnkgdGhlIGN1cnNvciBtb3Zpbmcgb3IgYnkgdGhlIGRvY3VtZW50IGNvbnRlbnQgY2hhbmdpbmcuXG4gICAgICovXG4gICAgU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kLkNvbnRlbnRDaGFuZ2UgPSAzO1xufSkoU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kID0gZXhwb3J0cy5TaWduYXR1cmVIZWxwVHJpZ2dlcktpbmQgfHwgKGV4cG9ydHMuU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kID0ge30pKTtcbnZhciBTaWduYXR1cmVIZWxwUmVxdWVzdDtcbihmdW5jdGlvbiAoU2lnbmF0dXJlSGVscFJlcXVlc3QpIHtcbiAgICBTaWduYXR1cmVIZWxwUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3NpZ25hdHVyZUhlbHAnO1xuICAgIFNpZ25hdHVyZUhlbHBSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgU2lnbmF0dXJlSGVscFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoU2lnbmF0dXJlSGVscFJlcXVlc3QubWV0aG9kKTtcbn0pKFNpZ25hdHVyZUhlbHBSZXF1ZXN0ID0gZXhwb3J0cy5TaWduYXR1cmVIZWxwUmVxdWVzdCB8fCAoZXhwb3J0cy5TaWduYXR1cmVIZWxwUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIHRoZSBkZWZpbml0aW9uIGxvY2F0aW9uIG9mIGEgc3ltYm9sIGF0IGEgZ2l2ZW4gdGV4dFxuICogZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mIHR5cGUgW1RleHREb2N1bWVudFBvc2l0aW9uXVxuICogKCNUZXh0RG9jdW1lbnRQb3NpdGlvbikgdGhlIHJlc3BvbnNlIGlzIG9mIGVpdGhlciB0eXBlIHtAbGluayBEZWZpbml0aW9ufVxuICogb3IgYSB0eXBlZCBhcnJheSBvZiB7QGxpbmsgRGVmaW5pdGlvbkxpbmt9IG9yIGEgVGhlbmFibGUgdGhhdCByZXNvbHZlc1xuICogdG8gc3VjaC5cbiAqL1xudmFyIERlZmluaXRpb25SZXF1ZXN0O1xuKGZ1bmN0aW9uIChEZWZpbml0aW9uUmVxdWVzdCkge1xuICAgIERlZmluaXRpb25SZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvZGVmaW5pdGlvbic7XG4gICAgRGVmaW5pdGlvblJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEZWZpbml0aW9uUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShEZWZpbml0aW9uUmVxdWVzdC5tZXRob2QpO1xufSkoRGVmaW5pdGlvblJlcXVlc3QgPSBleHBvcnRzLkRlZmluaXRpb25SZXF1ZXN0IHx8IChleHBvcnRzLkRlZmluaXRpb25SZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHJlc29sdmUgcHJvamVjdC13aWRlIHJlZmVyZW5jZXMgZm9yIHRoZSBzeW1ib2wgZGVub3RlZFxuICogYnkgdGhlIGdpdmVuIHRleHQgZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mXG4gKiB0eXBlIHtAbGluayBSZWZlcmVuY2VQYXJhbXN9IHRoZSByZXNwb25zZSBpcyBvZiB0eXBlXG4gKiB7QGxpbmsgTG9jYXRpb24gTG9jYXRpb25bXX0gb3IgYSBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBSZWZlcmVuY2VzUmVxdWVzdDtcbihmdW5jdGlvbiAoUmVmZXJlbmNlc1JlcXVlc3QpIHtcbiAgICBSZWZlcmVuY2VzUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3JlZmVyZW5jZXMnO1xuICAgIFJlZmVyZW5jZXNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgUmVmZXJlbmNlc1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoUmVmZXJlbmNlc1JlcXVlc3QubWV0aG9kKTtcbn0pKFJlZmVyZW5jZXNSZXF1ZXN0ID0gZXhwb3J0cy5SZWZlcmVuY2VzUmVxdWVzdCB8fCAoZXhwb3J0cy5SZWZlcmVuY2VzUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFJlcXVlc3QgdG8gcmVzb2x2ZSBhIHtAbGluayBEb2N1bWVudEhpZ2hsaWdodH0gZm9yIGEgZ2l2ZW5cbiAqIHRleHQgZG9jdW1lbnQgcG9zaXRpb24uIFRoZSByZXF1ZXN0J3MgcGFyYW1ldGVyIGlzIG9mIHR5cGUgW1RleHREb2N1bWVudFBvc2l0aW9uXVxuICogKCNUZXh0RG9jdW1lbnRQb3NpdGlvbikgdGhlIHJlcXVlc3QgcmVzcG9uc2UgaXMgb2YgdHlwZSBbRG9jdW1lbnRIaWdobGlnaHRbXV1cbiAqICgjRG9jdW1lbnRIaWdobGlnaHQpIG9yIGEgVGhlbmFibGUgdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0O1xuKGZ1bmN0aW9uIChEb2N1bWVudEhpZ2hsaWdodFJlcXVlc3QpIHtcbiAgICBEb2N1bWVudEhpZ2hsaWdodFJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9kb2N1bWVudEhpZ2hsaWdodCc7XG4gICAgRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKERvY3VtZW50SGlnaGxpZ2h0UmVxdWVzdC5tZXRob2QpO1xufSkoRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudEhpZ2hsaWdodFJlcXVlc3QgfHwgKGV4cG9ydHMuRG9jdW1lbnRIaWdobGlnaHRSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIGxpc3QgYWxsIHN5bWJvbHMgZm91bmQgaW4gYSBnaXZlbiB0ZXh0IGRvY3VtZW50LiBUaGUgcmVxdWVzdCdzXG4gKiBwYXJhbWV0ZXIgaXMgb2YgdHlwZSB7QGxpbmsgVGV4dERvY3VtZW50SWRlbnRpZmllcn0gdGhlXG4gKiByZXNwb25zZSBpcyBvZiB0eXBlIHtAbGluayBTeW1ib2xJbmZvcm1hdGlvbiBTeW1ib2xJbmZvcm1hdGlvbltdfSBvciBhIFRoZW5hYmxlXG4gKiB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBEb2N1bWVudFN5bWJvbFJlcXVlc3Q7XG4oZnVuY3Rpb24gKERvY3VtZW50U3ltYm9sUmVxdWVzdCkge1xuICAgIERvY3VtZW50U3ltYm9sUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2RvY3VtZW50U3ltYm9sJztcbiAgICBEb2N1bWVudFN5bWJvbFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEb2N1bWVudFN5bWJvbFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRG9jdW1lbnRTeW1ib2xSZXF1ZXN0Lm1ldGhvZCk7XG59KShEb2N1bWVudFN5bWJvbFJlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50U3ltYm9sUmVxdWVzdCB8fCAoZXhwb3J0cy5Eb2N1bWVudFN5bWJvbFJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcHJvdmlkZSBjb21tYW5kcyBmb3IgdGhlIGdpdmVuIHRleHQgZG9jdW1lbnQgYW5kIHJhbmdlLlxuICovXG52YXIgQ29kZUFjdGlvblJlcXVlc3Q7XG4oZnVuY3Rpb24gKENvZGVBY3Rpb25SZXF1ZXN0KSB7XG4gICAgQ29kZUFjdGlvblJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9jb2RlQWN0aW9uJztcbiAgICBDb2RlQWN0aW9uUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIENvZGVBY3Rpb25SZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKENvZGVBY3Rpb25SZXF1ZXN0Lm1ldGhvZCk7XG59KShDb2RlQWN0aW9uUmVxdWVzdCA9IGV4cG9ydHMuQ29kZUFjdGlvblJlcXVlc3QgfHwgKGV4cG9ydHMuQ29kZUFjdGlvblJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBSZXF1ZXN0IHRvIHJlc29sdmUgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBmb3IgYSBnaXZlbiBjb2RlIGFjdGlvbi5UaGUgcmVxdWVzdCdzXG4gKiBwYXJhbWV0ZXIgaXMgb2YgdHlwZSB7QGxpbmsgQ29kZUFjdGlvbn0gdGhlIHJlc3BvbnNlXG4gKiBpcyBvZiB0eXBlIHtAbGluayBDb2RlQWN0aW9ufSBvciBhIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqL1xudmFyIENvZGVBY3Rpb25SZXNvbHZlUmVxdWVzdDtcbihmdW5jdGlvbiAoQ29kZUFjdGlvblJlc29sdmVSZXF1ZXN0KSB7XG4gICAgQ29kZUFjdGlvblJlc29sdmVSZXF1ZXN0Lm1ldGhvZCA9ICdjb2RlQWN0aW9uL3Jlc29sdmUnO1xuICAgIENvZGVBY3Rpb25SZXNvbHZlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIENvZGVBY3Rpb25SZXNvbHZlUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShDb2RlQWN0aW9uUmVzb2x2ZVJlcXVlc3QubWV0aG9kKTtcbn0pKENvZGVBY3Rpb25SZXNvbHZlUmVxdWVzdCA9IGV4cG9ydHMuQ29kZUFjdGlvblJlc29sdmVSZXF1ZXN0IHx8IChleHBvcnRzLkNvZGVBY3Rpb25SZXNvbHZlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBsaXN0IHByb2plY3Qtd2lkZSBzeW1ib2xzIG1hdGNoaW5nIHRoZSBxdWVyeSBzdHJpbmcgZ2l2ZW5cbiAqIGJ5IHRoZSB7QGxpbmsgV29ya3NwYWNlU3ltYm9sUGFyYW1zfS4gVGhlIHJlc3BvbnNlIGlzXG4gKiBvZiB0eXBlIHtAbGluayBTeW1ib2xJbmZvcm1hdGlvbiBTeW1ib2xJbmZvcm1hdGlvbltdfSBvciBhIFRoZW5hYmxlIHRoYXRcbiAqIHJlc29sdmVzIHRvIHN1Y2guXG4gKlxuICogQHNpbmNlIDMuMTcuMCAtIHN1cHBvcnQgZm9yIFdvcmtzcGFjZVN5bWJvbCBpbiB0aGUgcmV0dXJuZWQgZGF0YS4gQ2xpZW50c1xuICogIG5lZWQgdG8gYWR2ZXJ0aXNlIHN1cHBvcnQgZm9yIFdvcmtzcGFjZVN5bWJvbHMgdmlhIHRoZSBjbGllbnQgY2FwYWJpbGl0eVxuICogIGB3b3Jrc3BhY2Uuc3ltYm9sLnJlc29sdmVTdXBwb3J0YC5cbiAqXG4gKi9cbnZhciBXb3Jrc3BhY2VTeW1ib2xSZXF1ZXN0O1xuKGZ1bmN0aW9uIChXb3Jrc3BhY2VTeW1ib2xSZXF1ZXN0KSB7XG4gICAgV29ya3NwYWNlU3ltYm9sUmVxdWVzdC5tZXRob2QgPSAnd29ya3NwYWNlL3N5bWJvbCc7XG4gICAgV29ya3NwYWNlU3ltYm9sUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFdvcmtzcGFjZVN5bWJvbFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoV29ya3NwYWNlU3ltYm9sUmVxdWVzdC5tZXRob2QpO1xufSkoV29ya3NwYWNlU3ltYm9sUmVxdWVzdCA9IGV4cG9ydHMuV29ya3NwYWNlU3ltYm9sUmVxdWVzdCB8fCAoZXhwb3J0cy5Xb3Jrc3BhY2VTeW1ib2xSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHJlc29sdmUgdGhlIHJhbmdlIGluc2lkZSB0aGUgd29ya3NwYWNlXG4gKiBzeW1ib2wncyBsb2NhdGlvbi5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBXb3Jrc3BhY2VTeW1ib2xSZXNvbHZlUmVxdWVzdDtcbihmdW5jdGlvbiAoV29ya3NwYWNlU3ltYm9sUmVzb2x2ZVJlcXVlc3QpIHtcbiAgICBXb3Jrc3BhY2VTeW1ib2xSZXNvbHZlUmVxdWVzdC5tZXRob2QgPSAnd29ya3NwYWNlU3ltYm9sL3Jlc29sdmUnO1xuICAgIFdvcmtzcGFjZVN5bWJvbFJlc29sdmVSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgV29ya3NwYWNlU3ltYm9sUmVzb2x2ZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoV29ya3NwYWNlU3ltYm9sUmVzb2x2ZVJlcXVlc3QubWV0aG9kKTtcbn0pKFdvcmtzcGFjZVN5bWJvbFJlc29sdmVSZXF1ZXN0ID0gZXhwb3J0cy5Xb3Jrc3BhY2VTeW1ib2xSZXNvbHZlUmVxdWVzdCB8fCAoZXhwb3J0cy5Xb3Jrc3BhY2VTeW1ib2xSZXNvbHZlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBwcm92aWRlIGNvZGUgbGVucyBmb3IgdGhlIGdpdmVuIHRleHQgZG9jdW1lbnQuXG4gKi9cbnZhciBDb2RlTGVuc1JlcXVlc3Q7XG4oZnVuY3Rpb24gKENvZGVMZW5zUmVxdWVzdCkge1xuICAgIENvZGVMZW5zUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2NvZGVMZW5zJztcbiAgICBDb2RlTGVuc1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBDb2RlTGVuc1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoQ29kZUxlbnNSZXF1ZXN0Lm1ldGhvZCk7XG59KShDb2RlTGVuc1JlcXVlc3QgPSBleHBvcnRzLkNvZGVMZW5zUmVxdWVzdCB8fCAoZXhwb3J0cy5Db2RlTGVuc1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVzb2x2ZSBhIGNvbW1hbmQgZm9yIGEgZ2l2ZW4gY29kZSBsZW5zLlxuICovXG52YXIgQ29kZUxlbnNSZXNvbHZlUmVxdWVzdDtcbihmdW5jdGlvbiAoQ29kZUxlbnNSZXNvbHZlUmVxdWVzdCkge1xuICAgIENvZGVMZW5zUmVzb2x2ZVJlcXVlc3QubWV0aG9kID0gJ2NvZGVMZW5zL3Jlc29sdmUnO1xuICAgIENvZGVMZW5zUmVzb2x2ZVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBDb2RlTGVuc1Jlc29sdmVSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKENvZGVMZW5zUmVzb2x2ZVJlcXVlc3QubWV0aG9kKTtcbn0pKENvZGVMZW5zUmVzb2x2ZVJlcXVlc3QgPSBleHBvcnRzLkNvZGVMZW5zUmVzb2x2ZVJlcXVlc3QgfHwgKGV4cG9ydHMuQ29kZUxlbnNSZXNvbHZlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZWZyZXNoIGFsbCBjb2RlIGFjdGlvbnNcbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBDb2RlTGVuc1JlZnJlc2hSZXF1ZXN0O1xuKGZ1bmN0aW9uIChDb2RlTGVuc1JlZnJlc2hSZXF1ZXN0KSB7XG4gICAgQ29kZUxlbnNSZWZyZXNoUmVxdWVzdC5tZXRob2QgPSBgd29ya3NwYWNlL2NvZGVMZW5zL3JlZnJlc2hgO1xuICAgIENvZGVMZW5zUmVmcmVzaFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5zZXJ2ZXJUb0NsaWVudDtcbiAgICBDb2RlTGVuc1JlZnJlc2hSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlMChDb2RlTGVuc1JlZnJlc2hSZXF1ZXN0Lm1ldGhvZCk7XG59KShDb2RlTGVuc1JlZnJlc2hSZXF1ZXN0ID0gZXhwb3J0cy5Db2RlTGVuc1JlZnJlc2hSZXF1ZXN0IHx8IChleHBvcnRzLkNvZGVMZW5zUmVmcmVzaFJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcHJvdmlkZSBkb2N1bWVudCBsaW5rc1xuICovXG52YXIgRG9jdW1lbnRMaW5rUmVxdWVzdDtcbihmdW5jdGlvbiAoRG9jdW1lbnRMaW5rUmVxdWVzdCkge1xuICAgIERvY3VtZW50TGlua1JlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9kb2N1bWVudExpbmsnO1xuICAgIERvY3VtZW50TGlua1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEb2N1bWVudExpbmtSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKERvY3VtZW50TGlua1JlcXVlc3QubWV0aG9kKTtcbn0pKERvY3VtZW50TGlua1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50TGlua1JlcXVlc3QgfHwgKGV4cG9ydHMuRG9jdW1lbnRMaW5rUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFJlcXVlc3QgdG8gcmVzb2x2ZSBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGZvciBhIGdpdmVuIGRvY3VtZW50IGxpbmsuIFRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBEb2N1bWVudExpbmt9IHRoZSByZXNwb25zZVxuICogaXMgb2YgdHlwZSB7QGxpbmsgRG9jdW1lbnRMaW5rfSBvciBhIFRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gc3VjaC5cbiAqL1xudmFyIERvY3VtZW50TGlua1Jlc29sdmVSZXF1ZXN0O1xuKGZ1bmN0aW9uIChEb2N1bWVudExpbmtSZXNvbHZlUmVxdWVzdCkge1xuICAgIERvY3VtZW50TGlua1Jlc29sdmVSZXF1ZXN0Lm1ldGhvZCA9ICdkb2N1bWVudExpbmsvcmVzb2x2ZSc7XG4gICAgRG9jdW1lbnRMaW5rUmVzb2x2ZVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEb2N1bWVudExpbmtSZXNvbHZlUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShEb2N1bWVudExpbmtSZXNvbHZlUmVxdWVzdC5tZXRob2QpO1xufSkoRG9jdW1lbnRMaW5rUmVzb2x2ZVJlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50TGlua1Jlc29sdmVSZXF1ZXN0IHx8IChleHBvcnRzLkRvY3VtZW50TGlua1Jlc29sdmVSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHRvIGZvcm1hdCBhIHdob2xlIGRvY3VtZW50LlxuICovXG52YXIgRG9jdW1lbnRGb3JtYXR0aW5nUmVxdWVzdDtcbihmdW5jdGlvbiAoRG9jdW1lbnRGb3JtYXR0aW5nUmVxdWVzdCkge1xuICAgIERvY3VtZW50Rm9ybWF0dGluZ1JlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9mb3JtYXR0aW5nJztcbiAgICBEb2N1bWVudEZvcm1hdHRpbmdSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRG9jdW1lbnRGb3JtYXR0aW5nUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShEb2N1bWVudEZvcm1hdHRpbmdSZXF1ZXN0Lm1ldGhvZCk7XG59KShEb2N1bWVudEZvcm1hdHRpbmdSZXF1ZXN0ID0gZXhwb3J0cy5Eb2N1bWVudEZvcm1hdHRpbmdSZXF1ZXN0IHx8IChleHBvcnRzLkRvY3VtZW50Rm9ybWF0dGluZ1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gdG8gZm9ybWF0IGEgcmFuZ2UgaW4gYSBkb2N1bWVudC5cbiAqL1xudmFyIERvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUmVxdWVzdDtcbihmdW5jdGlvbiAoRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdSZXF1ZXN0KSB7XG4gICAgRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvcmFuZ2VGb3JtYXR0aW5nJztcbiAgICBEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdSZXF1ZXN0Lm1ldGhvZCk7XG59KShEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QgPSBleHBvcnRzLkRvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUmVxdWVzdCB8fCAoZXhwb3J0cy5Eb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gZm9ybWF0IGEgZG9jdW1lbnQgb24gdHlwZS5cbiAqL1xudmFyIERvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3Q7XG4oZnVuY3Rpb24gKERvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3QpIHtcbiAgICBEb2N1bWVudE9uVHlwZUZvcm1hdHRpbmdSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvb25UeXBlRm9ybWF0dGluZyc7XG4gICAgRG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nUmVxdWVzdC5tZXRob2QpO1xufSkoRG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nUmVxdWVzdCA9IGV4cG9ydHMuRG9jdW1lbnRPblR5cGVGb3JtYXR0aW5nUmVxdWVzdCB8fCAoZXhwb3J0cy5Eb2N1bWVudE9uVHlwZUZvcm1hdHRpbmdSZXF1ZXN0ID0ge30pKTtcbi8vLS0tLSBSZW5hbWUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIFByZXBhcmVTdXBwb3J0RGVmYXVsdEJlaGF2aW9yO1xuKGZ1bmN0aW9uIChQcmVwYXJlU3VwcG9ydERlZmF1bHRCZWhhdmlvcikge1xuICAgIC8qKlxuICAgICAqIFRoZSBjbGllbnQncyBkZWZhdWx0IGJlaGF2aW9yIGlzIHRvIHNlbGVjdCB0aGUgaWRlbnRpZmllclxuICAgICAqIGFjY29yZGluZyB0aGUgdG8gbGFuZ3VhZ2UncyBzeW50YXggcnVsZS5cbiAgICAgKi9cbiAgICBQcmVwYXJlU3VwcG9ydERlZmF1bHRCZWhhdmlvci5JZGVudGlmaWVyID0gMTtcbn0pKFByZXBhcmVTdXBwb3J0RGVmYXVsdEJlaGF2aW9yID0gZXhwb3J0cy5QcmVwYXJlU3VwcG9ydERlZmF1bHRCZWhhdmlvciB8fCAoZXhwb3J0cy5QcmVwYXJlU3VwcG9ydERlZmF1bHRCZWhhdmlvciA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZW5hbWUgYSBzeW1ib2wuXG4gKi9cbnZhciBSZW5hbWVSZXF1ZXN0O1xuKGZ1bmN0aW9uIChSZW5hbWVSZXF1ZXN0KSB7XG4gICAgUmVuYW1lUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3JlbmFtZSc7XG4gICAgUmVuYW1lUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFJlbmFtZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoUmVuYW1lUmVxdWVzdC5tZXRob2QpO1xufSkoUmVuYW1lUmVxdWVzdCA9IGV4cG9ydHMuUmVuYW1lUmVxdWVzdCB8fCAoZXhwb3J0cy5SZW5hbWVSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHRlc3QgYW5kIHBlcmZvcm0gdGhlIHNldHVwIG5lY2Vzc2FyeSBmb3IgYSByZW5hbWUuXG4gKlxuICogQHNpbmNlIDMuMTYgLSBzdXBwb3J0IGZvciBkZWZhdWx0IGJlaGF2aW9yXG4gKi9cbnZhciBQcmVwYXJlUmVuYW1lUmVxdWVzdDtcbihmdW5jdGlvbiAoUHJlcGFyZVJlbmFtZVJlcXVlc3QpIHtcbiAgICBQcmVwYXJlUmVuYW1lUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3ByZXBhcmVSZW5hbWUnO1xuICAgIFByZXBhcmVSZW5hbWVSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgUHJlcGFyZVJlbmFtZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoUHJlcGFyZVJlbmFtZVJlcXVlc3QubWV0aG9kKTtcbn0pKFByZXBhcmVSZW5hbWVSZXF1ZXN0ID0gZXhwb3J0cy5QcmVwYXJlUmVuYW1lUmVxdWVzdCB8fCAoZXhwb3J0cy5QcmVwYXJlUmVuYW1lUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCBzZW5kIGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHRvIGV4ZWN1dGUgYSBjb21tYW5kLiBUaGUgcmVxdWVzdCBtaWdodCByZXR1cm5cbiAqIGEgd29ya3NwYWNlIGVkaXQgd2hpY2ggdGhlIGNsaWVudCB3aWxsIGFwcGx5IHRvIHRoZSB3b3Jrc3BhY2UuXG4gKi9cbnZhciBFeGVjdXRlQ29tbWFuZFJlcXVlc3Q7XG4oZnVuY3Rpb24gKEV4ZWN1dGVDb21tYW5kUmVxdWVzdCkge1xuICAgIEV4ZWN1dGVDb21tYW5kUmVxdWVzdC5tZXRob2QgPSAnd29ya3NwYWNlL2V4ZWN1dGVDb21tYW5kJztcbiAgICBFeGVjdXRlQ29tbWFuZFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBFeGVjdXRlQ29tbWFuZFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoRXhlY3V0ZUNvbW1hbmRSZXF1ZXN0Lm1ldGhvZCk7XG59KShFeGVjdXRlQ29tbWFuZFJlcXVlc3QgPSBleHBvcnRzLkV4ZWN1dGVDb21tYW5kUmVxdWVzdCB8fCAoZXhwb3J0cy5FeGVjdXRlQ29tbWFuZFJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBBIHJlcXVlc3Qgc2VudCBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudCB0byBtb2RpZmllZCBjZXJ0YWluIHJlc291cmNlcy5cbiAqL1xudmFyIEFwcGx5V29ya3NwYWNlRWRpdFJlcXVlc3Q7XG4oZnVuY3Rpb24gKEFwcGx5V29ya3NwYWNlRWRpdFJlcXVlc3QpIHtcbiAgICBBcHBseVdvcmtzcGFjZUVkaXRSZXF1ZXN0Lm1ldGhvZCA9ICd3b3Jrc3BhY2UvYXBwbHlFZGl0JztcbiAgICBBcHBseVdvcmtzcGFjZUVkaXRSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uc2VydmVyVG9DbGllbnQ7XG4gICAgQXBwbHlXb3Jrc3BhY2VFZGl0UmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZSgnd29ya3NwYWNlL2FwcGx5RWRpdCcpO1xufSkoQXBwbHlXb3Jrc3BhY2VFZGl0UmVxdWVzdCA9IGV4cG9ydHMuQXBwbHlXb3Jrc3BhY2VFZGl0UmVxdWVzdCB8fCAoZXhwb3J0cy5BcHBseVdvcmtzcGFjZUVkaXRSZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjI0OTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkxpbmtlZEVkaXRpbmdSYW5nZVJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHByb3ZpZGUgcmFuZ2VzIHRoYXQgY2FuIGJlIGVkaXRlZCB0b2dldGhlci5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBMaW5rZWRFZGl0aW5nUmFuZ2VSZXF1ZXN0O1xuKGZ1bmN0aW9uIChMaW5rZWRFZGl0aW5nUmFuZ2VSZXF1ZXN0KSB7XG4gICAgTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L2xpbmtlZEVkaXRpbmdSYW5nZSc7XG4gICAgTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIExpbmtlZEVkaXRpbmdSYW5nZVJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdC5tZXRob2QpO1xufSkoTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdCA9IGV4cG9ydHMuTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdCB8fCAoZXhwb3J0cy5MaW5rZWRFZGl0aW5nUmFuZ2VSZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzY4NDpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5Nb25pa2VyUmVxdWVzdCA9IGV4cG9ydHMuTW9uaWtlcktpbmQgPSBleHBvcnRzLlVuaXF1ZW5lc3NMZXZlbCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuLyoqXG4gKiBNb25pa2VyIHVuaXF1ZW5lc3MgbGV2ZWwgdG8gZGVmaW5lIHNjb3BlIG9mIHRoZSBtb25pa2VyLlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIFVuaXF1ZW5lc3NMZXZlbDtcbihmdW5jdGlvbiAoVW5pcXVlbmVzc0xldmVsKSB7XG4gICAgLyoqXG4gICAgICogVGhlIG1vbmlrZXIgaXMgb25seSB1bmlxdWUgaW5zaWRlIGEgZG9jdW1lbnRcbiAgICAgKi9cbiAgICBVbmlxdWVuZXNzTGV2ZWwuZG9jdW1lbnQgPSAnZG9jdW1lbnQnO1xuICAgIC8qKlxuICAgICAqIFRoZSBtb25pa2VyIGlzIHVuaXF1ZSBpbnNpZGUgYSBwcm9qZWN0IGZvciB3aGljaCBhIGR1bXAgZ290IGNyZWF0ZWRcbiAgICAgKi9cbiAgICBVbmlxdWVuZXNzTGV2ZWwucHJvamVjdCA9ICdwcm9qZWN0JztcbiAgICAvKipcbiAgICAgKiBUaGUgbW9uaWtlciBpcyB1bmlxdWUgaW5zaWRlIHRoZSBncm91cCB0byB3aGljaCBhIHByb2plY3QgYmVsb25nc1xuICAgICAqL1xuICAgIFVuaXF1ZW5lc3NMZXZlbC5ncm91cCA9ICdncm91cCc7XG4gICAgLyoqXG4gICAgICogVGhlIG1vbmlrZXIgaXMgdW5pcXVlIGluc2lkZSB0aGUgbW9uaWtlciBzY2hlbWUuXG4gICAgICovXG4gICAgVW5pcXVlbmVzc0xldmVsLnNjaGVtZSA9ICdzY2hlbWUnO1xuICAgIC8qKlxuICAgICAqIFRoZSBtb25pa2VyIGlzIGdsb2JhbGx5IHVuaXF1ZVxuICAgICAqL1xuICAgIFVuaXF1ZW5lc3NMZXZlbC5nbG9iYWwgPSAnZ2xvYmFsJztcbn0pKFVuaXF1ZW5lc3NMZXZlbCA9IGV4cG9ydHMuVW5pcXVlbmVzc0xldmVsIHx8IChleHBvcnRzLlVuaXF1ZW5lc3NMZXZlbCA9IHt9KSk7XG4vKipcbiAqIFRoZSBtb25pa2VyIGtpbmQuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgTW9uaWtlcktpbmQ7XG4oZnVuY3Rpb24gKE1vbmlrZXJLaW5kKSB7XG4gICAgLyoqXG4gICAgICogVGhlIG1vbmlrZXIgcmVwcmVzZW50IGEgc3ltYm9sIHRoYXQgaXMgaW1wb3J0ZWQgaW50byBhIHByb2plY3RcbiAgICAgKi9cbiAgICBNb25pa2VyS2luZC4kaW1wb3J0ID0gJ2ltcG9ydCc7XG4gICAgLyoqXG4gICAgICogVGhlIG1vbmlrZXIgcmVwcmVzZW50cyBhIHN5bWJvbCB0aGF0IGlzIGV4cG9ydGVkIGZyb20gYSBwcm9qZWN0XG4gICAgICovXG4gICAgTW9uaWtlcktpbmQuJGV4cG9ydCA9ICdleHBvcnQnO1xuICAgIC8qKlxuICAgICAqIFRoZSBtb25pa2VyIHJlcHJlc2VudHMgYSBzeW1ib2wgdGhhdCBpcyBsb2NhbCB0byBhIHByb2plY3QgKGUuZy4gYSBsb2NhbFxuICAgICAqIHZhcmlhYmxlIG9mIGEgZnVuY3Rpb24sIGEgY2xhc3Mgbm90IHZpc2libGUgb3V0c2lkZSB0aGUgcHJvamVjdCwgLi4uKVxuICAgICAqL1xuICAgIE1vbmlrZXJLaW5kLmxvY2FsID0gJ2xvY2FsJztcbn0pKE1vbmlrZXJLaW5kID0gZXhwb3J0cy5Nb25pa2VyS2luZCB8fCAoZXhwb3J0cy5Nb25pa2VyS2luZCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byBnZXQgdGhlIG1vbmlrZXIgb2YgYSBzeW1ib2wgYXQgYSBnaXZlbiB0ZXh0IGRvY3VtZW50IHBvc2l0aW9uLlxuICogVGhlIHJlcXVlc3QgcGFyYW1ldGVyIGlzIG9mIHR5cGUge0BsaW5rIFRleHREb2N1bWVudFBvc2l0aW9uUGFyYW1zfS5cbiAqIFRoZSByZXNwb25zZSBpcyBvZiB0eXBlIHtAbGluayBNb25pa2VyIE1vbmlrZXJbXX0gb3IgYG51bGxgLlxuICovXG52YXIgTW9uaWtlclJlcXVlc3Q7XG4oZnVuY3Rpb24gKE1vbmlrZXJSZXF1ZXN0KSB7XG4gICAgTW9uaWtlclJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9tb25pa2VyJztcbiAgICBNb25pa2VyUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIE1vbmlrZXJSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKE1vbmlrZXJSZXF1ZXN0Lm1ldGhvZCk7XG59KShNb25pa2VyUmVxdWVzdCA9IGV4cG9ydHMuTW9uaWtlclJlcXVlc3QgfHwgKGV4cG9ydHMuTW9uaWtlclJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0NzkyOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLkRpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkU2F2ZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLk5vdGVib29rQ2VsbEFycmF5Q2hhbmdlID0gZXhwb3J0cy5EaWRPcGVuTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlID0gZXhwb3J0cy5Ob3RlYm9va0RvY3VtZW50ID0gZXhwb3J0cy5Ob3RlYm9va0NlbGwgPSBleHBvcnRzLkV4ZWN1dGlvblN1bW1hcnkgPSBleHBvcnRzLk5vdGVib29rQ2VsbEtpbmQgPSB2b2lkIDA7XG5jb25zdCB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfdHlwZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNzcxNyk7XG5jb25zdCBJcyA9IF9fd2VicGFja19yZXF1aXJlX18oODYzMyk7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8qKlxuICogQSBub3RlYm9vayBjZWxsIGtpbmQuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgTm90ZWJvb2tDZWxsS2luZDtcbihmdW5jdGlvbiAoTm90ZWJvb2tDZWxsS2luZCkge1xuICAgIC8qKlxuICAgICAqIEEgbWFya3VwLWNlbGwgaXMgZm9ybWF0dGVkIHNvdXJjZSB0aGF0IGlzIHVzZWQgZm9yIGRpc3BsYXkuXG4gICAgICovXG4gICAgTm90ZWJvb2tDZWxsS2luZC5NYXJrdXAgPSAxO1xuICAgIC8qKlxuICAgICAqIEEgY29kZS1jZWxsIGlzIHNvdXJjZSBjb2RlLlxuICAgICAqL1xuICAgIE5vdGVib29rQ2VsbEtpbmQuQ29kZSA9IDI7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSAxIHx8IHZhbHVlID09PSAyO1xuICAgIH1cbiAgICBOb3RlYm9va0NlbGxLaW5kLmlzID0gaXM7XG59KShOb3RlYm9va0NlbGxLaW5kID0gZXhwb3J0cy5Ob3RlYm9va0NlbGxLaW5kIHx8IChleHBvcnRzLk5vdGVib29rQ2VsbEtpbmQgPSB7fSkpO1xudmFyIEV4ZWN1dGlvblN1bW1hcnk7XG4oZnVuY3Rpb24gKEV4ZWN1dGlvblN1bW1hcnkpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUoZXhlY3V0aW9uT3JkZXIsIHN1Y2Nlc3MpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0geyBleGVjdXRpb25PcmRlciB9O1xuICAgICAgICBpZiAoc3VjY2VzcyA9PT0gdHJ1ZSB8fCBzdWNjZXNzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmVzdWx0LnN1Y2Nlc3MgPSBzdWNjZXNzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIEV4ZWN1dGlvblN1bW1hcnkuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIHZzY29kZV9sYW5ndWFnZXNlcnZlcl90eXBlc18xLnVpbnRlZ2VyLmlzKGNhbmRpZGF0ZS5leGVjdXRpb25PcmRlcikgJiYgKGNhbmRpZGF0ZS5zdWNjZXNzID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUuc3VjY2VzcykpO1xuICAgIH1cbiAgICBFeGVjdXRpb25TdW1tYXJ5LmlzID0gaXM7XG4gICAgZnVuY3Rpb24gZXF1YWxzKG9uZSwgb3RoZXIpIHtcbiAgICAgICAgaWYgKG9uZSA9PT0gb3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbmUgPT09IG51bGwgfHwgb25lID09PSB1bmRlZmluZWQgfHwgb3RoZXIgPT09IG51bGwgfHwgb3RoZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvbmUuZXhlY3V0aW9uT3JkZXIgPT09IG90aGVyLmV4ZWN1dGlvbk9yZGVyICYmIG9uZS5zdWNjZXNzID09PSBvdGhlci5zdWNjZXNzO1xuICAgIH1cbiAgICBFeGVjdXRpb25TdW1tYXJ5LmVxdWFscyA9IGVxdWFscztcbn0pKEV4ZWN1dGlvblN1bW1hcnkgPSBleHBvcnRzLkV4ZWN1dGlvblN1bW1hcnkgfHwgKGV4cG9ydHMuRXhlY3V0aW9uU3VtbWFyeSA9IHt9KSk7XG52YXIgTm90ZWJvb2tDZWxsO1xuKGZ1bmN0aW9uIChOb3RlYm9va0NlbGwpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUoa2luZCwgZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHsga2luZCwgZG9jdW1lbnQgfTtcbiAgICB9XG4gICAgTm90ZWJvb2tDZWxsLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBOb3RlYm9va0NlbGxLaW5kLmlzKGNhbmRpZGF0ZS5raW5kKSAmJiB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfdHlwZXNfMS5Eb2N1bWVudFVyaS5pcyhjYW5kaWRhdGUuZG9jdW1lbnQpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLm1ldGFkYXRhID09PSB1bmRlZmluZWQgfHwgSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUubWV0YWRhdGEpKTtcbiAgICB9XG4gICAgTm90ZWJvb2tDZWxsLmlzID0gaXM7XG4gICAgZnVuY3Rpb24gZGlmZihvbmUsIHR3bykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgU2V0KCk7XG4gICAgICAgIGlmIChvbmUuZG9jdW1lbnQgIT09IHR3by5kb2N1bWVudCkge1xuICAgICAgICAgICAgcmVzdWx0LmFkZCgnZG9jdW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25lLmtpbmQgIT09IHR3by5raW5kKSB7XG4gICAgICAgICAgICByZXN1bHQuYWRkKCdraW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uZS5leGVjdXRpb25TdW1tYXJ5ICE9PSB0d28uZXhlY3V0aW9uU3VtbWFyeSkge1xuICAgICAgICAgICAgcmVzdWx0LmFkZCgnZXhlY3V0aW9uU3VtbWFyeScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgob25lLm1ldGFkYXRhICE9PSB1bmRlZmluZWQgfHwgdHdvLm1ldGFkYXRhICE9PSB1bmRlZmluZWQpICYmICFlcXVhbHNNZXRhZGF0YShvbmUubWV0YWRhdGEsIHR3by5tZXRhZGF0YSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hZGQoJ21ldGFkYXRhJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChvbmUuZXhlY3V0aW9uU3VtbWFyeSAhPT0gdW5kZWZpbmVkIHx8IHR3by5leGVjdXRpb25TdW1tYXJ5ICE9PSB1bmRlZmluZWQpICYmICFFeGVjdXRpb25TdW1tYXJ5LmVxdWFscyhvbmUuZXhlY3V0aW9uU3VtbWFyeSwgdHdvLmV4ZWN1dGlvblN1bW1hcnkpKSB7XG4gICAgICAgICAgICByZXN1bHQuYWRkKCdleGVjdXRpb25TdW1tYXJ5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgTm90ZWJvb2tDZWxsLmRpZmYgPSBkaWZmO1xuICAgIGZ1bmN0aW9uIGVxdWFsc01ldGFkYXRhKG9uZSwgb3RoZXIpIHtcbiAgICAgICAgaWYgKG9uZSA9PT0gb3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbmUgPT09IG51bGwgfHwgb25lID09PSB1bmRlZmluZWQgfHwgb3RoZXIgPT09IG51bGwgfHwgb3RoZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb25lICE9PSB0eXBlb2Ygb3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9uZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbmVBcnJheSA9IEFycmF5LmlzQXJyYXkob25lKTtcbiAgICAgICAgY29uc3Qgb3RoZXJBcnJheSA9IEFycmF5LmlzQXJyYXkob3RoZXIpO1xuICAgICAgICBpZiAob25lQXJyYXkgIT09IG90aGVyQXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25lQXJyYXkgJiYgb3RoZXJBcnJheSkge1xuICAgICAgICAgICAgaWYgKG9uZS5sZW5ndGggIT09IG90aGVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb25lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlcXVhbHNNZXRhZGF0YShvbmVbaV0sIG90aGVyW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChJcy5vYmplY3RMaXRlcmFsKG9uZSkgJiYgSXMub2JqZWN0TGl0ZXJhbChvdGhlcikpIHtcbiAgICAgICAgICAgIGNvbnN0IG9uZUtleXMgPSBPYmplY3Qua2V5cyhvbmUpO1xuICAgICAgICAgICAgY29uc3Qgb3RoZXJLZXlzID0gT2JqZWN0LmtleXMob3RoZXIpO1xuICAgICAgICAgICAgaWYgKG9uZUtleXMubGVuZ3RoICE9PSBvdGhlcktleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25lS2V5cy5zb3J0KCk7XG4gICAgICAgICAgICBvdGhlcktleXMuc29ydCgpO1xuICAgICAgICAgICAgaWYgKCFlcXVhbHNNZXRhZGF0YShvbmVLZXlzLCBvdGhlcktleXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvbmVLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcCA9IG9uZUtleXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKCFlcXVhbHNNZXRhZGF0YShvbmVbcHJvcF0sIG90aGVyW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn0pKE5vdGVib29rQ2VsbCA9IGV4cG9ydHMuTm90ZWJvb2tDZWxsIHx8IChleHBvcnRzLk5vdGVib29rQ2VsbCA9IHt9KSk7XG52YXIgTm90ZWJvb2tEb2N1bWVudDtcbihmdW5jdGlvbiAoTm90ZWJvb2tEb2N1bWVudCkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIG5vdGVib29rVHlwZSwgdmVyc2lvbiwgY2VsbHMpIHtcbiAgICAgICAgcmV0dXJuIHsgdXJpLCBub3RlYm9va1R5cGUsIHZlcnNpb24sIGNlbGxzIH07XG4gICAgfVxuICAgIE5vdGVib29rRG9jdW1lbnQuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfdHlwZXNfMS5pbnRlZ2VyLmlzKGNhbmRpZGF0ZS52ZXJzaW9uKSAmJiBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5jZWxscywgTm90ZWJvb2tDZWxsLmlzKTtcbiAgICB9XG4gICAgTm90ZWJvb2tEb2N1bWVudC5pcyA9IGlzO1xufSkoTm90ZWJvb2tEb2N1bWVudCA9IGV4cG9ydHMuTm90ZWJvb2tEb2N1bWVudCB8fCAoZXhwb3J0cy5Ob3RlYm9va0RvY3VtZW50ID0ge30pKTtcbnZhciBOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGU7XG4oZnVuY3Rpb24gKE5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZSkge1xuICAgIE5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZS5tZXRob2QgPSAnbm90ZWJvb2tEb2N1bWVudC9zeW5jJztcbiAgICBOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUudHlwZSA9IG5ldyBtZXNzYWdlc18xLlJlZ2lzdHJhdGlvblR5cGUoTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZCk7XG59KShOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUgPSBleHBvcnRzLk5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZSB8fCAoZXhwb3J0cy5Ob3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUgPSB7fSkpO1xuLyoqXG4gKiBBIG5vdGlmaWNhdGlvbiBzZW50IHdoZW4gYSBub3RlYm9vayBvcGVucy5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBEaWRPcGVuTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbjtcbihmdW5jdGlvbiAoRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24pIHtcbiAgICBEaWRPcGVuTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QgPSAnbm90ZWJvb2tEb2N1bWVudC9kaWRPcGVuJztcbiAgICBEaWRPcGVuTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kKTtcbiAgICBEaWRPcGVuTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5yZWdpc3RyYXRpb25NZXRob2QgPSBOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUubWV0aG9kO1xufSkoRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkRpZE9wZW5Ob3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0ge30pKTtcbnZhciBOb3RlYm9va0NlbGxBcnJheUNoYW5nZTtcbihmdW5jdGlvbiAoTm90ZWJvb2tDZWxsQXJyYXlDaGFuZ2UpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiB2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfdHlwZXNfMS51aW50ZWdlci5pcyhjYW5kaWRhdGUuc3RhcnQpICYmIHZzY29kZV9sYW5ndWFnZXNlcnZlcl90eXBlc18xLnVpbnRlZ2VyLmlzKGNhbmRpZGF0ZS5kZWxldGVDb3VudCkgJiYgKGNhbmRpZGF0ZS5jZWxscyA9PT0gdW5kZWZpbmVkIHx8IElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLmNlbGxzLCBOb3RlYm9va0NlbGwuaXMpKTtcbiAgICB9XG4gICAgTm90ZWJvb2tDZWxsQXJyYXlDaGFuZ2UuaXMgPSBpcztcbiAgICBmdW5jdGlvbiBjcmVhdGUoc3RhcnQsIGRlbGV0ZUNvdW50LCBjZWxscykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7IHN0YXJ0LCBkZWxldGVDb3VudCB9O1xuICAgICAgICBpZiAoY2VsbHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmNlbGxzID0gY2VsbHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgTm90ZWJvb2tDZWxsQXJyYXlDaGFuZ2UuY3JlYXRlID0gY3JlYXRlO1xufSkoTm90ZWJvb2tDZWxsQXJyYXlDaGFuZ2UgPSBleHBvcnRzLk5vdGVib29rQ2VsbEFycmF5Q2hhbmdlIHx8IChleHBvcnRzLk5vdGVib29rQ2VsbEFycmF5Q2hhbmdlID0ge30pKTtcbnZhciBEaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uKSB7XG4gICAgRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QgPSAnbm90ZWJvb2tEb2N1bWVudC9kaWRDaGFuZ2UnO1xuICAgIERpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBEaWRDaGFuZ2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xuICAgIERpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24ucmVnaXN0cmF0aW9uTWV0aG9kID0gTm90ZWJvb2tEb2N1bWVudFN5bmNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZDtcbn0pKERpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSBleHBvcnRzLkRpZENoYW5nZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IHt9KSk7XG4vKipcbiAqIEEgbm90aWZpY2F0aW9uIHNlbnQgd2hlbiBhIG5vdGVib29rIGRvY3VtZW50IGlzIHNhdmVkLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIERpZFNhdmVOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbikge1xuICAgIERpZFNhdmVOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLm1ldGhvZCA9ICdub3RlYm9va0RvY3VtZW50L2RpZFNhdmUnO1xuICAgIERpZFNhdmVOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgRGlkU2F2ZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShEaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xuICAgIERpZFNhdmVOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uLnJlZ2lzdHJhdGlvbk1ldGhvZCA9IE5vdGVib29rRG9jdW1lbnRTeW5jUmVnaXN0cmF0aW9uVHlwZS5tZXRob2Q7XG59KShEaWRTYXZlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuRGlkU2F2ZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkU2F2ZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBBIG5vdGlmaWNhdGlvbiBzZW50IHdoZW4gYSBub3RlYm9vayBjbG9zZXMuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uO1xuKGZ1bmN0aW9uIChEaWRDbG9zZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24pIHtcbiAgICBEaWRDbG9zZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24ubWV0aG9kID0gJ25vdGVib29rRG9jdW1lbnQvZGlkQ2xvc2UnO1xuICAgIERpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xOb3RpZmljYXRpb25UeXBlKERpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5tZXRob2QpO1xuICAgIERpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbi5yZWdpc3RyYXRpb25NZXRob2QgPSBOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUubWV0aG9kO1xufSkoRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRDbG9zZU5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24gfHwgKGV4cG9ydHMuRGlkQ2xvc2VOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDE2Njpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzQ2FuY2VsTm90aWZpY2F0aW9uID0gZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzQ3JlYXRlUmVxdWVzdCA9IGV4cG9ydHMuV29ya0RvbmVQcm9ncmVzcyA9IHZvaWQgMDtcbmNvbnN0IHZzY29kZV9qc29ucnBjXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkxMTApO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODQzMSk7XG52YXIgV29ya0RvbmVQcm9ncmVzcztcbihmdW5jdGlvbiAoV29ya0RvbmVQcm9ncmVzcykge1xuICAgIFdvcmtEb25lUHJvZ3Jlc3MudHlwZSA9IG5ldyB2c2NvZGVfanNvbnJwY18xLlByb2dyZXNzVHlwZSgpO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gV29ya0RvbmVQcm9ncmVzcy50eXBlO1xuICAgIH1cbiAgICBXb3JrRG9uZVByb2dyZXNzLmlzID0gaXM7XG59KShXb3JrRG9uZVByb2dyZXNzID0gZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzIHx8IChleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3MgPSB7fSkpO1xuLyoqXG4gKiBUaGUgYHdpbmRvdy93b3JrRG9uZVByb2dyZXNzL2NyZWF0ZWAgcmVxdWVzdCBpcyBzZW50IGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50IHRvIGluaXRpYXRlIHByb2dyZXNzXG4gKiByZXBvcnRpbmcgZnJvbSB0aGUgc2VydmVyLlxuICovXG52YXIgV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3Q7XG4oZnVuY3Rpb24gKFdvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0KSB7XG4gICAgV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3QubWV0aG9kID0gJ3dpbmRvdy93b3JrRG9uZVByb2dyZXNzL2NyZWF0ZSc7XG4gICAgV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5zZXJ2ZXJUb0NsaWVudDtcbiAgICBXb3JrRG9uZVByb2dyZXNzQ3JlYXRlUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShXb3JrRG9uZVByb2dyZXNzQ3JlYXRlUmVxdWVzdC5tZXRob2QpO1xufSkoV29ya0RvbmVQcm9ncmVzc0NyZWF0ZVJlcXVlc3QgPSBleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0IHx8IChleHBvcnRzLldvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogVGhlIGB3aW5kb3cvd29ya0RvbmVQcm9ncmVzcy9jYW5jZWxgIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gIHRoZSBjbGllbnQgdG8gdGhlIHNlcnZlciB0byBjYW5jZWwgYSBwcm9ncmVzc1xuICogaW5pdGlhdGVkIG9uIHRoZSBzZXJ2ZXIgc2lkZS5cbiAqL1xudmFyIFdvcmtEb25lUHJvZ3Jlc3NDYW5jZWxOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKFdvcmtEb25lUHJvZ3Jlc3NDYW5jZWxOb3RpZmljYXRpb24pIHtcbiAgICBXb3JrRG9uZVByb2dyZXNzQ2FuY2VsTm90aWZpY2F0aW9uLm1ldGhvZCA9ICd3aW5kb3cvd29ya0RvbmVQcm9ncmVzcy9jYW5jZWwnO1xuICAgIFdvcmtEb25lUHJvZ3Jlc3NDYW5jZWxOb3RpZmljYXRpb24ubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBXb3JrRG9uZVByb2dyZXNzQ2FuY2VsTm90aWZpY2F0aW9uLnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbE5vdGlmaWNhdGlvblR5cGUoV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvbi5tZXRob2QpO1xufSkoV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvbiA9IGV4cG9ydHMuV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvbiB8fCAoZXhwb3J0cy5Xb3JrRG9uZVByb2dyZXNzQ2FuY2VsTm90aWZpY2F0aW9uID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTUzMDpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLlNlbGVjdGlvblJhbmdlUmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcHJvdmlkZSBzZWxlY3Rpb24gcmFuZ2VzIGluIGEgZG9jdW1lbnQuIFRoZSByZXF1ZXN0J3NcbiAqIHBhcmFtZXRlciBpcyBvZiB0eXBlIHtAbGluayBTZWxlY3Rpb25SYW5nZVBhcmFtc30sIHRoZVxuICogcmVzcG9uc2UgaXMgb2YgdHlwZSB7QGxpbmsgU2VsZWN0aW9uUmFuZ2UgU2VsZWN0aW9uUmFuZ2VbXX0gb3IgYSBUaGVuYWJsZVxuICogdGhhdCByZXNvbHZlcyB0byBzdWNoLlxuICovXG52YXIgU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0O1xuKGZ1bmN0aW9uIChTZWxlY3Rpb25SYW5nZVJlcXVlc3QpIHtcbiAgICBTZWxlY3Rpb25SYW5nZVJlcXVlc3QubWV0aG9kID0gJ3RleHREb2N1bWVudC9zZWxlY3Rpb25SYW5nZSc7XG4gICAgU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFNlbGVjdGlvblJhbmdlUmVxdWVzdC5tZXRob2QpO1xufSkoU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0ID0gZXhwb3J0cy5TZWxlY3Rpb25SYW5nZVJlcXVlc3QgfHwgKGV4cG9ydHMuU2VsZWN0aW9uUmFuZ2VSZXF1ZXN0ID0ge30pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjA2Nzpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xuZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JlZnJlc2hSZXF1ZXN0ID0gZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdCA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3QgPSBleHBvcnRzLlNlbWFudGljVG9rZW5zUmVxdWVzdCA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlID0gZXhwb3J0cy5Ub2tlbkZvcm1hdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuLy8tLS0tLS0tICd0ZXh0RG9jdW1lbnQvc2VtYW50aWNUb2tlbnMnIC0tLS0tXG52YXIgVG9rZW5Gb3JtYXQ7XG4oZnVuY3Rpb24gKFRva2VuRm9ybWF0KSB7XG4gICAgVG9rZW5Gb3JtYXQuUmVsYXRpdmUgPSAncmVsYXRpdmUnO1xufSkoVG9rZW5Gb3JtYXQgPSBleHBvcnRzLlRva2VuRm9ybWF0IHx8IChleHBvcnRzLlRva2VuRm9ybWF0ID0ge30pKTtcbnZhciBTZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGU7XG4oZnVuY3Rpb24gKFNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZSkge1xuICAgIFNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZS5tZXRob2QgPSAndGV4dERvY3VtZW50L3NlbWFudGljVG9rZW5zJztcbiAgICBTZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGUudHlwZSA9IG5ldyBtZXNzYWdlc18xLlJlZ2lzdHJhdGlvblR5cGUoU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZCk7XG59KShTZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGUgPSBleHBvcnRzLlNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZSB8fCAoZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGUgPSB7fSkpO1xuLyoqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBTZW1hbnRpY1Rva2Vuc1JlcXVlc3Q7XG4oZnVuY3Rpb24gKFNlbWFudGljVG9rZW5zUmVxdWVzdCkge1xuICAgIFNlbWFudGljVG9rZW5zUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3NlbWFudGljVG9rZW5zL2Z1bGwnO1xuICAgIFNlbWFudGljVG9rZW5zUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFNlbWFudGljVG9rZW5zUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShTZW1hbnRpY1Rva2Vuc1JlcXVlc3QubWV0aG9kKTtcbiAgICBTZW1hbnRpY1Rva2Vuc1JlcXVlc3QucmVnaXN0cmF0aW9uTWV0aG9kID0gU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZDtcbn0pKFNlbWFudGljVG9rZW5zUmVxdWVzdCA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnNSZXF1ZXN0IHx8IChleHBvcnRzLlNlbWFudGljVG9rZW5zUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIFNlbWFudGljVG9rZW5zRGVsdGFSZXF1ZXN0O1xuKGZ1bmN0aW9uIChTZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdCkge1xuICAgIFNlbWFudGljVG9rZW5zRGVsdGFSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvc2VtYW50aWNUb2tlbnMvZnVsbC9kZWx0YSc7XG4gICAgU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBTZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShTZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdC5tZXRob2QpO1xuICAgIFNlbWFudGljVG9rZW5zRGVsdGFSZXF1ZXN0LnJlZ2lzdHJhdGlvbk1ldGhvZCA9IFNlbWFudGljVG9rZW5zUmVnaXN0cmF0aW9uVHlwZS5tZXRob2Q7XG59KShTZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdCA9IGV4cG9ydHMuU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3QgfHwgKGV4cG9ydHMuU2VtYW50aWNUb2tlbnNEZWx0YVJlcXVlc3QgPSB7fSkpO1xuLyoqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBTZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdDtcbihmdW5jdGlvbiAoU2VtYW50aWNUb2tlbnNSYW5nZVJlcXVlc3QpIHtcbiAgICBTZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3NlbWFudGljVG9rZW5zL3JhbmdlJztcbiAgICBTZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFNlbWFudGljVG9rZW5zUmFuZ2VSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFNlbWFudGljVG9rZW5zUmFuZ2VSZXF1ZXN0Lm1ldGhvZCk7XG4gICAgU2VtYW50aWNUb2tlbnNSYW5nZVJlcXVlc3QucmVnaXN0cmF0aW9uTWV0aG9kID0gU2VtYW50aWNUb2tlbnNSZWdpc3RyYXRpb25UeXBlLm1ldGhvZDtcbn0pKFNlbWFudGljVG9rZW5zUmFuZ2VSZXF1ZXN0ID0gZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdCB8fCAoZXhwb3J0cy5TZW1hbnRpY1Rva2Vuc1JhbmdlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIFNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3Q7XG4oZnVuY3Rpb24gKFNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QpIHtcbiAgICBTZW1hbnRpY1Rva2Vuc1JlZnJlc2hSZXF1ZXN0Lm1ldGhvZCA9IGB3b3Jrc3BhY2Uvc2VtYW50aWNUb2tlbnMvcmVmcmVzaGA7XG4gICAgU2VtYW50aWNUb2tlbnNSZWZyZXNoUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLnNlcnZlclRvQ2xpZW50O1xuICAgIFNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUwKFNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QubWV0aG9kKTtcbn0pKFNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QgPSBleHBvcnRzLlNlbWFudGljVG9rZW5zUmVmcmVzaFJlcXVlc3QgfHwgKGV4cG9ydHMuU2VtYW50aWNUb2tlbnNSZWZyZXNoUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQzMzM6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuU2hvd0RvY3VtZW50UmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg0MzEpO1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gc2hvdyBhIGRvY3VtZW50LiBUaGlzIHJlcXVlc3QgbWlnaHQgb3BlbiBhblxuICogZXh0ZXJuYWwgcHJvZ3JhbSBkZXBlbmRpbmcgb24gdGhlIHZhbHVlIG9mIHRoZSBVUkkgdG8gb3Blbi5cbiAqIEZvciBleGFtcGxlIGEgcmVxdWVzdCB0byBvcGVuIGBodHRwczovL2NvZGUudmlzdWFsc3R1ZGlvLmNvbS9gXG4gKiB3aWxsIHZlcnkgbGlrZWx5IG9wZW4gdGhlIFVSSSBpbiBhIFdFQiBicm93c2VyLlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiovXG52YXIgU2hvd0RvY3VtZW50UmVxdWVzdDtcbihmdW5jdGlvbiAoU2hvd0RvY3VtZW50UmVxdWVzdCkge1xuICAgIFNob3dEb2N1bWVudFJlcXVlc3QubWV0aG9kID0gJ3dpbmRvdy9zaG93RG9jdW1lbnQnO1xuICAgIFNob3dEb2N1bWVudFJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5zZXJ2ZXJUb0NsaWVudDtcbiAgICBTaG93RG9jdW1lbnRSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFNob3dEb2N1bWVudFJlcXVlc3QubWV0aG9kKTtcbn0pKFNob3dEb2N1bWVudFJlcXVlc3QgPSBleHBvcnRzLlNob3dEb2N1bWVudFJlcXVlc3QgfHwgKGV4cG9ydHMuU2hvd0RvY3VtZW50UmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkyNjQ6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuVHlwZURlZmluaXRpb25SZXF1ZXN0ID0gdm9pZCAwO1xuY29uc3QgbWVzc2FnZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODQzMSk7XG4vLyBAdHMtaWdub3JlOiB0byBhdm9pZCBpbmxpbmluZyBMb2NhdGlvTGluayBhcyBkeW5hbWljIGltcG9ydFxubGV0IF9fbm9EeW5hbWljSW1wb3J0O1xuLyoqXG4gKiBBIHJlcXVlc3QgdG8gcmVzb2x2ZSB0aGUgdHlwZSBkZWZpbml0aW9uIGxvY2F0aW9ucyBvZiBhIHN5bWJvbCBhdCBhIGdpdmVuIHRleHRcbiAqIGRvY3VtZW50IHBvc2l0aW9uLiBUaGUgcmVxdWVzdCdzIHBhcmFtZXRlciBpcyBvZiB0eXBlIFtUZXh0RG9jdW1lbnRQb3NpdGlvblBhcmFtc11cbiAqICgjVGV4dERvY3VtZW50UG9zaXRpb25QYXJhbXMpIHRoZSByZXNwb25zZSBpcyBvZiB0eXBlIHtAbGluayBEZWZpbml0aW9ufSBvciBhXG4gKiBUaGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIHN1Y2guXG4gKi9cbnZhciBUeXBlRGVmaW5pdGlvblJlcXVlc3Q7XG4oZnVuY3Rpb24gKFR5cGVEZWZpbml0aW9uUmVxdWVzdCkge1xuICAgIFR5cGVEZWZpbml0aW9uUmVxdWVzdC5tZXRob2QgPSAndGV4dERvY3VtZW50L3R5cGVEZWZpbml0aW9uJztcbiAgICBUeXBlRGVmaW5pdGlvblJlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBUeXBlRGVmaW5pdGlvblJlcXVlc3QudHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sUmVxdWVzdFR5cGUoVHlwZURlZmluaXRpb25SZXF1ZXN0Lm1ldGhvZCk7XG59KShUeXBlRGVmaW5pdGlvblJlcXVlc3QgPSBleHBvcnRzLlR5cGVEZWZpbml0aW9uUmVxdWVzdCB8fCAoZXhwb3J0cy5UeXBlRGVmaW5pdGlvblJlcXVlc3QgPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3MDYyOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgVHlwZUZveCwgTWljcm9zb2Z0IGFuZCBvdGhlcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuVHlwZUhpZXJhcmNoeVN1YnR5cGVzUmVxdWVzdCA9IGV4cG9ydHMuVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0ID0gZXhwb3J0cy5UeXBlSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHJlc3VsdCBhIGBUeXBlSGllcmFyY2h5SXRlbWAgaW4gYSBkb2N1bWVudCBhdCBhIGdpdmVuIHBvc2l0aW9uLlxuICogQ2FuIGJlIHVzZWQgYXMgYW4gaW5wdXQgdG8gYSBzdWJ0eXBlcyBvciBzdXBlcnR5cGVzIHR5cGUgaGllcmFyY2h5LlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIFR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdDtcbihmdW5jdGlvbiAoVHlwZUhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0KSB7XG4gICAgVHlwZUhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0Lm1ldGhvZCA9ICd0ZXh0RG9jdW1lbnQvcHJlcGFyZVR5cGVIaWVyYXJjaHknO1xuICAgIFR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdC5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIFR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZShUeXBlSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QubWV0aG9kKTtcbn0pKFR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCA9IGV4cG9ydHMuVHlwZUhpZXJhcmNoeVByZXBhcmVSZXF1ZXN0IHx8IChleHBvcnRzLlR5cGVIaWVyYXJjaHlQcmVwYXJlUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIEEgcmVxdWVzdCB0byByZXNvbHZlIHRoZSBzdXBlcnR5cGVzIGZvciBhIGdpdmVuIGBUeXBlSGllcmFyY2h5SXRlbWAuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0O1xuKGZ1bmN0aW9uIChUeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3QpIHtcbiAgICBUeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3QubWV0aG9kID0gJ3R5cGVIaWVyYXJjaHkvc3VwZXJ0eXBlcyc7XG4gICAgVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0Lm1lc3NhZ2VEaXJlY3Rpb24gPSBtZXNzYWdlc18xLk1lc3NhZ2VEaXJlY3Rpb24uY2xpZW50VG9TZXJ2ZXI7XG4gICAgVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFR5cGVIaWVyYXJjaHlTdXBlcnR5cGVzUmVxdWVzdC5tZXRob2QpO1xufSkoVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0ID0gZXhwb3J0cy5UeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3QgfHwgKGV4cG9ydHMuVHlwZUhpZXJhcmNoeVN1cGVydHlwZXNSZXF1ZXN0ID0ge30pKTtcbi8qKlxuICogQSByZXF1ZXN0IHRvIHJlc29sdmUgdGhlIHN1YnR5cGVzIGZvciBhIGdpdmVuIGBUeXBlSGllcmFyY2h5SXRlbWAuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgVHlwZUhpZXJhcmNoeVN1YnR5cGVzUmVxdWVzdDtcbihmdW5jdGlvbiAoVHlwZUhpZXJhcmNoeVN1YnR5cGVzUmVxdWVzdCkge1xuICAgIFR5cGVIaWVyYXJjaHlTdWJ0eXBlc1JlcXVlc3QubWV0aG9kID0gJ3R5cGVIaWVyYXJjaHkvc3VidHlwZXMnO1xuICAgIFR5cGVIaWVyYXJjaHlTdWJ0eXBlc1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5jbGllbnRUb1NlcnZlcjtcbiAgICBUeXBlSGllcmFyY2h5U3VidHlwZXNSZXF1ZXN0LnR5cGUgPSBuZXcgbWVzc2FnZXNfMS5Qcm90b2NvbFJlcXVlc3RUeXBlKFR5cGVIaWVyYXJjaHlTdWJ0eXBlc1JlcXVlc3QubWV0aG9kKTtcbn0pKFR5cGVIaWVyYXJjaHlTdWJ0eXBlc1JlcXVlc3QgPSBleHBvcnRzLlR5cGVIaWVyYXJjaHlTdWJ0eXBlc1JlcXVlc3QgfHwgKGV4cG9ydHMuVHlwZUhpZXJhcmNoeVN1YnR5cGVzUmVxdWVzdCA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDY4NjA6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuRGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVyc05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuV29ya3NwYWNlRm9sZGVyc1JlcXVlc3QgPSB2b2lkIDA7XG5jb25zdCBtZXNzYWdlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NDMxKTtcbi8qKlxuICogVGhlIGB3b3Jrc3BhY2Uvd29ya3NwYWNlRm9sZGVyc2AgaXMgc2VudCBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudCB0byBmZXRjaCB0aGUgb3BlbiB3b3Jrc3BhY2UgZm9sZGVycy5cbiAqL1xudmFyIFdvcmtzcGFjZUZvbGRlcnNSZXF1ZXN0O1xuKGZ1bmN0aW9uIChXb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdCkge1xuICAgIFdvcmtzcGFjZUZvbGRlcnNSZXF1ZXN0Lm1ldGhvZCA9ICd3b3Jrc3BhY2Uvd29ya3NwYWNlRm9sZGVycyc7XG4gICAgV29ya3NwYWNlRm9sZGVyc1JlcXVlc3QubWVzc2FnZURpcmVjdGlvbiA9IG1lc3NhZ2VzXzEuTWVzc2FnZURpcmVjdGlvbi5zZXJ2ZXJUb0NsaWVudDtcbiAgICBXb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdC50eXBlID0gbmV3IG1lc3NhZ2VzXzEuUHJvdG9jb2xSZXF1ZXN0VHlwZTAoV29ya3NwYWNlRm9sZGVyc1JlcXVlc3QubWV0aG9kKTtcbn0pKFdvcmtzcGFjZUZvbGRlcnNSZXF1ZXN0ID0gZXhwb3J0cy5Xb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdCB8fCAoZXhwb3J0cy5Xb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdCA9IHt9KSk7XG4vKipcbiAqIFRoZSBgd29ya3NwYWNlL2RpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNgIG5vdGlmaWNhdGlvbiBpcyBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHdoZW4gdGhlIHdvcmtzcGFjZVxuICogZm9sZGVyIGNvbmZpZ3VyYXRpb24gY2hhbmdlcy5cbiAqL1xudmFyIERpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb247XG4oZnVuY3Rpb24gKERpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb24pIHtcbiAgICBEaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uLm1ldGhvZCA9ICd3b3Jrc3BhY2UvZGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVycyc7XG4gICAgRGlkQ2hhbmdlV29ya3NwYWNlRm9sZGVyc05vdGlmaWNhdGlvbi5tZXNzYWdlRGlyZWN0aW9uID0gbWVzc2FnZXNfMS5NZXNzYWdlRGlyZWN0aW9uLmNsaWVudFRvU2VydmVyO1xuICAgIERpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb24udHlwZSA9IG5ldyBtZXNzYWdlc18xLlByb3RvY29sTm90aWZpY2F0aW9uVHlwZShEaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uLm1ldGhvZCk7XG59KShEaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uID0gZXhwb3J0cy5EaWRDaGFuZ2VXb3Jrc3BhY2VGb2xkZXJzTm90aWZpY2F0aW9uIHx8IChleHBvcnRzLkRpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb24gPSB7fSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4NjMzOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG5leHBvcnRzLm9iamVjdExpdGVyYWwgPSBleHBvcnRzLnR5cGVkQXJyYXkgPSBleHBvcnRzLnN0cmluZ0FycmF5ID0gZXhwb3J0cy5hcnJheSA9IGV4cG9ydHMuZnVuYyA9IGV4cG9ydHMuZXJyb3IgPSBleHBvcnRzLm51bWJlciA9IGV4cG9ydHMuc3RyaW5nID0gZXhwb3J0cy5ib29sZWFuID0gdm9pZCAwO1xuZnVuY3Rpb24gYm9vbGVhbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2U7XG59XG5leHBvcnRzLmJvb2xlYW4gPSBib29sZWFuO1xuZnVuY3Rpb24gc3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmc7XG59XG5leHBvcnRzLnN0cmluZyA9IHN0cmluZztcbmZ1bmN0aW9uIG51bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyO1xufVxuZXhwb3J0cy5udW1iZXIgPSBudW1iZXI7XG5mdW5jdGlvbiBlcnJvcih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEVycm9yO1xufVxuZXhwb3J0cy5lcnJvciA9IGVycm9yO1xuZnVuY3Rpb24gZnVuYyh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmZ1bmMgPSBmdW5jO1xuZnVuY3Rpb24gYXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG5leHBvcnRzLmFycmF5ID0gYXJyYXk7XG5mdW5jdGlvbiBzdHJpbmdBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBhcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkoZWxlbSA9PiBzdHJpbmcoZWxlbSkpO1xufVxuZXhwb3J0cy5zdHJpbmdBcnJheSA9IHN0cmluZ0FycmF5O1xuZnVuY3Rpb24gdHlwZWRBcnJheSh2YWx1ZSwgY2hlY2spIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkoY2hlY2spO1xufVxuZXhwb3J0cy50eXBlZEFycmF5ID0gdHlwZWRBcnJheTtcbmZ1bmN0aW9uIG9iamVjdExpdGVyYWwodmFsdWUpIHtcbiAgICAvLyBTdHJpY3RseSBzcGVha2luZyBjbGFzcyBpbnN0YW5jZXMgcGFzcyB0aGlzIGNoZWNrIGFzIHdlbGwuIFNpbmNlIHRoZSBMU1BcbiAgICAvLyBkb2Vzbid0IHVzZSBjbGFzc2VzIHdlIGlnbm9yZSB0aGlzIGZvciBub3cuIElmIHdlIGRvIHdlIG5lZWQgdG8gYWRkIHNvbWV0aGluZ1xuICAgIC8vIGxpa2UgdGhpczogYE9iamVjdC5nZXRQcm90b3R5cGVPZihPYmplY3QuZ2V0UHJvdG90eXBlT2YoeCkpID09PSBudWxsYFxuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnO1xufVxuZXhwb3J0cy5vYmplY3RMaXRlcmFsID0gb2JqZWN0TGl0ZXJhbDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzcxNzpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBBbm5vdGF0ZWRUZXh0RWRpdDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQW5ub3RhdGVkVGV4dEVkaXQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDaGFuZ2VBbm5vdGF0aW9uOiAoKSA9PiAoLyogYmluZGluZyAqLyBDaGFuZ2VBbm5vdGF0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXI6ICgpID0+ICgvKiBiaW5kaW5nICovIENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29kZUFjdGlvbjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29kZUFjdGlvbiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENvZGVBY3Rpb25Db250ZXh0OiAoKSA9PiAoLyogYmluZGluZyAqLyBDb2RlQWN0aW9uQ29udGV4dCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENvZGVBY3Rpb25LaW5kOiAoKSA9PiAoLyogYmluZGluZyAqLyBDb2RlQWN0aW9uS2luZCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENvZGVBY3Rpb25UcmlnZ2VyS2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29kZUFjdGlvblRyaWdnZXJLaW5kKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29kZURlc2NyaXB0aW9uOiAoKSA9PiAoLyogYmluZGluZyAqLyBDb2RlRGVzY3JpcHRpb24pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDb2RlTGVuczogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29kZUxlbnMpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDb2xvcjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29sb3IpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBDb2xvckluZm9ybWF0aW9uOiAoKSA9PiAoLyogYmluZGluZyAqLyBDb2xvckluZm9ybWF0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29sb3JQcmVzZW50YXRpb246ICgpID0+ICgvKiBiaW5kaW5nICovIENvbG9yUHJlc2VudGF0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29tbWFuZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29tbWFuZCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENvbXBsZXRpb25JdGVtOiAoKSA9PiAoLyogYmluZGluZyAqLyBDb21wbGV0aW9uSXRlbSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIENvbXBsZXRpb25JdGVtS2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ29tcGxldGlvbkl0ZW1LaW5kKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29tcGxldGlvbkl0ZW1MYWJlbERldGFpbHM6ICgpID0+ICgvKiBiaW5kaW5nICovIENvbXBsZXRpb25JdGVtTGFiZWxEZXRhaWxzKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29tcGxldGlvbkl0ZW1UYWc6ICgpID0+ICgvKiBiaW5kaW5nICovIENvbXBsZXRpb25JdGVtVGFnKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ29tcGxldGlvbkxpc3Q6ICgpID0+ICgvKiBiaW5kaW5nICovIENvbXBsZXRpb25MaXN0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgQ3JlYXRlRmlsZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gQ3JlYXRlRmlsZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIERlbGV0ZUZpbGU6ICgpID0+ICgvKiBiaW5kaW5nICovIERlbGV0ZUZpbGUpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBEaWFnbm9zdGljOiAoKSA9PiAoLyogYmluZGluZyAqLyBEaWFnbm9zdGljKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbiksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIERpYWdub3N0aWNTZXZlcml0eTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRGlhZ25vc3RpY1NldmVyaXR5KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRGlhZ25vc3RpY1RhZzogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRGlhZ25vc3RpY1RhZyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIERvY3VtZW50SGlnaGxpZ2h0OiAoKSA9PiAoLyogYmluZGluZyAqLyBEb2N1bWVudEhpZ2hsaWdodCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIERvY3VtZW50SGlnaGxpZ2h0S2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRG9jdW1lbnRIaWdobGlnaHRLaW5kKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRG9jdW1lbnRMaW5rOiAoKSA9PiAoLyogYmluZGluZyAqLyBEb2N1bWVudExpbmspLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBEb2N1bWVudFN5bWJvbDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRG9jdW1lbnRTeW1ib2wpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBEb2N1bWVudFVyaTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRG9jdW1lbnRVcmkpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBFT0w6ICgpID0+ICgvKiBiaW5kaW5nICovIEVPTCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEZvbGRpbmdSYW5nZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRm9sZGluZ1JhbmdlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgRm9sZGluZ1JhbmdlS2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gRm9sZGluZ1JhbmdlS2luZCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEZvcm1hdHRpbmdPcHRpb25zOiAoKSA9PiAoLyogYmluZGluZyAqLyBGb3JtYXR0aW5nT3B0aW9ucyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIEhvdmVyOiAoKSA9PiAoLyogYmluZGluZyAqLyBIb3ZlciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIElubGF5SGludDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5sYXlIaW50KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgSW5sYXlIaW50S2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5sYXlIaW50S2luZCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIElubGF5SGludExhYmVsUGFydDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5sYXlIaW50TGFiZWxQYXJ0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgSW5saW5lVmFsdWVDb250ZXh0OiAoKSA9PiAoLyogYmluZGluZyAqLyBJbmxpbmVWYWx1ZUNvbnRleHQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb24pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBJbmxpbmVWYWx1ZVRleHQ6ICgpID0+ICgvKiBiaW5kaW5nICovIElubGluZVZhbHVlVGV4dCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIElubGluZVZhbHVlVmFyaWFibGVMb29rdXA6ICgpID0+ICgvKiBiaW5kaW5nICovIElubGluZVZhbHVlVmFyaWFibGVMb29rdXApLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBJbnNlcnRSZXBsYWNlRWRpdDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gSW5zZXJ0UmVwbGFjZUVkaXQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBJbnNlcnRUZXh0Rm9ybWF0OiAoKSA9PiAoLyogYmluZGluZyAqLyBJbnNlcnRUZXh0Rm9ybWF0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgSW5zZXJ0VGV4dE1vZGU6ICgpID0+ICgvKiBiaW5kaW5nICovIEluc2VydFRleHRNb2RlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgTG9jYXRpb246ICgpID0+ICgvKiBiaW5kaW5nICovIExvY2F0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgTG9jYXRpb25MaW5rOiAoKSA9PiAoLyogYmluZGluZyAqLyBMb2NhdGlvbkxpbmspLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBNYXJrZWRTdHJpbmc6ICgpID0+ICgvKiBiaW5kaW5nICovIE1hcmtlZFN0cmluZyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIE1hcmt1cENvbnRlbnQ6ICgpID0+ICgvKiBiaW5kaW5nICovIE1hcmt1cENvbnRlbnQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBNYXJrdXBLaW5kOiAoKSA9PiAoLyogYmluZGluZyAqLyBNYXJrdXBLaW5kKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyOiAoKSA9PiAoLyogYmluZGluZyAqLyBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBQYXJhbWV0ZXJJbmZvcm1hdGlvbjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gUGFyYW1ldGVySW5mb3JtYXRpb24pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBQb3NpdGlvbjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gUG9zaXRpb24pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBSYW5nZTogKCkgPT4gKC8qIGJpbmRpbmcgKi8gUmFuZ2UpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBSZW5hbWVGaWxlOiAoKSA9PiAoLyogYmluZGluZyAqLyBSZW5hbWVGaWxlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU2VsZWN0aW9uUmFuZ2U6ICgpID0+ICgvKiBiaW5kaW5nICovIFNlbGVjdGlvblJhbmdlKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyczogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU2VtYW50aWNUb2tlbk1vZGlmaWVycyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFNlbWFudGljVG9rZW5UeXBlczogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU2VtYW50aWNUb2tlblR5cGVzKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU2VtYW50aWNUb2tlbnM6ICgpID0+ICgvKiBiaW5kaW5nICovIFNlbWFudGljVG9rZW5zKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU2lnbmF0dXJlSW5mb3JtYXRpb246ICgpID0+ICgvKiBiaW5kaW5nICovIFNpZ25hdHVyZUluZm9ybWF0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU3ltYm9sSW5mb3JtYXRpb246ICgpID0+ICgvKiBiaW5kaW5nICovIFN5bWJvbEluZm9ybWF0aW9uKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgU3ltYm9sS2luZDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU3ltYm9sS2luZCksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFN5bWJvbFRhZzogKCkgPT4gKC8qIGJpbmRpbmcgKi8gU3ltYm9sVGFnKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgVGV4dERvY3VtZW50OiAoKSA9PiAoLyogYmluZGluZyAqLyBUZXh0RG9jdW1lbnQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBUZXh0RG9jdW1lbnRFZGl0OiAoKSA9PiAoLyogYmluZGluZyAqLyBUZXh0RG9jdW1lbnRFZGl0KSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgVGV4dERvY3VtZW50SWRlbnRpZmllcjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gVGV4dERvY3VtZW50SWRlbnRpZmllciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFRleHREb2N1bWVudEl0ZW06ICgpID0+ICgvKiBiaW5kaW5nICovIFRleHREb2N1bWVudEl0ZW0pLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBUZXh0RWRpdDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gVGV4dEVkaXQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBVUkk6ICgpID0+ICgvKiBiaW5kaW5nICovIFVSSSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXI6ICgpID0+ICgvKiBiaW5kaW5nICovIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBXb3Jrc3BhY2VDaGFuZ2U6ICgpID0+ICgvKiBiaW5kaW5nICovIFdvcmtzcGFjZUNoYW5nZSksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFdvcmtzcGFjZUVkaXQ6ICgpID0+ICgvKiBiaW5kaW5nICovIFdvcmtzcGFjZUVkaXQpLFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBXb3Jrc3BhY2VGb2xkZXI6ICgpID0+ICgvKiBiaW5kaW5nICovIFdvcmtzcGFjZUZvbGRlciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFdvcmtzcGFjZVN5bWJvbDogKCkgPT4gKC8qIGJpbmRpbmcgKi8gV29ya3NwYWNlU3ltYm9sKSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgaW50ZWdlcjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gaW50ZWdlciksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIHVpbnRlZ2VyOiAoKSA9PiAoLyogYmluZGluZyAqLyB1aW50ZWdlcilcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG52YXIgRG9jdW1lbnRVcmk7XG4oZnVuY3Rpb24gKERvY3VtZW50VXJpKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gICAgfVxuICAgIERvY3VtZW50VXJpLmlzID0gaXM7XG59KShEb2N1bWVudFVyaSB8fCAoRG9jdW1lbnRVcmkgPSB7fSkpO1xudmFyIFVSSTtcbihmdW5jdGlvbiAoVVJJKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gICAgfVxuICAgIFVSSS5pcyA9IGlzO1xufSkoVVJJIHx8IChVUkkgPSB7fSkpO1xudmFyIGludGVnZXI7XG4oZnVuY3Rpb24gKGludGVnZXIpIHtcbiAgICBpbnRlZ2VyLk1JTl9WQUxVRSA9IC0yMTQ3NDgzNjQ4O1xuICAgIGludGVnZXIuTUFYX1ZBTFVFID0gMjE0NzQ4MzY0NztcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpbnRlZ2VyLk1JTl9WQUxVRSA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSBpbnRlZ2VyLk1BWF9WQUxVRTtcbiAgICB9XG4gICAgaW50ZWdlci5pcyA9IGlzO1xufSkoaW50ZWdlciB8fCAoaW50ZWdlciA9IHt9KSk7XG52YXIgdWludGVnZXI7XG4oZnVuY3Rpb24gKHVpbnRlZ2VyKSB7XG4gICAgdWludGVnZXIuTUlOX1ZBTFVFID0gMDtcbiAgICB1aW50ZWdlci5NQVhfVkFMVUUgPSAyMTQ3NDgzNjQ3O1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHVpbnRlZ2VyLk1JTl9WQUxVRSA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSB1aW50ZWdlci5NQVhfVkFMVUU7XG4gICAgfVxuICAgIHVpbnRlZ2VyLmlzID0gaXM7XG59KSh1aW50ZWdlciB8fCAodWludGVnZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgUG9zaXRpb24gbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgUG9zaXRpb259IGxpdGVyYWxzLlxuICovXG52YXIgUG9zaXRpb247XG4oZnVuY3Rpb24gKFBvc2l0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBQb3NpdGlvbiBsaXRlcmFsIGZyb20gdGhlIGdpdmVuIGxpbmUgYW5kIGNoYXJhY3Rlci5cbiAgICAgKiBAcGFyYW0gbGluZSBUaGUgcG9zaXRpb24ncyBsaW5lLlxuICAgICAqIEBwYXJhbSBjaGFyYWN0ZXIgVGhlIHBvc2l0aW9uJ3MgY2hhcmFjdGVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsaW5lLCBjaGFyYWN0ZXIpIHtcbiAgICAgICAgaWYgKGxpbmUgPT09IE51bWJlci5NQVhfVkFMVUUpIHtcbiAgICAgICAgICAgIGxpbmUgPSB1aW50ZWdlci5NQVhfVkFMVUU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXJhY3RlciA9PT0gTnVtYmVyLk1BWF9WQUxVRSkge1xuICAgICAgICAgICAgY2hhcmFjdGVyID0gdWludGVnZXIuTUFYX1ZBTFVFO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGxpbmU6IGxpbmUsIGNoYXJhY3RlcjogY2hhcmFjdGVyIH07XG4gICAgfVxuICAgIFBvc2l0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIFBvc2l0aW9ufSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5saW5lKSAmJiBJcy51aW50ZWdlcihjYW5kaWRhdGUuY2hhcmFjdGVyKTtcbiAgICB9XG4gICAgUG9zaXRpb24uaXMgPSBpcztcbn0pKFBvc2l0aW9uIHx8IChQb3NpdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBSYW5nZSBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBSYW5nZX0gbGl0ZXJhbHMuXG4gKi9cbnZhciBSYW5nZTtcbihmdW5jdGlvbiAoUmFuZ2UpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUob25lLCB0d28sIHRocmVlLCBmb3VyKSB7XG4gICAgICAgIGlmIChJcy51aW50ZWdlcihvbmUpICYmIElzLnVpbnRlZ2VyKHR3bykgJiYgSXMudWludGVnZXIodGhyZWUpICYmIElzLnVpbnRlZ2VyKGZvdXIpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdGFydDogUG9zaXRpb24uY3JlYXRlKG9uZSwgdHdvKSwgZW5kOiBQb3NpdGlvbi5jcmVhdGUodGhyZWUsIGZvdXIpIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoUG9zaXRpb24uaXMob25lKSAmJiBQb3NpdGlvbi5pcyh0d28pKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdGFydDogb25lLCBlbmQ6IHR3byB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmFuZ2UjY3JlYXRlIGNhbGxlZCB3aXRoIGludmFsaWQgYXJndW1lbnRzW1wiLmNvbmNhdChvbmUsIFwiLCBcIikuY29uY2F0KHR3bywgXCIsIFwiKS5jb25jYXQodGhyZWUsIFwiLCBcIikuY29uY2F0KGZvdXIsIFwiXVwiKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUmFuZ2UuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgUmFuZ2V9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgUG9zaXRpb24uaXMoY2FuZGlkYXRlLnN0YXJ0KSAmJiBQb3NpdGlvbi5pcyhjYW5kaWRhdGUuZW5kKTtcbiAgICB9XG4gICAgUmFuZ2UuaXMgPSBpcztcbn0pKFJhbmdlIHx8IChSYW5nZSA9IHt9KSk7XG4vKipcbiAqIFRoZSBMb2NhdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBMb2NhdGlvbn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBMb2NhdGlvbjtcbihmdW5jdGlvbiAoTG9jYXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgTG9jYXRpb24gbGl0ZXJhbC5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSBsb2NhdGlvbidzIHVyaS5cbiAgICAgKiBAcGFyYW0gcmFuZ2UgVGhlIGxvY2F0aW9uJ3MgcmFuZ2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgcmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHsgdXJpOiB1cmksIHJhbmdlOiByYW5nZSB9O1xuICAgIH1cbiAgICBMb2NhdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBMb2NhdGlvbn0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpICYmIChJcy5zdHJpbmcoY2FuZGlkYXRlLnVyaSkgfHwgSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS51cmkpKTtcbiAgICB9XG4gICAgTG9jYXRpb24uaXMgPSBpcztcbn0pKExvY2F0aW9uIHx8IChMb2NhdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBMb2NhdGlvbkxpbmsgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgTG9jYXRpb25MaW5rfSBsaXRlcmFscy5cbiAqL1xudmFyIExvY2F0aW9uTGluaztcbihmdW5jdGlvbiAoTG9jYXRpb25MaW5rKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIExvY2F0aW9uTGluayBsaXRlcmFsLlxuICAgICAqIEBwYXJhbSB0YXJnZXRVcmkgVGhlIGRlZmluaXRpb24ncyB1cmkuXG4gICAgICogQHBhcmFtIHRhcmdldFJhbmdlIFRoZSBmdWxsIHJhbmdlIG9mIHRoZSBkZWZpbml0aW9uLlxuICAgICAqIEBwYXJhbSB0YXJnZXRTZWxlY3Rpb25SYW5nZSBUaGUgc3BhbiBvZiB0aGUgc3ltYm9sIGRlZmluaXRpb24gYXQgdGhlIHRhcmdldC5cbiAgICAgKiBAcGFyYW0gb3JpZ2luU2VsZWN0aW9uUmFuZ2UgVGhlIHNwYW4gb2YgdGhlIHN5bWJvbCBiZWluZyBkZWZpbmVkIGluIHRoZSBvcmlnaW5hdGluZyBzb3VyY2UgZmlsZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodGFyZ2V0VXJpLCB0YXJnZXRSYW5nZSwgdGFyZ2V0U2VsZWN0aW9uUmFuZ2UsIG9yaWdpblNlbGVjdGlvblJhbmdlKSB7XG4gICAgICAgIHJldHVybiB7IHRhcmdldFVyaTogdGFyZ2V0VXJpLCB0YXJnZXRSYW5nZTogdGFyZ2V0UmFuZ2UsIHRhcmdldFNlbGVjdGlvblJhbmdlOiB0YXJnZXRTZWxlY3Rpb25SYW5nZSwgb3JpZ2luU2VsZWN0aW9uUmFuZ2U6IG9yaWdpblNlbGVjdGlvblJhbmdlIH07XG4gICAgfVxuICAgIExvY2F0aW9uTGluay5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBMb2NhdGlvbkxpbmt9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnRhcmdldFJhbmdlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnRhcmdldFVyaSlcbiAgICAgICAgICAgICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS50YXJnZXRTZWxlY3Rpb25SYW5nZSlcbiAgICAgICAgICAgICYmIChSYW5nZS5pcyhjYW5kaWRhdGUub3JpZ2luU2VsZWN0aW9uUmFuZ2UpIHx8IElzLnVuZGVmaW5lZChjYW5kaWRhdGUub3JpZ2luU2VsZWN0aW9uUmFuZ2UpKTtcbiAgICB9XG4gICAgTG9jYXRpb25MaW5rLmlzID0gaXM7XG59KShMb2NhdGlvbkxpbmsgfHwgKExvY2F0aW9uTGluayA9IHt9KSk7XG4vKipcbiAqIFRoZSBDb2xvciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBDb2xvcn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBDb2xvcjtcbihmdW5jdGlvbiAoQ29sb3IpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvbG9yIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZWQ6IHJlZCxcbiAgICAgICAgICAgIGdyZWVuOiBncmVlbixcbiAgICAgICAgICAgIGJsdWU6IGJsdWUsXG4gICAgICAgICAgICBhbHBoYTogYWxwaGEsXG4gICAgICAgIH07XG4gICAgfVxuICAgIENvbG9yLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIENvbG9yfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLm51bWJlclJhbmdlKGNhbmRpZGF0ZS5yZWQsIDAsIDEpXG4gICAgICAgICAgICAmJiBJcy5udW1iZXJSYW5nZShjYW5kaWRhdGUuZ3JlZW4sIDAsIDEpXG4gICAgICAgICAgICAmJiBJcy5udW1iZXJSYW5nZShjYW5kaWRhdGUuYmx1ZSwgMCwgMSlcbiAgICAgICAgICAgICYmIElzLm51bWJlclJhbmdlKGNhbmRpZGF0ZS5hbHBoYSwgMCwgMSk7XG4gICAgfVxuICAgIENvbG9yLmlzID0gaXM7XG59KShDb2xvciB8fCAoQ29sb3IgPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29sb3JJbmZvcm1hdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBDb2xvckluZm9ybWF0aW9ufSBsaXRlcmFscy5cbiAqL1xudmFyIENvbG9ySW5mb3JtYXRpb247XG4oZnVuY3Rpb24gKENvbG9ySW5mb3JtYXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvbG9ySW5mb3JtYXRpb24gbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIGNvbG9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYW5nZTogcmFuZ2UsXG4gICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgIH07XG4gICAgfVxuICAgIENvbG9ySW5mb3JtYXRpb24uY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgQ29sb3JJbmZvcm1hdGlvbn0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpICYmIENvbG9yLmlzKGNhbmRpZGF0ZS5jb2xvcik7XG4gICAgfVxuICAgIENvbG9ySW5mb3JtYXRpb24uaXMgPSBpcztcbn0pKENvbG9ySW5mb3JtYXRpb24gfHwgKENvbG9ySW5mb3JtYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29sb3IgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgQ29sb3JQcmVzZW50YXRpb259IGxpdGVyYWxzLlxuICovXG52YXIgQ29sb3JQcmVzZW50YXRpb247XG4oZnVuY3Rpb24gKENvbG9yUHJlc2VudGF0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBDb2xvckluZm9ybWF0aW9uIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKGxhYmVsLCB0ZXh0RWRpdCwgYWRkaXRpb25hbFRleHRFZGl0cykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgICAgICAgdGV4dEVkaXQ6IHRleHRFZGl0LFxuICAgICAgICAgICAgYWRkaXRpb25hbFRleHRFZGl0czogYWRkaXRpb25hbFRleHRFZGl0cyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgQ29sb3JQcmVzZW50YXRpb24uY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgQ29sb3JJbmZvcm1hdGlvbn0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLmxhYmVsKVxuICAgICAgICAgICAgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUudGV4dEVkaXQpIHx8IFRleHRFZGl0LmlzKGNhbmRpZGF0ZSkpXG4gICAgICAgICAgICAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5hZGRpdGlvbmFsVGV4dEVkaXRzKSB8fCBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5hZGRpdGlvbmFsVGV4dEVkaXRzLCBUZXh0RWRpdC5pcykpO1xuICAgIH1cbiAgICBDb2xvclByZXNlbnRhdGlvbi5pcyA9IGlzO1xufSkoQ29sb3JQcmVzZW50YXRpb24gfHwgKENvbG9yUHJlc2VudGF0aW9uID0ge30pKTtcbi8qKlxuICogQSBzZXQgb2YgcHJlZGVmaW5lZCByYW5nZSBraW5kcy5cbiAqL1xudmFyIEZvbGRpbmdSYW5nZUtpbmQ7XG4oZnVuY3Rpb24gKEZvbGRpbmdSYW5nZUtpbmQpIHtcbiAgICAvKipcbiAgICAgKiBGb2xkaW5nIHJhbmdlIGZvciBhIGNvbW1lbnRcbiAgICAgKi9cbiAgICBGb2xkaW5nUmFuZ2VLaW5kLkNvbW1lbnQgPSAnY29tbWVudCc7XG4gICAgLyoqXG4gICAgICogRm9sZGluZyByYW5nZSBmb3IgYW4gaW1wb3J0IG9yIGluY2x1ZGVcbiAgICAgKi9cbiAgICBGb2xkaW5nUmFuZ2VLaW5kLkltcG9ydHMgPSAnaW1wb3J0cyc7XG4gICAgLyoqXG4gICAgICogRm9sZGluZyByYW5nZSBmb3IgYSByZWdpb24gKGUuZy4gYCNyZWdpb25gKVxuICAgICAqL1xuICAgIEZvbGRpbmdSYW5nZUtpbmQuUmVnaW9uID0gJ3JlZ2lvbic7XG59KShGb2xkaW5nUmFuZ2VLaW5kIHx8IChGb2xkaW5nUmFuZ2VLaW5kID0ge30pKTtcbi8qKlxuICogVGhlIGZvbGRpbmcgcmFuZ2UgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgRm9sZGluZ1JhbmdlfSBsaXRlcmFscy5cbiAqL1xudmFyIEZvbGRpbmdSYW5nZTtcbihmdW5jdGlvbiAoRm9sZGluZ1JhbmdlKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBGb2xkaW5nUmFuZ2UgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUoc3RhcnRMaW5lLCBlbmRMaW5lLCBzdGFydENoYXJhY3RlciwgZW5kQ2hhcmFjdGVyLCBraW5kLCBjb2xsYXBzZWRUZXh0KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICBzdGFydExpbmU6IHN0YXJ0TGluZSxcbiAgICAgICAgICAgIGVuZExpbmU6IGVuZExpbmVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKElzLmRlZmluZWQoc3RhcnRDaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnRDaGFyYWN0ZXIgPSBzdGFydENoYXJhY3RlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXMuZGVmaW5lZChlbmRDaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICByZXN1bHQuZW5kQ2hhcmFjdGVyID0gZW5kQ2hhcmFjdGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKGtpbmQpKSB7XG4gICAgICAgICAgICByZXN1bHQua2luZCA9IGtpbmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzLmRlZmluZWQoY29sbGFwc2VkVGV4dCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jb2xsYXBzZWRUZXh0ID0gY29sbGFwc2VkVGV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBGb2xkaW5nUmFuZ2UuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgRm9sZGluZ1JhbmdlfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5zdGFydExpbmUpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5zdGFydExpbmUpXG4gICAgICAgICAgICAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5zdGFydENoYXJhY3RlcikgfHwgSXMudWludGVnZXIoY2FuZGlkYXRlLnN0YXJ0Q2hhcmFjdGVyKSlcbiAgICAgICAgICAgICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLmVuZENoYXJhY3RlcikgfHwgSXMudWludGVnZXIoY2FuZGlkYXRlLmVuZENoYXJhY3RlcikpXG4gICAgICAgICAgICAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5raW5kKSB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLmtpbmQpKTtcbiAgICB9XG4gICAgRm9sZGluZ1JhbmdlLmlzID0gaXM7XG59KShGb2xkaW5nUmFuZ2UgfHwgKEZvbGRpbmdSYW5nZSA9IHt9KSk7XG4vKipcbiAqIFRoZSBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb259IGxpdGVyYWxzLlxuICovXG52YXIgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbjtcbihmdW5jdGlvbiAoRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbiBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsb2NhdGlvbiwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb259IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgTG9jYXRpb24uaXMoY2FuZGlkYXRlLmxvY2F0aW9uKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm1lc3NhZ2UpO1xuICAgIH1cbiAgICBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uLmlzID0gaXM7XG59KShEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uIHx8IChEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIGRpYWdub3N0aWMncyBzZXZlcml0eS5cbiAqL1xudmFyIERpYWdub3N0aWNTZXZlcml0eTtcbihmdW5jdGlvbiAoRGlhZ25vc3RpY1NldmVyaXR5KSB7XG4gICAgLyoqXG4gICAgICogUmVwb3J0cyBhbiBlcnJvci5cbiAgICAgKi9cbiAgICBEaWFnbm9zdGljU2V2ZXJpdHkuRXJyb3IgPSAxO1xuICAgIC8qKlxuICAgICAqIFJlcG9ydHMgYSB3YXJuaW5nLlxuICAgICAqL1xuICAgIERpYWdub3N0aWNTZXZlcml0eS5XYXJuaW5nID0gMjtcbiAgICAvKipcbiAgICAgKiBSZXBvcnRzIGFuIGluZm9ybWF0aW9uLlxuICAgICAqL1xuICAgIERpYWdub3N0aWNTZXZlcml0eS5JbmZvcm1hdGlvbiA9IDM7XG4gICAgLyoqXG4gICAgICogUmVwb3J0cyBhIGhpbnQuXG4gICAgICovXG4gICAgRGlhZ25vc3RpY1NldmVyaXR5LkhpbnQgPSA0O1xufSkoRGlhZ25vc3RpY1NldmVyaXR5IHx8IChEaWFnbm9zdGljU2V2ZXJpdHkgPSB7fSkpO1xuLyoqXG4gKiBUaGUgZGlhZ25vc3RpYyB0YWdzLlxuICpcbiAqIEBzaW5jZSAzLjE1LjBcbiAqL1xudmFyIERpYWdub3N0aWNUYWc7XG4oZnVuY3Rpb24gKERpYWdub3N0aWNUYWcpIHtcbiAgICAvKipcbiAgICAgKiBVbnVzZWQgb3IgdW5uZWNlc3NhcnkgY29kZS5cbiAgICAgKlxuICAgICAqIENsaWVudHMgYXJlIGFsbG93ZWQgdG8gcmVuZGVyIGRpYWdub3N0aWNzIHdpdGggdGhpcyB0YWcgZmFkZWQgb3V0IGluc3RlYWQgb2YgaGF2aW5nXG4gICAgICogYW4gZXJyb3Igc3F1aWdnbGUuXG4gICAgICovXG4gICAgRGlhZ25vc3RpY1RhZy5Vbm5lY2Vzc2FyeSA9IDE7XG4gICAgLyoqXG4gICAgICogRGVwcmVjYXRlZCBvciBvYnNvbGV0ZSBjb2RlLlxuICAgICAqXG4gICAgICogQ2xpZW50cyBhcmUgYWxsb3dlZCB0byByZW5kZXJlZCBkaWFnbm9zdGljcyB3aXRoIHRoaXMgdGFnIHN0cmlrZSB0aHJvdWdoLlxuICAgICAqL1xuICAgIERpYWdub3N0aWNUYWcuRGVwcmVjYXRlZCA9IDI7XG59KShEaWFnbm9zdGljVGFnIHx8IChEaWFnbm9zdGljVGFnID0ge30pKTtcbi8qKlxuICogVGhlIENvZGVEZXNjcmlwdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGRlYWwgd2l0aCBkZXNjcmlwdGlvbnMgZm9yIGRpYWdub3N0aWMgY29kZXMuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgQ29kZURlc2NyaXB0aW9uO1xuKGZ1bmN0aW9uIChDb2RlRGVzY3JpcHRpb24pIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5ocmVmKTtcbiAgICB9XG4gICAgQ29kZURlc2NyaXB0aW9uLmlzID0gaXM7XG59KShDb2RlRGVzY3JpcHRpb24gfHwgKENvZGVEZXNjcmlwdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBEaWFnbm9zdGljIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIERpYWdub3N0aWN9IGxpdGVyYWxzLlxuICovXG52YXIgRGlhZ25vc3RpYztcbihmdW5jdGlvbiAoRGlhZ25vc3RpYykge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgRGlhZ25vc3RpYyBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgbWVzc2FnZSwgc2V2ZXJpdHksIGNvZGUsIHNvdXJjZSwgcmVsYXRlZEluZm9ybWF0aW9uKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7IHJhbmdlOiByYW5nZSwgbWVzc2FnZTogbWVzc2FnZSB9O1xuICAgICAgICBpZiAoSXMuZGVmaW5lZChzZXZlcml0eSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zZXZlcml0eSA9IHNldmVyaXR5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKGNvZGUpKSB7XG4gICAgICAgICAgICByZXN1bHQuY29kZSA9IGNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzLmRlZmluZWQoc291cmNlKSkge1xuICAgICAgICAgICAgcmVzdWx0LnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXMuZGVmaW5lZChyZWxhdGVkSW5mb3JtYXRpb24pKSB7XG4gICAgICAgICAgICByZXN1bHQucmVsYXRlZEluZm9ybWF0aW9uID0gcmVsYXRlZEluZm9ybWF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIERpYWdub3N0aWMuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgRGlhZ25vc3RpY30gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpXG4gICAgICAgICAgICAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpXG4gICAgICAgICAgICAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm1lc3NhZ2UpXG4gICAgICAgICAgICAmJiAoSXMubnVtYmVyKGNhbmRpZGF0ZS5zZXZlcml0eSkgfHwgSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5zZXZlcml0eSkpXG4gICAgICAgICAgICAmJiAoSXMuaW50ZWdlcihjYW5kaWRhdGUuY29kZSkgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5jb2RlKSB8fCBJcy51bmRlZmluZWQoY2FuZGlkYXRlLmNvZGUpKVxuICAgICAgICAgICAgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUuY29kZURlc2NyaXB0aW9uKSB8fCAoSXMuc3RyaW5nKChfYSA9IGNhbmRpZGF0ZS5jb2RlRGVzY3JpcHRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ocmVmKSkpXG4gICAgICAgICAgICAmJiAoSXMuc3RyaW5nKGNhbmRpZGF0ZS5zb3VyY2UpIHx8IElzLnVuZGVmaW5lZChjYW5kaWRhdGUuc291cmNlKSlcbiAgICAgICAgICAgICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLnJlbGF0ZWRJbmZvcm1hdGlvbikgfHwgSXMudHlwZWRBcnJheShjYW5kaWRhdGUucmVsYXRlZEluZm9ybWF0aW9uLCBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uLmlzKSk7XG4gICAgfVxuICAgIERpYWdub3N0aWMuaXMgPSBpcztcbn0pKERpYWdub3N0aWMgfHwgKERpYWdub3N0aWMgPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29tbWFuZCBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBDb21tYW5kfSBsaXRlcmFscy5cbiAqL1xudmFyIENvbW1hbmQ7XG4oZnVuY3Rpb24gKENvbW1hbmQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvbW1hbmQgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodGl0bGUsIGNvbW1hbmQpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgdGl0bGU6IHRpdGxlLCBjb21tYW5kOiBjb21tYW5kIH07XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKGFyZ3MpICYmIGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0LmFyZ3VtZW50cyA9IGFyZ3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgQ29tbWFuZC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBDb21tYW5kfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudGl0bGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUuY29tbWFuZCk7XG4gICAgfVxuICAgIENvbW1hbmQuaXMgPSBpcztcbn0pKENvbW1hbmQgfHwgKENvbW1hbmQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgVGV4dEVkaXQgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgcmVwbGFjZSxcbiAqIGluc2VydCBhbmQgZGVsZXRlIGVkaXRzIG1vcmUgZWFzaWx5LlxuICovXG52YXIgVGV4dEVkaXQ7XG4oZnVuY3Rpb24gKFRleHRFZGl0KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHJlcGxhY2UgdGV4dCBlZGl0LlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2Ugb2YgdGV4dCB0byBiZSByZXBsYWNlZC5cbiAgICAgKiBAcGFyYW0gbmV3VGV4dCBUaGUgbmV3IHRleHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVwbGFjZShyYW5nZSwgbmV3VGV4dCkge1xuICAgICAgICByZXR1cm4geyByYW5nZTogcmFuZ2UsIG5ld1RleHQ6IG5ld1RleHQgfTtcbiAgICB9XG4gICAgVGV4dEVkaXQucmVwbGFjZSA9IHJlcGxhY2U7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnNlcnQgdGV4dCBlZGl0LlxuICAgICAqIEBwYXJhbSBwb3NpdGlvbiBUaGUgcG9zaXRpb24gdG8gaW5zZXJ0IHRoZSB0ZXh0IGF0LlxuICAgICAqIEBwYXJhbSBuZXdUZXh0IFRoZSB0ZXh0IHRvIGJlIGluc2VydGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluc2VydChwb3NpdGlvbiwgbmV3VGV4dCkge1xuICAgICAgICByZXR1cm4geyByYW5nZTogeyBzdGFydDogcG9zaXRpb24sIGVuZDogcG9zaXRpb24gfSwgbmV3VGV4dDogbmV3VGV4dCB9O1xuICAgIH1cbiAgICBUZXh0RWRpdC5pbnNlcnQgPSBpbnNlcnQ7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGRlbGV0ZSB0ZXh0IGVkaXQuXG4gICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSBvZiB0ZXh0IHRvIGJlIGRlbGV0ZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVsKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiByYW5nZSwgbmV3VGV4dDogJycgfTtcbiAgICB9XG4gICAgVGV4dEVkaXQuZGVsID0gZGVsO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKVxuICAgICAgICAgICAgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5uZXdUZXh0KVxuICAgICAgICAgICAgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKTtcbiAgICB9XG4gICAgVGV4dEVkaXQuaXMgPSBpcztcbn0pKFRleHRFZGl0IHx8IChUZXh0RWRpdCA9IHt9KSk7XG52YXIgQ2hhbmdlQW5ub3RhdGlvbjtcbihmdW5jdGlvbiAoQ2hhbmdlQW5ub3RhdGlvbikge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsYWJlbCwgbmVlZHNDb25maXJtYXRpb24sIGRlc2NyaXB0aW9uKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7IGxhYmVsOiBsYWJlbCB9O1xuICAgICAgICBpZiAobmVlZHNDb25maXJtYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0Lm5lZWRzQ29uZmlybWF0aW9uID0gbmVlZHNDb25maXJtYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIENoYW5nZUFubm90YXRpb24uY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLmxhYmVsKSAmJlxuICAgICAgICAgICAgKElzLmJvb2xlYW4oY2FuZGlkYXRlLm5lZWRzQ29uZmlybWF0aW9uKSB8fCBjYW5kaWRhdGUubmVlZHNDb25maXJtYXRpb24gPT09IHVuZGVmaW5lZCkgJiZcbiAgICAgICAgICAgIChJcy5zdHJpbmcoY2FuZGlkYXRlLmRlc2NyaXB0aW9uKSB8fCBjYW5kaWRhdGUuZGVzY3JpcHRpb24gPT09IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIENoYW5nZUFubm90YXRpb24uaXMgPSBpcztcbn0pKENoYW5nZUFubm90YXRpb24gfHwgKENoYW5nZUFubm90YXRpb24gPSB7fSkpO1xudmFyIENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyO1xuKGZ1bmN0aW9uIChDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllcikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLnN0cmluZyhjYW5kaWRhdGUpO1xuICAgIH1cbiAgICBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyA9IGlzO1xufSkoQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIgfHwgKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyID0ge30pKTtcbnZhciBBbm5vdGF0ZWRUZXh0RWRpdDtcbihmdW5jdGlvbiAoQW5ub3RhdGVkVGV4dEVkaXQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFubm90YXRlZCByZXBsYWNlIHRleHQgZWRpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2Ugb2YgdGV4dCB0byBiZSByZXBsYWNlZC5cbiAgICAgKiBAcGFyYW0gbmV3VGV4dCBUaGUgbmV3IHRleHQuXG4gICAgICogQHBhcmFtIGFubm90YXRpb24gVGhlIGFubm90YXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVwbGFjZShyYW5nZSwgbmV3VGV4dCwgYW5ub3RhdGlvbikge1xuICAgICAgICByZXR1cm4geyByYW5nZTogcmFuZ2UsIG5ld1RleHQ6IG5ld1RleHQsIGFubm90YXRpb25JZDogYW5ub3RhdGlvbiB9O1xuICAgIH1cbiAgICBBbm5vdGF0ZWRUZXh0RWRpdC5yZXBsYWNlID0gcmVwbGFjZTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFubm90YXRlZCBpbnNlcnQgdGV4dCBlZGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBvc2l0aW9uIFRoZSBwb3NpdGlvbiB0byBpbnNlcnQgdGhlIHRleHQgYXQuXG4gICAgICogQHBhcmFtIG5ld1RleHQgVGhlIHRleHQgdG8gYmUgaW5zZXJ0ZWQuXG4gICAgICogQHBhcmFtIGFubm90YXRpb24gVGhlIGFubm90YXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5zZXJ0KHBvc2l0aW9uLCBuZXdUZXh0LCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiB7IHN0YXJ0OiBwb3NpdGlvbiwgZW5kOiBwb3NpdGlvbiB9LCBuZXdUZXh0OiBuZXdUZXh0LCBhbm5vdGF0aW9uSWQ6IGFubm90YXRpb24gfTtcbiAgICB9XG4gICAgQW5ub3RhdGVkVGV4dEVkaXQuaW5zZXJ0ID0gaW5zZXJ0O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYW5ub3RhdGVkIGRlbGV0ZSB0ZXh0IGVkaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIG9mIHRleHQgdG8gYmUgZGVsZXRlZC5cbiAgICAgKiBAcGFyYW0gYW5ub3RhdGlvbiBUaGUgYW5ub3RhdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWwocmFuZ2UsIGFubm90YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IHJhbmdlLCBuZXdUZXh0OiAnJywgYW5ub3RhdGlvbklkOiBhbm5vdGF0aW9uIH07XG4gICAgfVxuICAgIEFubm90YXRlZFRleHRFZGl0LmRlbCA9IGRlbDtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBUZXh0RWRpdC5pcyhjYW5kaWRhdGUpICYmIChDaGFuZ2VBbm5vdGF0aW9uLmlzKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQpIHx8IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQpKTtcbiAgICB9XG4gICAgQW5ub3RhdGVkVGV4dEVkaXQuaXMgPSBpcztcbn0pKEFubm90YXRlZFRleHRFZGl0IHx8IChBbm5vdGF0ZWRUZXh0RWRpdCA9IHt9KSk7XG4vKipcbiAqIFRoZSBUZXh0RG9jdW1lbnRFZGl0IG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlXG4gKiBhbiBlZGl0IHRoYXQgbWFuaXB1bGF0ZXMgYSB0ZXh0IGRvY3VtZW50LlxuICovXG52YXIgVGV4dERvY3VtZW50RWRpdDtcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50RWRpdCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgYFRleHREb2N1bWVudEVkaXRgXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHRleHREb2N1bWVudCwgZWRpdHMpIHtcbiAgICAgICAgcmV0dXJuIHsgdGV4dERvY3VtZW50OiB0ZXh0RG9jdW1lbnQsIGVkaXRzOiBlZGl0cyB9O1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnRFZGl0LmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSlcbiAgICAgICAgICAgICYmIE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllci5pcyhjYW5kaWRhdGUudGV4dERvY3VtZW50KVxuICAgICAgICAgICAgJiYgQXJyYXkuaXNBcnJheShjYW5kaWRhdGUuZWRpdHMpO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnRFZGl0LmlzID0gaXM7XG59KShUZXh0RG9jdW1lbnRFZGl0IHx8IChUZXh0RG9jdW1lbnRFZGl0ID0ge30pKTtcbnZhciBDcmVhdGVGaWxlO1xuKGZ1bmN0aW9uIChDcmVhdGVGaWxlKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgb3B0aW9ucywgYW5ub3RhdGlvbikge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAga2luZDogJ2NyZWF0ZScsXG4gICAgICAgICAgICB1cmk6IHVyaVxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIChvcHRpb25zLm92ZXJ3cml0ZSAhPT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuaWdub3JlSWZFeGlzdHMgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5ub3RhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQuYW5ub3RhdGlvbklkID0gYW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBDcmVhdGVGaWxlLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgY2FuZGlkYXRlLmtpbmQgPT09ICdjcmVhdGUnICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiAoY2FuZGlkYXRlLm9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgKChjYW5kaWRhdGUub3B0aW9ucy5vdmVyd3JpdGUgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5vcHRpb25zLm92ZXJ3cml0ZSkpICYmIChjYW5kaWRhdGUub3B0aW9ucy5pZ25vcmVJZkV4aXN0cyA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLm9wdGlvbnMuaWdub3JlSWZFeGlzdHMpKSkpICYmIChjYW5kaWRhdGUuYW5ub3RhdGlvbklkID09PSB1bmRlZmluZWQgfHwgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoY2FuZGlkYXRlLmFubm90YXRpb25JZCkpO1xuICAgIH1cbiAgICBDcmVhdGVGaWxlLmlzID0gaXM7XG59KShDcmVhdGVGaWxlIHx8IChDcmVhdGVGaWxlID0ge30pKTtcbnZhciBSZW5hbWVGaWxlO1xuKGZ1bmN0aW9uIChSZW5hbWVGaWxlKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKG9sZFVyaSwgbmV3VXJpLCBvcHRpb25zLCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICBraW5kOiAncmVuYW1lJyxcbiAgICAgICAgICAgIG9sZFVyaTogb2xkVXJpLFxuICAgICAgICAgICAgbmV3VXJpOiBuZXdVcmlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiAob3B0aW9ucy5vdmVyd3JpdGUgIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmlnbm9yZUlmRXhpc3RzICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICByZXN1bHQub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFubm90YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmFubm90YXRpb25JZCA9IGFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgUmVuYW1lRmlsZS5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIGNhbmRpZGF0ZS5raW5kID09PSAncmVuYW1lJyAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm9sZFVyaSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5uZXdVcmkpICYmIChjYW5kaWRhdGUub3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAoKGNhbmRpZGF0ZS5vcHRpb25zLm92ZXJ3cml0ZSA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLm9wdGlvbnMub3ZlcndyaXRlKSkgJiYgKGNhbmRpZGF0ZS5vcHRpb25zLmlnbm9yZUlmRXhpc3RzID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUub3B0aW9ucy5pZ25vcmVJZkV4aXN0cykpKSkgJiYgKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQgPT09IHVuZGVmaW5lZCB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhjYW5kaWRhdGUuYW5ub3RhdGlvbklkKSk7XG4gICAgfVxuICAgIFJlbmFtZUZpbGUuaXMgPSBpcztcbn0pKFJlbmFtZUZpbGUgfHwgKFJlbmFtZUZpbGUgPSB7fSkpO1xudmFyIERlbGV0ZUZpbGU7XG4oZnVuY3Rpb24gKERlbGV0ZUZpbGUpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCBvcHRpb25zLCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICBraW5kOiAnZGVsZXRlJyxcbiAgICAgICAgICAgIHVyaTogdXJpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgKG9wdGlvbnMucmVjdXJzaXZlICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5pZ25vcmVJZk5vdEV4aXN0cyAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgcmVzdWx0Lm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbm5vdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hbm5vdGF0aW9uSWQgPSBhbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIERlbGV0ZUZpbGUuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBjYW5kaWRhdGUua2luZCA9PT0gJ2RlbGV0ZScgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIChjYW5kaWRhdGUub3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAoKGNhbmRpZGF0ZS5vcHRpb25zLnJlY3Vyc2l2ZSA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLm9wdGlvbnMucmVjdXJzaXZlKSkgJiYgKGNhbmRpZGF0ZS5vcHRpb25zLmlnbm9yZUlmTm90RXhpc3RzID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUub3B0aW9ucy5pZ25vcmVJZk5vdEV4aXN0cykpKSkgJiYgKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQgPT09IHVuZGVmaW5lZCB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhjYW5kaWRhdGUuYW5ub3RhdGlvbklkKSk7XG4gICAgfVxuICAgIERlbGV0ZUZpbGUuaXMgPSBpcztcbn0pKERlbGV0ZUZpbGUgfHwgKERlbGV0ZUZpbGUgPSB7fSkpO1xudmFyIFdvcmtzcGFjZUVkaXQ7XG4oZnVuY3Rpb24gKFdvcmtzcGFjZUVkaXQpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuY2hhbmdlcyAhPT0gdW5kZWZpbmVkIHx8IGNhbmRpZGF0ZS5kb2N1bWVudENoYW5nZXMgIT09IHVuZGVmaW5lZCkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuZG9jdW1lbnRDaGFuZ2VzID09PSB1bmRlZmluZWQgfHwgY2FuZGlkYXRlLmRvY3VtZW50Q2hhbmdlcy5ldmVyeShmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKElzLnN0cmluZyhjaGFuZ2Uua2luZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENyZWF0ZUZpbGUuaXMoY2hhbmdlKSB8fCBSZW5hbWVGaWxlLmlzKGNoYW5nZSkgfHwgRGVsZXRlRmlsZS5pcyhjaGFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRleHREb2N1bWVudEVkaXQuaXMoY2hhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgfVxuICAgIFdvcmtzcGFjZUVkaXQuaXMgPSBpcztcbn0pKFdvcmtzcGFjZUVkaXQgfHwgKFdvcmtzcGFjZUVkaXQgPSB7fSkpO1xudmFyIFRleHRFZGl0Q2hhbmdlSW1wbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUZXh0RWRpdENoYW5nZUltcGwoZWRpdHMsIGNoYW5nZUFubm90YXRpb25zKSB7XG4gICAgICAgIHRoaXMuZWRpdHMgPSBlZGl0cztcbiAgICAgICAgdGhpcy5jaGFuZ2VBbm5vdGF0aW9ucyA9IGNoYW5nZUFubm90YXRpb25zO1xuICAgIH1cbiAgICBUZXh0RWRpdENoYW5nZUltcGwucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChwb3NpdGlvbiwgbmV3VGV4dCwgYW5ub3RhdGlvbikge1xuICAgICAgICB2YXIgZWRpdDtcbiAgICAgICAgdmFyIGlkO1xuICAgICAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlZGl0ID0gVGV4dEVkaXQuaW5zZXJ0KHBvc2l0aW9uLCBuZXdUZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhhbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgaWQgPSBhbm5vdGF0aW9uO1xuICAgICAgICAgICAgZWRpdCA9IEFubm90YXRlZFRleHRFZGl0Lmluc2VydChwb3NpdGlvbiwgbmV3VGV4dCwgYW5ub3RhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFzc2VydENoYW5nZUFubm90YXRpb25zKHRoaXMuY2hhbmdlQW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgaWQgPSB0aGlzLmNoYW5nZUFubm90YXRpb25zLm1hbmFnZShhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgIGVkaXQgPSBBbm5vdGF0ZWRUZXh0RWRpdC5pbnNlcnQocG9zaXRpb24sIG5ld1RleHQsIGlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVkaXRzLnB1c2goZWRpdCk7XG4gICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRleHRFZGl0Q2hhbmdlSW1wbC5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIChyYW5nZSwgbmV3VGV4dCwgYW5ub3RhdGlvbikge1xuICAgICAgICB2YXIgZWRpdDtcbiAgICAgICAgdmFyIGlkO1xuICAgICAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlZGl0ID0gVGV4dEVkaXQucmVwbGFjZShyYW5nZSwgbmV3VGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoYW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgIGlkID0gYW5ub3RhdGlvbjtcbiAgICAgICAgICAgIGVkaXQgPSBBbm5vdGF0ZWRUZXh0RWRpdC5yZXBsYWNlKHJhbmdlLCBuZXdUZXh0LCBhbm5vdGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0Q2hhbmdlQW5ub3RhdGlvbnModGhpcy5jaGFuZ2VBbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICBpZCA9IHRoaXMuY2hhbmdlQW5ub3RhdGlvbnMubWFuYWdlKGFubm90YXRpb24pO1xuICAgICAgICAgICAgZWRpdCA9IEFubm90YXRlZFRleHRFZGl0LnJlcGxhY2UocmFuZ2UsIG5ld1RleHQsIGlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVkaXRzLnB1c2goZWRpdCk7XG4gICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRleHRFZGl0Q2hhbmdlSW1wbC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKHJhbmdlLCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHZhciBlZGl0O1xuICAgICAgICB2YXIgaWQ7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVkaXQgPSBUZXh0RWRpdC5kZWwocmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGFubm90YXRpb24pKSB7XG4gICAgICAgICAgICBpZCA9IGFubm90YXRpb247XG4gICAgICAgICAgICBlZGl0ID0gQW5ub3RhdGVkVGV4dEVkaXQuZGVsKHJhbmdlLCBhbm5vdGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0Q2hhbmdlQW5ub3RhdGlvbnModGhpcy5jaGFuZ2VBbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICBpZCA9IHRoaXMuY2hhbmdlQW5ub3RhdGlvbnMubWFuYWdlKGFubm90YXRpb24pO1xuICAgICAgICAgICAgZWRpdCA9IEFubm90YXRlZFRleHRFZGl0LmRlbChyYW5nZSwgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWRpdHMucHVzaChlZGl0KTtcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGV4dEVkaXRDaGFuZ2VJbXBsLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZWRpdCkge1xuICAgICAgICB0aGlzLmVkaXRzLnB1c2goZWRpdCk7XG4gICAgfTtcbiAgICBUZXh0RWRpdENoYW5nZUltcGwucHJvdG90eXBlLmFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdHM7XG4gICAgfTtcbiAgICBUZXh0RWRpdENoYW5nZUltcGwucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVkaXRzLnNwbGljZSgwLCB0aGlzLmVkaXRzLmxlbmd0aCk7XG4gICAgfTtcbiAgICBUZXh0RWRpdENoYW5nZUltcGwucHJvdG90eXBlLmFzc2VydENoYW5nZUFubm90YXRpb25zID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUZXh0IGVkaXQgY2hhbmdlIGlzIG5vdCBjb25maWd1cmVkIHRvIG1hbmFnZSBjaGFuZ2UgYW5ub3RhdGlvbnMuXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVGV4dEVkaXRDaGFuZ2VJbXBsO1xufSgpKTtcbi8qKlxuICogQSBoZWxwZXIgY2xhc3NcbiAqL1xudmFyIENoYW5nZUFubm90YXRpb25zID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENoYW5nZUFubm90YXRpb25zKGFubm90YXRpb25zKSB7XG4gICAgICAgIHRoaXMuX2Fubm90YXRpb25zID0gYW5ub3RhdGlvbnMgPT09IHVuZGVmaW5lZCA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiBhbm5vdGF0aW9ucztcbiAgICAgICAgdGhpcy5fY291bnRlciA9IDA7XG4gICAgICAgIHRoaXMuX3NpemUgPSAwO1xuICAgIH1cbiAgICBDaGFuZ2VBbm5vdGF0aW9ucy5wcm90b3R5cGUuYWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW5ub3RhdGlvbnM7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hhbmdlQW5ub3RhdGlvbnMucHJvdG90eXBlLCBcInNpemVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaXplO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ2hhbmdlQW5ub3RhdGlvbnMucHJvdG90eXBlLm1hbmFnZSA9IGZ1bmN0aW9uIChpZE9yQW5ub3RhdGlvbiwgYW5ub3RhdGlvbikge1xuICAgICAgICB2YXIgaWQ7XG4gICAgICAgIGlmIChDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhpZE9yQW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgIGlkID0gaWRPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZCA9IHRoaXMubmV4dElkKCk7XG4gICAgICAgICAgICBhbm5vdGF0aW9uID0gaWRPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2Fubm90YXRpb25zW2lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJZCBcIi5jb25jYXQoaWQsIFwiIGlzIGFscmVhZHkgaW4gdXNlLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFubm90YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gYW5ub3RhdGlvbiBwcm92aWRlZCBmb3IgaWQgXCIuY29uY2F0KGlkKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYW5ub3RhdGlvbnNbaWRdID0gYW5ub3RhdGlvbjtcbiAgICAgICAgdGhpcy5fc2l6ZSsrO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfTtcbiAgICBDaGFuZ2VBbm5vdGF0aW9ucy5wcm90b3R5cGUubmV4dElkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jb3VudGVyKys7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb3VudGVyLnRvU3RyaW5nKCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2hhbmdlQW5ub3RhdGlvbnM7XG59KCkpO1xuLyoqXG4gKiBBIHdvcmtzcGFjZSBjaGFuZ2UgaGVscHMgY29uc3RydWN0aW5nIGNoYW5nZXMgdG8gYSB3b3Jrc3BhY2UuXG4gKi9cbnZhciBXb3Jrc3BhY2VDaGFuZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gV29ya3NwYWNlQ2hhbmdlKHdvcmtzcGFjZUVkaXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fdGV4dEVkaXRDaGFuZ2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgaWYgKHdvcmtzcGFjZUVkaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdCA9IHdvcmtzcGFjZUVkaXQ7XG4gICAgICAgICAgICBpZiAod29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucyA9IG5ldyBDaGFuZ2VBbm5vdGF0aW9ucyh3b3Jrc3BhY2VFZGl0LmNoYW5nZUFubm90YXRpb25zKTtcbiAgICAgICAgICAgICAgICB3b3Jrc3BhY2VFZGl0LmNoYW5nZUFubm90YXRpb25zID0gdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMuYWxsKCk7XG4gICAgICAgICAgICAgICAgd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMuZm9yRWFjaChmdW5jdGlvbiAoY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChUZXh0RG9jdW1lbnRFZGl0LmlzKGNoYW5nZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0RWRpdENoYW5nZSA9IG5ldyBUZXh0RWRpdENoYW5nZUltcGwoY2hhbmdlLmVkaXRzLCBfdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3RleHRFZGl0Q2hhbmdlc1tjaGFuZ2UudGV4dERvY3VtZW50LnVyaV0gPSB0ZXh0RWRpdENoYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAod29ya3NwYWNlRWRpdC5jaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMod29ya3NwYWNlRWRpdC5jaGFuZ2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRFZGl0Q2hhbmdlID0gbmV3IFRleHRFZGl0Q2hhbmdlSW1wbCh3b3Jrc3BhY2VFZGl0LmNoYW5nZXNba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl90ZXh0RWRpdENoYW5nZXNba2V5XSA9IHRleHRFZGl0Q2hhbmdlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdCA9IHt9O1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXb3Jrc3BhY2VDaGFuZ2UucHJvdG90eXBlLCBcImVkaXRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgdW5kZXJseWluZyB7QGxpbmsgV29ya3NwYWNlRWRpdH0gbGl0ZXJhbFxuICAgICAgICAgKiB1c2UgdG8gYmUgcmV0dXJuZWQgZnJvbSBhIHdvcmtzcGFjZSBlZGl0IG9wZXJhdGlvbiBsaWtlIHJlbmFtZS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5pbml0RG9jdW1lbnRDaGFuZ2VzKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlQW5ub3RhdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0LmNoYW5nZUFubm90YXRpb25zID0gdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMuYWxsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dvcmtzcGFjZUVkaXQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBXb3Jrc3BhY2VDaGFuZ2UucHJvdG90eXBlLmdldFRleHRFZGl0Q2hhbmdlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyLmlzKGtleSkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdERvY3VtZW50Q2hhbmdlcygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtzcGFjZSBlZGl0IGlzIG5vdCBjb25maWd1cmVkIGZvciBkb2N1bWVudCBjaGFuZ2VzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRleHREb2N1bWVudCA9IHsgdXJpOiBrZXkudXJpLCB2ZXJzaW9uOiBrZXkudmVyc2lvbiB9O1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX3RleHRFZGl0Q2hhbmdlc1t0ZXh0RG9jdW1lbnQudXJpXTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVkaXRzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIHRleHREb2N1bWVudEVkaXQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHREb2N1bWVudDogdGV4dERvY3VtZW50LFxuICAgICAgICAgICAgICAgICAgICBlZGl0czogZWRpdHNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzLnB1c2godGV4dERvY3VtZW50RWRpdCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFRleHRFZGl0Q2hhbmdlSW1wbChlZGl0cywgdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RleHRFZGl0Q2hhbmdlc1t0ZXh0RG9jdW1lbnQudXJpXSA9IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmluaXRDaGFuZ2VzKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtzcGFjZSBlZGl0IGlzIG5vdCBjb25maWd1cmVkIGZvciBub3JtYWwgdGV4dCBlZGl0IGNoYW5nZXMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fdGV4dEVkaXRDaGFuZ2VzW2tleV07XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHZhciBlZGl0cyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlc1trZXldID0gZWRpdHM7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFRleHRFZGl0Q2hhbmdlSW1wbChlZGl0cyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dEVkaXRDaGFuZ2VzW2tleV0gPSByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBXb3Jrc3BhY2VDaGFuZ2UucHJvdG90eXBlLmluaXREb2N1bWVudENoYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcyA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucyA9IG5ldyBDaGFuZ2VBbm5vdGF0aW9ucygpO1xuICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlQW5ub3RhdGlvbnMgPSB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucy5hbGwoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgV29ya3NwYWNlQ2hhbmdlLnByb3RvdHlwZS5pbml0Q2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzID09PSB1bmRlZmluZWQgJiYgdGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdvcmtzcGFjZUNoYW5nZS5wcm90b3R5cGUuY3JlYXRlRmlsZSA9IGZ1bmN0aW9uICh1cmksIG9wdGlvbnNPckFubm90YXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0RG9jdW1lbnRDaGFuZ2VzKCk7XG4gICAgICAgIGlmICh0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtzcGFjZSBlZGl0IGlzIG5vdCBjb25maWd1cmVkIGZvciBkb2N1bWVudCBjaGFuZ2VzLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbm5vdGF0aW9uO1xuICAgICAgICBpZiAoQ2hhbmdlQW5ub3RhdGlvbi5pcyhvcHRpb25zT3JBbm5vdGF0aW9uKSB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhvcHRpb25zT3JBbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgYW5ub3RhdGlvbiA9IG9wdGlvbnNPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9uc09yQW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3BlcmF0aW9uO1xuICAgICAgICB2YXIgaWQ7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IENyZWF0ZUZpbGUuY3JlYXRlKHVyaSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZCA9IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGFubm90YXRpb24pID8gYW5ub3RhdGlvbiA6IHRoaXMuX2NoYW5nZUFubm90YXRpb25zLm1hbmFnZShhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IENyZWF0ZUZpbGUuY3JlYXRlKHVyaSwgb3B0aW9ucywgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzLnB1c2gob3BlcmF0aW9uKTtcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgV29ya3NwYWNlQ2hhbmdlLnByb3RvdHlwZS5yZW5hbWVGaWxlID0gZnVuY3Rpb24gKG9sZFVyaSwgbmV3VXJpLCBvcHRpb25zT3JBbm5vdGF0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5pdERvY3VtZW50Q2hhbmdlcygpO1xuICAgICAgICBpZiAodGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXb3Jrc3BhY2UgZWRpdCBpcyBub3QgY29uZmlndXJlZCBmb3IgZG9jdW1lbnQgY2hhbmdlcy4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYW5ub3RhdGlvbjtcbiAgICAgICAgaWYgKENoYW5nZUFubm90YXRpb24uaXMob3B0aW9uc09yQW5ub3RhdGlvbikgfHwgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMob3B0aW9uc09yQW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgIGFubm90YXRpb24gPSBvcHRpb25zT3JBbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnNPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wZXJhdGlvbjtcbiAgICAgICAgdmFyIGlkO1xuICAgICAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcGVyYXRpb24gPSBSZW5hbWVGaWxlLmNyZWF0ZShvbGRVcmksIG5ld1VyaSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZCA9IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGFubm90YXRpb24pID8gYW5ub3RhdGlvbiA6IHRoaXMuX2NoYW5nZUFubm90YXRpb25zLm1hbmFnZShhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IFJlbmFtZUZpbGUuY3JlYXRlKG9sZFVyaSwgbmV3VXJpLCBvcHRpb25zLCBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMucHVzaChvcGVyYXRpb24pO1xuICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBXb3Jrc3BhY2VDaGFuZ2UucHJvdG90eXBlLmRlbGV0ZUZpbGUgPSBmdW5jdGlvbiAodXJpLCBvcHRpb25zT3JBbm5vdGF0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5pdERvY3VtZW50Q2hhbmdlcygpO1xuICAgICAgICBpZiAodGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXb3Jrc3BhY2UgZWRpdCBpcyBub3QgY29uZmlndXJlZCBmb3IgZG9jdW1lbnQgY2hhbmdlcy4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYW5ub3RhdGlvbjtcbiAgICAgICAgaWYgKENoYW5nZUFubm90YXRpb24uaXMob3B0aW9uc09yQW5ub3RhdGlvbikgfHwgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMob3B0aW9uc09yQW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgIGFubm90YXRpb24gPSBvcHRpb25zT3JBbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnNPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wZXJhdGlvbjtcbiAgICAgICAgdmFyIGlkO1xuICAgICAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcGVyYXRpb24gPSBEZWxldGVGaWxlLmNyZWF0ZSh1cmksIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWQgPSBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhhbm5vdGF0aW9uKSA/IGFubm90YXRpb24gOiB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucy5tYW5hZ2UoYW5ub3RhdGlvbik7XG4gICAgICAgICAgICBvcGVyYXRpb24gPSBEZWxldGVGaWxlLmNyZWF0ZSh1cmksIG9wdGlvbnMsIGlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcy5wdXNoKG9wZXJhdGlvbik7XG4gICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBXb3Jrc3BhY2VDaGFuZ2U7XG59KCkpO1xuXG4vKipcbiAqIFRoZSBUZXh0RG9jdW1lbnRJZGVudGlmaWVyIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIFRleHREb2N1bWVudElkZW50aWZpZXJ9IGxpdGVyYWxzLlxuICovXG52YXIgVGV4dERvY3VtZW50SWRlbnRpZmllcjtcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50SWRlbnRpZmllcikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVGV4dERvY3VtZW50SWRlbnRpZmllciBsaXRlcmFsLlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGRvY3VtZW50J3MgdXJpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmkpIHtcbiAgICAgICAgcmV0dXJuIHsgdXJpOiB1cmkgfTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50SWRlbnRpZmllci5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBUZXh0RG9jdW1lbnRJZGVudGlmaWVyfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50SWRlbnRpZmllci5pcyA9IGlzO1xufSkoVGV4dERvY3VtZW50SWRlbnRpZmllciB8fCAoVGV4dERvY3VtZW50SWRlbnRpZmllciA9IHt9KSk7XG4vKipcbiAqIFRoZSBWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXJ9IGxpdGVyYWxzLlxuICovXG52YXIgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcjtcbihmdW5jdGlvbiAoVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciBsaXRlcmFsLlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGRvY3VtZW50J3MgdXJpLlxuICAgICAqIEBwYXJhbSB2ZXJzaW9uIFRoZSBkb2N1bWVudCdzIHZlcnNpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgdmVyc2lvbikge1xuICAgICAgICByZXR1cm4geyB1cmk6IHVyaSwgdmVyc2lvbjogdmVyc2lvbiB9O1xuICAgIH1cbiAgICBWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXJ9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIElzLmludGVnZXIoY2FuZGlkYXRlLnZlcnNpb24pO1xuICAgIH1cbiAgICBWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyLmlzID0gaXM7XG59KShWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIHx8IChWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyID0ge30pKTtcbi8qKlxuICogVGhlIE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXJ9IGxpdGVyYWxzLlxuICovXG52YXIgT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyO1xuKGZ1bmN0aW9uIChPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciBsaXRlcmFsLlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGRvY3VtZW50J3MgdXJpLlxuICAgICAqIEBwYXJhbSB2ZXJzaW9uIFRoZSBkb2N1bWVudCdzIHZlcnNpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgdmVyc2lvbikge1xuICAgICAgICByZXR1cm4geyB1cmk6IHVyaSwgdmVyc2lvbjogdmVyc2lvbiB9O1xuICAgIH1cbiAgICBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiAoY2FuZGlkYXRlLnZlcnNpb24gPT09IG51bGwgfHwgSXMuaW50ZWdlcihjYW5kaWRhdGUudmVyc2lvbikpO1xuICAgIH1cbiAgICBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuaXMgPSBpcztcbn0pKE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciB8fCAoT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyID0ge30pKTtcbi8qKlxuICogVGhlIFRleHREb2N1bWVudEl0ZW0gbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgVGV4dERvY3VtZW50SXRlbX0gbGl0ZXJhbHMuXG4gKi9cbnZhciBUZXh0RG9jdW1lbnRJdGVtO1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnRJdGVtKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBUZXh0RG9jdW1lbnRJdGVtIGxpdGVyYWwuXG4gICAgICogQHBhcmFtIHVyaSBUaGUgZG9jdW1lbnQncyB1cmkuXG4gICAgICogQHBhcmFtIGxhbmd1YWdlSWQgVGhlIGRvY3VtZW50J3MgbGFuZ3VhZ2UgaWRlbnRpZmllci5cbiAgICAgKiBAcGFyYW0gdmVyc2lvbiBUaGUgZG9jdW1lbnQncyB2ZXJzaW9uIG51bWJlci5cbiAgICAgKiBAcGFyYW0gdGV4dCBUaGUgZG9jdW1lbnQncyB0ZXh0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHsgdXJpOiB1cmksIGxhbmd1YWdlSWQ6IGxhbmd1YWdlSWQsIHZlcnNpb246IHZlcnNpb24sIHRleHQ6IHRleHQgfTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50SXRlbS5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBUZXh0RG9jdW1lbnRJdGVtfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLmxhbmd1YWdlSWQpICYmIElzLmludGVnZXIoY2FuZGlkYXRlLnZlcnNpb24pICYmIElzLnN0cmluZyhjYW5kaWRhdGUudGV4dCk7XG4gICAgfVxuICAgIFRleHREb2N1bWVudEl0ZW0uaXMgPSBpcztcbn0pKFRleHREb2N1bWVudEl0ZW0gfHwgKFRleHREb2N1bWVudEl0ZW0gPSB7fSkpO1xuLyoqXG4gKiBEZXNjcmliZXMgdGhlIGNvbnRlbnQgdHlwZSB0aGF0IGEgY2xpZW50IHN1cHBvcnRzIGluIHZhcmlvdXNcbiAqIHJlc3VsdCBsaXRlcmFscyBsaWtlIGBIb3ZlcmAsIGBQYXJhbWV0ZXJJbmZvYCBvciBgQ29tcGxldGlvbkl0ZW1gLlxuICpcbiAqIFBsZWFzZSBub3RlIHRoYXQgYE1hcmt1cEtpbmRzYCBtdXN0IG5vdCBzdGFydCB3aXRoIGEgYCRgLiBUaGlzIGtpbmRzXG4gKiBhcmUgcmVzZXJ2ZWQgZm9yIGludGVybmFsIHVzYWdlLlxuICovXG52YXIgTWFya3VwS2luZDtcbihmdW5jdGlvbiAoTWFya3VwS2luZCkge1xuICAgIC8qKlxuICAgICAqIFBsYWluIHRleHQgaXMgc3VwcG9ydGVkIGFzIGEgY29udGVudCBmb3JtYXRcbiAgICAgKi9cbiAgICBNYXJrdXBLaW5kLlBsYWluVGV4dCA9ICdwbGFpbnRleHQnO1xuICAgIC8qKlxuICAgICAqIE1hcmtkb3duIGlzIHN1cHBvcnRlZCBhcyBhIGNvbnRlbnQgZm9ybWF0XG4gICAgICovXG4gICAgTWFya3VwS2luZC5NYXJrZG93biA9ICdtYXJrZG93bic7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsdWUgb2YgdGhlIHtAbGluayBNYXJrdXBLaW5kfSB0eXBlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSA9PT0gTWFya3VwS2luZC5QbGFpblRleHQgfHwgY2FuZGlkYXRlID09PSBNYXJrdXBLaW5kLk1hcmtkb3duO1xuICAgIH1cbiAgICBNYXJrdXBLaW5kLmlzID0gaXM7XG59KShNYXJrdXBLaW5kIHx8IChNYXJrdXBLaW5kID0ge30pKTtcbnZhciBNYXJrdXBDb250ZW50O1xuKGZ1bmN0aW9uIChNYXJrdXBDb250ZW50KSB7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgTWFya3VwQ29udGVudH0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwodmFsdWUpICYmIE1hcmt1cEtpbmQuaXMoY2FuZGlkYXRlLmtpbmQpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudmFsdWUpO1xuICAgIH1cbiAgICBNYXJrdXBDb250ZW50LmlzID0gaXM7XG59KShNYXJrdXBDb250ZW50IHx8IChNYXJrdXBDb250ZW50ID0ge30pKTtcbi8qKlxuICogVGhlIGtpbmQgb2YgYSBjb21wbGV0aW9uIGVudHJ5LlxuICovXG52YXIgQ29tcGxldGlvbkl0ZW1LaW5kO1xuKGZ1bmN0aW9uIChDb21wbGV0aW9uSXRlbUtpbmQpIHtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuVGV4dCA9IDE7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLk1ldGhvZCA9IDI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkZ1bmN0aW9uID0gMztcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuQ29uc3RydWN0b3IgPSA0O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5GaWVsZCA9IDU7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlZhcmlhYmxlID0gNjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuQ2xhc3MgPSA3O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5JbnRlcmZhY2UgPSA4O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5Nb2R1bGUgPSA5O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5Qcm9wZXJ0eSA9IDEwO1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5Vbml0ID0gMTE7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlZhbHVlID0gMTI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkVudW0gPSAxMztcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuS2V5d29yZCA9IDE0O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5TbmlwcGV0ID0gMTU7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkNvbG9yID0gMTY7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkZpbGUgPSAxNztcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuUmVmZXJlbmNlID0gMTg7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkZvbGRlciA9IDE5O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5FbnVtTWVtYmVyID0gMjA7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkNvbnN0YW50ID0gMjE7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlN0cnVjdCA9IDIyO1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5FdmVudCA9IDIzO1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5PcGVyYXRvciA9IDI0O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5UeXBlUGFyYW1ldGVyID0gMjU7XG59KShDb21wbGV0aW9uSXRlbUtpbmQgfHwgKENvbXBsZXRpb25JdGVtS2luZCA9IHt9KSk7XG4vKipcbiAqIERlZmluZXMgd2hldGhlciB0aGUgaW5zZXJ0IHRleHQgaW4gYSBjb21wbGV0aW9uIGl0ZW0gc2hvdWxkIGJlIGludGVycHJldGVkIGFzXG4gKiBwbGFpbiB0ZXh0IG9yIGEgc25pcHBldC5cbiAqL1xudmFyIEluc2VydFRleHRGb3JtYXQ7XG4oZnVuY3Rpb24gKEluc2VydFRleHRGb3JtYXQpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgcHJpbWFyeSB0ZXh0IHRvIGJlIGluc2VydGVkIGlzIHRyZWF0ZWQgYXMgYSBwbGFpbiBzdHJpbmcuXG4gICAgICovXG4gICAgSW5zZXJ0VGV4dEZvcm1hdC5QbGFpblRleHQgPSAxO1xuICAgIC8qKlxuICAgICAqIFRoZSBwcmltYXJ5IHRleHQgdG8gYmUgaW5zZXJ0ZWQgaXMgdHJlYXRlZCBhcyBhIHNuaXBwZXQuXG4gICAgICpcbiAgICAgKiBBIHNuaXBwZXQgY2FuIGRlZmluZSB0YWIgc3RvcHMgYW5kIHBsYWNlaG9sZGVycyB3aXRoIGAkMWAsIGAkMmBcbiAgICAgKiBhbmQgYCR7Mzpmb299YC4gYCQwYCBkZWZpbmVzIHRoZSBmaW5hbCB0YWIgc3RvcCwgaXQgZGVmYXVsdHMgdG9cbiAgICAgKiB0aGUgZW5kIG9mIHRoZSBzbmlwcGV0LiBQbGFjZWhvbGRlcnMgd2l0aCBlcXVhbCBpZGVudGlmaWVycyBhcmUgbGlua2VkLFxuICAgICAqIHRoYXQgaXMgdHlwaW5nIGluIG9uZSB3aWxsIHVwZGF0ZSBvdGhlcnMgdG9vLlxuICAgICAqXG4gICAgICogU2VlIGFsc286IGh0dHBzOi8vbWljcm9zb2Z0LmdpdGh1Yi5pby9sYW5ndWFnZS1zZXJ2ZXItcHJvdG9jb2wvc3BlY2lmaWNhdGlvbnMvc3BlY2lmaWNhdGlvbi1jdXJyZW50LyNzbmlwcGV0X3N5bnRheFxuICAgICAqL1xuICAgIEluc2VydFRleHRGb3JtYXQuU25pcHBldCA9IDI7XG59KShJbnNlcnRUZXh0Rm9ybWF0IHx8IChJbnNlcnRUZXh0Rm9ybWF0ID0ge30pKTtcbi8qKlxuICogQ29tcGxldGlvbiBpdGVtIHRhZ3MgYXJlIGV4dHJhIGFubm90YXRpb25zIHRoYXQgdHdlYWsgdGhlIHJlbmRlcmluZyBvZiBhIGNvbXBsZXRpb25cbiAqIGl0ZW0uXG4gKlxuICogQHNpbmNlIDMuMTUuMFxuICovXG52YXIgQ29tcGxldGlvbkl0ZW1UYWc7XG4oZnVuY3Rpb24gKENvbXBsZXRpb25JdGVtVGFnKSB7XG4gICAgLyoqXG4gICAgICogUmVuZGVyIGEgY29tcGxldGlvbiBhcyBvYnNvbGV0ZSwgdXN1YWxseSB1c2luZyBhIHN0cmlrZS1vdXQuXG4gICAgICovXG4gICAgQ29tcGxldGlvbkl0ZW1UYWcuRGVwcmVjYXRlZCA9IDE7XG59KShDb21wbGV0aW9uSXRlbVRhZyB8fCAoQ29tcGxldGlvbkl0ZW1UYWcgPSB7fSkpO1xuLyoqXG4gKiBUaGUgSW5zZXJ0UmVwbGFjZUVkaXQgbmFtZXNwYWNlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0byBkZWFsIHdpdGggaW5zZXJ0IC8gcmVwbGFjZSBlZGl0cy5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBJbnNlcnRSZXBsYWNlRWRpdDtcbihmdW5jdGlvbiAoSW5zZXJ0UmVwbGFjZUVkaXQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc2VydCAvIHJlcGxhY2UgZWRpdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShuZXdUZXh0LCBpbnNlcnQsIHJlcGxhY2UpIHtcbiAgICAgICAgcmV0dXJuIHsgbmV3VGV4dDogbmV3VGV4dCwgaW5zZXJ0OiBpbnNlcnQsIHJlcGxhY2U6IHJlcGxhY2UgfTtcbiAgICB9XG4gICAgSW5zZXJ0UmVwbGFjZUVkaXQuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgSW5zZXJ0UmVwbGFjZUVkaXR9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5uZXdUZXh0KSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUuaW5zZXJ0KSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmVwbGFjZSk7XG4gICAgfVxuICAgIEluc2VydFJlcGxhY2VFZGl0LmlzID0gaXM7XG59KShJbnNlcnRSZXBsYWNlRWRpdCB8fCAoSW5zZXJ0UmVwbGFjZUVkaXQgPSB7fSkpO1xuLyoqXG4gKiBIb3cgd2hpdGVzcGFjZSBhbmQgaW5kZW50YXRpb24gaXMgaGFuZGxlZCBkdXJpbmcgY29tcGxldGlvblxuICogaXRlbSBpbnNlcnRpb24uXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgSW5zZXJ0VGV4dE1vZGU7XG4oZnVuY3Rpb24gKEluc2VydFRleHRNb2RlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGluc2VydGlvbiBvciByZXBsYWNlIHN0cmluZ3MgaXMgdGFrZW4gYXMgaXQgaXMuIElmIHRoZVxuICAgICAqIHZhbHVlIGlzIG11bHRpIGxpbmUgdGhlIGxpbmVzIGJlbG93IHRoZSBjdXJzb3Igd2lsbCBiZVxuICAgICAqIGluc2VydGVkIHVzaW5nIHRoZSBpbmRlbnRhdGlvbiBkZWZpbmVkIGluIHRoZSBzdHJpbmcgdmFsdWUuXG4gICAgICogVGhlIGNsaWVudCB3aWxsIG5vdCBhcHBseSBhbnkga2luZCBvZiBhZGp1c3RtZW50cyB0byB0aGVcbiAgICAgKiBzdHJpbmcuXG4gICAgICovXG4gICAgSW5zZXJ0VGV4dE1vZGUuYXNJcyA9IDE7XG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBhZGp1c3RzIGxlYWRpbmcgd2hpdGVzcGFjZSBvZiBuZXcgbGluZXMgc28gdGhhdFxuICAgICAqIHRoZXkgbWF0Y2ggdGhlIGluZGVudGF0aW9uIHVwIHRvIHRoZSBjdXJzb3Igb2YgdGhlIGxpbmUgZm9yXG4gICAgICogd2hpY2ggdGhlIGl0ZW0gaXMgYWNjZXB0ZWQuXG4gICAgICpcbiAgICAgKiBDb25zaWRlciBhIGxpbmUgbGlrZSB0aGlzOiA8MnRhYnM+PGN1cnNvcj48M3RhYnM+Zm9vLiBBY2NlcHRpbmcgYVxuICAgICAqIG11bHRpIGxpbmUgY29tcGxldGlvbiBpdGVtIGlzIGluZGVudGVkIHVzaW5nIDIgdGFicyBhbmQgYWxsXG4gICAgICogZm9sbG93aW5nIGxpbmVzIGluc2VydGVkIHdpbGwgYmUgaW5kZW50ZWQgdXNpbmcgMiB0YWJzIGFzIHdlbGwuXG4gICAgICovXG4gICAgSW5zZXJ0VGV4dE1vZGUuYWRqdXN0SW5kZW50YXRpb24gPSAyO1xufSkoSW5zZXJ0VGV4dE1vZGUgfHwgKEluc2VydFRleHRNb2RlID0ge30pKTtcbnZhciBDb21wbGV0aW9uSXRlbUxhYmVsRGV0YWlscztcbihmdW5jdGlvbiAoQ29tcGxldGlvbkl0ZW1MYWJlbERldGFpbHMpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgKElzLnN0cmluZyhjYW5kaWRhdGUuZGV0YWlsKSB8fCBjYW5kaWRhdGUuZGV0YWlsID09PSB1bmRlZmluZWQpICYmXG4gICAgICAgICAgICAoSXMuc3RyaW5nKGNhbmRpZGF0ZS5kZXNjcmlwdGlvbikgfHwgY2FuZGlkYXRlLmRlc2NyaXB0aW9uID09PSB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBDb21wbGV0aW9uSXRlbUxhYmVsRGV0YWlscy5pcyA9IGlzO1xufSkoQ29tcGxldGlvbkl0ZW1MYWJlbERldGFpbHMgfHwgKENvbXBsZXRpb25JdGVtTGFiZWxEZXRhaWxzID0ge30pKTtcbi8qKlxuICogVGhlIENvbXBsZXRpb25JdGVtIG5hbWVzcGFjZSBwcm92aWRlcyBmdW5jdGlvbnMgdG8gZGVhbCB3aXRoXG4gKiBjb21wbGV0aW9uIGl0ZW1zLlxuICovXG52YXIgQ29tcGxldGlvbkl0ZW07XG4oZnVuY3Rpb24gKENvbXBsZXRpb25JdGVtKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgY29tcGxldGlvbiBpdGVtIGFuZCBzZWVkIGl0IHdpdGggYSBsYWJlbC5cbiAgICAgKiBAcGFyYW0gbGFiZWwgVGhlIGNvbXBsZXRpb24gaXRlbSdzIGxhYmVsXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKGxhYmVsKSB7XG4gICAgICAgIHJldHVybiB7IGxhYmVsOiBsYWJlbCB9O1xuICAgIH1cbiAgICBDb21wbGV0aW9uSXRlbS5jcmVhdGUgPSBjcmVhdGU7XG59KShDb21wbGV0aW9uSXRlbSB8fCAoQ29tcGxldGlvbkl0ZW0gPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29tcGxldGlvbkxpc3QgbmFtZXNwYWNlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0byBkZWFsIHdpdGhcbiAqIGNvbXBsZXRpb24gbGlzdHMuXG4gKi9cbnZhciBDb21wbGV0aW9uTGlzdDtcbihmdW5jdGlvbiAoQ29tcGxldGlvbkxpc3QpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNvbXBsZXRpb24gbGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpdGVtcyBUaGUgY29tcGxldGlvbiBpdGVtcy5cbiAgICAgKiBAcGFyYW0gaXNJbmNvbXBsZXRlIFRoZSBsaXN0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUoaXRlbXMsIGlzSW5jb21wbGV0ZSkge1xuICAgICAgICByZXR1cm4geyBpdGVtczogaXRlbXMgPyBpdGVtcyA6IFtdLCBpc0luY29tcGxldGU6ICEhaXNJbmNvbXBsZXRlIH07XG4gICAgfVxuICAgIENvbXBsZXRpb25MaXN0LmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKENvbXBsZXRpb25MaXN0IHx8IChDb21wbGV0aW9uTGlzdCA9IHt9KSk7XG52YXIgTWFya2VkU3RyaW5nO1xuKGZ1bmN0aW9uIChNYXJrZWRTdHJpbmcpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbWFya2VkIHN0cmluZyBmcm9tIHBsYWluIHRleHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGxhaW5UZXh0IFRoZSBwbGFpbiB0ZXh0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21QbGFpblRleHQocGxhaW5UZXh0KSB7XG4gICAgICAgIHJldHVybiBwbGFpblRleHQucmVwbGFjZSgvW1xcXFxgKl97fVtcXF0oKSMrXFwtLiFdL2csICdcXFxcJCYnKTsgLy8gZXNjYXBlIG1hcmtkb3duIHN5bnRheCB0b2tlbnM6IGh0dHA6Ly9kYXJpbmdmaXJlYmFsbC5uZXQvcHJvamVjdHMvbWFya2Rvd24vc3ludGF4I2JhY2tzbGFzaFxuICAgIH1cbiAgICBNYXJrZWRTdHJpbmcuZnJvbVBsYWluVGV4dCA9IGZyb21QbGFpblRleHQ7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgTWFya2VkU3RyaW5nfSB0eXBlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLnN0cmluZyhjYW5kaWRhdGUpIHx8IChJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5sYW5ndWFnZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS52YWx1ZSkpO1xuICAgIH1cbiAgICBNYXJrZWRTdHJpbmcuaXMgPSBpcztcbn0pKE1hcmtlZFN0cmluZyB8fCAoTWFya2VkU3RyaW5nID0ge30pKTtcbnZhciBIb3ZlcjtcbihmdW5jdGlvbiAoSG92ZXIpIHtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgY29uZm9ybXMgdG8gdGhlIHtAbGluayBIb3Zlcn0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuICEhY2FuZGlkYXRlICYmIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiAoTWFya3VwQ29udGVudC5pcyhjYW5kaWRhdGUuY29udGVudHMpIHx8XG4gICAgICAgICAgICBNYXJrZWRTdHJpbmcuaXMoY2FuZGlkYXRlLmNvbnRlbnRzKSB8fFxuICAgICAgICAgICAgSXMudHlwZWRBcnJheShjYW5kaWRhdGUuY29udGVudHMsIE1hcmtlZFN0cmluZy5pcykpICYmICh2YWx1ZS5yYW5nZSA9PT0gdW5kZWZpbmVkIHx8IFJhbmdlLmlzKHZhbHVlLnJhbmdlKSk7XG4gICAgfVxuICAgIEhvdmVyLmlzID0gaXM7XG59KShIb3ZlciB8fCAoSG92ZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgUGFyYW1ldGVySW5mb3JtYXRpb24gbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgUGFyYW1ldGVySW5mb3JtYXRpb259IGxpdGVyYWxzLlxuICovXG52YXIgUGFyYW1ldGVySW5mb3JtYXRpb247XG4oZnVuY3Rpb24gKFBhcmFtZXRlckluZm9ybWF0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBwYXJhbWV0ZXIgaW5mb3JtYXRpb24gbGl0ZXJhbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsYWJlbCBBIGxhYmVsIHN0cmluZy5cbiAgICAgKiBAcGFyYW0gZG9jdW1lbnRhdGlvbiBBIGRvYyBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKGxhYmVsLCBkb2N1bWVudGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudGF0aW9uID8geyBsYWJlbDogbGFiZWwsIGRvY3VtZW50YXRpb246IGRvY3VtZW50YXRpb24gfSA6IHsgbGFiZWw6IGxhYmVsIH07XG4gICAgfVxuICAgIFBhcmFtZXRlckluZm9ybWF0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKFBhcmFtZXRlckluZm9ybWF0aW9uIHx8IChQYXJhbWV0ZXJJbmZvcm1hdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBTaWduYXR1cmVJbmZvcm1hdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBTaWduYXR1cmVJbmZvcm1hdGlvbn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBTaWduYXR1cmVJbmZvcm1hdGlvbjtcbihmdW5jdGlvbiAoU2lnbmF0dXJlSW5mb3JtYXRpb24pIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUobGFiZWwsIGRvY3VtZW50YXRpb24pIHtcbiAgICAgICAgdmFyIHBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHBhcmFtZXRlcnNbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgbGFiZWw6IGxhYmVsIH07XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKGRvY3VtZW50YXRpb24pKSB7XG4gICAgICAgICAgICByZXN1bHQuZG9jdW1lbnRhdGlvbiA9IGRvY3VtZW50YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzLmRlZmluZWQocGFyYW1ldGVycykpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wYXJhbWV0ZXJzID0gcGFyYW1ldGVycztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wYXJhbWV0ZXJzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgU2lnbmF0dXJlSW5mb3JtYXRpb24uY3JlYXRlID0gY3JlYXRlO1xufSkoU2lnbmF0dXJlSW5mb3JtYXRpb24gfHwgKFNpZ25hdHVyZUluZm9ybWF0aW9uID0ge30pKTtcbi8qKlxuICogQSBkb2N1bWVudCBoaWdobGlnaHQga2luZC5cbiAqL1xudmFyIERvY3VtZW50SGlnaGxpZ2h0S2luZDtcbihmdW5jdGlvbiAoRG9jdW1lbnRIaWdobGlnaHRLaW5kKSB7XG4gICAgLyoqXG4gICAgICogQSB0ZXh0dWFsIG9jY3VycmVuY2UuXG4gICAgICovXG4gICAgRG9jdW1lbnRIaWdobGlnaHRLaW5kLlRleHQgPSAxO1xuICAgIC8qKlxuICAgICAqIFJlYWQtYWNjZXNzIG9mIGEgc3ltYm9sLCBsaWtlIHJlYWRpbmcgYSB2YXJpYWJsZS5cbiAgICAgKi9cbiAgICBEb2N1bWVudEhpZ2hsaWdodEtpbmQuUmVhZCA9IDI7XG4gICAgLyoqXG4gICAgICogV3JpdGUtYWNjZXNzIG9mIGEgc3ltYm9sLCBsaWtlIHdyaXRpbmcgdG8gYSB2YXJpYWJsZS5cbiAgICAgKi9cbiAgICBEb2N1bWVudEhpZ2hsaWdodEtpbmQuV3JpdGUgPSAzO1xufSkoRG9jdW1lbnRIaWdobGlnaHRLaW5kIHx8IChEb2N1bWVudEhpZ2hsaWdodEtpbmQgPSB7fSkpO1xuLyoqXG4gKiBEb2N1bWVudEhpZ2hsaWdodCBuYW1lc3BhY2UgdG8gcHJvdmlkZSBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIERvY3VtZW50SGlnaGxpZ2h0fSBsaXRlcmFscy5cbiAqL1xudmFyIERvY3VtZW50SGlnaGxpZ2h0O1xuKGZ1bmN0aW9uIChEb2N1bWVudEhpZ2hsaWdodCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIERvY3VtZW50SGlnaGxpZ2h0IG9iamVjdC5cbiAgICAgKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIHRoZSBoaWdobGlnaHQgYXBwbGllcyB0by5cbiAgICAgKiBAcGFyYW0ga2luZCBUaGUgaGlnaGxpZ2h0IGtpbmRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIGtpbmQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgcmFuZ2U6IHJhbmdlIH07XG4gICAgICAgIGlmIChJcy5udW1iZXIoa2luZCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5raW5kID0ga2luZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBEb2N1bWVudEhpZ2hsaWdodC5jcmVhdGUgPSBjcmVhdGU7XG59KShEb2N1bWVudEhpZ2hsaWdodCB8fCAoRG9jdW1lbnRIaWdobGlnaHQgPSB7fSkpO1xuLyoqXG4gKiBBIHN5bWJvbCBraW5kLlxuICovXG52YXIgU3ltYm9sS2luZDtcbihmdW5jdGlvbiAoU3ltYm9sS2luZCkge1xuICAgIFN5bWJvbEtpbmQuRmlsZSA9IDE7XG4gICAgU3ltYm9sS2luZC5Nb2R1bGUgPSAyO1xuICAgIFN5bWJvbEtpbmQuTmFtZXNwYWNlID0gMztcbiAgICBTeW1ib2xLaW5kLlBhY2thZ2UgPSA0O1xuICAgIFN5bWJvbEtpbmQuQ2xhc3MgPSA1O1xuICAgIFN5bWJvbEtpbmQuTWV0aG9kID0gNjtcbiAgICBTeW1ib2xLaW5kLlByb3BlcnR5ID0gNztcbiAgICBTeW1ib2xLaW5kLkZpZWxkID0gODtcbiAgICBTeW1ib2xLaW5kLkNvbnN0cnVjdG9yID0gOTtcbiAgICBTeW1ib2xLaW5kLkVudW0gPSAxMDtcbiAgICBTeW1ib2xLaW5kLkludGVyZmFjZSA9IDExO1xuICAgIFN5bWJvbEtpbmQuRnVuY3Rpb24gPSAxMjtcbiAgICBTeW1ib2xLaW5kLlZhcmlhYmxlID0gMTM7XG4gICAgU3ltYm9sS2luZC5Db25zdGFudCA9IDE0O1xuICAgIFN5bWJvbEtpbmQuU3RyaW5nID0gMTU7XG4gICAgU3ltYm9sS2luZC5OdW1iZXIgPSAxNjtcbiAgICBTeW1ib2xLaW5kLkJvb2xlYW4gPSAxNztcbiAgICBTeW1ib2xLaW5kLkFycmF5ID0gMTg7XG4gICAgU3ltYm9sS2luZC5PYmplY3QgPSAxOTtcbiAgICBTeW1ib2xLaW5kLktleSA9IDIwO1xuICAgIFN5bWJvbEtpbmQuTnVsbCA9IDIxO1xuICAgIFN5bWJvbEtpbmQuRW51bU1lbWJlciA9IDIyO1xuICAgIFN5bWJvbEtpbmQuU3RydWN0ID0gMjM7XG4gICAgU3ltYm9sS2luZC5FdmVudCA9IDI0O1xuICAgIFN5bWJvbEtpbmQuT3BlcmF0b3IgPSAyNTtcbiAgICBTeW1ib2xLaW5kLlR5cGVQYXJhbWV0ZXIgPSAyNjtcbn0pKFN5bWJvbEtpbmQgfHwgKFN5bWJvbEtpbmQgPSB7fSkpO1xuLyoqXG4gKiBTeW1ib2wgdGFncyBhcmUgZXh0cmEgYW5ub3RhdGlvbnMgdGhhdCB0d2VhayB0aGUgcmVuZGVyaW5nIG9mIGEgc3ltYm9sLlxuICpcbiAqIEBzaW5jZSAzLjE2XG4gKi9cbnZhciBTeW1ib2xUYWc7XG4oZnVuY3Rpb24gKFN5bWJvbFRhZykge1xuICAgIC8qKlxuICAgICAqIFJlbmRlciBhIHN5bWJvbCBhcyBvYnNvbGV0ZSwgdXN1YWxseSB1c2luZyBhIHN0cmlrZS1vdXQuXG4gICAgICovXG4gICAgU3ltYm9sVGFnLkRlcHJlY2F0ZWQgPSAxO1xufSkoU3ltYm9sVGFnIHx8IChTeW1ib2xUYWcgPSB7fSkpO1xudmFyIFN5bWJvbEluZm9ybWF0aW9uO1xuKGZ1bmN0aW9uIChTeW1ib2xJbmZvcm1hdGlvbikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgc3ltYm9sIGluZm9ybWF0aW9uIGxpdGVyYWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSBraW5kIFRoZSBraW5kIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSBvZiB0aGUgbG9jYXRpb24gb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSByZXNvdXJjZSBvZiB0aGUgbG9jYXRpb24gb2Ygc3ltYm9sLlxuICAgICAqIEBwYXJhbSBjb250YWluZXJOYW1lIFRoZSBuYW1lIG9mIHRoZSBzeW1ib2wgY29udGFpbmluZyB0aGUgc3ltYm9sLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShuYW1lLCBraW5kLCByYW5nZSwgdXJpLCBjb250YWluZXJOYW1lKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAga2luZDoga2luZCxcbiAgICAgICAgICAgIGxvY2F0aW9uOiB7IHVyaTogdXJpLCByYW5nZTogcmFuZ2UgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoY29udGFpbmVyTmFtZSkge1xuICAgICAgICAgICAgcmVzdWx0LmNvbnRhaW5lck5hbWUgPSBjb250YWluZXJOYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIFN5bWJvbEluZm9ybWF0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKFN5bWJvbEluZm9ybWF0aW9uIHx8IChTeW1ib2xJbmZvcm1hdGlvbiA9IHt9KSk7XG52YXIgV29ya3NwYWNlU3ltYm9sO1xuKGZ1bmN0aW9uIChXb3Jrc3BhY2VTeW1ib2wpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgd29ya3NwYWNlIHN5bWJvbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIGtpbmQgVGhlIGtpbmQgb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSByZXNvdXJjZSBvZiB0aGUgbG9jYXRpb24gb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gcmFuZ2UgQW4gb3B0aW9ucyByYW5nZSBvZiB0aGUgbG9jYXRpb24uXG4gICAgICogQHJldHVybnMgQSBXb3Jrc3BhY2VTeW1ib2wuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKG5hbWUsIGtpbmQsIHVyaSwgcmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8geyBuYW1lOiBuYW1lLCBraW5kOiBraW5kLCBsb2NhdGlvbjogeyB1cmk6IHVyaSwgcmFuZ2U6IHJhbmdlIH0gfVxuICAgICAgICAgICAgOiB7IG5hbWU6IG5hbWUsIGtpbmQ6IGtpbmQsIGxvY2F0aW9uOiB7IHVyaTogdXJpIH0gfTtcbiAgICB9XG4gICAgV29ya3NwYWNlU3ltYm9sLmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKFdvcmtzcGFjZVN5bWJvbCB8fCAoV29ya3NwYWNlU3ltYm9sID0ge30pKTtcbnZhciBEb2N1bWVudFN5bWJvbDtcbihmdW5jdGlvbiAoRG9jdW1lbnRTeW1ib2wpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHN5bWJvbCBpbmZvcm1hdGlvbiBsaXRlcmFsLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gZGV0YWlsIFRoZSBkZXRhaWwgb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0ga2luZCBUaGUga2luZCBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2Ugb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gc2VsZWN0aW9uUmFuZ2UgVGhlIHNlbGVjdGlvblJhbmdlIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIGNoaWxkcmVuIENoaWxkcmVuIG9mIHRoZSBzeW1ib2wuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKG5hbWUsIGRldGFpbCwga2luZCwgcmFuZ2UsIHNlbGVjdGlvblJhbmdlLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGRldGFpbDogZGV0YWlsLFxuICAgICAgICAgICAga2luZDoga2luZCxcbiAgICAgICAgICAgIHJhbmdlOiByYW5nZSxcbiAgICAgICAgICAgIHNlbGVjdGlvblJhbmdlOiBzZWxlY3Rpb25SYW5nZVxuICAgICAgICB9O1xuICAgICAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgRG9jdW1lbnRTeW1ib2wuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgRG9jdW1lbnRTeW1ib2x9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiZcbiAgICAgICAgICAgIElzLnN0cmluZyhjYW5kaWRhdGUubmFtZSkgJiYgSXMubnVtYmVyKGNhbmRpZGF0ZS5raW5kKSAmJlxuICAgICAgICAgICAgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUuc2VsZWN0aW9uUmFuZ2UpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmRldGFpbCA9PT0gdW5kZWZpbmVkIHx8IElzLnN0cmluZyhjYW5kaWRhdGUuZGV0YWlsKSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuZGVwcmVjYXRlZCA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLmRlcHJlY2F0ZWQpKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5jaGlsZHJlbiA9PT0gdW5kZWZpbmVkIHx8IEFycmF5LmlzQXJyYXkoY2FuZGlkYXRlLmNoaWxkcmVuKSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUudGFncyA9PT0gdW5kZWZpbmVkIHx8IEFycmF5LmlzQXJyYXkoY2FuZGlkYXRlLnRhZ3MpKTtcbiAgICB9XG4gICAgRG9jdW1lbnRTeW1ib2wuaXMgPSBpcztcbn0pKERvY3VtZW50U3ltYm9sIHx8IChEb2N1bWVudFN5bWJvbCA9IHt9KSk7XG4vKipcbiAqIEEgc2V0IG9mIHByZWRlZmluZWQgY29kZSBhY3Rpb24ga2luZHNcbiAqL1xudmFyIENvZGVBY3Rpb25LaW5kO1xuKGZ1bmN0aW9uIChDb2RlQWN0aW9uS2luZCkge1xuICAgIC8qKlxuICAgICAqIEVtcHR5IGtpbmQuXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuRW1wdHkgPSAnJztcbiAgICAvKipcbiAgICAgKiBCYXNlIGtpbmQgZm9yIHF1aWNrZml4IGFjdGlvbnM6ICdxdWlja2ZpeCdcbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5RdWlja0ZpeCA9ICdxdWlja2ZpeCc7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciByZWZhY3RvcmluZyBhY3Rpb25zOiAncmVmYWN0b3InXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuUmVmYWN0b3IgPSAncmVmYWN0b3InO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3IgcmVmYWN0b3JpbmcgZXh0cmFjdGlvbiBhY3Rpb25zOiAncmVmYWN0b3IuZXh0cmFjdCdcbiAgICAgKlxuICAgICAqIEV4YW1wbGUgZXh0cmFjdCBhY3Rpb25zOlxuICAgICAqXG4gICAgICogLSBFeHRyYWN0IG1ldGhvZFxuICAgICAqIC0gRXh0cmFjdCBmdW5jdGlvblxuICAgICAqIC0gRXh0cmFjdCB2YXJpYWJsZVxuICAgICAqIC0gRXh0cmFjdCBpbnRlcmZhY2UgZnJvbSBjbGFzc1xuICAgICAqIC0gLi4uXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuUmVmYWN0b3JFeHRyYWN0ID0gJ3JlZmFjdG9yLmV4dHJhY3QnO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3IgcmVmYWN0b3JpbmcgaW5saW5lIGFjdGlvbnM6ICdyZWZhY3Rvci5pbmxpbmUnXG4gICAgICpcbiAgICAgKiBFeGFtcGxlIGlubGluZSBhY3Rpb25zOlxuICAgICAqXG4gICAgICogLSBJbmxpbmUgZnVuY3Rpb25cbiAgICAgKiAtIElubGluZSB2YXJpYWJsZVxuICAgICAqIC0gSW5saW5lIGNvbnN0YW50XG4gICAgICogLSAuLi5cbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5SZWZhY3RvcklubGluZSA9ICdyZWZhY3Rvci5pbmxpbmUnO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3IgcmVmYWN0b3JpbmcgcmV3cml0ZSBhY3Rpb25zOiAncmVmYWN0b3IucmV3cml0ZSdcbiAgICAgKlxuICAgICAqIEV4YW1wbGUgcmV3cml0ZSBhY3Rpb25zOlxuICAgICAqXG4gICAgICogLSBDb252ZXJ0IEphdmFTY3JpcHQgZnVuY3Rpb24gdG8gY2xhc3NcbiAgICAgKiAtIEFkZCBvciByZW1vdmUgcGFyYW1ldGVyXG4gICAgICogLSBFbmNhcHN1bGF0ZSBmaWVsZFxuICAgICAqIC0gTWFrZSBtZXRob2Qgc3RhdGljXG4gICAgICogLSBNb3ZlIG1ldGhvZCB0byBiYXNlIGNsYXNzXG4gICAgICogLSAuLi5cbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5SZWZhY3RvclJld3JpdGUgPSAncmVmYWN0b3IucmV3cml0ZSc7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciBzb3VyY2UgYWN0aW9uczogYHNvdXJjZWBcbiAgICAgKlxuICAgICAqIFNvdXJjZSBjb2RlIGFjdGlvbnMgYXBwbHkgdG8gdGhlIGVudGlyZSBmaWxlLlxuICAgICAqL1xuICAgIENvZGVBY3Rpb25LaW5kLlNvdXJjZSA9ICdzb3VyY2UnO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3IgYW4gb3JnYW5pemUgaW1wb3J0cyBzb3VyY2UgYWN0aW9uOiBgc291cmNlLm9yZ2FuaXplSW1wb3J0c2BcbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5Tb3VyY2VPcmdhbml6ZUltcG9ydHMgPSAnc291cmNlLm9yZ2FuaXplSW1wb3J0cyc7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciBhdXRvLWZpeCBzb3VyY2UgYWN0aW9uczogYHNvdXJjZS5maXhBbGxgLlxuICAgICAqXG4gICAgICogRml4IGFsbCBhY3Rpb25zIGF1dG9tYXRpY2FsbHkgZml4IGVycm9ycyB0aGF0IGhhdmUgYSBjbGVhciBmaXggdGhhdCBkbyBub3QgcmVxdWlyZSB1c2VyIGlucHV0LlxuICAgICAqIFRoZXkgc2hvdWxkIG5vdCBzdXBwcmVzcyBlcnJvcnMgb3IgcGVyZm9ybSB1bnNhZmUgZml4ZXMgc3VjaCBhcyBnZW5lcmF0aW5nIG5ldyB0eXBlcyBvciBjbGFzc2VzLlxuICAgICAqXG4gICAgICogQHNpbmNlIDMuMTUuMFxuICAgICAqL1xuICAgIENvZGVBY3Rpb25LaW5kLlNvdXJjZUZpeEFsbCA9ICdzb3VyY2UuZml4QWxsJztcbn0pKENvZGVBY3Rpb25LaW5kIHx8IChDb2RlQWN0aW9uS2luZCA9IHt9KSk7XG4vKipcbiAqIFRoZSByZWFzb24gd2h5IGNvZGUgYWN0aW9ucyB3ZXJlIHJlcXVlc3RlZC5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBDb2RlQWN0aW9uVHJpZ2dlcktpbmQ7XG4oZnVuY3Rpb24gKENvZGVBY3Rpb25UcmlnZ2VyS2luZCkge1xuICAgIC8qKlxuICAgICAqIENvZGUgYWN0aW9ucyB3ZXJlIGV4cGxpY2l0bHkgcmVxdWVzdGVkIGJ5IHRoZSB1c2VyIG9yIGJ5IGFuIGV4dGVuc2lvbi5cbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uVHJpZ2dlcktpbmQuSW52b2tlZCA9IDE7XG4gICAgLyoqXG4gICAgICogQ29kZSBhY3Rpb25zIHdlcmUgcmVxdWVzdGVkIGF1dG9tYXRpY2FsbHkuXG4gICAgICpcbiAgICAgKiBUaGlzIHR5cGljYWxseSBoYXBwZW5zIHdoZW4gY3VycmVudCBzZWxlY3Rpb24gaW4gYSBmaWxlIGNoYW5nZXMsIGJ1dCBjYW5cbiAgICAgKiBhbHNvIGJlIHRyaWdnZXJlZCB3aGVuIGZpbGUgY29udGVudCBjaGFuZ2VzLlxuICAgICAqL1xuICAgIENvZGVBY3Rpb25UcmlnZ2VyS2luZC5BdXRvbWF0aWMgPSAyO1xufSkoQ29kZUFjdGlvblRyaWdnZXJLaW5kIHx8IChDb2RlQWN0aW9uVHJpZ2dlcktpbmQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29kZUFjdGlvbkNvbnRleHQgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgQ29kZUFjdGlvbkNvbnRleHR9IGxpdGVyYWxzLlxuICovXG52YXIgQ29kZUFjdGlvbkNvbnRleHQ7XG4oZnVuY3Rpb24gKENvZGVBY3Rpb25Db250ZXh0KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBDb2RlQWN0aW9uQ29udGV4dCBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShkaWFnbm9zdGljcywgb25seSwgdHJpZ2dlcktpbmQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgZGlhZ25vc3RpY3M6IGRpYWdub3N0aWNzIH07XG4gICAgICAgIGlmIChvbmx5ICE9PSB1bmRlZmluZWQgJiYgb25seSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0Lm9ubHkgPSBvbmx5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmlnZ2VyS2luZCAhPT0gdW5kZWZpbmVkICYmIHRyaWdnZXJLaW5kICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQudHJpZ2dlcktpbmQgPSB0cmlnZ2VyS2luZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBDb2RlQWN0aW9uQ29udGV4dC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBDb2RlQWN0aW9uQ29udGV4dH0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5kaWFnbm9zdGljcywgRGlhZ25vc3RpYy5pcylcbiAgICAgICAgICAgICYmIChjYW5kaWRhdGUub25seSA9PT0gdW5kZWZpbmVkIHx8IElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLm9ubHksIElzLnN0cmluZykpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLnRyaWdnZXJLaW5kID09PSB1bmRlZmluZWQgfHwgY2FuZGlkYXRlLnRyaWdnZXJLaW5kID09PSBDb2RlQWN0aW9uVHJpZ2dlcktpbmQuSW52b2tlZCB8fCBjYW5kaWRhdGUudHJpZ2dlcktpbmQgPT09IENvZGVBY3Rpb25UcmlnZ2VyS2luZC5BdXRvbWF0aWMpO1xuICAgIH1cbiAgICBDb2RlQWN0aW9uQ29udGV4dC5pcyA9IGlzO1xufSkoQ29kZUFjdGlvbkNvbnRleHQgfHwgKENvZGVBY3Rpb25Db250ZXh0ID0ge30pKTtcbnZhciBDb2RlQWN0aW9uO1xuKGZ1bmN0aW9uIChDb2RlQWN0aW9uKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHRpdGxlLCBraW5kT3JDb21tYW5kT3JFZGl0LCBraW5kKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7IHRpdGxlOiB0aXRsZSB9O1xuICAgICAgICB2YXIgY2hlY2tLaW5kID0gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBraW5kT3JDb21tYW5kT3JFZGl0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY2hlY2tLaW5kID0gZmFsc2U7XG4gICAgICAgICAgICByZXN1bHQua2luZCA9IGtpbmRPckNvbW1hbmRPckVkaXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQ29tbWFuZC5pcyhraW5kT3JDb21tYW5kT3JFZGl0KSkge1xuICAgICAgICAgICAgcmVzdWx0LmNvbW1hbmQgPSBraW5kT3JDb21tYW5kT3JFZGl0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LmVkaXQgPSBraW5kT3JDb21tYW5kT3JFZGl0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGVja0tpbmQgJiYga2luZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQua2luZCA9IGtpbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgQ29kZUFjdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIElzLnN0cmluZyhjYW5kaWRhdGUudGl0bGUpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmRpYWdub3N0aWNzID09PSB1bmRlZmluZWQgfHwgSXMudHlwZWRBcnJheShjYW5kaWRhdGUuZGlhZ25vc3RpY3MsIERpYWdub3N0aWMuaXMpKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5raW5kID09PSB1bmRlZmluZWQgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5raW5kKSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuZWRpdCAhPT0gdW5kZWZpbmVkIHx8IGNhbmRpZGF0ZS5jb21tYW5kICE9PSB1bmRlZmluZWQpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmNvbW1hbmQgPT09IHVuZGVmaW5lZCB8fCBDb21tYW5kLmlzKGNhbmRpZGF0ZS5jb21tYW5kKSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuaXNQcmVmZXJyZWQgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5pc1ByZWZlcnJlZCkpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmVkaXQgPT09IHVuZGVmaW5lZCB8fCBXb3Jrc3BhY2VFZGl0LmlzKGNhbmRpZGF0ZS5lZGl0KSk7XG4gICAgfVxuICAgIENvZGVBY3Rpb24uaXMgPSBpcztcbn0pKENvZGVBY3Rpb24gfHwgKENvZGVBY3Rpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29kZUxlbnMgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgQ29kZUxlbnN9IGxpdGVyYWxzLlxuICovXG52YXIgQ29kZUxlbnM7XG4oZnVuY3Rpb24gKENvZGVMZW5zKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBDb2RlTGVucyBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgZGF0YSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0geyByYW5nZTogcmFuZ2UgfTtcbiAgICAgICAgaWYgKElzLmRlZmluZWQoZGF0YSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5kYXRhID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBDb2RlTGVucy5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBDb2RlTGVuc30gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLmNvbW1hbmQpIHx8IENvbW1hbmQuaXMoY2FuZGlkYXRlLmNvbW1hbmQpKTtcbiAgICB9XG4gICAgQ29kZUxlbnMuaXMgPSBpcztcbn0pKENvZGVMZW5zIHx8IChDb2RlTGVucyA9IHt9KSk7XG4vKipcbiAqIFRoZSBGb3JtYXR0aW5nT3B0aW9ucyBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBGb3JtYXR0aW5nT3B0aW9uc30gbGl0ZXJhbHMuXG4gKi9cbnZhciBGb3JtYXR0aW5nT3B0aW9ucztcbihmdW5jdGlvbiAoRm9ybWF0dGluZ09wdGlvbnMpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEZvcm1hdHRpbmdPcHRpb25zIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHRhYlNpemUsIGluc2VydFNwYWNlcykge1xuICAgICAgICByZXR1cm4geyB0YWJTaXplOiB0YWJTaXplLCBpbnNlcnRTcGFjZXM6IGluc2VydFNwYWNlcyB9O1xuICAgIH1cbiAgICBGb3JtYXR0aW5nT3B0aW9ucy5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBGb3JtYXR0aW5nT3B0aW9uc30gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy51aW50ZWdlcihjYW5kaWRhdGUudGFiU2l6ZSkgJiYgSXMuYm9vbGVhbihjYW5kaWRhdGUuaW5zZXJ0U3BhY2VzKTtcbiAgICB9XG4gICAgRm9ybWF0dGluZ09wdGlvbnMuaXMgPSBpcztcbn0pKEZvcm1hdHRpbmdPcHRpb25zIHx8IChGb3JtYXR0aW5nT3B0aW9ucyA9IHt9KSk7XG4vKipcbiAqIFRoZSBEb2N1bWVudExpbmsgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgRG9jdW1lbnRMaW5rfSBsaXRlcmFscy5cbiAqL1xudmFyIERvY3VtZW50TGluaztcbihmdW5jdGlvbiAoRG9jdW1lbnRMaW5rKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBEb2N1bWVudExpbmsgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIHRhcmdldCwgZGF0YSkge1xuICAgICAgICByZXR1cm4geyByYW5nZTogcmFuZ2UsIHRhcmdldDogdGFyZ2V0LCBkYXRhOiBkYXRhIH07XG4gICAgfVxuICAgIERvY3VtZW50TGluay5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBEb2N1bWVudExpbmt9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS50YXJnZXQpIHx8IElzLnN0cmluZyhjYW5kaWRhdGUudGFyZ2V0KSk7XG4gICAgfVxuICAgIERvY3VtZW50TGluay5pcyA9IGlzO1xufSkoRG9jdW1lbnRMaW5rIHx8IChEb2N1bWVudExpbmsgPSB7fSkpO1xuLyoqXG4gKiBUaGUgU2VsZWN0aW9uUmFuZ2UgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbiB0byB3b3JrIHdpdGhcbiAqIFNlbGVjdGlvblJhbmdlIGxpdGVyYWxzLlxuICovXG52YXIgU2VsZWN0aW9uUmFuZ2U7XG4oZnVuY3Rpb24gKFNlbGVjdGlvblJhbmdlKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBTZWxlY3Rpb25SYW5nZVxuICAgICAqIEBwYXJhbSByYW5nZSB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHBhcmVudCBhbiBvcHRpb25hbCBwYXJlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCBwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IHJhbmdlLCBwYXJlbnQ6IHBhcmVudCB9O1xuICAgIH1cbiAgICBTZWxlY3Rpb25SYW5nZS5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgKGNhbmRpZGF0ZS5wYXJlbnQgPT09IHVuZGVmaW5lZCB8fCBTZWxlY3Rpb25SYW5nZS5pcyhjYW5kaWRhdGUucGFyZW50KSk7XG4gICAgfVxuICAgIFNlbGVjdGlvblJhbmdlLmlzID0gaXM7XG59KShTZWxlY3Rpb25SYW5nZSB8fCAoU2VsZWN0aW9uUmFuZ2UgPSB7fSkpO1xuLyoqXG4gKiBBIHNldCBvZiBwcmVkZWZpbmVkIHRva2VuIHR5cGVzLiBUaGlzIHNldCBpcyBub3QgZml4ZWRcbiAqIGFuIGNsaWVudHMgY2FuIHNwZWNpZnkgYWRkaXRpb25hbCB0b2tlbiB0eXBlcyB2aWEgdGhlXG4gKiBjb3JyZXNwb25kaW5nIGNsaWVudCBjYXBhYmlsaXRpZXMuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgU2VtYW50aWNUb2tlblR5cGVzO1xuKGZ1bmN0aW9uIChTZW1hbnRpY1Rva2VuVHlwZXMpIHtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJuYW1lc3BhY2VcIl0gPSBcIm5hbWVzcGFjZVwiO1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBnZW5lcmljIHR5cGUuIEFjdHMgYXMgYSBmYWxsYmFjayBmb3IgdHlwZXMgd2hpY2ggY2FuJ3QgYmUgbWFwcGVkIHRvXG4gICAgICogYSBzcGVjaWZpYyB0eXBlIGxpa2UgY2xhc3Mgb3IgZW51bS5cbiAgICAgKi9cbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJ0eXBlXCJdID0gXCJ0eXBlXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wiY2xhc3NcIl0gPSBcImNsYXNzXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wiZW51bVwiXSA9IFwiZW51bVwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcImludGVyZmFjZVwiXSA9IFwiaW50ZXJmYWNlXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wic3RydWN0XCJdID0gXCJzdHJ1Y3RcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJ0eXBlUGFyYW1ldGVyXCJdID0gXCJ0eXBlUGFyYW1ldGVyXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wicGFyYW1ldGVyXCJdID0gXCJwYXJhbWV0ZXJcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJ2YXJpYWJsZVwiXSA9IFwidmFyaWFibGVcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJwcm9wZXJ0eVwiXSA9IFwicHJvcGVydHlcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJlbnVtTWVtYmVyXCJdID0gXCJlbnVtTWVtYmVyXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wiZXZlbnRcIl0gPSBcImV2ZW50XCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wiZnVuY3Rpb25cIl0gPSBcImZ1bmN0aW9uXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wibWV0aG9kXCJdID0gXCJtZXRob2RcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJtYWNyb1wiXSA9IFwibWFjcm9cIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJrZXl3b3JkXCJdID0gXCJrZXl3b3JkXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wibW9kaWZpZXJcIl0gPSBcIm1vZGlmaWVyXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wiY29tbWVudFwiXSA9IFwiY29tbWVudFwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInN0cmluZ1wiXSA9IFwic3RyaW5nXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wibnVtYmVyXCJdID0gXCJudW1iZXJcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJyZWdleHBcIl0gPSBcInJlZ2V4cFwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcIm9wZXJhdG9yXCJdID0gXCJvcGVyYXRvclwiO1xuICAgIC8qKlxuICAgICAqIEBzaW5jZSAzLjE3LjBcbiAgICAgKi9cbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJkZWNvcmF0b3JcIl0gPSBcImRlY29yYXRvclwiO1xufSkoU2VtYW50aWNUb2tlblR5cGVzIHx8IChTZW1hbnRpY1Rva2VuVHlwZXMgPSB7fSkpO1xuLyoqXG4gKiBBIHNldCBvZiBwcmVkZWZpbmVkIHRva2VuIG1vZGlmaWVycy4gVGhpcyBzZXQgaXMgbm90IGZpeGVkXG4gKiBhbiBjbGllbnRzIGNhbiBzcGVjaWZ5IGFkZGl0aW9uYWwgdG9rZW4gdHlwZXMgdmlhIHRoZVxuICogY29ycmVzcG9uZGluZyBjbGllbnQgY2FwYWJpbGl0aWVzLlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIFNlbWFudGljVG9rZW5Nb2RpZmllcnM7XG4oZnVuY3Rpb24gKFNlbWFudGljVG9rZW5Nb2RpZmllcnMpIHtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wiZGVjbGFyYXRpb25cIl0gPSBcImRlY2xhcmF0aW9uXCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcImRlZmluaXRpb25cIl0gPSBcImRlZmluaXRpb25cIjtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wicmVhZG9ubHlcIl0gPSBcInJlYWRvbmx5XCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcInN0YXRpY1wiXSA9IFwic3RhdGljXCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcImRlcHJlY2F0ZWRcIl0gPSBcImRlcHJlY2F0ZWRcIjtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wiYWJzdHJhY3RcIl0gPSBcImFic3RyYWN0XCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcImFzeW5jXCJdID0gXCJhc3luY1wiO1xuICAgIFNlbWFudGljVG9rZW5Nb2RpZmllcnNbXCJtb2RpZmljYXRpb25cIl0gPSBcIm1vZGlmaWNhdGlvblwiO1xuICAgIFNlbWFudGljVG9rZW5Nb2RpZmllcnNbXCJkb2N1bWVudGF0aW9uXCJdID0gXCJkb2N1bWVudGF0aW9uXCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcImRlZmF1bHRMaWJyYXJ5XCJdID0gXCJkZWZhdWx0TGlicmFyeVwiO1xufSkoU2VtYW50aWNUb2tlbk1vZGlmaWVycyB8fCAoU2VtYW50aWNUb2tlbk1vZGlmaWVycyA9IHt9KSk7XG4vKipcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIFNlbWFudGljVG9rZW5zO1xuKGZ1bmN0aW9uIChTZW1hbnRpY1Rva2Vucykge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiAoY2FuZGlkYXRlLnJlc3VsdElkID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGNhbmRpZGF0ZS5yZXN1bHRJZCA9PT0gJ3N0cmluZycpICYmXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KGNhbmRpZGF0ZS5kYXRhKSAmJiAoY2FuZGlkYXRlLmRhdGEubGVuZ3RoID09PSAwIHx8IHR5cGVvZiBjYW5kaWRhdGUuZGF0YVswXSA9PT0gJ251bWJlcicpO1xuICAgIH1cbiAgICBTZW1hbnRpY1Rva2Vucy5pcyA9IGlzO1xufSkoU2VtYW50aWNUb2tlbnMgfHwgKFNlbWFudGljVG9rZW5zID0ge30pKTtcbi8qKlxuICogVGhlIElubGluZVZhbHVlVGV4dCBuYW1lc3BhY2UgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGRlYWwgd2l0aCBJbmxpbmVWYWx1ZVRleHRzLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIElubGluZVZhbHVlVGV4dDtcbihmdW5jdGlvbiAoSW5saW5lVmFsdWVUZXh0KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBJbmxpbmVWYWx1ZVRleHQgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IHJhbmdlLCB0ZXh0OiB0ZXh0IH07XG4gICAgfVxuICAgIElubGluZVZhbHVlVGV4dC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICE9PSB1bmRlZmluZWQgJiYgY2FuZGlkYXRlICE9PSBudWxsICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS50ZXh0KTtcbiAgICB9XG4gICAgSW5saW5lVmFsdWVUZXh0LmlzID0gaXM7XG59KShJbmxpbmVWYWx1ZVRleHQgfHwgKElubGluZVZhbHVlVGV4dCA9IHt9KSk7XG4vKipcbiAqIFRoZSBJbmxpbmVWYWx1ZVZhcmlhYmxlTG9va3VwIG5hbWVzcGFjZSBwcm92aWRlcyBmdW5jdGlvbnMgdG8gZGVhbCB3aXRoIElubGluZVZhbHVlVmFyaWFibGVMb29rdXBzLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIElubGluZVZhbHVlVmFyaWFibGVMb29rdXA7XG4oZnVuY3Rpb24gKElubGluZVZhbHVlVmFyaWFibGVMb29rdXApIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IElubGluZVZhbHVlVGV4dCBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgdmFyaWFibGVOYW1lLCBjYXNlU2Vuc2l0aXZlTG9va3VwKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiByYW5nZSwgdmFyaWFibGVOYW1lOiB2YXJpYWJsZU5hbWUsIGNhc2VTZW5zaXRpdmVMb29rdXA6IGNhc2VTZW5zaXRpdmVMb29rdXAgfTtcbiAgICB9XG4gICAgSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICE9PSB1bmRlZmluZWQgJiYgY2FuZGlkYXRlICE9PSBudWxsICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgSXMuYm9vbGVhbihjYW5kaWRhdGUuY2FzZVNlbnNpdGl2ZUxvb2t1cClcbiAgICAgICAgICAgICYmIChJcy5zdHJpbmcoY2FuZGlkYXRlLnZhcmlhYmxlTmFtZSkgfHwgY2FuZGlkYXRlLnZhcmlhYmxlTmFtZSA9PT0gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cC5pcyA9IGlzO1xufSkoSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cCB8fCAoSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cCA9IHt9KSk7XG4vKipcbiAqIFRoZSBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbiBuYW1lc3BhY2UgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGRlYWwgd2l0aCBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbi5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbjtcbihmdW5jdGlvbiAoSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb24pIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCBleHByZXNzaW9uKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiByYW5nZSwgZXhwcmVzc2lvbjogZXhwcmVzc2lvbiB9O1xuICAgIH1cbiAgICBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICE9PSB1bmRlZmluZWQgJiYgY2FuZGlkYXRlICE9PSBudWxsICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSlcbiAgICAgICAgICAgICYmIChJcy5zdHJpbmcoY2FuZGlkYXRlLmV4cHJlc3Npb24pIHx8IGNhbmRpZGF0ZS5leHByZXNzaW9uID09PSB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbi5pcyA9IGlzO1xufSkoSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb24gfHwgKElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uID0ge30pKTtcbi8qKlxuICogVGhlIElubGluZVZhbHVlQ29udGV4dCBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBJbmxpbmVWYWx1ZUNvbnRleHR9IGxpdGVyYWxzLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIElubGluZVZhbHVlQ29udGV4dDtcbihmdW5jdGlvbiAoSW5saW5lVmFsdWVDb250ZXh0KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBJbmxpbmVWYWx1ZUNvbnRleHQgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUoZnJhbWVJZCwgc3RvcHBlZExvY2F0aW9uKSB7XG4gICAgICAgIHJldHVybiB7IGZyYW1lSWQ6IGZyYW1lSWQsIHN0b3BwZWRMb2NhdGlvbjogc3RvcHBlZExvY2F0aW9uIH07XG4gICAgfVxuICAgIElubGluZVZhbHVlQ29udGV4dC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBJbmxpbmVWYWx1ZUNvbnRleHR9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXModmFsdWUuc3RvcHBlZExvY2F0aW9uKTtcbiAgICB9XG4gICAgSW5saW5lVmFsdWVDb250ZXh0LmlzID0gaXM7XG59KShJbmxpbmVWYWx1ZUNvbnRleHQgfHwgKElubGluZVZhbHVlQ29udGV4dCA9IHt9KSk7XG4vKipcbiAqIElubGF5IGhpbnQga2luZHMuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG52YXIgSW5sYXlIaW50S2luZDtcbihmdW5jdGlvbiAoSW5sYXlIaW50S2luZCkge1xuICAgIC8qKlxuICAgICAqIEFuIGlubGF5IGhpbnQgdGhhdCBmb3IgYSB0eXBlIGFubm90YXRpb24uXG4gICAgICovXG4gICAgSW5sYXlIaW50S2luZC5UeXBlID0gMTtcbiAgICAvKipcbiAgICAgKiBBbiBpbmxheSBoaW50IHRoYXQgaXMgZm9yIGEgcGFyYW1ldGVyLlxuICAgICAqL1xuICAgIElubGF5SGludEtpbmQuUGFyYW1ldGVyID0gMjtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IDEgfHwgdmFsdWUgPT09IDI7XG4gICAgfVxuICAgIElubGF5SGludEtpbmQuaXMgPSBpcztcbn0pKElubGF5SGludEtpbmQgfHwgKElubGF5SGludEtpbmQgPSB7fSkpO1xudmFyIElubGF5SGludExhYmVsUGFydDtcbihmdW5jdGlvbiAoSW5sYXlIaW50TGFiZWxQYXJ0KSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiB2YWx1ZSB9O1xuICAgIH1cbiAgICBJbmxheUhpbnRMYWJlbFBhcnQuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS50b29sdGlwID09PSB1bmRlZmluZWQgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS50b29sdGlwKSB8fCBNYXJrdXBDb250ZW50LmlzKGNhbmRpZGF0ZS50b29sdGlwKSlcbiAgICAgICAgICAgICYmIChjYW5kaWRhdGUubG9jYXRpb24gPT09IHVuZGVmaW5lZCB8fCBMb2NhdGlvbi5pcyhjYW5kaWRhdGUubG9jYXRpb24pKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS5jb21tYW5kID09PSB1bmRlZmluZWQgfHwgQ29tbWFuZC5pcyhjYW5kaWRhdGUuY29tbWFuZCkpO1xuICAgIH1cbiAgICBJbmxheUhpbnRMYWJlbFBhcnQuaXMgPSBpcztcbn0pKElubGF5SGludExhYmVsUGFydCB8fCAoSW5sYXlIaW50TGFiZWxQYXJ0ID0ge30pKTtcbnZhciBJbmxheUhpbnQ7XG4oZnVuY3Rpb24gKElubGF5SGludCkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShwb3NpdGlvbiwgbGFiZWwsIGtpbmQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHsgcG9zaXRpb246IHBvc2l0aW9uLCBsYWJlbDogbGFiZWwgfTtcbiAgICAgICAgaWYgKGtpbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmtpbmQgPSBraW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIElubGF5SGludC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIFBvc2l0aW9uLmlzKGNhbmRpZGF0ZS5wb3NpdGlvbilcbiAgICAgICAgICAgICYmIChJcy5zdHJpbmcoY2FuZGlkYXRlLmxhYmVsKSB8fCBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5sYWJlbCwgSW5sYXlIaW50TGFiZWxQYXJ0LmlzKSlcbiAgICAgICAgICAgICYmIChjYW5kaWRhdGUua2luZCA9PT0gdW5kZWZpbmVkIHx8IElubGF5SGludEtpbmQuaXMoY2FuZGlkYXRlLmtpbmQpKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS50ZXh0RWRpdHMgPT09IHVuZGVmaW5lZCkgfHwgSXMudHlwZWRBcnJheShjYW5kaWRhdGUudGV4dEVkaXRzLCBUZXh0RWRpdC5pcylcbiAgICAgICAgICAgICYmIChjYW5kaWRhdGUudG9vbHRpcCA9PT0gdW5kZWZpbmVkIHx8IElzLnN0cmluZyhjYW5kaWRhdGUudG9vbHRpcCkgfHwgTWFya3VwQ29udGVudC5pcyhjYW5kaWRhdGUudG9vbHRpcCkpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLnBhZGRpbmdMZWZ0ID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUucGFkZGluZ0xlZnQpKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS5wYWRkaW5nUmlnaHQgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5wYWRkaW5nUmlnaHQpKTtcbiAgICB9XG4gICAgSW5sYXlIaW50LmlzID0gaXM7XG59KShJbmxheUhpbnQgfHwgKElubGF5SGludCA9IHt9KSk7XG52YXIgV29ya3NwYWNlRm9sZGVyO1xuKGZ1bmN0aW9uIChXb3Jrc3BhY2VGb2xkZXIpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgVVJJLmlzKGNhbmRpZGF0ZS51cmkpICYmIElzLnN0cmluZyhjYW5kaWRhdGUubmFtZSk7XG4gICAgfVxuICAgIFdvcmtzcGFjZUZvbGRlci5pcyA9IGlzO1xufSkoV29ya3NwYWNlRm9sZGVyIHx8IChXb3Jrc3BhY2VGb2xkZXIgPSB7fSkpO1xudmFyIEVPTCA9IFsnXFxuJywgJ1xcclxcbicsICdcXHInXTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIHRoZSB0ZXh0IGRvY3VtZW50IGZyb20gdGhlIG5ldyB2c2NvZGUtbGFuZ3VhZ2VzZXJ2ZXItdGV4dGRvY3VtZW50IHBhY2thZ2UuXG4gKi9cbnZhciBUZXh0RG9jdW1lbnQ7XG4oZnVuY3Rpb24gKFRleHREb2N1bWVudCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgSVRleHREb2N1bWVudCBsaXRlcmFsIGZyb20gdGhlIGdpdmVuIHVyaSBhbmQgY29udGVudC5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSBkb2N1bWVudCdzIHVyaS5cbiAgICAgKiBAcGFyYW0gbGFuZ3VhZ2VJZCBUaGUgZG9jdW1lbnQncyBsYW5ndWFnZSBJZC5cbiAgICAgKiBAcGFyYW0gdmVyc2lvbiBUaGUgZG9jdW1lbnQncyB2ZXJzaW9uLlxuICAgICAqIEBwYXJhbSBjb250ZW50IFRoZSBkb2N1bWVudCdzIGNvbnRlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgbGFuZ3VhZ2VJZCwgdmVyc2lvbiwgY29udGVudCkge1xuICAgICAgICByZXR1cm4gbmV3IEZ1bGxUZXh0RG9jdW1lbnQodXJpLCBsYW5ndWFnZUlkLCB2ZXJzaW9uLCBjb250ZW50KTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50LmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIElUZXh0RG9jdW1lbnR9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLmxhbmd1YWdlSWQpIHx8IElzLnN0cmluZyhjYW5kaWRhdGUubGFuZ3VhZ2VJZCkpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5saW5lQ291bnQpXG4gICAgICAgICAgICAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5nZXRUZXh0KSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5wb3NpdGlvbkF0KSAmJiBJcy5mdW5jKGNhbmRpZGF0ZS5vZmZzZXRBdCkgPyB0cnVlIDogZmFsc2U7XG4gICAgfVxuICAgIFRleHREb2N1bWVudC5pcyA9IGlzO1xuICAgIGZ1bmN0aW9uIGFwcGx5RWRpdHMoZG9jdW1lbnQsIGVkaXRzKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gZG9jdW1lbnQuZ2V0VGV4dCgpO1xuICAgICAgICB2YXIgc29ydGVkRWRpdHMgPSBtZXJnZVNvcnQoZWRpdHMsIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICB2YXIgZGlmZiA9IGEucmFuZ2Uuc3RhcnQubGluZSAtIGIucmFuZ2Uuc3RhcnQubGluZTtcbiAgICAgICAgICAgIGlmIChkaWZmID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyIC0gYi5yYW5nZS5zdGFydC5jaGFyYWN0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGlmZjtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBsYXN0TW9kaWZpZWRPZmZzZXQgPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IHNvcnRlZEVkaXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgZSA9IHNvcnRlZEVkaXRzW2ldO1xuICAgICAgICAgICAgdmFyIHN0YXJ0T2Zmc2V0ID0gZG9jdW1lbnQub2Zmc2V0QXQoZS5yYW5nZS5zdGFydCk7XG4gICAgICAgICAgICB2YXIgZW5kT2Zmc2V0ID0gZG9jdW1lbnQub2Zmc2V0QXQoZS5yYW5nZS5lbmQpO1xuICAgICAgICAgICAgaWYgKGVuZE9mZnNldCA8PSBsYXN0TW9kaWZpZWRPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgc3RhcnRPZmZzZXQpICsgZS5uZXdUZXh0ICsgdGV4dC5zdWJzdHJpbmcoZW5kT2Zmc2V0LCB0ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ092ZXJsYXBwaW5nIGVkaXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RNb2RpZmllZE9mZnNldCA9IHN0YXJ0T2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnQuYXBwbHlFZGl0cyA9IGFwcGx5RWRpdHM7XG4gICAgZnVuY3Rpb24gbWVyZ2VTb3J0KGRhdGEsIGNvbXBhcmUpIHtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgIC8vIHNvcnRlZFxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHAgPSAoZGF0YS5sZW5ndGggLyAyKSB8IDA7XG4gICAgICAgIHZhciBsZWZ0ID0gZGF0YS5zbGljZSgwLCBwKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gZGF0YS5zbGljZShwKTtcbiAgICAgICAgbWVyZ2VTb3J0KGxlZnQsIGNvbXBhcmUpO1xuICAgICAgICBtZXJnZVNvcnQocmlnaHQsIGNvbXBhcmUpO1xuICAgICAgICB2YXIgbGVmdElkeCA9IDA7XG4gICAgICAgIHZhciByaWdodElkeCA9IDA7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGxlZnRJZHggPCBsZWZ0Lmxlbmd0aCAmJiByaWdodElkeCA8IHJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHJldCA9IGNvbXBhcmUobGVmdFtsZWZ0SWR4XSwgcmlnaHRbcmlnaHRJZHhdKTtcbiAgICAgICAgICAgIGlmIChyZXQgPD0gMCkge1xuICAgICAgICAgICAgICAgIC8vIHNtYWxsZXJfZXF1YWwgLT4gdGFrZSBsZWZ0IHRvIHByZXNlcnZlIG9yZGVyXG4gICAgICAgICAgICAgICAgZGF0YVtpKytdID0gbGVmdFtsZWZ0SWR4KytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZ3JlYXRlciAtPiB0YWtlIHJpZ2h0XG4gICAgICAgICAgICAgICAgZGF0YVtpKytdID0gcmlnaHRbcmlnaHRJZHgrK107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGxlZnRJZHggPCBsZWZ0Lmxlbmd0aCkge1xuICAgICAgICAgICAgZGF0YVtpKytdID0gbGVmdFtsZWZ0SWR4KytdO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChyaWdodElkeCA8IHJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICAgICAgZGF0YVtpKytdID0gcmlnaHRbcmlnaHRJZHgrK107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxufSkoVGV4dERvY3VtZW50IHx8IChUZXh0RG9jdW1lbnQgPSB7fSkpO1xuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2UgdGhlIHRleHQgZG9jdW1lbnQgZnJvbSB0aGUgbmV3IHZzY29kZS1sYW5ndWFnZXNlcnZlci10ZXh0ZG9jdW1lbnQgcGFja2FnZS5cbiAqL1xudmFyIEZ1bGxUZXh0RG9jdW1lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRnVsbFRleHREb2N1bWVudCh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIGNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5fdXJpID0gdXJpO1xuICAgICAgICB0aGlzLl9sYW5ndWFnZUlkID0gbGFuZ3VhZ2VJZDtcbiAgICAgICAgdGhpcy5fdmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB0aGlzLl9saW5lT2Zmc2V0cyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLCBcInVyaVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VyaTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZSwgXCJsYW5ndWFnZUlkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGFuZ3VhZ2VJZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZSwgXCJ2ZXJzaW9uXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmVyc2lvbjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLmdldFRleHQgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLm9mZnNldEF0KHJhbmdlLnN0YXJ0KTtcbiAgICAgICAgICAgIHZhciBlbmQgPSB0aGlzLm9mZnNldEF0KHJhbmdlLmVuZCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudC5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQ7XG4gICAgfTtcbiAgICBGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZXZlbnQsIHZlcnNpb24pIHtcbiAgICAgICAgdGhpcy5fY29udGVudCA9IGV2ZW50LnRleHQ7XG4gICAgICAgIHRoaXMuX3ZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB0aGlzLl9saW5lT2Zmc2V0cyA9IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLmdldExpbmVPZmZzZXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fbGluZU9mZnNldHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGxpbmVPZmZzZXRzID0gW107XG4gICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMuX2NvbnRlbnQ7XG4gICAgICAgICAgICB2YXIgaXNMaW5lU3RhcnQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTGluZVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVPZmZzZXRzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgIGlzTGluZVN0YXJ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjaCA9IHRleHQuY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgIGlzTGluZVN0YXJ0ID0gKGNoID09PSAnXFxyJyB8fCBjaCA9PT0gJ1xcbicpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xccicgJiYgaSArIDEgPCB0ZXh0Lmxlbmd0aCAmJiB0ZXh0LmNoYXJBdChpICsgMSkgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNMaW5lU3RhcnQgJiYgdGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGluZU9mZnNldHMucHVzaCh0ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9saW5lT2Zmc2V0cyA9IGxpbmVPZmZzZXRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lT2Zmc2V0cztcbiAgICB9O1xuICAgIEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLnBvc2l0aW9uQXQgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCA9IE1hdGgubWF4KE1hdGgubWluKG9mZnNldCwgdGhpcy5fY29udGVudC5sZW5ndGgpLCAwKTtcbiAgICAgICAgdmFyIGxpbmVPZmZzZXRzID0gdGhpcy5nZXRMaW5lT2Zmc2V0cygpO1xuICAgICAgICB2YXIgbG93ID0gMCwgaGlnaCA9IGxpbmVPZmZzZXRzLmxlbmd0aDtcbiAgICAgICAgaWYgKGhpZ2ggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBQb3NpdGlvbi5jcmVhdGUoMCwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICAgICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICAgICAgICBpZiAobGluZU9mZnNldHNbbWlkXSA+IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGxvdyBpcyB0aGUgbGVhc3QgeCBmb3Igd2hpY2ggdGhlIGxpbmUgb2Zmc2V0IGlzIGxhcmdlciB0aGFuIHRoZSBjdXJyZW50IG9mZnNldFxuICAgICAgICAvLyBvciBhcnJheS5sZW5ndGggaWYgbm8gbGluZSBvZmZzZXQgaXMgbGFyZ2VyIHRoYW4gdGhlIGN1cnJlbnQgb2Zmc2V0XG4gICAgICAgIHZhciBsaW5lID0gbG93IC0gMTtcbiAgICAgICAgcmV0dXJuIFBvc2l0aW9uLmNyZWF0ZShsaW5lLCBvZmZzZXQgLSBsaW5lT2Zmc2V0c1tsaW5lXSk7XG4gICAgfTtcbiAgICBGdWxsVGV4dERvY3VtZW50LnByb3RvdHlwZS5vZmZzZXRBdCA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgICAgICB2YXIgbGluZU9mZnNldHMgPSB0aGlzLmdldExpbmVPZmZzZXRzKCk7XG4gICAgICAgIGlmIChwb3NpdGlvbi5saW5lID49IGxpbmVPZmZzZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvc2l0aW9uLmxpbmUgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGluZU9mZnNldCA9IGxpbmVPZmZzZXRzW3Bvc2l0aW9uLmxpbmVdO1xuICAgICAgICB2YXIgbmV4dExpbmVPZmZzZXQgPSAocG9zaXRpb24ubGluZSArIDEgPCBsaW5lT2Zmc2V0cy5sZW5ndGgpID8gbGluZU9mZnNldHNbcG9zaXRpb24ubGluZSArIDFdIDogdGhpcy5fY29udGVudC5sZW5ndGg7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihsaW5lT2Zmc2V0ICsgcG9zaXRpb24uY2hhcmFjdGVyLCBuZXh0TGluZU9mZnNldCksIGxpbmVPZmZzZXQpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bGxUZXh0RG9jdW1lbnQucHJvdG90eXBlLCBcImxpbmVDb3VudFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGluZU9mZnNldHMoKS5sZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gRnVsbFRleHREb2N1bWVudDtcbn0oKSk7XG52YXIgSXM7XG4oZnVuY3Rpb24gKElzKSB7XG4gICAgdmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgICBmdW5jdGlvbiBkZWZpbmVkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnO1xuICAgIH1cbiAgICBJcy5kZWZpbmVkID0gZGVmaW5lZDtcbiAgICBmdW5jdGlvbiB1bmRlZmluZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgfVxuICAgIElzLnVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICBmdW5jdGlvbiBib29sZWFuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2U7XG4gICAgfVxuICAgIElzLmJvb2xlYW4gPSBib29sZWFuO1xuICAgIGZ1bmN0aW9uIHN0cmluZyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xuICAgIH1cbiAgICBJcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgZnVuY3Rpb24gbnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgTnVtYmVyXSc7XG4gICAgfVxuICAgIElzLm51bWJlciA9IG51bWJlcjtcbiAgICBmdW5jdGlvbiBudW1iZXJSYW5nZSh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBOdW1iZXJdJyAmJiBtaW4gPD0gdmFsdWUgJiYgdmFsdWUgPD0gbWF4O1xuICAgIH1cbiAgICBJcy5udW1iZXJSYW5nZSA9IG51bWJlclJhbmdlO1xuICAgIGZ1bmN0aW9uIGludGVnZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBOdW1iZXJdJyAmJiAtMjE0NzQ4MzY0OCA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSAyMTQ3NDgzNjQ3O1xuICAgIH1cbiAgICBJcy5pbnRlZ2VyID0gaW50ZWdlcjtcbiAgICBmdW5jdGlvbiB1aW50ZWdlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE51bWJlcl0nICYmIDAgPD0gdmFsdWUgJiYgdmFsdWUgPD0gMjE0NzQ4MzY0NztcbiAgICB9XG4gICAgSXMudWludGVnZXIgPSB1aW50ZWdlcjtcbiAgICBmdW5jdGlvbiBmdW5jKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgICB9XG4gICAgSXMuZnVuYyA9IGZ1bmM7XG4gICAgZnVuY3Rpb24gb2JqZWN0TGl0ZXJhbCh2YWx1ZSkge1xuICAgICAgICAvLyBTdHJpY3RseSBzcGVha2luZyBjbGFzcyBpbnN0YW5jZXMgcGFzcyB0aGlzIGNoZWNrIGFzIHdlbGwuIFNpbmNlIHRoZSBMU1BcbiAgICAgICAgLy8gZG9lc24ndCB1c2UgY2xhc3NlcyB3ZSBpZ25vcmUgdGhpcyBmb3Igbm93LiBJZiB3ZSBkbyB3ZSBuZWVkIHRvIGFkZCBzb21ldGhpbmdcbiAgICAgICAgLy8gbGlrZSB0aGlzOiBgT2JqZWN0LmdldFByb3RvdHlwZU9mKE9iamVjdC5nZXRQcm90b3R5cGVPZih4KSkgPT09IG51bGxgXG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnO1xuICAgIH1cbiAgICBJcy5vYmplY3RMaXRlcmFsID0gb2JqZWN0TGl0ZXJhbDtcbiAgICBmdW5jdGlvbiB0eXBlZEFycmF5KHZhbHVlLCBjaGVjaykge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkoY2hlY2spO1xuICAgIH1cbiAgICBJcy50eXBlZEFycmF5ID0gdHlwZWRBcnJheTtcbn0pKElzIHx8IChJcyA9IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI3MzA6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBmb3JFYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MDUpO1xudmFyIGF2YWlsYWJsZVR5cGVkQXJyYXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0ODM0KTtcbnZhciBjYWxsQmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oODQ5OCk7XG52YXIgY2FsbEJvdW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5ODE4KTtcbnZhciBnT1BEID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MzM2KTtcblxudmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOTEzKSgpO1xuXG52YXIgZyA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSAndW5kZWZpbmVkJyA/IF9fd2VicGFja19yZXF1aXJlX18uZyA6IGdsb2JhbFRoaXM7XG52YXIgdHlwZWRBcnJheXMgPSBhdmFpbGFibGVUeXBlZEFycmF5cygpO1xuXG52YXIgJHNsaWNlID0gY2FsbEJvdW5kKCdTdHJpbmcucHJvdG90eXBlLnNsaWNlJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7IC8vIHJlcXVpcmUoJ2dldHByb3RvdHlwZW9mJyk7XG5cbnZhciAkaW5kZXhPZiA9IGNhbGxCb3VuZCgnQXJyYXkucHJvdG90eXBlLmluZGV4T2YnLCB0cnVlKSB8fCBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0aWYgKGFycmF5W2ldID09PSB2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIGk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiAtMTtcbn07XG52YXIgY2FjaGUgPSB7IF9fcHJvdG9fXzogbnVsbCB9O1xuaWYgKGhhc1RvU3RyaW5nVGFnICYmIGdPUEQgJiYgZ2V0UHJvdG90eXBlT2YpIHtcblx0Zm9yRWFjaCh0eXBlZEFycmF5cywgZnVuY3Rpb24gKHR5cGVkQXJyYXkpIHtcblx0XHR2YXIgYXJyID0gbmV3IGdbdHlwZWRBcnJheV0oKTtcblx0XHRpZiAoU3ltYm9sLnRvU3RyaW5nVGFnIGluIGFycikge1xuXHRcdFx0dmFyIHByb3RvID0gZ2V0UHJvdG90eXBlT2YoYXJyKTtcblx0XHRcdHZhciBkZXNjcmlwdG9yID0gZ09QRChwcm90bywgU3ltYm9sLnRvU3RyaW5nVGFnKTtcblx0XHRcdGlmICghZGVzY3JpcHRvcikge1xuXHRcdFx0XHR2YXIgc3VwZXJQcm90byA9IGdldFByb3RvdHlwZU9mKHByb3RvKTtcblx0XHRcdFx0ZGVzY3JpcHRvciA9IGdPUEQoc3VwZXJQcm90bywgU3ltYm9sLnRvU3RyaW5nVGFnKTtcblx0XHRcdH1cblx0XHRcdGNhY2hlWyckJyArIHR5cGVkQXJyYXldID0gY2FsbEJpbmQoZGVzY3JpcHRvci5nZXQpO1xuXHRcdH1cblx0fSk7XG59IGVsc2Uge1xuXHRmb3JFYWNoKHR5cGVkQXJyYXlzLCBmdW5jdGlvbiAodHlwZWRBcnJheSkge1xuXHRcdHZhciBhcnIgPSBuZXcgZ1t0eXBlZEFycmF5XSgpO1xuXHRcdGNhY2hlWyckJyArIHR5cGVkQXJyYXldID0gY2FsbEJpbmQoYXJyLnNsaWNlKTtcblx0fSk7XG59XG5cbnZhciB0cnlUeXBlZEFycmF5cyA9IGZ1bmN0aW9uIHRyeUFsbFR5cGVkQXJyYXlzKHZhbHVlKSB7XG5cdHZhciBmb3VuZCA9IGZhbHNlO1xuXHRmb3JFYWNoKGNhY2hlLCBmdW5jdGlvbiAoZ2V0dGVyLCB0eXBlZEFycmF5KSB7XG5cdFx0aWYgKCFmb3VuZCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKCckJyArIGdldHRlcih2YWx1ZSkgPT09IHR5cGVkQXJyYXkpIHtcblx0XHRcdFx0XHRmb3VuZCA9ICRzbGljZSh0eXBlZEFycmF5LCAxKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZSkgeyAvKiovIH1cblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gZm91bmQ7XG59O1xuXG52YXIgdHJ5U2xpY2VzID0gZnVuY3Rpb24gdHJ5QWxsU2xpY2VzKHZhbHVlKSB7XG5cdHZhciBmb3VuZCA9IGZhbHNlO1xuXHRmb3JFYWNoKGNhY2hlLCBmdW5jdGlvbiAoZ2V0dGVyLCBuYW1lKSB7XG5cdFx0aWYgKCFmb3VuZCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Z2V0dGVyKHZhbHVlKTtcblx0XHRcdFx0Zm91bmQgPSAkc2xpY2UobmFtZSwgMSk7XG5cdFx0XHR9IGNhdGNoIChlKSB7IC8qKi8gfVxuXHRcdH1cblx0fSk7XG5cdHJldHVybiBmb3VuZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSB7XG5cdGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKCFoYXNUb1N0cmluZ1RhZykge1xuXHRcdHZhciB0YWcgPSAkc2xpY2UoJHRvU3RyaW5nKHZhbHVlKSwgOCwgLTEpO1xuXHRcdGlmICgkaW5kZXhPZih0eXBlZEFycmF5cywgdGFnKSA+IC0xKSB7XG5cdFx0XHRyZXR1cm4gdGFnO1xuXHRcdH1cblx0XHRpZiAodGFnICE9PSAnT2JqZWN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHQvLyBub2RlIDwgMC42IGhpdHMgaGVyZSBvbiByZWFsIFR5cGVkIEFycmF5c1xuXHRcdHJldHVybiB0cnlTbGljZXModmFsdWUpO1xuXHR9XG5cdGlmICghZ09QRCkgeyByZXR1cm4gbnVsbDsgfSAvLyB1bmtub3duIGVuZ2luZVxuXHRyZXR1cm4gdHJ5VHlwZWRBcnJheXModmFsdWUpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDgzNDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIHBvc3NpYmxlTmFtZXMgPSBbXG5cdCdCaWdJbnQ2NEFycmF5Jyxcblx0J0JpZ1VpbnQ2NEFycmF5Jyxcblx0J0Zsb2F0MzJBcnJheScsXG5cdCdGbG9hdDY0QXJyYXknLFxuXHQnSW50MTZBcnJheScsXG5cdCdJbnQzMkFycmF5Jyxcblx0J0ludDhBcnJheScsXG5cdCdVaW50MTZBcnJheScsXG5cdCdVaW50MzJBcnJheScsXG5cdCdVaW50OEFycmF5Jyxcblx0J1VpbnQ4Q2xhbXBlZEFycmF5J1xuXTtcblxudmFyIGcgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ3VuZGVmaW5lZCcgPyBfX3dlYnBhY2tfcmVxdWlyZV9fLmcgOiBnbG9iYWxUaGlzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGF2YWlsYWJsZVR5cGVkQXJyYXlzKCkge1xuXHR2YXIgb3V0ID0gW107XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcG9zc2libGVOYW1lcy5sZW5ndGg7IGkrKykge1xuXHRcdGlmICh0eXBlb2YgZ1twb3NzaWJsZU5hbWVzW2ldXSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0b3V0W291dC5sZW5ndGhdID0gcG9zc2libGVOYW1lc1tpXTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG91dDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDgwNDE6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfX193ZWJwYWNrX21vZHVsZV9fLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgVjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gVGV4dERvY3VtZW50KVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbmNsYXNzIEZ1bGxUZXh0RG9jdW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKHVyaSwgbGFuZ3VhZ2VJZCwgdmVyc2lvbiwgY29udGVudCkge1xuICAgICAgICB0aGlzLl91cmkgPSB1cmk7XG4gICAgICAgIHRoaXMuX2xhbmd1YWdlSWQgPSBsYW5ndWFnZUlkO1xuICAgICAgICB0aGlzLl92ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5fY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIHRoaXMuX2xpbmVPZmZzZXRzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgdXJpKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXJpO1xuICAgIH1cbiAgICBnZXQgbGFuZ3VhZ2VJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhbmd1YWdlSWQ7XG4gICAgfVxuICAgIGdldCB2ZXJzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmVyc2lvbjtcbiAgICB9XG4gICAgZ2V0VGV4dChyYW5nZSkge1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5vZmZzZXRBdChyYW5nZS5zdGFydCk7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSB0aGlzLm9mZnNldEF0KHJhbmdlLmVuZCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudC5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQ7XG4gICAgfVxuICAgIHVwZGF0ZShjaGFuZ2VzLCB2ZXJzaW9uKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2hhbmdlIG9mIGNoYW5nZXMpIHtcbiAgICAgICAgICAgIGlmIChGdWxsVGV4dERvY3VtZW50LmlzSW5jcmVtZW50YWwoY2hhbmdlKSkge1xuICAgICAgICAgICAgICAgIC8vIG1ha2VzIHN1cmUgc3RhcnQgaXMgYmVmb3JlIGVuZFxuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gZ2V0V2VsbGZvcm1lZFJhbmdlKGNoYW5nZS5yYW5nZSk7XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGNvbnRlbnRcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydE9mZnNldCA9IHRoaXMub2Zmc2V0QXQocmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZE9mZnNldCA9IHRoaXMub2Zmc2V0QXQocmFuZ2UuZW5kKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZW50ID0gdGhpcy5fY29udGVudC5zdWJzdHJpbmcoMCwgc3RhcnRPZmZzZXQpICsgY2hhbmdlLnRleHQgKyB0aGlzLl9jb250ZW50LnN1YnN0cmluZyhlbmRPZmZzZXQsIHRoaXMuX2NvbnRlbnQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIG9mZnNldHNcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydExpbmUgPSBNYXRoLm1heChyYW5nZS5zdGFydC5saW5lLCAwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmRMaW5lID0gTWF0aC5tYXgocmFuZ2UuZW5kLmxpbmUsIDApO1xuICAgICAgICAgICAgICAgIGxldCBsaW5lT2Zmc2V0cyA9IHRoaXMuX2xpbmVPZmZzZXRzO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFkZGVkTGluZU9mZnNldHMgPSBjb21wdXRlTGluZU9mZnNldHMoY2hhbmdlLnRleHQsIGZhbHNlLCBzdGFydE9mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKGVuZExpbmUgLSBzdGFydExpbmUgPT09IGFkZGVkTGluZU9mZnNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBhZGRlZExpbmVPZmZzZXRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lT2Zmc2V0c1tpICsgc3RhcnRMaW5lICsgMV0gPSBhZGRlZExpbmVPZmZzZXRzW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkZWRMaW5lT2Zmc2V0cy5sZW5ndGggPCAxMDAwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZU9mZnNldHMuc3BsaWNlKHN0YXJ0TGluZSArIDEsIGVuZExpbmUgLSBzdGFydExpbmUsIC4uLmFkZGVkTGluZU9mZnNldHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBhdm9pZCB0b28gbWFueSBhcmd1bWVudHMgZm9yIHNwbGljZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGluZU9mZnNldHMgPSBsaW5lT2Zmc2V0cyA9IGxpbmVPZmZzZXRzLnNsaWNlKDAsIHN0YXJ0TGluZSArIDEpLmNvbmNhdChhZGRlZExpbmVPZmZzZXRzLCBsaW5lT2Zmc2V0cy5zbGljZShlbmRMaW5lICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBjaGFuZ2UudGV4dC5sZW5ndGggLSAoZW5kT2Zmc2V0IC0gc3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIGlmIChkaWZmICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydExpbmUgKyAxICsgYWRkZWRMaW5lT2Zmc2V0cy5sZW5ndGgsIGxlbiA9IGxpbmVPZmZzZXRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lT2Zmc2V0c1tpXSA9IGxpbmVPZmZzZXRzW2ldICsgZGlmZjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEZ1bGxUZXh0RG9jdW1lbnQuaXNGdWxsKGNoYW5nZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZW50ID0gY2hhbmdlLnRleHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGluZU9mZnNldHMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gY2hhbmdlIGV2ZW50IHJlY2VpdmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmVyc2lvbiA9IHZlcnNpb247XG4gICAgfVxuICAgIGdldExpbmVPZmZzZXRzKCkge1xuICAgICAgICBpZiAodGhpcy5fbGluZU9mZnNldHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fbGluZU9mZnNldHMgPSBjb21wdXRlTGluZU9mZnNldHModGhpcy5fY29udGVudCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVPZmZzZXRzO1xuICAgIH1cbiAgICBwb3NpdGlvbkF0KG9mZnNldCkge1xuICAgICAgICBvZmZzZXQgPSBNYXRoLm1heChNYXRoLm1pbihvZmZzZXQsIHRoaXMuX2NvbnRlbnQubGVuZ3RoKSwgMCk7XG4gICAgICAgIGNvbnN0IGxpbmVPZmZzZXRzID0gdGhpcy5nZXRMaW5lT2Zmc2V0cygpO1xuICAgICAgICBsZXQgbG93ID0gMCwgaGlnaCA9IGxpbmVPZmZzZXRzLmxlbmd0aDtcbiAgICAgICAgaWYgKGhpZ2ggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7IGxpbmU6IDAsIGNoYXJhY3Rlcjogb2Zmc2V0IH07XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgICAgIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICAgICAgICBpZiAobGluZU9mZnNldHNbbWlkXSA+IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGxvdyBpcyB0aGUgbGVhc3QgeCBmb3Igd2hpY2ggdGhlIGxpbmUgb2Zmc2V0IGlzIGxhcmdlciB0aGFuIHRoZSBjdXJyZW50IG9mZnNldFxuICAgICAgICAvLyBvciBhcnJheS5sZW5ndGggaWYgbm8gbGluZSBvZmZzZXQgaXMgbGFyZ2VyIHRoYW4gdGhlIGN1cnJlbnQgb2Zmc2V0XG4gICAgICAgIGNvbnN0IGxpbmUgPSBsb3cgLSAxO1xuICAgICAgICBvZmZzZXQgPSB0aGlzLmVuc3VyZUJlZm9yZUVPTChvZmZzZXQsIGxpbmVPZmZzZXRzW2xpbmVdKTtcbiAgICAgICAgcmV0dXJuIHsgbGluZSwgY2hhcmFjdGVyOiBvZmZzZXQgLSBsaW5lT2Zmc2V0c1tsaW5lXSB9O1xuICAgIH1cbiAgICBvZmZzZXRBdChwb3NpdGlvbikge1xuICAgICAgICBjb25zdCBsaW5lT2Zmc2V0cyA9IHRoaXMuZ2V0TGluZU9mZnNldHMoKTtcbiAgICAgICAgaWYgKHBvc2l0aW9uLmxpbmUgPj0gbGluZU9mZnNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocG9zaXRpb24ubGluZSA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpbmVPZmZzZXQgPSBsaW5lT2Zmc2V0c1twb3NpdGlvbi5saW5lXTtcbiAgICAgICAgaWYgKHBvc2l0aW9uLmNoYXJhY3RlciA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbGluZU9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0TGluZU9mZnNldCA9IChwb3NpdGlvbi5saW5lICsgMSA8IGxpbmVPZmZzZXRzLmxlbmd0aCkgPyBsaW5lT2Zmc2V0c1twb3NpdGlvbi5saW5lICsgMV0gOiB0aGlzLl9jb250ZW50Lmxlbmd0aDtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gTWF0aC5taW4obGluZU9mZnNldCArIHBvc2l0aW9uLmNoYXJhY3RlciwgbmV4dExpbmVPZmZzZXQpO1xuICAgICAgICByZXR1cm4gdGhpcy5lbnN1cmVCZWZvcmVFT0wob2Zmc2V0LCBsaW5lT2Zmc2V0KTtcbiAgICB9XG4gICAgZW5zdXJlQmVmb3JlRU9MKG9mZnNldCwgbGluZU9mZnNldCkge1xuICAgICAgICB3aGlsZSAob2Zmc2V0ID4gbGluZU9mZnNldCAmJiBpc0VPTCh0aGlzLl9jb250ZW50LmNoYXJDb2RlQXQob2Zmc2V0IC0gMSkpKSB7XG4gICAgICAgICAgICBvZmZzZXQtLTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgICBnZXQgbGluZUNvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRMaW5lT2Zmc2V0cygpLmxlbmd0aDtcbiAgICB9XG4gICAgc3RhdGljIGlzSW5jcmVtZW50YWwoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gZXZlbnQ7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjYW5kaWRhdGUudGV4dCA9PT0gJ3N0cmluZycgJiYgY2FuZGlkYXRlLnJhbmdlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUucmFuZ2VMZW5ndGggPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgY2FuZGlkYXRlLnJhbmdlTGVuZ3RoID09PSAnbnVtYmVyJyk7XG4gICAgfVxuICAgIHN0YXRpYyBpc0Z1bGwoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gZXZlbnQ7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjYW5kaWRhdGUudGV4dCA9PT0gJ3N0cmluZycgJiYgY2FuZGlkYXRlLnJhbmdlID09PSB1bmRlZmluZWQgJiYgY2FuZGlkYXRlLnJhbmdlTGVuZ3RoID09PSB1bmRlZmluZWQ7XG4gICAgfVxufVxudmFyIFRleHREb2N1bWVudDtcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB0ZXh0IGRvY3VtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHVyaSBUaGUgZG9jdW1lbnQncyB1cmkuXG4gICAgICogQHBhcmFtIGxhbmd1YWdlSWQgIFRoZSBkb2N1bWVudCdzIGxhbmd1YWdlIElkLlxuICAgICAqIEBwYXJhbSB2ZXJzaW9uIFRoZSBkb2N1bWVudCdzIGluaXRpYWwgdmVyc2lvbiBudW1iZXIuXG4gICAgICogQHBhcmFtIGNvbnRlbnQgVGhlIGRvY3VtZW50J3MgY29udGVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCBsYW5ndWFnZUlkLCB2ZXJzaW9uLCBjb250ZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgRnVsbFRleHREb2N1bWVudCh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIGNvbnRlbnQpO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnQuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgYSBUZXh0RG9jdW1lbnQgYnkgbW9kaWZ5aW5nIGl0cyBjb250ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGRvY3VtZW50IHRoZSBkb2N1bWVudCB0byB1cGRhdGUuIE9ubHkgZG9jdW1lbnRzIGNyZWF0ZWQgYnkgVGV4dERvY3VtZW50LmNyZWF0ZSBhcmUgdmFsaWQgaW5wdXRzLlxuICAgICAqIEBwYXJhbSBjaGFuZ2VzIHRoZSBjaGFuZ2VzIHRvIGFwcGx5IHRvIHRoZSBkb2N1bWVudC5cbiAgICAgKiBAcGFyYW0gdmVyc2lvbiB0aGUgY2hhbmdlcyB2ZXJzaW9uIGZvciB0aGUgZG9jdW1lbnQuXG4gICAgICogQHJldHVybnMgVGhlIHVwZGF0ZWQgVGV4dERvY3VtZW50LiBOb3RlOiBUaGF0J3MgdGhlIHNhbWUgZG9jdW1lbnQgaW5zdGFuY2UgcGFzc2VkIGluIGFzIGZpcnN0IHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZShkb2N1bWVudCwgY2hhbmdlcywgdmVyc2lvbikge1xuICAgICAgICBpZiAoZG9jdW1lbnQgaW5zdGFuY2VvZiBGdWxsVGV4dERvY3VtZW50KSB7XG4gICAgICAgICAgICBkb2N1bWVudC51cGRhdGUoY2hhbmdlcywgdmVyc2lvbik7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHREb2N1bWVudC51cGRhdGU6IGRvY3VtZW50IG11c3QgYmUgY3JlYXRlZCBieSBUZXh0RG9jdW1lbnQuY3JlYXRlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVGV4dERvY3VtZW50LnVwZGF0ZSA9IHVwZGF0ZTtcbiAgICBmdW5jdGlvbiBhcHBseUVkaXRzKGRvY3VtZW50LCBlZGl0cykge1xuICAgICAgICBjb25zdCB0ZXh0ID0gZG9jdW1lbnQuZ2V0VGV4dCgpO1xuICAgICAgICBjb25zdCBzb3J0ZWRFZGl0cyA9IG1lcmdlU29ydChlZGl0cy5tYXAoZ2V0V2VsbGZvcm1lZEVkaXQpLCAoYSwgYikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGlmZiA9IGEucmFuZ2Uuc3RhcnQubGluZSAtIGIucmFuZ2Uuc3RhcnQubGluZTtcbiAgICAgICAgICAgIGlmIChkaWZmID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyIC0gYi5yYW5nZS5zdGFydC5jaGFyYWN0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGlmZjtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBsYXN0TW9kaWZpZWRPZmZzZXQgPSAwO1xuICAgICAgICBjb25zdCBzcGFucyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGUgb2Ygc29ydGVkRWRpdHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gZG9jdW1lbnQub2Zmc2V0QXQoZS5yYW5nZS5zdGFydCk7XG4gICAgICAgICAgICBpZiAoc3RhcnRPZmZzZXQgPCBsYXN0TW9kaWZpZWRPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ092ZXJsYXBwaW5nIGVkaXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJ0T2Zmc2V0ID4gbGFzdE1vZGlmaWVkT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgc3BhbnMucHVzaCh0ZXh0LnN1YnN0cmluZyhsYXN0TW9kaWZpZWRPZmZzZXQsIHN0YXJ0T2Zmc2V0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZS5uZXdUZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNwYW5zLnB1c2goZS5uZXdUZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RNb2RpZmllZE9mZnNldCA9IGRvY3VtZW50Lm9mZnNldEF0KGUucmFuZ2UuZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBzcGFucy5wdXNoKHRleHQuc3Vic3RyKGxhc3RNb2RpZmllZE9mZnNldCkpO1xuICAgICAgICByZXR1cm4gc3BhbnMuam9pbignJyk7XG4gICAgfVxuICAgIFRleHREb2N1bWVudC5hcHBseUVkaXRzID0gYXBwbHlFZGl0cztcbn0pKFRleHREb2N1bWVudCB8fCAoVGV4dERvY3VtZW50ID0ge30pKTtcbmZ1bmN0aW9uIG1lcmdlU29ydChkYXRhLCBjb21wYXJlKSB7XG4gICAgaWYgKGRhdGEubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgLy8gc29ydGVkXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBjb25zdCBwID0gKGRhdGEubGVuZ3RoIC8gMikgfCAwO1xuICAgIGNvbnN0IGxlZnQgPSBkYXRhLnNsaWNlKDAsIHApO1xuICAgIGNvbnN0IHJpZ2h0ID0gZGF0YS5zbGljZShwKTtcbiAgICBtZXJnZVNvcnQobGVmdCwgY29tcGFyZSk7XG4gICAgbWVyZ2VTb3J0KHJpZ2h0LCBjb21wYXJlKTtcbiAgICBsZXQgbGVmdElkeCA9IDA7XG4gICAgbGV0IHJpZ2h0SWR4ID0gMDtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGxlZnRJZHggPCBsZWZ0Lmxlbmd0aCAmJiByaWdodElkeCA8IHJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICBjb25zdCByZXQgPSBjb21wYXJlKGxlZnRbbGVmdElkeF0sIHJpZ2h0W3JpZ2h0SWR4XSk7XG4gICAgICAgIGlmIChyZXQgPD0gMCkge1xuICAgICAgICAgICAgLy8gc21hbGxlcl9lcXVhbCAtPiB0YWtlIGxlZnQgdG8gcHJlc2VydmUgb3JkZXJcbiAgICAgICAgICAgIGRhdGFbaSsrXSA9IGxlZnRbbGVmdElkeCsrXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGdyZWF0ZXIgLT4gdGFrZSByaWdodFxuICAgICAgICAgICAgZGF0YVtpKytdID0gcmlnaHRbcmlnaHRJZHgrK107XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKGxlZnRJZHggPCBsZWZ0Lmxlbmd0aCkge1xuICAgICAgICBkYXRhW2krK10gPSBsZWZ0W2xlZnRJZHgrK107XG4gICAgfVxuICAgIHdoaWxlIChyaWdodElkeCA8IHJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICBkYXRhW2krK10gPSByaWdodFtyaWdodElkeCsrXTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59XG5mdW5jdGlvbiBjb21wdXRlTGluZU9mZnNldHModGV4dCwgaXNBdExpbmVTdGFydCwgdGV4dE9mZnNldCA9IDApIHtcbiAgICBjb25zdCByZXN1bHQgPSBpc0F0TGluZVN0YXJ0ID8gW3RleHRPZmZzZXRdIDogW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoaXNFT0woY2gpKSB7XG4gICAgICAgICAgICBpZiAoY2ggPT09IDEzIC8qIENoYXJDb2RlLkNhcnJpYWdlUmV0dXJuICovICYmIGkgKyAxIDwgdGV4dC5sZW5ndGggJiYgdGV4dC5jaGFyQ29kZUF0KGkgKyAxKSA9PT0gMTAgLyogQ2hhckNvZGUuTGluZUZlZWQgKi8pIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0ZXh0T2Zmc2V0ICsgaSArIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBpc0VPTChjaGFyKSB7XG4gICAgcmV0dXJuIGNoYXIgPT09IDEzIC8qIENoYXJDb2RlLkNhcnJpYWdlUmV0dXJuICovIHx8IGNoYXIgPT09IDEwIC8qIENoYXJDb2RlLkxpbmVGZWVkICovO1xufVxuZnVuY3Rpb24gZ2V0V2VsbGZvcm1lZFJhbmdlKHJhbmdlKSB7XG4gICAgY29uc3Qgc3RhcnQgPSByYW5nZS5zdGFydDtcbiAgICBjb25zdCBlbmQgPSByYW5nZS5lbmQ7XG4gICAgaWYgKHN0YXJ0LmxpbmUgPiBlbmQubGluZSB8fCAoc3RhcnQubGluZSA9PT0gZW5kLmxpbmUgJiYgc3RhcnQuY2hhcmFjdGVyID4gZW5kLmNoYXJhY3RlcikpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IGVuZCwgZW5kOiBzdGFydCB9O1xuICAgIH1cbiAgICByZXR1cm4gcmFuZ2U7XG59XG5mdW5jdGlvbiBnZXRXZWxsZm9ybWVkRWRpdCh0ZXh0RWRpdCkge1xuICAgIGNvbnN0IHJhbmdlID0gZ2V0V2VsbGZvcm1lZFJhbmdlKHRleHRFZGl0LnJhbmdlKTtcbiAgICBpZiAocmFuZ2UgIT09IHRleHRFZGl0LnJhbmdlKSB7XG4gICAgICAgIHJldHVybiB7IG5ld1RleHQ6IHRleHRFZGl0Lm5ld1RleHQsIHJhbmdlIH07XG4gICAgfVxuICAgIHJldHVybiB0ZXh0RWRpdDtcbn1cblxuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCAqL1xuLyoqKioqKi8gXHQoKCkgPT4ge1xuLyoqKioqKi8gXHRcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuLyoqKioqKi8gXHRcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuLyoqKioqKi8gXHRcdFx0XHQoKSA9PiAobW9kdWxlKTtcbi8qKioqKiovIFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzICovXG4vKioqKioqLyBcdCgoKSA9PiB7XG4vKioqKioqLyBcdFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG4vKioqKioqLyBcdFx0XHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG4vKioqKioqLyBcdFx0XHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuLyoqKioqKi8gXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG4vKioqKioqLyBcdFx0XHRcdH1cbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2dsb2JhbCAqL1xuLyoqKioqKi8gXHQoKCkgPT4ge1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcbi8qKioqKiovIFx0XHRcdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuLyoqKioqKi8gXHRcdFx0dHJ5IHtcbi8qKioqKiovIFx0XHRcdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG4vKioqKioqLyBcdFx0XHR9IGNhdGNoIChlKSB7XG4vKioqKioqLyBcdFx0XHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHR9KSgpO1xuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCAqL1xuLyoqKioqKi8gXHQoKCkgPT4ge1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSlcbi8qKioqKiovIFx0fSkoKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QgKi9cbi8qKioqKiovIFx0KCgpID0+IHtcbi8qKioqKiovIFx0XHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcbi8qKioqKiovIFx0XHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0fSkoKTtcbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xudmFyIF9fd2VicGFja19leHBvcnRzX18gPSB7fTtcbi8vIFRoaXMgZW50cnkgbmVlZCB0byBiZSB3cmFwcGVkIGluIGFuIElJRkUgYmVjYXVzZSBpdCBuZWVkIHRvIGJlIGluIHN0cmljdCBtb2RlLlxuKCgpID0+IHtcblwidXNlIHN0cmljdFwiO1xuLy8gRVNNIENPTVBBVCBGTEFHXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG5cbi8vIEVYUE9SVFNcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4gIEpzb25TZXJ2aWNlOiAoKSA9PiAoLyogYmluZGluZyAqLyBKc29uU2VydmljZSlcbn0pO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL3NlcnZpY2VzL2Jhc2Utc2VydmljZS50c1xudmFyIGJhc2Vfc2VydmljZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjEyNSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL2pzb25jLXBhcnNlci9saWIvZXNtL2ltcGwvc2Nhbm5lci5qc1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbi8qKlxuICogQ3JlYXRlcyBhIEpTT04gc2Nhbm5lciBvbiB0aGUgZ2l2ZW4gdGV4dC5cbiAqIElmIGlnbm9yZVRyaXZpYSBpcyBzZXQsIHdoaXRlc3BhY2VzIG9yIGNvbW1lbnRzIGFyZSBpZ25vcmVkLlxuICovXG5mdW5jdGlvbiBjcmVhdGVTY2FubmVyKHRleHQsIGlnbm9yZVRyaXZpYSA9IGZhbHNlKSB7XG4gICAgY29uc3QgbGVuID0gdGV4dC5sZW5ndGg7XG4gICAgbGV0IHBvcyA9IDAsIHZhbHVlID0gJycsIHRva2VuT2Zmc2V0ID0gMCwgdG9rZW4gPSAxNiAvKiBTeW50YXhLaW5kLlVua25vd24gKi8sIGxpbmVOdW1iZXIgPSAwLCBsaW5lU3RhcnRPZmZzZXQgPSAwLCB0b2tlbkxpbmVTdGFydE9mZnNldCA9IDAsIHByZXZUb2tlbkxpbmVTdGFydE9mZnNldCA9IDAsIHNjYW5FcnJvciA9IDAgLyogU2NhbkVycm9yLk5vbmUgKi87XG4gICAgZnVuY3Rpb24gc2NhbkhleERpZ2l0cyhjb3VudCwgZXhhY3QpIHtcbiAgICAgICAgbGV0IGRpZ2l0cyA9IDA7XG4gICAgICAgIGxldCB2YWx1ZSA9IDA7XG4gICAgICAgIHdoaWxlIChkaWdpdHMgPCBjb3VudCB8fCAhZXhhY3QpIHtcbiAgICAgICAgICAgIGxldCBjaCA9IHRleHQuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICAgICAgaWYgKGNoID49IDQ4IC8qIENoYXJhY3RlckNvZGVzLl8wICovICYmIGNoIDw9IDU3IC8qIENoYXJhY3RlckNvZGVzLl85ICovKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAqIDE2ICsgY2ggLSA0OCAvKiBDaGFyYWN0ZXJDb2Rlcy5fMCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoID49IDY1IC8qIENoYXJhY3RlckNvZGVzLkEgKi8gJiYgY2ggPD0gNzAgLyogQ2hhcmFjdGVyQ29kZXMuRiAqLykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgKiAxNiArIGNoIC0gNjUgLyogQ2hhcmFjdGVyQ29kZXMuQSAqLyArIDEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2ggPj0gOTcgLyogQ2hhcmFjdGVyQ29kZXMuYSAqLyAmJiBjaCA8PSAxMDIgLyogQ2hhcmFjdGVyQ29kZXMuZiAqLykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgKiAxNiArIGNoIC0gOTcgLyogQ2hhcmFjdGVyQ29kZXMuYSAqLyArIDEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIGRpZ2l0cysrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaWdpdHMgPCBjb3VudCkge1xuICAgICAgICAgICAgdmFsdWUgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldFBvc2l0aW9uKG5ld1Bvc2l0aW9uKSB7XG4gICAgICAgIHBvcyA9IG5ld1Bvc2l0aW9uO1xuICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICB0b2tlbk9mZnNldCA9IDA7XG4gICAgICAgIHRva2VuID0gMTYgLyogU3ludGF4S2luZC5Vbmtub3duICovO1xuICAgICAgICBzY2FuRXJyb3IgPSAwIC8qIFNjYW5FcnJvci5Ob25lICovO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2FuTnVtYmVyKCkge1xuICAgICAgICBsZXQgc3RhcnQgPSBwb3M7XG4gICAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQocG9zKSA9PT0gNDggLyogQ2hhcmFjdGVyQ29kZXMuXzAgKi8pIHtcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICB3aGlsZSAocG9zIDwgdGV4dC5sZW5ndGggJiYgaXNEaWdpdCh0ZXh0LmNoYXJDb2RlQXQocG9zKSkpIHtcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zIDwgdGV4dC5sZW5ndGggJiYgdGV4dC5jaGFyQ29kZUF0KHBvcykgPT09IDQ2IC8qIENoYXJhY3RlckNvZGVzLmRvdCAqLykge1xuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICBpZiAocG9zIDwgdGV4dC5sZW5ndGggJiYgaXNEaWdpdCh0ZXh0LmNoYXJDb2RlQXQocG9zKSkpIHtcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICB3aGlsZSAocG9zIDwgdGV4dC5sZW5ndGggJiYgaXNEaWdpdCh0ZXh0LmNoYXJDb2RlQXQocG9zKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2NhbkVycm9yID0gMyAvKiBTY2FuRXJyb3IuVW5leHBlY3RlZEVuZE9mTnVtYmVyICovO1xuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0LnN1YnN0cmluZyhzdGFydCwgcG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgZW5kID0gcG9zO1xuICAgICAgICBpZiAocG9zIDwgdGV4dC5sZW5ndGggJiYgKHRleHQuY2hhckNvZGVBdChwb3MpID09PSA2OSAvKiBDaGFyYWN0ZXJDb2Rlcy5FICovIHx8IHRleHQuY2hhckNvZGVBdChwb3MpID09PSAxMDEgLyogQ2hhcmFjdGVyQ29kZXMuZSAqLykpIHtcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgaWYgKHBvcyA8IHRleHQubGVuZ3RoICYmIHRleHQuY2hhckNvZGVBdChwb3MpID09PSA0MyAvKiBDaGFyYWN0ZXJDb2Rlcy5wbHVzICovIHx8IHRleHQuY2hhckNvZGVBdChwb3MpID09PSA0NSAvKiBDaGFyYWN0ZXJDb2Rlcy5taW51cyAqLykge1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvcyA8IHRleHQubGVuZ3RoICYmIGlzRGlnaXQodGV4dC5jaGFyQ29kZUF0KHBvcykpKSB7XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHBvcyA8IHRleHQubGVuZ3RoICYmIGlzRGlnaXQodGV4dC5jaGFyQ29kZUF0KHBvcykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbmQgPSBwb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY2FuRXJyb3IgPSAzIC8qIFNjYW5FcnJvci5VbmV4cGVjdGVkRW5kT2ZOdW1iZXIgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2FuU3RyaW5nKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gJycsIHN0YXJ0ID0gcG9zO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHBvcyA+PSBsZW4pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGV4dC5zdWJzdHJpbmcoc3RhcnQsIHBvcyk7XG4gICAgICAgICAgICAgICAgc2NhbkVycm9yID0gMiAvKiBTY2FuRXJyb3IuVW5leHBlY3RlZEVuZE9mU3RyaW5nICovO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2ggPSB0ZXh0LmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gMzQgLyogQ2hhcmFjdGVyQ29kZXMuZG91YmxlUXVvdGUgKi8pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGV4dC5zdWJzdHJpbmcoc3RhcnQsIHBvcyk7XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2ggPT09IDkyIC8qIENoYXJhY3RlckNvZGVzLmJhY2tzbGFzaCAqLykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0ZXh0LnN1YnN0cmluZyhzdGFydCwgcG9zKTtcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICBpZiAocG9zID49IGxlbikge1xuICAgICAgICAgICAgICAgICAgICBzY2FuRXJyb3IgPSAyIC8qIFNjYW5FcnJvci5VbmV4cGVjdGVkRW5kT2ZTdHJpbmcgKi87XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjaDIgPSB0ZXh0LmNoYXJDb2RlQXQocG9zKyspO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoY2gyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzQgLyogQ2hhcmFjdGVyQ29kZXMuZG91YmxlUXVvdGUgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xcXCInO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgOTIgLyogQ2hhcmFjdGVyQ29kZXMuYmFja3NsYXNoICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcXFxcJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ3IC8qIENoYXJhY3RlckNvZGVzLnNsYXNoICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcvJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDk4IC8qIENoYXJhY3RlckNvZGVzLmIgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xcYic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDIgLyogQ2hhcmFjdGVyQ29kZXMuZiAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXFxmJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDExMCAvKiBDaGFyYWN0ZXJDb2Rlcy5uICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTE0IC8qIENoYXJhY3RlckNvZGVzLnIgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xccic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTYgLyogQ2hhcmFjdGVyQ29kZXMudCAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXFx0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDExNyAvKiBDaGFyYWN0ZXJDb2Rlcy51ICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2gzID0gc2NhbkhleERpZ2l0cyg0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaDMgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FuRXJyb3IgPSA0IC8qIFNjYW5FcnJvci5JbnZhbGlkVW5pY29kZSAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbkVycm9yID0gNSAvKiBTY2FuRXJyb3IuSW52YWxpZEVzY2FwZUNoYXJhY3RlciAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBwb3M7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2ggPj0gMCAmJiBjaCA8PSAweDFmKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTGluZUJyZWFrKGNoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGV4dC5zdWJzdHJpbmcoc3RhcnQsIHBvcyk7XG4gICAgICAgICAgICAgICAgICAgIHNjYW5FcnJvciA9IDIgLyogU2NhbkVycm9yLlVuZXhwZWN0ZWRFbmRPZlN0cmluZyAqLztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzY2FuRXJyb3IgPSA2IC8qIFNjYW5FcnJvci5JbnZhbGlkQ2hhcmFjdGVyICovO1xuICAgICAgICAgICAgICAgICAgICAvLyBtYXJrIGFzIGVycm9yIGJ1dCBjb250aW51ZSB3aXRoIHN0cmluZ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYW5OZXh0KCkge1xuICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICBzY2FuRXJyb3IgPSAwIC8qIFNjYW5FcnJvci5Ob25lICovO1xuICAgICAgICB0b2tlbk9mZnNldCA9IHBvcztcbiAgICAgICAgbGluZVN0YXJ0T2Zmc2V0ID0gbGluZU51bWJlcjtcbiAgICAgICAgcHJldlRva2VuTGluZVN0YXJ0T2Zmc2V0ID0gdG9rZW5MaW5lU3RhcnRPZmZzZXQ7XG4gICAgICAgIGlmIChwb3MgPj0gbGVuKSB7XG4gICAgICAgICAgICAvLyBhdCB0aGUgZW5kXG4gICAgICAgICAgICB0b2tlbk9mZnNldCA9IGxlbjtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbiA9IDE3IC8qIFN5bnRheEtpbmQuRU9GICovO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb2RlID0gdGV4dC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIC8vIHRyaXZpYTogd2hpdGVzcGFjZVxuICAgICAgICBpZiAoaXNXaGl0ZVNwYWNlKGNvZGUpKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgICAgICAgICBjb2RlID0gdGV4dC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgICAgICB9IHdoaWxlIChpc1doaXRlU3BhY2UoY29kZSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuID0gMTUgLyogU3ludGF4S2luZC5Ucml2aWEgKi87XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHJpdmlhOiBuZXdsaW5lc1xuICAgICAgICBpZiAoaXNMaW5lQnJlYWsoY29kZSkpIHtcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgdmFsdWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgICAgIGlmIChjb2RlID09PSAxMyAvKiBDaGFyYWN0ZXJDb2Rlcy5jYXJyaWFnZVJldHVybiAqLyAmJiB0ZXh0LmNoYXJDb2RlQXQocG9zKSA9PT0gMTAgLyogQ2hhcmFjdGVyQ29kZXMubGluZUZlZWQgKi8pIHtcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSAnXFxuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmVOdW1iZXIrKztcbiAgICAgICAgICAgIHRva2VuTGluZVN0YXJ0T2Zmc2V0ID0gcG9zO1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuID0gMTQgLyogU3ludGF4S2luZC5MaW5lQnJlYWtUcml2aWEgKi87XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICAvLyB0b2tlbnM6IFtde306LFxuICAgICAgICAgICAgY2FzZSAxMjMgLyogQ2hhcmFjdGVyQ29kZXMub3BlbkJyYWNlICovOlxuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbiA9IDEgLyogU3ludGF4S2luZC5PcGVuQnJhY2VUb2tlbiAqLztcbiAgICAgICAgICAgIGNhc2UgMTI1IC8qIENoYXJhY3RlckNvZGVzLmNsb3NlQnJhY2UgKi86XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuID0gMiAvKiBTeW50YXhLaW5kLkNsb3NlQnJhY2VUb2tlbiAqLztcbiAgICAgICAgICAgIGNhc2UgOTEgLyogQ2hhcmFjdGVyQ29kZXMub3BlbkJyYWNrZXQgKi86XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuID0gMyAvKiBTeW50YXhLaW5kLk9wZW5CcmFja2V0VG9rZW4gKi87XG4gICAgICAgICAgICBjYXNlIDkzIC8qIENoYXJhY3RlckNvZGVzLmNsb3NlQnJhY2tldCAqLzpcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4gPSA0IC8qIFN5bnRheEtpbmQuQ2xvc2VCcmFja2V0VG9rZW4gKi87XG4gICAgICAgICAgICBjYXNlIDU4IC8qIENoYXJhY3RlckNvZGVzLmNvbG9uICovOlxuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbiA9IDYgLyogU3ludGF4S2luZC5Db2xvblRva2VuICovO1xuICAgICAgICAgICAgY2FzZSA0NCAvKiBDaGFyYWN0ZXJDb2Rlcy5jb21tYSAqLzpcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4gPSA1IC8qIFN5bnRheEtpbmQuQ29tbWFUb2tlbiAqLztcbiAgICAgICAgICAgIC8vIHN0cmluZ3NcbiAgICAgICAgICAgIGNhc2UgMzQgLyogQ2hhcmFjdGVyQ29kZXMuZG91YmxlUXVvdGUgKi86XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBzY2FuU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuID0gMTAgLyogU3ludGF4S2luZC5TdHJpbmdMaXRlcmFsICovO1xuICAgICAgICAgICAgLy8gY29tbWVudHNcbiAgICAgICAgICAgIGNhc2UgNDcgLyogQ2hhcmFjdGVyQ29kZXMuc2xhc2ggKi86XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBwb3MgLSAxO1xuICAgICAgICAgICAgICAgIC8vIFNpbmdsZS1saW5lIGNvbW1lbnRcbiAgICAgICAgICAgICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KHBvcyArIDEpID09PSA0NyAvKiBDaGFyYWN0ZXJDb2Rlcy5zbGFzaCAqLykge1xuICAgICAgICAgICAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHBvcyA8IGxlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTGluZUJyZWFrKHRleHQuY2hhckNvZGVBdChwb3MpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0ZXh0LnN1YnN0cmluZyhzdGFydCwgcG9zKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuID0gMTIgLyogU3ludGF4S2luZC5MaW5lQ29tbWVudFRyaXZpYSAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTXVsdGktbGluZSBjb21tZW50XG4gICAgICAgICAgICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChwb3MgKyAxKSA9PT0gNDIgLyogQ2hhcmFjdGVyQ29kZXMuYXN0ZXJpc2sgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNhZmVMZW5ndGggPSBsZW4gLSAxOyAvLyBGb3IgbG9va2FoZWFkLlxuICAgICAgICAgICAgICAgICAgICBsZXQgY29tbWVudENsb3NlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocG9zIDwgc2FmZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2ggPSB0ZXh0LmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gNDIgLyogQ2hhcmFjdGVyQ29kZXMuYXN0ZXJpc2sgKi8gJiYgdGV4dC5jaGFyQ29kZUF0KHBvcyArIDEpID09PSA0NyAvKiBDaGFyYWN0ZXJDb2Rlcy5zbGFzaCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRDbG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNMaW5lQnJlYWsoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAxMyAvKiBDaGFyYWN0ZXJDb2Rlcy5jYXJyaWFnZVJldHVybiAqLyAmJiB0ZXh0LmNoYXJDb2RlQXQocG9zKSA9PT0gMTAgLyogQ2hhcmFjdGVyQ29kZXMubGluZUZlZWQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXIrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbkxpbmVTdGFydE9mZnNldCA9IHBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbW1lbnRDbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NhbkVycm9yID0gMSAvKiBTY2FuRXJyb3IuVW5leHBlY3RlZEVuZE9mQ29tbWVudCAqLztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRleHQuc3Vic3RyaW5nKHN0YXJ0LCBwb3MpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4gPSAxMyAvKiBTeW50YXhLaW5kLkJsb2NrQ29tbWVudFRyaXZpYSAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8ganVzdCBhIHNpbmdsZSBzbGFzaFxuICAgICAgICAgICAgICAgIHZhbHVlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuID0gMTYgLyogU3ludGF4S2luZC5Vbmtub3duICovO1xuICAgICAgICAgICAgLy8gbnVtYmVyc1xuICAgICAgICAgICAgY2FzZSA0NSAvKiBDaGFyYWN0ZXJDb2Rlcy5taW51cyAqLzpcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIGlmIChwb3MgPT09IGxlbiB8fCAhaXNEaWdpdCh0ZXh0LmNoYXJDb2RlQXQocG9zKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuID0gMTYgLyogU3ludGF4S2luZC5Vbmtub3duICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZvdW5kIGEgbWludXMsIGZvbGxvd2VkIGJ5IGEgbnVtYmVyIHNvXG4gICAgICAgICAgICAvLyB3ZSBmYWxsIHRocm91Z2ggdG8gcHJvY2VlZCB3aXRoIHNjYW5uaW5nXG4gICAgICAgICAgICAvLyBudW1iZXJzXG4gICAgICAgICAgICBjYXNlIDQ4IC8qIENoYXJhY3RlckNvZGVzLl8wICovOlxuICAgICAgICAgICAgY2FzZSA0OSAvKiBDaGFyYWN0ZXJDb2Rlcy5fMSAqLzpcbiAgICAgICAgICAgIGNhc2UgNTAgLyogQ2hhcmFjdGVyQ29kZXMuXzIgKi86XG4gICAgICAgICAgICBjYXNlIDUxIC8qIENoYXJhY3RlckNvZGVzLl8zICovOlxuICAgICAgICAgICAgY2FzZSA1MiAvKiBDaGFyYWN0ZXJDb2Rlcy5fNCAqLzpcbiAgICAgICAgICAgIGNhc2UgNTMgLyogQ2hhcmFjdGVyQ29kZXMuXzUgKi86XG4gICAgICAgICAgICBjYXNlIDU0IC8qIENoYXJhY3RlckNvZGVzLl82ICovOlxuICAgICAgICAgICAgY2FzZSA1NSAvKiBDaGFyYWN0ZXJDb2Rlcy5fNyAqLzpcbiAgICAgICAgICAgIGNhc2UgNTYgLyogQ2hhcmFjdGVyQ29kZXMuXzggKi86XG4gICAgICAgICAgICBjYXNlIDU3IC8qIENoYXJhY3RlckNvZGVzLl85ICovOlxuICAgICAgICAgICAgICAgIHZhbHVlICs9IHNjYW5OdW1iZXIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4gPSAxMSAvKiBTeW50YXhLaW5kLk51bWVyaWNMaXRlcmFsICovO1xuICAgICAgICAgICAgLy8gbGl0ZXJhbHMgYW5kIHVua25vd24gc3ltYm9sc1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBpcyBhIGxpdGVyYWw/IFJlYWQgdGhlIGZ1bGwgd29yZC5cbiAgICAgICAgICAgICAgICB3aGlsZSAocG9zIDwgbGVuICYmIGlzVW5rbm93bkNvbnRlbnRDaGFyYWN0ZXIoY29kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuT2Zmc2V0ICE9PSBwb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0ZXh0LnN1YnN0cmluZyh0b2tlbk9mZnNldCwgcG9zKTtcbiAgICAgICAgICAgICAgICAgICAgLy8ga2V5d29yZHM6IHRydWUsIGZhbHNlLCBudWxsXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RydWUnOiByZXR1cm4gdG9rZW4gPSA4IC8qIFN5bnRheEtpbmQuVHJ1ZUtleXdvcmQgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmYWxzZSc6IHJldHVybiB0b2tlbiA9IDkgLyogU3ludGF4S2luZC5GYWxzZUtleXdvcmQgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdudWxsJzogcmV0dXJuIHRva2VuID0gNyAvKiBTeW50YXhLaW5kLk51bGxLZXl3b3JkICovO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbiA9IDE2IC8qIFN5bnRheEtpbmQuVW5rbm93biAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gc29tZVxuICAgICAgICAgICAgICAgIHZhbHVlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuID0gMTYgLyogU3ludGF4S2luZC5Vbmtub3duICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzVW5rbm93bkNvbnRlbnRDaGFyYWN0ZXIoY29kZSkge1xuICAgICAgICBpZiAoaXNXaGl0ZVNwYWNlKGNvZGUpIHx8IGlzTGluZUJyZWFrKGNvZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICBjYXNlIDEyNSAvKiBDaGFyYWN0ZXJDb2Rlcy5jbG9zZUJyYWNlICovOlxuICAgICAgICAgICAgY2FzZSA5MyAvKiBDaGFyYWN0ZXJDb2Rlcy5jbG9zZUJyYWNrZXQgKi86XG4gICAgICAgICAgICBjYXNlIDEyMyAvKiBDaGFyYWN0ZXJDb2Rlcy5vcGVuQnJhY2UgKi86XG4gICAgICAgICAgICBjYXNlIDkxIC8qIENoYXJhY3RlckNvZGVzLm9wZW5CcmFja2V0ICovOlxuICAgICAgICAgICAgY2FzZSAzNCAvKiBDaGFyYWN0ZXJDb2Rlcy5kb3VibGVRdW90ZSAqLzpcbiAgICAgICAgICAgIGNhc2UgNTggLyogQ2hhcmFjdGVyQ29kZXMuY29sb24gKi86XG4gICAgICAgICAgICBjYXNlIDQ0IC8qIENoYXJhY3RlckNvZGVzLmNvbW1hICovOlxuICAgICAgICAgICAgY2FzZSA0NyAvKiBDaGFyYWN0ZXJDb2Rlcy5zbGFzaCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYW5OZXh0Tm9uVHJpdmlhKCkge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICByZXN1bHQgPSBzY2FuTmV4dCgpO1xuICAgICAgICB9IHdoaWxlIChyZXN1bHQgPj0gMTIgLyogU3ludGF4S2luZC5MaW5lQ29tbWVudFRyaXZpYSAqLyAmJiByZXN1bHQgPD0gMTUgLyogU3ludGF4S2luZC5Ucml2aWEgKi8pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzZXRQb3NpdGlvbjogc2V0UG9zaXRpb24sXG4gICAgICAgIGdldFBvc2l0aW9uOiAoKSA9PiBwb3MsXG4gICAgICAgIHNjYW46IGlnbm9yZVRyaXZpYSA/IHNjYW5OZXh0Tm9uVHJpdmlhIDogc2Nhbk5leHQsXG4gICAgICAgIGdldFRva2VuOiAoKSA9PiB0b2tlbixcbiAgICAgICAgZ2V0VG9rZW5WYWx1ZTogKCkgPT4gdmFsdWUsXG4gICAgICAgIGdldFRva2VuT2Zmc2V0OiAoKSA9PiB0b2tlbk9mZnNldCxcbiAgICAgICAgZ2V0VG9rZW5MZW5ndGg6ICgpID0+IHBvcyAtIHRva2VuT2Zmc2V0LFxuICAgICAgICBnZXRUb2tlblN0YXJ0TGluZTogKCkgPT4gbGluZVN0YXJ0T2Zmc2V0LFxuICAgICAgICBnZXRUb2tlblN0YXJ0Q2hhcmFjdGVyOiAoKSA9PiB0b2tlbk9mZnNldCAtIHByZXZUb2tlbkxpbmVTdGFydE9mZnNldCxcbiAgICAgICAgZ2V0VG9rZW5FcnJvcjogKCkgPT4gc2NhbkVycm9yLFxuICAgIH07XG59XG5mdW5jdGlvbiBpc1doaXRlU3BhY2UoY2gpIHtcbiAgICByZXR1cm4gY2ggPT09IDMyIC8qIENoYXJhY3RlckNvZGVzLnNwYWNlICovIHx8IGNoID09PSA5IC8qIENoYXJhY3RlckNvZGVzLnRhYiAqLztcbn1cbmZ1bmN0aW9uIGlzTGluZUJyZWFrKGNoKSB7XG4gICAgcmV0dXJuIGNoID09PSAxMCAvKiBDaGFyYWN0ZXJDb2Rlcy5saW5lRmVlZCAqLyB8fCBjaCA9PT0gMTMgLyogQ2hhcmFjdGVyQ29kZXMuY2FycmlhZ2VSZXR1cm4gKi87XG59XG5mdW5jdGlvbiBpc0RpZ2l0KGNoKSB7XG4gICAgcmV0dXJuIGNoID49IDQ4IC8qIENoYXJhY3RlckNvZGVzLl8wICovICYmIGNoIDw9IDU3IC8qIENoYXJhY3RlckNvZGVzLl85ICovO1xufVxudmFyIENoYXJhY3RlckNvZGVzO1xuKGZ1bmN0aW9uIChDaGFyYWN0ZXJDb2Rlcykge1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wibGluZUZlZWRcIl0gPSAxMF0gPSBcImxpbmVGZWVkXCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJjYXJyaWFnZVJldHVyblwiXSA9IDEzXSA9IFwiY2FycmlhZ2VSZXR1cm5cIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcInNwYWNlXCJdID0gMzJdID0gXCJzcGFjZVwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiXzBcIl0gPSA0OF0gPSBcIl8wXCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJfMVwiXSA9IDQ5XSA9IFwiXzFcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIl8yXCJdID0gNTBdID0gXCJfMlwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiXzNcIl0gPSA1MV0gPSBcIl8zXCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJfNFwiXSA9IDUyXSA9IFwiXzRcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIl81XCJdID0gNTNdID0gXCJfNVwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiXzZcIl0gPSA1NF0gPSBcIl82XCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJfN1wiXSA9IDU1XSA9IFwiXzdcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIl84XCJdID0gNTZdID0gXCJfOFwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiXzlcIl0gPSA1N10gPSBcIl85XCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJhXCJdID0gOTddID0gXCJhXCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJiXCJdID0gOThdID0gXCJiXCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJjXCJdID0gOTldID0gXCJjXCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJkXCJdID0gMTAwXSA9IFwiZFwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiZVwiXSA9IDEwMV0gPSBcImVcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcImZcIl0gPSAxMDJdID0gXCJmXCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJnXCJdID0gMTAzXSA9IFwiZ1wiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiaFwiXSA9IDEwNF0gPSBcImhcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcImlcIl0gPSAxMDVdID0gXCJpXCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJqXCJdID0gMTA2XSA9IFwialwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wia1wiXSA9IDEwN10gPSBcImtcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcImxcIl0gPSAxMDhdID0gXCJsXCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJtXCJdID0gMTA5XSA9IFwibVwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiblwiXSA9IDExMF0gPSBcIm5cIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIm9cIl0gPSAxMTFdID0gXCJvXCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJwXCJdID0gMTEyXSA9IFwicFwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wicVwiXSA9IDExM10gPSBcInFcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcInJcIl0gPSAxMTRdID0gXCJyXCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJzXCJdID0gMTE1XSA9IFwic1wiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1widFwiXSA9IDExNl0gPSBcInRcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcInVcIl0gPSAxMTddID0gXCJ1XCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJ2XCJdID0gMTE4XSA9IFwidlwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wid1wiXSA9IDExOV0gPSBcIndcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcInhcIl0gPSAxMjBdID0gXCJ4XCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJ5XCJdID0gMTIxXSA9IFwieVwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wielwiXSA9IDEyMl0gPSBcInpcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIkFcIl0gPSA2NV0gPSBcIkFcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIkJcIl0gPSA2Nl0gPSBcIkJcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIkNcIl0gPSA2N10gPSBcIkNcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIkRcIl0gPSA2OF0gPSBcIkRcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIkVcIl0gPSA2OV0gPSBcIkVcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIkZcIl0gPSA3MF0gPSBcIkZcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIkdcIl0gPSA3MV0gPSBcIkdcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIkhcIl0gPSA3Ml0gPSBcIkhcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIklcIl0gPSA3M10gPSBcIklcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIkpcIl0gPSA3NF0gPSBcIkpcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIktcIl0gPSA3NV0gPSBcIktcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIkxcIl0gPSA3Nl0gPSBcIkxcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIk1cIl0gPSA3N10gPSBcIk1cIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIk5cIl0gPSA3OF0gPSBcIk5cIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIk9cIl0gPSA3OV0gPSBcIk9cIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIlBcIl0gPSA4MF0gPSBcIlBcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIlFcIl0gPSA4MV0gPSBcIlFcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIlJcIl0gPSA4Ml0gPSBcIlJcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIlNcIl0gPSA4M10gPSBcIlNcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIlRcIl0gPSA4NF0gPSBcIlRcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIlVcIl0gPSA4NV0gPSBcIlVcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIlZcIl0gPSA4Nl0gPSBcIlZcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIldcIl0gPSA4N10gPSBcIldcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIlhcIl0gPSA4OF0gPSBcIlhcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIllcIl0gPSA4OV0gPSBcIllcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIlpcIl0gPSA5MF0gPSBcIlpcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcImFzdGVyaXNrXCJdID0gNDJdID0gXCJhc3Rlcmlza1wiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiYmFja3NsYXNoXCJdID0gOTJdID0gXCJiYWNrc2xhc2hcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcImNsb3NlQnJhY2VcIl0gPSAxMjVdID0gXCJjbG9zZUJyYWNlXCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJjbG9zZUJyYWNrZXRcIl0gPSA5M10gPSBcImNsb3NlQnJhY2tldFwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiY29sb25cIl0gPSA1OF0gPSBcImNvbG9uXCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJjb21tYVwiXSA9IDQ0XSA9IFwiY29tbWFcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcImRvdFwiXSA9IDQ2XSA9IFwiZG90XCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJkb3VibGVRdW90ZVwiXSA9IDM0XSA9IFwiZG91YmxlUXVvdGVcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcIm1pbnVzXCJdID0gNDVdID0gXCJtaW51c1wiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wib3BlbkJyYWNlXCJdID0gMTIzXSA9IFwib3BlbkJyYWNlXCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJvcGVuQnJhY2tldFwiXSA9IDkxXSA9IFwib3BlbkJyYWNrZXRcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcInBsdXNcIl0gPSA0M10gPSBcInBsdXNcIjtcbiAgICBDaGFyYWN0ZXJDb2Rlc1tDaGFyYWN0ZXJDb2Rlc1tcInNsYXNoXCJdID0gNDddID0gXCJzbGFzaFwiO1xuICAgIENoYXJhY3RlckNvZGVzW0NoYXJhY3RlckNvZGVzW1wiZm9ybUZlZWRcIl0gPSAxMl0gPSBcImZvcm1GZWVkXCI7XG4gICAgQ2hhcmFjdGVyQ29kZXNbQ2hhcmFjdGVyQ29kZXNbXCJ0YWJcIl0gPSA5XSA9IFwidGFiXCI7XG59KShDaGFyYWN0ZXJDb2RlcyB8fCAoQ2hhcmFjdGVyQ29kZXMgPSB7fSkpO1xuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL2pzb25jLXBhcnNlci9saWIvZXNtL2ltcGwvc3RyaW5nLWludGVybi5qc1xuY29uc3QgY2FjaGVkU3BhY2VzID0gbmV3IEFycmF5KDIwKS5maWxsKDApLm1hcCgoXywgaW5kZXgpID0+IHtcbiAgICByZXR1cm4gJyAnLnJlcGVhdChpbmRleCk7XG59KTtcbmNvbnN0IG1heENhY2hlZFZhbHVlcyA9IDIwMDtcbmNvbnN0IGNhY2hlZEJyZWFrTGluZXNXaXRoU3BhY2VzID0ge1xuICAgICcgJzoge1xuICAgICAgICAnXFxuJzogbmV3IEFycmF5KG1heENhY2hlZFZhbHVlcykuZmlsbCgwKS5tYXAoKF8sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gJ1xcbicgKyAnICcucmVwZWF0KGluZGV4KTtcbiAgICAgICAgfSksXG4gICAgICAgICdcXHInOiBuZXcgQXJyYXkobWF4Q2FjaGVkVmFsdWVzKS5maWxsKDApLm1hcCgoXywgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAnXFxyJyArICcgJy5yZXBlYXQoaW5kZXgpO1xuICAgICAgICB9KSxcbiAgICAgICAgJ1xcclxcbic6IG5ldyBBcnJheShtYXhDYWNoZWRWYWx1ZXMpLmZpbGwoMCkubWFwKChfLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICdcXHJcXG4nICsgJyAnLnJlcGVhdChpbmRleCk7XG4gICAgICAgIH0pLFxuICAgIH0sXG4gICAgJ1xcdCc6IHtcbiAgICAgICAgJ1xcbic6IG5ldyBBcnJheShtYXhDYWNoZWRWYWx1ZXMpLmZpbGwoMCkubWFwKChfLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICdcXG4nICsgJ1xcdCcucmVwZWF0KGluZGV4KTtcbiAgICAgICAgfSksXG4gICAgICAgICdcXHInOiBuZXcgQXJyYXkobWF4Q2FjaGVkVmFsdWVzKS5maWxsKDApLm1hcCgoXywgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAnXFxyJyArICdcXHQnLnJlcGVhdChpbmRleCk7XG4gICAgICAgIH0pLFxuICAgICAgICAnXFxyXFxuJzogbmV3IEFycmF5KG1heENhY2hlZFZhbHVlcykuZmlsbCgwKS5tYXAoKF8sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gJ1xcclxcbicgKyAnXFx0Jy5yZXBlYXQoaW5kZXgpO1xuICAgICAgICB9KSxcbiAgICB9XG59O1xuY29uc3Qgc3VwcG9ydGVkRW9scyA9IFsnXFxuJywgJ1xccicsICdcXHJcXG4nXTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy9qc29uYy1wYXJzZXIvbGliL2VzbS9pbXBsL2Zvcm1hdC5qc1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXG5mdW5jdGlvbiBmb3JtYXRfZm9ybWF0KGRvY3VtZW50VGV4dCwgcmFuZ2UsIG9wdGlvbnMpIHtcbiAgICBsZXQgaW5pdGlhbEluZGVudExldmVsO1xuICAgIGxldCBmb3JtYXRUZXh0O1xuICAgIGxldCBmb3JtYXRUZXh0U3RhcnQ7XG4gICAgbGV0IHJhbmdlU3RhcnQ7XG4gICAgbGV0IHJhbmdlRW5kO1xuICAgIGlmIChyYW5nZSkge1xuICAgICAgICByYW5nZVN0YXJ0ID0gcmFuZ2Uub2Zmc2V0O1xuICAgICAgICByYW5nZUVuZCA9IHJhbmdlU3RhcnQgKyByYW5nZS5sZW5ndGg7XG4gICAgICAgIGZvcm1hdFRleHRTdGFydCA9IHJhbmdlU3RhcnQ7XG4gICAgICAgIHdoaWxlIChmb3JtYXRUZXh0U3RhcnQgPiAwICYmICFmb3JtYXRfaXNFT0woZG9jdW1lbnRUZXh0LCBmb3JtYXRUZXh0U3RhcnQgLSAxKSkge1xuICAgICAgICAgICAgZm9ybWF0VGV4dFN0YXJ0LS07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGVuZE9mZnNldCA9IHJhbmdlRW5kO1xuICAgICAgICB3aGlsZSAoZW5kT2Zmc2V0IDwgZG9jdW1lbnRUZXh0Lmxlbmd0aCAmJiAhZm9ybWF0X2lzRU9MKGRvY3VtZW50VGV4dCwgZW5kT2Zmc2V0KSkge1xuICAgICAgICAgICAgZW5kT2Zmc2V0Kys7XG4gICAgICAgIH1cbiAgICAgICAgZm9ybWF0VGV4dCA9IGRvY3VtZW50VGV4dC5zdWJzdHJpbmcoZm9ybWF0VGV4dFN0YXJ0LCBlbmRPZmZzZXQpO1xuICAgICAgICBpbml0aWFsSW5kZW50TGV2ZWwgPSBjb21wdXRlSW5kZW50TGV2ZWwoZm9ybWF0VGV4dCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3JtYXRUZXh0ID0gZG9jdW1lbnRUZXh0O1xuICAgICAgICBpbml0aWFsSW5kZW50TGV2ZWwgPSAwO1xuICAgICAgICBmb3JtYXRUZXh0U3RhcnQgPSAwO1xuICAgICAgICByYW5nZVN0YXJ0ID0gMDtcbiAgICAgICAgcmFuZ2VFbmQgPSBkb2N1bWVudFRleHQubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCBlb2wgPSBnZXRFT0wob3B0aW9ucywgZG9jdW1lbnRUZXh0KTtcbiAgICBjb25zdCBlb2xGYXN0UGF0aFN1cHBvcnRlZCA9IHN1cHBvcnRlZEVvbHMuaW5jbHVkZXMoZW9sKTtcbiAgICBsZXQgbnVtYmVyTGluZUJyZWFrcyA9IDA7XG4gICAgbGV0IGluZGVudExldmVsID0gMDtcbiAgICBsZXQgaW5kZW50VmFsdWU7XG4gICAgaWYgKG9wdGlvbnMuaW5zZXJ0U3BhY2VzKSB7XG4gICAgICAgIGluZGVudFZhbHVlID0gY2FjaGVkU3BhY2VzW29wdGlvbnMudGFiU2l6ZSB8fCA0XSA/PyByZXBlYXQoY2FjaGVkU3BhY2VzWzFdLCBvcHRpb25zLnRhYlNpemUgfHwgNCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpbmRlbnRWYWx1ZSA9ICdcXHQnO1xuICAgIH1cbiAgICBjb25zdCBpbmRlbnRUeXBlID0gaW5kZW50VmFsdWUgPT09ICdcXHQnID8gJ1xcdCcgOiAnICc7XG4gICAgbGV0IHNjYW5uZXIgPSBjcmVhdGVTY2FubmVyKGZvcm1hdFRleHQsIGZhbHNlKTtcbiAgICBsZXQgaGFzRXJyb3IgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBuZXdMaW5lc0FuZEluZGVudCgpIHtcbiAgICAgICAgaWYgKG51bWJlckxpbmVCcmVha3MgPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVwZWF0KGVvbCwgbnVtYmVyTGluZUJyZWFrcykgKyByZXBlYXQoaW5kZW50VmFsdWUsIGluaXRpYWxJbmRlbnRMZXZlbCArIGluZGVudExldmVsKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbW91bnRPZlNwYWNlcyA9IGluZGVudFZhbHVlLmxlbmd0aCAqIChpbml0aWFsSW5kZW50TGV2ZWwgKyBpbmRlbnRMZXZlbCk7XG4gICAgICAgIGlmICghZW9sRmFzdFBhdGhTdXBwb3J0ZWQgfHwgYW1vdW50T2ZTcGFjZXMgPiBjYWNoZWRCcmVha0xpbmVzV2l0aFNwYWNlc1tpbmRlbnRUeXBlXVtlb2xdLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGVvbCArIHJlcGVhdChpbmRlbnRWYWx1ZSwgaW5pdGlhbEluZGVudExldmVsICsgaW5kZW50TGV2ZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbW91bnRPZlNwYWNlcyA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZW9sO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWNoZWRCcmVha0xpbmVzV2l0aFNwYWNlc1tpbmRlbnRUeXBlXVtlb2xdW2Ftb3VudE9mU3BhY2VzXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2Nhbk5leHQoKSB7XG4gICAgICAgIGxldCB0b2tlbiA9IHNjYW5uZXIuc2NhbigpO1xuICAgICAgICBudW1iZXJMaW5lQnJlYWtzID0gMDtcbiAgICAgICAgd2hpbGUgKHRva2VuID09PSAxNSAvKiBTeW50YXhLaW5kLlRyaXZpYSAqLyB8fCB0b2tlbiA9PT0gMTQgLyogU3ludGF4S2luZC5MaW5lQnJlYWtUcml2aWEgKi8pIHtcbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gMTQgLyogU3ludGF4S2luZC5MaW5lQnJlYWtUcml2aWEgKi8gJiYgb3B0aW9ucy5rZWVwTGluZXMpIHtcbiAgICAgICAgICAgICAgICBudW1iZXJMaW5lQnJlYWtzICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b2tlbiA9PT0gMTQgLyogU3ludGF4S2luZC5MaW5lQnJlYWtUcml2aWEgKi8pIHtcbiAgICAgICAgICAgICAgICBudW1iZXJMaW5lQnJlYWtzID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRva2VuID0gc2Nhbm5lci5zY2FuKCk7XG4gICAgICAgIH1cbiAgICAgICAgaGFzRXJyb3IgPSB0b2tlbiA9PT0gMTYgLyogU3ludGF4S2luZC5Vbmtub3duICovIHx8IHNjYW5uZXIuZ2V0VG9rZW5FcnJvcigpICE9PSAwIC8qIFNjYW5FcnJvci5Ob25lICovO1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuICAgIGNvbnN0IGVkaXRPcGVyYXRpb25zID0gW107XG4gICAgZnVuY3Rpb24gYWRkRWRpdCh0ZXh0LCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0KSB7XG4gICAgICAgIGlmICghaGFzRXJyb3IgJiYgKCFyYW5nZSB8fCAoc3RhcnRPZmZzZXQgPCByYW5nZUVuZCAmJiBlbmRPZmZzZXQgPiByYW5nZVN0YXJ0KSkgJiYgZG9jdW1lbnRUZXh0LnN1YnN0cmluZyhzdGFydE9mZnNldCwgZW5kT2Zmc2V0KSAhPT0gdGV4dCkge1xuICAgICAgICAgICAgZWRpdE9wZXJhdGlvbnMucHVzaCh7IG9mZnNldDogc3RhcnRPZmZzZXQsIGxlbmd0aDogZW5kT2Zmc2V0IC0gc3RhcnRPZmZzZXQsIGNvbnRlbnQ6IHRleHQgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGZpcnN0VG9rZW4gPSBzY2FuTmV4dCgpO1xuICAgIGlmIChvcHRpb25zLmtlZXBMaW5lcyAmJiBudW1iZXJMaW5lQnJlYWtzID4gMCkge1xuICAgICAgICBhZGRFZGl0KHJlcGVhdChlb2wsIG51bWJlckxpbmVCcmVha3MpLCAwLCAwKTtcbiAgICB9XG4gICAgaWYgKGZpcnN0VG9rZW4gIT09IDE3IC8qIFN5bnRheEtpbmQuRU9GICovKSB7XG4gICAgICAgIGxldCBmaXJzdFRva2VuU3RhcnQgPSBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkgKyBmb3JtYXRUZXh0U3RhcnQ7XG4gICAgICAgIGxldCBpbml0aWFsSW5kZW50ID0gKGluZGVudFZhbHVlLmxlbmd0aCAqIGluaXRpYWxJbmRlbnRMZXZlbCA8IDIwKSAmJiBvcHRpb25zLmluc2VydFNwYWNlc1xuICAgICAgICAgICAgPyBjYWNoZWRTcGFjZXNbaW5kZW50VmFsdWUubGVuZ3RoICogaW5pdGlhbEluZGVudExldmVsXVxuICAgICAgICAgICAgOiByZXBlYXQoaW5kZW50VmFsdWUsIGluaXRpYWxJbmRlbnRMZXZlbCk7XG4gICAgICAgIGFkZEVkaXQoaW5pdGlhbEluZGVudCwgZm9ybWF0VGV4dFN0YXJ0LCBmaXJzdFRva2VuU3RhcnQpO1xuICAgIH1cbiAgICB3aGlsZSAoZmlyc3RUb2tlbiAhPT0gMTcgLyogU3ludGF4S2luZC5FT0YgKi8pIHtcbiAgICAgICAgbGV0IGZpcnN0VG9rZW5FbmQgPSBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkgKyBzY2FubmVyLmdldFRva2VuTGVuZ3RoKCkgKyBmb3JtYXRUZXh0U3RhcnQ7XG4gICAgICAgIGxldCBzZWNvbmRUb2tlbiA9IHNjYW5OZXh0KCk7XG4gICAgICAgIGxldCByZXBsYWNlQ29udGVudCA9ICcnO1xuICAgICAgICBsZXQgbmVlZHNMaW5lQnJlYWsgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKG51bWJlckxpbmVCcmVha3MgPT09IDAgJiYgKHNlY29uZFRva2VuID09PSAxMiAvKiBTeW50YXhLaW5kLkxpbmVDb21tZW50VHJpdmlhICovIHx8IHNlY29uZFRva2VuID09PSAxMyAvKiBTeW50YXhLaW5kLkJsb2NrQ29tbWVudFRyaXZpYSAqLykpIHtcbiAgICAgICAgICAgIGxldCBjb21tZW50VG9rZW5TdGFydCA9IHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSArIGZvcm1hdFRleHRTdGFydDtcbiAgICAgICAgICAgIGFkZEVkaXQoY2FjaGVkU3BhY2VzWzFdLCBmaXJzdFRva2VuRW5kLCBjb21tZW50VG9rZW5TdGFydCk7XG4gICAgICAgICAgICBmaXJzdFRva2VuRW5kID0gc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpICsgc2Nhbm5lci5nZXRUb2tlbkxlbmd0aCgpICsgZm9ybWF0VGV4dFN0YXJ0O1xuICAgICAgICAgICAgbmVlZHNMaW5lQnJlYWsgPSBzZWNvbmRUb2tlbiA9PT0gMTIgLyogU3ludGF4S2luZC5MaW5lQ29tbWVudFRyaXZpYSAqLztcbiAgICAgICAgICAgIHJlcGxhY2VDb250ZW50ID0gbmVlZHNMaW5lQnJlYWsgPyBuZXdMaW5lc0FuZEluZGVudCgpIDogJyc7XG4gICAgICAgICAgICBzZWNvbmRUb2tlbiA9IHNjYW5OZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlY29uZFRva2VuID09PSAyIC8qIFN5bnRheEtpbmQuQ2xvc2VCcmFjZVRva2VuICovKSB7XG4gICAgICAgICAgICBpZiAoZmlyc3RUb2tlbiAhPT0gMSAvKiBTeW50YXhLaW5kLk9wZW5CcmFjZVRva2VuICovKSB7XG4gICAgICAgICAgICAgICAgaW5kZW50TGV2ZWwtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmtlZXBMaW5lcyAmJiBudW1iZXJMaW5lQnJlYWtzID4gMCB8fCAhb3B0aW9ucy5rZWVwTGluZXMgJiYgZmlyc3RUb2tlbiAhPT0gMSAvKiBTeW50YXhLaW5kLk9wZW5CcmFjZVRva2VuICovKSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZUNvbnRlbnQgPSBuZXdMaW5lc0FuZEluZGVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5rZWVwTGluZXMpIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlQ29udGVudCA9IGNhY2hlZFNwYWNlc1sxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzZWNvbmRUb2tlbiA9PT0gNCAvKiBTeW50YXhLaW5kLkNsb3NlQnJhY2tldFRva2VuICovKSB7XG4gICAgICAgICAgICBpZiAoZmlyc3RUb2tlbiAhPT0gMyAvKiBTeW50YXhLaW5kLk9wZW5CcmFja2V0VG9rZW4gKi8pIHtcbiAgICAgICAgICAgICAgICBpbmRlbnRMZXZlbC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMua2VlcExpbmVzICYmIG51bWJlckxpbmVCcmVha3MgPiAwIHx8ICFvcHRpb25zLmtlZXBMaW5lcyAmJiBmaXJzdFRva2VuICE9PSAzIC8qIFN5bnRheEtpbmQuT3BlbkJyYWNrZXRUb2tlbiAqLykge1xuICAgICAgICAgICAgICAgIHJlcGxhY2VDb250ZW50ID0gbmV3TGluZXNBbmRJbmRlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMua2VlcExpbmVzKSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZUNvbnRlbnQgPSBjYWNoZWRTcGFjZXNbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpcnN0VG9rZW4pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDMgLyogU3ludGF4S2luZC5PcGVuQnJhY2tldFRva2VuICovOlxuICAgICAgICAgICAgICAgIGNhc2UgMSAvKiBTeW50YXhLaW5kLk9wZW5CcmFjZVRva2VuICovOlxuICAgICAgICAgICAgICAgICAgICBpbmRlbnRMZXZlbCsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5rZWVwTGluZXMgJiYgbnVtYmVyTGluZUJyZWFrcyA+IDAgfHwgIW9wdGlvbnMua2VlcExpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlQ29udGVudCA9IG5ld0xpbmVzQW5kSW5kZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlQ29udGVudCA9IGNhY2hlZFNwYWNlc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDUgLyogU3ludGF4S2luZC5Db21tYVRva2VuICovOlxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5rZWVwTGluZXMgJiYgbnVtYmVyTGluZUJyZWFrcyA+IDAgfHwgIW9wdGlvbnMua2VlcExpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlQ29udGVudCA9IG5ld0xpbmVzQW5kSW5kZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlQ29udGVudCA9IGNhY2hlZFNwYWNlc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEyIC8qIFN5bnRheEtpbmQuTGluZUNvbW1lbnRUcml2aWEgKi86XG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VDb250ZW50ID0gbmV3TGluZXNBbmRJbmRlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMyAvKiBTeW50YXhLaW5kLkJsb2NrQ29tbWVudFRyaXZpYSAqLzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKG51bWJlckxpbmVCcmVha3MgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlQ29udGVudCA9IG5ld0xpbmVzQW5kSW5kZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIW5lZWRzTGluZUJyZWFrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlQ29udGVudCA9IGNhY2hlZFNwYWNlc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDYgLyogU3ludGF4S2luZC5Db2xvblRva2VuICovOlxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5rZWVwTGluZXMgJiYgbnVtYmVyTGluZUJyZWFrcyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VDb250ZW50ID0gbmV3TGluZXNBbmRJbmRlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghbmVlZHNMaW5lQnJlYWspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VDb250ZW50ID0gY2FjaGVkU3BhY2VzWzFdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTAgLyogU3ludGF4S2luZC5TdHJpbmdMaXRlcmFsICovOlxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5rZWVwTGluZXMgJiYgbnVtYmVyTGluZUJyZWFrcyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VDb250ZW50ID0gbmV3TGluZXNBbmRJbmRlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzZWNvbmRUb2tlbiA9PT0gNiAvKiBTeW50YXhLaW5kLkNvbG9uVG9rZW4gKi8gJiYgIW5lZWRzTGluZUJyZWFrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlQ29udGVudCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNyAvKiBTeW50YXhLaW5kLk51bGxLZXl3b3JkICovOlxuICAgICAgICAgICAgICAgIGNhc2UgOCAvKiBTeW50YXhLaW5kLlRydWVLZXl3b3JkICovOlxuICAgICAgICAgICAgICAgIGNhc2UgOSAvKiBTeW50YXhLaW5kLkZhbHNlS2V5d29yZCAqLzpcbiAgICAgICAgICAgICAgICBjYXNlIDExIC8qIFN5bnRheEtpbmQuTnVtZXJpY0xpdGVyYWwgKi86XG4gICAgICAgICAgICAgICAgY2FzZSAyIC8qIFN5bnRheEtpbmQuQ2xvc2VCcmFjZVRva2VuICovOlxuICAgICAgICAgICAgICAgIGNhc2UgNCAvKiBTeW50YXhLaW5kLkNsb3NlQnJhY2tldFRva2VuICovOlxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5rZWVwTGluZXMgJiYgbnVtYmVyTGluZUJyZWFrcyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VDb250ZW50ID0gbmV3TGluZXNBbmRJbmRlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoc2Vjb25kVG9rZW4gPT09IDEyIC8qIFN5bnRheEtpbmQuTGluZUNvbW1lbnRUcml2aWEgKi8gfHwgc2Vjb25kVG9rZW4gPT09IDEzIC8qIFN5bnRheEtpbmQuQmxvY2tDb21tZW50VHJpdmlhICovKSAmJiAhbmVlZHNMaW5lQnJlYWspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlQ29udGVudCA9IGNhY2hlZFNwYWNlc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlY29uZFRva2VuICE9PSA1IC8qIFN5bnRheEtpbmQuQ29tbWFUb2tlbiAqLyAmJiBzZWNvbmRUb2tlbiAhPT0gMTcgLyogU3ludGF4S2luZC5FT0YgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxNiAvKiBTeW50YXhLaW5kLlVua25vd24gKi86XG4gICAgICAgICAgICAgICAgICAgIGhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobnVtYmVyTGluZUJyZWFrcyA+IDAgJiYgKHNlY29uZFRva2VuID09PSAxMiAvKiBTeW50YXhLaW5kLkxpbmVDb21tZW50VHJpdmlhICovIHx8IHNlY29uZFRva2VuID09PSAxMyAvKiBTeW50YXhLaW5kLkJsb2NrQ29tbWVudFRyaXZpYSAqLykpIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlQ29udGVudCA9IG5ld0xpbmVzQW5kSW5kZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlY29uZFRva2VuID09PSAxNyAvKiBTeW50YXhLaW5kLkVPRiAqLykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMua2VlcExpbmVzICYmIG51bWJlckxpbmVCcmVha3MgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZUNvbnRlbnQgPSBuZXdMaW5lc0FuZEluZGVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZUNvbnRlbnQgPSBvcHRpb25zLmluc2VydEZpbmFsTmV3bGluZSA/IGVvbCA6ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlY29uZFRva2VuU3RhcnQgPSBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkgKyBmb3JtYXRUZXh0U3RhcnQ7XG4gICAgICAgIGFkZEVkaXQocmVwbGFjZUNvbnRlbnQsIGZpcnN0VG9rZW5FbmQsIHNlY29uZFRva2VuU3RhcnQpO1xuICAgICAgICBmaXJzdFRva2VuID0gc2Vjb25kVG9rZW47XG4gICAgfVxuICAgIHJldHVybiBlZGl0T3BlcmF0aW9ucztcbn1cbmZ1bmN0aW9uIHJlcGVhdChzLCBjb3VudCkge1xuICAgIGxldCByZXN1bHQgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgcmVzdWx0ICs9IHM7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjb21wdXRlSW5kZW50TGV2ZWwoY29udGVudCwgb3B0aW9ucykge1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgbkNoYXJzID0gMDtcbiAgICBjb25zdCB0YWJTaXplID0gb3B0aW9ucy50YWJTaXplIHx8IDQ7XG4gICAgd2hpbGUgKGkgPCBjb250ZW50Lmxlbmd0aCkge1xuICAgICAgICBsZXQgY2ggPSBjb250ZW50LmNoYXJBdChpKTtcbiAgICAgICAgaWYgKGNoID09PSBjYWNoZWRTcGFjZXNbMV0pIHtcbiAgICAgICAgICAgIG5DaGFycysrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSAnXFx0Jykge1xuICAgICAgICAgICAgbkNoYXJzICs9IHRhYlNpemU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLmZsb29yKG5DaGFycyAvIHRhYlNpemUpO1xufVxuZnVuY3Rpb24gZ2V0RU9MKG9wdGlvbnMsIHRleHQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2ggPSB0ZXh0LmNoYXJBdChpKTtcbiAgICAgICAgaWYgKGNoID09PSAnXFxyJykge1xuICAgICAgICAgICAgaWYgKGkgKyAxIDwgdGV4dC5sZW5ndGggJiYgdGV4dC5jaGFyQXQoaSArIDEpID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAnXFxyXFxuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnXFxyJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaCA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgIHJldHVybiAnXFxuJztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKG9wdGlvbnMgJiYgb3B0aW9ucy5lb2wpIHx8ICdcXG4nO1xufVxuZnVuY3Rpb24gZm9ybWF0X2lzRU9MKHRleHQsIG9mZnNldCkge1xuICAgIHJldHVybiAnXFxyXFxuJy5pbmRleE9mKHRleHQuY2hhckF0KG9mZnNldCkpICE9PSAtMTtcbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy9qc29uYy1wYXJzZXIvbGliL2VzbS9pbXBsL3BhcnNlci5qc1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxudmFyIFBhcnNlT3B0aW9ucztcbihmdW5jdGlvbiAoUGFyc2VPcHRpb25zKSB7XG4gICAgUGFyc2VPcHRpb25zLkRFRkFVTFQgPSB7XG4gICAgICAgIGFsbG93VHJhaWxpbmdDb21tYTogZmFsc2VcbiAgICB9O1xufSkoUGFyc2VPcHRpb25zIHx8IChQYXJzZU9wdGlvbnMgPSB7fSkpO1xuLyoqXG4gKiBGb3IgYSBnaXZlbiBvZmZzZXQsIGV2YWx1YXRlIHRoZSBsb2NhdGlvbiBpbiB0aGUgSlNPTiBkb2N1bWVudC4gRWFjaCBzZWdtZW50IGluIHRoZSBsb2NhdGlvbiBwYXRoIGlzIGVpdGhlciBhIHByb3BlcnR5IG5hbWUgb3IgYW4gYXJyYXkgaW5kZXguXG4gKi9cbmZ1bmN0aW9uIGdldExvY2F0aW9uKHRleHQsIHBvc2l0aW9uKSB7XG4gICAgY29uc3Qgc2VnbWVudHMgPSBbXTsgLy8gc3RyaW5ncyBvciBudW1iZXJzXG4gICAgY29uc3QgZWFybHlSZXR1cm5FeGNlcHRpb24gPSBuZXcgT2JqZWN0KCk7XG4gICAgbGV0IHByZXZpb3VzTm9kZSA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCBwcmV2aW91c05vZGVJbnN0ID0ge1xuICAgICAgICB2YWx1ZToge30sXG4gICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgbGVuZ3RoOiAwLFxuICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgcGFyZW50OiB1bmRlZmluZWRcbiAgICB9O1xuICAgIGxldCBpc0F0UHJvcGVydHlLZXkgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBzZXRQcmV2aW91c05vZGUodmFsdWUsIG9mZnNldCwgbGVuZ3RoLCB0eXBlKSB7XG4gICAgICAgIHByZXZpb3VzTm9kZUluc3QudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcHJldmlvdXNOb2RlSW5zdC5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHByZXZpb3VzTm9kZUluc3QubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICBwcmV2aW91c05vZGVJbnN0LnR5cGUgPSB0eXBlO1xuICAgICAgICBwcmV2aW91c05vZGVJbnN0LmNvbG9uT2Zmc2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICBwcmV2aW91c05vZGUgPSBwcmV2aW91c05vZGVJbnN0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICB2aXNpdCh0ZXh0LCB7XG4gICAgICAgICAgICBvbk9iamVjdEJlZ2luOiAob2Zmc2V0LCBsZW5ndGgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPD0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVhcmx5UmV0dXJuRXhjZXB0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmV2aW91c05vZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaXNBdFByb3BlcnR5S2V5ID0gcG9zaXRpb24gPiBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaCgnJyk7IC8vIHB1c2ggYSBwbGFjZWhvbGRlciAod2lsbCBiZSByZXBsYWNlZClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbk9iamVjdFByb3BlcnR5OiAobmFtZSwgb2Zmc2V0LCBsZW5ndGgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPCBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZWFybHlSZXR1cm5FeGNlcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldFByZXZpb3VzTm9kZShuYW1lLCBvZmZzZXQsIGxlbmd0aCwgJ3Byb3BlcnR5Jyk7XG4gICAgICAgICAgICAgICAgc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV0gPSBuYW1lO1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8PSBvZmZzZXQgKyBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZWFybHlSZXR1cm5FeGNlcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uT2JqZWN0RW5kOiAob2Zmc2V0LCBsZW5ndGgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPD0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVhcmx5UmV0dXJuRXhjZXB0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmV2aW91c05vZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgc2VnbWVudHMucG9wKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25BcnJheUJlZ2luOiAob2Zmc2V0LCBsZW5ndGgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPD0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVhcmx5UmV0dXJuRXhjZXB0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmV2aW91c05vZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaCgwKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkFycmF5RW5kOiAob2Zmc2V0LCBsZW5ndGgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPD0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVhcmx5UmV0dXJuRXhjZXB0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmV2aW91c05vZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgc2VnbWVudHMucG9wKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25MaXRlcmFsVmFsdWU6ICh2YWx1ZSwgb2Zmc2V0LCBsZW5ndGgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPCBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZWFybHlSZXR1cm5FeGNlcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldFByZXZpb3VzTm9kZSh2YWx1ZSwgb2Zmc2V0LCBsZW5ndGgsIGdldE5vZGVUeXBlKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDw9IG9mZnNldCArIGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlYXJseVJldHVybkV4Y2VwdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25TZXBhcmF0b3I6IChzZXAsIG9mZnNldCwgbGVuZ3RoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDw9IG9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlYXJseVJldHVybkV4Y2VwdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlcCA9PT0gJzonICYmIHByZXZpb3VzTm9kZSAmJiBwcmV2aW91c05vZGUudHlwZSA9PT0gJ3Byb3BlcnR5Jykge1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c05vZGUuY29sb25PZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIGlzQXRQcm9wZXJ0eUtleSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c05vZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlcCA9PT0gJywnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3QgPSBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsYXN0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV0gPSBsYXN0ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQXRQcm9wZXJ0eUtleSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzTm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZSAhPT0gZWFybHlSZXR1cm5FeGNlcHRpb24pIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aDogc2VnbWVudHMsXG4gICAgICAgIHByZXZpb3VzTm9kZSxcbiAgICAgICAgaXNBdFByb3BlcnR5S2V5LFxuICAgICAgICBtYXRjaGVzOiAocGF0dGVybikgPT4ge1xuICAgICAgICAgICAgbGV0IGsgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGsgPCBwYXR0ZXJuLmxlbmd0aCAmJiBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocGF0dGVybltrXSA9PT0gc2VnbWVudHNbaV0gfHwgcGF0dGVybltrXSA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGF0dGVybltrXSAhPT0gJyoqJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGsgPT09IHBhdHRlcm4ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuICogUGFyc2VzIHRoZSBnaXZlbiB0ZXh0IGFuZCByZXR1cm5zIHRoZSBvYmplY3QgdGhlIEpTT04gY29udGVudCByZXByZXNlbnRzLiBPbiBpbnZhbGlkIGlucHV0LCB0aGUgcGFyc2VyIHRyaWVzIHRvIGJlIGFzIGZhdWx0IHRvbGVyYW50IGFzIHBvc3NpYmxlLCBidXQgc3RpbGwgcmV0dXJuIGEgcmVzdWx0LlxuICogVGhlcmVmb3JlIGFsd2F5cyBjaGVjayB0aGUgZXJyb3JzIGxpc3QgdG8gZmluZCBvdXQgaWYgdGhlIGlucHV0IHdhcyB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gcGFyc2UodGV4dCwgZXJyb3JzID0gW10sIG9wdGlvbnMgPSBQYXJzZU9wdGlvbnMuREVGQVVMVCkge1xuICAgIGxldCBjdXJyZW50UHJvcGVydHkgPSBudWxsO1xuICAgIGxldCBjdXJyZW50UGFyZW50ID0gW107XG4gICAgY29uc3QgcHJldmlvdXNQYXJlbnRzID0gW107XG4gICAgZnVuY3Rpb24gb25WYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50UGFyZW50KSkge1xuICAgICAgICAgICAgY3VycmVudFBhcmVudC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJyZW50UHJvcGVydHkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRbY3VycmVudFByb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHZpc2l0b3IgPSB7XG4gICAgICAgIG9uT2JqZWN0QmVnaW46ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgb25WYWx1ZShvYmplY3QpO1xuICAgICAgICAgICAgcHJldmlvdXNQYXJlbnRzLnB1c2goY3VycmVudFBhcmVudCk7XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gb2JqZWN0O1xuICAgICAgICAgICAgY3VycmVudFByb3BlcnR5ID0gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgb25PYmplY3RQcm9wZXJ0eTogKG5hbWUpID0+IHtcbiAgICAgICAgICAgIGN1cnJlbnRQcm9wZXJ0eSA9IG5hbWU7XG4gICAgICAgIH0sXG4gICAgICAgIG9uT2JqZWN0RW5kOiAoKSA9PiB7XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gcHJldmlvdXNQYXJlbnRzLnBvcCgpO1xuICAgICAgICB9LFxuICAgICAgICBvbkFycmF5QmVnaW46ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFycmF5ID0gW107XG4gICAgICAgICAgICBvblZhbHVlKGFycmF5KTtcbiAgICAgICAgICAgIHByZXZpb3VzUGFyZW50cy5wdXNoKGN1cnJlbnRQYXJlbnQpO1xuICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IGFycmF5O1xuICAgICAgICAgICAgY3VycmVudFByb3BlcnR5ID0gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgb25BcnJheUVuZDogKCkgPT4ge1xuICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IHByZXZpb3VzUGFyZW50cy5wb3AoKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25MaXRlcmFsVmFsdWU6IG9uVmFsdWUsXG4gICAgICAgIG9uRXJyb3I6IChlcnJvciwgb2Zmc2V0LCBsZW5ndGgpID0+IHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHsgZXJyb3IsIG9mZnNldCwgbGVuZ3RoIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2aXNpdCh0ZXh0LCB2aXNpdG9yLCBvcHRpb25zKTtcbiAgICByZXR1cm4gY3VycmVudFBhcmVudFswXTtcbn1cbi8qKlxuICogUGFyc2VzIHRoZSBnaXZlbiB0ZXh0IGFuZCByZXR1cm5zIGEgdHJlZSByZXByZXNlbnRhdGlvbiB0aGUgSlNPTiBjb250ZW50LiBPbiBpbnZhbGlkIGlucHV0LCB0aGUgcGFyc2VyIHRyaWVzIHRvIGJlIGFzIGZhdWx0IHRvbGVyYW50IGFzIHBvc3NpYmxlLCBidXQgc3RpbGwgcmV0dXJuIGEgcmVzdWx0LlxuICovXG5mdW5jdGlvbiBwYXJzZXJfcGFyc2VUcmVlKHRleHQsIGVycm9ycyA9IFtdLCBvcHRpb25zID0gUGFyc2VPcHRpb25zLkRFRkFVTFQpIHtcbiAgICBsZXQgY3VycmVudFBhcmVudCA9IHsgdHlwZTogJ2FycmF5Jywgb2Zmc2V0OiAtMSwgbGVuZ3RoOiAtMSwgY2hpbGRyZW46IFtdLCBwYXJlbnQ6IHVuZGVmaW5lZCB9OyAvLyBhcnRpZmljaWFsIHJvb3RcbiAgICBmdW5jdGlvbiBlbnN1cmVQcm9wZXJ0eUNvbXBsZXRlKGVuZE9mZnNldCkge1xuICAgICAgICBpZiAoY3VycmVudFBhcmVudC50eXBlID09PSAncHJvcGVydHknKSB7XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50Lmxlbmd0aCA9IGVuZE9mZnNldCAtIGN1cnJlbnRQYXJlbnQub2Zmc2V0O1xuICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IGN1cnJlbnRQYXJlbnQucGFyZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uVmFsdWUodmFsdWVOb2RlKSB7XG4gICAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaCh2YWx1ZU5vZGUpO1xuICAgICAgICByZXR1cm4gdmFsdWVOb2RlO1xuICAgIH1cbiAgICBjb25zdCB2aXNpdG9yID0ge1xuICAgICAgICBvbk9iamVjdEJlZ2luOiAob2Zmc2V0KSA9PiB7XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gb25WYWx1ZSh7IHR5cGU6ICdvYmplY3QnLCBvZmZzZXQsIGxlbmd0aDogLTEsIHBhcmVudDogY3VycmVudFBhcmVudCwgY2hpbGRyZW46IFtdIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbk9iamVjdFByb3BlcnR5OiAobmFtZSwgb2Zmc2V0LCBsZW5ndGgpID0+IHtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBvblZhbHVlKHsgdHlwZTogJ3Byb3BlcnR5Jywgb2Zmc2V0LCBsZW5ndGg6IC0xLCBwYXJlbnQ6IGN1cnJlbnRQYXJlbnQsIGNoaWxkcmVuOiBbXSB9KTtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaCh7IHR5cGU6ICdzdHJpbmcnLCB2YWx1ZTogbmFtZSwgb2Zmc2V0LCBsZW5ndGgsIHBhcmVudDogY3VycmVudFBhcmVudCB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25PYmplY3RFbmQ6IChvZmZzZXQsIGxlbmd0aCkgPT4ge1xuICAgICAgICAgICAgZW5zdXJlUHJvcGVydHlDb21wbGV0ZShvZmZzZXQgKyBsZW5ndGgpOyAvLyBpbiBjYXNlIG9mIGEgbWlzc2luZyB2YWx1ZSBmb3IgYSBwcm9wZXJ0eTogbWFrZSBzdXJlIHByb3BlcnR5IGlzIGNvbXBsZXRlXG4gICAgICAgICAgICBjdXJyZW50UGFyZW50Lmxlbmd0aCA9IG9mZnNldCArIGxlbmd0aCAtIGN1cnJlbnRQYXJlbnQub2Zmc2V0O1xuICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IGN1cnJlbnRQYXJlbnQucGFyZW50O1xuICAgICAgICAgICAgZW5zdXJlUHJvcGVydHlDb21wbGV0ZShvZmZzZXQgKyBsZW5ndGgpO1xuICAgICAgICB9LFxuICAgICAgICBvbkFycmF5QmVnaW46IChvZmZzZXQsIGxlbmd0aCkgPT4ge1xuICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IG9uVmFsdWUoeyB0eXBlOiAnYXJyYXknLCBvZmZzZXQsIGxlbmd0aDogLTEsIHBhcmVudDogY3VycmVudFBhcmVudCwgY2hpbGRyZW46IFtdIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbkFycmF5RW5kOiAob2Zmc2V0LCBsZW5ndGgpID0+IHtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQubGVuZ3RoID0gb2Zmc2V0ICsgbGVuZ3RoIC0gY3VycmVudFBhcmVudC5vZmZzZXQ7XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gY3VycmVudFBhcmVudC5wYXJlbnQ7XG4gICAgICAgICAgICBlbnN1cmVQcm9wZXJ0eUNvbXBsZXRlKG9mZnNldCArIGxlbmd0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uTGl0ZXJhbFZhbHVlOiAodmFsdWUsIG9mZnNldCwgbGVuZ3RoKSA9PiB7XG4gICAgICAgICAgICBvblZhbHVlKHsgdHlwZTogZ2V0Tm9kZVR5cGUodmFsdWUpLCBvZmZzZXQsIGxlbmd0aCwgcGFyZW50OiBjdXJyZW50UGFyZW50LCB2YWx1ZSB9KTtcbiAgICAgICAgICAgIGVuc3VyZVByb3BlcnR5Q29tcGxldGUob2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25TZXBhcmF0b3I6IChzZXAsIG9mZnNldCwgbGVuZ3RoKSA9PiB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFBhcmVudC50eXBlID09PSAncHJvcGVydHknKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlcCA9PT0gJzonKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQuY29sb25PZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlcCA9PT0gJywnKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuc3VyZVByb3BlcnR5Q29tcGxldGUob2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uRXJyb3I6IChlcnJvciwgb2Zmc2V0LCBsZW5ndGgpID0+IHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHsgZXJyb3IsIG9mZnNldCwgbGVuZ3RoIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2aXNpdCh0ZXh0LCB2aXNpdG9yLCBvcHRpb25zKTtcbiAgICBjb25zdCByZXN1bHQgPSBjdXJyZW50UGFyZW50LmNoaWxkcmVuWzBdO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgZGVsZXRlIHJlc3VsdC5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEZpbmRzIHRoZSBub2RlIGF0IHRoZSBnaXZlbiBwYXRoIGluIGEgSlNPTiBET00uXG4gKi9cbmZ1bmN0aW9uIHBhcnNlcl9maW5kTm9kZUF0TG9jYXRpb24ocm9vdCwgcGF0aCkge1xuICAgIGlmICghcm9vdCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBsZXQgbm9kZSA9IHJvb3Q7XG4gICAgZm9yIChsZXQgc2VnbWVudCBvZiBwYXRoKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VnbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgIT09ICdvYmplY3QnIHx8ICFBcnJheS5pc0FycmF5KG5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eU5vZGUgb2Ygbm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BlcnR5Tm9kZS5jaGlsZHJlbikgJiYgcHJvcGVydHlOb2RlLmNoaWxkcmVuWzBdLnZhbHVlID09PSBzZWdtZW50ICYmIHByb3BlcnR5Tm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHByb3BlcnR5Tm9kZS5jaGlsZHJlblsxXTtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gc2VnbWVudDtcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgIT09ICdhcnJheScgfHwgaW5kZXggPCAwIHx8ICFBcnJheS5pc0FycmF5KG5vZGUuY2hpbGRyZW4pIHx8IGluZGV4ID49IG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuW2luZGV4XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn1cbi8qKlxuICogR2V0cyB0aGUgSlNPTiBwYXRoIG9mIHRoZSBnaXZlbiBKU09OIERPTSBub2RlXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVQYXRoKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUucGFyZW50IHx8ICFub2RlLnBhcmVudC5jaGlsZHJlbikge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IHBhdGggPSBnZXROb2RlUGF0aChub2RlLnBhcmVudCk7XG4gICAgaWYgKG5vZGUucGFyZW50LnR5cGUgPT09ICdwcm9wZXJ0eScpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gbm9kZS5wYXJlbnQuY2hpbGRyZW5bMF0udmFsdWU7XG4gICAgICAgIHBhdGgucHVzaChrZXkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlLnBhcmVudC50eXBlID09PSAnYXJyYXknKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbm9kZS5wYXJlbnQuY2hpbGRyZW4uaW5kZXhPZihub2RlKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgcGF0aC5wdXNoKGluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbn1cbi8qKlxuICogRXZhbHVhdGVzIHRoZSBKYXZhU2NyaXB0IG9iamVjdCBvZiB0aGUgZ2l2ZW4gSlNPTiBET00gbm9kZVxuICovXG5mdW5jdGlvbiBnZXROb2RlVmFsdWUobm9kZSkge1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgICAgICAgIHJldHVybiBub2RlLmNoaWxkcmVuLm1hcChnZXROb2RlVmFsdWUpO1xuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIGZvciAobGV0IHByb3Agb2Ygbm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlTm9kZSA9IHByb3AuY2hpbGRyZW5bMV07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBvYmpbcHJvcC5jaGlsZHJlblswXS52YWx1ZV0gPSBnZXROb2RlVmFsdWUodmFsdWVOb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICBjYXNlICdudWxsJzpcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZnVuY3Rpb24gY29udGFpbnMobm9kZSwgb2Zmc2V0LCBpbmNsdWRlUmlnaHRCb3VuZCA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIChvZmZzZXQgPj0gbm9kZS5vZmZzZXQgJiYgb2Zmc2V0IDwgKG5vZGUub2Zmc2V0ICsgbm9kZS5sZW5ndGgpKSB8fCBpbmNsdWRlUmlnaHRCb3VuZCAmJiAob2Zmc2V0ID09PSAobm9kZS5vZmZzZXQgKyBub2RlLmxlbmd0aCkpO1xufVxuLyoqXG4gKiBGaW5kcyB0aGUgbW9zdCBpbm5lciBub2RlIGF0IHRoZSBnaXZlbiBvZmZzZXQuIElmIGluY2x1ZGVSaWdodEJvdW5kIGlzIHNldCwgYWxzbyBmaW5kcyBub2RlcyB0aGF0IGVuZCBhdCB0aGUgZ2l2ZW4gb2Zmc2V0LlxuICovXG5mdW5jdGlvbiBmaW5kTm9kZUF0T2Zmc2V0KG5vZGUsIG9mZnNldCwgaW5jbHVkZVJpZ2h0Qm91bmQgPSBmYWxzZSkge1xuICAgIGlmIChjb250YWlucyhub2RlLCBvZmZzZXQsIGluY2x1ZGVSaWdodEJvdW5kKSkge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGggJiYgY2hpbGRyZW5baV0ub2Zmc2V0IDw9IG9mZnNldDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IGZpbmROb2RlQXRPZmZzZXQoY2hpbGRyZW5baV0sIG9mZnNldCwgaW5jbHVkZVJpZ2h0Qm91bmQpO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8qKlxuICogUGFyc2VzIHRoZSBnaXZlbiB0ZXh0IGFuZCBpbnZva2VzIHRoZSB2aXNpdG9yIGZ1bmN0aW9ucyBmb3IgZWFjaCBvYmplY3QsIGFycmF5IGFuZCBsaXRlcmFsIHJlYWNoZWQuXG4gKi9cbmZ1bmN0aW9uIHZpc2l0KHRleHQsIHZpc2l0b3IsIG9wdGlvbnMgPSBQYXJzZU9wdGlvbnMuREVGQVVMVCkge1xuICAgIGNvbnN0IF9zY2FubmVyID0gY3JlYXRlU2Nhbm5lcih0ZXh0LCBmYWxzZSk7XG4gICAgLy8gSW1wb3J0YW50OiBPbmx5IHBhc3MgY29waWVzIG9mIHRoaXMgdG8gdmlzaXRvciBmdW5jdGlvbnMgdG8gcHJldmVudCBhY2NpZGVudGFsIG1vZGlmaWNhdGlvbiwgYW5kXG4gICAgLy8gdG8gbm90IGFmZmVjdCB2aXNpdG9yIGZ1bmN0aW9ucyB3aGljaCBzdG9yZWQgYSByZWZlcmVuY2UgdG8gYSBwcmV2aW91cyBKU09OUGF0aFxuICAgIGNvbnN0IF9qc29uUGF0aCA9IFtdO1xuICAgIC8vIERlcHRoIG9mIG9uWFhYQmVnaW4oKSBjYWxsYmFja3Mgc3VwcHJlc3NlZC4gb25YWFhFbmQoKSBkZWNyZW1lbnRzIHRoaXMgaWYgaXQgaXNuJ3QgMCBhbHJlYWR5LlxuICAgIC8vIENhbGxiYWNrcyBhcmUgb25seSBjYWxsZWQgd2hlbiB0aGlzIHZhbHVlIGlzIDAuXG4gICAgbGV0IHN1cHByZXNzZWRDYWxsYmFja3MgPSAwO1xuICAgIGZ1bmN0aW9uIHRvTm9BcmdWaXNpdCh2aXNpdEZ1bmN0aW9uKSB7XG4gICAgICAgIHJldHVybiB2aXNpdEZ1bmN0aW9uID8gKCkgPT4gc3VwcHJlc3NlZENhbGxiYWNrcyA9PT0gMCAmJiB2aXNpdEZ1bmN0aW9uKF9zY2FubmVyLmdldFRva2VuT2Zmc2V0KCksIF9zY2FubmVyLmdldFRva2VuTGVuZ3RoKCksIF9zY2FubmVyLmdldFRva2VuU3RhcnRMaW5lKCksIF9zY2FubmVyLmdldFRva2VuU3RhcnRDaGFyYWN0ZXIoKSkgOiAoKSA9PiB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0b09uZUFyZ1Zpc2l0KHZpc2l0RnVuY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0RnVuY3Rpb24gPyAoYXJnKSA9PiBzdXBwcmVzc2VkQ2FsbGJhY2tzID09PSAwICYmIHZpc2l0RnVuY3Rpb24oYXJnLCBfc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpLCBfc2Nhbm5lci5nZXRUb2tlbkxlbmd0aCgpLCBfc2Nhbm5lci5nZXRUb2tlblN0YXJ0TGluZSgpLCBfc2Nhbm5lci5nZXRUb2tlblN0YXJ0Q2hhcmFjdGVyKCkpIDogKCkgPT4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdG9PbmVBcmdWaXNpdFdpdGhQYXRoKHZpc2l0RnVuY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0RnVuY3Rpb24gPyAoYXJnKSA9PiBzdXBwcmVzc2VkQ2FsbGJhY2tzID09PSAwICYmIHZpc2l0RnVuY3Rpb24oYXJnLCBfc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpLCBfc2Nhbm5lci5nZXRUb2tlbkxlbmd0aCgpLCBfc2Nhbm5lci5nZXRUb2tlblN0YXJ0TGluZSgpLCBfc2Nhbm5lci5nZXRUb2tlblN0YXJ0Q2hhcmFjdGVyKCksICgpID0+IF9qc29uUGF0aC5zbGljZSgpKSA6ICgpID0+IHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvQmVnaW5WaXNpdCh2aXNpdEZ1bmN0aW9uKSB7XG4gICAgICAgIHJldHVybiB2aXNpdEZ1bmN0aW9uID9cbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc3VwcHJlc3NlZENhbGxiYWNrcyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3VwcHJlc3NlZENhbGxiYWNrcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNiUmV0dXJuID0gdmlzaXRGdW5jdGlvbihfc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpLCBfc2Nhbm5lci5nZXRUb2tlbkxlbmd0aCgpLCBfc2Nhbm5lci5nZXRUb2tlblN0YXJ0TGluZSgpLCBfc2Nhbm5lci5nZXRUb2tlblN0YXJ0Q2hhcmFjdGVyKCksICgpID0+IF9qc29uUGF0aC5zbGljZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNiUmV0dXJuID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VwcHJlc3NlZENhbGxiYWNrcyA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6ICgpID0+IHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvRW5kVmlzaXQodmlzaXRGdW5jdGlvbikge1xuICAgICAgICByZXR1cm4gdmlzaXRGdW5jdGlvbiA/XG4gICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHN1cHByZXNzZWRDYWxsYmFja3MgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cHByZXNzZWRDYWxsYmFja3MtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN1cHByZXNzZWRDYWxsYmFja3MgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmlzaXRGdW5jdGlvbihfc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpLCBfc2Nhbm5lci5nZXRUb2tlbkxlbmd0aCgpLCBfc2Nhbm5lci5nZXRUb2tlblN0YXJ0TGluZSgpLCBfc2Nhbm5lci5nZXRUb2tlblN0YXJ0Q2hhcmFjdGVyKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogKCkgPT4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3Qgb25PYmplY3RCZWdpbiA9IHRvQmVnaW5WaXNpdCh2aXNpdG9yLm9uT2JqZWN0QmVnaW4pLCBvbk9iamVjdFByb3BlcnR5ID0gdG9PbmVBcmdWaXNpdFdpdGhQYXRoKHZpc2l0b3Iub25PYmplY3RQcm9wZXJ0eSksIG9uT2JqZWN0RW5kID0gdG9FbmRWaXNpdCh2aXNpdG9yLm9uT2JqZWN0RW5kKSwgb25BcnJheUJlZ2luID0gdG9CZWdpblZpc2l0KHZpc2l0b3Iub25BcnJheUJlZ2luKSwgb25BcnJheUVuZCA9IHRvRW5kVmlzaXQodmlzaXRvci5vbkFycmF5RW5kKSwgb25MaXRlcmFsVmFsdWUgPSB0b09uZUFyZ1Zpc2l0V2l0aFBhdGgodmlzaXRvci5vbkxpdGVyYWxWYWx1ZSksIG9uU2VwYXJhdG9yID0gdG9PbmVBcmdWaXNpdCh2aXNpdG9yLm9uU2VwYXJhdG9yKSwgb25Db21tZW50ID0gdG9Ob0FyZ1Zpc2l0KHZpc2l0b3Iub25Db21tZW50KSwgb25FcnJvciA9IHRvT25lQXJnVmlzaXQodmlzaXRvci5vbkVycm9yKTtcbiAgICBjb25zdCBkaXNhbGxvd0NvbW1lbnRzID0gb3B0aW9ucyAmJiBvcHRpb25zLmRpc2FsbG93Q29tbWVudHM7XG4gICAgY29uc3QgYWxsb3dUcmFpbGluZ0NvbW1hID0gb3B0aW9ucyAmJiBvcHRpb25zLmFsbG93VHJhaWxpbmdDb21tYTtcbiAgICBmdW5jdGlvbiBzY2FuTmV4dCgpIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gX3NjYW5uZXIuc2NhbigpO1xuICAgICAgICAgICAgc3dpdGNoIChfc2Nhbm5lci5nZXRUb2tlbkVycm9yKCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDQgLyogU2NhbkVycm9yLkludmFsaWRVbmljb2RlICovOlxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcigxNCAvKiBQYXJzZUVycm9yQ29kZS5JbnZhbGlkVW5pY29kZSAqLyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNSAvKiBTY2FuRXJyb3IuSW52YWxpZEVzY2FwZUNoYXJhY3RlciAqLzpcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoMTUgLyogUGFyc2VFcnJvckNvZGUuSW52YWxpZEVzY2FwZUNoYXJhY3RlciAqLyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMyAvKiBTY2FuRXJyb3IuVW5leHBlY3RlZEVuZE9mTnVtYmVyICovOlxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcigxMyAvKiBQYXJzZUVycm9yQ29kZS5VbmV4cGVjdGVkRW5kT2ZOdW1iZXIgKi8pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEgLyogU2NhbkVycm9yLlVuZXhwZWN0ZWRFbmRPZkNvbW1lbnQgKi86XG4gICAgICAgICAgICAgICAgICAgIGlmICghZGlzYWxsb3dDb21tZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoMTEgLyogUGFyc2VFcnJvckNvZGUuVW5leHBlY3RlZEVuZE9mQ29tbWVudCAqLyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyIC8qIFNjYW5FcnJvci5VbmV4cGVjdGVkRW5kT2ZTdHJpbmcgKi86XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKDEyIC8qIFBhcnNlRXJyb3JDb2RlLlVuZXhwZWN0ZWRFbmRPZlN0cmluZyAqLyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNiAvKiBTY2FuRXJyb3IuSW52YWxpZENoYXJhY3RlciAqLzpcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoMTYgLyogUGFyc2VFcnJvckNvZGUuSW52YWxpZENoYXJhY3RlciAqLyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICAgICAgICAgIGNhc2UgMTIgLyogU3ludGF4S2luZC5MaW5lQ29tbWVudFRyaXZpYSAqLzpcbiAgICAgICAgICAgICAgICBjYXNlIDEzIC8qIFN5bnRheEtpbmQuQmxvY2tDb21tZW50VHJpdmlhICovOlxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzYWxsb3dDb21tZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoMTAgLyogUGFyc2VFcnJvckNvZGUuSW52YWxpZENvbW1lbnRUb2tlbiAqLyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNvbW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE2IC8qIFN5bnRheEtpbmQuVW5rbm93biAqLzpcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoMSAvKiBQYXJzZUVycm9yQ29kZS5JbnZhbGlkU3ltYm9sICovKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxNSAvKiBTeW50YXhLaW5kLlRyaXZpYSAqLzpcbiAgICAgICAgICAgICAgICBjYXNlIDE0IC8qIFN5bnRheEtpbmQuTGluZUJyZWFrVHJpdmlhICovOlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyb3IsIHNraXBVbnRpbEFmdGVyID0gW10sIHNraXBVbnRpbCA9IFtdKSB7XG4gICAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICBpZiAoc2tpcFVudGlsQWZ0ZXIubGVuZ3RoICsgc2tpcFVudGlsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxldCB0b2tlbiA9IF9zY2FubmVyLmdldFRva2VuKCk7XG4gICAgICAgICAgICB3aGlsZSAodG9rZW4gIT09IDE3IC8qIFN5bnRheEtpbmQuRU9GICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNraXBVbnRpbEFmdGVyLmluZGV4T2YodG9rZW4pICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBzY2FuTmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2tpcFVudGlsLmluZGV4T2YodG9rZW4pICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBzY2FuTmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlU3RyaW5nKGlzVmFsdWUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBfc2Nhbm5lci5nZXRUb2tlblZhbHVlKCk7XG4gICAgICAgIGlmIChpc1ZhbHVlKSB7XG4gICAgICAgICAgICBvbkxpdGVyYWxWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvbk9iamVjdFByb3BlcnR5KHZhbHVlKTtcbiAgICAgICAgICAgIC8vIGFkZCBwcm9wZXJ0eSBuYW1lIGFmdGVyd2FyZHNcbiAgICAgICAgICAgIF9qc29uUGF0aC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBzY2FuTmV4dCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VMaXRlcmFsKCkge1xuICAgICAgICBzd2l0Y2ggKF9zY2FubmVyLmdldFRva2VuKCkpIHtcbiAgICAgICAgICAgIGNhc2UgMTEgLyogU3ludGF4S2luZC5OdW1lcmljTGl0ZXJhbCAqLzpcbiAgICAgICAgICAgICAgICBjb25zdCB0b2tlblZhbHVlID0gX3NjYW5uZXIuZ2V0VG9rZW5WYWx1ZSgpO1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IE51bWJlcih0b2tlblZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKDIgLyogUGFyc2VFcnJvckNvZGUuSW52YWxpZE51bWJlckZvcm1hdCAqLyk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb25MaXRlcmFsVmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA3IC8qIFN5bnRheEtpbmQuTnVsbEtleXdvcmQgKi86XG4gICAgICAgICAgICAgICAgb25MaXRlcmFsVmFsdWUobnVsbCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDggLyogU3ludGF4S2luZC5UcnVlS2V5d29yZCAqLzpcbiAgICAgICAgICAgICAgICBvbkxpdGVyYWxWYWx1ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgOSAvKiBTeW50YXhLaW5kLkZhbHNlS2V5d29yZCAqLzpcbiAgICAgICAgICAgICAgICBvbkxpdGVyYWxWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzY2FuTmV4dCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VQcm9wZXJ0eSgpIHtcbiAgICAgICAgaWYgKF9zY2FubmVyLmdldFRva2VuKCkgIT09IDEwIC8qIFN5bnRheEtpbmQuU3RyaW5nTGl0ZXJhbCAqLykge1xuICAgICAgICAgICAgaGFuZGxlRXJyb3IoMyAvKiBQYXJzZUVycm9yQ29kZS5Qcm9wZXJ0eU5hbWVFeHBlY3RlZCAqLywgW10sIFsyIC8qIFN5bnRheEtpbmQuQ2xvc2VCcmFjZVRva2VuICovLCA1IC8qIFN5bnRheEtpbmQuQ29tbWFUb2tlbiAqL10pO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlU3RyaW5nKGZhbHNlKTtcbiAgICAgICAgaWYgKF9zY2FubmVyLmdldFRva2VuKCkgPT09IDYgLyogU3ludGF4S2luZC5Db2xvblRva2VuICovKSB7XG4gICAgICAgICAgICBvblNlcGFyYXRvcignOicpO1xuICAgICAgICAgICAgc2Nhbk5leHQoKTsgLy8gY29uc3VtZSBjb2xvblxuICAgICAgICAgICAgaWYgKCFwYXJzZVZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcig0IC8qIFBhcnNlRXJyb3JDb2RlLlZhbHVlRXhwZWN0ZWQgKi8sIFtdLCBbMiAvKiBTeW50YXhLaW5kLkNsb3NlQnJhY2VUb2tlbiAqLywgNSAvKiBTeW50YXhLaW5kLkNvbW1hVG9rZW4gKi9dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKDUgLyogUGFyc2VFcnJvckNvZGUuQ29sb25FeHBlY3RlZCAqLywgW10sIFsyIC8qIFN5bnRheEtpbmQuQ2xvc2VCcmFjZVRva2VuICovLCA1IC8qIFN5bnRheEtpbmQuQ29tbWFUb2tlbiAqL10pO1xuICAgICAgICB9XG4gICAgICAgIF9qc29uUGF0aC5wb3AoKTsgLy8gcmVtb3ZlIHByb2Nlc3NlZCBwcm9wZXJ0eSBuYW1lXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZU9iamVjdCgpIHtcbiAgICAgICAgb25PYmplY3RCZWdpbigpO1xuICAgICAgICBzY2FuTmV4dCgpOyAvLyBjb25zdW1lIG9wZW4gYnJhY2VcbiAgICAgICAgbGV0IG5lZWRzQ29tbWEgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKF9zY2FubmVyLmdldFRva2VuKCkgIT09IDIgLyogU3ludGF4S2luZC5DbG9zZUJyYWNlVG9rZW4gKi8gJiYgX3NjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gMTcgLyogU3ludGF4S2luZC5FT0YgKi8pIHtcbiAgICAgICAgICAgIGlmIChfc2Nhbm5lci5nZXRUb2tlbigpID09PSA1IC8qIFN5bnRheEtpbmQuQ29tbWFUb2tlbiAqLykge1xuICAgICAgICAgICAgICAgIGlmICghbmVlZHNDb21tYSkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcig0IC8qIFBhcnNlRXJyb3JDb2RlLlZhbHVlRXhwZWN0ZWQgKi8sIFtdLCBbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9uU2VwYXJhdG9yKCcsJyk7XG4gICAgICAgICAgICAgICAgc2Nhbk5leHQoKTsgLy8gY29uc3VtZSBjb21tYVxuICAgICAgICAgICAgICAgIGlmIChfc2Nhbm5lci5nZXRUb2tlbigpID09PSAyIC8qIFN5bnRheEtpbmQuQ2xvc2VCcmFjZVRva2VuICovICYmIGFsbG93VHJhaWxpbmdDb21tYSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZWVkc0NvbW1hKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoNiAvKiBQYXJzZUVycm9yQ29kZS5Db21tYUV4cGVjdGVkICovLCBbXSwgW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwYXJzZVByb3BlcnR5KCkpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcig0IC8qIFBhcnNlRXJyb3JDb2RlLlZhbHVlRXhwZWN0ZWQgKi8sIFtdLCBbMiAvKiBTeW50YXhLaW5kLkNsb3NlQnJhY2VUb2tlbiAqLywgNSAvKiBTeW50YXhLaW5kLkNvbW1hVG9rZW4gKi9dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5lZWRzQ29tbWEgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIG9uT2JqZWN0RW5kKCk7XG4gICAgICAgIGlmIChfc2Nhbm5lci5nZXRUb2tlbigpICE9PSAyIC8qIFN5bnRheEtpbmQuQ2xvc2VCcmFjZVRva2VuICovKSB7XG4gICAgICAgICAgICBoYW5kbGVFcnJvcig3IC8qIFBhcnNlRXJyb3JDb2RlLkNsb3NlQnJhY2VFeHBlY3RlZCAqLywgWzIgLyogU3ludGF4S2luZC5DbG9zZUJyYWNlVG9rZW4gKi9dLCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzY2FuTmV4dCgpOyAvLyBjb25zdW1lIGNsb3NlIGJyYWNlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlQXJyYXkoKSB7XG4gICAgICAgIG9uQXJyYXlCZWdpbigpO1xuICAgICAgICBzY2FuTmV4dCgpOyAvLyBjb25zdW1lIG9wZW4gYnJhY2tldFxuICAgICAgICBsZXQgaXNGaXJzdEVsZW1lbnQgPSB0cnVlO1xuICAgICAgICBsZXQgbmVlZHNDb21tYSA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAoX3NjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gNCAvKiBTeW50YXhLaW5kLkNsb3NlQnJhY2tldFRva2VuICovICYmIF9zY2FubmVyLmdldFRva2VuKCkgIT09IDE3IC8qIFN5bnRheEtpbmQuRU9GICovKSB7XG4gICAgICAgICAgICBpZiAoX3NjYW5uZXIuZ2V0VG9rZW4oKSA9PT0gNSAvKiBTeW50YXhLaW5kLkNvbW1hVG9rZW4gKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoIW5lZWRzQ29tbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoNCAvKiBQYXJzZUVycm9yQ29kZS5WYWx1ZUV4cGVjdGVkICovLCBbXSwgW10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvblNlcGFyYXRvcignLCcpO1xuICAgICAgICAgICAgICAgIHNjYW5OZXh0KCk7IC8vIGNvbnN1bWUgY29tbWFcbiAgICAgICAgICAgICAgICBpZiAoX3NjYW5uZXIuZ2V0VG9rZW4oKSA9PT0gNCAvKiBTeW50YXhLaW5kLkNsb3NlQnJhY2tldFRva2VuICovICYmIGFsbG93VHJhaWxpbmdDb21tYSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZWVkc0NvbW1hKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoNiAvKiBQYXJzZUVycm9yQ29kZS5Db21tYUV4cGVjdGVkICovLCBbXSwgW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRmlyc3RFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgX2pzb25QYXRoLnB1c2goMCk7XG4gICAgICAgICAgICAgICAgaXNGaXJzdEVsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF9qc29uUGF0aFtfanNvblBhdGgubGVuZ3RoIC0gMV0rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcGFyc2VWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlRXJyb3IoNCAvKiBQYXJzZUVycm9yQ29kZS5WYWx1ZUV4cGVjdGVkICovLCBbXSwgWzQgLyogU3ludGF4S2luZC5DbG9zZUJyYWNrZXRUb2tlbiAqLywgNSAvKiBTeW50YXhLaW5kLkNvbW1hVG9rZW4gKi9dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5lZWRzQ29tbWEgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIG9uQXJyYXlFbmQoKTtcbiAgICAgICAgaWYgKCFpc0ZpcnN0RWxlbWVudCkge1xuICAgICAgICAgICAgX2pzb25QYXRoLnBvcCgpOyAvLyByZW1vdmUgYXJyYXkgaW5kZXhcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3NjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gNCAvKiBTeW50YXhLaW5kLkNsb3NlQnJhY2tldFRva2VuICovKSB7XG4gICAgICAgICAgICBoYW5kbGVFcnJvcig4IC8qIFBhcnNlRXJyb3JDb2RlLkNsb3NlQnJhY2tldEV4cGVjdGVkICovLCBbNCAvKiBTeW50YXhLaW5kLkNsb3NlQnJhY2tldFRva2VuICovXSwgW10pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2Nhbk5leHQoKTsgLy8gY29uc3VtZSBjbG9zZSBicmFja2V0XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlVmFsdWUoKSB7XG4gICAgICAgIHN3aXRjaCAoX3NjYW5uZXIuZ2V0VG9rZW4oKSkge1xuICAgICAgICAgICAgY2FzZSAzIC8qIFN5bnRheEtpbmQuT3BlbkJyYWNrZXRUb2tlbiAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VBcnJheSgpO1xuICAgICAgICAgICAgY2FzZSAxIC8qIFN5bnRheEtpbmQuT3BlbkJyYWNlVG9rZW4gKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlT2JqZWN0KCk7XG4gICAgICAgICAgICBjYXNlIDEwIC8qIFN5bnRheEtpbmQuU3RyaW5nTGl0ZXJhbCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VTdHJpbmcodHJ1ZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUxpdGVyYWwoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzY2FuTmV4dCgpO1xuICAgIGlmIChfc2Nhbm5lci5nZXRUb2tlbigpID09PSAxNyAvKiBTeW50YXhLaW5kLkVPRiAqLykge1xuICAgICAgICBpZiAob3B0aW9ucy5hbGxvd0VtcHR5Q29udGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlRXJyb3IoNCAvKiBQYXJzZUVycm9yQ29kZS5WYWx1ZUV4cGVjdGVkICovLCBbXSwgW10pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghcGFyc2VWYWx1ZSgpKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKDQgLyogUGFyc2VFcnJvckNvZGUuVmFsdWVFeHBlY3RlZCAqLywgW10sIFtdKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoX3NjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gMTcgLyogU3ludGF4S2luZC5FT0YgKi8pIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoOSAvKiBQYXJzZUVycm9yQ29kZS5FbmRPZkZpbGVFeHBlY3RlZCAqLywgW10sIFtdKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIFRha2VzIEpTT04gd2l0aCBKYXZhU2NyaXB0LXN0eWxlIGNvbW1lbnRzIGFuZCByZW1vdmVcbiAqIHRoZW0uIE9wdGlvbmFsbHkgcmVwbGFjZXMgZXZlcnkgbm9uZS1uZXdsaW5lIGNoYXJhY3RlclxuICogb2YgY29tbWVudHMgd2l0aCBhIHJlcGxhY2VDaGFyYWN0ZXJcbiAqL1xuZnVuY3Rpb24gc3RyaXBDb21tZW50cyh0ZXh0LCByZXBsYWNlQ2gpIHtcbiAgICBsZXQgX3NjYW5uZXIgPSBjcmVhdGVTY2FubmVyKHRleHQpLCBwYXJ0cyA9IFtdLCBraW5kLCBvZmZzZXQgPSAwLCBwb3M7XG4gICAgZG8ge1xuICAgICAgICBwb3MgPSBfc2Nhbm5lci5nZXRQb3NpdGlvbigpO1xuICAgICAgICBraW5kID0gX3NjYW5uZXIuc2NhbigpO1xuICAgICAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgMTIgLyogU3ludGF4S2luZC5MaW5lQ29tbWVudFRyaXZpYSAqLzpcbiAgICAgICAgICAgIGNhc2UgMTMgLyogU3ludGF4S2luZC5CbG9ja0NvbW1lbnRUcml2aWEgKi86XG4gICAgICAgICAgICBjYXNlIDE3IC8qIFN5bnRheEtpbmQuRU9GICovOlxuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgIT09IHBvcykge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHRleHQuc3Vic3RyaW5nKG9mZnNldCwgcG9zKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlQ2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKF9zY2FubmVyLmdldFRva2VuVmFsdWUoKS5yZXBsYWNlKC9bXlxcclxcbl0vZywgcmVwbGFjZUNoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCA9IF9zY2FubmVyLmdldFBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9IHdoaWxlIChraW5kICE9PSAxNyAvKiBTeW50YXhLaW5kLkVPRiAqLyk7XG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oJycpO1xufVxuZnVuY3Rpb24gZ2V0Tm9kZVR5cGUodmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlICdib29sZWFuJzogcmV0dXJuICdib29sZWFuJztcbiAgICAgICAgY2FzZSAnbnVtYmVyJzogcmV0dXJuICdudW1iZXInO1xuICAgICAgICBjYXNlICdzdHJpbmcnOiByZXR1cm4gJ3N0cmluZyc7XG4gICAgICAgIGNhc2UgJ29iamVjdCc6IHtcbiAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2FycmF5JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiByZXR1cm4gJ251bGwnO1xuICAgIH1cbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy9qc29uYy1wYXJzZXIvbGliL2VzbS9pbXBsL2VkaXQuanNcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblxuZnVuY3Rpb24gcmVtb3ZlUHJvcGVydHkodGV4dCwgcGF0aCwgb3B0aW9ucykge1xuICAgIHJldHVybiBzZXRQcm9wZXJ0eSh0ZXh0LCBwYXRoLCB2b2lkIDAsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gc2V0UHJvcGVydHkodGV4dCwgb3JpZ2luYWxQYXRoLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHBhdGggPSBvcmlnaW5hbFBhdGguc2xpY2UoKTtcbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICBjb25zdCByb290ID0gcGFyc2VUcmVlKHRleHQsIGVycm9ycyk7XG4gICAgbGV0IHBhcmVudCA9IHZvaWQgMDtcbiAgICBsZXQgbGFzdFNlZ21lbnQgPSB2b2lkIDA7XG4gICAgd2hpbGUgKHBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICBsYXN0U2VnbWVudCA9IHBhdGgucG9wKCk7XG4gICAgICAgIHBhcmVudCA9IGZpbmROb2RlQXRMb2NhdGlvbihyb290LCBwYXRoKTtcbiAgICAgICAgaWYgKHBhcmVudCA9PT0gdm9pZCAwICYmIHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGFzdFNlZ21lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB7IFtsYXN0U2VnbWVudF06IHZhbHVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICAvLyBlbXB0eSBkb2N1bWVudFxuICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyAvLyBkZWxldGVcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBkZWxldGUgaW4gZW1wdHkgZG9jdW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2l0aEZvcm1hdHRpbmcodGV4dCwgeyBvZmZzZXQ6IHJvb3QgPyByb290Lm9mZnNldCA6IDAsIGxlbmd0aDogcm9vdCA/IHJvb3QubGVuZ3RoIDogMCwgY29udGVudDogSlNPTi5zdHJpbmdpZnkodmFsdWUpIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChwYXJlbnQudHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGxhc3RTZWdtZW50ID09PSAnc3RyaW5nJyAmJiBBcnJheS5pc0FycmF5KHBhcmVudC5jaGlsZHJlbikpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBmaW5kTm9kZUF0TG9jYXRpb24ocGFyZW50LCBbbGFzdFNlZ21lbnRdKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7IC8vIGRlbGV0ZVxuICAgICAgICAgICAgICAgIGlmICghZXhpc3RpbmcucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIEFTVCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eUluZGV4ID0gcGFyZW50LmNoaWxkcmVuLmluZGV4T2YoZXhpc3RpbmcucGFyZW50KTtcbiAgICAgICAgICAgICAgICBsZXQgcmVtb3ZlQmVnaW47XG4gICAgICAgICAgICAgICAgbGV0IHJlbW92ZUVuZCA9IGV4aXN0aW5nLnBhcmVudC5vZmZzZXQgKyBleGlzdGluZy5wYXJlbnQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eUluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIGNvbW1hIG9mIHRoZSBwcmV2aW91cyBub2RlXG4gICAgICAgICAgICAgICAgICAgIGxldCBwcmV2aW91cyA9IHBhcmVudC5jaGlsZHJlbltwcm9wZXJ0eUluZGV4IC0gMV07XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUJlZ2luID0gcHJldmlvdXMub2Zmc2V0ICsgcHJldmlvdXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQmVnaW4gPSBwYXJlbnQub2Zmc2V0ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudC5jaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIGNvbW1hIG9mIHRoZSBuZXh0IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gcGFyZW50LmNoaWxkcmVuWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRW5kID0gbmV4dC5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpdGhGb3JtYXR0aW5nKHRleHQsIHsgb2Zmc2V0OiByZW1vdmVCZWdpbiwgbGVuZ3RoOiByZW1vdmVFbmQgLSByZW1vdmVCZWdpbiwgY29udGVudDogJycgfSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzZXQgdmFsdWUgb2YgZXhpc3RpbmcgcHJvcGVydHlcbiAgICAgICAgICAgICAgICByZXR1cm4gd2l0aEZvcm1hdHRpbmcodGV4dCwgeyBvZmZzZXQ6IGV4aXN0aW5nLm9mZnNldCwgbGVuZ3RoOiBleGlzdGluZy5sZW5ndGgsIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KHZhbHVlKSB9LCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7IC8vIGRlbGV0ZVxuICAgICAgICAgICAgICAgIHJldHVybiBbXTsgLy8gcHJvcGVydHkgZG9lcyBub3QgZXhpc3QsIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5ld1Byb3BlcnR5ID0gYCR7SlNPTi5zdHJpbmdpZnkobGFzdFNlZ21lbnQpfTogJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9YDtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gb3B0aW9ucy5nZXRJbnNlcnRpb25JbmRleCA/IG9wdGlvbnMuZ2V0SW5zZXJ0aW9uSW5kZXgocGFyZW50LmNoaWxkcmVuLm1hcChwID0+IHAuY2hpbGRyZW5bMF0udmFsdWUpKSA6IHBhcmVudC5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgZWRpdDtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJldmlvdXMgPSBwYXJlbnQuY2hpbGRyZW5baW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICBlZGl0ID0geyBvZmZzZXQ6IHByZXZpb3VzLm9mZnNldCArIHByZXZpb3VzLmxlbmd0aCwgbGVuZ3RoOiAwLCBjb250ZW50OiAnLCcgKyBuZXdQcm9wZXJ0eSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyZW50LmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGVkaXQgPSB7IG9mZnNldDogcGFyZW50Lm9mZnNldCArIDEsIGxlbmd0aDogMCwgY29udGVudDogbmV3UHJvcGVydHkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVkaXQgPSB7IG9mZnNldDogcGFyZW50Lm9mZnNldCArIDEsIGxlbmd0aDogMCwgY29udGVudDogbmV3UHJvcGVydHkgKyAnLCcgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB3aXRoRm9ybWF0dGluZyh0ZXh0LCBlZGl0LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChwYXJlbnQudHlwZSA9PT0gJ2FycmF5JyAmJiB0eXBlb2YgbGFzdFNlZ21lbnQgPT09ICdudW1iZXInICYmIEFycmF5LmlzQXJyYXkocGFyZW50LmNoaWxkcmVuKSkge1xuICAgICAgICBjb25zdCBpbnNlcnRJbmRleCA9IGxhc3RTZWdtZW50O1xuICAgICAgICBpZiAoaW5zZXJ0SW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBJbnNlcnRcbiAgICAgICAgICAgIGNvbnN0IG5ld1Byb3BlcnR5ID0gYCR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfWA7XG4gICAgICAgICAgICBsZXQgZWRpdDtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZWRpdCA9IHsgb2Zmc2V0OiBwYXJlbnQub2Zmc2V0ICsgMSwgbGVuZ3RoOiAwLCBjb250ZW50OiBuZXdQcm9wZXJ0eSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXMgPSBwYXJlbnQuY2hpbGRyZW5bcGFyZW50LmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGVkaXQgPSB7IG9mZnNldDogcHJldmlvdXMub2Zmc2V0ICsgcHJldmlvdXMubGVuZ3RoLCBsZW5ndGg6IDAsIGNvbnRlbnQ6ICcsJyArIG5ld1Byb3BlcnR5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd2l0aEZvcm1hdHRpbmcodGV4dCwgZWRpdCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IHZvaWQgMCAmJiBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoID49IDApIHtcbiAgICAgICAgICAgIC8vIFJlbW92YWxcbiAgICAgICAgICAgIGNvbnN0IHJlbW92YWxJbmRleCA9IGxhc3RTZWdtZW50O1xuICAgICAgICAgICAgY29uc3QgdG9SZW1vdmUgPSBwYXJlbnQuY2hpbGRyZW5bcmVtb3ZhbEluZGV4XTtcbiAgICAgICAgICAgIGxldCBlZGl0O1xuICAgICAgICAgICAgaWYgKHBhcmVudC5jaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGl0ZW1cbiAgICAgICAgICAgICAgICBlZGl0ID0geyBvZmZzZXQ6IHBhcmVudC5vZmZzZXQgKyAxLCBsZW5ndGg6IHBhcmVudC5sZW5ndGggLSAyLCBjb250ZW50OiAnJyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyZW50LmNoaWxkcmVuLmxlbmd0aCAtIDEgPT09IHJlbW92YWxJbmRleCkge1xuICAgICAgICAgICAgICAgIC8vIGxhc3QgaXRlbVxuICAgICAgICAgICAgICAgIGxldCBwcmV2aW91cyA9IHBhcmVudC5jaGlsZHJlbltyZW1vdmFsSW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gcHJldmlvdXMub2Zmc2V0ICsgcHJldmlvdXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxldCBwYXJlbnRFbmRPZmZzZXQgPSBwYXJlbnQub2Zmc2V0ICsgcGFyZW50Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBlZGl0ID0geyBvZmZzZXQsIGxlbmd0aDogcGFyZW50RW5kT2Zmc2V0IC0gMiAtIG9mZnNldCwgY29udGVudDogJycgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVkaXQgPSB7IG9mZnNldDogdG9SZW1vdmUub2Zmc2V0LCBsZW5ndGg6IHBhcmVudC5jaGlsZHJlbltyZW1vdmFsSW5kZXggKyAxXS5vZmZzZXQgLSB0b1JlbW92ZS5vZmZzZXQsIGNvbnRlbnQ6ICcnIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd2l0aEZvcm1hdHRpbmcodGV4dCwgZWRpdCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgbGV0IGVkaXQ7XG4gICAgICAgICAgICBjb25zdCBuZXdQcm9wZXJ0eSA9IGAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmlzQXJyYXlJbnNlcnRpb24gJiYgcGFyZW50LmNoaWxkcmVuLmxlbmd0aCA+IGxhc3RTZWdtZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9Nb2RpZnkgPSBwYXJlbnQuY2hpbGRyZW5bbGFzdFNlZ21lbnRdO1xuICAgICAgICAgICAgICAgIGVkaXQgPSB7IG9mZnNldDogdG9Nb2RpZnkub2Zmc2V0LCBsZW5ndGg6IHRvTW9kaWZ5Lmxlbmd0aCwgY29udGVudDogbmV3UHJvcGVydHkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmVudC5jaGlsZHJlbi5sZW5ndGggPT09IDAgfHwgbGFzdFNlZ21lbnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBlZGl0ID0geyBvZmZzZXQ6IHBhcmVudC5vZmZzZXQgKyAxLCBsZW5ndGg6IDAsIGNvbnRlbnQ6IHBhcmVudC5jaGlsZHJlbi5sZW5ndGggPT09IDAgPyBuZXdQcm9wZXJ0eSA6IG5ld1Byb3BlcnR5ICsgJywnIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGxhc3RTZWdtZW50ID4gcGFyZW50LmNoaWxkcmVuLmxlbmd0aCA/IHBhcmVudC5jaGlsZHJlbi5sZW5ndGggOiBsYXN0U2VnbWVudDtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91cyA9IHBhcmVudC5jaGlsZHJlbltpbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgIGVkaXQgPSB7IG9mZnNldDogcHJldmlvdXMub2Zmc2V0ICsgcHJldmlvdXMubGVuZ3RoLCBsZW5ndGg6IDAsIGNvbnRlbnQ6ICcsJyArIG5ld1Byb3BlcnR5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd2l0aEZvcm1hdHRpbmcodGV4dCwgZWRpdCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbiBub3QgJHt2YWx1ZSA9PT0gdm9pZCAwID8gJ3JlbW92ZScgOiAob3B0aW9ucy5pc0FycmF5SW5zZXJ0aW9uID8gJ2luc2VydCcgOiAnbW9kaWZ5Jyl9IEFycmF5IGluZGV4ICR7aW5zZXJ0SW5kZXh9IGFzIGxlbmd0aCBpcyBub3Qgc3VmZmljaWVudGApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbiBub3QgYWRkICR7dHlwZW9mIGxhc3RTZWdtZW50ICE9PSAnbnVtYmVyJyA/ICdpbmRleCcgOiAncHJvcGVydHknfSB0byBwYXJlbnQgb2YgdHlwZSAke3BhcmVudC50eXBlfWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHdpdGhGb3JtYXR0aW5nKHRleHQsIGVkaXQsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMuZm9ybWF0dGluZ09wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIFtlZGl0XTtcbiAgICB9XG4gICAgLy8gYXBwbHkgdGhlIGVkaXRcbiAgICBsZXQgbmV3VGV4dCA9IGFwcGx5RWRpdCh0ZXh0LCBlZGl0KTtcbiAgICAvLyBmb3JtYXQgdGhlIG5ldyB0ZXh0XG4gICAgbGV0IGJlZ2luID0gZWRpdC5vZmZzZXQ7XG4gICAgbGV0IGVuZCA9IGVkaXQub2Zmc2V0ICsgZWRpdC5jb250ZW50Lmxlbmd0aDtcbiAgICBpZiAoZWRpdC5sZW5ndGggPT09IDAgfHwgZWRpdC5jb250ZW50Lmxlbmd0aCA9PT0gMCkgeyAvLyBpbnNlcnQgb3IgcmVtb3ZlXG4gICAgICAgIHdoaWxlIChiZWdpbiA+IDAgJiYgIWlzRU9MKG5ld1RleHQsIGJlZ2luIC0gMSkpIHtcbiAgICAgICAgICAgIGJlZ2luLS07XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGVuZCA8IG5ld1RleHQubGVuZ3RoICYmICFpc0VPTChuZXdUZXh0LCBlbmQpKSB7XG4gICAgICAgICAgICBlbmQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBlZGl0cyA9IGZvcm1hdChuZXdUZXh0LCB7IG9mZnNldDogYmVnaW4sIGxlbmd0aDogZW5kIC0gYmVnaW4gfSwgeyAuLi5vcHRpb25zLmZvcm1hdHRpbmdPcHRpb25zLCBrZWVwTGluZXM6IGZhbHNlIH0pO1xuICAgIC8vIGFwcGx5IHRoZSBmb3JtYXR0aW5nIGVkaXRzIGFuZCB0cmFjayB0aGUgYmVnaW4gYW5kIGVuZCBvZmZzZXRzIG9mIHRoZSBjaGFuZ2VzXG4gICAgZm9yIChsZXQgaSA9IGVkaXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGVkaXQgPSBlZGl0c1tpXTtcbiAgICAgICAgbmV3VGV4dCA9IGFwcGx5RWRpdChuZXdUZXh0LCBlZGl0KTtcbiAgICAgICAgYmVnaW4gPSBNYXRoLm1pbihiZWdpbiwgZWRpdC5vZmZzZXQpO1xuICAgICAgICBlbmQgPSBNYXRoLm1heChlbmQsIGVkaXQub2Zmc2V0ICsgZWRpdC5sZW5ndGgpO1xuICAgICAgICBlbmQgKz0gZWRpdC5jb250ZW50Lmxlbmd0aCAtIGVkaXQubGVuZ3RoO1xuICAgIH1cbiAgICAvLyBjcmVhdGUgYSBzaW5nbGUgZWRpdCB3aXRoIGFsbCBjaGFuZ2VzXG4gICAgY29uc3QgZWRpdExlbmd0aCA9IHRleHQubGVuZ3RoIC0gKG5ld1RleHQubGVuZ3RoIC0gZW5kKSAtIGJlZ2luO1xuICAgIHJldHVybiBbeyBvZmZzZXQ6IGJlZ2luLCBsZW5ndGg6IGVkaXRMZW5ndGgsIGNvbnRlbnQ6IG5ld1RleHQuc3Vic3RyaW5nKGJlZ2luLCBlbmQpIH1dO1xufVxuZnVuY3Rpb24gYXBwbHlFZGl0KHRleHQsIGVkaXQpIHtcbiAgICByZXR1cm4gdGV4dC5zdWJzdHJpbmcoMCwgZWRpdC5vZmZzZXQpICsgZWRpdC5jb250ZW50ICsgdGV4dC5zdWJzdHJpbmcoZWRpdC5vZmZzZXQgKyBlZGl0Lmxlbmd0aCk7XG59XG5mdW5jdGlvbiBpc1dTKHRleHQsIG9mZnNldCkge1xuICAgIHJldHVybiAnXFxyXFxuIFxcdCcuaW5kZXhPZih0ZXh0LmNoYXJBdChvZmZzZXQpKSAhPT0gLTE7XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvanNvbmMtcGFyc2VyL2xpYi9lc20vbWFpbi5qc1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXG5cblxuLyoqXG4gKiBDcmVhdGVzIGEgSlNPTiBzY2FubmVyIG9uIHRoZSBnaXZlbiB0ZXh0LlxuICogSWYgaWdub3JlVHJpdmlhIGlzIHNldCwgd2hpdGVzcGFjZXMgb3IgY29tbWVudHMgYXJlIGlnbm9yZWQuXG4gKi9cbmNvbnN0IG1haW5fY3JlYXRlU2Nhbm5lciA9IGNyZWF0ZVNjYW5uZXI7XG52YXIgU2NhbkVycm9yO1xuKGZ1bmN0aW9uIChTY2FuRXJyb3IpIHtcbiAgICBTY2FuRXJyb3JbU2NhbkVycm9yW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XG4gICAgU2NhbkVycm9yW1NjYW5FcnJvcltcIlVuZXhwZWN0ZWRFbmRPZkNvbW1lbnRcIl0gPSAxXSA9IFwiVW5leHBlY3RlZEVuZE9mQ29tbWVudFwiO1xuICAgIFNjYW5FcnJvcltTY2FuRXJyb3JbXCJVbmV4cGVjdGVkRW5kT2ZTdHJpbmdcIl0gPSAyXSA9IFwiVW5leHBlY3RlZEVuZE9mU3RyaW5nXCI7XG4gICAgU2NhbkVycm9yW1NjYW5FcnJvcltcIlVuZXhwZWN0ZWRFbmRPZk51bWJlclwiXSA9IDNdID0gXCJVbmV4cGVjdGVkRW5kT2ZOdW1iZXJcIjtcbiAgICBTY2FuRXJyb3JbU2NhbkVycm9yW1wiSW52YWxpZFVuaWNvZGVcIl0gPSA0XSA9IFwiSW52YWxpZFVuaWNvZGVcIjtcbiAgICBTY2FuRXJyb3JbU2NhbkVycm9yW1wiSW52YWxpZEVzY2FwZUNoYXJhY3RlclwiXSA9IDVdID0gXCJJbnZhbGlkRXNjYXBlQ2hhcmFjdGVyXCI7XG4gICAgU2NhbkVycm9yW1NjYW5FcnJvcltcIkludmFsaWRDaGFyYWN0ZXJcIl0gPSA2XSA9IFwiSW52YWxpZENoYXJhY3RlclwiO1xufSkoU2NhbkVycm9yIHx8IChTY2FuRXJyb3IgPSB7fSkpO1xudmFyIFN5bnRheEtpbmQ7XG4oZnVuY3Rpb24gKFN5bnRheEtpbmQpIHtcbiAgICBTeW50YXhLaW5kW1N5bnRheEtpbmRbXCJPcGVuQnJhY2VUb2tlblwiXSA9IDFdID0gXCJPcGVuQnJhY2VUb2tlblwiO1xuICAgIFN5bnRheEtpbmRbU3ludGF4S2luZFtcIkNsb3NlQnJhY2VUb2tlblwiXSA9IDJdID0gXCJDbG9zZUJyYWNlVG9rZW5cIjtcbiAgICBTeW50YXhLaW5kW1N5bnRheEtpbmRbXCJPcGVuQnJhY2tldFRva2VuXCJdID0gM10gPSBcIk9wZW5CcmFja2V0VG9rZW5cIjtcbiAgICBTeW50YXhLaW5kW1N5bnRheEtpbmRbXCJDbG9zZUJyYWNrZXRUb2tlblwiXSA9IDRdID0gXCJDbG9zZUJyYWNrZXRUb2tlblwiO1xuICAgIFN5bnRheEtpbmRbU3ludGF4S2luZFtcIkNvbW1hVG9rZW5cIl0gPSA1XSA9IFwiQ29tbWFUb2tlblwiO1xuICAgIFN5bnRheEtpbmRbU3ludGF4S2luZFtcIkNvbG9uVG9rZW5cIl0gPSA2XSA9IFwiQ29sb25Ub2tlblwiO1xuICAgIFN5bnRheEtpbmRbU3ludGF4S2luZFtcIk51bGxLZXl3b3JkXCJdID0gN10gPSBcIk51bGxLZXl3b3JkXCI7XG4gICAgU3ludGF4S2luZFtTeW50YXhLaW5kW1wiVHJ1ZUtleXdvcmRcIl0gPSA4XSA9IFwiVHJ1ZUtleXdvcmRcIjtcbiAgICBTeW50YXhLaW5kW1N5bnRheEtpbmRbXCJGYWxzZUtleXdvcmRcIl0gPSA5XSA9IFwiRmFsc2VLZXl3b3JkXCI7XG4gICAgU3ludGF4S2luZFtTeW50YXhLaW5kW1wiU3RyaW5nTGl0ZXJhbFwiXSA9IDEwXSA9IFwiU3RyaW5nTGl0ZXJhbFwiO1xuICAgIFN5bnRheEtpbmRbU3ludGF4S2luZFtcIk51bWVyaWNMaXRlcmFsXCJdID0gMTFdID0gXCJOdW1lcmljTGl0ZXJhbFwiO1xuICAgIFN5bnRheEtpbmRbU3ludGF4S2luZFtcIkxpbmVDb21tZW50VHJpdmlhXCJdID0gMTJdID0gXCJMaW5lQ29tbWVudFRyaXZpYVwiO1xuICAgIFN5bnRheEtpbmRbU3ludGF4S2luZFtcIkJsb2NrQ29tbWVudFRyaXZpYVwiXSA9IDEzXSA9IFwiQmxvY2tDb21tZW50VHJpdmlhXCI7XG4gICAgU3ludGF4S2luZFtTeW50YXhLaW5kW1wiTGluZUJyZWFrVHJpdmlhXCJdID0gMTRdID0gXCJMaW5lQnJlYWtUcml2aWFcIjtcbiAgICBTeW50YXhLaW5kW1N5bnRheEtpbmRbXCJUcml2aWFcIl0gPSAxNV0gPSBcIlRyaXZpYVwiO1xuICAgIFN5bnRheEtpbmRbU3ludGF4S2luZFtcIlVua25vd25cIl0gPSAxNl0gPSBcIlVua25vd25cIjtcbiAgICBTeW50YXhLaW5kW1N5bnRheEtpbmRbXCJFT0ZcIl0gPSAxN10gPSBcIkVPRlwiO1xufSkoU3ludGF4S2luZCB8fCAoU3ludGF4S2luZCA9IHt9KSk7XG4vKipcbiAqIEZvciBhIGdpdmVuIG9mZnNldCwgZXZhbHVhdGUgdGhlIGxvY2F0aW9uIGluIHRoZSBKU09OIGRvY3VtZW50LiBFYWNoIHNlZ21lbnQgaW4gdGhlIGxvY2F0aW9uIHBhdGggaXMgZWl0aGVyIGEgcHJvcGVydHkgbmFtZSBvciBhbiBhcnJheSBpbmRleC5cbiAqL1xuY29uc3QgbWFpbl9nZXRMb2NhdGlvbiA9IGdldExvY2F0aW9uO1xuLyoqXG4gKiBQYXJzZXMgdGhlIGdpdmVuIHRleHQgYW5kIHJldHVybnMgdGhlIG9iamVjdCB0aGUgSlNPTiBjb250ZW50IHJlcHJlc2VudHMuIE9uIGludmFsaWQgaW5wdXQsIHRoZSBwYXJzZXIgdHJpZXMgdG8gYmUgYXMgZmF1bHQgdG9sZXJhbnQgYXMgcG9zc2libGUsIGJ1dCBzdGlsbCByZXR1cm4gYSByZXN1bHQuXG4gKiBUaGVyZWZvcmUsIGFsd2F5cyBjaGVjayB0aGUgZXJyb3JzIGxpc3QgdG8gZmluZCBvdXQgaWYgdGhlIGlucHV0IHdhcyB2YWxpZC5cbiAqL1xuY29uc3QgbWFpbl9wYXJzZSA9IHBhcnNlO1xuLyoqXG4gKiBQYXJzZXMgdGhlIGdpdmVuIHRleHQgYW5kIHJldHVybnMgYSB0cmVlIHJlcHJlc2VudGF0aW9uIHRoZSBKU09OIGNvbnRlbnQuIE9uIGludmFsaWQgaW5wdXQsIHRoZSBwYXJzZXIgdHJpZXMgdG8gYmUgYXMgZmF1bHQgdG9sZXJhbnQgYXMgcG9zc2libGUsIGJ1dCBzdGlsbCByZXR1cm4gYSByZXN1bHQuXG4gKi9cbmNvbnN0IG1haW5fcGFyc2VUcmVlID0gcGFyc2VyX3BhcnNlVHJlZTtcbi8qKlxuICogRmluZHMgdGhlIG5vZGUgYXQgdGhlIGdpdmVuIHBhdGggaW4gYSBKU09OIERPTS5cbiAqL1xuY29uc3QgbWFpbl9maW5kTm9kZUF0TG9jYXRpb24gPSBwYXJzZXJfZmluZE5vZGVBdExvY2F0aW9uO1xuLyoqXG4gKiBGaW5kcyB0aGUgaW5uZXJtb3N0IG5vZGUgYXQgdGhlIGdpdmVuIG9mZnNldC4gSWYgaW5jbHVkZVJpZ2h0Qm91bmQgaXMgc2V0LCBhbHNvIGZpbmRzIG5vZGVzIHRoYXQgZW5kIGF0IHRoZSBnaXZlbiBvZmZzZXQuXG4gKi9cbmNvbnN0IG1haW5fZmluZE5vZGVBdE9mZnNldCA9IGZpbmROb2RlQXRPZmZzZXQ7XG4vKipcbiAqIEdldHMgdGhlIEpTT04gcGF0aCBvZiB0aGUgZ2l2ZW4gSlNPTiBET00gbm9kZVxuICovXG5jb25zdCBtYWluX2dldE5vZGVQYXRoID0gZ2V0Tm9kZVBhdGg7XG4vKipcbiAqIEV2YWx1YXRlcyB0aGUgSmF2YVNjcmlwdCBvYmplY3Qgb2YgdGhlIGdpdmVuIEpTT04gRE9NIG5vZGVcbiAqL1xuY29uc3QgbWFpbl9nZXROb2RlVmFsdWUgPSBnZXROb2RlVmFsdWU7XG4vKipcbiAqIFBhcnNlcyB0aGUgZ2l2ZW4gdGV4dCBhbmQgaW52b2tlcyB0aGUgdmlzaXRvciBmdW5jdGlvbnMgZm9yIGVhY2ggb2JqZWN0LCBhcnJheSBhbmQgbGl0ZXJhbCByZWFjaGVkLlxuICovXG5jb25zdCBtYWluX3Zpc2l0ID0gdmlzaXQ7XG4vKipcbiAqIFRha2VzIEpTT04gd2l0aCBKYXZhU2NyaXB0LXN0eWxlIGNvbW1lbnRzIGFuZCByZW1vdmVcbiAqIHRoZW0uIE9wdGlvbmFsbHkgcmVwbGFjZXMgZXZlcnkgbm9uZS1uZXdsaW5lIGNoYXJhY3RlclxuICogb2YgY29tbWVudHMgd2l0aCBhIHJlcGxhY2VDaGFyYWN0ZXJcbiAqL1xuY29uc3QgbWFpbl9zdHJpcENvbW1lbnRzID0gc3RyaXBDb21tZW50cztcbnZhciBQYXJzZUVycm9yQ29kZTtcbihmdW5jdGlvbiAoUGFyc2VFcnJvckNvZGUpIHtcbiAgICBQYXJzZUVycm9yQ29kZVtQYXJzZUVycm9yQ29kZVtcIkludmFsaWRTeW1ib2xcIl0gPSAxXSA9IFwiSW52YWxpZFN5bWJvbFwiO1xuICAgIFBhcnNlRXJyb3JDb2RlW1BhcnNlRXJyb3JDb2RlW1wiSW52YWxpZE51bWJlckZvcm1hdFwiXSA9IDJdID0gXCJJbnZhbGlkTnVtYmVyRm9ybWF0XCI7XG4gICAgUGFyc2VFcnJvckNvZGVbUGFyc2VFcnJvckNvZGVbXCJQcm9wZXJ0eU5hbWVFeHBlY3RlZFwiXSA9IDNdID0gXCJQcm9wZXJ0eU5hbWVFeHBlY3RlZFwiO1xuICAgIFBhcnNlRXJyb3JDb2RlW1BhcnNlRXJyb3JDb2RlW1wiVmFsdWVFeHBlY3RlZFwiXSA9IDRdID0gXCJWYWx1ZUV4cGVjdGVkXCI7XG4gICAgUGFyc2VFcnJvckNvZGVbUGFyc2VFcnJvckNvZGVbXCJDb2xvbkV4cGVjdGVkXCJdID0gNV0gPSBcIkNvbG9uRXhwZWN0ZWRcIjtcbiAgICBQYXJzZUVycm9yQ29kZVtQYXJzZUVycm9yQ29kZVtcIkNvbW1hRXhwZWN0ZWRcIl0gPSA2XSA9IFwiQ29tbWFFeHBlY3RlZFwiO1xuICAgIFBhcnNlRXJyb3JDb2RlW1BhcnNlRXJyb3JDb2RlW1wiQ2xvc2VCcmFjZUV4cGVjdGVkXCJdID0gN10gPSBcIkNsb3NlQnJhY2VFeHBlY3RlZFwiO1xuICAgIFBhcnNlRXJyb3JDb2RlW1BhcnNlRXJyb3JDb2RlW1wiQ2xvc2VCcmFja2V0RXhwZWN0ZWRcIl0gPSA4XSA9IFwiQ2xvc2VCcmFja2V0RXhwZWN0ZWRcIjtcbiAgICBQYXJzZUVycm9yQ29kZVtQYXJzZUVycm9yQ29kZVtcIkVuZE9mRmlsZUV4cGVjdGVkXCJdID0gOV0gPSBcIkVuZE9mRmlsZUV4cGVjdGVkXCI7XG4gICAgUGFyc2VFcnJvckNvZGVbUGFyc2VFcnJvckNvZGVbXCJJbnZhbGlkQ29tbWVudFRva2VuXCJdID0gMTBdID0gXCJJbnZhbGlkQ29tbWVudFRva2VuXCI7XG4gICAgUGFyc2VFcnJvckNvZGVbUGFyc2VFcnJvckNvZGVbXCJVbmV4cGVjdGVkRW5kT2ZDb21tZW50XCJdID0gMTFdID0gXCJVbmV4cGVjdGVkRW5kT2ZDb21tZW50XCI7XG4gICAgUGFyc2VFcnJvckNvZGVbUGFyc2VFcnJvckNvZGVbXCJVbmV4cGVjdGVkRW5kT2ZTdHJpbmdcIl0gPSAxMl0gPSBcIlVuZXhwZWN0ZWRFbmRPZlN0cmluZ1wiO1xuICAgIFBhcnNlRXJyb3JDb2RlW1BhcnNlRXJyb3JDb2RlW1wiVW5leHBlY3RlZEVuZE9mTnVtYmVyXCJdID0gMTNdID0gXCJVbmV4cGVjdGVkRW5kT2ZOdW1iZXJcIjtcbiAgICBQYXJzZUVycm9yQ29kZVtQYXJzZUVycm9yQ29kZVtcIkludmFsaWRVbmljb2RlXCJdID0gMTRdID0gXCJJbnZhbGlkVW5pY29kZVwiO1xuICAgIFBhcnNlRXJyb3JDb2RlW1BhcnNlRXJyb3JDb2RlW1wiSW52YWxpZEVzY2FwZUNoYXJhY3RlclwiXSA9IDE1XSA9IFwiSW52YWxpZEVzY2FwZUNoYXJhY3RlclwiO1xuICAgIFBhcnNlRXJyb3JDb2RlW1BhcnNlRXJyb3JDb2RlW1wiSW52YWxpZENoYXJhY3RlclwiXSA9IDE2XSA9IFwiSW52YWxpZENoYXJhY3RlclwiO1xufSkoUGFyc2VFcnJvckNvZGUgfHwgKFBhcnNlRXJyb3JDb2RlID0ge30pKTtcbmZ1bmN0aW9uIHByaW50UGFyc2VFcnJvckNvZGUoY29kZSkge1xuICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICBjYXNlIDEgLyogUGFyc2VFcnJvckNvZGUuSW52YWxpZFN5bWJvbCAqLzogcmV0dXJuICdJbnZhbGlkU3ltYm9sJztcbiAgICAgICAgY2FzZSAyIC8qIFBhcnNlRXJyb3JDb2RlLkludmFsaWROdW1iZXJGb3JtYXQgKi86IHJldHVybiAnSW52YWxpZE51bWJlckZvcm1hdCc7XG4gICAgICAgIGNhc2UgMyAvKiBQYXJzZUVycm9yQ29kZS5Qcm9wZXJ0eU5hbWVFeHBlY3RlZCAqLzogcmV0dXJuICdQcm9wZXJ0eU5hbWVFeHBlY3RlZCc7XG4gICAgICAgIGNhc2UgNCAvKiBQYXJzZUVycm9yQ29kZS5WYWx1ZUV4cGVjdGVkICovOiByZXR1cm4gJ1ZhbHVlRXhwZWN0ZWQnO1xuICAgICAgICBjYXNlIDUgLyogUGFyc2VFcnJvckNvZGUuQ29sb25FeHBlY3RlZCAqLzogcmV0dXJuICdDb2xvbkV4cGVjdGVkJztcbiAgICAgICAgY2FzZSA2IC8qIFBhcnNlRXJyb3JDb2RlLkNvbW1hRXhwZWN0ZWQgKi86IHJldHVybiAnQ29tbWFFeHBlY3RlZCc7XG4gICAgICAgIGNhc2UgNyAvKiBQYXJzZUVycm9yQ29kZS5DbG9zZUJyYWNlRXhwZWN0ZWQgKi86IHJldHVybiAnQ2xvc2VCcmFjZUV4cGVjdGVkJztcbiAgICAgICAgY2FzZSA4IC8qIFBhcnNlRXJyb3JDb2RlLkNsb3NlQnJhY2tldEV4cGVjdGVkICovOiByZXR1cm4gJ0Nsb3NlQnJhY2tldEV4cGVjdGVkJztcbiAgICAgICAgY2FzZSA5IC8qIFBhcnNlRXJyb3JDb2RlLkVuZE9mRmlsZUV4cGVjdGVkICovOiByZXR1cm4gJ0VuZE9mRmlsZUV4cGVjdGVkJztcbiAgICAgICAgY2FzZSAxMCAvKiBQYXJzZUVycm9yQ29kZS5JbnZhbGlkQ29tbWVudFRva2VuICovOiByZXR1cm4gJ0ludmFsaWRDb21tZW50VG9rZW4nO1xuICAgICAgICBjYXNlIDExIC8qIFBhcnNlRXJyb3JDb2RlLlVuZXhwZWN0ZWRFbmRPZkNvbW1lbnQgKi86IHJldHVybiAnVW5leHBlY3RlZEVuZE9mQ29tbWVudCc7XG4gICAgICAgIGNhc2UgMTIgLyogUGFyc2VFcnJvckNvZGUuVW5leHBlY3RlZEVuZE9mU3RyaW5nICovOiByZXR1cm4gJ1VuZXhwZWN0ZWRFbmRPZlN0cmluZyc7XG4gICAgICAgIGNhc2UgMTMgLyogUGFyc2VFcnJvckNvZGUuVW5leHBlY3RlZEVuZE9mTnVtYmVyICovOiByZXR1cm4gJ1VuZXhwZWN0ZWRFbmRPZk51bWJlcic7XG4gICAgICAgIGNhc2UgMTQgLyogUGFyc2VFcnJvckNvZGUuSW52YWxpZFVuaWNvZGUgKi86IHJldHVybiAnSW52YWxpZFVuaWNvZGUnO1xuICAgICAgICBjYXNlIDE1IC8qIFBhcnNlRXJyb3JDb2RlLkludmFsaWRFc2NhcGVDaGFyYWN0ZXIgKi86IHJldHVybiAnSW52YWxpZEVzY2FwZUNoYXJhY3Rlcic7XG4gICAgICAgIGNhc2UgMTYgLyogUGFyc2VFcnJvckNvZGUuSW52YWxpZENoYXJhY3RlciAqLzogcmV0dXJuICdJbnZhbGlkQ2hhcmFjdGVyJztcbiAgICB9XG4gICAgcmV0dXJuICc8dW5rbm93biBQYXJzZUVycm9yQ29kZT4nO1xufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgZWRpdCBvcGVyYXRpb25zIG5lZWRlZCB0byBmb3JtYXQgYSBKU09OIGRvY3VtZW50LlxuICpcbiAqIEBwYXJhbSBkb2N1bWVudFRleHQgVGhlIGlucHV0IHRleHRcbiAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2UgdG8gZm9ybWF0IG9yIGB1bmRlZmluZWRgIHRvIGZvcm1hdCB0aGUgZnVsbCBjb250ZW50XG4gKiBAcGFyYW0gb3B0aW9ucyBUaGUgZm9ybWF0dGluZyBvcHRpb25zXG4gKiBAcmV0dXJucyBUaGUgZWRpdCBvcGVyYXRpb25zIGRlc2NyaWJpbmcgdGhlIGZvcm1hdHRpbmcgY2hhbmdlcyB0byB0aGUgb3JpZ2luYWwgZG9jdW1lbnQgZm9sbG93aW5nIHRoZSBmb3JtYXQgZGVzY3JpYmVkIGluIHtAbGlua2NvZGUgRWRpdFJlc3VsdH0uXG4gKiBUbyBhcHBseSB0aGUgZWRpdCBvcGVyYXRpb25zIHRvIHRoZSBpbnB1dCwgdXNlIHtAbGlua2NvZGUgYXBwbHlFZGl0c30uXG4gKi9cbmZ1bmN0aW9uIG1haW5fZm9ybWF0KGRvY3VtZW50VGV4dCwgcmFuZ2UsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZm9ybWF0X2Zvcm1hdChkb2N1bWVudFRleHQsIHJhbmdlLCBvcHRpb25zKTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGVkaXQgb3BlcmF0aW9ucyBuZWVkZWQgdG8gbW9kaWZ5IGEgdmFsdWUgaW4gdGhlIEpTT04gZG9jdW1lbnQuXG4gKlxuICogQHBhcmFtIGRvY3VtZW50VGV4dCBUaGUgaW5wdXQgdGV4dFxuICogQHBhcmFtIHBhdGggVGhlIHBhdGggb2YgdGhlIHZhbHVlIHRvIGNoYW5nZS4gVGhlIHBhdGggcmVwcmVzZW50cyBlaXRoZXIgdG8gdGhlIGRvY3VtZW50IHJvb3QsIGEgcHJvcGVydHkgb3IgYW4gYXJyYXkgaXRlbS5cbiAqIElmIHRoZSBwYXRoIHBvaW50cyB0byBhbiBub24tZXhpc3RpbmcgcHJvcGVydHkgb3IgaXRlbSwgaXQgd2lsbCBiZSBjcmVhdGVkLlxuICogQHBhcmFtIHZhbHVlIFRoZSBuZXcgdmFsdWUgZm9yIHRoZSBzcGVjaWZpZWQgcHJvcGVydHkgb3IgaXRlbS4gSWYgdGhlIHZhbHVlIGlzIHVuZGVmaW5lZCxcbiAqIHRoZSBwcm9wZXJ0eSBvciBpdGVtIHdpbGwgYmUgcmVtb3ZlZC5cbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnNcbiAqIEByZXR1cm5zIFRoZSBlZGl0IG9wZXJhdGlvbnMgZGVzY3JpYmluZyB0aGUgY2hhbmdlcyB0byB0aGUgb3JpZ2luYWwgZG9jdW1lbnQsIGZvbGxvd2luZyB0aGUgZm9ybWF0IGRlc2NyaWJlZCBpbiB7QGxpbmtjb2RlIEVkaXRSZXN1bHR9LlxuICogVG8gYXBwbHkgdGhlIGVkaXQgb3BlcmF0aW9ucyB0byB0aGUgaW5wdXQsIHVzZSB7QGxpbmtjb2RlIGFwcGx5RWRpdHN9LlxuICovXG5mdW5jdGlvbiBtb2RpZnkodGV4dCwgcGF0aCwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZWRpdC5zZXRQcm9wZXJ0eSh0ZXh0LCBwYXRoLCB2YWx1ZSwgb3B0aW9ucyk7XG59XG4vKipcbiAqIEFwcGxpZXMgZWRpdHMgdG8gYW4gaW5wdXQgc3RyaW5nLlxuICogQHBhcmFtIHRleHQgVGhlIGlucHV0IHRleHRcbiAqIEBwYXJhbSBlZGl0cyBFZGl0IG9wZXJhdGlvbnMgZm9sbG93aW5nIHRoZSBmb3JtYXQgZGVzY3JpYmVkIGluIHtAbGlua2NvZGUgRWRpdFJlc3VsdH0uXG4gKiBAcmV0dXJucyBUaGUgdGV4dCB3aXRoIHRoZSBhcHBsaWVkIGVkaXRzLlxuICogQHRocm93cyBBbiBlcnJvciBpZiB0aGUgZWRpdCBvcGVyYXRpb25zIGFyZSBub3Qgd2VsbC1mb3JtZWQgYXMgZGVzY3JpYmVkIGluIHtAbGlua2NvZGUgRWRpdFJlc3VsdH0uXG4gKi9cbmZ1bmN0aW9uIGFwcGx5RWRpdHModGV4dCwgZWRpdHMpIHtcbiAgICBsZXQgc29ydGVkRWRpdHMgPSBlZGl0cy5zbGljZSgwKS5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgIGNvbnN0IGRpZmYgPSBhLm9mZnNldCAtIGIub2Zmc2V0O1xuICAgICAgICBpZiAoZGlmZiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGEubGVuZ3RoIC0gYi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgfSk7XG4gICAgbGV0IGxhc3RNb2RpZmllZE9mZnNldCA9IHRleHQubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSBzb3J0ZWRFZGl0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsZXQgZSA9IHNvcnRlZEVkaXRzW2ldO1xuICAgICAgICBpZiAoZS5vZmZzZXQgKyBlLmxlbmd0aCA8PSBsYXN0TW9kaWZpZWRPZmZzZXQpIHtcbiAgICAgICAgICAgIHRleHQgPSBlZGl0LmFwcGx5RWRpdCh0ZXh0LCBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3ZlcmxhcHBpbmcgZWRpdCcpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RNb2RpZmllZE9mZnNldCA9IGUub2Zmc2V0O1xuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy92c2NvZGUtanNvbi1sYW5ndWFnZXNlcnZpY2UvbGliL2VzbS91dGlscy9vYmplY3RzLmpzXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmZ1bmN0aW9uIGVxdWFscyhvbmUsIG90aGVyKSB7XG4gICAgaWYgKG9uZSA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChvbmUgPT09IG51bGwgfHwgb25lID09PSB1bmRlZmluZWQgfHwgb3RoZXIgPT09IG51bGwgfHwgb3RoZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb25lICE9PSB0eXBlb2Ygb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9uZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoKEFycmF5LmlzQXJyYXkob25lKSkgIT09IChBcnJheS5pc0FycmF5KG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgaSwga2V5O1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9uZSkpIHtcbiAgICAgICAgaWYgKG9uZS5sZW5ndGggIT09IG90aGVyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghZXF1YWxzKG9uZVtpXSwgb3RoZXJbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBvbmVLZXlzID0gW107XG4gICAgICAgIGZvciAoa2V5IGluIG9uZSkge1xuICAgICAgICAgICAgb25lS2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgb25lS2V5cy5zb3J0KCk7XG4gICAgICAgIGNvbnN0IG90aGVyS2V5cyA9IFtdO1xuICAgICAgICBmb3IgKGtleSBpbiBvdGhlcikge1xuICAgICAgICAgICAgb3RoZXJLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBvdGhlcktleXMuc29ydCgpO1xuICAgICAgICBpZiAoIWVxdWFscyhvbmVLZXlzLCBvdGhlcktleXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9uZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghZXF1YWxzKG9uZVtvbmVLZXlzW2ldXSwgb3RoZXJbb25lS2V5c1tpXV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gaXNOdW1iZXIodmFsKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInO1xufVxuZnVuY3Rpb24gaXNEZWZpbmVkKHZhbCkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsICE9PSAndW5kZWZpbmVkJztcbn1cbmZ1bmN0aW9uIGlzQm9vbGVhbih2YWwpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nO1xufVxuZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnO1xufVxuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheSh2YWwpO1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3ZzY29kZS1qc29uLWxhbmd1YWdlc2VydmljZS9saWIvZXNtL3V0aWxzL3N0cmluZ3MuanNcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZnVuY3Rpb24gc3RhcnRzV2l0aChoYXlzdGFjaywgbmVlZGxlKSB7XG4gICAgaWYgKGhheXN0YWNrLmxlbmd0aCA8IG5lZWRsZS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5lZWRsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaGF5c3RhY2tbaV0gIT09IG5lZWRsZVtpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGhheXN0YWNrIGVuZHMgd2l0aCBuZWVkbGUuXG4gKi9cbmZ1bmN0aW9uIGVuZHNXaXRoKGhheXN0YWNrLCBuZWVkbGUpIHtcbiAgICBjb25zdCBkaWZmID0gaGF5c3RhY2subGVuZ3RoIC0gbmVlZGxlLmxlbmd0aDtcbiAgICBpZiAoZGlmZiA+IDApIHtcbiAgICAgICAgcmV0dXJuIGhheXN0YWNrLmxhc3RJbmRleE9mKG5lZWRsZSkgPT09IGRpZmY7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRpZmYgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGhheXN0YWNrID09PSBuZWVkbGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gY29udmVydFNpbXBsZTJSZWdFeHBQYXR0ZXJuKHBhdHRlcm4pIHtcbiAgICByZXR1cm4gcGF0dGVybi5yZXBsYWNlKC9bXFwtXFxcXFxce1xcfVxcK1xcP1xcfFxcXlxcJFxcLlxcLFxcW1xcXVxcKFxcKVxcI1xcc10vZywgJ1xcXFwkJicpLnJlcGxhY2UoL1tcXCpdL2csICcuKicpO1xufVxuZnVuY3Rpb24gc3RyaW5nc19yZXBlYXQodmFsdWUsIGNvdW50KSB7XG4gICAgbGV0IHMgPSAnJztcbiAgICB3aGlsZSAoY291bnQgPiAwKSB7XG4gICAgICAgIGlmICgoY291bnQgJiAxKSA9PT0gMSkge1xuICAgICAgICAgICAgcyArPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSArPSB2YWx1ZTtcbiAgICAgICAgY291bnQgPSBjb3VudCA+Pj4gMTtcbiAgICB9XG4gICAgcmV0dXJuIHM7XG59XG5mdW5jdGlvbiBleHRlbmRlZFJlZ0V4cChwYXR0ZXJuKSB7XG4gICAgbGV0IGZsYWdzID0gJyc7XG4gICAgaWYgKHN0YXJ0c1dpdGgocGF0dGVybiwgJyg/aSknKSkge1xuICAgICAgICBwYXR0ZXJuID0gcGF0dGVybi5zdWJzdHJpbmcoNCk7XG4gICAgICAgIGZsYWdzID0gJ2knO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuLCBmbGFncyArICd1Jyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGNvdWxkIGJlIGFuIGV4Y2VwdGlvbiBkdWUgdG8gdGhlICd1ICcgZmxhZ1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocGF0dGVybiwgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBpbnZhbGlkIHBhdHRlcm5cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBmcm9tIGh0dHBzOi8vdGFuaXNoaWtpbmcuZ2l0aHViLmlvL3Bvc3RzL2NvdW50LXVuaWNvZGUtY29kZXBvaW50LyN3b3JrLWhhcmQtd2l0aC1mb3Itc3RhdGVtZW50c1xuZnVuY3Rpb24gc3RyaW5nTGVuZ3RoKHN0cikge1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY291bnQrKztcbiAgICAgICAgLy8gb2J0YWluIHRoZSBpLXRoIDE2LWJpdFxuICAgICAgICBjb25zdCBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmICgweEQ4MDAgPD0gY29kZSAmJiBjb2RlIDw9IDB4REJGRikge1xuICAgICAgICAgICAgLy8gaWYgdGhlIGktdGggMTZiaXQgaXMgYW4gdXBwZXIgc3Vycm9nYXRlXG4gICAgICAgICAgICAvLyBza2lwIHRoZSBuZXh0IDE2IGJpdHMgKGxvd2VyIHN1cnJvZ2F0ZSlcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY291bnQ7XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL25vZGVfbW9kdWxlcy92c2NvZGUtbGFuZ3VhZ2VzZXJ2ZXItdHlwZXMvbGliL2VzbS9tYWluLmpzXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbnZhciBEb2N1bWVudFVyaTtcbihmdW5jdGlvbiAoRG9jdW1lbnRVcmkpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbiAgICB9XG4gICAgRG9jdW1lbnRVcmkuaXMgPSBpcztcbn0pKERvY3VtZW50VXJpIHx8IChEb2N1bWVudFVyaSA9IHt9KSk7XG52YXIganNvbl9zZXJ2aWNlX1VSSTtcbihmdW5jdGlvbiAoVVJJKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gICAgfVxuICAgIFVSSS5pcyA9IGlzO1xufSkoanNvbl9zZXJ2aWNlX1VSSSB8fCAoanNvbl9zZXJ2aWNlX1VSSSA9IHt9KSk7XG52YXIgaW50ZWdlcjtcbihmdW5jdGlvbiAoaW50ZWdlcikge1xuICAgIGludGVnZXIuTUlOX1ZBTFVFID0gLTIxNDc0ODM2NDg7XG4gICAgaW50ZWdlci5NQVhfVkFMVUUgPSAyMTQ3NDgzNjQ3O1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGludGVnZXIuTUlOX1ZBTFVFIDw9IHZhbHVlICYmIHZhbHVlIDw9IGludGVnZXIuTUFYX1ZBTFVFO1xuICAgIH1cbiAgICBpbnRlZ2VyLmlzID0gaXM7XG59KShpbnRlZ2VyIHx8IChpbnRlZ2VyID0ge30pKTtcbnZhciB1aW50ZWdlcjtcbihmdW5jdGlvbiAodWludGVnZXIpIHtcbiAgICB1aW50ZWdlci5NSU5fVkFMVUUgPSAwO1xuICAgIHVpbnRlZ2VyLk1BWF9WQUxVRSA9IDIxNDc0ODM2NDc7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdWludGVnZXIuTUlOX1ZBTFVFIDw9IHZhbHVlICYmIHZhbHVlIDw9IHVpbnRlZ2VyLk1BWF9WQUxVRTtcbiAgICB9XG4gICAgdWludGVnZXIuaXMgPSBpcztcbn0pKHVpbnRlZ2VyIHx8ICh1aW50ZWdlciA9IHt9KSk7XG4vKipcbiAqIFRoZSBQb3NpdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBQb3NpdGlvbn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBQb3NpdGlvbjtcbihmdW5jdGlvbiAoUG9zaXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFBvc2l0aW9uIGxpdGVyYWwgZnJvbSB0aGUgZ2l2ZW4gbGluZSBhbmQgY2hhcmFjdGVyLlxuICAgICAqIEBwYXJhbSBsaW5lIFRoZSBwb3NpdGlvbidzIGxpbmUuXG4gICAgICogQHBhcmFtIGNoYXJhY3RlciBUaGUgcG9zaXRpb24ncyBjaGFyYWN0ZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKGxpbmUsIGNoYXJhY3Rlcikge1xuICAgICAgICBpZiAobGluZSA9PT0gTnVtYmVyLk1BWF9WQUxVRSkge1xuICAgICAgICAgICAgbGluZSA9IHVpbnRlZ2VyLk1BWF9WQUxVRTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhcmFjdGVyID09PSBOdW1iZXIuTUFYX1ZBTFVFKSB7XG4gICAgICAgICAgICBjaGFyYWN0ZXIgPSB1aW50ZWdlci5NQVhfVkFMVUU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbGluZSwgY2hhcmFjdGVyIH07XG4gICAgfVxuICAgIFBvc2l0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIFBvc2l0aW9ufSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5saW5lKSAmJiBJcy51aW50ZWdlcihjYW5kaWRhdGUuY2hhcmFjdGVyKTtcbiAgICB9XG4gICAgUG9zaXRpb24uaXMgPSBpcztcbn0pKFBvc2l0aW9uIHx8IChQb3NpdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBSYW5nZSBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBSYW5nZX0gbGl0ZXJhbHMuXG4gKi9cbnZhciBSYW5nZTtcbihmdW5jdGlvbiAoUmFuZ2UpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUob25lLCB0d28sIHRocmVlLCBmb3VyKSB7XG4gICAgICAgIGlmIChJcy51aW50ZWdlcihvbmUpICYmIElzLnVpbnRlZ2VyKHR3bykgJiYgSXMudWludGVnZXIodGhyZWUpICYmIElzLnVpbnRlZ2VyKGZvdXIpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdGFydDogUG9zaXRpb24uY3JlYXRlKG9uZSwgdHdvKSwgZW5kOiBQb3NpdGlvbi5jcmVhdGUodGhyZWUsIGZvdXIpIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoUG9zaXRpb24uaXMob25lKSAmJiBQb3NpdGlvbi5pcyh0d28pKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdGFydDogb25lLCBlbmQ6IHR3byB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSYW5nZSNjcmVhdGUgY2FsbGVkIHdpdGggaW52YWxpZCBhcmd1bWVudHNbJHtvbmV9LCAke3R3b30sICR7dGhyZWV9LCAke2ZvdXJ9XWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIFJhbmdlLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIFJhbmdlfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIFBvc2l0aW9uLmlzKGNhbmRpZGF0ZS5zdGFydCkgJiYgUG9zaXRpb24uaXMoY2FuZGlkYXRlLmVuZCk7XG4gICAgfVxuICAgIFJhbmdlLmlzID0gaXM7XG59KShSYW5nZSB8fCAoUmFuZ2UgPSB7fSkpO1xuLyoqXG4gKiBUaGUgTG9jYXRpb24gbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgTG9jYXRpb259IGxpdGVyYWxzLlxuICovXG52YXIgTG9jYXRpb247XG4oZnVuY3Rpb24gKExvY2F0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIExvY2F0aW9uIGxpdGVyYWwuXG4gICAgICogQHBhcmFtIHVyaSBUaGUgbG9jYXRpb24ncyB1cmkuXG4gICAgICogQHBhcmFtIHJhbmdlIFRoZSBsb2NhdGlvbidzIHJhbmdlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIHJhbmdlKSB7XG4gICAgICAgIHJldHVybiB7IHVyaSwgcmFuZ2UgfTtcbiAgICB9XG4gICAgTG9jYXRpb24uY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgTG9jYXRpb259IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiAoSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpIHx8IElzLnVuZGVmaW5lZChjYW5kaWRhdGUudXJpKSk7XG4gICAgfVxuICAgIExvY2F0aW9uLmlzID0gaXM7XG59KShMb2NhdGlvbiB8fCAoTG9jYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgTG9jYXRpb25MaW5rIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIExvY2F0aW9uTGlua30gbGl0ZXJhbHMuXG4gKi9cbnZhciBMb2NhdGlvbkxpbms7XG4oZnVuY3Rpb24gKExvY2F0aW9uTGluaykge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBMb2NhdGlvbkxpbmsgbGl0ZXJhbC5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0VXJpIFRoZSBkZWZpbml0aW9uJ3MgdXJpLlxuICAgICAqIEBwYXJhbSB0YXJnZXRSYW5nZSBUaGUgZnVsbCByYW5nZSBvZiB0aGUgZGVmaW5pdGlvbi5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0U2VsZWN0aW9uUmFuZ2UgVGhlIHNwYW4gb2YgdGhlIHN5bWJvbCBkZWZpbml0aW9uIGF0IHRoZSB0YXJnZXQuXG4gICAgICogQHBhcmFtIG9yaWdpblNlbGVjdGlvblJhbmdlIFRoZSBzcGFuIG9mIHRoZSBzeW1ib2wgYmVpbmcgZGVmaW5lZCBpbiB0aGUgb3JpZ2luYXRpbmcgc291cmNlIGZpbGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHRhcmdldFVyaSwgdGFyZ2V0UmFuZ2UsIHRhcmdldFNlbGVjdGlvblJhbmdlLCBvcmlnaW5TZWxlY3Rpb25SYW5nZSkge1xuICAgICAgICByZXR1cm4geyB0YXJnZXRVcmksIHRhcmdldFJhbmdlLCB0YXJnZXRTZWxlY3Rpb25SYW5nZSwgb3JpZ2luU2VsZWN0aW9uUmFuZ2UgfTtcbiAgICB9XG4gICAgTG9jYXRpb25MaW5rLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIExvY2F0aW9uTGlua30gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUudGFyZ2V0UmFuZ2UpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudGFyZ2V0VXJpKVxuICAgICAgICAgICAgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnRhcmdldFNlbGVjdGlvblJhbmdlKVxuICAgICAgICAgICAgJiYgKFJhbmdlLmlzKGNhbmRpZGF0ZS5vcmlnaW5TZWxlY3Rpb25SYW5nZSkgfHwgSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5vcmlnaW5TZWxlY3Rpb25SYW5nZSkpO1xuICAgIH1cbiAgICBMb2NhdGlvbkxpbmsuaXMgPSBpcztcbn0pKExvY2F0aW9uTGluayB8fCAoTG9jYXRpb25MaW5rID0ge30pKTtcbi8qKlxuICogVGhlIENvbG9yIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIENvbG9yfSBsaXRlcmFscy5cbiAqL1xudmFyIENvbG9yO1xuKGZ1bmN0aW9uIChDb2xvcikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ29sb3IgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmVkLCBncmVlbiwgYmx1ZSwgYWxwaGEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlZCxcbiAgICAgICAgICAgIGdyZWVuLFxuICAgICAgICAgICAgYmx1ZSxcbiAgICAgICAgICAgIGFscGhhLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBDb2xvci5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBDb2xvcn0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLm51bWJlclJhbmdlKGNhbmRpZGF0ZS5yZWQsIDAsIDEpXG4gICAgICAgICAgICAmJiBJcy5udW1iZXJSYW5nZShjYW5kaWRhdGUuZ3JlZW4sIDAsIDEpXG4gICAgICAgICAgICAmJiBJcy5udW1iZXJSYW5nZShjYW5kaWRhdGUuYmx1ZSwgMCwgMSlcbiAgICAgICAgICAgICYmIElzLm51bWJlclJhbmdlKGNhbmRpZGF0ZS5hbHBoYSwgMCwgMSk7XG4gICAgfVxuICAgIENvbG9yLmlzID0gaXM7XG59KShDb2xvciB8fCAoQ29sb3IgPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29sb3JJbmZvcm1hdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBDb2xvckluZm9ybWF0aW9ufSBsaXRlcmFscy5cbiAqL1xudmFyIENvbG9ySW5mb3JtYXRpb247XG4oZnVuY3Rpb24gKENvbG9ySW5mb3JtYXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvbG9ySW5mb3JtYXRpb24gbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIGNvbG9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYW5nZSxcbiAgICAgICAgICAgIGNvbG9yLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBDb2xvckluZm9ybWF0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIENvbG9ySW5mb3JtYXRpb259IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpICYmIENvbG9yLmlzKGNhbmRpZGF0ZS5jb2xvcik7XG4gICAgfVxuICAgIENvbG9ySW5mb3JtYXRpb24uaXMgPSBpcztcbn0pKENvbG9ySW5mb3JtYXRpb24gfHwgKENvbG9ySW5mb3JtYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29sb3IgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgQ29sb3JQcmVzZW50YXRpb259IGxpdGVyYWxzLlxuICovXG52YXIgQ29sb3JQcmVzZW50YXRpb247XG4oZnVuY3Rpb24gKENvbG9yUHJlc2VudGF0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBDb2xvckluZm9ybWF0aW9uIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKGxhYmVsLCB0ZXh0RWRpdCwgYWRkaXRpb25hbFRleHRFZGl0cykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGFiZWwsXG4gICAgICAgICAgICB0ZXh0RWRpdCxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxUZXh0RWRpdHMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIENvbG9yUHJlc2VudGF0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIENvbG9ySW5mb3JtYXRpb259IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLmxhYmVsKVxuICAgICAgICAgICAgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUudGV4dEVkaXQpIHx8IFRleHRFZGl0LmlzKGNhbmRpZGF0ZSkpXG4gICAgICAgICAgICAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5hZGRpdGlvbmFsVGV4dEVkaXRzKSB8fCBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5hZGRpdGlvbmFsVGV4dEVkaXRzLCBUZXh0RWRpdC5pcykpO1xuICAgIH1cbiAgICBDb2xvclByZXNlbnRhdGlvbi5pcyA9IGlzO1xufSkoQ29sb3JQcmVzZW50YXRpb24gfHwgKENvbG9yUHJlc2VudGF0aW9uID0ge30pKTtcbi8qKlxuICogQSBzZXQgb2YgcHJlZGVmaW5lZCByYW5nZSBraW5kcy5cbiAqL1xudmFyIEZvbGRpbmdSYW5nZUtpbmQ7XG4oZnVuY3Rpb24gKEZvbGRpbmdSYW5nZUtpbmQpIHtcbiAgICAvKipcbiAgICAgKiBGb2xkaW5nIHJhbmdlIGZvciBhIGNvbW1lbnRcbiAgICAgKi9cbiAgICBGb2xkaW5nUmFuZ2VLaW5kLkNvbW1lbnQgPSAnY29tbWVudCc7XG4gICAgLyoqXG4gICAgICogRm9sZGluZyByYW5nZSBmb3IgYW4gaW1wb3J0IG9yIGluY2x1ZGVcbiAgICAgKi9cbiAgICBGb2xkaW5nUmFuZ2VLaW5kLkltcG9ydHMgPSAnaW1wb3J0cyc7XG4gICAgLyoqXG4gICAgICogRm9sZGluZyByYW5nZSBmb3IgYSByZWdpb24gKGUuZy4gYCNyZWdpb25gKVxuICAgICAqL1xuICAgIEZvbGRpbmdSYW5nZUtpbmQuUmVnaW9uID0gJ3JlZ2lvbic7XG59KShGb2xkaW5nUmFuZ2VLaW5kIHx8IChGb2xkaW5nUmFuZ2VLaW5kID0ge30pKTtcbi8qKlxuICogVGhlIGZvbGRpbmcgcmFuZ2UgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgRm9sZGluZ1JhbmdlfSBsaXRlcmFscy5cbiAqL1xudmFyIEZvbGRpbmdSYW5nZTtcbihmdW5jdGlvbiAoRm9sZGluZ1JhbmdlKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBGb2xkaW5nUmFuZ2UgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUoc3RhcnRMaW5lLCBlbmRMaW5lLCBzdGFydENoYXJhY3RlciwgZW5kQ2hhcmFjdGVyLCBraW5kLCBjb2xsYXBzZWRUZXh0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIHN0YXJ0TGluZSxcbiAgICAgICAgICAgIGVuZExpbmVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKElzLmRlZmluZWQoc3RhcnRDaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnRDaGFyYWN0ZXIgPSBzdGFydENoYXJhY3RlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXMuZGVmaW5lZChlbmRDaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICByZXN1bHQuZW5kQ2hhcmFjdGVyID0gZW5kQ2hhcmFjdGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKGtpbmQpKSB7XG4gICAgICAgICAgICByZXN1bHQua2luZCA9IGtpbmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzLmRlZmluZWQoY29sbGFwc2VkVGV4dCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jb2xsYXBzZWRUZXh0ID0gY29sbGFwc2VkVGV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBGb2xkaW5nUmFuZ2UuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgRm9sZGluZ1JhbmdlfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMudWludGVnZXIoY2FuZGlkYXRlLnN0YXJ0TGluZSkgJiYgSXMudWludGVnZXIoY2FuZGlkYXRlLnN0YXJ0TGluZSlcbiAgICAgICAgICAgICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLnN0YXJ0Q2hhcmFjdGVyKSB8fCBJcy51aW50ZWdlcihjYW5kaWRhdGUuc3RhcnRDaGFyYWN0ZXIpKVxuICAgICAgICAgICAgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUuZW5kQ2hhcmFjdGVyKSB8fCBJcy51aW50ZWdlcihjYW5kaWRhdGUuZW5kQ2hhcmFjdGVyKSlcbiAgICAgICAgICAgICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLmtpbmQpIHx8IElzLnN0cmluZyhjYW5kaWRhdGUua2luZCkpO1xuICAgIH1cbiAgICBGb2xkaW5nUmFuZ2UuaXMgPSBpcztcbn0pKEZvbGRpbmdSYW5nZSB8fCAoRm9sZGluZ1JhbmdlID0ge30pKTtcbi8qKlxuICogVGhlIERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24gbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uO1xuKGZ1bmN0aW9uIChEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKGxvY2F0aW9uLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgICAgIG1lc3NhZ2VcbiAgICAgICAgfTtcbiAgICB9XG4gICAgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9ufSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIExvY2F0aW9uLmlzKGNhbmRpZGF0ZS5sb2NhdGlvbikgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5tZXNzYWdlKTtcbiAgICB9XG4gICAgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbi5pcyA9IGlzO1xufSkoRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbiB8fCAoRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBkaWFnbm9zdGljJ3Mgc2V2ZXJpdHkuXG4gKi9cbnZhciBEaWFnbm9zdGljU2V2ZXJpdHk7XG4oZnVuY3Rpb24gKERpYWdub3N0aWNTZXZlcml0eSkge1xuICAgIC8qKlxuICAgICAqIFJlcG9ydHMgYW4gZXJyb3IuXG4gICAgICovXG4gICAgRGlhZ25vc3RpY1NldmVyaXR5LkVycm9yID0gMTtcbiAgICAvKipcbiAgICAgKiBSZXBvcnRzIGEgd2FybmluZy5cbiAgICAgKi9cbiAgICBEaWFnbm9zdGljU2V2ZXJpdHkuV2FybmluZyA9IDI7XG4gICAgLyoqXG4gICAgICogUmVwb3J0cyBhbiBpbmZvcm1hdGlvbi5cbiAgICAgKi9cbiAgICBEaWFnbm9zdGljU2V2ZXJpdHkuSW5mb3JtYXRpb24gPSAzO1xuICAgIC8qKlxuICAgICAqIFJlcG9ydHMgYSBoaW50LlxuICAgICAqL1xuICAgIERpYWdub3N0aWNTZXZlcml0eS5IaW50ID0gNDtcbn0pKERpYWdub3N0aWNTZXZlcml0eSB8fCAoRGlhZ25vc3RpY1NldmVyaXR5ID0ge30pKTtcbi8qKlxuICogVGhlIGRpYWdub3N0aWMgdGFncy5cbiAqXG4gKiBAc2luY2UgMy4xNS4wXG4gKi9cbnZhciBEaWFnbm9zdGljVGFnO1xuKGZ1bmN0aW9uIChEaWFnbm9zdGljVGFnKSB7XG4gICAgLyoqXG4gICAgICogVW51c2VkIG9yIHVubmVjZXNzYXJ5IGNvZGUuXG4gICAgICpcbiAgICAgKiBDbGllbnRzIGFyZSBhbGxvd2VkIHRvIHJlbmRlciBkaWFnbm9zdGljcyB3aXRoIHRoaXMgdGFnIGZhZGVkIG91dCBpbnN0ZWFkIG9mIGhhdmluZ1xuICAgICAqIGFuIGVycm9yIHNxdWlnZ2xlLlxuICAgICAqL1xuICAgIERpYWdub3N0aWNUYWcuVW5uZWNlc3NhcnkgPSAxO1xuICAgIC8qKlxuICAgICAqIERlcHJlY2F0ZWQgb3Igb2Jzb2xldGUgY29kZS5cbiAgICAgKlxuICAgICAqIENsaWVudHMgYXJlIGFsbG93ZWQgdG8gcmVuZGVyZWQgZGlhZ25vc3RpY3Mgd2l0aCB0aGlzIHRhZyBzdHJpa2UgdGhyb3VnaC5cbiAgICAgKi9cbiAgICBEaWFnbm9zdGljVGFnLkRlcHJlY2F0ZWQgPSAyO1xufSkoRGlhZ25vc3RpY1RhZyB8fCAoRGlhZ25vc3RpY1RhZyA9IHt9KSk7XG4vKipcbiAqIFRoZSBDb2RlRGVzY3JpcHRpb24gbmFtZXNwYWNlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0byBkZWFsIHdpdGggZGVzY3JpcHRpb25zIGZvciBkaWFnbm9zdGljIGNvZGVzLlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIENvZGVEZXNjcmlwdGlvbjtcbihmdW5jdGlvbiAoQ29kZURlc2NyaXB0aW9uKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5ocmVmKTtcbiAgICB9XG4gICAgQ29kZURlc2NyaXB0aW9uLmlzID0gaXM7XG59KShDb2RlRGVzY3JpcHRpb24gfHwgKENvZGVEZXNjcmlwdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBEaWFnbm9zdGljIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIERpYWdub3N0aWN9IGxpdGVyYWxzLlxuICovXG52YXIgRGlhZ25vc3RpYztcbihmdW5jdGlvbiAoRGlhZ25vc3RpYykge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgRGlhZ25vc3RpYyBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgbWVzc2FnZSwgc2V2ZXJpdHksIGNvZGUsIHNvdXJjZSwgcmVsYXRlZEluZm9ybWF0aW9uKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7IHJhbmdlLCBtZXNzYWdlIH07XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKHNldmVyaXR5KSkge1xuICAgICAgICAgICAgcmVzdWx0LnNldmVyaXR5ID0gc2V2ZXJpdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzLmRlZmluZWQoY29kZSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jb2RlID0gY29kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXMuZGVmaW5lZChzb3VyY2UpKSB7XG4gICAgICAgICAgICByZXN1bHQuc291cmNlID0gc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKHJlbGF0ZWRJbmZvcm1hdGlvbikpIHtcbiAgICAgICAgICAgIHJlc3VsdC5yZWxhdGVkSW5mb3JtYXRpb24gPSByZWxhdGVkSW5mb3JtYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgRGlhZ25vc3RpYy5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBEaWFnbm9zdGljfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSlcbiAgICAgICAgICAgICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSlcbiAgICAgICAgICAgICYmIElzLnN0cmluZyhjYW5kaWRhdGUubWVzc2FnZSlcbiAgICAgICAgICAgICYmIChJcy5udW1iZXIoY2FuZGlkYXRlLnNldmVyaXR5KSB8fCBJcy51bmRlZmluZWQoY2FuZGlkYXRlLnNldmVyaXR5KSlcbiAgICAgICAgICAgICYmIChJcy5pbnRlZ2VyKGNhbmRpZGF0ZS5jb2RlKSB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLmNvZGUpIHx8IElzLnVuZGVmaW5lZChjYW5kaWRhdGUuY29kZSkpXG4gICAgICAgICAgICAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5jb2RlRGVzY3JpcHRpb24pIHx8IChJcy5zdHJpbmcoKF9hID0gY2FuZGlkYXRlLmNvZGVEZXNjcmlwdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhyZWYpKSlcbiAgICAgICAgICAgICYmIChJcy5zdHJpbmcoY2FuZGlkYXRlLnNvdXJjZSkgfHwgSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5zb3VyY2UpKVxuICAgICAgICAgICAgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUucmVsYXRlZEluZm9ybWF0aW9uKSB8fCBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5yZWxhdGVkSW5mb3JtYXRpb24sIERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24uaXMpKTtcbiAgICB9XG4gICAgRGlhZ25vc3RpYy5pcyA9IGlzO1xufSkoRGlhZ25vc3RpYyB8fCAoRGlhZ25vc3RpYyA9IHt9KSk7XG4vKipcbiAqIFRoZSBDb21tYW5kIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIENvbW1hbmR9IGxpdGVyYWxzLlxuICovXG52YXIgQ29tbWFuZDtcbihmdW5jdGlvbiAoQ29tbWFuZCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ29tbWFuZCBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh0aXRsZSwgY29tbWFuZCwgLi4uYXJncykge1xuICAgICAgICBsZXQgcmVzdWx0ID0geyB0aXRsZSwgY29tbWFuZCB9O1xuICAgICAgICBpZiAoSXMuZGVmaW5lZChhcmdzKSAmJiBhcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5hcmd1bWVudHMgPSBhcmdzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIENvbW1hbmQuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgQ29tbWFuZH0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnRpdGxlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLmNvbW1hbmQpO1xuICAgIH1cbiAgICBDb21tYW5kLmlzID0gaXM7XG59KShDb21tYW5kIHx8IChDb21tYW5kID0ge30pKTtcbi8qKlxuICogVGhlIFRleHRFZGl0IG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIHJlcGxhY2UsXG4gKiBpbnNlcnQgYW5kIGRlbGV0ZSBlZGl0cyBtb3JlIGVhc2lseS5cbiAqL1xudmFyIFRleHRFZGl0O1xuKGZ1bmN0aW9uIChUZXh0RWRpdCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSByZXBsYWNlIHRleHQgZWRpdC5cbiAgICAgKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIG9mIHRleHQgdG8gYmUgcmVwbGFjZWQuXG4gICAgICogQHBhcmFtIG5ld1RleHQgVGhlIG5ldyB0ZXh0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlcGxhY2UocmFuZ2UsIG5ld1RleHQpIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2UsIG5ld1RleHQgfTtcbiAgICB9XG4gICAgVGV4dEVkaXQucmVwbGFjZSA9IHJlcGxhY2U7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnNlcnQgdGV4dCBlZGl0LlxuICAgICAqIEBwYXJhbSBwb3NpdGlvbiBUaGUgcG9zaXRpb24gdG8gaW5zZXJ0IHRoZSB0ZXh0IGF0LlxuICAgICAqIEBwYXJhbSBuZXdUZXh0IFRoZSB0ZXh0IHRvIGJlIGluc2VydGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluc2VydChwb3NpdGlvbiwgbmV3VGV4dCkge1xuICAgICAgICByZXR1cm4geyByYW5nZTogeyBzdGFydDogcG9zaXRpb24sIGVuZDogcG9zaXRpb24gfSwgbmV3VGV4dCB9O1xuICAgIH1cbiAgICBUZXh0RWRpdC5pbnNlcnQgPSBpbnNlcnQ7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGRlbGV0ZSB0ZXh0IGVkaXQuXG4gICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSBvZiB0ZXh0IHRvIGJlIGRlbGV0ZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVsKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlLCBuZXdUZXh0OiAnJyB9O1xuICAgIH1cbiAgICBUZXh0RWRpdC5kZWwgPSBkZWw7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSlcbiAgICAgICAgICAgICYmIElzLnN0cmluZyhjYW5kaWRhdGUubmV3VGV4dClcbiAgICAgICAgICAgICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSk7XG4gICAgfVxuICAgIFRleHRFZGl0LmlzID0gaXM7XG59KShUZXh0RWRpdCB8fCAoVGV4dEVkaXQgPSB7fSkpO1xudmFyIENoYW5nZUFubm90YXRpb247XG4oZnVuY3Rpb24gKENoYW5nZUFubm90YXRpb24pIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUobGFiZWwsIG5lZWRzQ29uZmlybWF0aW9uLCBkZXNjcmlwdGlvbikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7IGxhYmVsIH07XG4gICAgICAgIGlmIChuZWVkc0NvbmZpcm1hdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQubmVlZHNDb25maXJtYXRpb24gPSBuZWVkc0NvbmZpcm1hdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVzY3JpcHRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgQ2hhbmdlQW5ub3RhdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5sYWJlbCkgJiZcbiAgICAgICAgICAgIChJcy5ib29sZWFuKGNhbmRpZGF0ZS5uZWVkc0NvbmZpcm1hdGlvbikgfHwgY2FuZGlkYXRlLm5lZWRzQ29uZmlybWF0aW9uID09PSB1bmRlZmluZWQpICYmXG4gICAgICAgICAgICAoSXMuc3RyaW5nKGNhbmRpZGF0ZS5kZXNjcmlwdGlvbikgfHwgY2FuZGlkYXRlLmRlc2NyaXB0aW9uID09PSB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBDaGFuZ2VBbm5vdGF0aW9uLmlzID0gaXM7XG59KShDaGFuZ2VBbm5vdGF0aW9uIHx8IChDaGFuZ2VBbm5vdGF0aW9uID0ge30pKTtcbnZhciBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllcjtcbihmdW5jdGlvbiAoQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLnN0cmluZyhjYW5kaWRhdGUpO1xuICAgIH1cbiAgICBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyA9IGlzO1xufSkoQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIgfHwgKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyID0ge30pKTtcbnZhciBBbm5vdGF0ZWRUZXh0RWRpdDtcbihmdW5jdGlvbiAoQW5ub3RhdGVkVGV4dEVkaXQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFubm90YXRlZCByZXBsYWNlIHRleHQgZWRpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2Ugb2YgdGV4dCB0byBiZSByZXBsYWNlZC5cbiAgICAgKiBAcGFyYW0gbmV3VGV4dCBUaGUgbmV3IHRleHQuXG4gICAgICogQHBhcmFtIGFubm90YXRpb24gVGhlIGFubm90YXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVwbGFjZShyYW5nZSwgbmV3VGV4dCwgYW5ub3RhdGlvbikge1xuICAgICAgICByZXR1cm4geyByYW5nZSwgbmV3VGV4dCwgYW5ub3RhdGlvbklkOiBhbm5vdGF0aW9uIH07XG4gICAgfVxuICAgIEFubm90YXRlZFRleHRFZGl0LnJlcGxhY2UgPSByZXBsYWNlO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYW5ub3RhdGVkIGluc2VydCB0ZXh0IGVkaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gVGhlIHBvc2l0aW9uIHRvIGluc2VydCB0aGUgdGV4dCBhdC5cbiAgICAgKiBAcGFyYW0gbmV3VGV4dCBUaGUgdGV4dCB0byBiZSBpbnNlcnRlZC5cbiAgICAgKiBAcGFyYW0gYW5ub3RhdGlvbiBUaGUgYW5ub3RhdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnNlcnQocG9zaXRpb24sIG5ld1RleHQsIGFubm90YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IHsgc3RhcnQ6IHBvc2l0aW9uLCBlbmQ6IHBvc2l0aW9uIH0sIG5ld1RleHQsIGFubm90YXRpb25JZDogYW5ub3RhdGlvbiB9O1xuICAgIH1cbiAgICBBbm5vdGF0ZWRUZXh0RWRpdC5pbnNlcnQgPSBpbnNlcnQ7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhbm5vdGF0ZWQgZGVsZXRlIHRleHQgZWRpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2Ugb2YgdGV4dCB0byBiZSBkZWxldGVkLlxuICAgICAqIEBwYXJhbSBhbm5vdGF0aW9uIFRoZSBhbm5vdGF0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlbChyYW5nZSwgYW5ub3RhdGlvbikge1xuICAgICAgICByZXR1cm4geyByYW5nZSwgbmV3VGV4dDogJycsIGFubm90YXRpb25JZDogYW5ub3RhdGlvbiB9O1xuICAgIH1cbiAgICBBbm5vdGF0ZWRUZXh0RWRpdC5kZWwgPSBkZWw7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBUZXh0RWRpdC5pcyhjYW5kaWRhdGUpICYmIChDaGFuZ2VBbm5vdGF0aW9uLmlzKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQpIHx8IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQpKTtcbiAgICB9XG4gICAgQW5ub3RhdGVkVGV4dEVkaXQuaXMgPSBpcztcbn0pKEFubm90YXRlZFRleHRFZGl0IHx8IChBbm5vdGF0ZWRUZXh0RWRpdCA9IHt9KSk7XG4vKipcbiAqIFRoZSBUZXh0RG9jdW1lbnRFZGl0IG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlXG4gKiBhbiBlZGl0IHRoYXQgbWFuaXB1bGF0ZXMgYSB0ZXh0IGRvY3VtZW50LlxuICovXG52YXIgVGV4dERvY3VtZW50RWRpdDtcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50RWRpdCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgYFRleHREb2N1bWVudEVkaXRgXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHRleHREb2N1bWVudCwgZWRpdHMpIHtcbiAgICAgICAgcmV0dXJuIHsgdGV4dERvY3VtZW50LCBlZGl0cyB9O1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnRFZGl0LmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSlcbiAgICAgICAgICAgICYmIE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllci5pcyhjYW5kaWRhdGUudGV4dERvY3VtZW50KVxuICAgICAgICAgICAgJiYgQXJyYXkuaXNBcnJheShjYW5kaWRhdGUuZWRpdHMpO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnRFZGl0LmlzID0gaXM7XG59KShUZXh0RG9jdW1lbnRFZGl0IHx8IChUZXh0RG9jdW1lbnRFZGl0ID0ge30pKTtcbnZhciBDcmVhdGVGaWxlO1xuKGZ1bmN0aW9uIChDcmVhdGVGaWxlKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgb3B0aW9ucywgYW5ub3RhdGlvbikge1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAga2luZDogJ2NyZWF0ZScsXG4gICAgICAgICAgICB1cmlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiAob3B0aW9ucy5vdmVyd3JpdGUgIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmlnbm9yZUlmRXhpc3RzICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICByZXN1bHQub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFubm90YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmFubm90YXRpb25JZCA9IGFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgQ3JlYXRlRmlsZS5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIGNhbmRpZGF0ZS5raW5kID09PSAnY3JlYXRlJyAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnVyaSkgJiYgKGNhbmRpZGF0ZS5vcHRpb25zID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICgoY2FuZGlkYXRlLm9wdGlvbnMub3ZlcndyaXRlID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUub3B0aW9ucy5vdmVyd3JpdGUpKSAmJiAoY2FuZGlkYXRlLm9wdGlvbnMuaWdub3JlSWZFeGlzdHMgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5vcHRpb25zLmlnbm9yZUlmRXhpc3RzKSkpKSAmJiAoY2FuZGlkYXRlLmFubm90YXRpb25JZCA9PT0gdW5kZWZpbmVkIHx8IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQpKTtcbiAgICB9XG4gICAgQ3JlYXRlRmlsZS5pcyA9IGlzO1xufSkoQ3JlYXRlRmlsZSB8fCAoQ3JlYXRlRmlsZSA9IHt9KSk7XG52YXIgUmVuYW1lRmlsZTtcbihmdW5jdGlvbiAoUmVuYW1lRmlsZSkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShvbGRVcmksIG5ld1VyaSwgb3B0aW9ucywgYW5ub3RhdGlvbikge1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAga2luZDogJ3JlbmFtZScsXG4gICAgICAgICAgICBvbGRVcmksXG4gICAgICAgICAgICBuZXdVcmlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiAob3B0aW9ucy5vdmVyd3JpdGUgIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmlnbm9yZUlmRXhpc3RzICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICByZXN1bHQub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFubm90YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmFubm90YXRpb25JZCA9IGFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgUmVuYW1lRmlsZS5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIGNhbmRpZGF0ZS5raW5kID09PSAncmVuYW1lJyAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm9sZFVyaSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5uZXdVcmkpICYmIChjYW5kaWRhdGUub3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAoKGNhbmRpZGF0ZS5vcHRpb25zLm92ZXJ3cml0ZSA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLm9wdGlvbnMub3ZlcndyaXRlKSkgJiYgKGNhbmRpZGF0ZS5vcHRpb25zLmlnbm9yZUlmRXhpc3RzID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUub3B0aW9ucy5pZ25vcmVJZkV4aXN0cykpKSkgJiYgKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQgPT09IHVuZGVmaW5lZCB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhjYW5kaWRhdGUuYW5ub3RhdGlvbklkKSk7XG4gICAgfVxuICAgIFJlbmFtZUZpbGUuaXMgPSBpcztcbn0pKFJlbmFtZUZpbGUgfHwgKFJlbmFtZUZpbGUgPSB7fSkpO1xudmFyIERlbGV0ZUZpbGU7XG4oZnVuY3Rpb24gKERlbGV0ZUZpbGUpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCBvcHRpb25zLCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgICBraW5kOiAnZGVsZXRlJyxcbiAgICAgICAgICAgIHVyaVxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIChvcHRpb25zLnJlY3Vyc2l2ZSAhPT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuaWdub3JlSWZOb3RFeGlzdHMgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5ub3RhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQuYW5ub3RhdGlvbklkID0gYW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBEZWxldGVGaWxlLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgY2FuZGlkYXRlLmtpbmQgPT09ICdkZWxldGUnICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiAoY2FuZGlkYXRlLm9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgKChjYW5kaWRhdGUub3B0aW9ucy5yZWN1cnNpdmUgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5vcHRpb25zLnJlY3Vyc2l2ZSkpICYmIChjYW5kaWRhdGUub3B0aW9ucy5pZ25vcmVJZk5vdEV4aXN0cyA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLm9wdGlvbnMuaWdub3JlSWZOb3RFeGlzdHMpKSkpICYmIChjYW5kaWRhdGUuYW5ub3RhdGlvbklkID09PSB1bmRlZmluZWQgfHwgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoY2FuZGlkYXRlLmFubm90YXRpb25JZCkpO1xuICAgIH1cbiAgICBEZWxldGVGaWxlLmlzID0gaXM7XG59KShEZWxldGVGaWxlIHx8IChEZWxldGVGaWxlID0ge30pKTtcbnZhciBXb3Jrc3BhY2VFZGl0O1xuKGZ1bmN0aW9uIChXb3Jrc3BhY2VFZGl0KSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmNoYW5nZXMgIT09IHVuZGVmaW5lZCB8fCBjYW5kaWRhdGUuZG9jdW1lbnRDaGFuZ2VzICE9PSB1bmRlZmluZWQpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmRvY3VtZW50Q2hhbmdlcyA9PT0gdW5kZWZpbmVkIHx8IGNhbmRpZGF0ZS5kb2N1bWVudENoYW5nZXMuZXZlcnkoKGNoYW5nZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChJcy5zdHJpbmcoY2hhbmdlLmtpbmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBDcmVhdGVGaWxlLmlzKGNoYW5nZSkgfHwgUmVuYW1lRmlsZS5pcyhjaGFuZ2UpIHx8IERlbGV0ZUZpbGUuaXMoY2hhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBUZXh0RG9jdW1lbnRFZGl0LmlzKGNoYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgIH1cbiAgICBXb3Jrc3BhY2VFZGl0LmlzID0gaXM7XG59KShXb3Jrc3BhY2VFZGl0IHx8IChXb3Jrc3BhY2VFZGl0ID0ge30pKTtcbmNsYXNzIFRleHRFZGl0Q2hhbmdlSW1wbCB7XG4gICAgY29uc3RydWN0b3IoZWRpdHMsIGNoYW5nZUFubm90YXRpb25zKSB7XG4gICAgICAgIHRoaXMuZWRpdHMgPSBlZGl0cztcbiAgICAgICAgdGhpcy5jaGFuZ2VBbm5vdGF0aW9ucyA9IGNoYW5nZUFubm90YXRpb25zO1xuICAgIH1cbiAgICBpbnNlcnQocG9zaXRpb24sIG5ld1RleHQsIGFubm90YXRpb24pIHtcbiAgICAgICAgbGV0IGVkaXQ7XG4gICAgICAgIGxldCBpZDtcbiAgICAgICAgaWYgKGFubm90YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZWRpdCA9IFRleHRFZGl0Lmluc2VydChwb3NpdGlvbiwgbmV3VGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoYW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgIGlkID0gYW5ub3RhdGlvbjtcbiAgICAgICAgICAgIGVkaXQgPSBBbm5vdGF0ZWRUZXh0RWRpdC5pbnNlcnQocG9zaXRpb24sIG5ld1RleHQsIGFubm90YXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRDaGFuZ2VBbm5vdGF0aW9ucyh0aGlzLmNoYW5nZUFubm90YXRpb25zKTtcbiAgICAgICAgICAgIGlkID0gdGhpcy5jaGFuZ2VBbm5vdGF0aW9ucy5tYW5hZ2UoYW5ub3RhdGlvbik7XG4gICAgICAgICAgICBlZGl0ID0gQW5ub3RhdGVkVGV4dEVkaXQuaW5zZXJ0KHBvc2l0aW9uLCBuZXdUZXh0LCBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGl0cy5wdXNoKGVkaXQpO1xuICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcGxhY2UocmFuZ2UsIG5ld1RleHQsIGFubm90YXRpb24pIHtcbiAgICAgICAgbGV0IGVkaXQ7XG4gICAgICAgIGxldCBpZDtcbiAgICAgICAgaWYgKGFubm90YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZWRpdCA9IFRleHRFZGl0LnJlcGxhY2UocmFuZ2UsIG5ld1RleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGFubm90YXRpb24pKSB7XG4gICAgICAgICAgICBpZCA9IGFubm90YXRpb247XG4gICAgICAgICAgICBlZGl0ID0gQW5ub3RhdGVkVGV4dEVkaXQucmVwbGFjZShyYW5nZSwgbmV3VGV4dCwgYW5ub3RhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFzc2VydENoYW5nZUFubm90YXRpb25zKHRoaXMuY2hhbmdlQW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgaWQgPSB0aGlzLmNoYW5nZUFubm90YXRpb25zLm1hbmFnZShhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgIGVkaXQgPSBBbm5vdGF0ZWRUZXh0RWRpdC5yZXBsYWNlKHJhbmdlLCBuZXdUZXh0LCBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGl0cy5wdXNoKGVkaXQpO1xuICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlbGV0ZShyYW5nZSwgYW5ub3RhdGlvbikge1xuICAgICAgICBsZXQgZWRpdDtcbiAgICAgICAgbGV0IGlkO1xuICAgICAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlZGl0ID0gVGV4dEVkaXQuZGVsKHJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhhbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgaWQgPSBhbm5vdGF0aW9uO1xuICAgICAgICAgICAgZWRpdCA9IEFubm90YXRlZFRleHRFZGl0LmRlbChyYW5nZSwgYW5ub3RhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFzc2VydENoYW5nZUFubm90YXRpb25zKHRoaXMuY2hhbmdlQW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgaWQgPSB0aGlzLmNoYW5nZUFubm90YXRpb25zLm1hbmFnZShhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgIGVkaXQgPSBBbm5vdGF0ZWRUZXh0RWRpdC5kZWwocmFuZ2UsIGlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVkaXRzLnB1c2goZWRpdCk7XG4gICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkKGVkaXQpIHtcbiAgICAgICAgdGhpcy5lZGl0cy5wdXNoKGVkaXQpO1xuICAgIH1cbiAgICBhbGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRzO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5lZGl0cy5zcGxpY2UoMCwgdGhpcy5lZGl0cy5sZW5ndGgpO1xuICAgIH1cbiAgICBhc3NlcnRDaGFuZ2VBbm5vdGF0aW9ucyh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUZXh0IGVkaXQgY2hhbmdlIGlzIG5vdCBjb25maWd1cmVkIHRvIG1hbmFnZSBjaGFuZ2UgYW5ub3RhdGlvbnMuYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEEgaGVscGVyIGNsYXNzXG4gKi9cbmNsYXNzIENoYW5nZUFubm90YXRpb25zIHtcbiAgICBjb25zdHJ1Y3Rvcihhbm5vdGF0aW9ucykge1xuICAgICAgICB0aGlzLl9hbm5vdGF0aW9ucyA9IGFubm90YXRpb25zID09PSB1bmRlZmluZWQgPyBPYmplY3QuY3JlYXRlKG51bGwpIDogYW5ub3RhdGlvbnM7XG4gICAgICAgIHRoaXMuX2NvdW50ZXIgPSAwO1xuICAgICAgICB0aGlzLl9zaXplID0gMDtcbiAgICB9XG4gICAgYWxsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW5ub3RhdGlvbnM7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgICB9XG4gICAgbWFuYWdlKGlkT3JBbm5vdGF0aW9uLCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIGxldCBpZDtcbiAgICAgICAgaWYgKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGlkT3JBbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgaWQgPSBpZE9yQW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlkID0gdGhpcy5uZXh0SWQoKTtcbiAgICAgICAgICAgIGFubm90YXRpb24gPSBpZE9yQW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fYW5ub3RhdGlvbnNbaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSWQgJHtpZH0gaXMgYWxyZWFkeSBpbiB1c2UuYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFubm90YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBhbm5vdGF0aW9uIHByb3ZpZGVkIGZvciBpZCAke2lkfWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Fubm90YXRpb25zW2lkXSA9IGFubm90YXRpb247XG4gICAgICAgIHRoaXMuX3NpemUrKztcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbiAgICBuZXh0SWQoKSB7XG4gICAgICAgIHRoaXMuX2NvdW50ZXIrKztcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvdW50ZXIudG9TdHJpbmcoKTtcbiAgICB9XG59XG4vKipcbiAqIEEgd29ya3NwYWNlIGNoYW5nZSBoZWxwcyBjb25zdHJ1Y3RpbmcgY2hhbmdlcyB0byBhIHdvcmtzcGFjZS5cbiAqL1xuY2xhc3MgV29ya3NwYWNlQ2hhbmdlIHtcbiAgICBjb25zdHJ1Y3Rvcih3b3Jrc3BhY2VFZGl0KSB7XG4gICAgICAgIHRoaXMuX3RleHRFZGl0Q2hhbmdlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGlmICh3b3Jrc3BhY2VFZGl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQgPSB3b3Jrc3BhY2VFZGl0O1xuICAgICAgICAgICAgaWYgKHdvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMgPSBuZXcgQ2hhbmdlQW5ub3RhdGlvbnMod29ya3NwYWNlRWRpdC5jaGFuZ2VBbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICAgICAgd29ya3NwYWNlRWRpdC5jaGFuZ2VBbm5vdGF0aW9ucyA9IHRoaXMuX2NoYW5nZUFubm90YXRpb25zLmFsbCgpO1xuICAgICAgICAgICAgICAgIHdvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzLmZvckVhY2goKGNoYW5nZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoVGV4dERvY3VtZW50RWRpdC5pcyhjaGFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0RWRpdENoYW5nZSA9IG5ldyBUZXh0RWRpdENoYW5nZUltcGwoY2hhbmdlLmVkaXRzLCB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0RWRpdENoYW5nZXNbY2hhbmdlLnRleHREb2N1bWVudC51cmldID0gdGV4dEVkaXRDaGFuZ2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHdvcmtzcGFjZUVkaXQuY2hhbmdlcykge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHdvcmtzcGFjZUVkaXQuY2hhbmdlcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHRFZGl0Q2hhbmdlID0gbmV3IFRleHRFZGl0Q2hhbmdlSW1wbCh3b3Jrc3BhY2VFZGl0LmNoYW5nZXNba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RleHRFZGl0Q2hhbmdlc1trZXldID0gdGV4dEVkaXRDaGFuZ2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0ID0ge307XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdW5kZXJseWluZyB7QGxpbmsgV29ya3NwYWNlRWRpdH0gbGl0ZXJhbFxuICAgICAqIHVzZSB0byBiZSByZXR1cm5lZCBmcm9tIGEgd29ya3NwYWNlIGVkaXQgb3BlcmF0aW9uIGxpa2UgcmVuYW1lLlxuICAgICAqL1xuICAgIGdldCBlZGl0KCkge1xuICAgICAgICB0aGlzLmluaXREb2N1bWVudENoYW5nZXMoKTtcbiAgICAgICAgaWYgKHRoaXMuX2NoYW5nZUFubm90YXRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VBbm5vdGF0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlQW5ub3RhdGlvbnMgPSB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucy5hbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fd29ya3NwYWNlRWRpdDtcbiAgICB9XG4gICAgZ2V0VGV4dEVkaXRDaGFuZ2Uoa2V5KSB7XG4gICAgICAgIGlmIChPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuaXMoa2V5KSkge1xuICAgICAgICAgICAgdGhpcy5pbml0RG9jdW1lbnRDaGFuZ2VzKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV29ya3NwYWNlIGVkaXQgaXMgbm90IGNvbmZpZ3VyZWQgZm9yIGRvY3VtZW50IGNoYW5nZXMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0ZXh0RG9jdW1lbnQgPSB7IHVyaToga2V5LnVyaSwgdmVyc2lvbjoga2V5LnZlcnNpb24gfTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLl90ZXh0RWRpdENoYW5nZXNbdGV4dERvY3VtZW50LnVyaV07XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVkaXRzID0gW107XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dERvY3VtZW50RWRpdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dERvY3VtZW50LFxuICAgICAgICAgICAgICAgICAgICBlZGl0c1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMucHVzaCh0ZXh0RG9jdW1lbnRFZGl0KTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgVGV4dEVkaXRDaGFuZ2VJbXBsKGVkaXRzLCB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dEVkaXRDaGFuZ2VzW3RleHREb2N1bWVudC51cmldID0gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdENoYW5nZXMoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl93b3Jrc3BhY2VFZGl0LmNoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV29ya3NwYWNlIGVkaXQgaXMgbm90IGNvbmZpZ3VyZWQgZm9yIG5vcm1hbCB0ZXh0IGVkaXQgY2hhbmdlcy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLl90ZXh0RWRpdENoYW5nZXNba2V5XTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgbGV0IGVkaXRzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VzW2tleV0gPSBlZGl0cztcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgVGV4dEVkaXRDaGFuZ2VJbXBsKGVkaXRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0RWRpdENoYW5nZXNba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5pdERvY3VtZW50Q2hhbmdlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzID09PSB1bmRlZmluZWQgJiYgdGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZUFubm90YXRpb25zID0gbmV3IENoYW5nZUFubm90YXRpb25zKCk7XG4gICAgICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VBbm5vdGF0aW9ucyA9IHRoaXMuX2NoYW5nZUFubm90YXRpb25zLmFsbCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluaXRDaGFuZ2VzKCkge1xuICAgICAgICBpZiAodGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMgPT09IHVuZGVmaW5lZCAmJiB0aGlzLl93b3Jrc3BhY2VFZGl0LmNoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVGaWxlKHVyaSwgb3B0aW9uc09yQW5ub3RhdGlvbiwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXREb2N1bWVudENoYW5nZXMoKTtcbiAgICAgICAgaWYgKHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV29ya3NwYWNlIGVkaXQgaXMgbm90IGNvbmZpZ3VyZWQgZm9yIGRvY3VtZW50IGNoYW5nZXMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFubm90YXRpb247XG4gICAgICAgIGlmIChDaGFuZ2VBbm5vdGF0aW9uLmlzKG9wdGlvbnNPckFubm90YXRpb24pIHx8IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKG9wdGlvbnNPckFubm90YXRpb24pKSB7XG4gICAgICAgICAgICBhbm5vdGF0aW9uID0gb3B0aW9uc09yQW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zT3JBbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvcGVyYXRpb247XG4gICAgICAgIGxldCBpZDtcbiAgICAgICAgaWYgKGFubm90YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3BlcmF0aW9uID0gQ3JlYXRlRmlsZS5jcmVhdGUodXJpLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlkID0gQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoYW5ub3RhdGlvbikgPyBhbm5vdGF0aW9uIDogdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMubWFuYWdlKGFubm90YXRpb24pO1xuICAgICAgICAgICAgb3BlcmF0aW9uID0gQ3JlYXRlRmlsZS5jcmVhdGUodXJpLCBvcHRpb25zLCBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMucHVzaChvcGVyYXRpb24pO1xuICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmFtZUZpbGUob2xkVXJpLCBuZXdVcmksIG9wdGlvbnNPckFubm90YXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0RG9jdW1lbnRDaGFuZ2VzKCk7XG4gICAgICAgIGlmICh0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtzcGFjZSBlZGl0IGlzIG5vdCBjb25maWd1cmVkIGZvciBkb2N1bWVudCBjaGFuZ2VzLicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhbm5vdGF0aW9uO1xuICAgICAgICBpZiAoQ2hhbmdlQW5ub3RhdGlvbi5pcyhvcHRpb25zT3JBbm5vdGF0aW9uKSB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhvcHRpb25zT3JBbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgYW5ub3RhdGlvbiA9IG9wdGlvbnNPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9uc09yQW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3BlcmF0aW9uO1xuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IFJlbmFtZUZpbGUuY3JlYXRlKG9sZFVyaSwgbmV3VXJpLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlkID0gQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoYW5ub3RhdGlvbikgPyBhbm5vdGF0aW9uIDogdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMubWFuYWdlKGFubm90YXRpb24pO1xuICAgICAgICAgICAgb3BlcmF0aW9uID0gUmVuYW1lRmlsZS5jcmVhdGUob2xkVXJpLCBuZXdVcmksIG9wdGlvbnMsIGlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcy5wdXNoKG9wZXJhdGlvbik7XG4gICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVsZXRlRmlsZSh1cmksIG9wdGlvbnNPckFubm90YXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0RG9jdW1lbnRDaGFuZ2VzKCk7XG4gICAgICAgIGlmICh0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtzcGFjZSBlZGl0IGlzIG5vdCBjb25maWd1cmVkIGZvciBkb2N1bWVudCBjaGFuZ2VzLicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhbm5vdGF0aW9uO1xuICAgICAgICBpZiAoQ2hhbmdlQW5ub3RhdGlvbi5pcyhvcHRpb25zT3JBbm5vdGF0aW9uKSB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhvcHRpb25zT3JBbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgYW5ub3RhdGlvbiA9IG9wdGlvbnNPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9uc09yQW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3BlcmF0aW9uO1xuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IERlbGV0ZUZpbGUuY3JlYXRlKHVyaSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZCA9IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGFubm90YXRpb24pID8gYW5ub3RhdGlvbiA6IHRoaXMuX2NoYW5nZUFubm90YXRpb25zLm1hbmFnZShhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IERlbGV0ZUZpbGUuY3JlYXRlKHVyaSwgb3B0aW9ucywgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzLnB1c2gob3BlcmF0aW9uKTtcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogVGhlIFRleHREb2N1bWVudElkZW50aWZpZXIgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgVGV4dERvY3VtZW50SWRlbnRpZmllcn0gbGl0ZXJhbHMuXG4gKi9cbnZhciBUZXh0RG9jdW1lbnRJZGVudGlmaWVyO1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnRJZGVudGlmaWVyKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBUZXh0RG9jdW1lbnRJZGVudGlmaWVyIGxpdGVyYWwuXG4gICAgICogQHBhcmFtIHVyaSBUaGUgZG9jdW1lbnQncyB1cmkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSkge1xuICAgICAgICByZXR1cm4geyB1cmkgfTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50SWRlbnRpZmllci5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBUZXh0RG9jdW1lbnRJZGVudGlmaWVyfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50SWRlbnRpZmllci5pcyA9IGlzO1xufSkoVGV4dERvY3VtZW50SWRlbnRpZmllciB8fCAoVGV4dERvY3VtZW50SWRlbnRpZmllciA9IHt9KSk7XG4vKipcbiAqIFRoZSBWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXJ9IGxpdGVyYWxzLlxuICovXG52YXIgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcjtcbihmdW5jdGlvbiAoVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciBsaXRlcmFsLlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGRvY3VtZW50J3MgdXJpLlxuICAgICAqIEBwYXJhbSB2ZXJzaW9uIFRoZSBkb2N1bWVudCdzIHZlcnNpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgdmVyc2lvbikge1xuICAgICAgICByZXR1cm4geyB1cmksIHZlcnNpb24gfTtcbiAgICB9XG4gICAgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllci5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiBJcy5pbnRlZ2VyKGNhbmRpZGF0ZS52ZXJzaW9uKTtcbiAgICB9XG4gICAgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllci5pcyA9IGlzO1xufSkoVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciB8fCAoVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciA9IHt9KSk7XG4vKipcbiAqIFRoZSBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyfSBsaXRlcmFscy5cbiAqL1xudmFyIE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcjtcbihmdW5jdGlvbiAoT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIgbGl0ZXJhbC5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSBkb2N1bWVudCdzIHVyaS5cbiAgICAgKiBAcGFyYW0gdmVyc2lvbiBUaGUgZG9jdW1lbnQncyB2ZXJzaW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIHZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIHsgdXJpLCB2ZXJzaW9uIH07XG4gICAgfVxuICAgIE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllci5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXJ9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIChjYW5kaWRhdGUudmVyc2lvbiA9PT0gbnVsbCB8fCBJcy5pbnRlZ2VyKGNhbmRpZGF0ZS52ZXJzaW9uKSk7XG4gICAgfVxuICAgIE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllci5pcyA9IGlzO1xufSkoT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIHx8IChPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgVGV4dERvY3VtZW50SXRlbSBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBUZXh0RG9jdW1lbnRJdGVtfSBsaXRlcmFscy5cbiAqL1xudmFyIFRleHREb2N1bWVudEl0ZW07XG4oZnVuY3Rpb24gKFRleHREb2N1bWVudEl0ZW0pIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFRleHREb2N1bWVudEl0ZW0gbGl0ZXJhbC5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSBkb2N1bWVudCdzIHVyaS5cbiAgICAgKiBAcGFyYW0gbGFuZ3VhZ2VJZCBUaGUgZG9jdW1lbnQncyBsYW5ndWFnZSBpZGVudGlmaWVyLlxuICAgICAqIEBwYXJhbSB2ZXJzaW9uIFRoZSBkb2N1bWVudCdzIHZlcnNpb24gbnVtYmVyLlxuICAgICAqIEBwYXJhbSB0ZXh0IFRoZSBkb2N1bWVudCdzIHRleHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgbGFuZ3VhZ2VJZCwgdmVyc2lvbiwgdGV4dCkge1xuICAgICAgICByZXR1cm4geyB1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIHRleHQgfTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50SXRlbS5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBUZXh0RG9jdW1lbnRJdGVtfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLmxhbmd1YWdlSWQpICYmIElzLmludGVnZXIoY2FuZGlkYXRlLnZlcnNpb24pICYmIElzLnN0cmluZyhjYW5kaWRhdGUudGV4dCk7XG4gICAgfVxuICAgIFRleHREb2N1bWVudEl0ZW0uaXMgPSBpcztcbn0pKFRleHREb2N1bWVudEl0ZW0gfHwgKFRleHREb2N1bWVudEl0ZW0gPSB7fSkpO1xuLyoqXG4gKiBEZXNjcmliZXMgdGhlIGNvbnRlbnQgdHlwZSB0aGF0IGEgY2xpZW50IHN1cHBvcnRzIGluIHZhcmlvdXNcbiAqIHJlc3VsdCBsaXRlcmFscyBsaWtlIGBIb3ZlcmAsIGBQYXJhbWV0ZXJJbmZvYCBvciBgQ29tcGxldGlvbkl0ZW1gLlxuICpcbiAqIFBsZWFzZSBub3RlIHRoYXQgYE1hcmt1cEtpbmRzYCBtdXN0IG5vdCBzdGFydCB3aXRoIGEgYCRgLiBUaGlzIGtpbmRzXG4gKiBhcmUgcmVzZXJ2ZWQgZm9yIGludGVybmFsIHVzYWdlLlxuICovXG52YXIgTWFya3VwS2luZDtcbihmdW5jdGlvbiAoTWFya3VwS2luZCkge1xuICAgIC8qKlxuICAgICAqIFBsYWluIHRleHQgaXMgc3VwcG9ydGVkIGFzIGEgY29udGVudCBmb3JtYXRcbiAgICAgKi9cbiAgICBNYXJrdXBLaW5kLlBsYWluVGV4dCA9ICdwbGFpbnRleHQnO1xuICAgIC8qKlxuICAgICAqIE1hcmtkb3duIGlzIHN1cHBvcnRlZCBhcyBhIGNvbnRlbnQgZm9ybWF0XG4gICAgICovXG4gICAgTWFya3VwS2luZC5NYXJrZG93biA9ICdtYXJrZG93bic7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsdWUgb2YgdGhlIHtAbGluayBNYXJrdXBLaW5kfSB0eXBlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlID09PSBNYXJrdXBLaW5kLlBsYWluVGV4dCB8fCBjYW5kaWRhdGUgPT09IE1hcmt1cEtpbmQuTWFya2Rvd247XG4gICAgfVxuICAgIE1hcmt1cEtpbmQuaXMgPSBpcztcbn0pKE1hcmt1cEtpbmQgfHwgKE1hcmt1cEtpbmQgPSB7fSkpO1xudmFyIG1haW5fTWFya3VwQ29udGVudDtcbihmdW5jdGlvbiAoTWFya3VwQ29udGVudCkge1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBjb25mb3JtcyB0byB0aGUge0BsaW5rIE1hcmt1cENvbnRlbnR9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwodmFsdWUpICYmIE1hcmt1cEtpbmQuaXMoY2FuZGlkYXRlLmtpbmQpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudmFsdWUpO1xuICAgIH1cbiAgICBNYXJrdXBDb250ZW50LmlzID0gaXM7XG59KShtYWluX01hcmt1cENvbnRlbnQgfHwgKG1haW5fTWFya3VwQ29udGVudCA9IHt9KSk7XG4vKipcbiAqIFRoZSBraW5kIG9mIGEgY29tcGxldGlvbiBlbnRyeS5cbiAqL1xudmFyIG1haW5fQ29tcGxldGlvbkl0ZW1LaW5kO1xuKGZ1bmN0aW9uIChDb21wbGV0aW9uSXRlbUtpbmQpIHtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuVGV4dCA9IDE7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLk1ldGhvZCA9IDI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkZ1bmN0aW9uID0gMztcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuQ29uc3RydWN0b3IgPSA0O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5GaWVsZCA9IDU7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlZhcmlhYmxlID0gNjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuQ2xhc3MgPSA3O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5JbnRlcmZhY2UgPSA4O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5Nb2R1bGUgPSA5O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5Qcm9wZXJ0eSA9IDEwO1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5Vbml0ID0gMTE7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlZhbHVlID0gMTI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkVudW0gPSAxMztcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuS2V5d29yZCA9IDE0O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5TbmlwcGV0ID0gMTU7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkNvbG9yID0gMTY7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkZpbGUgPSAxNztcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuUmVmZXJlbmNlID0gMTg7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkZvbGRlciA9IDE5O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5FbnVtTWVtYmVyID0gMjA7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkNvbnN0YW50ID0gMjE7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlN0cnVjdCA9IDIyO1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5FdmVudCA9IDIzO1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5PcGVyYXRvciA9IDI0O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5UeXBlUGFyYW1ldGVyID0gMjU7XG59KShtYWluX0NvbXBsZXRpb25JdGVtS2luZCB8fCAobWFpbl9Db21wbGV0aW9uSXRlbUtpbmQgPSB7fSkpO1xuLyoqXG4gKiBEZWZpbmVzIHdoZXRoZXIgdGhlIGluc2VydCB0ZXh0IGluIGEgY29tcGxldGlvbiBpdGVtIHNob3VsZCBiZSBpbnRlcnByZXRlZCBhc1xuICogcGxhaW4gdGV4dCBvciBhIHNuaXBwZXQuXG4gKi9cbnZhciBtYWluX0luc2VydFRleHRGb3JtYXQ7XG4oZnVuY3Rpb24gKEluc2VydFRleHRGb3JtYXQpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgcHJpbWFyeSB0ZXh0IHRvIGJlIGluc2VydGVkIGlzIHRyZWF0ZWQgYXMgYSBwbGFpbiBzdHJpbmcuXG4gICAgICovXG4gICAgSW5zZXJ0VGV4dEZvcm1hdC5QbGFpblRleHQgPSAxO1xuICAgIC8qKlxuICAgICAqIFRoZSBwcmltYXJ5IHRleHQgdG8gYmUgaW5zZXJ0ZWQgaXMgdHJlYXRlZCBhcyBhIHNuaXBwZXQuXG4gICAgICpcbiAgICAgKiBBIHNuaXBwZXQgY2FuIGRlZmluZSB0YWIgc3RvcHMgYW5kIHBsYWNlaG9sZGVycyB3aXRoIGAkMWAsIGAkMmBcbiAgICAgKiBhbmQgYCR7Mzpmb299YC4gYCQwYCBkZWZpbmVzIHRoZSBmaW5hbCB0YWIgc3RvcCwgaXQgZGVmYXVsdHMgdG9cbiAgICAgKiB0aGUgZW5kIG9mIHRoZSBzbmlwcGV0LiBQbGFjZWhvbGRlcnMgd2l0aCBlcXVhbCBpZGVudGlmaWVycyBhcmUgbGlua2VkLFxuICAgICAqIHRoYXQgaXMgdHlwaW5nIGluIG9uZSB3aWxsIHVwZGF0ZSBvdGhlcnMgdG9vLlxuICAgICAqXG4gICAgICogU2VlIGFsc286IGh0dHBzOi8vbWljcm9zb2Z0LmdpdGh1Yi5pby9sYW5ndWFnZS1zZXJ2ZXItcHJvdG9jb2wvc3BlY2lmaWNhdGlvbnMvc3BlY2lmaWNhdGlvbi1jdXJyZW50LyNzbmlwcGV0X3N5bnRheFxuICAgICAqL1xuICAgIEluc2VydFRleHRGb3JtYXQuU25pcHBldCA9IDI7XG59KShtYWluX0luc2VydFRleHRGb3JtYXQgfHwgKG1haW5fSW5zZXJ0VGV4dEZvcm1hdCA9IHt9KSk7XG4vKipcbiAqIENvbXBsZXRpb24gaXRlbSB0YWdzIGFyZSBleHRyYSBhbm5vdGF0aW9ucyB0aGF0IHR3ZWFrIHRoZSByZW5kZXJpbmcgb2YgYSBjb21wbGV0aW9uXG4gKiBpdGVtLlxuICpcbiAqIEBzaW5jZSAzLjE1LjBcbiAqL1xudmFyIENvbXBsZXRpb25JdGVtVGFnO1xuKGZ1bmN0aW9uIChDb21wbGV0aW9uSXRlbVRhZykge1xuICAgIC8qKlxuICAgICAqIFJlbmRlciBhIGNvbXBsZXRpb24gYXMgb2Jzb2xldGUsIHVzdWFsbHkgdXNpbmcgYSBzdHJpa2Utb3V0LlxuICAgICAqL1xuICAgIENvbXBsZXRpb25JdGVtVGFnLkRlcHJlY2F0ZWQgPSAxO1xufSkoQ29tcGxldGlvbkl0ZW1UYWcgfHwgKENvbXBsZXRpb25JdGVtVGFnID0ge30pKTtcbi8qKlxuICogVGhlIEluc2VydFJlcGxhY2VFZGl0IG5hbWVzcGFjZSBwcm92aWRlcyBmdW5jdGlvbnMgdG8gZGVhbCB3aXRoIGluc2VydCAvIHJlcGxhY2UgZWRpdHMuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG52YXIgSW5zZXJ0UmVwbGFjZUVkaXQ7XG4oZnVuY3Rpb24gKEluc2VydFJlcGxhY2VFZGl0KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnNlcnQgLyByZXBsYWNlIGVkaXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUobmV3VGV4dCwgaW5zZXJ0LCByZXBsYWNlKSB7XG4gICAgICAgIHJldHVybiB7IG5ld1RleHQsIGluc2VydCwgcmVwbGFjZSB9O1xuICAgIH1cbiAgICBJbnNlcnRSZXBsYWNlRWRpdC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBJbnNlcnRSZXBsYWNlRWRpdH0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIElzLnN0cmluZyhjYW5kaWRhdGUubmV3VGV4dCkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLmluc2VydCkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJlcGxhY2UpO1xuICAgIH1cbiAgICBJbnNlcnRSZXBsYWNlRWRpdC5pcyA9IGlzO1xufSkoSW5zZXJ0UmVwbGFjZUVkaXQgfHwgKEluc2VydFJlcGxhY2VFZGl0ID0ge30pKTtcbi8qKlxuICogSG93IHdoaXRlc3BhY2UgYW5kIGluZGVudGF0aW9uIGlzIGhhbmRsZWQgZHVyaW5nIGNvbXBsZXRpb25cbiAqIGl0ZW0gaW5zZXJ0aW9uLlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIEluc2VydFRleHRNb2RlO1xuKGZ1bmN0aW9uIChJbnNlcnRUZXh0TW9kZSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBpbnNlcnRpb24gb3IgcmVwbGFjZSBzdHJpbmdzIGlzIHRha2VuIGFzIGl0IGlzLiBJZiB0aGVcbiAgICAgKiB2YWx1ZSBpcyBtdWx0aSBsaW5lIHRoZSBsaW5lcyBiZWxvdyB0aGUgY3Vyc29yIHdpbGwgYmVcbiAgICAgKiBpbnNlcnRlZCB1c2luZyB0aGUgaW5kZW50YXRpb24gZGVmaW5lZCBpbiB0aGUgc3RyaW5nIHZhbHVlLlxuICAgICAqIFRoZSBjbGllbnQgd2lsbCBub3QgYXBwbHkgYW55IGtpbmQgb2YgYWRqdXN0bWVudHMgdG8gdGhlXG4gICAgICogc3RyaW5nLlxuICAgICAqL1xuICAgIEluc2VydFRleHRNb2RlLmFzSXMgPSAxO1xuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3IgYWRqdXN0cyBsZWFkaW5nIHdoaXRlc3BhY2Ugb2YgbmV3IGxpbmVzIHNvIHRoYXRcbiAgICAgKiB0aGV5IG1hdGNoIHRoZSBpbmRlbnRhdGlvbiB1cCB0byB0aGUgY3Vyc29yIG9mIHRoZSBsaW5lIGZvclxuICAgICAqIHdoaWNoIHRoZSBpdGVtIGlzIGFjY2VwdGVkLlxuICAgICAqXG4gICAgICogQ29uc2lkZXIgYSBsaW5lIGxpa2UgdGhpczogPDJ0YWJzPjxjdXJzb3I+PDN0YWJzPmZvby4gQWNjZXB0aW5nIGFcbiAgICAgKiBtdWx0aSBsaW5lIGNvbXBsZXRpb24gaXRlbSBpcyBpbmRlbnRlZCB1c2luZyAyIHRhYnMgYW5kIGFsbFxuICAgICAqIGZvbGxvd2luZyBsaW5lcyBpbnNlcnRlZCB3aWxsIGJlIGluZGVudGVkIHVzaW5nIDIgdGFicyBhcyB3ZWxsLlxuICAgICAqL1xuICAgIEluc2VydFRleHRNb2RlLmFkanVzdEluZGVudGF0aW9uID0gMjtcbn0pKEluc2VydFRleHRNb2RlIHx8IChJbnNlcnRUZXh0TW9kZSA9IHt9KSk7XG52YXIgQ29tcGxldGlvbkl0ZW1MYWJlbERldGFpbHM7XG4oZnVuY3Rpb24gKENvbXBsZXRpb25JdGVtTGFiZWxEZXRhaWxzKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgKElzLnN0cmluZyhjYW5kaWRhdGUuZGV0YWlsKSB8fCBjYW5kaWRhdGUuZGV0YWlsID09PSB1bmRlZmluZWQpICYmXG4gICAgICAgICAgICAoSXMuc3RyaW5nKGNhbmRpZGF0ZS5kZXNjcmlwdGlvbikgfHwgY2FuZGlkYXRlLmRlc2NyaXB0aW9uID09PSB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBDb21wbGV0aW9uSXRlbUxhYmVsRGV0YWlscy5pcyA9IGlzO1xufSkoQ29tcGxldGlvbkl0ZW1MYWJlbERldGFpbHMgfHwgKENvbXBsZXRpb25JdGVtTGFiZWxEZXRhaWxzID0ge30pKTtcbi8qKlxuICogVGhlIENvbXBsZXRpb25JdGVtIG5hbWVzcGFjZSBwcm92aWRlcyBmdW5jdGlvbnMgdG8gZGVhbCB3aXRoXG4gKiBjb21wbGV0aW9uIGl0ZW1zLlxuICovXG52YXIgQ29tcGxldGlvbkl0ZW07XG4oZnVuY3Rpb24gKENvbXBsZXRpb25JdGVtKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgY29tcGxldGlvbiBpdGVtIGFuZCBzZWVkIGl0IHdpdGggYSBsYWJlbC5cbiAgICAgKiBAcGFyYW0gbGFiZWwgVGhlIGNvbXBsZXRpb24gaXRlbSdzIGxhYmVsXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKGxhYmVsKSB7XG4gICAgICAgIHJldHVybiB7IGxhYmVsIH07XG4gICAgfVxuICAgIENvbXBsZXRpb25JdGVtLmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKENvbXBsZXRpb25JdGVtIHx8IChDb21wbGV0aW9uSXRlbSA9IHt9KSk7XG4vKipcbiAqIFRoZSBDb21wbGV0aW9uTGlzdCBuYW1lc3BhY2UgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGRlYWwgd2l0aFxuICogY29tcGxldGlvbiBsaXN0cy5cbiAqL1xudmFyIENvbXBsZXRpb25MaXN0O1xuKGZ1bmN0aW9uIChDb21wbGV0aW9uTGlzdCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgY29tcGxldGlvbiBsaXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGl0ZW1zIFRoZSBjb21wbGV0aW9uIGl0ZW1zLlxuICAgICAqIEBwYXJhbSBpc0luY29tcGxldGUgVGhlIGxpc3QgaXMgbm90IGNvbXBsZXRlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShpdGVtcywgaXNJbmNvbXBsZXRlKSB7XG4gICAgICAgIHJldHVybiB7IGl0ZW1zOiBpdGVtcyA/IGl0ZW1zIDogW10sIGlzSW5jb21wbGV0ZTogISFpc0luY29tcGxldGUgfTtcbiAgICB9XG4gICAgQ29tcGxldGlvbkxpc3QuY3JlYXRlID0gY3JlYXRlO1xufSkoQ29tcGxldGlvbkxpc3QgfHwgKENvbXBsZXRpb25MaXN0ID0ge30pKTtcbnZhciBtYWluX01hcmtlZFN0cmluZztcbihmdW5jdGlvbiAoTWFya2VkU3RyaW5nKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG1hcmtlZCBzdHJpbmcgZnJvbSBwbGFpbiB0ZXh0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBsYWluVGV4dCBUaGUgcGxhaW4gdGV4dC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmcm9tUGxhaW5UZXh0KHBsYWluVGV4dCkge1xuICAgICAgICByZXR1cm4gcGxhaW5UZXh0LnJlcGxhY2UoL1tcXFxcYCpfe31bXFxdKCkjK1xcLS4hXS9nLCAnXFxcXCQmJyk7IC8vIGVzY2FwZSBtYXJrZG93biBzeW50YXggdG9rZW5zOiBodHRwOi8vZGFyaW5nZmlyZWJhbGwubmV0L3Byb2plY3RzL21hcmtkb3duL3N5bnRheCNiYWNrc2xhc2hcbiAgICB9XG4gICAgTWFya2VkU3RyaW5nLmZyb21QbGFpblRleHQgPSBmcm9tUGxhaW5UZXh0O1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBjb25mb3JtcyB0byB0aGUge0BsaW5rIE1hcmtlZFN0cmluZ30gdHlwZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLnN0cmluZyhjYW5kaWRhdGUpIHx8IChJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5sYW5ndWFnZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS52YWx1ZSkpO1xuICAgIH1cbiAgICBNYXJrZWRTdHJpbmcuaXMgPSBpcztcbn0pKG1haW5fTWFya2VkU3RyaW5nIHx8IChtYWluX01hcmtlZFN0cmluZyA9IHt9KSk7XG52YXIgSG92ZXI7XG4oZnVuY3Rpb24gKEhvdmVyKSB7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgSG92ZXJ9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiAhIWNhbmRpZGF0ZSAmJiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgKG1haW5fTWFya3VwQ29udGVudC5pcyhjYW5kaWRhdGUuY29udGVudHMpIHx8XG4gICAgICAgICAgICBtYWluX01hcmtlZFN0cmluZy5pcyhjYW5kaWRhdGUuY29udGVudHMpIHx8XG4gICAgICAgICAgICBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5jb250ZW50cywgbWFpbl9NYXJrZWRTdHJpbmcuaXMpKSAmJiAodmFsdWUucmFuZ2UgPT09IHVuZGVmaW5lZCB8fCBSYW5nZS5pcyh2YWx1ZS5yYW5nZSkpO1xuICAgIH1cbiAgICBIb3Zlci5pcyA9IGlzO1xufSkoSG92ZXIgfHwgKEhvdmVyID0ge30pKTtcbi8qKlxuICogVGhlIFBhcmFtZXRlckluZm9ybWF0aW9uIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIFBhcmFtZXRlckluZm9ybWF0aW9ufSBsaXRlcmFscy5cbiAqL1xudmFyIFBhcmFtZXRlckluZm9ybWF0aW9uO1xuKGZ1bmN0aW9uIChQYXJhbWV0ZXJJbmZvcm1hdGlvbikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgcGFyYW1ldGVyIGluZm9ybWF0aW9uIGxpdGVyYWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGFiZWwgQSBsYWJlbCBzdHJpbmcuXG4gICAgICogQHBhcmFtIGRvY3VtZW50YXRpb24gQSBkb2Mgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsYWJlbCwgZG9jdW1lbnRhdGlvbikge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnRhdGlvbiA/IHsgbGFiZWwsIGRvY3VtZW50YXRpb24gfSA6IHsgbGFiZWwgfTtcbiAgICB9XG4gICAgUGFyYW1ldGVySW5mb3JtYXRpb24uY3JlYXRlID0gY3JlYXRlO1xufSkoUGFyYW1ldGVySW5mb3JtYXRpb24gfHwgKFBhcmFtZXRlckluZm9ybWF0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIFNpZ25hdHVyZUluZm9ybWF0aW9uIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIFNpZ25hdHVyZUluZm9ybWF0aW9ufSBsaXRlcmFscy5cbiAqL1xudmFyIFNpZ25hdHVyZUluZm9ybWF0aW9uO1xuKGZ1bmN0aW9uIChTaWduYXR1cmVJbmZvcm1hdGlvbikge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsYWJlbCwgZG9jdW1lbnRhdGlvbiwgLi4ucGFyYW1ldGVycykge1xuICAgICAgICBsZXQgcmVzdWx0ID0geyBsYWJlbCB9O1xuICAgICAgICBpZiAoSXMuZGVmaW5lZChkb2N1bWVudGF0aW9uKSkge1xuICAgICAgICAgICAgcmVzdWx0LmRvY3VtZW50YXRpb24gPSBkb2N1bWVudGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKHBhcmFtZXRlcnMpKSB7XG4gICAgICAgICAgICByZXN1bHQucGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucGFyYW1ldGVycyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIFNpZ25hdHVyZUluZm9ybWF0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKFNpZ25hdHVyZUluZm9ybWF0aW9uIHx8IChTaWduYXR1cmVJbmZvcm1hdGlvbiA9IHt9KSk7XG4vKipcbiAqIEEgZG9jdW1lbnQgaGlnaGxpZ2h0IGtpbmQuXG4gKi9cbnZhciBEb2N1bWVudEhpZ2hsaWdodEtpbmQ7XG4oZnVuY3Rpb24gKERvY3VtZW50SGlnaGxpZ2h0S2luZCkge1xuICAgIC8qKlxuICAgICAqIEEgdGV4dHVhbCBvY2N1cnJlbmNlLlxuICAgICAqL1xuICAgIERvY3VtZW50SGlnaGxpZ2h0S2luZC5UZXh0ID0gMTtcbiAgICAvKipcbiAgICAgKiBSZWFkLWFjY2VzcyBvZiBhIHN5bWJvbCwgbGlrZSByZWFkaW5nIGEgdmFyaWFibGUuXG4gICAgICovXG4gICAgRG9jdW1lbnRIaWdobGlnaHRLaW5kLlJlYWQgPSAyO1xuICAgIC8qKlxuICAgICAqIFdyaXRlLWFjY2VzcyBvZiBhIHN5bWJvbCwgbGlrZSB3cml0aW5nIHRvIGEgdmFyaWFibGUuXG4gICAgICovXG4gICAgRG9jdW1lbnRIaWdobGlnaHRLaW5kLldyaXRlID0gMztcbn0pKERvY3VtZW50SGlnaGxpZ2h0S2luZCB8fCAoRG9jdW1lbnRIaWdobGlnaHRLaW5kID0ge30pKTtcbi8qKlxuICogRG9jdW1lbnRIaWdobGlnaHQgbmFtZXNwYWNlIHRvIHByb3ZpZGUgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBEb2N1bWVudEhpZ2hsaWdodH0gbGl0ZXJhbHMuXG4gKi9cbnZhciBEb2N1bWVudEhpZ2hsaWdodDtcbihmdW5jdGlvbiAoRG9jdW1lbnRIaWdobGlnaHQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBEb2N1bWVudEhpZ2hsaWdodCBvYmplY3QuXG4gICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSB0aGUgaGlnaGxpZ2h0IGFwcGxpZXMgdG8uXG4gICAgICogQHBhcmFtIGtpbmQgVGhlIGhpZ2hsaWdodCBraW5kXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCBraW5kKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7IHJhbmdlIH07XG4gICAgICAgIGlmIChJcy5udW1iZXIoa2luZCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5raW5kID0ga2luZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBEb2N1bWVudEhpZ2hsaWdodC5jcmVhdGUgPSBjcmVhdGU7XG59KShEb2N1bWVudEhpZ2hsaWdodCB8fCAoRG9jdW1lbnRIaWdobGlnaHQgPSB7fSkpO1xuLyoqXG4gKiBBIHN5bWJvbCBraW5kLlxuICovXG52YXIgU3ltYm9sS2luZDtcbihmdW5jdGlvbiAoU3ltYm9sS2luZCkge1xuICAgIFN5bWJvbEtpbmQuRmlsZSA9IDE7XG4gICAgU3ltYm9sS2luZC5Nb2R1bGUgPSAyO1xuICAgIFN5bWJvbEtpbmQuTmFtZXNwYWNlID0gMztcbiAgICBTeW1ib2xLaW5kLlBhY2thZ2UgPSA0O1xuICAgIFN5bWJvbEtpbmQuQ2xhc3MgPSA1O1xuICAgIFN5bWJvbEtpbmQuTWV0aG9kID0gNjtcbiAgICBTeW1ib2xLaW5kLlByb3BlcnR5ID0gNztcbiAgICBTeW1ib2xLaW5kLkZpZWxkID0gODtcbiAgICBTeW1ib2xLaW5kLkNvbnN0cnVjdG9yID0gOTtcbiAgICBTeW1ib2xLaW5kLkVudW0gPSAxMDtcbiAgICBTeW1ib2xLaW5kLkludGVyZmFjZSA9IDExO1xuICAgIFN5bWJvbEtpbmQuRnVuY3Rpb24gPSAxMjtcbiAgICBTeW1ib2xLaW5kLlZhcmlhYmxlID0gMTM7XG4gICAgU3ltYm9sS2luZC5Db25zdGFudCA9IDE0O1xuICAgIFN5bWJvbEtpbmQuU3RyaW5nID0gMTU7XG4gICAgU3ltYm9sS2luZC5OdW1iZXIgPSAxNjtcbiAgICBTeW1ib2xLaW5kLkJvb2xlYW4gPSAxNztcbiAgICBTeW1ib2xLaW5kLkFycmF5ID0gMTg7XG4gICAgU3ltYm9sS2luZC5PYmplY3QgPSAxOTtcbiAgICBTeW1ib2xLaW5kLktleSA9IDIwO1xuICAgIFN5bWJvbEtpbmQuTnVsbCA9IDIxO1xuICAgIFN5bWJvbEtpbmQuRW51bU1lbWJlciA9IDIyO1xuICAgIFN5bWJvbEtpbmQuU3RydWN0ID0gMjM7XG4gICAgU3ltYm9sS2luZC5FdmVudCA9IDI0O1xuICAgIFN5bWJvbEtpbmQuT3BlcmF0b3IgPSAyNTtcbiAgICBTeW1ib2xLaW5kLlR5cGVQYXJhbWV0ZXIgPSAyNjtcbn0pKFN5bWJvbEtpbmQgfHwgKFN5bWJvbEtpbmQgPSB7fSkpO1xuLyoqXG4gKiBTeW1ib2wgdGFncyBhcmUgZXh0cmEgYW5ub3RhdGlvbnMgdGhhdCB0d2VhayB0aGUgcmVuZGVyaW5nIG9mIGEgc3ltYm9sLlxuICpcbiAqIEBzaW5jZSAzLjE2XG4gKi9cbnZhciBTeW1ib2xUYWc7XG4oZnVuY3Rpb24gKFN5bWJvbFRhZykge1xuICAgIC8qKlxuICAgICAqIFJlbmRlciBhIHN5bWJvbCBhcyBvYnNvbGV0ZSwgdXN1YWxseSB1c2luZyBhIHN0cmlrZS1vdXQuXG4gICAgICovXG4gICAgU3ltYm9sVGFnLkRlcHJlY2F0ZWQgPSAxO1xufSkoU3ltYm9sVGFnIHx8IChTeW1ib2xUYWcgPSB7fSkpO1xudmFyIFN5bWJvbEluZm9ybWF0aW9uO1xuKGZ1bmN0aW9uIChTeW1ib2xJbmZvcm1hdGlvbikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgc3ltYm9sIGluZm9ybWF0aW9uIGxpdGVyYWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSBraW5kIFRoZSBraW5kIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSBvZiB0aGUgbG9jYXRpb24gb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSByZXNvdXJjZSBvZiB0aGUgbG9jYXRpb24gb2Ygc3ltYm9sLlxuICAgICAqIEBwYXJhbSBjb250YWluZXJOYW1lIFRoZSBuYW1lIG9mIHRoZSBzeW1ib2wgY29udGFpbmluZyB0aGUgc3ltYm9sLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShuYW1lLCBraW5kLCByYW5nZSwgdXJpLCBjb250YWluZXJOYW1lKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgIGxvY2F0aW9uOiB7IHVyaSwgcmFuZ2UgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoY29udGFpbmVyTmFtZSkge1xuICAgICAgICAgICAgcmVzdWx0LmNvbnRhaW5lck5hbWUgPSBjb250YWluZXJOYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIFN5bWJvbEluZm9ybWF0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKFN5bWJvbEluZm9ybWF0aW9uIHx8IChTeW1ib2xJbmZvcm1hdGlvbiA9IHt9KSk7XG52YXIgV29ya3NwYWNlU3ltYm9sO1xuKGZ1bmN0aW9uIChXb3Jrc3BhY2VTeW1ib2wpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgd29ya3NwYWNlIHN5bWJvbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIGtpbmQgVGhlIGtpbmQgb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSByZXNvdXJjZSBvZiB0aGUgbG9jYXRpb24gb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gcmFuZ2UgQW4gb3B0aW9ucyByYW5nZSBvZiB0aGUgbG9jYXRpb24uXG4gICAgICogQHJldHVybnMgQSBXb3Jrc3BhY2VTeW1ib2wuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKG5hbWUsIGtpbmQsIHVyaSwgcmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8geyBuYW1lLCBraW5kLCBsb2NhdGlvbjogeyB1cmksIHJhbmdlIH0gfVxuICAgICAgICAgICAgOiB7IG5hbWUsIGtpbmQsIGxvY2F0aW9uOiB7IHVyaSB9IH07XG4gICAgfVxuICAgIFdvcmtzcGFjZVN5bWJvbC5jcmVhdGUgPSBjcmVhdGU7XG59KShXb3Jrc3BhY2VTeW1ib2wgfHwgKFdvcmtzcGFjZVN5bWJvbCA9IHt9KSk7XG52YXIgRG9jdW1lbnRTeW1ib2w7XG4oZnVuY3Rpb24gKERvY3VtZW50U3ltYm9sKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBzeW1ib2wgaW5mb3JtYXRpb24gbGl0ZXJhbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIGRldGFpbCBUaGUgZGV0YWlsIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIGtpbmQgVGhlIGtpbmQgb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIHNlbGVjdGlvblJhbmdlIFRoZSBzZWxlY3Rpb25SYW5nZSBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSBjaGlsZHJlbiBDaGlsZHJlbiBvZiB0aGUgc3ltYm9sLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShuYW1lLCBkZXRhaWwsIGtpbmQsIHJhbmdlLCBzZWxlY3Rpb25SYW5nZSwgY2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBkZXRhaWwsXG4gICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgcmFuZ2UsXG4gICAgICAgICAgICBzZWxlY3Rpb25SYW5nZVxuICAgICAgICB9O1xuICAgICAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgRG9jdW1lbnRTeW1ib2wuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgRG9jdW1lbnRTeW1ib2x9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiZcbiAgICAgICAgICAgIElzLnN0cmluZyhjYW5kaWRhdGUubmFtZSkgJiYgSXMubnVtYmVyKGNhbmRpZGF0ZS5raW5kKSAmJlxuICAgICAgICAgICAgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUuc2VsZWN0aW9uUmFuZ2UpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmRldGFpbCA9PT0gdW5kZWZpbmVkIHx8IElzLnN0cmluZyhjYW5kaWRhdGUuZGV0YWlsKSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuZGVwcmVjYXRlZCA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLmRlcHJlY2F0ZWQpKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5jaGlsZHJlbiA9PT0gdW5kZWZpbmVkIHx8IEFycmF5LmlzQXJyYXkoY2FuZGlkYXRlLmNoaWxkcmVuKSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUudGFncyA9PT0gdW5kZWZpbmVkIHx8IEFycmF5LmlzQXJyYXkoY2FuZGlkYXRlLnRhZ3MpKTtcbiAgICB9XG4gICAgRG9jdW1lbnRTeW1ib2wuaXMgPSBpcztcbn0pKERvY3VtZW50U3ltYm9sIHx8IChEb2N1bWVudFN5bWJvbCA9IHt9KSk7XG4vKipcbiAqIEEgc2V0IG9mIHByZWRlZmluZWQgY29kZSBhY3Rpb24ga2luZHNcbiAqL1xudmFyIENvZGVBY3Rpb25LaW5kO1xuKGZ1bmN0aW9uIChDb2RlQWN0aW9uS2luZCkge1xuICAgIC8qKlxuICAgICAqIEVtcHR5IGtpbmQuXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuRW1wdHkgPSAnJztcbiAgICAvKipcbiAgICAgKiBCYXNlIGtpbmQgZm9yIHF1aWNrZml4IGFjdGlvbnM6ICdxdWlja2ZpeCdcbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5RdWlja0ZpeCA9ICdxdWlja2ZpeCc7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciByZWZhY3RvcmluZyBhY3Rpb25zOiAncmVmYWN0b3InXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuUmVmYWN0b3IgPSAncmVmYWN0b3InO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3IgcmVmYWN0b3JpbmcgZXh0cmFjdGlvbiBhY3Rpb25zOiAncmVmYWN0b3IuZXh0cmFjdCdcbiAgICAgKlxuICAgICAqIEV4YW1wbGUgZXh0cmFjdCBhY3Rpb25zOlxuICAgICAqXG4gICAgICogLSBFeHRyYWN0IG1ldGhvZFxuICAgICAqIC0gRXh0cmFjdCBmdW5jdGlvblxuICAgICAqIC0gRXh0cmFjdCB2YXJpYWJsZVxuICAgICAqIC0gRXh0cmFjdCBpbnRlcmZhY2UgZnJvbSBjbGFzc1xuICAgICAqIC0gLi4uXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuUmVmYWN0b3JFeHRyYWN0ID0gJ3JlZmFjdG9yLmV4dHJhY3QnO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3IgcmVmYWN0b3JpbmcgaW5saW5lIGFjdGlvbnM6ICdyZWZhY3Rvci5pbmxpbmUnXG4gICAgICpcbiAgICAgKiBFeGFtcGxlIGlubGluZSBhY3Rpb25zOlxuICAgICAqXG4gICAgICogLSBJbmxpbmUgZnVuY3Rpb25cbiAgICAgKiAtIElubGluZSB2YXJpYWJsZVxuICAgICAqIC0gSW5saW5lIGNvbnN0YW50XG4gICAgICogLSAuLi5cbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5SZWZhY3RvcklubGluZSA9ICdyZWZhY3Rvci5pbmxpbmUnO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3IgcmVmYWN0b3JpbmcgcmV3cml0ZSBhY3Rpb25zOiAncmVmYWN0b3IucmV3cml0ZSdcbiAgICAgKlxuICAgICAqIEV4YW1wbGUgcmV3cml0ZSBhY3Rpb25zOlxuICAgICAqXG4gICAgICogLSBDb252ZXJ0IEphdmFTY3JpcHQgZnVuY3Rpb24gdG8gY2xhc3NcbiAgICAgKiAtIEFkZCBvciByZW1vdmUgcGFyYW1ldGVyXG4gICAgICogLSBFbmNhcHN1bGF0ZSBmaWVsZFxuICAgICAqIC0gTWFrZSBtZXRob2Qgc3RhdGljXG4gICAgICogLSBNb3ZlIG1ldGhvZCB0byBiYXNlIGNsYXNzXG4gICAgICogLSAuLi5cbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5SZWZhY3RvclJld3JpdGUgPSAncmVmYWN0b3IucmV3cml0ZSc7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciBzb3VyY2UgYWN0aW9uczogYHNvdXJjZWBcbiAgICAgKlxuICAgICAqIFNvdXJjZSBjb2RlIGFjdGlvbnMgYXBwbHkgdG8gdGhlIGVudGlyZSBmaWxlLlxuICAgICAqL1xuICAgIENvZGVBY3Rpb25LaW5kLlNvdXJjZSA9ICdzb3VyY2UnO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3IgYW4gb3JnYW5pemUgaW1wb3J0cyBzb3VyY2UgYWN0aW9uOiBgc291cmNlLm9yZ2FuaXplSW1wb3J0c2BcbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5Tb3VyY2VPcmdhbml6ZUltcG9ydHMgPSAnc291cmNlLm9yZ2FuaXplSW1wb3J0cyc7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciBhdXRvLWZpeCBzb3VyY2UgYWN0aW9uczogYHNvdXJjZS5maXhBbGxgLlxuICAgICAqXG4gICAgICogRml4IGFsbCBhY3Rpb25zIGF1dG9tYXRpY2FsbHkgZml4IGVycm9ycyB0aGF0IGhhdmUgYSBjbGVhciBmaXggdGhhdCBkbyBub3QgcmVxdWlyZSB1c2VyIGlucHV0LlxuICAgICAqIFRoZXkgc2hvdWxkIG5vdCBzdXBwcmVzcyBlcnJvcnMgb3IgcGVyZm9ybSB1bnNhZmUgZml4ZXMgc3VjaCBhcyBnZW5lcmF0aW5nIG5ldyB0eXBlcyBvciBjbGFzc2VzLlxuICAgICAqXG4gICAgICogQHNpbmNlIDMuMTUuMFxuICAgICAqL1xuICAgIENvZGVBY3Rpb25LaW5kLlNvdXJjZUZpeEFsbCA9ICdzb3VyY2UuZml4QWxsJztcbn0pKENvZGVBY3Rpb25LaW5kIHx8IChDb2RlQWN0aW9uS2luZCA9IHt9KSk7XG4vKipcbiAqIFRoZSByZWFzb24gd2h5IGNvZGUgYWN0aW9ucyB3ZXJlIHJlcXVlc3RlZC5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBDb2RlQWN0aW9uVHJpZ2dlcktpbmQ7XG4oZnVuY3Rpb24gKENvZGVBY3Rpb25UcmlnZ2VyS2luZCkge1xuICAgIC8qKlxuICAgICAqIENvZGUgYWN0aW9ucyB3ZXJlIGV4cGxpY2l0bHkgcmVxdWVzdGVkIGJ5IHRoZSB1c2VyIG9yIGJ5IGFuIGV4dGVuc2lvbi5cbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uVHJpZ2dlcktpbmQuSW52b2tlZCA9IDE7XG4gICAgLyoqXG4gICAgICogQ29kZSBhY3Rpb25zIHdlcmUgcmVxdWVzdGVkIGF1dG9tYXRpY2FsbHkuXG4gICAgICpcbiAgICAgKiBUaGlzIHR5cGljYWxseSBoYXBwZW5zIHdoZW4gY3VycmVudCBzZWxlY3Rpb24gaW4gYSBmaWxlIGNoYW5nZXMsIGJ1dCBjYW5cbiAgICAgKiBhbHNvIGJlIHRyaWdnZXJlZCB3aGVuIGZpbGUgY29udGVudCBjaGFuZ2VzLlxuICAgICAqL1xuICAgIENvZGVBY3Rpb25UcmlnZ2VyS2luZC5BdXRvbWF0aWMgPSAyO1xufSkoQ29kZUFjdGlvblRyaWdnZXJLaW5kIHx8IChDb2RlQWN0aW9uVHJpZ2dlcktpbmQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29kZUFjdGlvbkNvbnRleHQgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgQ29kZUFjdGlvbkNvbnRleHR9IGxpdGVyYWxzLlxuICovXG52YXIgQ29kZUFjdGlvbkNvbnRleHQ7XG4oZnVuY3Rpb24gKENvZGVBY3Rpb25Db250ZXh0KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBDb2RlQWN0aW9uQ29udGV4dCBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShkaWFnbm9zdGljcywgb25seSwgdHJpZ2dlcktpbmQpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgZGlhZ25vc3RpY3MgfTtcbiAgICAgICAgaWYgKG9ubHkgIT09IHVuZGVmaW5lZCAmJiBvbmx5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQub25seSA9IG9ubHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyaWdnZXJLaW5kICE9PSB1bmRlZmluZWQgJiYgdHJpZ2dlcktpbmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC50cmlnZ2VyS2luZCA9IHRyaWdnZXJLaW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIENvZGVBY3Rpb25Db250ZXh0LmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIENvZGVBY3Rpb25Db250ZXh0fSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLmRpYWdub3N0aWNzLCBEaWFnbm9zdGljLmlzKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS5vbmx5ID09PSB1bmRlZmluZWQgfHwgSXMudHlwZWRBcnJheShjYW5kaWRhdGUub25seSwgSXMuc3RyaW5nKSlcbiAgICAgICAgICAgICYmIChjYW5kaWRhdGUudHJpZ2dlcktpbmQgPT09IHVuZGVmaW5lZCB8fCBjYW5kaWRhdGUudHJpZ2dlcktpbmQgPT09IENvZGVBY3Rpb25UcmlnZ2VyS2luZC5JbnZva2VkIHx8IGNhbmRpZGF0ZS50cmlnZ2VyS2luZCA9PT0gQ29kZUFjdGlvblRyaWdnZXJLaW5kLkF1dG9tYXRpYyk7XG4gICAgfVxuICAgIENvZGVBY3Rpb25Db250ZXh0LmlzID0gaXM7XG59KShDb2RlQWN0aW9uQ29udGV4dCB8fCAoQ29kZUFjdGlvbkNvbnRleHQgPSB7fSkpO1xudmFyIENvZGVBY3Rpb247XG4oZnVuY3Rpb24gKENvZGVBY3Rpb24pIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUodGl0bGUsIGtpbmRPckNvbW1hbmRPckVkaXQsIGtpbmQpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgdGl0bGUgfTtcbiAgICAgICAgbGV0IGNoZWNrS2luZCA9IHRydWU7XG4gICAgICAgIGlmICh0eXBlb2Yga2luZE9yQ29tbWFuZE9yRWRpdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNoZWNrS2luZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmVzdWx0LmtpbmQgPSBraW5kT3JDb21tYW5kT3JFZGl0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKENvbW1hbmQuaXMoa2luZE9yQ29tbWFuZE9yRWRpdCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jb21tYW5kID0ga2luZE9yQ29tbWFuZE9yRWRpdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5lZGl0ID0ga2luZE9yQ29tbWFuZE9yRWRpdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hlY2tLaW5kICYmIGtpbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmtpbmQgPSBraW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIENvZGVBY3Rpb24uY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnRpdGxlKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5kaWFnbm9zdGljcyA9PT0gdW5kZWZpbmVkIHx8IElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLmRpYWdub3N0aWNzLCBEaWFnbm9zdGljLmlzKSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUua2luZCA9PT0gdW5kZWZpbmVkIHx8IElzLnN0cmluZyhjYW5kaWRhdGUua2luZCkpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmVkaXQgIT09IHVuZGVmaW5lZCB8fCBjYW5kaWRhdGUuY29tbWFuZCAhPT0gdW5kZWZpbmVkKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5jb21tYW5kID09PSB1bmRlZmluZWQgfHwgQ29tbWFuZC5pcyhjYW5kaWRhdGUuY29tbWFuZCkpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmlzUHJlZmVycmVkID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUuaXNQcmVmZXJyZWQpKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5lZGl0ID09PSB1bmRlZmluZWQgfHwgV29ya3NwYWNlRWRpdC5pcyhjYW5kaWRhdGUuZWRpdCkpO1xuICAgIH1cbiAgICBDb2RlQWN0aW9uLmlzID0gaXM7XG59KShDb2RlQWN0aW9uIHx8IChDb2RlQWN0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIENvZGVMZW5zIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIENvZGVMZW5zfSBsaXRlcmFscy5cbiAqL1xudmFyIENvZGVMZW5zO1xuKGZ1bmN0aW9uIChDb2RlTGVucykge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ29kZUxlbnMgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIGRhdGEpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgcmFuZ2UgfTtcbiAgICAgICAgaWYgKElzLmRlZmluZWQoZGF0YSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5kYXRhID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBDb2RlTGVucy5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBDb2RlTGVuc30gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLmNvbW1hbmQpIHx8IENvbW1hbmQuaXMoY2FuZGlkYXRlLmNvbW1hbmQpKTtcbiAgICB9XG4gICAgQ29kZUxlbnMuaXMgPSBpcztcbn0pKENvZGVMZW5zIHx8IChDb2RlTGVucyA9IHt9KSk7XG4vKipcbiAqIFRoZSBGb3JtYXR0aW5nT3B0aW9ucyBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBGb3JtYXR0aW5nT3B0aW9uc30gbGl0ZXJhbHMuXG4gKi9cbnZhciBGb3JtYXR0aW5nT3B0aW9ucztcbihmdW5jdGlvbiAoRm9ybWF0dGluZ09wdGlvbnMpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEZvcm1hdHRpbmdPcHRpb25zIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHRhYlNpemUsIGluc2VydFNwYWNlcykge1xuICAgICAgICByZXR1cm4geyB0YWJTaXplLCBpbnNlcnRTcGFjZXMgfTtcbiAgICB9XG4gICAgRm9ybWF0dGluZ09wdGlvbnMuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgRm9ybWF0dGluZ09wdGlvbnN9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgSXMudWludGVnZXIoY2FuZGlkYXRlLnRhYlNpemUpICYmIElzLmJvb2xlYW4oY2FuZGlkYXRlLmluc2VydFNwYWNlcyk7XG4gICAgfVxuICAgIEZvcm1hdHRpbmdPcHRpb25zLmlzID0gaXM7XG59KShGb3JtYXR0aW5nT3B0aW9ucyB8fCAoRm9ybWF0dGluZ09wdGlvbnMgPSB7fSkpO1xuLyoqXG4gKiBUaGUgRG9jdW1lbnRMaW5rIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIERvY3VtZW50TGlua30gbGl0ZXJhbHMuXG4gKi9cbnZhciBEb2N1bWVudExpbms7XG4oZnVuY3Rpb24gKERvY3VtZW50TGluaykge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgRG9jdW1lbnRMaW5rIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCB0YXJnZXQsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2UsIHRhcmdldCwgZGF0YSB9O1xuICAgIH1cbiAgICBEb2N1bWVudExpbmsuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgRG9jdW1lbnRMaW5rfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUudGFyZ2V0KSB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLnRhcmdldCkpO1xuICAgIH1cbiAgICBEb2N1bWVudExpbmsuaXMgPSBpcztcbn0pKERvY3VtZW50TGluayB8fCAoRG9jdW1lbnRMaW5rID0ge30pKTtcbi8qKlxuICogVGhlIFNlbGVjdGlvblJhbmdlIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb24gdG8gd29yayB3aXRoXG4gKiBTZWxlY3Rpb25SYW5nZSBsaXRlcmFscy5cbiAqL1xudmFyIFNlbGVjdGlvblJhbmdlO1xuKGZ1bmN0aW9uIChTZWxlY3Rpb25SYW5nZSkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgU2VsZWN0aW9uUmFuZ2VcbiAgICAgKiBAcGFyYW0gcmFuZ2UgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSBwYXJlbnQgYW4gb3B0aW9uYWwgcGFyZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgcGFyZW50KSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlLCBwYXJlbnQgfTtcbiAgICB9XG4gICAgU2VsZWN0aW9uUmFuZ2UuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpICYmIChjYW5kaWRhdGUucGFyZW50ID09PSB1bmRlZmluZWQgfHwgU2VsZWN0aW9uUmFuZ2UuaXMoY2FuZGlkYXRlLnBhcmVudCkpO1xuICAgIH1cbiAgICBTZWxlY3Rpb25SYW5nZS5pcyA9IGlzO1xufSkoU2VsZWN0aW9uUmFuZ2UgfHwgKFNlbGVjdGlvblJhbmdlID0ge30pKTtcbi8qKlxuICogQSBzZXQgb2YgcHJlZGVmaW5lZCB0b2tlbiB0eXBlcy4gVGhpcyBzZXQgaXMgbm90IGZpeGVkXG4gKiBhbiBjbGllbnRzIGNhbiBzcGVjaWZ5IGFkZGl0aW9uYWwgdG9rZW4gdHlwZXMgdmlhIHRoZVxuICogY29ycmVzcG9uZGluZyBjbGllbnQgY2FwYWJpbGl0aWVzLlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xudmFyIFNlbWFudGljVG9rZW5UeXBlcztcbihmdW5jdGlvbiAoU2VtYW50aWNUb2tlblR5cGVzKSB7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wibmFtZXNwYWNlXCJdID0gXCJuYW1lc3BhY2VcIjtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgZ2VuZXJpYyB0eXBlLiBBY3RzIGFzIGEgZmFsbGJhY2sgZm9yIHR5cGVzIHdoaWNoIGNhbid0IGJlIG1hcHBlZCB0b1xuICAgICAqIGEgc3BlY2lmaWMgdHlwZSBsaWtlIGNsYXNzIG9yIGVudW0uXG4gICAgICovXG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1widHlwZVwiXSA9IFwidHlwZVwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcImNsYXNzXCJdID0gXCJjbGFzc1wiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcImVudW1cIl0gPSBcImVudW1cIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJpbnRlcmZhY2VcIl0gPSBcImludGVyZmFjZVwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInN0cnVjdFwiXSA9IFwic3RydWN0XCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1widHlwZVBhcmFtZXRlclwiXSA9IFwidHlwZVBhcmFtZXRlclwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInBhcmFtZXRlclwiXSA9IFwicGFyYW1ldGVyXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1widmFyaWFibGVcIl0gPSBcInZhcmlhYmxlXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wicHJvcGVydHlcIl0gPSBcInByb3BlcnR5XCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wiZW51bU1lbWJlclwiXSA9IFwiZW51bU1lbWJlclwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcImV2ZW50XCJdID0gXCJldmVudFwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcImZ1bmN0aW9uXCJdID0gXCJmdW5jdGlvblwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcIm1ldGhvZFwiXSA9IFwibWV0aG9kXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wibWFjcm9cIl0gPSBcIm1hY3JvXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wia2V5d29yZFwiXSA9IFwia2V5d29yZFwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcIm1vZGlmaWVyXCJdID0gXCJtb2RpZmllclwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcImNvbW1lbnRcIl0gPSBcImNvbW1lbnRcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJzdHJpbmdcIl0gPSBcInN0cmluZ1wiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcIm51bWJlclwiXSA9IFwibnVtYmVyXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wicmVnZXhwXCJdID0gXCJyZWdleHBcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJvcGVyYXRvclwiXSA9IFwib3BlcmF0b3JcIjtcbiAgICAvKipcbiAgICAgKiBAc2luY2UgMy4xNy4wXG4gICAgICovXG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wiZGVjb3JhdG9yXCJdID0gXCJkZWNvcmF0b3JcIjtcbn0pKFNlbWFudGljVG9rZW5UeXBlcyB8fCAoU2VtYW50aWNUb2tlblR5cGVzID0ge30pKTtcbi8qKlxuICogQSBzZXQgb2YgcHJlZGVmaW5lZCB0b2tlbiBtb2RpZmllcnMuIFRoaXMgc2V0IGlzIG5vdCBmaXhlZFxuICogYW4gY2xpZW50cyBjYW4gc3BlY2lmeSBhZGRpdGlvbmFsIHRva2VuIHR5cGVzIHZpYSB0aGVcbiAqIGNvcnJlc3BvbmRpbmcgY2xpZW50IGNhcGFiaWxpdGllcy5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzO1xuKGZ1bmN0aW9uIChTZW1hbnRpY1Rva2VuTW9kaWZpZXJzKSB7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcImRlY2xhcmF0aW9uXCJdID0gXCJkZWNsYXJhdGlvblwiO1xuICAgIFNlbWFudGljVG9rZW5Nb2RpZmllcnNbXCJkZWZpbml0aW9uXCJdID0gXCJkZWZpbml0aW9uXCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcInJlYWRvbmx5XCJdID0gXCJyZWFkb25seVwiO1xuICAgIFNlbWFudGljVG9rZW5Nb2RpZmllcnNbXCJzdGF0aWNcIl0gPSBcInN0YXRpY1wiO1xuICAgIFNlbWFudGljVG9rZW5Nb2RpZmllcnNbXCJkZXByZWNhdGVkXCJdID0gXCJkZXByZWNhdGVkXCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcImFic3RyYWN0XCJdID0gXCJhYnN0cmFjdFwiO1xuICAgIFNlbWFudGljVG9rZW5Nb2RpZmllcnNbXCJhc3luY1wiXSA9IFwiYXN5bmNcIjtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wibW9kaWZpY2F0aW9uXCJdID0gXCJtb2RpZmljYXRpb25cIjtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wiZG9jdW1lbnRhdGlvblwiXSA9IFwiZG9jdW1lbnRhdGlvblwiO1xuICAgIFNlbWFudGljVG9rZW5Nb2RpZmllcnNbXCJkZWZhdWx0TGlicmFyeVwiXSA9IFwiZGVmYXVsdExpYnJhcnlcIjtcbn0pKFNlbWFudGljVG9rZW5Nb2RpZmllcnMgfHwgKFNlbWFudGljVG9rZW5Nb2RpZmllcnMgPSB7fSkpO1xuLyoqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbnZhciBTZW1hbnRpY1Rva2VucztcbihmdW5jdGlvbiAoU2VtYW50aWNUb2tlbnMpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiAoY2FuZGlkYXRlLnJlc3VsdElkID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGNhbmRpZGF0ZS5yZXN1bHRJZCA9PT0gJ3N0cmluZycpICYmXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KGNhbmRpZGF0ZS5kYXRhKSAmJiAoY2FuZGlkYXRlLmRhdGEubGVuZ3RoID09PSAwIHx8IHR5cGVvZiBjYW5kaWRhdGUuZGF0YVswXSA9PT0gJ251bWJlcicpO1xuICAgIH1cbiAgICBTZW1hbnRpY1Rva2Vucy5pcyA9IGlzO1xufSkoU2VtYW50aWNUb2tlbnMgfHwgKFNlbWFudGljVG9rZW5zID0ge30pKTtcbi8qKlxuICogVGhlIElubGluZVZhbHVlVGV4dCBuYW1lc3BhY2UgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGRlYWwgd2l0aCBJbmxpbmVWYWx1ZVRleHRzLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIElubGluZVZhbHVlVGV4dDtcbihmdW5jdGlvbiAoSW5saW5lVmFsdWVUZXh0KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBJbmxpbmVWYWx1ZVRleHQgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2UsIHRleHQgfTtcbiAgICB9XG4gICAgSW5saW5lVmFsdWVUZXh0LmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAhPT0gdW5kZWZpbmVkICYmIGNhbmRpZGF0ZSAhPT0gbnVsbCAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudGV4dCk7XG4gICAgfVxuICAgIElubGluZVZhbHVlVGV4dC5pcyA9IGlzO1xufSkoSW5saW5lVmFsdWVUZXh0IHx8IChJbmxpbmVWYWx1ZVRleHQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cCBuYW1lc3BhY2UgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGRlYWwgd2l0aCBJbmxpbmVWYWx1ZVZhcmlhYmxlTG9va3Vwcy5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBJbmxpbmVWYWx1ZVZhcmlhYmxlTG9va3VwO1xuKGZ1bmN0aW9uIChJbmxpbmVWYWx1ZVZhcmlhYmxlTG9va3VwKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBJbmxpbmVWYWx1ZVRleHQgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIHZhcmlhYmxlTmFtZSwgY2FzZVNlbnNpdGl2ZUxvb2t1cCkge1xuICAgICAgICByZXR1cm4geyByYW5nZSwgdmFyaWFibGVOYW1lLCBjYXNlU2Vuc2l0aXZlTG9va3VwIH07XG4gICAgfVxuICAgIElubGluZVZhbHVlVmFyaWFibGVMb29rdXAuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICE9PSB1bmRlZmluZWQgJiYgY2FuZGlkYXRlICE9PSBudWxsICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgSXMuYm9vbGVhbihjYW5kaWRhdGUuY2FzZVNlbnNpdGl2ZUxvb2t1cClcbiAgICAgICAgICAgICYmIChJcy5zdHJpbmcoY2FuZGlkYXRlLnZhcmlhYmxlTmFtZSkgfHwgY2FuZGlkYXRlLnZhcmlhYmxlTmFtZSA9PT0gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cC5pcyA9IGlzO1xufSkoSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cCB8fCAoSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cCA9IHt9KSk7XG4vKipcbiAqIFRoZSBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbiBuYW1lc3BhY2UgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGRlYWwgd2l0aCBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbi5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbjtcbihmdW5jdGlvbiAoSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb24pIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCBleHByZXNzaW9uKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlLCBleHByZXNzaW9uIH07XG4gICAgfVxuICAgIElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAhPT0gdW5kZWZpbmVkICYmIGNhbmRpZGF0ZSAhPT0gbnVsbCAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpXG4gICAgICAgICAgICAmJiAoSXMuc3RyaW5nKGNhbmRpZGF0ZS5leHByZXNzaW9uKSB8fCBjYW5kaWRhdGUuZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb24uaXMgPSBpcztcbn0pKElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uIHx8IChJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBJbmxpbmVWYWx1ZUNvbnRleHQgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgSW5saW5lVmFsdWVDb250ZXh0fSBsaXRlcmFscy5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbnZhciBJbmxpbmVWYWx1ZUNvbnRleHQ7XG4oZnVuY3Rpb24gKElubGluZVZhbHVlQ29udGV4dCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgSW5saW5lVmFsdWVDb250ZXh0IGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKGZyYW1lSWQsIHN0b3BwZWRMb2NhdGlvbikge1xuICAgICAgICByZXR1cm4geyBmcmFtZUlkLCBzdG9wcGVkTG9jYXRpb24gfTtcbiAgICB9XG4gICAgSW5saW5lVmFsdWVDb250ZXh0LmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIElubGluZVZhbHVlQ29udGV4dH0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIFJhbmdlLmlzKHZhbHVlLnN0b3BwZWRMb2NhdGlvbik7XG4gICAgfVxuICAgIElubGluZVZhbHVlQ29udGV4dC5pcyA9IGlzO1xufSkoSW5saW5lVmFsdWVDb250ZXh0IHx8IChJbmxpbmVWYWx1ZUNvbnRleHQgPSB7fSkpO1xuLyoqXG4gKiBJbmxheSBoaW50IGtpbmRzLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xudmFyIElubGF5SGludEtpbmQ7XG4oZnVuY3Rpb24gKElubGF5SGludEtpbmQpIHtcbiAgICAvKipcbiAgICAgKiBBbiBpbmxheSBoaW50IHRoYXQgZm9yIGEgdHlwZSBhbm5vdGF0aW9uLlxuICAgICAqL1xuICAgIElubGF5SGludEtpbmQuVHlwZSA9IDE7XG4gICAgLyoqXG4gICAgICogQW4gaW5sYXkgaGludCB0aGF0IGlzIGZvciBhIHBhcmFtZXRlci5cbiAgICAgKi9cbiAgICBJbmxheUhpbnRLaW5kLlBhcmFtZXRlciA9IDI7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSAxIHx8IHZhbHVlID09PSAyO1xuICAgIH1cbiAgICBJbmxheUhpbnRLaW5kLmlzID0gaXM7XG59KShJbmxheUhpbnRLaW5kIHx8IChJbmxheUhpbnRLaW5kID0ge30pKTtcbnZhciBJbmxheUhpbnRMYWJlbFBhcnQ7XG4oZnVuY3Rpb24gKElubGF5SGludExhYmVsUGFydCkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4geyB2YWx1ZSB9O1xuICAgIH1cbiAgICBJbmxheUhpbnRMYWJlbFBhcnQuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLnRvb2x0aXAgPT09IHVuZGVmaW5lZCB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLnRvb2x0aXApIHx8IG1haW5fTWFya3VwQ29udGVudC5pcyhjYW5kaWRhdGUudG9vbHRpcCkpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLmxvY2F0aW9uID09PSB1bmRlZmluZWQgfHwgTG9jYXRpb24uaXMoY2FuZGlkYXRlLmxvY2F0aW9uKSlcbiAgICAgICAgICAgICYmIChjYW5kaWRhdGUuY29tbWFuZCA9PT0gdW5kZWZpbmVkIHx8IENvbW1hbmQuaXMoY2FuZGlkYXRlLmNvbW1hbmQpKTtcbiAgICB9XG4gICAgSW5sYXlIaW50TGFiZWxQYXJ0LmlzID0gaXM7XG59KShJbmxheUhpbnRMYWJlbFBhcnQgfHwgKElubGF5SGludExhYmVsUGFydCA9IHt9KSk7XG52YXIgSW5sYXlIaW50O1xuKGZ1bmN0aW9uIChJbmxheUhpbnQpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUocG9zaXRpb24sIGxhYmVsLCBraW5kKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgcG9zaXRpb24sIGxhYmVsIH07XG4gICAgICAgIGlmIChraW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5raW5kID0ga2luZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBJbmxheUhpbnQuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIFBvc2l0aW9uLmlzKGNhbmRpZGF0ZS5wb3NpdGlvbilcbiAgICAgICAgICAgICYmIChJcy5zdHJpbmcoY2FuZGlkYXRlLmxhYmVsKSB8fCBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5sYWJlbCwgSW5sYXlIaW50TGFiZWxQYXJ0LmlzKSlcbiAgICAgICAgICAgICYmIChjYW5kaWRhdGUua2luZCA9PT0gdW5kZWZpbmVkIHx8IElubGF5SGludEtpbmQuaXMoY2FuZGlkYXRlLmtpbmQpKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS50ZXh0RWRpdHMgPT09IHVuZGVmaW5lZCkgfHwgSXMudHlwZWRBcnJheShjYW5kaWRhdGUudGV4dEVkaXRzLCBUZXh0RWRpdC5pcylcbiAgICAgICAgICAgICYmIChjYW5kaWRhdGUudG9vbHRpcCA9PT0gdW5kZWZpbmVkIHx8IElzLnN0cmluZyhjYW5kaWRhdGUudG9vbHRpcCkgfHwgbWFpbl9NYXJrdXBDb250ZW50LmlzKGNhbmRpZGF0ZS50b29sdGlwKSlcbiAgICAgICAgICAgICYmIChjYW5kaWRhdGUucGFkZGluZ0xlZnQgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5wYWRkaW5nTGVmdCkpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLnBhZGRpbmdSaWdodCA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLnBhZGRpbmdSaWdodCkpO1xuICAgIH1cbiAgICBJbmxheUhpbnQuaXMgPSBpcztcbn0pKElubGF5SGludCB8fCAoSW5sYXlIaW50ID0ge30pKTtcbnZhciBTdHJpbmdWYWx1ZTtcbihmdW5jdGlvbiAoU3RyaW5nVmFsdWUpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGVTbmlwcGV0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7IGtpbmQ6ICdzbmlwcGV0JywgdmFsdWUgfTtcbiAgICB9XG4gICAgU3RyaW5nVmFsdWUuY3JlYXRlU25pcHBldCA9IGNyZWF0ZVNuaXBwZXQ7XG59KShTdHJpbmdWYWx1ZSB8fCAoU3RyaW5nVmFsdWUgPSB7fSkpO1xudmFyIElubGluZUNvbXBsZXRpb25JdGVtO1xuKGZ1bmN0aW9uIChJbmxpbmVDb21wbGV0aW9uSXRlbSkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShpbnNlcnRUZXh0LCBmaWx0ZXJUZXh0LCByYW5nZSwgY29tbWFuZCkge1xuICAgICAgICByZXR1cm4geyBpbnNlcnRUZXh0LCBmaWx0ZXJUZXh0LCByYW5nZSwgY29tbWFuZCB9O1xuICAgIH1cbiAgICBJbmxpbmVDb21wbGV0aW9uSXRlbS5jcmVhdGUgPSBjcmVhdGU7XG59KShJbmxpbmVDb21wbGV0aW9uSXRlbSB8fCAoSW5saW5lQ29tcGxldGlvbkl0ZW0gPSB7fSkpO1xudmFyIElubGluZUNvbXBsZXRpb25MaXN0O1xuKGZ1bmN0aW9uIChJbmxpbmVDb21wbGV0aW9uTGlzdCkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShpdGVtcykge1xuICAgICAgICByZXR1cm4geyBpdGVtcyB9O1xuICAgIH1cbiAgICBJbmxpbmVDb21wbGV0aW9uTGlzdC5jcmVhdGUgPSBjcmVhdGU7XG59KShJbmxpbmVDb21wbGV0aW9uTGlzdCB8fCAoSW5saW5lQ29tcGxldGlvbkxpc3QgPSB7fSkpO1xuLyoqXG4gKiBEZXNjcmliZXMgaG93IGFuIHtAbGluayBJbmxpbmVDb21wbGV0aW9uSXRlbVByb3ZpZGVyIGlubGluZSBjb21wbGV0aW9uIHByb3ZpZGVyfSB3YXMgdHJpZ2dlcmVkLlxuICpcbiAqIEBzaW5jZSAzLjE4LjBcbiAqIEBwcm9wb3NlZFxuICovXG52YXIgSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kO1xuKGZ1bmN0aW9uIChJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmQpIHtcbiAgICAvKipcbiAgICAgKiBDb21wbGV0aW9uIHdhcyB0cmlnZ2VyZWQgZXhwbGljaXRseSBieSBhIHVzZXIgZ2VzdHVyZS5cbiAgICAgKi9cbiAgICBJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmQuSW52b2tlZCA9IDA7XG4gICAgLyoqXG4gICAgICogQ29tcGxldGlvbiB3YXMgdHJpZ2dlcmVkIGF1dG9tYXRpY2FsbHkgd2hpbGUgZWRpdGluZy5cbiAgICAgKi9cbiAgICBJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmQuQXV0b21hdGljID0gMTtcbn0pKElubGluZUNvbXBsZXRpb25UcmlnZ2VyS2luZCB8fCAoSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kID0ge30pKTtcbnZhciBTZWxlY3RlZENvbXBsZXRpb25JbmZvO1xuKGZ1bmN0aW9uIChTZWxlY3RlZENvbXBsZXRpb25JbmZvKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCB0ZXh0KSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlLCB0ZXh0IH07XG4gICAgfVxuICAgIFNlbGVjdGVkQ29tcGxldGlvbkluZm8uY3JlYXRlID0gY3JlYXRlO1xufSkoU2VsZWN0ZWRDb21wbGV0aW9uSW5mbyB8fCAoU2VsZWN0ZWRDb21wbGV0aW9uSW5mbyA9IHt9KSk7XG52YXIgSW5saW5lQ29tcGxldGlvbkNvbnRleHQ7XG4oZnVuY3Rpb24gKElubGluZUNvbXBsZXRpb25Db250ZXh0KSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHRyaWdnZXJLaW5kLCBzZWxlY3RlZENvbXBsZXRpb25JbmZvKSB7XG4gICAgICAgIHJldHVybiB7IHRyaWdnZXJLaW5kLCBzZWxlY3RlZENvbXBsZXRpb25JbmZvIH07XG4gICAgfVxuICAgIElubGluZUNvbXBsZXRpb25Db250ZXh0LmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKElubGluZUNvbXBsZXRpb25Db250ZXh0IHx8IChJbmxpbmVDb21wbGV0aW9uQ29udGV4dCA9IHt9KSk7XG52YXIgV29ya3NwYWNlRm9sZGVyO1xuKGZ1bmN0aW9uIChXb3Jrc3BhY2VGb2xkZXIpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBqc29uX3NlcnZpY2VfVVJJLmlzKGNhbmRpZGF0ZS51cmkpICYmIElzLnN0cmluZyhjYW5kaWRhdGUubmFtZSk7XG4gICAgfVxuICAgIFdvcmtzcGFjZUZvbGRlci5pcyA9IGlzO1xufSkoV29ya3NwYWNlRm9sZGVyIHx8IChXb3Jrc3BhY2VGb2xkZXIgPSB7fSkpO1xuY29uc3QgRU9MID0gKC8qIHVudXNlZCBwdXJlIGV4cHJlc3Npb24gb3Igc3VwZXIgKi8gbnVsbCAmJiAoWydcXG4nLCAnXFxyXFxuJywgJ1xcciddKSk7XG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSB0aGUgdGV4dCBkb2N1bWVudCBmcm9tIHRoZSBuZXcgdnNjb2RlLWxhbmd1YWdlc2VydmVyLXRleHRkb2N1bWVudCBwYWNrYWdlLlxuICovXG52YXIgVGV4dERvY3VtZW50O1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IElUZXh0RG9jdW1lbnQgbGl0ZXJhbCBmcm9tIHRoZSBnaXZlbiB1cmkgYW5kIGNvbnRlbnQuXG4gICAgICogQHBhcmFtIHVyaSBUaGUgZG9jdW1lbnQncyB1cmkuXG4gICAgICogQHBhcmFtIGxhbmd1YWdlSWQgVGhlIGRvY3VtZW50J3MgbGFuZ3VhZ2UgSWQuXG4gICAgICogQHBhcmFtIHZlcnNpb24gVGhlIGRvY3VtZW50J3MgdmVyc2lvbi5cbiAgICAgKiBAcGFyYW0gY29udGVudCBUaGUgZG9jdW1lbnQncyBjb250ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGdWxsVGV4dERvY3VtZW50KHVyaSwgbGFuZ3VhZ2VJZCwgdmVyc2lvbiwgY29udGVudCk7XG4gICAgfVxuICAgIFRleHREb2N1bWVudC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBJVGV4dERvY3VtZW50fSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5sYW5ndWFnZUlkKSB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLmxhbmd1YWdlSWQpKSAmJiBJcy51aW50ZWdlcihjYW5kaWRhdGUubGluZUNvdW50KVxuICAgICAgICAgICAgJiYgSXMuZnVuYyhjYW5kaWRhdGUuZ2V0VGV4dCkgJiYgSXMuZnVuYyhjYW5kaWRhdGUucG9zaXRpb25BdCkgJiYgSXMuZnVuYyhjYW5kaWRhdGUub2Zmc2V0QXQpID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnQuaXMgPSBpcztcbiAgICBmdW5jdGlvbiBhcHBseUVkaXRzKGRvY3VtZW50LCBlZGl0cykge1xuICAgICAgICBsZXQgdGV4dCA9IGRvY3VtZW50LmdldFRleHQoKTtcbiAgICAgICAgbGV0IHNvcnRlZEVkaXRzID0gbWVyZ2VTb3J0KGVkaXRzLCAoYSwgYikgPT4ge1xuICAgICAgICAgICAgbGV0IGRpZmYgPSBhLnJhbmdlLnN0YXJ0LmxpbmUgLSBiLnJhbmdlLnN0YXJ0LmxpbmU7XG4gICAgICAgICAgICBpZiAoZGlmZiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLnJhbmdlLnN0YXJ0LmNoYXJhY3RlciAtIGIucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgbGFzdE1vZGlmaWVkT2Zmc2V0ID0gdGV4dC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSBzb3J0ZWRFZGl0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IGUgPSBzb3J0ZWRFZGl0c1tpXTtcbiAgICAgICAgICAgIGxldCBzdGFydE9mZnNldCA9IGRvY3VtZW50Lm9mZnNldEF0KGUucmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgbGV0IGVuZE9mZnNldCA9IGRvY3VtZW50Lm9mZnNldEF0KGUucmFuZ2UuZW5kKTtcbiAgICAgICAgICAgIGlmIChlbmRPZmZzZXQgPD0gbGFzdE1vZGlmaWVkT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHN0YXJ0T2Zmc2V0KSArIGUubmV3VGV4dCArIHRleHQuc3Vic3RyaW5nKGVuZE9mZnNldCwgdGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPdmVybGFwcGluZyBlZGl0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0TW9kaWZpZWRPZmZzZXQgPSBzdGFydE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50LmFwcGx5RWRpdHMgPSBhcHBseUVkaXRzO1xuICAgIGZ1bmN0aW9uIG1lcmdlU29ydChkYXRhLCBjb21wYXJlKSB7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAvLyBzb3J0ZWRcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHAgPSAoZGF0YS5sZW5ndGggLyAyKSB8IDA7XG4gICAgICAgIGNvbnN0IGxlZnQgPSBkYXRhLnNsaWNlKDAsIHApO1xuICAgICAgICBjb25zdCByaWdodCA9IGRhdGEuc2xpY2UocCk7XG4gICAgICAgIG1lcmdlU29ydChsZWZ0LCBjb21wYXJlKTtcbiAgICAgICAgbWVyZ2VTb3J0KHJpZ2h0LCBjb21wYXJlKTtcbiAgICAgICAgbGV0IGxlZnRJZHggPSAwO1xuICAgICAgICBsZXQgcmlnaHRJZHggPSAwO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIHdoaWxlIChsZWZ0SWR4IDwgbGVmdC5sZW5ndGggJiYgcmlnaHRJZHggPCByaWdodC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCByZXQgPSBjb21wYXJlKGxlZnRbbGVmdElkeF0sIHJpZ2h0W3JpZ2h0SWR4XSk7XG4gICAgICAgICAgICBpZiAocmV0IDw9IDApIHtcbiAgICAgICAgICAgICAgICAvLyBzbWFsbGVyX2VxdWFsIC0+IHRha2UgbGVmdCB0byBwcmVzZXJ2ZSBvcmRlclxuICAgICAgICAgICAgICAgIGRhdGFbaSsrXSA9IGxlZnRbbGVmdElkeCsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGdyZWF0ZXIgLT4gdGFrZSByaWdodFxuICAgICAgICAgICAgICAgIGRhdGFbaSsrXSA9IHJpZ2h0W3JpZ2h0SWR4KytdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChsZWZ0SWR4IDwgbGVmdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRhdGFbaSsrXSA9IGxlZnRbbGVmdElkeCsrXTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAocmlnaHRJZHggPCByaWdodC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRhdGFbaSsrXSA9IHJpZ2h0W3JpZ2h0SWR4KytdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbn0pKFRleHREb2N1bWVudCB8fCAoVGV4dERvY3VtZW50ID0ge30pKTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIHRoZSB0ZXh0IGRvY3VtZW50IGZyb20gdGhlIG5ldyB2c2NvZGUtbGFuZ3VhZ2VzZXJ2ZXItdGV4dGRvY3VtZW50IHBhY2thZ2UuXG4gKi9cbmNsYXNzIEZ1bGxUZXh0RG9jdW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKHVyaSwgbGFuZ3VhZ2VJZCwgdmVyc2lvbiwgY29udGVudCkge1xuICAgICAgICB0aGlzLl91cmkgPSB1cmk7XG4gICAgICAgIHRoaXMuX2xhbmd1YWdlSWQgPSBsYW5ndWFnZUlkO1xuICAgICAgICB0aGlzLl92ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5fY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIHRoaXMuX2xpbmVPZmZzZXRzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgdXJpKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXJpO1xuICAgIH1cbiAgICBnZXQgbGFuZ3VhZ2VJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhbmd1YWdlSWQ7XG4gICAgfVxuICAgIGdldCB2ZXJzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmVyc2lvbjtcbiAgICB9XG4gICAgZ2V0VGV4dChyYW5nZSkge1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMub2Zmc2V0QXQocmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgbGV0IGVuZCA9IHRoaXMub2Zmc2V0QXQocmFuZ2UuZW5kKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50LnN1YnN0cmluZyhzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudDtcbiAgICB9XG4gICAgdXBkYXRlKGV2ZW50LCB2ZXJzaW9uKSB7XG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBldmVudC50ZXh0O1xuICAgICAgICB0aGlzLl92ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5fbGluZU9mZnNldHMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldExpbmVPZmZzZXRzKCkge1xuICAgICAgICBpZiAodGhpcy5fbGluZU9mZnNldHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IGxpbmVPZmZzZXRzID0gW107XG4gICAgICAgICAgICBsZXQgdGV4dCA9IHRoaXMuX2NvbnRlbnQ7XG4gICAgICAgICAgICBsZXQgaXNMaW5lU3RhcnQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTGluZVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVPZmZzZXRzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgIGlzTGluZVN0YXJ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBjaCA9IHRleHQuY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgIGlzTGluZVN0YXJ0ID0gKGNoID09PSAnXFxyJyB8fCBjaCA9PT0gJ1xcbicpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xccicgJiYgaSArIDEgPCB0ZXh0Lmxlbmd0aCAmJiB0ZXh0LmNoYXJBdChpICsgMSkgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNMaW5lU3RhcnQgJiYgdGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGluZU9mZnNldHMucHVzaCh0ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9saW5lT2Zmc2V0cyA9IGxpbmVPZmZzZXRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lT2Zmc2V0cztcbiAgICB9XG4gICAgcG9zaXRpb25BdChvZmZzZXQpIHtcbiAgICAgICAgb2Zmc2V0ID0gTWF0aC5tYXgoTWF0aC5taW4ob2Zmc2V0LCB0aGlzLl9jb250ZW50Lmxlbmd0aCksIDApO1xuICAgICAgICBsZXQgbGluZU9mZnNldHMgPSB0aGlzLmdldExpbmVPZmZzZXRzKCk7XG4gICAgICAgIGxldCBsb3cgPSAwLCBoaWdoID0gbGluZU9mZnNldHMubGVuZ3RoO1xuICAgICAgICBpZiAoaGlnaCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFBvc2l0aW9uLmNyZWF0ZSgwLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgICAgICBsZXQgbWlkID0gTWF0aC5mbG9vcigobG93ICsgaGlnaCkgLyAyKTtcbiAgICAgICAgICAgIGlmIChsaW5lT2Zmc2V0c1ttaWRdID4gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG93IGlzIHRoZSBsZWFzdCB4IGZvciB3aGljaCB0aGUgbGluZSBvZmZzZXQgaXMgbGFyZ2VyIHRoYW4gdGhlIGN1cnJlbnQgb2Zmc2V0XG4gICAgICAgIC8vIG9yIGFycmF5Lmxlbmd0aCBpZiBubyBsaW5lIG9mZnNldCBpcyBsYXJnZXIgdGhhbiB0aGUgY3VycmVudCBvZmZzZXRcbiAgICAgICAgbGV0IGxpbmUgPSBsb3cgLSAxO1xuICAgICAgICByZXR1cm4gUG9zaXRpb24uY3JlYXRlKGxpbmUsIG9mZnNldCAtIGxpbmVPZmZzZXRzW2xpbmVdKTtcbiAgICB9XG4gICAgb2Zmc2V0QXQocG9zaXRpb24pIHtcbiAgICAgICAgbGV0IGxpbmVPZmZzZXRzID0gdGhpcy5nZXRMaW5lT2Zmc2V0cygpO1xuICAgICAgICBpZiAocG9zaXRpb24ubGluZSA+PSBsaW5lT2Zmc2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwb3NpdGlvbi5saW5lIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxpbmVPZmZzZXQgPSBsaW5lT2Zmc2V0c1twb3NpdGlvbi5saW5lXTtcbiAgICAgICAgbGV0IG5leHRMaW5lT2Zmc2V0ID0gKHBvc2l0aW9uLmxpbmUgKyAxIDwgbGluZU9mZnNldHMubGVuZ3RoKSA/IGxpbmVPZmZzZXRzW3Bvc2l0aW9uLmxpbmUgKyAxXSA6IHRoaXMuX2NvbnRlbnQubGVuZ3RoO1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4obGluZU9mZnNldCArIHBvc2l0aW9uLmNoYXJhY3RlciwgbmV4dExpbmVPZmZzZXQpLCBsaW5lT2Zmc2V0KTtcbiAgICB9XG4gICAgZ2V0IGxpbmVDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGluZU9mZnNldHMoKS5sZW5ndGg7XG4gICAgfVxufVxudmFyIElzO1xuKGZ1bmN0aW9uIChJcykge1xuICAgIGNvbnN0IHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgICBmdW5jdGlvbiBkZWZpbmVkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnO1xuICAgIH1cbiAgICBJcy5kZWZpbmVkID0gZGVmaW5lZDtcbiAgICBmdW5jdGlvbiB1bmRlZmluZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgfVxuICAgIElzLnVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICBmdW5jdGlvbiBib29sZWFuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2U7XG4gICAgfVxuICAgIElzLmJvb2xlYW4gPSBib29sZWFuO1xuICAgIGZ1bmN0aW9uIHN0cmluZyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xuICAgIH1cbiAgICBJcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgZnVuY3Rpb24gbnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgTnVtYmVyXSc7XG4gICAgfVxuICAgIElzLm51bWJlciA9IG51bWJlcjtcbiAgICBmdW5jdGlvbiBudW1iZXJSYW5nZSh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBOdW1iZXJdJyAmJiBtaW4gPD0gdmFsdWUgJiYgdmFsdWUgPD0gbWF4O1xuICAgIH1cbiAgICBJcy5udW1iZXJSYW5nZSA9IG51bWJlclJhbmdlO1xuICAgIGZ1bmN0aW9uIGludGVnZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBOdW1iZXJdJyAmJiAtMjE0NzQ4MzY0OCA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSAyMTQ3NDgzNjQ3O1xuICAgIH1cbiAgICBJcy5pbnRlZ2VyID0gaW50ZWdlcjtcbiAgICBmdW5jdGlvbiB1aW50ZWdlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE51bWJlcl0nICYmIDAgPD0gdmFsdWUgJiYgdmFsdWUgPD0gMjE0NzQ4MzY0NztcbiAgICB9XG4gICAgSXMudWludGVnZXIgPSB1aW50ZWdlcjtcbiAgICBmdW5jdGlvbiBmdW5jKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgICB9XG4gICAgSXMuZnVuYyA9IGZ1bmM7XG4gICAgZnVuY3Rpb24gb2JqZWN0TGl0ZXJhbCh2YWx1ZSkge1xuICAgICAgICAvLyBTdHJpY3RseSBzcGVha2luZyBjbGFzcyBpbnN0YW5jZXMgcGFzcyB0aGlzIGNoZWNrIGFzIHdlbGwuIFNpbmNlIHRoZSBMU1BcbiAgICAgICAgLy8gZG9lc24ndCB1c2UgY2xhc3NlcyB3ZSBpZ25vcmUgdGhpcyBmb3Igbm93LiBJZiB3ZSBkbyB3ZSBuZWVkIHRvIGFkZCBzb21ldGhpbmdcbiAgICAgICAgLy8gbGlrZSB0aGlzOiBgT2JqZWN0LmdldFByb3RvdHlwZU9mKE9iamVjdC5nZXRQcm90b3R5cGVPZih4KSkgPT09IG51bGxgXG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnO1xuICAgIH1cbiAgICBJcy5vYmplY3RMaXRlcmFsID0gb2JqZWN0TGl0ZXJhbDtcbiAgICBmdW5jdGlvbiB0eXBlZEFycmF5KHZhbHVlLCBjaGVjaykge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkoY2hlY2spO1xuICAgIH1cbiAgICBJcy50eXBlZEFycmF5ID0gdHlwZWRBcnJheTtcbn0pKElzIHx8IChJcyA9IHt9KSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3ZzY29kZS1sYW5ndWFnZXNlcnZlci10ZXh0ZG9jdW1lbnQvbGliL2VzbS9tYWluLmpzXG52YXIgbWFpbiA9IF9fd2VicGFja19yZXF1aXJlX18oODA0MSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3ZzY29kZS1qc29uLWxhbmd1YWdlc2VydmljZS9saWIvZXNtL2pzb25MYW5ndWFnZVR5cGVzLmpzXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cbi8qKlxuICogRXJyb3IgY29kZXMgdXNlZCBieSBkaWFnbm9zdGljc1xuICovXG52YXIgRXJyb3JDb2RlO1xuKGZ1bmN0aW9uIChFcnJvckNvZGUpIHtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiVW5kZWZpbmVkXCJdID0gMF0gPSBcIlVuZGVmaW5lZFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJFbnVtVmFsdWVNaXNtYXRjaFwiXSA9IDFdID0gXCJFbnVtVmFsdWVNaXNtYXRjaFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJEZXByZWNhdGVkXCJdID0gMl0gPSBcIkRlcHJlY2F0ZWRcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiVW5leHBlY3RlZEVuZE9mQ29tbWVudFwiXSA9IDI1N10gPSBcIlVuZXhwZWN0ZWRFbmRPZkNvbW1lbnRcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiVW5leHBlY3RlZEVuZE9mU3RyaW5nXCJdID0gMjU4XSA9IFwiVW5leHBlY3RlZEVuZE9mU3RyaW5nXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIlVuZXhwZWN0ZWRFbmRPZk51bWJlclwiXSA9IDI1OV0gPSBcIlVuZXhwZWN0ZWRFbmRPZk51bWJlclwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJJbnZhbGlkVW5pY29kZVwiXSA9IDI2MF0gPSBcIkludmFsaWRVbmljb2RlXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkludmFsaWRFc2NhcGVDaGFyYWN0ZXJcIl0gPSAyNjFdID0gXCJJbnZhbGlkRXNjYXBlQ2hhcmFjdGVyXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkludmFsaWRDaGFyYWN0ZXJcIl0gPSAyNjJdID0gXCJJbnZhbGlkQ2hhcmFjdGVyXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIlByb3BlcnR5RXhwZWN0ZWRcIl0gPSA1MTNdID0gXCJQcm9wZXJ0eUV4cGVjdGVkXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkNvbW1hRXhwZWN0ZWRcIl0gPSA1MTRdID0gXCJDb21tYUV4cGVjdGVkXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkNvbG9uRXhwZWN0ZWRcIl0gPSA1MTVdID0gXCJDb2xvbkV4cGVjdGVkXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIlZhbHVlRXhwZWN0ZWRcIl0gPSA1MTZdID0gXCJWYWx1ZUV4cGVjdGVkXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkNvbW1hT3JDbG9zZUJhY2tldEV4cGVjdGVkXCJdID0gNTE3XSA9IFwiQ29tbWFPckNsb3NlQmFja2V0RXhwZWN0ZWRcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiQ29tbWFPckNsb3NlQnJhY2VFeHBlY3RlZFwiXSA9IDUxOF0gPSBcIkNvbW1hT3JDbG9zZUJyYWNlRXhwZWN0ZWRcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiVHJhaWxpbmdDb21tYVwiXSA9IDUxOV0gPSBcIlRyYWlsaW5nQ29tbWFcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiRHVwbGljYXRlS2V5XCJdID0gNTIwXSA9IFwiRHVwbGljYXRlS2V5XCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkNvbW1lbnROb3RQZXJtaXR0ZWRcIl0gPSA1MjFdID0gXCJDb21tZW50Tm90UGVybWl0dGVkXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIlByb3BlcnR5S2V5c011c3RCZURvdWJsZXF1b3RlZFwiXSA9IDUyOF0gPSBcIlByb3BlcnR5S2V5c011c3RCZURvdWJsZXF1b3RlZFwiO1xuICAgIEVycm9yQ29kZVtFcnJvckNvZGVbXCJTY2hlbWFSZXNvbHZlRXJyb3JcIl0gPSA3NjhdID0gXCJTY2hlbWFSZXNvbHZlRXJyb3JcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiU2NoZW1hVW5zdXBwb3J0ZWRGZWF0dXJlXCJdID0gNzY5XSA9IFwiU2NoZW1hVW5zdXBwb3J0ZWRGZWF0dXJlXCI7XG59KShFcnJvckNvZGUgfHwgKEVycm9yQ29kZSA9IHt9KSk7XG52YXIgU2NoZW1hRHJhZnQ7XG4oZnVuY3Rpb24gKFNjaGVtYURyYWZ0KSB7XG4gICAgU2NoZW1hRHJhZnRbU2NoZW1hRHJhZnRbXCJ2M1wiXSA9IDNdID0gXCJ2M1wiO1xuICAgIFNjaGVtYURyYWZ0W1NjaGVtYURyYWZ0W1widjRcIl0gPSA0XSA9IFwidjRcIjtcbiAgICBTY2hlbWFEcmFmdFtTY2hlbWFEcmFmdFtcInY2XCJdID0gNl0gPSBcInY2XCI7XG4gICAgU2NoZW1hRHJhZnRbU2NoZW1hRHJhZnRbXCJ2N1wiXSA9IDddID0gXCJ2N1wiO1xuICAgIFNjaGVtYURyYWZ0W1NjaGVtYURyYWZ0W1widjIwMTlfMDlcIl0gPSAxOV0gPSBcInYyMDE5XzA5XCI7XG4gICAgU2NoZW1hRHJhZnRbU2NoZW1hRHJhZnRbXCJ2MjAyMF8xMlwiXSA9IDIwXSA9IFwidjIwMjBfMTJcIjtcbn0pKFNjaGVtYURyYWZ0IHx8IChTY2hlbWFEcmFmdCA9IHt9KSk7XG52YXIgQ2xpZW50Q2FwYWJpbGl0aWVzO1xuKGZ1bmN0aW9uIChDbGllbnRDYXBhYmlsaXRpZXMpIHtcbiAgICBDbGllbnRDYXBhYmlsaXRpZXMuTEFURVNUID0ge1xuICAgICAgICB0ZXh0RG9jdW1lbnQ6IHtcbiAgICAgICAgICAgIGNvbXBsZXRpb246IHtcbiAgICAgICAgICAgICAgICBjb21wbGV0aW9uSXRlbToge1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudGF0aW9uRm9ybWF0OiBbTWFya3VwS2luZC5NYXJrZG93biwgTWFya3VwS2luZC5QbGFpblRleHRdLFxuICAgICAgICAgICAgICAgICAgICBjb21taXRDaGFyYWN0ZXJzU3VwcG9ydDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxEZXRhaWxzU3VwcG9ydDogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59KShDbGllbnRDYXBhYmlsaXRpZXMgfHwgKENsaWVudENhcGFiaWxpdGllcyA9IHt9KSk7XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL25vZGVfbW9kdWxlcy9AdnNjb2RlL2wxMG4vZGlzdC9icm93c2VyLmpzXG4vLyBzcmMvYnJvd3Nlci9yZWFkZXIudHNcbmFzeW5jIGZ1bmN0aW9uIHJlYWRGaWxlRnJvbVVyaSh1cmkpIHtcbiAgaWYgKHVyaS5wcm90b2NvbCA9PT0gXCJodHRwOlwiIHx8IHVyaS5wcm90b2NvbCA9PT0gXCJodHRwczpcIikge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKHVyaSk7XG4gICAgcmV0dXJuIGF3YWl0IHJlcy50ZXh0KCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgcHJvdG9jb2xcIik7XG59XG5mdW5jdGlvbiByZWFkRmlsZUZyb21Gc1BhdGgoXykge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBpbiBicm93c2VyXCIpO1xufVxuXG4vLyBzcmMvbWFpbi50c1xudmFyIGJ1bmRsZTtcbmZ1bmN0aW9uIGNvbmZpZyhjb25maWcyKSB7XG4gIGlmIChcImNvbnRlbnRzXCIgaW4gY29uZmlnMikge1xuICAgIGlmICh0eXBlb2YgY29uZmlnMi5jb250ZW50cyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgYnVuZGxlID0gSlNPTi5wYXJzZShjb25maWcyLmNvbnRlbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnVuZGxlID0gY29uZmlnMi5jb250ZW50cztcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChcImZzUGF0aFwiIGluIGNvbmZpZzIpIHtcbiAgICBjb25zdCBmaWxlQ29udGVudCA9IHJlYWRGaWxlRnJvbUZzUGF0aChjb25maWcyLmZzUGF0aCk7XG4gICAgY29uc3QgY29udGVudCA9IEpTT04ucGFyc2UoZmlsZUNvbnRlbnQpO1xuICAgIGJ1bmRsZSA9IGlzQnVpbHRpbkV4dGVuc2lvbihjb250ZW50KSA/IGNvbnRlbnQuY29udGVudHMuYnVuZGxlIDogY29udGVudDtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGNvbmZpZzIudXJpKSB7XG4gICAgbGV0IHVyaSA9IGNvbmZpZzIudXJpO1xuICAgIGlmICh0eXBlb2YgY29uZmlnMi51cmkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHVyaSA9IG5ldyBVUkwoY29uZmlnMi51cmkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcmVhZEZpbGVGcm9tVXJpKHVyaSkudGhlbigodXJpQ29udGVudCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBKU09OLnBhcnNlKHVyaUNvbnRlbnQpO1xuICAgICAgICAgIGJ1bmRsZSA9IGlzQnVpbHRpbkV4dGVuc2lvbihjb250ZW50KSA/IGNvbnRlbnQuY29udGVudHMuYnVuZGxlIDogY29udGVudDtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHQoLi4uYXJncykge1xuICBjb25zdCBmaXJzdEFyZyA9IGFyZ3NbMF07XG4gIGxldCBrZXk7XG4gIGxldCBtZXNzYWdlO1xuICBsZXQgZm9ybWF0QXJncztcbiAgaWYgKHR5cGVvZiBmaXJzdEFyZyA9PT0gXCJzdHJpbmdcIikge1xuICAgIGtleSA9IGZpcnN0QXJnO1xuICAgIG1lc3NhZ2UgPSBmaXJzdEFyZztcbiAgICBhcmdzLnNwbGljZSgwLCAxKTtcbiAgICBmb3JtYXRBcmdzID0gIWFyZ3MgfHwgdHlwZW9mIGFyZ3NbMF0gIT09IFwib2JqZWN0XCIgPyBhcmdzIDogYXJnc1swXTtcbiAgfSBlbHNlIGlmIChmaXJzdEFyZyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgY29uc3QgcmVwbGFjZW1lbnRzID0gYXJncy5zbGljZSgxKTtcbiAgICBpZiAoZmlyc3RBcmcubGVuZ3RoICE9PSByZXBsYWNlbWVudHMubGVuZ3RoICsgMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0ZWQgYSBzdHJpbmcgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIGwxMG4udFwiKTtcbiAgICB9XG4gICAgbGV0IHN0ciA9IGZpcnN0QXJnWzBdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZmlyc3RBcmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIHN0ciArPSBgeyR7aSAtIDF9fWAgKyBmaXJzdEFyZ1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHQoc3RyLCAuLi5yZXBsYWNlbWVudHMpO1xuICB9IGVsc2Uge1xuICAgIG1lc3NhZ2UgPSBmaXJzdEFyZy5tZXNzYWdlO1xuICAgIGtleSA9IG1lc3NhZ2U7XG4gICAgaWYgKGZpcnN0QXJnLmNvbW1lbnQgJiYgZmlyc3RBcmcuY29tbWVudC5sZW5ndGggPiAwKSB7XG4gICAgICBrZXkgKz0gYC8ke0FycmF5LmlzQXJyYXkoZmlyc3RBcmcuY29tbWVudCkgPyBmaXJzdEFyZy5jb21tZW50LmpvaW4oXCJcIikgOiBmaXJzdEFyZy5jb21tZW50fWA7XG4gICAgfVxuICAgIGZvcm1hdEFyZ3MgPSBmaXJzdEFyZy5hcmdzID8/IHt9O1xuICB9XG4gIGNvbnN0IG1lc3NhZ2VGcm9tQnVuZGxlID0gYnVuZGxlPy5ba2V5XTtcbiAgaWYgKCFtZXNzYWdlRnJvbUJ1bmRsZSkge1xuICAgIHJldHVybiBicm93c2VyX2Zvcm1hdChtZXNzYWdlLCBmb3JtYXRBcmdzKTtcbiAgfVxuICBpZiAodHlwZW9mIG1lc3NhZ2VGcm9tQnVuZGxlID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGJyb3dzZXJfZm9ybWF0KG1lc3NhZ2VGcm9tQnVuZGxlLCBmb3JtYXRBcmdzKTtcbiAgfVxuICBpZiAobWVzc2FnZUZyb21CdW5kbGUuY29tbWVudCkge1xuICAgIHJldHVybiBicm93c2VyX2Zvcm1hdChtZXNzYWdlRnJvbUJ1bmRsZS5tZXNzYWdlLCBmb3JtYXRBcmdzKTtcbiAgfVxuICByZXR1cm4gYnJvd3Nlcl9mb3JtYXQobWVzc2FnZSwgZm9ybWF0QXJncyk7XG59XG52YXIgX2Zvcm1hdDJSZWdleHAgPSAveyhbXn1dKyl9L2c7XG5mdW5jdGlvbiBicm93c2VyX2Zvcm1hdCh0ZW1wbGF0ZSwgdmFsdWVzKSB7XG4gIGlmIChPYmplY3Qua2V5cyh2YWx1ZXMpLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfVxuICByZXR1cm4gdGVtcGxhdGUucmVwbGFjZShfZm9ybWF0MlJlZ2V4cCwgKG1hdGNoLCBncm91cCkgPT4gdmFsdWVzW2dyb3VwXSA/PyBtYXRjaCk7XG59XG5mdW5jdGlvbiBpc0J1aWx0aW5FeHRlbnNpb24oanNvbikge1xuICByZXR1cm4gISEodHlwZW9mIGpzb24/LmNvbnRlbnRzPy5idW5kbGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGpzb24/LnZlcnNpb24gPT09IFwic3RyaW5nXCIpO1xufVxuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL2xpYi9lc20vcGFyc2VyL2pzb25QYXJzZXIuanNcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblxuXG5cbmNvbnN0IGZvcm1hdHMgPSB7XG4gICAgJ2NvbG9yLWhleCc6IHsgZXJyb3JNZXNzYWdlOiB0KCdJbnZhbGlkIGNvbG9yIGZvcm1hdC4gVXNlICNSR0IsICNSR0JBLCAjUlJHR0JCIG9yICNSUkdHQkJBQS4nKSwgcGF0dGVybjogL14jKFswLTlBLUZhLWZdezMsNH18KFswLTlBLUZhLWZdezJ9KXszLDR9KSQvIH0sXG4gICAgJ2RhdGUtdGltZSc6IHsgZXJyb3JNZXNzYWdlOiB0KCdTdHJpbmcgaXMgbm90IGEgUkZDMzMzOSBkYXRlLXRpbWUuJyksIHBhdHRlcm46IC9eKFxcZHs0fSktKDBbMS05XXwxWzAtMl0pLSgwWzEtOV18WzEyXVswLTldfDNbMDFdKVQoWzAxXVswLTldfDJbMC0zXSk6KFswLTVdWzAtOV0pOihbMC01XVswLTldfDYwKShcXC5bMC05XSspPyhafChcXCt8LSkoWzAxXVswLTldfDJbMC0zXSk6KFswLTVdWzAtOV0pKSQvaSB9LFxuICAgICdkYXRlJzogeyBlcnJvck1lc3NhZ2U6IHQoJ1N0cmluZyBpcyBub3QgYSBSRkMzMzM5IGRhdGUuJyksIHBhdHRlcm46IC9eKFxcZHs0fSktKDBbMS05XXwxWzAtMl0pLSgwWzEtOV18WzEyXVswLTldfDNbMDFdKSQvaSB9LFxuICAgICd0aW1lJzogeyBlcnJvck1lc3NhZ2U6IHQoJ1N0cmluZyBpcyBub3QgYSBSRkMzMzM5IHRpbWUuJyksIHBhdHRlcm46IC9eKFswMV1bMC05XXwyWzAtM10pOihbMC01XVswLTldKTooWzAtNV1bMC05XXw2MCkoXFwuWzAtOV0rKT8oWnwoXFwrfC0pKFswMV1bMC05XXwyWzAtM10pOihbMC01XVswLTldKSkkL2kgfSxcbiAgICAnZW1haWwnOiB7IGVycm9yTWVzc2FnZTogdCgnU3RyaW5nIGlzIG5vdCBhbiBlLW1haWwgYWRkcmVzcy4nKSwgcGF0dGVybjogL14oKFtePD4oKVxcW1xcXVxcXFwuLDs6XFxzQFwiXSsoXFwuW148PigpXFxbXFxdXFxcXC4sOzpcXHNAXCJdKykqKXwoXCIuK1wiKSlAKChcXFtbMC05XXsxLDN9XFwuWzAtOV17MSwzfVxcLlswLTldezEsM31cXC5bMC05XXsxLDN9XSl8KChbYS16QS1aMC05LV0rXFwuKStbYS16QS1aXXsyLH0pKSQvIH0sXG4gICAgJ2hvc3RuYW1lJzogeyBlcnJvck1lc3NhZ2U6IHQoJ1N0cmluZyBpcyBub3QgYSBob3N0bmFtZS4nKSwgcGF0dGVybjogL14oPz0uezEsMjUzfVxcLj8kKVthLXowLTldKD86W2EtejAtOS1dezAsNjF9W2EtejAtOV0pPyg/OlxcLlthLXowLTldKD86Wy0wLTlhLXpdezAsNjF9WzAtOWEtel0pPykqXFwuPyQvaSB9LFxuICAgICdpcHY0JzogeyBlcnJvck1lc3NhZ2U6IHQoJ1N0cmluZyBpcyBub3QgYW4gSVB2NCBhZGRyZXNzLicpLCBwYXR0ZXJuOiAvXig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkkLyB9LFxuICAgICdpcHY2JzogeyBlcnJvck1lc3NhZ2U6IHQoJ1N0cmluZyBpcyBub3QgYW4gSVB2NiBhZGRyZXNzLicpLCBwYXR0ZXJuOiAvXigoKFswLTlhLWZdezEsNH06KXs3fShbMC05YS1mXXsxLDR9fDopKXwoKFswLTlhLWZdezEsNH06KXs2fSg6WzAtOWEtZl17MSw0fXwoKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSl8OikpfCgoWzAtOWEtZl17MSw0fTopezV9KCgoOlswLTlhLWZdezEsNH0pezEsMn0pfDooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSl8OikpfCgoWzAtOWEtZl17MSw0fTopezR9KCgoOlswLTlhLWZdezEsNH0pezEsM30pfCgoOlswLTlhLWZdezEsNH0pPzooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoKFswLTlhLWZdezEsNH06KXszfSgoKDpbMC05YS1mXXsxLDR9KXsxLDR9KXwoKDpbMC05YS1mXXsxLDR9KXswLDJ9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCgoWzAtOWEtZl17MSw0fTopezJ9KCgoOlswLTlhLWZdezEsNH0pezEsNX0pfCgoOlswLTlhLWZdezEsNH0pezAsM306KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KChbMC05YS1mXXsxLDR9Oil7MX0oKCg6WzAtOWEtZl17MSw0fSl7MSw2fSl8KCg6WzAtOWEtZl17MSw0fSl7MCw0fTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoOigoKDpbMC05YS1mXXsxLDR9KXsxLDd9KXwoKDpbMC05YS1mXXsxLDR9KXswLDV9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpKSQvaSB9LFxufTtcbmNsYXNzIEFTVE5vZGVJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIG9mZnNldCwgbGVuZ3RoID0gMCkge1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIH1cbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAndHlwZTogJyArIHRoaXMudHlwZSArICcgKCcgKyB0aGlzLm9mZnNldCArICcvJyArIHRoaXMubGVuZ3RoICsgJyknICsgKHRoaXMucGFyZW50ID8gJyBwYXJlbnQ6IHsnICsgdGhpcy5wYXJlbnQudG9TdHJpbmcoKSArICd9JyA6ICcnKTtcbiAgICB9XG59XG5jbGFzcyBOdWxsQVNUTm9kZUltcGwgZXh0ZW5kcyBBU1ROb2RlSW1wbCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBvZmZzZXQpIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBvZmZzZXQpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnbnVsbCc7XG4gICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgIH1cbn1cbmNsYXNzIEJvb2xlYW5BU1ROb2RlSW1wbCBleHRlbmRzIEFTVE5vZGVJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIGJvb2xWYWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgb2Zmc2V0KTtcbiAgICAgICAgdGhpcy50eXBlID0gJ2Jvb2xlYW4nO1xuICAgICAgICB0aGlzLnZhbHVlID0gYm9vbFZhbHVlO1xuICAgIH1cbn1cbmNsYXNzIEFycmF5QVNUTm9kZUltcGwgZXh0ZW5kcyBBU1ROb2RlSW1wbCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBvZmZzZXQpIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBvZmZzZXQpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnYXJyYXknO1xuICAgICAgICB0aGlzLml0ZW1zID0gW107XG4gICAgfVxuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXM7XG4gICAgfVxufVxuY2xhc3MgTnVtYmVyQVNUTm9kZUltcGwgZXh0ZW5kcyBBU1ROb2RlSW1wbCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBvZmZzZXQpIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBvZmZzZXQpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnbnVtYmVyJztcbiAgICAgICAgdGhpcy5pc0ludGVnZXIgPSB0cnVlO1xuICAgICAgICB0aGlzLnZhbHVlID0gTnVtYmVyLk5hTjtcbiAgICB9XG59XG5jbGFzcyBTdHJpbmdBU1ROb2RlSW1wbCBleHRlbmRzIEFTVE5vZGVJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnc3RyaW5nJztcbiAgICAgICAgdGhpcy52YWx1ZSA9ICcnO1xuICAgIH1cbn1cbmNsYXNzIFByb3BlcnR5QVNUTm9kZUltcGwgZXh0ZW5kcyBBU1ROb2RlSW1wbCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBvZmZzZXQsIGtleU5vZGUpIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBvZmZzZXQpO1xuICAgICAgICB0aGlzLnR5cGUgPSAncHJvcGVydHknO1xuICAgICAgICB0aGlzLmNvbG9uT2Zmc2V0ID0gLTE7XG4gICAgICAgIHRoaXMua2V5Tm9kZSA9IGtleU5vZGU7XG4gICAgfVxuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVOb2RlID8gW3RoaXMua2V5Tm9kZSwgdGhpcy52YWx1ZU5vZGVdIDogW3RoaXMua2V5Tm9kZV07XG4gICAgfVxufVxuY2xhc3MgT2JqZWN0QVNUTm9kZUltcGwgZXh0ZW5kcyBBU1ROb2RlSW1wbCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBvZmZzZXQpIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBvZmZzZXQpO1xuICAgICAgICB0aGlzLnR5cGUgPSAnb2JqZWN0JztcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gW107XG4gICAgfVxuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydGllcztcbiAgICB9XG59XG5mdW5jdGlvbiBhc1NjaGVtYShzY2hlbWEpIHtcbiAgICBpZiAoaXNCb29sZWFuKHNjaGVtYSkpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYSA/IHt9IDogeyBcIm5vdFwiOiB7fSB9O1xuICAgIH1cbiAgICByZXR1cm4gc2NoZW1hO1xufVxudmFyIEVudW1NYXRjaDtcbihmdW5jdGlvbiAoRW51bU1hdGNoKSB7XG4gICAgRW51bU1hdGNoW0VudW1NYXRjaFtcIktleVwiXSA9IDBdID0gXCJLZXlcIjtcbiAgICBFbnVtTWF0Y2hbRW51bU1hdGNoW1wiRW51bVwiXSA9IDFdID0gXCJFbnVtXCI7XG59KShFbnVtTWF0Y2ggfHwgKEVudW1NYXRjaCA9IHt9KSk7XG5jb25zdCBzY2hlbWFEcmFmdEZyb21JZCA9IHtcbiAgICAnaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wMy9zY2hlbWEjJzogU2NoZW1hRHJhZnQudjMsXG4gICAgJ2h0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hIyc6IFNjaGVtYURyYWZ0LnY0LFxuICAgICdodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA2L3NjaGVtYSMnOiBTY2hlbWFEcmFmdC52NixcbiAgICAnaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjJzogU2NoZW1hRHJhZnQudjcsXG4gICAgJ2h0dHBzOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LzIwMTktMDkvc2NoZW1hJzogU2NoZW1hRHJhZnQudjIwMTlfMDksXG4gICAgJ2h0dHBzOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LzIwMjAtMTIvc2NoZW1hJzogU2NoZW1hRHJhZnQudjIwMjBfMTJcbn07XG5jbGFzcyBFdmFsdWF0aW9uQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3Ioc2NoZW1hRHJhZnQpIHtcbiAgICAgICAgdGhpcy5zY2hlbWFEcmFmdCA9IHNjaGVtYURyYWZ0O1xuICAgIH1cbn1cbmNsYXNzIFNjaGVtYUNvbGxlY3RvciB7XG4gICAgY29uc3RydWN0b3IoZm9jdXNPZmZzZXQgPSAtMSwgZXhjbHVkZSkge1xuICAgICAgICB0aGlzLmZvY3VzT2Zmc2V0ID0gZm9jdXNPZmZzZXQ7XG4gICAgICAgIHRoaXMuZXhjbHVkZSA9IGV4Y2x1ZGU7XG4gICAgICAgIHRoaXMuc2NoZW1hcyA9IFtdO1xuICAgIH1cbiAgICBhZGQoc2NoZW1hKSB7XG4gICAgICAgIHRoaXMuc2NoZW1hcy5wdXNoKHNjaGVtYSk7XG4gICAgfVxuICAgIG1lcmdlKG90aGVyKSB7XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMuc2NoZW1hcywgb3RoZXIuc2NoZW1hcyk7XG4gICAgfVxuICAgIGluY2x1ZGUobm9kZSkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZm9jdXNPZmZzZXQgPT09IC0xIHx8IGpzb25QYXJzZXJfY29udGFpbnMobm9kZSwgdGhpcy5mb2N1c09mZnNldCkpICYmIChub2RlICE9PSB0aGlzLmV4Y2x1ZGUpO1xuICAgIH1cbiAgICBuZXdTdWIoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2NoZW1hQ29sbGVjdG9yKC0xLCB0aGlzLmV4Y2x1ZGUpO1xuICAgIH1cbn1cbmNsYXNzIE5vT3BTY2hlbWFDb2xsZWN0b3Ige1xuICAgIGNvbnN0cnVjdG9yKCkgeyB9XG4gICAgZ2V0IHNjaGVtYXMoKSB7IHJldHVybiBbXTsgfVxuICAgIGFkZChfc2NoZW1hKSB7IH1cbiAgICBtZXJnZShfb3RoZXIpIHsgfVxuICAgIGluY2x1ZGUoX25vZGUpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBuZXdTdWIoKSB7IHJldHVybiB0aGlzOyB9XG59XG5Ob09wU2NoZW1hQ29sbGVjdG9yLmluc3RhbmNlID0gbmV3IE5vT3BTY2hlbWFDb2xsZWN0b3IoKTtcbmNsYXNzIFZhbGlkYXRpb25SZXN1bHQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnByb2JsZW1zID0gW107XG4gICAgICAgIHRoaXMucHJvcGVydGllc01hdGNoZXMgPSAwO1xuICAgICAgICB0aGlzLnByb2Nlc3NlZFByb3BlcnRpZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMucHJvcGVydGllc1ZhbHVlTWF0Y2hlcyA9IDA7XG4gICAgICAgIHRoaXMucHJpbWFyeVZhbHVlTWF0Y2hlcyA9IDA7XG4gICAgICAgIHRoaXMuZW51bVZhbHVlTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbnVtVmFsdWVzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBoYXNQcm9ibGVtcygpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5wcm9ibGVtcy5sZW5ndGg7XG4gICAgfVxuICAgIG1lcmdlKHZhbGlkYXRpb25SZXN1bHQpIHtcbiAgICAgICAgdGhpcy5wcm9ibGVtcyA9IHRoaXMucHJvYmxlbXMuY29uY2F0KHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMpO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXNNYXRjaGVzICs9IHZhbGlkYXRpb25SZXN1bHQucHJvcGVydGllc01hdGNoZXM7XG4gICAgICAgIHRoaXMucHJvcGVydGllc1ZhbHVlTWF0Y2hlcyArPSB2YWxpZGF0aW9uUmVzdWx0LnByb3BlcnRpZXNWYWx1ZU1hdGNoZXM7XG4gICAgICAgIHRoaXMubWVyZ2VQcm9jZXNzZWRQcm9wZXJ0aWVzKHZhbGlkYXRpb25SZXN1bHQpO1xuICAgIH1cbiAgICBtZXJnZUVudW1WYWx1ZXModmFsaWRhdGlvblJlc3VsdCkge1xuICAgICAgICBpZiAoIXRoaXMuZW51bVZhbHVlTWF0Y2ggJiYgIXZhbGlkYXRpb25SZXN1bHQuZW51bVZhbHVlTWF0Y2ggJiYgdGhpcy5lbnVtVmFsdWVzICYmIHZhbGlkYXRpb25SZXN1bHQuZW51bVZhbHVlcykge1xuICAgICAgICAgICAgdGhpcy5lbnVtVmFsdWVzID0gdGhpcy5lbnVtVmFsdWVzLmNvbmNhdCh2YWxpZGF0aW9uUmVzdWx0LmVudW1WYWx1ZXMpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBlcnJvciBvZiB0aGlzLnByb2JsZW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IEVycm9yQ29kZS5FbnVtVmFsdWVNaXNtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlID0gdCgnVmFsdWUgaXMgbm90IGFjY2VwdGVkLiBWYWxpZCB2YWx1ZXM6IHswfS4nLCB0aGlzLmVudW1WYWx1ZXMubWFwKHYgPT4gSlNPTi5zdHJpbmdpZnkodikpLmpvaW4oJywgJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBtZXJnZVByb3BlcnR5TWF0Y2gocHJvcGVydHlWYWxpZGF0aW9uUmVzdWx0KSB7XG4gICAgICAgIHRoaXMucHJvYmxlbXMgPSB0aGlzLnByb2JsZW1zLmNvbmNhdChwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMpO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXNNYXRjaGVzKys7XG4gICAgICAgIGlmIChwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQuZW51bVZhbHVlTWF0Y2ggfHwgIXByb3BlcnR5VmFsaWRhdGlvblJlc3VsdC5oYXNQcm9ibGVtcygpICYmIHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdC5wcm9wZXJ0aWVzTWF0Y2hlcykge1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzVmFsdWVNYXRjaGVzKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdC5lbnVtVmFsdWVNYXRjaCAmJiBwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQuZW51bVZhbHVlcyAmJiBwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQuZW51bVZhbHVlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMucHJpbWFyeVZhbHVlTWF0Y2hlcysrO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1lcmdlUHJvY2Vzc2VkUHJvcGVydGllcyh2YWxpZGF0aW9uUmVzdWx0KSB7XG4gICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvY2Vzc2VkUHJvcGVydGllcy5mb3JFYWNoKHAgPT4gdGhpcy5wcm9jZXNzZWRQcm9wZXJ0aWVzLmFkZChwKSk7XG4gICAgfVxuICAgIGNvbXBhcmUob3RoZXIpIHtcbiAgICAgICAgY29uc3QgaGFzUHJvYmxlbXMgPSB0aGlzLmhhc1Byb2JsZW1zKCk7XG4gICAgICAgIGlmIChoYXNQcm9ibGVtcyAhPT0gb3RoZXIuaGFzUHJvYmxlbXMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGhhc1Byb2JsZW1zID8gLTEgOiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVudW1WYWx1ZU1hdGNoICE9PSBvdGhlci5lbnVtVmFsdWVNYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIG90aGVyLmVudW1WYWx1ZU1hdGNoID8gLTEgOiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByaW1hcnlWYWx1ZU1hdGNoZXMgIT09IG90aGVyLnByaW1hcnlWYWx1ZU1hdGNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByaW1hcnlWYWx1ZU1hdGNoZXMgLSBvdGhlci5wcmltYXJ5VmFsdWVNYXRjaGVzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb3BlcnRpZXNWYWx1ZU1hdGNoZXMgIT09IG90aGVyLnByb3BlcnRpZXNWYWx1ZU1hdGNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXNWYWx1ZU1hdGNoZXMgLSBvdGhlci5wcm9wZXJ0aWVzVmFsdWVNYXRjaGVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXNNYXRjaGVzIC0gb3RoZXIucHJvcGVydGllc01hdGNoZXM7XG4gICAgfVxufVxuZnVuY3Rpb24gbmV3SlNPTkRvY3VtZW50KHJvb3QsIGRpYWdub3N0aWNzID0gW10pIHtcbiAgICByZXR1cm4gbmV3IEpTT05Eb2N1bWVudChyb290LCBkaWFnbm9zdGljcywgW10pO1xufVxuZnVuY3Rpb24ganNvblBhcnNlcl9nZXROb2RlVmFsdWUobm9kZSkge1xuICAgIHJldHVybiBtYWluX2dldE5vZGVWYWx1ZShub2RlKTtcbn1cbmZ1bmN0aW9uIGpzb25QYXJzZXJfZ2V0Tm9kZVBhdGgobm9kZSkge1xuICAgIHJldHVybiBtYWluX2dldE5vZGVQYXRoKG5vZGUpO1xufVxuZnVuY3Rpb24ganNvblBhcnNlcl9jb250YWlucyhub2RlLCBvZmZzZXQsIGluY2x1ZGVSaWdodEJvdW5kID0gZmFsc2UpIHtcbiAgICByZXR1cm4gb2Zmc2V0ID49IG5vZGUub2Zmc2V0ICYmIG9mZnNldCA8IChub2RlLm9mZnNldCArIG5vZGUubGVuZ3RoKSB8fCBpbmNsdWRlUmlnaHRCb3VuZCAmJiBvZmZzZXQgPT09IChub2RlLm9mZnNldCArIG5vZGUubGVuZ3RoKTtcbn1cbmNsYXNzIEpTT05Eb2N1bWVudCB7XG4gICAgY29uc3RydWN0b3Iocm9vdCwgc3ludGF4RXJyb3JzID0gW10sIGNvbW1lbnRzID0gW10pIHtcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICAgICAgdGhpcy5zeW50YXhFcnJvcnMgPSBzeW50YXhFcnJvcnM7XG4gICAgICAgIHRoaXMuY29tbWVudHMgPSBjb21tZW50cztcbiAgICB9XG4gICAgZ2V0Tm9kZUZyb21PZmZzZXQob2Zmc2V0LCBpbmNsdWRlUmlnaHRCb3VuZCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLnJvb3QpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWluX2ZpbmROb2RlQXRPZmZzZXQodGhpcy5yb290LCBvZmZzZXQsIGluY2x1ZGVSaWdodEJvdW5kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yKSB7XG4gICAgICAgIGlmICh0aGlzLnJvb3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGRvVmlzaXQgPSAobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBjdG4gPSB2aXNpdG9yKG5vZGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGggJiYgY3RuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0biA9IGRvVmlzaXQoY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjdG47XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZG9WaXNpdCh0aGlzLnJvb3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhbGlkYXRlKHRleHREb2N1bWVudCwgc2NoZW1hLCBzZXZlcml0eSA9IERpYWdub3N0aWNTZXZlcml0eS5XYXJuaW5nLCBzY2hlbWFEcmFmdCkge1xuICAgICAgICBpZiAodGhpcy5yb290ICYmIHNjaGVtYSkge1xuICAgICAgICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IG5ldyBWYWxpZGF0aW9uUmVzdWx0KCk7XG4gICAgICAgICAgICB2YWxpZGF0ZSh0aGlzLnJvb3QsIHNjaGVtYSwgdmFsaWRhdGlvblJlc3VsdCwgTm9PcFNjaGVtYUNvbGxlY3Rvci5pbnN0YW5jZSwgbmV3IEV2YWx1YXRpb25Db250ZXh0KHNjaGVtYURyYWZ0ID8/IGdldFNjaGVtYURyYWZ0KHNjaGVtYSkpKTtcbiAgICAgICAgICAgIHJldHVybiB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLm1hcChwID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IFJhbmdlLmNyZWF0ZSh0ZXh0RG9jdW1lbnQucG9zaXRpb25BdChwLmxvY2F0aW9uLm9mZnNldCksIHRleHREb2N1bWVudC5wb3NpdGlvbkF0KHAubG9jYXRpb24ub2Zmc2V0ICsgcC5sb2NhdGlvbi5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gRGlhZ25vc3RpYy5jcmVhdGUocmFuZ2UsIHAubWVzc2FnZSwgcC5zZXZlcml0eSA/PyBzZXZlcml0eSwgcC5jb2RlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldE1hdGNoaW5nU2NoZW1hcyhzY2hlbWEsIGZvY3VzT2Zmc2V0ID0gLTEsIGV4Y2x1ZGUpIHtcbiAgICAgICAgaWYgKHRoaXMucm9vdCAmJiBzY2hlbWEpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nU2NoZW1hcyA9IG5ldyBTY2hlbWFDb2xsZWN0b3IoZm9jdXNPZmZzZXQsIGV4Y2x1ZGUpO1xuICAgICAgICAgICAgY29uc3Qgc2NoZW1hRHJhZnQgPSBnZXRTY2hlbWFEcmFmdChzY2hlbWEpO1xuICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IG5ldyBFdmFsdWF0aW9uQ29udGV4dChzY2hlbWFEcmFmdCk7XG4gICAgICAgICAgICB2YWxpZGF0ZSh0aGlzLnJvb3QsIHNjaGVtYSwgbmV3IFZhbGlkYXRpb25SZXN1bHQoKSwgbWF0Y2hpbmdTY2hlbWFzLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaGluZ1NjaGVtYXMuc2NoZW1hcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0U2NoZW1hRHJhZnQoc2NoZW1hLCBmYWxsQmFjayA9IFNjaGVtYURyYWZ0LnYyMDIwXzEyKSB7XG4gICAgbGV0IHNjaGVtYUlkID0gc2NoZW1hLiRzY2hlbWE7XG4gICAgaWYgKHNjaGVtYUlkKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWFEcmFmdEZyb21JZFtzY2hlbWFJZF0gPz8gZmFsbEJhY2s7XG4gICAgfVxuICAgIHJldHVybiBmYWxsQmFjaztcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlKG4sIHNjaGVtYSwgdmFsaWRhdGlvblJlc3VsdCwgbWF0Y2hpbmdTY2hlbWFzLCBjb250ZXh0KSB7XG4gICAgaWYgKCFuIHx8ICFtYXRjaGluZ1NjaGVtYXMuaW5jbHVkZShuKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuLnR5cGUgPT09ICdwcm9wZXJ0eScpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKG4udmFsdWVOb2RlLCBzY2hlbWEsIHZhbGlkYXRpb25SZXN1bHQsIG1hdGNoaW5nU2NoZW1hcywgY29udGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSBuO1xuICAgIF92YWxpZGF0ZU5vZGUoKTtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgX3ZhbGlkYXRlT2JqZWN0Tm9kZShub2RlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdhcnJheSc6XG4gICAgICAgICAgICBfdmFsaWRhdGVBcnJheU5vZGUobm9kZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIF92YWxpZGF0ZVN0cmluZ05vZGUobm9kZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgIF92YWxpZGF0ZU51bWJlck5vZGUobm9kZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgbWF0Y2hpbmdTY2hlbWFzLmFkZCh7IG5vZGU6IG5vZGUsIHNjaGVtYTogc2NoZW1hIH0pO1xuICAgIGZ1bmN0aW9uIF92YWxpZGF0ZU5vZGUoKSB7XG4gICAgICAgIGZ1bmN0aW9uIG1hdGNoZXNUeXBlKHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLnR5cGUgPT09IHR5cGUgfHwgKHR5cGUgPT09ICdpbnRlZ2VyJyAmJiBub2RlLnR5cGUgPT09ICdudW1iZXInICYmIG5vZGUuaXNJbnRlZ2VyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEudHlwZSkpIHtcbiAgICAgICAgICAgIGlmICghc2NoZW1hLnR5cGUuc29tZShtYXRjaGVzVHlwZSkpIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogeyBvZmZzZXQ6IG5vZGUub2Zmc2V0LCBsZW5ndGg6IG5vZGUubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHNjaGVtYS5lcnJvck1lc3NhZ2UgfHwgdCgnSW5jb3JyZWN0IHR5cGUuIEV4cGVjdGVkIG9uZSBvZiB7MH0uJywgc2NoZW1hLnR5cGUuam9pbignLCAnKSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzY2hlbWEudHlwZSkge1xuICAgICAgICAgICAgaWYgKCFtYXRjaGVzVHlwZShzY2hlbWEudHlwZSkpIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogeyBvZmZzZXQ6IG5vZGUub2Zmc2V0LCBsZW5ndGg6IG5vZGUubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHNjaGVtYS5lcnJvck1lc3NhZ2UgfHwgdCgnSW5jb3JyZWN0IHR5cGUuIEV4cGVjdGVkIFwiezB9XCIuJywgc2NoZW1hLnR5cGUpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLmFsbE9mKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBzdWJTY2hlbWFSZWYgb2Ygc2NoZW1hLmFsbE9mKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViVmFsaWRhdGlvblJlc3VsdCA9IG5ldyBWYWxpZGF0aW9uUmVzdWx0KCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViTWF0Y2hpbmdTY2hlbWFzID0gbWF0Y2hpbmdTY2hlbWFzLm5ld1N1YigpO1xuICAgICAgICAgICAgICAgIHZhbGlkYXRlKG5vZGUsIGFzU2NoZW1hKHN1YlNjaGVtYVJlZiksIHN1YlZhbGlkYXRpb25SZXN1bHQsIHN1Yk1hdGNoaW5nU2NoZW1hcywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5tZXJnZShzdWJWYWxpZGF0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgICAgICBtYXRjaGluZ1NjaGVtYXMubWVyZ2Uoc3ViTWF0Y2hpbmdTY2hlbWFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub3RTY2hlbWEgPSBhc1NjaGVtYShzY2hlbWEubm90KTtcbiAgICAgICAgaWYgKG5vdFNjaGVtYSkge1xuICAgICAgICAgICAgY29uc3Qgc3ViVmFsaWRhdGlvblJlc3VsdCA9IG5ldyBWYWxpZGF0aW9uUmVzdWx0KCk7XG4gICAgICAgICAgICBjb25zdCBzdWJNYXRjaGluZ1NjaGVtYXMgPSBtYXRjaGluZ1NjaGVtYXMubmV3U3ViKCk7XG4gICAgICAgICAgICB2YWxpZGF0ZShub2RlLCBub3RTY2hlbWEsIHN1YlZhbGlkYXRpb25SZXN1bHQsIHN1Yk1hdGNoaW5nU2NoZW1hcywgY29udGV4dCk7XG4gICAgICAgICAgICBpZiAoIXN1YlZhbGlkYXRpb25SZXN1bHQuaGFzUHJvYmxlbXMoKSkge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogc2NoZW1hLmVycm9yTWVzc2FnZSB8fCB0KFwiTWF0Y2hlcyBhIHNjaGVtYSB0aGF0IGlzIG5vdCBhbGxvd2VkLlwiKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBtcyBvZiBzdWJNYXRjaGluZ1NjaGVtYXMuc2NoZW1hcykge1xuICAgICAgICAgICAgICAgIG1zLmludmVydGVkID0gIW1zLmludmVydGVkO1xuICAgICAgICAgICAgICAgIG1hdGNoaW5nU2NoZW1hcy5hZGQobXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRlc3RBbHRlcm5hdGl2ZXMgPSAoYWx0ZXJuYXRpdmVzLCBtYXhPbmVNYXRjaCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IFtdO1xuICAgICAgICAgICAgLy8gcmVtZW1iZXIgdGhlIGJlc3QgbWF0Y2ggdGhhdCBpcyB1c2VkIGZvciBlcnJvciBtZXNzYWdlc1xuICAgICAgICAgICAgbGV0IGJlc3RNYXRjaCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3ViU2NoZW1hUmVmIG9mIGFsdGVybmF0aXZlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YlNjaGVtYSA9IGFzU2NoZW1hKHN1YlNjaGVtYVJlZik7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViVmFsaWRhdGlvblJlc3VsdCA9IG5ldyBWYWxpZGF0aW9uUmVzdWx0KCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViTWF0Y2hpbmdTY2hlbWFzID0gbWF0Y2hpbmdTY2hlbWFzLm5ld1N1YigpO1xuICAgICAgICAgICAgICAgIHZhbGlkYXRlKG5vZGUsIHN1YlNjaGVtYSwgc3ViVmFsaWRhdGlvblJlc3VsdCwgc3ViTWF0Y2hpbmdTY2hlbWFzLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAoIXN1YlZhbGlkYXRpb25SZXN1bHQuaGFzUHJvYmxlbXMoKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2goc3ViU2NoZW1hKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFiZXN0TWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoID0geyBzY2hlbWE6IHN1YlNjaGVtYSwgdmFsaWRhdGlvblJlc3VsdDogc3ViVmFsaWRhdGlvblJlc3VsdCwgbWF0Y2hpbmdTY2hlbWFzOiBzdWJNYXRjaGluZ1NjaGVtYXMgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWF4T25lTWF0Y2ggJiYgIXN1YlZhbGlkYXRpb25SZXN1bHQuaGFzUHJvYmxlbXMoKSAmJiAhYmVzdE1hdGNoLnZhbGlkYXRpb25SZXN1bHQuaGFzUHJvYmxlbXMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8gZXJyb3JzLCBib3RoIGFyZSBlcXVhbGx5IGdvb2QgbWF0Y2hlc1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLm1hdGNoaW5nU2NoZW1hcy5tZXJnZShzdWJNYXRjaGluZ1NjaGVtYXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLnZhbGlkYXRpb25SZXN1bHQucHJvcGVydGllc01hdGNoZXMgKz0gc3ViVmFsaWRhdGlvblJlc3VsdC5wcm9wZXJ0aWVzTWF0Y2hlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC52YWxpZGF0aW9uUmVzdWx0LnByb3BlcnRpZXNWYWx1ZU1hdGNoZXMgKz0gc3ViVmFsaWRhdGlvblJlc3VsdC5wcm9wZXJ0aWVzVmFsdWVNYXRjaGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLnZhbGlkYXRpb25SZXN1bHQubWVyZ2VQcm9jZXNzZWRQcm9wZXJ0aWVzKHN1YlZhbGlkYXRpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tcGFyZVJlc3VsdCA9IHN1YlZhbGlkYXRpb25SZXN1bHQuY29tcGFyZShiZXN0TWF0Y2gudmFsaWRhdGlvblJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGFyZVJlc3VsdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvdXIgbm9kZSBpcyB0aGUgYmVzdCBtYXRjaGluZyBzbyBmYXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2ggPSB7IHNjaGVtYTogc3ViU2NoZW1hLCB2YWxpZGF0aW9uUmVzdWx0OiBzdWJWYWxpZGF0aW9uUmVzdWx0LCBtYXRjaGluZ1NjaGVtYXM6IHN1Yk1hdGNoaW5nU2NoZW1hcyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29tcGFyZVJlc3VsdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZXJlJ3MgYWxyZWFkeSBhIGJlc3QgbWF0Y2hpbmcgYnV0IHdlIGFyZSBhcyBnb29kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLm1hdGNoaW5nU2NoZW1hcy5tZXJnZShzdWJNYXRjaGluZ1NjaGVtYXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC52YWxpZGF0aW9uUmVzdWx0Lm1lcmdlRW51bVZhbHVlcyhzdWJWYWxpZGF0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCA+IDEgJiYgbWF4T25lTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogeyBvZmZzZXQ6IG5vZGUub2Zmc2V0LCBsZW5ndGg6IDEgfSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogdChcIk1hdGNoZXMgbXVsdGlwbGUgc2NoZW1hcyB3aGVuIG9ubHkgb25lIG11c3QgdmFsaWRhdGUuXCIpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmVzdE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5tZXJnZShiZXN0TWF0Y2gudmFsaWRhdGlvblJlc3VsdCk7XG4gICAgICAgICAgICAgICAgbWF0Y2hpbmdTY2hlbWFzLm1lcmdlKGJlc3RNYXRjaC5tYXRjaGluZ1NjaGVtYXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXMubGVuZ3RoO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEuYW55T2YpKSB7XG4gICAgICAgICAgICB0ZXN0QWx0ZXJuYXRpdmVzKHNjaGVtYS5hbnlPZiwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5vbmVPZikpIHtcbiAgICAgICAgICAgIHRlc3RBbHRlcm5hdGl2ZXMoc2NoZW1hLm9uZU9mLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZXN0QnJhbmNoID0gKHNjaGVtYSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3ViVmFsaWRhdGlvblJlc3VsdCA9IG5ldyBWYWxpZGF0aW9uUmVzdWx0KCk7XG4gICAgICAgICAgICBjb25zdCBzdWJNYXRjaGluZ1NjaGVtYXMgPSBtYXRjaGluZ1NjaGVtYXMubmV3U3ViKCk7XG4gICAgICAgICAgICB2YWxpZGF0ZShub2RlLCBhc1NjaGVtYShzY2hlbWEpLCBzdWJWYWxpZGF0aW9uUmVzdWx0LCBzdWJNYXRjaGluZ1NjaGVtYXMsIGNvbnRleHQpO1xuICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5tZXJnZShzdWJWYWxpZGF0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgIG1hdGNoaW5nU2NoZW1hcy5tZXJnZShzdWJNYXRjaGluZ1NjaGVtYXMpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB0ZXN0Q29uZGl0aW9uID0gKGlmU2NoZW1hLCB0aGVuU2NoZW1hLCBlbHNlU2NoZW1hKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdWJTY2hlbWEgPSBhc1NjaGVtYShpZlNjaGVtYSk7XG4gICAgICAgICAgICBjb25zdCBzdWJWYWxpZGF0aW9uUmVzdWx0ID0gbmV3IFZhbGlkYXRpb25SZXN1bHQoKTtcbiAgICAgICAgICAgIGNvbnN0IHN1Yk1hdGNoaW5nU2NoZW1hcyA9IG1hdGNoaW5nU2NoZW1hcy5uZXdTdWIoKTtcbiAgICAgICAgICAgIHZhbGlkYXRlKG5vZGUsIHN1YlNjaGVtYSwgc3ViVmFsaWRhdGlvblJlc3VsdCwgc3ViTWF0Y2hpbmdTY2hlbWFzLCBjb250ZXh0KTtcbiAgICAgICAgICAgIG1hdGNoaW5nU2NoZW1hcy5tZXJnZShzdWJNYXRjaGluZ1NjaGVtYXMpO1xuICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5tZXJnZVByb2Nlc3NlZFByb3BlcnRpZXMoc3ViVmFsaWRhdGlvblJlc3VsdCk7XG4gICAgICAgICAgICBpZiAoIXN1YlZhbGlkYXRpb25SZXN1bHQuaGFzUHJvYmxlbXMoKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGVuU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlc3RCcmFuY2godGhlblNjaGVtYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZWxzZVNjaGVtYSkge1xuICAgICAgICAgICAgICAgIHRlc3RCcmFuY2goZWxzZVNjaGVtYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGlmU2NoZW1hID0gYXNTY2hlbWEoc2NoZW1hLmlmKTtcbiAgICAgICAgaWYgKGlmU2NoZW1hKSB7XG4gICAgICAgICAgICB0ZXN0Q29uZGl0aW9uKGlmU2NoZW1hLCBhc1NjaGVtYShzY2hlbWEudGhlbiksIGFzU2NoZW1hKHNjaGVtYS5lbHNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLmVudW0pKSB7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSBqc29uUGFyc2VyX2dldE5vZGVWYWx1ZShub2RlKTtcbiAgICAgICAgICAgIGxldCBlbnVtVmFsdWVNYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBlIG9mIHNjaGVtYS5lbnVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVxdWFscyh2YWwsIGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1WYWx1ZU1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5lbnVtVmFsdWVzID0gc2NoZW1hLmVudW07XG4gICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LmVudW1WYWx1ZU1hdGNoID0gZW51bVZhbHVlTWF0Y2g7XG4gICAgICAgICAgICBpZiAoIWVudW1WYWx1ZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBFcnJvckNvZGUuRW51bVZhbHVlTWlzbWF0Y2gsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHNjaGVtYS5lcnJvck1lc3NhZ2UgfHwgdCgnVmFsdWUgaXMgbm90IGFjY2VwdGVkLiBWYWxpZCB2YWx1ZXM6IHswfS4nLCBzY2hlbWEuZW51bS5tYXAodiA9PiBKU09OLnN0cmluZ2lmeSh2KSkuam9pbignLCAnKSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEZWZpbmVkKHNjaGVtYS5jb25zdCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbCA9IGpzb25QYXJzZXJfZ2V0Tm9kZVZhbHVlKG5vZGUpO1xuICAgICAgICAgICAgaWYgKCFlcXVhbHModmFsLCBzY2hlbWEuY29uc3QpKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBFcnJvckNvZGUuRW51bVZhbHVlTWlzbWF0Y2gsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHNjaGVtYS5lcnJvck1lc3NhZ2UgfHwgdCgnVmFsdWUgbXVzdCBiZSB7MH0uJywgSlNPTi5zdHJpbmdpZnkoc2NoZW1hLmNvbnN0KSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LmVudW1WYWx1ZU1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LmVudW1WYWx1ZU1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQuZW51bVZhbHVlcyA9IFtzY2hlbWEuY29uc3RdO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkZXByZWNhdGlvbk1lc3NhZ2UgPSBzY2hlbWEuZGVwcmVjYXRpb25NZXNzYWdlO1xuICAgICAgICBpZiAoZGVwcmVjYXRpb25NZXNzYWdlIHx8IHNjaGVtYS5kZXByZWNhdGVkKSB7XG4gICAgICAgICAgICBkZXByZWNhdGlvbk1lc3NhZ2UgPSBkZXByZWNhdGlvbk1lc3NhZ2UgfHwgdCgnVmFsdWUgaXMgZGVwcmVjYXRlZCcpO1xuICAgICAgICAgICAgbGV0IHRhcmdldE5vZGUgPSBub2RlLnBhcmVudD8udHlwZSA9PT0gJ3Byb3BlcnR5JyA/IG5vZGUucGFyZW50IDogbm9kZTtcbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiB0YXJnZXROb2RlLm9mZnNldCwgbGVuZ3RoOiB0YXJnZXROb2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgIHNldmVyaXR5OiBEaWFnbm9zdGljU2V2ZXJpdHkuV2FybmluZyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZXByZWNhdGlvbk1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgY29kZTogRXJyb3JDb2RlLkRlcHJlY2F0ZWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIF92YWxpZGF0ZU51bWJlck5vZGUobm9kZSkge1xuICAgICAgICBjb25zdCB2YWwgPSBub2RlLnZhbHVlO1xuICAgICAgICBmdW5jdGlvbiBub3JtYWxpemVGbG9hdHMoZmxvYXQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gL14oLT9cXGQrKSg/OlxcLihcXGQrKSk/KD86ZShbLStdXFxkKykpPyQvLmV4ZWMoZmxvYXQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICByZXR1cm4gcGFydHMgJiYge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBOdW1iZXIocGFydHNbMV0gKyAocGFydHNbMl0gfHwgJycpKSxcbiAgICAgICAgICAgICAgICBtdWx0aXBsaWVyOiAocGFydHNbMl0/Lmxlbmd0aCB8fCAwKSAtIChwYXJzZUludChwYXJ0c1szXSkgfHwgMClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICBpZiAoaXNOdW1iZXIoc2NoZW1hLm11bHRpcGxlT2YpKSB7XG4gICAgICAgICAgICBsZXQgcmVtYWluZGVyID0gLTE7XG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihzY2hlbWEubXVsdGlwbGVPZikpIHtcbiAgICAgICAgICAgICAgICByZW1haW5kZXIgPSB2YWwgJSBzY2hlbWEubXVsdGlwbGVPZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBub3JtTXVsdGlwbGVPZiA9IG5vcm1hbGl6ZUZsb2F0cyhzY2hlbWEubXVsdGlwbGVPZik7XG4gICAgICAgICAgICAgICAgbGV0IG5vcm1WYWx1ZSA9IG5vcm1hbGl6ZUZsb2F0cyh2YWwpO1xuICAgICAgICAgICAgICAgIGlmIChub3JtTXVsdGlwbGVPZiAmJiBub3JtVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbXVsdGlwbGllciA9IDEwICoqIE1hdGguYWJzKG5vcm1WYWx1ZS5tdWx0aXBsaWVyIC0gbm9ybU11bHRpcGxlT2YubXVsdGlwbGllcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub3JtVmFsdWUubXVsdGlwbGllciA8IG5vcm1NdWx0aXBsZU9mLm11bHRpcGxpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1WYWx1ZS52YWx1ZSAqPSBtdWx0aXBsaWVyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybU11bHRpcGxlT2YudmFsdWUgKj0gbXVsdGlwbGllcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZW1haW5kZXIgPSBub3JtVmFsdWUudmFsdWUgJSBub3JtTXVsdGlwbGVPZi52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVtYWluZGVyICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiB0KCdWYWx1ZSBpcyBub3QgZGl2aXNpYmxlIGJ5IHswfS4nLCBzY2hlbWEubXVsdGlwbGVPZilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRFeGNsdXNpdmVMaW1pdChsaW1pdCwgZXhjbHVzaXZlKSB7XG4gICAgICAgICAgICBpZiAoaXNOdW1iZXIoZXhjbHVzaXZlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBleGNsdXNpdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNCb29sZWFuKGV4Y2x1c2l2ZSkgJiYgZXhjbHVzaXZlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpbWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRMaW1pdChsaW1pdCwgZXhjbHVzaXZlKSB7XG4gICAgICAgICAgICBpZiAoIWlzQm9vbGVhbihleGNsdXNpdmUpIHx8ICFleGNsdXNpdmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4Y2x1c2l2ZU1pbmltdW0gPSBnZXRFeGNsdXNpdmVMaW1pdChzY2hlbWEubWluaW11bSwgc2NoZW1hLmV4Y2x1c2l2ZU1pbmltdW0pO1xuICAgICAgICBpZiAoaXNOdW1iZXIoZXhjbHVzaXZlTWluaW11bSkgJiYgdmFsIDw9IGV4Y2x1c2l2ZU1pbmltdW0pIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHQoJ1ZhbHVlIGlzIGJlbG93IHRoZSBleGNsdXNpdmUgbWluaW11bSBvZiB7MH0uJywgZXhjbHVzaXZlTWluaW11bSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4Y2x1c2l2ZU1heGltdW0gPSBnZXRFeGNsdXNpdmVMaW1pdChzY2hlbWEubWF4aW11bSwgc2NoZW1hLmV4Y2x1c2l2ZU1heGltdW0pO1xuICAgICAgICBpZiAoaXNOdW1iZXIoZXhjbHVzaXZlTWF4aW11bSkgJiYgdmFsID49IGV4Y2x1c2l2ZU1heGltdW0pIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHQoJ1ZhbHVlIGlzIGFib3ZlIHRoZSBleGNsdXNpdmUgbWF4aW11bSBvZiB7MH0uJywgZXhjbHVzaXZlTWF4aW11bSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1pbmltdW0gPSBnZXRMaW1pdChzY2hlbWEubWluaW11bSwgc2NoZW1hLmV4Y2x1c2l2ZU1pbmltdW0pO1xuICAgICAgICBpZiAoaXNOdW1iZXIobWluaW11bSkgJiYgdmFsIDwgbWluaW11bSkge1xuICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogeyBvZmZzZXQ6IG5vZGUub2Zmc2V0LCBsZW5ndGg6IG5vZGUubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogdCgnVmFsdWUgaXMgYmVsb3cgdGhlIG1pbmltdW0gb2YgezB9LicsIG1pbmltdW0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXhpbXVtID0gZ2V0TGltaXQoc2NoZW1hLm1heGltdW0sIHNjaGVtYS5leGNsdXNpdmVNYXhpbXVtKTtcbiAgICAgICAgaWYgKGlzTnVtYmVyKG1heGltdW0pICYmIHZhbCA+IG1heGltdW0pIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHQoJ1ZhbHVlIGlzIGFib3ZlIHRoZSBtYXhpbXVtIG9mIHswfS4nLCBtYXhpbXVtKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gX3ZhbGlkYXRlU3RyaW5nTm9kZShub2RlKSB7XG4gICAgICAgIGlmIChpc051bWJlcihzY2hlbWEubWluTGVuZ3RoKSAmJiBzdHJpbmdMZW5ndGgobm9kZS52YWx1ZSkgPCBzY2hlbWEubWluTGVuZ3RoKSB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiB0KCdTdHJpbmcgaXMgc2hvcnRlciB0aGFuIHRoZSBtaW5pbXVtIGxlbmd0aCBvZiB7MH0uJywgc2NoZW1hLm1pbkxlbmd0aClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc051bWJlcihzY2hlbWEubWF4TGVuZ3RoKSAmJiBzdHJpbmdMZW5ndGgobm9kZS52YWx1ZSkgPiBzY2hlbWEubWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiB0KCdTdHJpbmcgaXMgbG9uZ2VyIHRoYW4gdGhlIG1heGltdW0gbGVuZ3RoIG9mIHswfS4nLCBzY2hlbWEubWF4TGVuZ3RoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RyaW5nKHNjaGVtYS5wYXR0ZXJuKSkge1xuICAgICAgICAgICAgY29uc3QgcmVnZXggPSBleHRlbmRlZFJlZ0V4cChzY2hlbWEucGF0dGVybik7XG4gICAgICAgICAgICBpZiAoIShyZWdleD8udGVzdChub2RlLnZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogeyBvZmZzZXQ6IG5vZGUub2Zmc2V0LCBsZW5ndGg6IG5vZGUubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHNjaGVtYS5wYXR0ZXJuRXJyb3JNZXNzYWdlIHx8IHNjaGVtYS5lcnJvck1lc3NhZ2UgfHwgdCgnU3RyaW5nIGRvZXMgbm90IG1hdGNoIHRoZSBwYXR0ZXJuIG9mIFwiezB9XCIuJywgc2NoZW1hLnBhdHRlcm4pXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYS5mb3JtYXQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoc2NoZW1hLmZvcm1hdCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3VyaSc6XG4gICAgICAgICAgICAgICAgY2FzZSAndXJpLXJlZmVyZW5jZSc6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlcnJvck1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSB0KCdVUkkgZXhwZWN0ZWQuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IC9eKChbXjovPyNdKz8pOik/KFxcL1xcLyhbXi8/I10qKSk/KFtePyNdKikoXFw/KFteI10qKSk/KCMoLiopKT8vLmV4ZWMobm9kZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSB0KCdVUkkgaXMgZXhwZWN0ZWQuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFtYXRjaFsyXSAmJiBzY2hlbWEuZm9ybWF0ID09PSAndXJpJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSB0KCdVUkkgd2l0aCBhIHNjaGVtZSBpcyBleHBlY3RlZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBzY2hlbWEucGF0dGVybkVycm9yTWVzc2FnZSB8fCBzY2hlbWEuZXJyb3JNZXNzYWdlIHx8IHQoJ1N0cmluZyBpcyBub3QgYSBVUkk6IHswfScsIGVycm9yTWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjb2xvci1oZXgnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2RhdGUtdGltZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAndGltZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZW1haWwnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2hvc3RuYW1lJzpcbiAgICAgICAgICAgICAgICBjYXNlICdpcHY0JzpcbiAgICAgICAgICAgICAgICBjYXNlICdpcHY2JzpcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9ybWF0ID0gZm9ybWF0c1tzY2hlbWEuZm9ybWF0XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLnZhbHVlIHx8ICFmb3JtYXQucGF0dGVybi5leGVjKG5vZGUudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBzY2hlbWEucGF0dGVybkVycm9yTWVzc2FnZSB8fCBzY2hlbWEuZXJyb3JNZXNzYWdlIHx8IGZvcm1hdC5lcnJvck1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBfdmFsaWRhdGVBcnJheU5vZGUobm9kZSkge1xuICAgICAgICBsZXQgcHJlZml4SXRlbXNTY2hlbWFzO1xuICAgICAgICBsZXQgYWRkaXRpb25hbEl0ZW1TY2hlbWE7XG4gICAgICAgIGlmIChjb250ZXh0LnNjaGVtYURyYWZ0ID49IFNjaGVtYURyYWZ0LnYyMDIwXzEyKSB7XG4gICAgICAgICAgICBwcmVmaXhJdGVtc1NjaGVtYXMgPSBzY2hlbWEucHJlZml4SXRlbXM7XG4gICAgICAgICAgICBhZGRpdGlvbmFsSXRlbVNjaGVtYSA9ICFBcnJheS5pc0FycmF5KHNjaGVtYS5pdGVtcykgPyBzY2hlbWEuaXRlbXMgOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwcmVmaXhJdGVtc1NjaGVtYXMgPSBBcnJheS5pc0FycmF5KHNjaGVtYS5pdGVtcykgPyBzY2hlbWEuaXRlbXMgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBhZGRpdGlvbmFsSXRlbVNjaGVtYSA9ICFBcnJheS5pc0FycmF5KHNjaGVtYS5pdGVtcykgPyBzY2hlbWEuaXRlbXMgOiBzY2hlbWEuYWRkaXRpb25hbEl0ZW1zO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIGlmIChwcmVmaXhJdGVtc1NjaGVtYXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgbWF4ID0gTWF0aC5taW4ocHJlZml4SXRlbXNTY2hlbWFzLmxlbmd0aCwgbm9kZS5pdGVtcy5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yICg7IGluZGV4IDwgbWF4OyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViU2NoZW1hUmVmID0gcHJlZml4SXRlbXNTY2hlbWFzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJTY2hlbWEgPSBhc1NjaGVtYShzdWJTY2hlbWFSZWYpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1WYWxpZGF0aW9uUmVzdWx0ID0gbmV3IFZhbGlkYXRpb25SZXN1bHQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gbm9kZS5pdGVtc1tpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGUoaXRlbSwgc3ViU2NoZW1hLCBpdGVtVmFsaWRhdGlvblJlc3VsdCwgbWF0Y2hpbmdTY2hlbWFzLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5tZXJnZVByb3BlcnR5TWF0Y2goaXRlbVZhbGlkYXRpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2Nlc3NlZFByb3BlcnRpZXMuYWRkKFN0cmluZyhpbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhZGRpdGlvbmFsSXRlbVNjaGVtYSAhPT0gdW5kZWZpbmVkICYmIGluZGV4IDwgbm9kZS5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYWRkaXRpb25hbEl0ZW1TY2hlbWEgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGlmIChhZGRpdGlvbmFsSXRlbVNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHQoJ0FycmF5IGhhcyB0b28gbWFueSBpdGVtcyBhY2NvcmRpbmcgdG8gc2NoZW1hLiBFeHBlY3RlZCB7MH0gb3IgZmV3ZXIuJywgaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKDsgaW5kZXggPCBub2RlLml0ZW1zLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2Nlc3NlZFByb3BlcnRpZXMuYWRkKFN0cmluZyhpbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb3BlcnRpZXNWYWx1ZU1hdGNoZXMrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKDsgaW5kZXggPCBub2RlLml0ZW1zLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtVmFsaWRhdGlvblJlc3VsdCA9IG5ldyBWYWxpZGF0aW9uUmVzdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlKG5vZGUuaXRlbXNbaW5kZXhdLCBhZGRpdGlvbmFsSXRlbVNjaGVtYSwgaXRlbVZhbGlkYXRpb25SZXN1bHQsIG1hdGNoaW5nU2NoZW1hcywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQubWVyZ2VQcm9wZXJ0eU1hdGNoKGl0ZW1WYWxpZGF0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9jZXNzZWRQcm9wZXJ0aWVzLmFkZChTdHJpbmcoaW5kZXgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGFpbnNTY2hlbWEgPSBhc1NjaGVtYShzY2hlbWEuY29udGFpbnMpO1xuICAgICAgICBpZiAoY29udGFpbnNTY2hlbWEpIHtcbiAgICAgICAgICAgIGxldCBjb250YWluc0NvdW50ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBub2RlLml0ZW1zLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBub2RlLml0ZW1zW2luZGV4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtVmFsaWRhdGlvblJlc3VsdCA9IG5ldyBWYWxpZGF0aW9uUmVzdWx0KCk7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGUoaXRlbSwgY29udGFpbnNTY2hlbWEsIGl0ZW1WYWxpZGF0aW9uUmVzdWx0LCBOb09wU2NoZW1hQ29sbGVjdG9yLmluc3RhbmNlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW1WYWxpZGF0aW9uUmVzdWx0Lmhhc1Byb2JsZW1zKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbnNDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5zY2hlbWFEcmFmdCA+PSBTY2hlbWFEcmFmdC52MjAyMF8xMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9jZXNzZWRQcm9wZXJ0aWVzLmFkZChTdHJpbmcoaW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb250YWluc0NvdW50ID09PSAwICYmICFpc051bWJlcihzY2hlbWEubWluQ29udGFpbnMpKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBzY2hlbWEuZXJyb3JNZXNzYWdlIHx8IHQoJ0FycmF5IGRvZXMgbm90IGNvbnRhaW4gcmVxdWlyZWQgaXRlbS4nKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKHNjaGVtYS5taW5Db250YWlucykgJiYgY29udGFpbnNDb3VudCA8IHNjaGVtYS5taW5Db250YWlucykge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogc2NoZW1hLmVycm9yTWVzc2FnZSB8fCB0KCdBcnJheSBoYXMgdG9vIGZldyBpdGVtcyB0aGF0IG1hdGNoIHRoZSBjb250YWlucyBjb250cmFpbnQuIEV4cGVjdGVkIHswfSBvciBtb3JlLicsIHNjaGVtYS5taW5Db250YWlucylcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc051bWJlcihzY2hlbWEubWF4Q29udGFpbnMpICYmIGNvbnRhaW5zQ291bnQgPiBzY2hlbWEubWF4Q29udGFpbnMpIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogeyBvZmZzZXQ6IG5vZGUub2Zmc2V0LCBsZW5ndGg6IG5vZGUubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHNjaGVtYS5lcnJvck1lc3NhZ2UgfHwgdCgnQXJyYXkgaGFzIHRvbyBtYW55IGl0ZW1zIHRoYXQgbWF0Y2ggdGhlIGNvbnRhaW5zIGNvbnRyYWludC4gRXhwZWN0ZWQgezB9IG9yIGxlc3MuJywgc2NoZW1hLm1heENvbnRhaW5zKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVuZXZhbHVhdGVkSXRlbXMgPSBzY2hlbWEudW5ldmFsdWF0ZWRJdGVtcztcbiAgICAgICAgaWYgKHVuZXZhbHVhdGVkSXRlbXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLml0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2YWxpZGF0aW9uUmVzdWx0LnByb2Nlc3NlZFByb3BlcnRpZXMuaGFzKFN0cmluZyhpKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVuZXZhbHVhdGVkSXRlbXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiB0KCdJdGVtIGRvZXMgbm90IG1hdGNoIGFueSB2YWxpZGF0aW9uIHJ1bGUgZnJvbSB0aGUgYXJyYXkuJylcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbVZhbGlkYXRpb25SZXN1bHQgPSBuZXcgVmFsaWRhdGlvblJlc3VsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGUobm9kZS5pdGVtc1tpXSwgc2NoZW1hLnVuZXZhbHVhdGVkSXRlbXMsIGl0ZW1WYWxpZGF0aW9uUmVzdWx0LCBtYXRjaGluZ1NjaGVtYXMsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5tZXJnZVByb3BlcnR5TWF0Y2goaXRlbVZhbGlkYXRpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvY2Vzc2VkUHJvcGVydGllcy5hZGQoU3RyaW5nKGkpKTtcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb3BlcnRpZXNWYWx1ZU1hdGNoZXMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOdW1iZXIoc2NoZW1hLm1pbkl0ZW1zKSAmJiBub2RlLml0ZW1zLmxlbmd0aCA8IHNjaGVtYS5taW5JdGVtcykge1xuICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogeyBvZmZzZXQ6IG5vZGUub2Zmc2V0LCBsZW5ndGg6IG5vZGUubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogdCgnQXJyYXkgaGFzIHRvbyBmZXcgaXRlbXMuIEV4cGVjdGVkIHswfSBvciBtb3JlLicsIHNjaGVtYS5taW5JdGVtcylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc051bWJlcihzY2hlbWEubWF4SXRlbXMpICYmIG5vZGUuaXRlbXMubGVuZ3RoID4gc2NoZW1hLm1heEl0ZW1zKSB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiB0KCdBcnJheSBoYXMgdG9vIG1hbnkgaXRlbXMuIEV4cGVjdGVkIHswfSBvciBmZXdlci4nLCBzY2hlbWEubWF4SXRlbXMpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLnVuaXF1ZUl0ZW1zID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBqc29uUGFyc2VyX2dldE5vZGVWYWx1ZShub2RlKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGhhc0R1cGxpY2F0ZXMoKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCB2YWx1ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcXVhbHModmFsdWUsIHZhbHVlc1tqXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzRHVwbGljYXRlcygpKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBub2RlLm9mZnNldCwgbGVuZ3RoOiBub2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiB0KCdBcnJheSBoYXMgZHVwbGljYXRlIGl0ZW1zLicpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gX3ZhbGlkYXRlT2JqZWN0Tm9kZShub2RlKSB7XG4gICAgICAgIGNvbnN0IHNlZW5LZXlzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgY29uc3QgdW5wcm9jZXNzZWRQcm9wZXJ0aWVzID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5Tm9kZSBvZiBub2RlLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHByb3BlcnR5Tm9kZS5rZXlOb2RlLnZhbHVlO1xuICAgICAgICAgICAgc2VlbktleXNba2V5XSA9IHByb3BlcnR5Tm9kZS52YWx1ZU5vZGU7XG4gICAgICAgICAgICB1bnByb2Nlc3NlZFByb3BlcnRpZXMuYWRkKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLnJlcXVpcmVkKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eU5hbWUgb2Ygc2NoZW1hLnJlcXVpcmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWVuS2V5c1twcm9wZXJ0eU5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleU5vZGUgPSBub2RlLnBhcmVudCAmJiBub2RlLnBhcmVudC50eXBlID09PSAncHJvcGVydHknICYmIG5vZGUucGFyZW50LmtleU5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0ga2V5Tm9kZSA/IHsgb2Zmc2V0OiBrZXlOb2RlLm9mZnNldCwgbGVuZ3RoOiBrZXlOb2RlLmxlbmd0aCB9IDogeyBvZmZzZXQ6IG5vZGUub2Zmc2V0LCBsZW5ndGg6IDEgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHQoJ01pc3NpbmcgcHJvcGVydHkgXCJ7MH1cIi4nLCBwcm9wZXJ0eU5hbWUpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9wZXJ0eVByb2Nlc3NlZCA9IChwcm9wKSA9PiB7XG4gICAgICAgICAgICB1bnByb2Nlc3NlZFByb3BlcnRpZXMuZGVsZXRlKHByb3ApO1xuICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9jZXNzZWRQcm9wZXJ0aWVzLmFkZChwcm9wKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHNjaGVtYS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5TmFtZSBvZiBPYmplY3Qua2V5cyhzY2hlbWEucHJvcGVydGllcykpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eVByb2Nlc3NlZChwcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5U2NoZW1hID0gc2NoZW1hLnByb3BlcnRpZXNbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IHNlZW5LZXlzW3Byb3BlcnR5TmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Jvb2xlYW4ocHJvcGVydHlTY2hlbWEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXByb3BlcnR5U2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcGVydHlOb2RlID0gY2hpbGQucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogcHJvcGVydHlOb2RlLmtleU5vZGUub2Zmc2V0LCBsZW5ndGg6IHByb3BlcnR5Tm9kZS5rZXlOb2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBzY2hlbWEuZXJyb3JNZXNzYWdlIHx8IHQoJ1Byb3BlcnR5IHswfSBpcyBub3QgYWxsb3dlZC4nLCBwcm9wZXJ0eU5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb3BlcnRpZXNNYXRjaGVzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9wZXJ0aWVzVmFsdWVNYXRjaGVzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQgPSBuZXcgVmFsaWRhdGlvblJlc3VsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGUoY2hpbGQsIHByb3BlcnR5U2NoZW1hLCBwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQsIG1hdGNoaW5nU2NoZW1hcywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0Lm1lcmdlUHJvcGVydHlNYXRjaChwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEucGF0dGVyblByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcGVydHlQYXR0ZXJuIG9mIE9iamVjdC5rZXlzKHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IGV4dGVuZGVkUmVnRXhwKHByb3BlcnR5UGF0dGVybik7XG4gICAgICAgICAgICAgICAgaWYgKHJlZ2V4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5TmFtZSBvZiB1bnByb2Nlc3NlZFByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWdleC50ZXN0KHByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWQucHVzaChwcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gc2VlbktleXNbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcGVydHlTY2hlbWEgPSBzY2hlbWEucGF0dGVyblByb3BlcnRpZXNbcHJvcGVydHlQYXR0ZXJuXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQm9vbGVhbihwcm9wZXJ0eVNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcHJvcGVydHlTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eU5vZGUgPSBjaGlsZC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBwcm9wZXJ0eU5vZGUua2V5Tm9kZS5vZmZzZXQsIGxlbmd0aDogcHJvcGVydHlOb2RlLmtleU5vZGUubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHNjaGVtYS5lcnJvck1lc3NhZ2UgfHwgdCgnUHJvcGVydHkgezB9IGlzIG5vdCBhbGxvd2VkLicsIHByb3BlcnR5TmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvcGVydGllc01hdGNoZXMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb3BlcnRpZXNWYWx1ZU1hdGNoZXMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdCA9IG5ldyBWYWxpZGF0aW9uUmVzdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZShjaGlsZCwgcHJvcGVydHlTY2hlbWEsIHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdCwgbWF0Y2hpbmdTY2hlbWFzLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQubWVyZ2VQcm9wZXJ0eU1hdGNoKHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2VkLmZvckVhY2gocHJvcGVydHlQcm9jZXNzZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZGRpdGlvbmFsUHJvcGVydGllcyA9IHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcztcbiAgICAgICAgaWYgKGFkZGl0aW9uYWxQcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcGVydHlOYW1lIG9mIHVucHJvY2Vzc2VkUHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIHByb3BlcnR5UHJvY2Vzc2VkKHByb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBzZWVuS2V5c1twcm9wZXJ0eU5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkaXRpb25hbFByb3BlcnRpZXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eU5vZGUgPSBjaGlsZC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogcHJvcGVydHlOb2RlLmtleU5vZGUub2Zmc2V0LCBsZW5ndGg6IHByb3BlcnR5Tm9kZS5rZXlOb2RlLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHNjaGVtYS5lcnJvck1lc3NhZ2UgfHwgdCgnUHJvcGVydHkgezB9IGlzIG5vdCBhbGxvd2VkLicsIHByb3BlcnR5TmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFkZGl0aW9uYWxQcm9wZXJ0aWVzICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQgPSBuZXcgVmFsaWRhdGlvblJlc3VsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGUoY2hpbGQsIGFkZGl0aW9uYWxQcm9wZXJ0aWVzLCBwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQsIG1hdGNoaW5nU2NoZW1hcywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0Lm1lcmdlUHJvcGVydHlNYXRjaChwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVuZXZhbHVhdGVkUHJvcGVydGllcyA9IHNjaGVtYS51bmV2YWx1YXRlZFByb3BlcnRpZXM7XG4gICAgICAgIGlmICh1bmV2YWx1YXRlZFByb3BlcnRpZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5TmFtZSBvZiB1bnByb2Nlc3NlZFByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRpb25SZXN1bHQucHJvY2Vzc2VkUHJvcGVydGllcy5oYXMocHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWQucHVzaChwcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IHNlZW5LZXlzW3Byb3BlcnR5TmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVuZXZhbHVhdGVkUHJvcGVydGllcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eU5vZGUgPSBjaGlsZC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5wcm9ibGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHsgb2Zmc2V0OiBwcm9wZXJ0eU5vZGUua2V5Tm9kZS5vZmZzZXQsIGxlbmd0aDogcHJvcGVydHlOb2RlLmtleU5vZGUubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHNjaGVtYS5lcnJvck1lc3NhZ2UgfHwgdCgnUHJvcGVydHkgezB9IGlzIG5vdCBhbGxvd2VkLicsIHByb3BlcnR5TmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHVuZXZhbHVhdGVkUHJvcGVydGllcyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdCA9IG5ldyBWYWxpZGF0aW9uUmVzdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGUoY2hpbGQsIHVuZXZhbHVhdGVkUHJvcGVydGllcywgcHJvcGVydHlWYWxpZGF0aW9uUmVzdWx0LCBtYXRjaGluZ1NjaGVtYXMsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQubWVyZ2VQcm9wZXJ0eU1hdGNoKHByb3BlcnR5VmFsaWRhdGlvblJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9jZXNzZWQuZm9yRWFjaChwcm9wZXJ0eVByb2Nlc3NlZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTnVtYmVyKHNjaGVtYS5tYXhQcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgaWYgKG5vZGUucHJvcGVydGllcy5sZW5ndGggPiBzY2hlbWEubWF4UHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogdCgnT2JqZWN0IGhhcyBtb3JlIHByb3BlcnRpZXMgdGhhbiBsaW1pdCBvZiB7MH0uJywgc2NoZW1hLm1heFByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTnVtYmVyKHNjaGVtYS5taW5Qcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgaWYgKG5vZGUucHJvcGVydGllcy5sZW5ndGggPCBzY2hlbWEubWluUHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQucHJvYmxlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogdCgnT2JqZWN0IGhhcyBmZXdlciBwcm9wZXJ0aWVzIHRoYW4gdGhlIHJlcXVpcmVkIG51bWJlciBvZiB7MH0nLCBzY2hlbWEubWluUHJvcGVydGllcylcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLmRlcGVuZGVudFJlcXVpcmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEuZGVwZW5kZW50UmVxdWlyZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wID0gc2VlbktleXNba2V5XTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eURlcHMgPSBzY2hlbWEuZGVwZW5kZW50UmVxdWlyZWRba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcCAmJiBBcnJheS5pc0FycmF5KHByb3BlcnR5RGVwcykpIHtcbiAgICAgICAgICAgICAgICAgICAgX3ZhbGlkYXRlUHJvcGVydHlEZXBlbmRlbmNpZXMoa2V5LCBwcm9wZXJ0eURlcHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLmRlcGVuZGVudFNjaGVtYXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYS5kZXBlbmRlbnRTY2hlbWFzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcCA9IHNlZW5LZXlzW2tleV07XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcGVydHlEZXBzID0gc2NoZW1hLmRlcGVuZGVudFNjaGVtYXNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcCAmJiBpc09iamVjdChwcm9wZXJ0eURlcHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIF92YWxpZGF0ZVByb3BlcnR5RGVwZW5kZW5jaWVzKGtleSwgcHJvcGVydHlEZXBzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYS5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYS5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wID0gc2VlbktleXNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcCkge1xuICAgICAgICAgICAgICAgICAgICBfdmFsaWRhdGVQcm9wZXJ0eURlcGVuZGVuY2llcyhrZXksIHNjaGVtYS5kZXBlbmRlbmNpZXNba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb3BlcnR5TmFtZXMgPSBhc1NjaGVtYShzY2hlbWEucHJvcGVydHlOYW1lcyk7XG4gICAgICAgIGlmIChwcm9wZXJ0eU5hbWVzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGYgb2Ygbm9kZS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gZi5rZXlOb2RlO1xuICAgICAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGUoa2V5LCBwcm9wZXJ0eU5hbWVzLCB2YWxpZGF0aW9uUmVzdWx0LCBOb09wU2NoZW1hQ29sbGVjdG9yLmluc3RhbmNlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gX3ZhbGlkYXRlUHJvcGVydHlEZXBlbmRlbmNpZXMoa2V5LCBwcm9wZXJ0eURlcCkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcGVydHlEZXApKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCByZXF1aXJlZFByb3Agb2YgcHJvcGVydHlEZXApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWVuS2V5c1tyZXF1aXJlZFByb3BdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb2JsZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiB7IG9mZnNldDogbm9kZS5vZmZzZXQsIGxlbmd0aDogbm9kZS5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiB0KCdPYmplY3QgaXMgbWlzc2luZyBwcm9wZXJ0eSB7MH0gcmVxdWlyZWQgYnkgcHJvcGVydHkgezF9LicsIHJlcXVpcmVkUHJvcCwga2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0LnByb3BlcnRpZXNWYWx1ZU1hdGNoZXMrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5U2NoZW1hID0gYXNTY2hlbWEocHJvcGVydHlEZXApO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eVNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQgPSBuZXcgVmFsaWRhdGlvblJlc3VsdCgpO1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZShub2RlLCBwcm9wZXJ0eVNjaGVtYSwgcHJvcGVydHlWYWxpZGF0aW9uUmVzdWx0LCBtYXRjaGluZ1NjaGVtYXMsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0Lm1lcmdlUHJvcGVydHlNYXRjaChwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGpzb25QYXJzZXJfcGFyc2UodGV4dERvY3VtZW50LCBjb25maWcpIHtcbiAgICBjb25zdCBwcm9ibGVtcyA9IFtdO1xuICAgIGxldCBsYXN0UHJvYmxlbU9mZnNldCA9IC0xO1xuICAgIGNvbnN0IHRleHQgPSB0ZXh0RG9jdW1lbnQuZ2V0VGV4dCgpO1xuICAgIGNvbnN0IHNjYW5uZXIgPSBtYWluX2NyZWF0ZVNjYW5uZXIodGV4dCwgZmFsc2UpO1xuICAgIGNvbnN0IGNvbW1lbnRSYW5nZXMgPSBjb25maWcgJiYgY29uZmlnLmNvbGxlY3RDb21tZW50cyA/IFtdIDogdW5kZWZpbmVkO1xuICAgIGZ1bmN0aW9uIF9zY2FuTmV4dCgpIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gc2Nhbm5lci5zY2FuKCk7XG4gICAgICAgICAgICBfY2hlY2tTY2FuRXJyb3IoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDEyIC8qIEpzb24uU3ludGF4S2luZC5MaW5lQ29tbWVudFRyaXZpYSAqLzpcbiAgICAgICAgICAgICAgICBjYXNlIDEzIC8qIEpzb24uU3ludGF4S2luZC5CbG9ja0NvbW1lbnRUcml2aWEgKi86XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbW1lbnRSYW5nZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50UmFuZ2VzLnB1c2goUmFuZ2UuY3JlYXRlKHRleHREb2N1bWVudC5wb3NpdGlvbkF0KHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSksIHRleHREb2N1bWVudC5wb3NpdGlvbkF0KHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSArIHNjYW5uZXIuZ2V0VG9rZW5MZW5ndGgoKSkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE1IC8qIEpzb24uU3ludGF4S2luZC5Ucml2aWEgKi86XG4gICAgICAgICAgICAgICAgY2FzZSAxNCAvKiBKc29uLlN5bnRheEtpbmQuTGluZUJyZWFrVHJpdmlhICovOlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gX2FjY2VwdCh0b2tlbikge1xuICAgICAgICBpZiAoc2Nhbm5lci5nZXRUb2tlbigpID09PSB0b2tlbikge1xuICAgICAgICAgICAgX3NjYW5OZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9lcnJvckF0UmFuZ2UobWVzc2FnZSwgY29kZSwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgc2V2ZXJpdHkgPSBEaWFnbm9zdGljU2V2ZXJpdHkuRXJyb3IpIHtcbiAgICAgICAgaWYgKHByb2JsZW1zLmxlbmd0aCA9PT0gMCB8fCBzdGFydE9mZnNldCAhPT0gbGFzdFByb2JsZW1PZmZzZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gUmFuZ2UuY3JlYXRlKHRleHREb2N1bWVudC5wb3NpdGlvbkF0KHN0YXJ0T2Zmc2V0KSwgdGV4dERvY3VtZW50LnBvc2l0aW9uQXQoZW5kT2Zmc2V0KSk7XG4gICAgICAgICAgICBwcm9ibGVtcy5wdXNoKERpYWdub3N0aWMuY3JlYXRlKHJhbmdlLCBtZXNzYWdlLCBzZXZlcml0eSwgY29kZSwgdGV4dERvY3VtZW50Lmxhbmd1YWdlSWQpKTtcbiAgICAgICAgICAgIGxhc3RQcm9ibGVtT2Zmc2V0ID0gc3RhcnRPZmZzZXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gX2Vycm9yKG1lc3NhZ2UsIGNvZGUsIG5vZGUgPSB1bmRlZmluZWQsIHNraXBVbnRpbEFmdGVyID0gW10sIHNraXBVbnRpbCA9IFtdKSB7XG4gICAgICAgIGxldCBzdGFydCA9IHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKTtcbiAgICAgICAgbGV0IGVuZCA9IHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSArIHNjYW5uZXIuZ2V0VG9rZW5MZW5ndGgoKTtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSBlbmQgJiYgc3RhcnQgPiAwKSB7XG4gICAgICAgICAgICBzdGFydC0tO1xuICAgICAgICAgICAgd2hpbGUgKHN0YXJ0ID4gMCAmJiAvXFxzLy50ZXN0KHRleHQuY2hhckF0KHN0YXJ0KSkpIHtcbiAgICAgICAgICAgICAgICBzdGFydC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5kID0gc3RhcnQgKyAxO1xuICAgICAgICB9XG4gICAgICAgIF9lcnJvckF0UmFuZ2UobWVzc2FnZSwgY29kZSwgc3RhcnQsIGVuZCk7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICBfZmluYWxpemUobm9kZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChza2lwVW50aWxBZnRlci5sZW5ndGggKyBza2lwVW50aWwubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IHRva2VuID0gc2Nhbm5lci5nZXRUb2tlbigpO1xuICAgICAgICAgICAgd2hpbGUgKHRva2VuICE9PSAxNyAvKiBKc29uLlN5bnRheEtpbmQuRU9GICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNraXBVbnRpbEFmdGVyLmluZGV4T2YodG9rZW4pICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBfc2Nhbk5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNraXBVbnRpbC5pbmRleE9mKHRva2VuKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRva2VuID0gX3NjYW5OZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9jaGVja1NjYW5FcnJvcigpIHtcbiAgICAgICAgc3dpdGNoIChzY2FubmVyLmdldFRva2VuRXJyb3IoKSkge1xuICAgICAgICAgICAgY2FzZSA0IC8qIEpzb24uU2NhbkVycm9yLkludmFsaWRVbmljb2RlICovOlxuICAgICAgICAgICAgICAgIF9lcnJvcih0KCdJbnZhbGlkIHVuaWNvZGUgc2VxdWVuY2UgaW4gc3RyaW5nLicpLCBFcnJvckNvZGUuSW52YWxpZFVuaWNvZGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY2FzZSA1IC8qIEpzb24uU2NhbkVycm9yLkludmFsaWRFc2NhcGVDaGFyYWN0ZXIgKi86XG4gICAgICAgICAgICAgICAgX2Vycm9yKHQoJ0ludmFsaWQgZXNjYXBlIGNoYXJhY3RlciBpbiBzdHJpbmcuJyksIEVycm9yQ29kZS5JbnZhbGlkRXNjYXBlQ2hhcmFjdGVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGNhc2UgMyAvKiBKc29uLlNjYW5FcnJvci5VbmV4cGVjdGVkRW5kT2ZOdW1iZXIgKi86XG4gICAgICAgICAgICAgICAgX2Vycm9yKHQoJ1VuZXhwZWN0ZWQgZW5kIG9mIG51bWJlci4nKSwgRXJyb3JDb2RlLlVuZXhwZWN0ZWRFbmRPZk51bWJlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBjYXNlIDEgLyogSnNvbi5TY2FuRXJyb3IuVW5leHBlY3RlZEVuZE9mQ29tbWVudCAqLzpcbiAgICAgICAgICAgICAgICBfZXJyb3IodCgnVW5leHBlY3RlZCBlbmQgb2YgY29tbWVudC4nKSwgRXJyb3JDb2RlLlVuZXhwZWN0ZWRFbmRPZkNvbW1lbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY2FzZSAyIC8qIEpzb24uU2NhbkVycm9yLlVuZXhwZWN0ZWRFbmRPZlN0cmluZyAqLzpcbiAgICAgICAgICAgICAgICBfZXJyb3IodCgnVW5leHBlY3RlZCBlbmQgb2Ygc3RyaW5nLicpLCBFcnJvckNvZGUuVW5leHBlY3RlZEVuZE9mU3RyaW5nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGNhc2UgNiAvKiBKc29uLlNjYW5FcnJvci5JbnZhbGlkQ2hhcmFjdGVyICovOlxuICAgICAgICAgICAgICAgIF9lcnJvcih0KCdJbnZhbGlkIGNoYXJhY3RlcnMgaW4gc3RyaW5nLiBDb250cm9sIGNoYXJhY3RlcnMgbXVzdCBiZSBlc2NhcGVkLicpLCBFcnJvckNvZGUuSW52YWxpZENoYXJhY3Rlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfZmluYWxpemUobm9kZSwgc2Nhbk5leHQpIHtcbiAgICAgICAgbm9kZS5sZW5ndGggPSBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkgKyBzY2FubmVyLmdldFRva2VuTGVuZ3RoKCkgLSBub2RlLm9mZnNldDtcbiAgICAgICAgaWYgKHNjYW5OZXh0KSB7XG4gICAgICAgICAgICBfc2Nhbk5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX3BhcnNlQXJyYXkocGFyZW50KSB7XG4gICAgICAgIGlmIChzY2FubmVyLmdldFRva2VuKCkgIT09IDMgLyogSnNvbi5TeW50YXhLaW5kLk9wZW5CcmFja2V0VG9rZW4gKi8pIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBBcnJheUFTVE5vZGVJbXBsKHBhcmVudCwgc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpKTtcbiAgICAgICAgX3NjYW5OZXh0KCk7IC8vIGNvbnN1bWUgT3BlbkJyYWNrZXRUb2tlblxuICAgICAgICBjb25zdCBjb3VudCA9IDA7XG4gICAgICAgIGxldCBuZWVkc0NvbW1hID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChzY2FubmVyLmdldFRva2VuKCkgIT09IDQgLyogSnNvbi5TeW50YXhLaW5kLkNsb3NlQnJhY2tldFRva2VuICovICYmIHNjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gMTcgLyogSnNvbi5TeW50YXhLaW5kLkVPRiAqLykge1xuICAgICAgICAgICAgaWYgKHNjYW5uZXIuZ2V0VG9rZW4oKSA9PT0gNSAvKiBKc29uLlN5bnRheEtpbmQuQ29tbWFUb2tlbiAqLykge1xuICAgICAgICAgICAgICAgIGlmICghbmVlZHNDb21tYSkge1xuICAgICAgICAgICAgICAgICAgICBfZXJyb3IodCgnVmFsdWUgZXhwZWN0ZWQnKSwgRXJyb3JDb2RlLlZhbHVlRXhwZWN0ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjb21tYU9mZnNldCA9IHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKTtcbiAgICAgICAgICAgICAgICBfc2Nhbk5leHQoKTsgLy8gY29uc3VtZSBjb21tYVxuICAgICAgICAgICAgICAgIGlmIChzY2FubmVyLmdldFRva2VuKCkgPT09IDQgLyogSnNvbi5TeW50YXhLaW5kLkNsb3NlQnJhY2tldFRva2VuICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZWVkc0NvbW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZXJyb3JBdFJhbmdlKHQoJ1RyYWlsaW5nIGNvbW1hJyksIEVycm9yQ29kZS5UcmFpbGluZ0NvbW1hLCBjb21tYU9mZnNldCwgY29tbWFPZmZzZXQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZWVkc0NvbW1hKSB7XG4gICAgICAgICAgICAgICAgX2Vycm9yKHQoJ0V4cGVjdGVkIGNvbW1hJyksIEVycm9yQ29kZS5Db21tYUV4cGVjdGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBfcGFyc2VWYWx1ZShub2RlKTtcbiAgICAgICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgICAgIF9lcnJvcih0KCdWYWx1ZSBleHBlY3RlZCcpLCBFcnJvckNvZGUuVmFsdWVFeHBlY3RlZCwgdW5kZWZpbmVkLCBbXSwgWzQgLyogSnNvbi5TeW50YXhLaW5kLkNsb3NlQnJhY2tldFRva2VuICovLCA1IC8qIEpzb24uU3ludGF4S2luZC5Db21tYVRva2VuICovXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlLml0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZWVkc0NvbW1hID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Nhbm5lci5nZXRUb2tlbigpICE9PSA0IC8qIEpzb24uU3ludGF4S2luZC5DbG9zZUJyYWNrZXRUb2tlbiAqLykge1xuICAgICAgICAgICAgcmV0dXJuIF9lcnJvcih0KCdFeHBlY3RlZCBjb21tYSBvciBjbG9zaW5nIGJyYWNrZXQnKSwgRXJyb3JDb2RlLkNvbW1hT3JDbG9zZUJhY2tldEV4cGVjdGVkLCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2ZpbmFsaXplKG5vZGUsIHRydWUpO1xuICAgIH1cbiAgICBjb25zdCBrZXlQbGFjZWhvbGRlciA9IG5ldyBTdHJpbmdBU1ROb2RlSW1wbCh1bmRlZmluZWQsIDAsIDApO1xuICAgIGZ1bmN0aW9uIF9wYXJzZVByb3BlcnR5KHBhcmVudCwga2V5c1NlZW4pIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBQcm9wZXJ0eUFTVE5vZGVJbXBsKHBhcmVudCwgc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpLCBrZXlQbGFjZWhvbGRlcik7XG4gICAgICAgIGxldCBrZXkgPSBfcGFyc2VTdHJpbmcobm9kZSk7XG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICBpZiAoc2Nhbm5lci5nZXRUb2tlbigpID09PSAxNiAvKiBKc29uLlN5bnRheEtpbmQuVW5rbm93biAqLykge1xuICAgICAgICAgICAgICAgIC8vIGdpdmUgYSBtb3JlIGhlbHBmdWwgZXJyb3IgbWVzc2FnZVxuICAgICAgICAgICAgICAgIF9lcnJvcih0KCdQcm9wZXJ0eSBrZXlzIG11c3QgYmUgZG91YmxlcXVvdGVkJyksIEVycm9yQ29kZS5Qcm9wZXJ0eUtleXNNdXN0QmVEb3VibGVxdW90ZWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleU5vZGUgPSBuZXcgU3RyaW5nQVNUTm9kZUltcGwobm9kZSwgc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpLCBzY2FubmVyLmdldFRva2VuTGVuZ3RoKCkpO1xuICAgICAgICAgICAgICAgIGtleU5vZGUudmFsdWUgPSBzY2FubmVyLmdldFRva2VuVmFsdWUoKTtcbiAgICAgICAgICAgICAgICBrZXkgPSBrZXlOb2RlO1xuICAgICAgICAgICAgICAgIF9zY2FuTmV4dCgpOyAvLyBjb25zdW1lIFVua25vd25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5rZXlOb2RlID0ga2V5O1xuICAgICAgICAvLyBGb3IgSlNPTiBmaWxlcyB0aGF0IGZvcmJpZCBjb2RlIGNvbW1lbnRzLCB0aGVyZSBpcyBhIGNvbnZlbnRpb24gdG8gdXNlIHRoZSBrZXkgbmFtZSBcIi8vXCIgdG8gYWRkIGNvbW1lbnRzLlxuICAgICAgICAvLyBNdWx0aXBsZSBpbnN0YW5jZXMgb2YgXCIvL1wiIGFyZSBva2F5LlxuICAgICAgICBpZiAoa2V5LnZhbHVlICE9PSBcIi8vXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlZW4gPSBrZXlzU2VlbltrZXkudmFsdWVdO1xuICAgICAgICAgICAgaWYgKHNlZW4pIHtcbiAgICAgICAgICAgICAgICBfZXJyb3JBdFJhbmdlKHQoXCJEdXBsaWNhdGUgb2JqZWN0IGtleVwiKSwgRXJyb3JDb2RlLkR1cGxpY2F0ZUtleSwgbm9kZS5rZXlOb2RlLm9mZnNldCwgbm9kZS5rZXlOb2RlLm9mZnNldCArIG5vZGUua2V5Tm9kZS5sZW5ndGgsIERpYWdub3N0aWNTZXZlcml0eS5XYXJuaW5nKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3Qoc2VlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgX2Vycm9yQXRSYW5nZSh0KFwiRHVwbGljYXRlIG9iamVjdCBrZXlcIiksIEVycm9yQ29kZS5EdXBsaWNhdGVLZXksIHNlZW4ua2V5Tm9kZS5vZmZzZXQsIHNlZW4ua2V5Tm9kZS5vZmZzZXQgKyBzZWVuLmtleU5vZGUubGVuZ3RoLCBEaWFnbm9zdGljU2V2ZXJpdHkuV2FybmluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGtleXNTZWVuW2tleS52YWx1ZV0gPSB0cnVlOyAvLyBpZiB0aGUgc2FtZSBrZXkgaXMgZHVwbGljYXRlIGFnYWluLCBhdm9pZCBkdXBsaWNhdGUgZXJyb3IgcmVwb3J0aW5nXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBrZXlzU2VlbltrZXkudmFsdWVdID0gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Nhbm5lci5nZXRUb2tlbigpID09PSA2IC8qIEpzb24uU3ludGF4S2luZC5Db2xvblRva2VuICovKSB7XG4gICAgICAgICAgICBub2RlLmNvbG9uT2Zmc2V0ID0gc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpO1xuICAgICAgICAgICAgX3NjYW5OZXh0KCk7IC8vIGNvbnN1bWUgQ29sb25Ub2tlblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX2Vycm9yKHQoJ0NvbG9uIGV4cGVjdGVkJyksIEVycm9yQ29kZS5Db2xvbkV4cGVjdGVkKTtcbiAgICAgICAgICAgIGlmIChzY2FubmVyLmdldFRva2VuKCkgPT09IDEwIC8qIEpzb24uU3ludGF4S2luZC5TdHJpbmdMaXRlcmFsICovICYmIHRleHREb2N1bWVudC5wb3NpdGlvbkF0KGtleS5vZmZzZXQgKyBrZXkubGVuZ3RoKS5saW5lIDwgdGV4dERvY3VtZW50LnBvc2l0aW9uQXQoc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpKS5saW5lKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5sZW5ndGggPSBrZXkubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gX3BhcnNlVmFsdWUobm9kZSk7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBfZXJyb3IodCgnVmFsdWUgZXhwZWN0ZWQnKSwgRXJyb3JDb2RlLlZhbHVlRXhwZWN0ZWQsIG5vZGUsIFtdLCBbMiAvKiBKc29uLlN5bnRheEtpbmQuQ2xvc2VCcmFjZVRva2VuICovLCA1IC8qIEpzb24uU3ludGF4S2luZC5Db21tYVRva2VuICovXSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS52YWx1ZU5vZGUgPSB2YWx1ZTtcbiAgICAgICAgbm9kZS5sZW5ndGggPSB2YWx1ZS5vZmZzZXQgKyB2YWx1ZS5sZW5ndGggLSBub2RlLm9mZnNldDtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9wYXJzZU9iamVjdChwYXJlbnQpIHtcbiAgICAgICAgaWYgKHNjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gMSAvKiBKc29uLlN5bnRheEtpbmQuT3BlbkJyYWNlVG9rZW4gKi8pIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBPYmplY3RBU1ROb2RlSW1wbChwYXJlbnQsIHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSk7XG4gICAgICAgIGNvbnN0IGtleXNTZWVuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgX3NjYW5OZXh0KCk7IC8vIGNvbnN1bWUgT3BlbkJyYWNlVG9rZW5cbiAgICAgICAgbGV0IG5lZWRzQ29tbWEgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKHNjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gMiAvKiBKc29uLlN5bnRheEtpbmQuQ2xvc2VCcmFjZVRva2VuICovICYmIHNjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gMTcgLyogSnNvbi5TeW50YXhLaW5kLkVPRiAqLykge1xuICAgICAgICAgICAgaWYgKHNjYW5uZXIuZ2V0VG9rZW4oKSA9PT0gNSAvKiBKc29uLlN5bnRheEtpbmQuQ29tbWFUb2tlbiAqLykge1xuICAgICAgICAgICAgICAgIGlmICghbmVlZHNDb21tYSkge1xuICAgICAgICAgICAgICAgICAgICBfZXJyb3IodCgnUHJvcGVydHkgZXhwZWN0ZWQnKSwgRXJyb3JDb2RlLlByb3BlcnR5RXhwZWN0ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjb21tYU9mZnNldCA9IHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKTtcbiAgICAgICAgICAgICAgICBfc2Nhbk5leHQoKTsgLy8gY29uc3VtZSBjb21tYVxuICAgICAgICAgICAgICAgIGlmIChzY2FubmVyLmdldFRva2VuKCkgPT09IDIgLyogSnNvbi5TeW50YXhLaW5kLkNsb3NlQnJhY2VUb2tlbiAqLykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmVlZHNDb21tYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2Vycm9yQXRSYW5nZSh0KCdUcmFpbGluZyBjb21tYScpLCBFcnJvckNvZGUuVHJhaWxpbmdDb21tYSwgY29tbWFPZmZzZXQsIGNvbW1hT2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmVlZHNDb21tYSkge1xuICAgICAgICAgICAgICAgIF9lcnJvcih0KCdFeHBlY3RlZCBjb21tYScpLCBFcnJvckNvZGUuQ29tbWFFeHBlY3RlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwcm9wZXJ0eSA9IF9wYXJzZVByb3BlcnR5KG5vZGUsIGtleXNTZWVuKTtcbiAgICAgICAgICAgIGlmICghcHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBfZXJyb3IodCgnUHJvcGVydHkgZXhwZWN0ZWQnKSwgRXJyb3JDb2RlLlByb3BlcnR5RXhwZWN0ZWQsIHVuZGVmaW5lZCwgW10sIFsyIC8qIEpzb24uU3ludGF4S2luZC5DbG9zZUJyYWNlVG9rZW4gKi8sIDUgLyogSnNvbi5TeW50YXhLaW5kLkNvbW1hVG9rZW4gKi9dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUucHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5lZWRzQ29tbWEgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2FubmVyLmdldFRva2VuKCkgIT09IDIgLyogSnNvbi5TeW50YXhLaW5kLkNsb3NlQnJhY2VUb2tlbiAqLykge1xuICAgICAgICAgICAgcmV0dXJuIF9lcnJvcih0KCdFeHBlY3RlZCBjb21tYSBvciBjbG9zaW5nIGJyYWNlJyksIEVycm9yQ29kZS5Db21tYU9yQ2xvc2VCcmFjZUV4cGVjdGVkLCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2ZpbmFsaXplKG5vZGUsIHRydWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfcGFyc2VTdHJpbmcocGFyZW50KSB7XG4gICAgICAgIGlmIChzY2FubmVyLmdldFRva2VuKCkgIT09IDEwIC8qIEpzb24uU3ludGF4S2luZC5TdHJpbmdMaXRlcmFsICovKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgU3RyaW5nQVNUTm9kZUltcGwocGFyZW50LCBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkpO1xuICAgICAgICBub2RlLnZhbHVlID0gc2Nhbm5lci5nZXRUb2tlblZhbHVlKCk7XG4gICAgICAgIHJldHVybiBfZmluYWxpemUobm9kZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9wYXJzZU51bWJlcihwYXJlbnQpIHtcbiAgICAgICAgaWYgKHNjYW5uZXIuZ2V0VG9rZW4oKSAhPT0gMTEgLyogSnNvbi5TeW50YXhLaW5kLk51bWVyaWNMaXRlcmFsICovKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgTnVtYmVyQVNUTm9kZUltcGwocGFyZW50LCBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkpO1xuICAgICAgICBpZiAoc2Nhbm5lci5nZXRUb2tlbkVycm9yKCkgPT09IDAgLyogSnNvbi5TY2FuRXJyb3IuTm9uZSAqLykge1xuICAgICAgICAgICAgY29uc3QgdG9rZW5WYWx1ZSA9IHNjYW5uZXIuZ2V0VG9rZW5WYWx1ZSgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBudW1iZXJWYWx1ZSA9IEpTT04ucGFyc2UodG9rZW5WYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc051bWJlcihudW1iZXJWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9lcnJvcih0KCdJbnZhbGlkIG51bWJlciBmb3JtYXQuJyksIEVycm9yQ29kZS5VbmRlZmluZWQsIG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlLnZhbHVlID0gbnVtYmVyVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZXJyb3IodCgnSW52YWxpZCBudW1iZXIgZm9ybWF0LicpLCBFcnJvckNvZGUuVW5kZWZpbmVkLCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUuaXNJbnRlZ2VyID0gdG9rZW5WYWx1ZS5pbmRleE9mKCcuJykgPT09IC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfZmluYWxpemUobm9kZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9wYXJzZUxpdGVyYWwocGFyZW50KSB7XG4gICAgICAgIGxldCBub2RlO1xuICAgICAgICBzd2l0Y2ggKHNjYW5uZXIuZ2V0VG9rZW4oKSkge1xuICAgICAgICAgICAgY2FzZSA3IC8qIEpzb24uU3ludGF4S2luZC5OdWxsS2V5d29yZCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZpbmFsaXplKG5ldyBOdWxsQVNUTm9kZUltcGwocGFyZW50LCBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkpLCB0cnVlKTtcbiAgICAgICAgICAgIGNhc2UgOCAvKiBKc29uLlN5bnRheEtpbmQuVHJ1ZUtleXdvcmQgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9maW5hbGl6ZShuZXcgQm9vbGVhbkFTVE5vZGVJbXBsKHBhcmVudCwgdHJ1ZSwgc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpKSwgdHJ1ZSk7XG4gICAgICAgICAgICBjYXNlIDkgLyogSnNvbi5TeW50YXhLaW5kLkZhbHNlS2V5d29yZCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZpbmFsaXplKG5ldyBCb29sZWFuQVNUTm9kZUltcGwocGFyZW50LCBmYWxzZSwgc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpKSwgdHJ1ZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gX3BhcnNlVmFsdWUocGFyZW50KSB7XG4gICAgICAgIHJldHVybiBfcGFyc2VBcnJheShwYXJlbnQpIHx8IF9wYXJzZU9iamVjdChwYXJlbnQpIHx8IF9wYXJzZVN0cmluZyhwYXJlbnQpIHx8IF9wYXJzZU51bWJlcihwYXJlbnQpIHx8IF9wYXJzZUxpdGVyYWwocGFyZW50KTtcbiAgICB9XG4gICAgbGV0IF9yb290ID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHRva2VuID0gX3NjYW5OZXh0KCk7XG4gICAgaWYgKHRva2VuICE9PSAxNyAvKiBKc29uLlN5bnRheEtpbmQuRU9GICovKSB7XG4gICAgICAgIF9yb290ID0gX3BhcnNlVmFsdWUoX3Jvb3QpO1xuICAgICAgICBpZiAoIV9yb290KSB7XG4gICAgICAgICAgICBfZXJyb3IodCgnRXhwZWN0ZWQgYSBKU09OIG9iamVjdCwgYXJyYXkgb3IgbGl0ZXJhbC4nKSwgRXJyb3JDb2RlLlVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2Nhbm5lci5nZXRUb2tlbigpICE9PSAxNyAvKiBKc29uLlN5bnRheEtpbmQuRU9GICovKSB7XG4gICAgICAgICAgICBfZXJyb3IodCgnRW5kIG9mIGZpbGUgZXhwZWN0ZWQuJyksIEVycm9yQ29kZS5VbmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgSlNPTkRvY3VtZW50KF9yb290LCBwcm9ibGVtcywgY29tbWVudFJhbmdlcyk7XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL2xpYi9lc20vdXRpbHMvanNvbi5qc1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5mdW5jdGlvbiBzdHJpbmdpZnlPYmplY3Qob2JqLCBpbmRlbnQsIHN0cmluZ2lmeUxpdGVyYWwpIHtcbiAgICBpZiAob2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbnN0IG5ld0luZGVudCA9IGluZGVudCArICdcXHQnO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICBpZiAob2JqLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnW10nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9ICdbXFxuJztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IG5ld0luZGVudCArIHN0cmluZ2lmeU9iamVjdChvYmpbaV0sIG5ld0luZGVudCwgc3RyaW5naWZ5TGl0ZXJhbCk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCBvYmoubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJywnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgKz0gaW5kZW50ICsgJ10nO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICd7fSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gJ3tcXG4nO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gbmV3SW5kZW50ICsgSlNPTi5zdHJpbmdpZnkoa2V5KSArICc6ICcgKyBzdHJpbmdpZnlPYmplY3Qob2JqW2tleV0sIG5ld0luZGVudCwgc3RyaW5naWZ5TGl0ZXJhbCk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCBrZXlzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcsJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcXG4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ICs9IGluZGVudCArICd9JztcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZ2lmeUxpdGVyYWwob2JqKTtcbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy92c2NvZGUtanNvbi1sYW5ndWFnZXNlcnZpY2UvbGliL2VzbS9zZXJ2aWNlcy9qc29uQ29tcGxldGlvbi5qc1xuLyogcHJvdmlkZWQgZGVwZW5kZW5jeSAqLyB2YXIgY29uc29sZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDM2NCk7XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cblxuXG5cblxuY29uc3QgdmFsdWVDb21taXRDaGFyYWN0ZXJzID0gWycsJywgJ30nLCAnXSddO1xuY29uc3QgcHJvcGVydHlDb21taXRDaGFyYWN0ZXJzID0gWyc6J107XG5jbGFzcyBKU09OQ29tcGxldGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc2NoZW1hU2VydmljZSwgY29udHJpYnV0aW9ucyA9IFtdLCBwcm9taXNlQ29uc3RydWN0b3IgPSBQcm9taXNlLCBjbGllbnRDYXBhYmlsaXRpZXMgPSB7fSkge1xuICAgICAgICB0aGlzLnNjaGVtYVNlcnZpY2UgPSBzY2hlbWFTZXJ2aWNlO1xuICAgICAgICB0aGlzLmNvbnRyaWJ1dGlvbnMgPSBjb250cmlidXRpb25zO1xuICAgICAgICB0aGlzLnByb21pc2VDb25zdHJ1Y3RvciA9IHByb21pc2VDb25zdHJ1Y3RvcjtcbiAgICAgICAgdGhpcy5jbGllbnRDYXBhYmlsaXRpZXMgPSBjbGllbnRDYXBhYmlsaXRpZXM7XG4gICAgfVxuICAgIGRvUmVzb2x2ZShpdGVtKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmNvbnRyaWJ1dGlvbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVDb21wbGV0aW9uID0gdGhpcy5jb250cmlidXRpb25zW2ldLnJlc29sdmVDb21wbGV0aW9uO1xuICAgICAgICAgICAgaWYgKHJlc29sdmVDb21wbGV0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSByZXNvbHZlQ29tcGxldGlvbihpdGVtKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlQ29uc3RydWN0b3IucmVzb2x2ZShpdGVtKTtcbiAgICB9XG4gICAgZG9Db21wbGV0ZShkb2N1bWVudCwgcG9zaXRpb24sIGRvYykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICBpdGVtczogW10sXG4gICAgICAgICAgICBpc0luY29tcGxldGU6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHRleHQgPSBkb2N1bWVudC5nZXRUZXh0KCk7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGRvY3VtZW50Lm9mZnNldEF0KHBvc2l0aW9uKTtcbiAgICAgICAgbGV0IG5vZGUgPSBkb2MuZ2V0Tm9kZUZyb21PZmZzZXQob2Zmc2V0LCB0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMuaXNJbkNvbW1lbnQoZG9jdW1lbnQsIG5vZGUgPyBub2RlLm9mZnNldCA6IDAsIG9mZnNldCkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSAmJiAob2Zmc2V0ID09PSBub2RlLm9mZnNldCArIG5vZGUubGVuZ3RoKSAmJiBvZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBjaCA9IHRleHRbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAnb2JqZWN0JyAmJiBjaCA9PT0gJ30nIHx8IG5vZGUudHlwZSA9PT0gJ2FycmF5JyAmJiBjaCA9PT0gJ10nKSB7XG4gICAgICAgICAgICAgICAgLy8gYWZ0ZXIgXSBvciB9XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRXb3JkID0gdGhpcy5nZXRDdXJyZW50V29yZChkb2N1bWVudCwgb2Zmc2V0KTtcbiAgICAgICAgbGV0IG92ZXJ3cml0ZVJhbmdlO1xuICAgICAgICBpZiAobm9kZSAmJiAobm9kZS50eXBlID09PSAnc3RyaW5nJyB8fCBub2RlLnR5cGUgPT09ICdudW1iZXInIHx8IG5vZGUudHlwZSA9PT0gJ2Jvb2xlYW4nIHx8IG5vZGUudHlwZSA9PT0gJ251bGwnKSkge1xuICAgICAgICAgICAgb3ZlcndyaXRlUmFuZ2UgPSBSYW5nZS5jcmVhdGUoZG9jdW1lbnQucG9zaXRpb25BdChub2RlLm9mZnNldCksIGRvY3VtZW50LnBvc2l0aW9uQXQobm9kZS5vZmZzZXQgKyBub2RlLmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG92ZXJ3cml0ZVN0YXJ0ID0gb2Zmc2V0IC0gY3VycmVudFdvcmQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG92ZXJ3cml0ZVN0YXJ0ID4gMCAmJiB0ZXh0W292ZXJ3cml0ZVN0YXJ0IC0gMV0gPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICBvdmVyd3JpdGVTdGFydC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3ZlcndyaXRlUmFuZ2UgPSBSYW5nZS5jcmVhdGUoZG9jdW1lbnQucG9zaXRpb25BdChvdmVyd3JpdGVTdGFydCksIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdXBwb3J0c0NvbW1pdENoYXJhY3RlcnMgPSBmYWxzZTsgLy90aGlzLmRvZXNTdXBwb3J0c0NvbW1pdENoYXJhY3RlcnMoKTsgZGlzYWJsZWQgZm9yIG5vdywgd2FpdGluZyBmb3IgbmV3IEFQSTogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC92c2NvZGUvaXNzdWVzLzQyNTQ0XG4gICAgICAgIGNvbnN0IHByb3Bvc2VkID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBjb2xsZWN0b3IgPSB7XG4gICAgICAgICAgICBhZGQ6IChzdWdnZXN0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGxhYmVsID0gc3VnZ2VzdGlvbi5sYWJlbDtcbiAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IHByb3Bvc2VkLmdldChsYWJlbCk7XG4gICAgICAgICAgICAgICAgaWYgKCFleGlzdGluZykge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbCA9IGxhYmVsLnJlcGxhY2UoL1tcXG5dL2csICfihrUnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsLmxlbmd0aCA+IDYwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaG9ydGVuZGVkTGFiZWwgPSBsYWJlbC5zdWJzdHIoMCwgNTcpLnRyaW0oKSArICcuLi4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9wb3NlZC5oYXMoc2hvcnRlbmRlZExhYmVsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsID0gc2hvcnRlbmRlZExhYmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN1Z2dlc3Rpb24udGV4dEVkaXQgPSBUZXh0RWRpdC5yZXBsYWNlKG92ZXJ3cml0ZVJhbmdlLCBzdWdnZXN0aW9uLmluc2VydFRleHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydHNDb21taXRDaGFyYWN0ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWdnZXN0aW9uLmNvbW1pdENoYXJhY3RlcnMgPSBzdWdnZXN0aW9uLmtpbmQgPT09IG1haW5fQ29tcGxldGlvbkl0ZW1LaW5kLlByb3BlcnR5ID8gcHJvcGVydHlDb21taXRDaGFyYWN0ZXJzIDogdmFsdWVDb21taXRDaGFyYWN0ZXJzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN1Z2dlc3Rpb24ubGFiZWwgPSBsYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgcHJvcG9zZWQuc2V0KGxhYmVsLCBzdWdnZXN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lml0ZW1zLnB1c2goc3VnZ2VzdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV4aXN0aW5nLmRvY3VtZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmRvY3VtZW50YXRpb24gPSBzdWdnZXN0aW9uLmRvY3VtZW50YXRpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFleGlzdGluZy5kZXRhaWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmRldGFpbCA9IHN1Z2dlc3Rpb24uZGV0YWlsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXhpc3RpbmcubGFiZWxEZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sYWJlbERldGFpbHMgPSBzdWdnZXN0aW9uLmxhYmVsRGV0YWlscztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRBc0luY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXN1bHQuaXNJbmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcjogKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldE51bWJlck9mUHJvcG9zYWxzOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5pdGVtcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLnNjaGVtYVNlcnZpY2UuZ2V0U2NoZW1hRm9yUmVzb3VyY2UoZG9jdW1lbnQudXJpLCBkb2MpLnRoZW4oKHNjaGVtYSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29sbGVjdGlvblByb21pc2VzID0gW107XG4gICAgICAgICAgICBsZXQgYWRkVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRLZXkgPSAnJztcbiAgICAgICAgICAgIGxldCBjdXJyZW50UHJvcGVydHkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGUucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudC50eXBlID09PSAncHJvcGVydHknICYmIHBhcmVudC5rZXlOb2RlID09PSBub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRWYWx1ZSA9ICFwYXJlbnQudmFsdWVOb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb3BlcnR5ID0gcGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEtleSA9IHRleHQuc3Vic3RyKG5vZGUub2Zmc2V0ICsgMSwgbm9kZS5sZW5ndGggLSAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHByb3Bvc2FscyBmb3IgcHJvcGVydGllc1xuICAgICAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS50eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIC8vIGRvbid0IHN1Z2dlc3Qga2V5cyB3aGVuIHRoZSBjdXJzb3IgaXMganVzdCBiZWZvcmUgdGhlIG9wZW5pbmcgY3VybHkgYnJhY2VcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5vZmZzZXQgPT09IG9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBkb24ndCBzdWdnZXN0IHByb3BlcnRpZXMgdGhhdCBhcmUgYWxyZWFkeSBwcmVzZW50XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IG5vZGUucHJvcGVydGllcztcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLmZvckVhY2gocCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3VycmVudFByb3BlcnR5IHx8IGN1cnJlbnRQcm9wZXJ0eSAhPT0gcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcG9zZWQuc2V0KHAua2V5Tm9kZS52YWx1ZSwgQ29tcGxldGlvbkl0ZW0uY3JlYXRlKCdfXycpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGxldCBzZXBhcmF0b3JBZnRlciA9ICcnO1xuICAgICAgICAgICAgICAgIGlmIChhZGRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3JBZnRlciA9IHRoaXMuZXZhbHVhdGVTZXBhcmF0b3JBZnRlcihkb2N1bWVudCwgZG9jdW1lbnQub2Zmc2V0QXQob3ZlcndyaXRlUmFuZ2UuZW5kKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJvcGVydHkgcHJvcG9zYWxzIHdpdGggc2NoZW1hXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0UHJvcGVydHlDb21wbGV0aW9ucyhzY2hlbWEsIGRvYywgbm9kZSwgYWRkVmFsdWUsIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJvcGVydHkgcHJvcG9zYWxzIHdpdGhvdXQgc2NoZW1hXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0U2NoZW1hTGVzc1Byb3BlcnR5Q29tcGxldGlvbnMoZG9jLCBub2RlLCBjdXJyZW50S2V5LCBjb2xsZWN0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhdGlvbiA9IGpzb25QYXJzZXJfZ2V0Tm9kZVBhdGgobm9kZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250cmlidXRpb25zLmZvckVhY2goKGNvbnRyaWJ1dGlvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2xsZWN0UHJvbWlzZSA9IGNvbnRyaWJ1dGlvbi5jb2xsZWN0UHJvcGVydHlDb21wbGV0aW9ucyhkb2N1bWVudC51cmksIGxvY2F0aW9uLCBjdXJyZW50V29yZCwgYWRkVmFsdWUsIHNlcGFyYXRvckFmdGVyID09PSAnJywgY29sbGVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbGxlY3RQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uUHJvbWlzZXMucHVzaChjb2xsZWN0UHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoKCFzY2hlbWEgJiYgY3VycmVudFdvcmQubGVuZ3RoID4gMCAmJiB0ZXh0LmNoYXJBdChvZmZzZXQgLSBjdXJyZW50V29yZC5sZW5ndGggLSAxKSAhPT0gJ1wiJykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdG9yLmFkZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBtYWluX0NvbXBsZXRpb25JdGVtS2luZC5Qcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiB0aGlzLmdldExhYmVsRm9yVmFsdWUoY3VycmVudFdvcmQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VGV4dDogdGhpcy5nZXRJbnNlcnRUZXh0Rm9yUHJvcGVydHkoY3VycmVudFdvcmQsIHVuZGVmaW5lZCwgZmFsc2UsIHNlcGFyYXRvckFmdGVyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydFRleHRGb3JtYXQ6IG1haW5fSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0LCBkb2N1bWVudGF0aW9uOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rvci5zZXRBc0luY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBwcm9wb3NhbHMgZm9yIHZhbHVlc1xuICAgICAgICAgICAgY29uc3QgdHlwZXMgPSB7fTtcbiAgICAgICAgICAgIGlmIChzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZSBwcm9wb3NhbHMgd2l0aCBzY2hlbWFcbiAgICAgICAgICAgICAgICB0aGlzLmdldFZhbHVlQ29tcGxldGlvbnMoc2NoZW1hLCBkb2MsIG5vZGUsIG9mZnNldCwgZG9jdW1lbnQsIGNvbGxlY3RvciwgdHlwZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdmFsdWUgcHJvcG9zYWxzIHdpdGhvdXQgc2NoZW1hXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRTY2hlbWFMZXNzVmFsdWVDb21wbGV0aW9ucyhkb2MsIG5vZGUsIG9mZnNldCwgZG9jdW1lbnQsIGNvbGxlY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb250cmlidXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldENvbnRyaWJ1dGVkVmFsdWVDb21wbGV0aW9ucyhkb2MsIG5vZGUsIG9mZnNldCwgZG9jdW1lbnQsIGNvbGxlY3RvciwgY29sbGVjdGlvblByb21pc2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb21pc2VDb25zdHJ1Y3Rvci5hbGwoY29sbGVjdGlvblByb21pc2VzKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29sbGVjdG9yLmdldE51bWJlck9mUHJvcG9zYWxzKCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9mZnNldEZvclNlcGFyYXRvciA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgJiYgKG5vZGUudHlwZSA9PT0gJ3N0cmluZycgfHwgbm9kZS50eXBlID09PSAnbnVtYmVyJyB8fCBub2RlLnR5cGUgPT09ICdib29sZWFuJyB8fCBub2RlLnR5cGUgPT09ICdudWxsJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldEZvclNlcGFyYXRvciA9IG5vZGUub2Zmc2V0ICsgbm9kZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VwYXJhdG9yQWZ0ZXIgPSB0aGlzLmV2YWx1YXRlU2VwYXJhdG9yQWZ0ZXIoZG9jdW1lbnQsIG9mZnNldEZvclNlcGFyYXRvcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRmlsbGVyVmFsdWVDb21wbGV0aW9ucyh0eXBlcywgc2VwYXJhdG9yQWZ0ZXIsIGNvbGxlY3Rvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFByb3BlcnR5Q29tcGxldGlvbnMoc2NoZW1hLCBkb2MsIG5vZGUsIGFkZFZhbHVlLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoaW5nU2NoZW1hcyA9IGRvYy5nZXRNYXRjaGluZ1NjaGVtYXMoc2NoZW1hLnNjaGVtYSwgbm9kZS5vZmZzZXQpO1xuICAgICAgICBtYXRjaGluZ1NjaGVtYXMuZm9yRWFjaCgocykgPT4ge1xuICAgICAgICAgICAgaWYgKHMubm9kZSA9PT0gbm9kZSAmJiAhcy5pbnZlcnRlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVtYVByb3BlcnRpZXMgPSBzLnNjaGVtYS5wcm9wZXJ0aWVzO1xuICAgICAgICAgICAgICAgIGlmIChzY2hlbWFQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHNjaGVtYVByb3BlcnRpZXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcGVydHlTY2hlbWEgPSBzY2hlbWFQcm9wZXJ0aWVzW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3BlcnR5U2NoZW1hID09PSAnb2JqZWN0JyAmJiAhcHJvcGVydHlTY2hlbWEuZGVwcmVjYXRpb25NZXNzYWdlICYmICFwcm9wZXJ0eVNjaGVtYS5kb05vdFN1Z2dlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wb3NhbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogbWFpbl9Db21wbGV0aW9uSXRlbUtpbmQuUHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydFRleHQ6IHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclByb3BlcnR5KGtleSwgcHJvcGVydHlTY2hlbWEsIGFkZFZhbHVlLCBzZXBhcmF0b3JBZnRlciksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydFRleHRGb3JtYXQ6IG1haW5fSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJUZXh0OiB0aGlzLmdldEZpbHRlclRleHRGb3JWYWx1ZShrZXkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudGF0aW9uOiB0aGlzLmZyb21NYXJrdXAocHJvcGVydHlTY2hlbWEubWFya2Rvd25EZXNjcmlwdGlvbikgfHwgcHJvcGVydHlTY2hlbWEuZGVzY3JpcHRpb24gfHwgJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydHlTY2hlbWEuc3VnZ2VzdFNvcnRUZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcG9zYWwuc29ydFRleHQgPSBwcm9wZXJ0eVNjaGVtYS5zdWdnZXN0U29ydFRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wb3NhbC5pbnNlcnRUZXh0ICYmIGVuZHNXaXRoKHByb3Bvc2FsLmluc2VydFRleHQsIGAkMSR7c2VwYXJhdG9yQWZ0ZXJ9YCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcG9zYWwuY29tbWFuZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnU3VnZ2VzdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiAnZWRpdG9yLmFjdGlvbi50cmlnZ2VyU3VnZ2VzdCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdG9yLmFkZChwcm9wb3NhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzY2hlbWFQcm9wZXJ0eU5hbWVzID0gcy5zY2hlbWEucHJvcGVydHlOYW1lcztcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNjaGVtYVByb3BlcnR5TmFtZXMgPT09ICdvYmplY3QnICYmICFzY2hlbWFQcm9wZXJ0eU5hbWVzLmRlcHJlY2F0aW9uTWVzc2FnZSAmJiAhc2NoZW1hUHJvcGVydHlOYW1lcy5kb05vdFN1Z2dlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcGVydHlOYW1lQ29tcGxldGlvbkl0ZW0gPSAobmFtZSwgZW51bURlc2NyaXB0aW9uID0gdW5kZWZpbmVkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wb3NhbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBtYWluX0NvbXBsZXRpb25JdGVtS2luZC5Qcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRUZXh0OiB0aGlzLmdldEluc2VydFRleHRGb3JQcm9wZXJ0eShuYW1lLCB1bmRlZmluZWQsIGFkZFZhbHVlLCBzZXBhcmF0b3JBZnRlciksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VGV4dEZvcm1hdDogbWFpbl9JbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyVGV4dDogdGhpcy5nZXRGaWx0ZXJUZXh0Rm9yVmFsdWUobmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRhdGlvbjogZW51bURlc2NyaXB0aW9uIHx8IHRoaXMuZnJvbU1hcmt1cChzY2hlbWFQcm9wZXJ0eU5hbWVzLm1hcmtkb3duRGVzY3JpcHRpb24pIHx8IHNjaGVtYVByb3BlcnR5TmFtZXMuZGVzY3JpcHRpb24gfHwgJycsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtYVByb3BlcnR5TmFtZXMuc3VnZ2VzdFNvcnRUZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wb3NhbC5zb3J0VGV4dCA9IHNjaGVtYVByb3BlcnR5TmFtZXMuc3VnZ2VzdFNvcnRUZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3Bvc2FsLmluc2VydFRleHQgJiYgZW5kc1dpdGgocHJvcG9zYWwuaW5zZXJ0VGV4dCwgYCQxJHtzZXBhcmF0b3JBZnRlcn1gKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3Bvc2FsLmNvbW1hbmQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnU3VnZ2VzdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdlZGl0b3IuYWN0aW9uLnRyaWdnZXJTdWdnZXN0J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0b3IuYWRkKHByb3Bvc2FsKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtYVByb3BlcnR5TmFtZXMuZW51bSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2hlbWFQcm9wZXJ0eU5hbWVzLmVudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZW51bURlc2NyaXB0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWFQcm9wZXJ0eU5hbWVzLm1hcmtkb3duRW51bURlc2NyaXB0aW9ucyAmJiBpIDwgc2NoZW1hUHJvcGVydHlOYW1lcy5tYXJrZG93bkVudW1EZXNjcmlwdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudW1EZXNjcmlwdGlvbiA9IHRoaXMuZnJvbU1hcmt1cChzY2hlbWFQcm9wZXJ0eU5hbWVzLm1hcmtkb3duRW51bURlc2NyaXB0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjaGVtYVByb3BlcnR5TmFtZXMuZW51bURlc2NyaXB0aW9ucyAmJiBpIDwgc2NoZW1hUHJvcGVydHlOYW1lcy5lbnVtRGVzY3JpcHRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnVtRGVzY3JpcHRpb24gPSBzY2hlbWFQcm9wZXJ0eU5hbWVzLmVudW1EZXNjcmlwdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5TmFtZUNvbXBsZXRpb25JdGVtKHNjaGVtYVByb3BlcnR5TmFtZXMuZW51bVtpXSwgZW51bURlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1hUHJvcGVydHlOYW1lcy5jb25zdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lQ29tcGxldGlvbkl0ZW0oc2NoZW1hUHJvcGVydHlOYW1lcy5jb25zdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRTY2hlbWFMZXNzUHJvcGVydHlDb21wbGV0aW9ucyhkb2MsIG5vZGUsIGN1cnJlbnRLZXksIGNvbGxlY3Rvcikge1xuICAgICAgICBjb25zdCBjb2xsZWN0Q29tcGxldGlvbnNGb3JTaW1pbGFyT2JqZWN0ID0gKG9iaikgPT4ge1xuICAgICAgICAgICAgb2JqLnByb3BlcnRpZXMuZm9yRWFjaCgocCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IHAua2V5Tm9kZS52YWx1ZTtcbiAgICAgICAgICAgICAgICBjb2xsZWN0b3IuYWRkKHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogbWFpbl9Db21wbGV0aW9uSXRlbUtpbmQuUHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBrZXksXG4gICAgICAgICAgICAgICAgICAgIGluc2VydFRleHQ6IHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclZhbHVlKGtleSwgJycpLFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBtYWluX0luc2VydFRleHRGb3JtYXQuU25pcHBldCxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyVGV4dDogdGhpcy5nZXRGaWx0ZXJUZXh0Rm9yVmFsdWUoa2V5KSxcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRhdGlvbjogJydcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAobm9kZS5wYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChub2RlLnBhcmVudC50eXBlID09PSAncHJvcGVydHknKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIG9iamVjdCBpcyBhIHByb3BlcnR5IHZhbHVlLCBjaGVjayB0aGUgdHJlZSBmb3Igb3RoZXIgb2JqZWN0cyB0aGF0IGhhbmcgdW5kZXIgYSBwcm9wZXJ0eSBvZiB0aGUgc2FtZSBuYW1lXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50S2V5ID0gbm9kZS5wYXJlbnQua2V5Tm9kZS52YWx1ZTtcbiAgICAgICAgICAgICAgICBkb2MudmlzaXQobiA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuLnR5cGUgPT09ICdwcm9wZXJ0eScgJiYgbiAhPT0gbm9kZS5wYXJlbnQgJiYgbi5rZXlOb2RlLnZhbHVlID09PSBwYXJlbnRLZXkgJiYgbi52YWx1ZU5vZGUgJiYgbi52YWx1ZU5vZGUudHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3RDb21wbGV0aW9uc0ZvclNpbWlsYXJPYmplY3Qobi52YWx1ZU5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5wYXJlbnQudHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBvYmplY3QgaXMgaW4gYW4gYXJyYXksIHVzZSBhbGwgb3RoZXIgYXJyYXkgZWxlbWVudHMgYXMgc2ltaWxhciBvYmplY3RzXG4gICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQuaXRlbXMuZm9yRWFjaChuID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4udHlwZSA9PT0gJ29iamVjdCcgJiYgbiAhPT0gbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdENvbXBsZXRpb25zRm9yU2ltaWxhck9iamVjdChuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbGxlY3Rvci5hZGQoe1xuICAgICAgICAgICAgICAgIGtpbmQ6IG1haW5fQ29tcGxldGlvbkl0ZW1LaW5kLlByb3BlcnR5LFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnJHNjaGVtYScsXG4gICAgICAgICAgICAgICAgaW5zZXJ0VGV4dDogdGhpcy5nZXRJbnNlcnRUZXh0Rm9yUHJvcGVydHkoJyRzY2hlbWEnLCB1bmRlZmluZWQsIHRydWUsICcnKSxcbiAgICAgICAgICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBtYWluX0luc2VydFRleHRGb3JtYXQuU25pcHBldCwgZG9jdW1lbnRhdGlvbjogJycsXG4gICAgICAgICAgICAgICAgZmlsdGVyVGV4dDogdGhpcy5nZXRGaWx0ZXJUZXh0Rm9yVmFsdWUoXCIkc2NoZW1hXCIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRTY2hlbWFMZXNzVmFsdWVDb21wbGV0aW9ucyhkb2MsIG5vZGUsIG9mZnNldCwgZG9jdW1lbnQsIGNvbGxlY3Rvcikge1xuICAgICAgICBsZXQgb2Zmc2V0Rm9yU2VwYXJhdG9yID0gb2Zmc2V0O1xuICAgICAgICBpZiAobm9kZSAmJiAobm9kZS50eXBlID09PSAnc3RyaW5nJyB8fCBub2RlLnR5cGUgPT09ICdudW1iZXInIHx8IG5vZGUudHlwZSA9PT0gJ2Jvb2xlYW4nIHx8IG5vZGUudHlwZSA9PT0gJ251bGwnKSkge1xuICAgICAgICAgICAgb2Zmc2V0Rm9yU2VwYXJhdG9yID0gbm9kZS5vZmZzZXQgKyBub2RlLmxlbmd0aDtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIGNvbGxlY3Rvci5hZGQoe1xuICAgICAgICAgICAgICAgIGtpbmQ6IHRoaXMuZ2V0U3VnZ2VzdGlvbktpbmQoJ29iamVjdCcpLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAnRW1wdHkgb2JqZWN0JyxcbiAgICAgICAgICAgICAgICBpbnNlcnRUZXh0OiB0aGlzLmdldEluc2VydFRleHRGb3JWYWx1ZSh7fSwgJycpLFxuICAgICAgICAgICAgICAgIGluc2VydFRleHRGb3JtYXQ6IG1haW5fSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0LFxuICAgICAgICAgICAgICAgIGRvY3VtZW50YXRpb246ICcnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbGxlY3Rvci5hZGQoe1xuICAgICAgICAgICAgICAgIGtpbmQ6IHRoaXMuZ2V0U3VnZ2VzdGlvbktpbmQoJ2FycmF5JyksXG4gICAgICAgICAgICAgICAgbGFiZWw6ICdFbXB0eSBhcnJheScsXG4gICAgICAgICAgICAgICAgaW5zZXJ0VGV4dDogdGhpcy5nZXRJbnNlcnRUZXh0Rm9yVmFsdWUoW10sICcnKSxcbiAgICAgICAgICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBtYWluX0luc2VydFRleHRGb3JtYXQuU25pcHBldCxcbiAgICAgICAgICAgICAgICBkb2N1bWVudGF0aW9uOiAnJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VwYXJhdG9yQWZ0ZXIgPSB0aGlzLmV2YWx1YXRlU2VwYXJhdG9yQWZ0ZXIoZG9jdW1lbnQsIG9mZnNldEZvclNlcGFyYXRvcik7XG4gICAgICAgIGNvbnN0IGNvbGxlY3RTdWdnZXN0aW9uc0ZvclZhbHVlcyA9ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlLnBhcmVudCAmJiAhanNvblBhcnNlcl9jb250YWlucyh2YWx1ZS5wYXJlbnQsIG9mZnNldCwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICBjb2xsZWN0b3IuYWRkKHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogdGhpcy5nZXRTdWdnZXN0aW9uS2luZCh2YWx1ZS50eXBlKSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHRoaXMuZ2V0TGFiZWxUZXh0Rm9yTWF0Y2hpbmdOb2RlKHZhbHVlLCBkb2N1bWVudCksXG4gICAgICAgICAgICAgICAgICAgIGluc2VydFRleHQ6IHRoaXMuZ2V0SW5zZXJ0VGV4dEZvck1hdGNoaW5nTm9kZSh2YWx1ZSwgZG9jdW1lbnQsIHNlcGFyYXRvckFmdGVyKSxcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VGV4dEZvcm1hdDogbWFpbl9JbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXQsIGRvY3VtZW50YXRpb246ICcnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUudHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRCb29sZWFuVmFsdWVDb21wbGV0aW9uKCF2YWx1ZS52YWx1ZSwgc2VwYXJhdG9yQWZ0ZXIsIGNvbGxlY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdwcm9wZXJ0eScpIHtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPiAobm9kZS5jb2xvbk9mZnNldCB8fCAwKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlTm9kZSA9IG5vZGUudmFsdWVOb2RlO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZU5vZGUgJiYgKG9mZnNldCA+ICh2YWx1ZU5vZGUub2Zmc2V0ICsgdmFsdWVOb2RlLmxlbmd0aCkgfHwgdmFsdWVOb2RlLnR5cGUgPT09ICdvYmplY3QnIHx8IHZhbHVlTm9kZS50eXBlID09PSAnYXJyYXknKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHN1Z2dlc3QgdmFsdWVzIGF0IHRoZSBzYW1lIGtleVxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudEtleSA9IG5vZGUua2V5Tm9kZS52YWx1ZTtcbiAgICAgICAgICAgICAgICBkb2MudmlzaXQobiA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuLnR5cGUgPT09ICdwcm9wZXJ0eScgJiYgbi5rZXlOb2RlLnZhbHVlID09PSBwYXJlbnRLZXkgJiYgbi52YWx1ZU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3RTdWdnZXN0aW9uc0ZvclZhbHVlcyhuLnZhbHVlTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudEtleSA9PT0gJyRzY2hlbWEnICYmIG5vZGUucGFyZW50ICYmICFub2RlLnBhcmVudC5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGREb2xsYXJTY2hlbWFDb21wbGV0aW9ucyhzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50ICYmIG5vZGUucGFyZW50LnR5cGUgPT09ICdwcm9wZXJ0eScpIHtcbiAgICAgICAgICAgICAgICAvLyBzdWdnZXN0IGl0ZW1zIG9mIGFuIGFycmF5IGF0IHRoZSBzYW1lIGtleVxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudEtleSA9IG5vZGUucGFyZW50LmtleU5vZGUudmFsdWU7XG4gICAgICAgICAgICAgICAgZG9jLnZpc2l0KChuKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuLnR5cGUgPT09ICdwcm9wZXJ0eScgJiYgbi5rZXlOb2RlLnZhbHVlID09PSBwYXJlbnRLZXkgJiYgbi52YWx1ZU5vZGUgJiYgbi52YWx1ZU5vZGUudHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbi52YWx1ZU5vZGUuaXRlbXMuZm9yRWFjaChjb2xsZWN0U3VnZ2VzdGlvbnNGb3JWYWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gc3VnZ2VzdCBpdGVtcyBpbiB0aGUgc2FtZSBhcnJheVxuICAgICAgICAgICAgICAgIG5vZGUuaXRlbXMuZm9yRWFjaChjb2xsZWN0U3VnZ2VzdGlvbnNGb3JWYWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldFZhbHVlQ29tcGxldGlvbnMoc2NoZW1hLCBkb2MsIG5vZGUsIG9mZnNldCwgZG9jdW1lbnQsIGNvbGxlY3RvciwgdHlwZXMpIHtcbiAgICAgICAgbGV0IG9mZnNldEZvclNlcGFyYXRvciA9IG9mZnNldDtcbiAgICAgICAgbGV0IHBhcmVudEtleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHZhbHVlTm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG5vZGUgJiYgKG5vZGUudHlwZSA9PT0gJ3N0cmluZycgfHwgbm9kZS50eXBlID09PSAnbnVtYmVyJyB8fCBub2RlLnR5cGUgPT09ICdib29sZWFuJyB8fCBub2RlLnR5cGUgPT09ICdudWxsJykpIHtcbiAgICAgICAgICAgIG9mZnNldEZvclNlcGFyYXRvciA9IG5vZGUub2Zmc2V0ICsgbm9kZS5sZW5ndGg7XG4gICAgICAgICAgICB2YWx1ZU5vZGUgPSBub2RlO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgdGhpcy5hZGRTY2hlbWFWYWx1ZUNvbXBsZXRpb25zKHNjaGVtYS5zY2hlbWEsICcnLCBjb2xsZWN0b3IsIHR5cGVzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKG5vZGUudHlwZSA9PT0gJ3Byb3BlcnR5JykgJiYgb2Zmc2V0ID4gKG5vZGUuY29sb25PZmZzZXQgfHwgMCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlTm9kZSA9IG5vZGUudmFsdWVOb2RlO1xuICAgICAgICAgICAgaWYgKHZhbHVlTm9kZSAmJiBvZmZzZXQgPiAodmFsdWVOb2RlLm9mZnNldCArIHZhbHVlTm9kZS5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyB3ZSBhcmUgcGFzdCB0aGUgdmFsdWUgbm9kZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50S2V5ID0gbm9kZS5rZXlOb2RlLnZhbHVlO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlICYmIChwYXJlbnRLZXkgIT09IHVuZGVmaW5lZCB8fCBub2RlLnR5cGUgPT09ICdhcnJheScpKSB7XG4gICAgICAgICAgICBjb25zdCBzZXBhcmF0b3JBZnRlciA9IHRoaXMuZXZhbHVhdGVTZXBhcmF0b3JBZnRlcihkb2N1bWVudCwgb2Zmc2V0Rm9yU2VwYXJhdG9yKTtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nU2NoZW1hcyA9IGRvYy5nZXRNYXRjaGluZ1NjaGVtYXMoc2NoZW1hLnNjaGVtYSwgbm9kZS5vZmZzZXQsIHZhbHVlTm9kZSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHMgb2YgbWF0Y2hpbmdTY2hlbWFzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHMubm9kZSA9PT0gbm9kZSAmJiAhcy5pbnZlcnRlZCAmJiBzLnNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAnYXJyYXknICYmIHMuc2NoZW1hLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYyA9IGNvbGxlY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzLnNjaGVtYS51bmlxdWVJdGVtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nVmFsdWVzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChuID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4udHlwZSAhPT0gJ2FycmF5JyAmJiBuLnR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1ZhbHVlcy5hZGQodGhpcy5nZXRMYWJlbEZvclZhbHVlKGpzb25QYXJzZXJfZ2V0Tm9kZVZhbHVlKG4pKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5jb2xsZWN0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZChzdWdnZXN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWV4aXN0aW5nVmFsdWVzLmhhcyhzdWdnZXN0aW9uLmxhYmVsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rvci5hZGQoc3VnZ2VzdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocy5zY2hlbWEuaXRlbXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmZpbmRJdGVtQXRPZmZzZXQobm9kZSwgZG9jdW1lbnQsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgcy5zY2hlbWEuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkU2NoZW1hVmFsdWVDb21wbGV0aW9ucyhzLnNjaGVtYS5pdGVtc1tpbmRleF0sIHNlcGFyYXRvckFmdGVyLCBjLCB0eXBlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRTY2hlbWFWYWx1ZUNvbXBsZXRpb25zKHMuc2NoZW1hLml0ZW1zLCBzZXBhcmF0b3JBZnRlciwgYywgdHlwZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHByb3BlcnR5TWF0Y2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMuc2NoZW1hLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eVNjaGVtYSA9IHMuc2NoZW1hLnByb3BlcnRpZXNbcGFyZW50S2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydHlTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlNYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRTY2hlbWFWYWx1ZUNvbXBsZXRpb25zKHByb3BlcnR5U2NoZW1hLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yLCB0eXBlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMuc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzICYmICFwcm9wZXJ0eU1hdGNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgT2JqZWN0LmtleXMocy5zY2hlbWEucGF0dGVyblByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gZXh0ZW5kZWRSZWdFeHAocGF0dGVybik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWdleD8udGVzdChwYXJlbnRLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eU1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcGVydHlTY2hlbWEgPSBzLnNjaGVtYS5wYXR0ZXJuUHJvcGVydGllc1twYXR0ZXJuXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkU2NoZW1hVmFsdWVDb21wbGV0aW9ucyhwcm9wZXJ0eVNjaGVtYSwgc2VwYXJhdG9yQWZ0ZXIsIGNvbGxlY3RvciwgdHlwZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMuc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzICYmICFwcm9wZXJ0eU1hdGNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eVNjaGVtYSA9IHMuc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkU2NoZW1hVmFsdWVDb21wbGV0aW9ucyhwcm9wZXJ0eVNjaGVtYSwgc2VwYXJhdG9yQWZ0ZXIsIGNvbGxlY3RvciwgdHlwZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmVudEtleSA9PT0gJyRzY2hlbWEnICYmICFub2RlLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkRG9sbGFyU2NoZW1hQ29tcGxldGlvbnMoc2VwYXJhdG9yQWZ0ZXIsIGNvbGxlY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZXNbJ2Jvb2xlYW4nXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQm9vbGVhblZhbHVlQ29tcGxldGlvbih0cnVlLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEJvb2xlYW5WYWx1ZUNvbXBsZXRpb24oZmFsc2UsIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVzWydudWxsJ10pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZE51bGxWYWx1ZUNvbXBsZXRpb24oc2VwYXJhdG9yQWZ0ZXIsIGNvbGxlY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0Q29udHJpYnV0ZWRWYWx1ZUNvbXBsZXRpb25zKGRvYywgbm9kZSwgb2Zmc2V0LCBkb2N1bWVudCwgY29sbGVjdG9yLCBjb2xsZWN0aW9uUHJvbWlzZXMpIHtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRyaWJ1dGlvbnMuZm9yRWFjaCgoY29udHJpYnV0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sbGVjdFByb21pc2UgPSBjb250cmlidXRpb24uY29sbGVjdERlZmF1bHRDb21wbGV0aW9ucyhkb2N1bWVudC51cmksIGNvbGxlY3Rvcik7XG4gICAgICAgICAgICAgICAgaWYgKGNvbGxlY3RQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25Qcm9taXNlcy5wdXNoKGNvbGxlY3RQcm9taXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdzdHJpbmcnIHx8IG5vZGUudHlwZSA9PT0gJ251bWJlcicgfHwgbm9kZS50eXBlID09PSAnYm9vbGVhbicgfHwgbm9kZS50eXBlID09PSAnbnVsbCcpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZSAmJiAobm9kZS50eXBlID09PSAncHJvcGVydHknKSAmJiBvZmZzZXQgPiAobm9kZS5jb2xvbk9mZnNldCB8fCAwKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudEtleSA9IG5vZGUua2V5Tm9kZS52YWx1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZU5vZGUgPSBub2RlLnZhbHVlTm9kZTtcbiAgICAgICAgICAgICAgICBpZiAoKCF2YWx1ZU5vZGUgfHwgb2Zmc2V0IDw9ICh2YWx1ZU5vZGUub2Zmc2V0ICsgdmFsdWVOb2RlLmxlbmd0aCkpICYmIG5vZGUucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0ganNvblBhcnNlcl9nZXROb2RlUGF0aChub2RlLnBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udHJpYnV0aW9ucy5mb3JFYWNoKChjb250cmlidXRpb24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbGxlY3RQcm9taXNlID0gY29udHJpYnV0aW9uLmNvbGxlY3RWYWx1ZUNvbXBsZXRpb25zKGRvY3VtZW50LnVyaSwgbG9jYXRpb24sIHBhcmVudEtleSwgY29sbGVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2xsZWN0UHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25Qcm9taXNlcy5wdXNoKGNvbGxlY3RQcm9taXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFkZFNjaGVtYVZhbHVlQ29tcGxldGlvbnMoc2NoZW1hLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yLCB0eXBlcykge1xuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRW51bVZhbHVlQ29tcGxldGlvbnMoc2NoZW1hLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yKTtcbiAgICAgICAgICAgIHRoaXMuYWRkRGVmYXVsdFZhbHVlQ29tcGxldGlvbnMoc2NoZW1hLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yKTtcbiAgICAgICAgICAgIHRoaXMuY29sbGVjdFR5cGVzKHNjaGVtYSwgdHlwZXMpO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLmFsbE9mKSkge1xuICAgICAgICAgICAgICAgIHNjaGVtYS5hbGxPZi5mb3JFYWNoKHMgPT4gdGhpcy5hZGRTY2hlbWFWYWx1ZUNvbXBsZXRpb25zKHMsIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IsIHR5cGVzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEuYW55T2YpKSB7XG4gICAgICAgICAgICAgICAgc2NoZW1hLmFueU9mLmZvckVhY2gocyA9PiB0aGlzLmFkZFNjaGVtYVZhbHVlQ29tcGxldGlvbnMocywgc2VwYXJhdG9yQWZ0ZXIsIGNvbGxlY3RvciwgdHlwZXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5vbmVPZikpIHtcbiAgICAgICAgICAgICAgICBzY2hlbWEub25lT2YuZm9yRWFjaChzID0+IHRoaXMuYWRkU2NoZW1hVmFsdWVDb21wbGV0aW9ucyhzLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yLCB0eXBlcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFkZERlZmF1bHRWYWx1ZUNvbXBsZXRpb25zKHNjaGVtYSwgc2VwYXJhdG9yQWZ0ZXIsIGNvbGxlY3RvciwgYXJyYXlEZXB0aCA9IDApIHtcbiAgICAgICAgbGV0IGhhc1Byb3Bvc2FscyA9IGZhbHNlO1xuICAgICAgICBpZiAoaXNEZWZpbmVkKHNjaGVtYS5kZWZhdWx0KSkge1xuICAgICAgICAgICAgbGV0IHR5cGUgPSBzY2hlbWEudHlwZTtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHNjaGVtYS5kZWZhdWx0O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGFycmF5RGVwdGg7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZV07XG4gICAgICAgICAgICAgICAgdHlwZSA9ICdhcnJheSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb21wbGV0aW9uSXRlbSA9IHtcbiAgICAgICAgICAgICAgICBraW5kOiB0aGlzLmdldFN1Z2dlc3Rpb25LaW5kKHR5cGUpLFxuICAgICAgICAgICAgICAgIGxhYmVsOiB0aGlzLmdldExhYmVsRm9yVmFsdWUodmFsdWUpLFxuICAgICAgICAgICAgICAgIGluc2VydFRleHQ6IHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclZhbHVlKHZhbHVlLCBzZXBhcmF0b3JBZnRlciksXG4gICAgICAgICAgICAgICAgaW5zZXJ0VGV4dEZvcm1hdDogbWFpbl9JbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5kb2VzU3VwcG9ydHNMYWJlbERldGFpbHMoKSkge1xuICAgICAgICAgICAgICAgIGNvbXBsZXRpb25JdGVtLmxhYmVsRGV0YWlscyA9IHsgZGVzY3JpcHRpb246IHQoJ0RlZmF1bHQgdmFsdWUnKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tcGxldGlvbkl0ZW0uZGV0YWlsID0gdCgnRGVmYXVsdCB2YWx1ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29sbGVjdG9yLmFkZChjb21wbGV0aW9uSXRlbSk7XG4gICAgICAgICAgICBoYXNQcm9wb3NhbHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5leGFtcGxlcykpIHtcbiAgICAgICAgICAgIHNjaGVtYS5leGFtcGxlcy5mb3JFYWNoKGV4YW1wbGUgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB0eXBlID0gc2NoZW1hLnR5cGU7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gZXhhbXBsZTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gYXJyYXlEZXB0aDsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZV07XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSAnYXJyYXknO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2xsZWN0b3IuYWRkKHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogdGhpcy5nZXRTdWdnZXN0aW9uS2luZCh0eXBlKSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHRoaXMuZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSksXG4gICAgICAgICAgICAgICAgICAgIGluc2VydFRleHQ6IHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclZhbHVlKHZhbHVlLCBzZXBhcmF0b3JBZnRlciksXG4gICAgICAgICAgICAgICAgICAgIGluc2VydFRleHRGb3JtYXQ6IG1haW5fSW5zZXJ0VGV4dEZvcm1hdC5TbmlwcGV0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaGFzUHJvcG9zYWxzID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5kZWZhdWx0U25pcHBldHMpKSB7XG4gICAgICAgICAgICBzY2hlbWEuZGVmYXVsdFNuaXBwZXRzLmZvckVhY2gocyA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHR5cGUgPSBzY2hlbWEudHlwZTtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBzLmJvZHk7XG4gICAgICAgICAgICAgICAgbGV0IGxhYmVsID0gcy5sYWJlbDtcbiAgICAgICAgICAgICAgICBsZXQgaW5zZXJ0VGV4dDtcbiAgICAgICAgICAgICAgICBsZXQgZmlsdGVyVGV4dDtcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdHlwZSA9IHNjaGVtYS50eXBlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gYXJyYXlEZXB0aDsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBbdmFsdWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9ICdhcnJheSc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VGV4dCA9IHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclNuaXBwZXRWYWx1ZSh2YWx1ZSwgc2VwYXJhdG9yQWZ0ZXIpO1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJUZXh0ID0gdGhpcy5nZXRGaWx0ZXJUZXh0Rm9yU25pcHBldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwgPSBsYWJlbCB8fCB0aGlzLmdldExhYmVsRm9yU25pcHBldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHMuYm9keVRleHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwcmVmaXggPSAnJywgc3VmZml4ID0gJycsIGluZGVudCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gYXJyYXlEZXB0aDsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4ID0gcHJlZml4ICsgaW5kZW50ICsgJ1tcXG4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VmZml4ID0gc3VmZml4ICsgJ1xcbicgKyBpbmRlbnQgKyAnXSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRlbnQgKz0gJ1xcdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gJ2FycmF5JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRUZXh0ID0gcHJlZml4ICsgaW5kZW50ICsgcy5ib2R5VGV4dC5zcGxpdCgnXFxuJykuam9pbignXFxuJyArIGluZGVudCkgKyBzdWZmaXggKyBzZXBhcmF0b3JBZnRlcjtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwgPSBsYWJlbCB8fCBpbnNlcnRUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyVGV4dCA9IGluc2VydFRleHQucmVwbGFjZSgvW1xcbl0vZywgJycpOyAvLyByZW1vdmUgbmV3IGxpbmVzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbGxlY3Rvci5hZGQoe1xuICAgICAgICAgICAgICAgICAgICBraW5kOiB0aGlzLmdldFN1Z2dlc3Rpb25LaW5kKHR5cGUpLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRhdGlvbjogdGhpcy5mcm9tTWFya3VwKHMubWFya2Rvd25EZXNjcmlwdGlvbikgfHwgcy5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VGV4dCxcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0VGV4dEZvcm1hdDogbWFpbl9JbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXQsXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlclRleHRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBoYXNQcm9wb3NhbHMgPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYXNQcm9wb3NhbHMgJiYgdHlwZW9mIHNjaGVtYS5pdGVtcyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoc2NoZW1hLml0ZW1zKSAmJiBhcnJheURlcHRoIDwgNSAvKiBiZXdhcmUgb2YgcmVjdXJzaW9uICovKSB7XG4gICAgICAgICAgICB0aGlzLmFkZERlZmF1bHRWYWx1ZUNvbXBsZXRpb25zKHNjaGVtYS5pdGVtcywgc2VwYXJhdG9yQWZ0ZXIsIGNvbGxlY3RvciwgYXJyYXlEZXB0aCArIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEVudW1WYWx1ZUNvbXBsZXRpb25zKHNjaGVtYSwgc2VwYXJhdG9yQWZ0ZXIsIGNvbGxlY3Rvcikge1xuICAgICAgICBpZiAoaXNEZWZpbmVkKHNjaGVtYS5jb25zdCkpIHtcbiAgICAgICAgICAgIGNvbGxlY3Rvci5hZGQoe1xuICAgICAgICAgICAgICAgIGtpbmQ6IHRoaXMuZ2V0U3VnZ2VzdGlvbktpbmQoc2NoZW1hLnR5cGUpLFxuICAgICAgICAgICAgICAgIGxhYmVsOiB0aGlzLmdldExhYmVsRm9yVmFsdWUoc2NoZW1hLmNvbnN0KSxcbiAgICAgICAgICAgICAgICBpbnNlcnRUZXh0OiB0aGlzLmdldEluc2VydFRleHRGb3JWYWx1ZShzY2hlbWEuY29uc3QsIHNlcGFyYXRvckFmdGVyKSxcbiAgICAgICAgICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBtYWluX0luc2VydFRleHRGb3JtYXQuU25pcHBldCxcbiAgICAgICAgICAgICAgICBkb2N1bWVudGF0aW9uOiB0aGlzLmZyb21NYXJrdXAoc2NoZW1hLm1hcmtkb3duRGVzY3JpcHRpb24pIHx8IHNjaGVtYS5kZXNjcmlwdGlvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLmVudW0pKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gc2NoZW1hLmVudW0ubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbm0gPSBzY2hlbWEuZW51bVtpXTtcbiAgICAgICAgICAgICAgICBsZXQgZG9jdW1lbnRhdGlvbiA9IHRoaXMuZnJvbU1hcmt1cChzY2hlbWEubWFya2Rvd25EZXNjcmlwdGlvbikgfHwgc2NoZW1hLmRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgICAgIGlmIChzY2hlbWEubWFya2Rvd25FbnVtRGVzY3JpcHRpb25zICYmIGkgPCBzY2hlbWEubWFya2Rvd25FbnVtRGVzY3JpcHRpb25zLmxlbmd0aCAmJiB0aGlzLmRvZXNTdXBwb3J0TWFya2Rvd24oKSkge1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudGF0aW9uID0gdGhpcy5mcm9tTWFya3VwKHNjaGVtYS5tYXJrZG93bkVudW1EZXNjcmlwdGlvbnNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzY2hlbWEuZW51bURlc2NyaXB0aW9ucyAmJiBpIDwgc2NoZW1hLmVudW1EZXNjcmlwdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50YXRpb24gPSBzY2hlbWEuZW51bURlc2NyaXB0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29sbGVjdG9yLmFkZCh7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IHRoaXMuZ2V0U3VnZ2VzdGlvbktpbmQoc2NoZW1hLnR5cGUpLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogdGhpcy5nZXRMYWJlbEZvclZhbHVlKGVubSksXG4gICAgICAgICAgICAgICAgICAgIGluc2VydFRleHQ6IHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclZhbHVlKGVubSwgc2VwYXJhdG9yQWZ0ZXIpLFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBtYWluX0luc2VydFRleHRGb3JtYXQuU25pcHBldCxcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRhdGlvblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbGxlY3RUeXBlcyhzY2hlbWEsIHR5cGVzKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYS5lbnVtKSB8fCBpc0RlZmluZWQoc2NoZW1hLmNvbnN0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR5cGUgPSBzY2hlbWEudHlwZTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgICAgIHR5cGUuZm9yRWFjaCh0ID0+IHR5cGVzW3RdID0gdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSkge1xuICAgICAgICAgICAgdHlwZXNbdHlwZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEZpbGxlclZhbHVlQ29tcGxldGlvbnModHlwZXMsIHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IpIHtcbiAgICAgICAgaWYgKHR5cGVzWydvYmplY3QnXSkge1xuICAgICAgICAgICAgY29sbGVjdG9yLmFkZCh7XG4gICAgICAgICAgICAgICAga2luZDogdGhpcy5nZXRTdWdnZXN0aW9uS2luZCgnb2JqZWN0JyksXG4gICAgICAgICAgICAgICAgbGFiZWw6ICd7fScsXG4gICAgICAgICAgICAgICAgaW5zZXJ0VGV4dDogdGhpcy5nZXRJbnNlcnRUZXh0Rm9yR3Vlc3NlZFZhbHVlKHt9LCBzZXBhcmF0b3JBZnRlciksXG4gICAgICAgICAgICAgICAgaW5zZXJ0VGV4dEZvcm1hdDogbWFpbl9JbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXQsXG4gICAgICAgICAgICAgICAgZGV0YWlsOiB0KCdOZXcgb2JqZWN0JyksXG4gICAgICAgICAgICAgICAgZG9jdW1lbnRhdGlvbjogJydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlc1snYXJyYXknXSkge1xuICAgICAgICAgICAgY29sbGVjdG9yLmFkZCh7XG4gICAgICAgICAgICAgICAga2luZDogdGhpcy5nZXRTdWdnZXN0aW9uS2luZCgnYXJyYXknKSxcbiAgICAgICAgICAgICAgICBsYWJlbDogJ1tdJyxcbiAgICAgICAgICAgICAgICBpbnNlcnRUZXh0OiB0aGlzLmdldEluc2VydFRleHRGb3JHdWVzc2VkVmFsdWUoW10sIHNlcGFyYXRvckFmdGVyKSxcbiAgICAgICAgICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBtYWluX0luc2VydFRleHRGb3JtYXQuU25pcHBldCxcbiAgICAgICAgICAgICAgICBkZXRhaWw6IHQoJ05ldyBhcnJheScpLFxuICAgICAgICAgICAgICAgIGRvY3VtZW50YXRpb246ICcnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRCb29sZWFuVmFsdWVDb21wbGV0aW9uKHZhbHVlLCBzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yKSB7XG4gICAgICAgIGNvbGxlY3Rvci5hZGQoe1xuICAgICAgICAgICAga2luZDogdGhpcy5nZXRTdWdnZXN0aW9uS2luZCgnYm9vbGVhbicpLFxuICAgICAgICAgICAgbGFiZWw6IHZhbHVlID8gJ3RydWUnIDogJ2ZhbHNlJyxcbiAgICAgICAgICAgIGluc2VydFRleHQ6IHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclZhbHVlKHZhbHVlLCBzZXBhcmF0b3JBZnRlciksXG4gICAgICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBtYWluX0luc2VydFRleHRGb3JtYXQuU25pcHBldCxcbiAgICAgICAgICAgIGRvY3VtZW50YXRpb246ICcnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhZGROdWxsVmFsdWVDb21wbGV0aW9uKHNlcGFyYXRvckFmdGVyLCBjb2xsZWN0b3IpIHtcbiAgICAgICAgY29sbGVjdG9yLmFkZCh7XG4gICAgICAgICAgICBraW5kOiB0aGlzLmdldFN1Z2dlc3Rpb25LaW5kKCdudWxsJyksXG4gICAgICAgICAgICBsYWJlbDogJ251bGwnLFxuICAgICAgICAgICAgaW5zZXJ0VGV4dDogJ251bGwnICsgc2VwYXJhdG9yQWZ0ZXIsXG4gICAgICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBtYWluX0luc2VydFRleHRGb3JtYXQuU25pcHBldCxcbiAgICAgICAgICAgIGRvY3VtZW50YXRpb246ICcnXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhZGREb2xsYXJTY2hlbWFDb21wbGV0aW9ucyhzZXBhcmF0b3JBZnRlciwgY29sbGVjdG9yKSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYUlkcyA9IHRoaXMuc2NoZW1hU2VydmljZS5nZXRSZWdpc3RlcmVkU2NoZW1hSWRzKHNjaGVtYSA9PiBzY2hlbWEgPT09ICdodHRwJyB8fCBzY2hlbWEgPT09ICdodHRwcycpO1xuICAgICAgICBzY2hlbWFJZHMuZm9yRWFjaChzY2hlbWFJZCA9PiB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hSWQuc3RhcnRzV2l0aCgnaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0nKSkge1xuICAgICAgICAgICAgICAgIHNjaGVtYUlkID0gc2NoZW1hSWQgKyAnIyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2xsZWN0b3IuYWRkKHtcbiAgICAgICAgICAgICAgICBraW5kOiBtYWluX0NvbXBsZXRpb25JdGVtS2luZC5Nb2R1bGUsXG4gICAgICAgICAgICAgICAgbGFiZWw6IHRoaXMuZ2V0TGFiZWxGb3JWYWx1ZShzY2hlbWFJZCksXG4gICAgICAgICAgICAgICAgZmlsdGVyVGV4dDogdGhpcy5nZXRGaWx0ZXJUZXh0Rm9yVmFsdWUoc2NoZW1hSWQpLFxuICAgICAgICAgICAgICAgIGluc2VydFRleHQ6IHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclZhbHVlKHNjaGVtYUlkLCBzZXBhcmF0b3JBZnRlciksXG4gICAgICAgICAgICAgICAgaW5zZXJ0VGV4dEZvcm1hdDogbWFpbl9JbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXQsIGRvY3VtZW50YXRpb246ICcnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0VmFsdWVGcm9tTGFiZWwodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xuICAgIH1cbiAgICBnZXRGaWx0ZXJUZXh0Rm9yVmFsdWUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0RmlsdGVyVGV4dEZvclNuaXBwZXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL1xcJFxce1xcZCs6KFtefV0rKVxcfXxcXCRcXGQrL2csICckMScpO1xuICAgIH1cbiAgICBnZXRMYWJlbEZvclNuaXBwZXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBsYWJlbCA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGxhYmVsLnJlcGxhY2UoL1xcJFxce1xcZCs6KFtefV0rKVxcfXxcXCRcXGQrL2csICckMScpO1xuICAgIH1cbiAgICBnZXRJbnNlcnRUZXh0Rm9yUGxhaW5UZXh0KHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRleHQucmVwbGFjZSgvW1xcXFxcXCRcXH1dL2csICdcXFxcJCYnKTsgLy8gZXNjYXBlICQsIFxcIGFuZCB9XG4gICAgfVxuICAgIGdldEluc2VydFRleHRGb3JWYWx1ZSh2YWx1ZSwgc2VwYXJhdG9yQWZ0ZXIpIHtcbiAgICAgICAgY29uc3QgdGV4dCA9IEpTT04uc3RyaW5naWZ5KHZhbHVlLCBudWxsLCAnXFx0Jyk7XG4gICAgICAgIGlmICh0ZXh0ID09PSAne30nKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3skMX0nICsgc2VwYXJhdG9yQWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGV4dCA9PT0gJ1tdJykge1xuICAgICAgICAgICAgcmV0dXJuICdbJDFdJyArIHNlcGFyYXRvckFmdGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldEluc2VydFRleHRGb3JQbGFpblRleHQodGV4dCArIHNlcGFyYXRvckFmdGVyKTtcbiAgICB9XG4gICAgZ2V0SW5zZXJ0VGV4dEZvclNuaXBwZXRWYWx1ZSh2YWx1ZSwgc2VwYXJhdG9yQWZ0ZXIpIHtcbiAgICAgICAgY29uc3QgcmVwbGFjZXIgPSAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlWzBdID09PSAnXicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnN1YnN0cigxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gc3RyaW5naWZ5T2JqZWN0KHZhbHVlLCAnJywgcmVwbGFjZXIpICsgc2VwYXJhdG9yQWZ0ZXI7XG4gICAgfVxuICAgIGdldEluc2VydFRleHRGb3JHdWVzc2VkVmFsdWUodmFsdWUsIHNlcGFyYXRvckFmdGVyKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyR7MTpudWxsfScgKyBzZXBhcmF0b3JBZnRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclZhbHVlKHZhbHVlLCBzZXBhcmF0b3JBZnRlcik7XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIGxldCBzbmlwcGV0VmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgc25pcHBldFZhbHVlID0gc25pcHBldFZhbHVlLnN1YnN0cigxLCBzbmlwcGV0VmFsdWUubGVuZ3RoIC0gMik7IC8vIHJlbW92ZSBxdW90ZXNcbiAgICAgICAgICAgICAgICBzbmlwcGV0VmFsdWUgPSB0aGlzLmdldEluc2VydFRleHRGb3JQbGFpblRleHQoc25pcHBldFZhbHVlKTsgLy8gZXNjYXBlIFxcIGFuZCB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICdcIiR7MTonICsgc25pcHBldFZhbHVlICsgJ31cIicgKyBzZXBhcmF0b3JBZnRlcjtcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJyR7MTonICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpICsgJ30nICsgc2VwYXJhdG9yQWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclZhbHVlKHZhbHVlLCBzZXBhcmF0b3JBZnRlcik7XG4gICAgfVxuICAgIGdldFN1Z2dlc3Rpb25LaW5kKHR5cGUpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGFycmF5ID0gdHlwZTtcbiAgICAgICAgICAgIHR5cGUgPSBhcnJheS5sZW5ndGggPiAwID8gYXJyYXlbMF0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFpbl9Db21wbGV0aW9uSXRlbUtpbmQuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOiByZXR1cm4gbWFpbl9Db21wbGV0aW9uSXRlbUtpbmQuVmFsdWU7XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOiByZXR1cm4gbWFpbl9Db21wbGV0aW9uSXRlbUtpbmQuTW9kdWxlO1xuICAgICAgICAgICAgY2FzZSAncHJvcGVydHknOiByZXR1cm4gbWFpbl9Db21wbGV0aW9uSXRlbUtpbmQuUHJvcGVydHk7XG4gICAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gbWFpbl9Db21wbGV0aW9uSXRlbUtpbmQuVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0TGFiZWxUZXh0Rm9yTWF0Y2hpbmdOb2RlKG5vZGUsIGRvY3VtZW50KSB7XG4gICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdhcnJheSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdbXSc7XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgIHJldHVybiAne30nO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gZG9jdW1lbnQuZ2V0VGV4dCgpLnN1YnN0cihub2RlLm9mZnNldCwgbm9kZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEluc2VydFRleHRGb3JNYXRjaGluZ05vZGUobm9kZSwgZG9jdW1lbnQsIHNlcGFyYXRvckFmdGVyKSB7XG4gICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdhcnJheSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclZhbHVlKFtdLCBzZXBhcmF0b3JBZnRlcik7XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEluc2VydFRleHRGb3JWYWx1ZSh7fSwgc2VwYXJhdG9yQWZ0ZXIpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gZG9jdW1lbnQuZ2V0VGV4dCgpLnN1YnN0cihub2RlLm9mZnNldCwgbm9kZS5sZW5ndGgpICsgc2VwYXJhdG9yQWZ0ZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclBsYWluVGV4dChjb250ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRJbnNlcnRUZXh0Rm9yUHJvcGVydHkoa2V5LCBwcm9wZXJ0eVNjaGVtYSwgYWRkVmFsdWUsIHNlcGFyYXRvckFmdGVyKSB7XG4gICAgICAgIGNvbnN0IHByb3BlcnR5VGV4dCA9IHRoaXMuZ2V0SW5zZXJ0VGV4dEZvclZhbHVlKGtleSwgJycpO1xuICAgICAgICBpZiAoIWFkZFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvcGVydHlUZXh0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdFRleHQgPSBwcm9wZXJ0eVRleHQgKyAnOiAnO1xuICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgIGxldCBuVmFsdWVQcm9wb3NhbHMgPSAwO1xuICAgICAgICBpZiAocHJvcGVydHlTY2hlbWEpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BlcnR5U2NoZW1hLmRlZmF1bHRTbmlwcGV0cykpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHlTY2hlbWEuZGVmYXVsdFNuaXBwZXRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBib2R5ID0gcHJvcGVydHlTY2hlbWEuZGVmYXVsdFNuaXBwZXRzWzBdLmJvZHk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQoYm9keSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5nZXRJbnNlcnRUZXh0Rm9yU25pcHBldFZhbHVlKGJvZHksICcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuVmFsdWVQcm9wb3NhbHMgKz0gcHJvcGVydHlTY2hlbWEuZGVmYXVsdFNuaXBwZXRzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eVNjaGVtYS5lbnVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSAmJiBwcm9wZXJ0eVNjaGVtYS5lbnVtLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZ2V0SW5zZXJ0VGV4dEZvckd1ZXNzZWRWYWx1ZShwcm9wZXJ0eVNjaGVtYS5lbnVtWzBdLCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5WYWx1ZVByb3Bvc2FscyArPSBwcm9wZXJ0eVNjaGVtYS5lbnVtLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0RlZmluZWQocHJvcGVydHlTY2hlbWEuY29uc3QpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZ2V0SW5zZXJ0VGV4dEZvckd1ZXNzZWRWYWx1ZShwcm9wZXJ0eVNjaGVtYS5jb25zdCwgJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuVmFsdWVQcm9wb3NhbHMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0RlZmluZWQocHJvcGVydHlTY2hlbWEuZGVmYXVsdCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5nZXRJbnNlcnRUZXh0Rm9yR3Vlc3NlZFZhbHVlKHByb3BlcnR5U2NoZW1hLmRlZmF1bHQsICcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgblZhbHVlUHJvcG9zYWxzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wZXJ0eVNjaGVtYS5leGFtcGxlcykgJiYgcHJvcGVydHlTY2hlbWEuZXhhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZ2V0SW5zZXJ0VGV4dEZvckd1ZXNzZWRWYWx1ZShwcm9wZXJ0eVNjaGVtYS5leGFtcGxlc1swXSwgJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuVmFsdWVQcm9wb3NhbHMgKz0gcHJvcGVydHlTY2hlbWEuZXhhbXBsZXMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5WYWx1ZVByb3Bvc2FscyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxldCB0eXBlID0gQXJyYXkuaXNBcnJheShwcm9wZXJ0eVNjaGVtYS50eXBlKSA/IHByb3BlcnR5U2NoZW1hLnR5cGVbMF0gOiBwcm9wZXJ0eVNjaGVtYS50eXBlO1xuICAgICAgICAgICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydHlTY2hlbWEucHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9ICdvYmplY3QnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb3BlcnR5U2NoZW1hLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gJ2FycmF5JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICckMSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJ1wiJDFcIic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJ3skMX0nO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJ1skMV0nO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ludGVnZXInOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnJHsxOjB9JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdudWxsJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJyR7MTpudWxsfSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eVRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdmFsdWUgfHwgblZhbHVlUHJvcG9zYWxzID4gMSkge1xuICAgICAgICAgICAgdmFsdWUgPSAnJDEnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRUZXh0ICsgdmFsdWUgKyBzZXBhcmF0b3JBZnRlcjtcbiAgICB9XG4gICAgZ2V0Q3VycmVudFdvcmQoZG9jdW1lbnQsIG9mZnNldCkge1xuICAgICAgICBsZXQgaSA9IG9mZnNldCAtIDE7XG4gICAgICAgIGNvbnN0IHRleHQgPSBkb2N1bWVudC5nZXRUZXh0KCk7XG4gICAgICAgIHdoaWxlIChpID49IDAgJiYgJyBcXHRcXG5cXHJcXHZcIjp7WyxdfScuaW5kZXhPZih0ZXh0LmNoYXJBdChpKSkgPT09IC0xKSB7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQuc3Vic3RyaW5nKGkgKyAxLCBvZmZzZXQpO1xuICAgIH1cbiAgICBldmFsdWF0ZVNlcGFyYXRvckFmdGVyKGRvY3VtZW50LCBvZmZzZXQpIHtcbiAgICAgICAgY29uc3Qgc2Nhbm5lciA9IG1haW5fY3JlYXRlU2Nhbm5lcihkb2N1bWVudC5nZXRUZXh0KCksIHRydWUpO1xuICAgICAgICBzY2FubmVyLnNldFBvc2l0aW9uKG9mZnNldCk7XG4gICAgICAgIGNvbnN0IHRva2VuID0gc2Nhbm5lci5zY2FuKCk7XG4gICAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgICAgIGNhc2UgNSAvKiBKc29uLlN5bnRheEtpbmQuQ29tbWFUb2tlbiAqLzpcbiAgICAgICAgICAgIGNhc2UgMiAvKiBKc29uLlN5bnRheEtpbmQuQ2xvc2VCcmFjZVRva2VuICovOlxuICAgICAgICAgICAgY2FzZSA0IC8qIEpzb24uU3ludGF4S2luZC5DbG9zZUJyYWNrZXRUb2tlbiAqLzpcbiAgICAgICAgICAgIGNhc2UgMTcgLyogSnNvbi5TeW50YXhLaW5kLkVPRiAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAnLCc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluZEl0ZW1BdE9mZnNldChub2RlLCBkb2N1bWVudCwgb2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IHNjYW5uZXIgPSBtYWluX2NyZWF0ZVNjYW5uZXIoZG9jdW1lbnQuZ2V0VGV4dCgpLCB0cnVlKTtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLml0ZW1zO1xuICAgICAgICBmb3IgKGxldCBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID4gY2hpbGQub2Zmc2V0ICsgY2hpbGQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc2Nhbm5lci5zZXRQb3NpdGlvbihjaGlsZC5vZmZzZXQgKyBjaGlsZC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuID0gc2Nhbm5lci5zY2FuKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSA1IC8qIEpzb24uU3ludGF4S2luZC5Db21tYVRva2VuICovICYmIG9mZnNldCA+PSBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkgKyBzY2FubmVyLmdldFRva2VuTGVuZ3RoKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9mZnNldCA+PSBjaGlsZC5vZmZzZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaXNJbkNvbW1lbnQoZG9jdW1lbnQsIHN0YXJ0LCBvZmZzZXQpIHtcbiAgICAgICAgY29uc3Qgc2Nhbm5lciA9IG1haW5fY3JlYXRlU2Nhbm5lcihkb2N1bWVudC5nZXRUZXh0KCksIGZhbHNlKTtcbiAgICAgICAgc2Nhbm5lci5zZXRQb3NpdGlvbihzdGFydCk7XG4gICAgICAgIGxldCB0b2tlbiA9IHNjYW5uZXIuc2NhbigpO1xuICAgICAgICB3aGlsZSAodG9rZW4gIT09IDE3IC8qIEpzb24uU3ludGF4S2luZC5FT0YgKi8gJiYgKHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSArIHNjYW5uZXIuZ2V0VG9rZW5MZW5ndGgoKSA8IG9mZnNldCkpIHtcbiAgICAgICAgICAgIHRva2VuID0gc2Nhbm5lci5zY2FuKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0b2tlbiA9PT0gMTIgLyogSnNvbi5TeW50YXhLaW5kLkxpbmVDb21tZW50VHJpdmlhICovIHx8IHRva2VuID09PSAxMyAvKiBKc29uLlN5bnRheEtpbmQuQmxvY2tDb21tZW50VHJpdmlhICovKSAmJiBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkgPD0gb2Zmc2V0O1xuICAgIH1cbiAgICBmcm9tTWFya3VwKG1hcmt1cFN0cmluZykge1xuICAgICAgICBpZiAobWFya3VwU3RyaW5nICYmIHRoaXMuZG9lc1N1cHBvcnRNYXJrZG93bigpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGtpbmQ6IE1hcmt1cEtpbmQuTWFya2Rvd24sXG4gICAgICAgICAgICAgICAgdmFsdWU6IG1hcmt1cFN0cmluZ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBkb2VzU3VwcG9ydE1hcmtkb3duKCkge1xuICAgICAgICBpZiAoIWlzRGVmaW5lZCh0aGlzLnN1cHBvcnRzTWFya2Rvd24pKSB7XG4gICAgICAgICAgICBjb25zdCBkb2N1bWVudGF0aW9uRm9ybWF0ID0gdGhpcy5jbGllbnRDYXBhYmlsaXRpZXMudGV4dERvY3VtZW50Py5jb21wbGV0aW9uPy5jb21wbGV0aW9uSXRlbT8uZG9jdW1lbnRhdGlvbkZvcm1hdDtcbiAgICAgICAgICAgIHRoaXMuc3VwcG9ydHNNYXJrZG93biA9IEFycmF5LmlzQXJyYXkoZG9jdW1lbnRhdGlvbkZvcm1hdCkgJiYgZG9jdW1lbnRhdGlvbkZvcm1hdC5pbmRleE9mKE1hcmt1cEtpbmQuTWFya2Rvd24pICE9PSAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zdXBwb3J0c01hcmtkb3duO1xuICAgIH1cbiAgICBkb2VzU3VwcG9ydHNDb21taXRDaGFyYWN0ZXJzKCkge1xuICAgICAgICBpZiAoIWlzRGVmaW5lZCh0aGlzLnN1cHBvcnRzQ29tbWl0Q2hhcmFjdGVycykpIHtcbiAgICAgICAgICAgIHRoaXMubGFiZWxEZXRhaWxzU3VwcG9ydCA9IHRoaXMuY2xpZW50Q2FwYWJpbGl0aWVzLnRleHREb2N1bWVudD8uY29tcGxldGlvbj8uY29tcGxldGlvbkl0ZW0/LmNvbW1pdENoYXJhY3RlcnNTdXBwb3J0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnN1cHBvcnRzQ29tbWl0Q2hhcmFjdGVycztcbiAgICB9XG4gICAgZG9lc1N1cHBvcnRzTGFiZWxEZXRhaWxzKCkge1xuICAgICAgICBpZiAoIWlzRGVmaW5lZCh0aGlzLmxhYmVsRGV0YWlsc1N1cHBvcnQpKSB7XG4gICAgICAgICAgICB0aGlzLmxhYmVsRGV0YWlsc1N1cHBvcnQgPSB0aGlzLmNsaWVudENhcGFiaWxpdGllcy50ZXh0RG9jdW1lbnQ/LmNvbXBsZXRpb24/LmNvbXBsZXRpb25JdGVtPy5sYWJlbERldGFpbHNTdXBwb3J0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxhYmVsRGV0YWlsc1N1cHBvcnQ7XG4gICAgfVxufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3ZzY29kZS1qc29uLWxhbmd1YWdlc2VydmljZS9saWIvZXNtL3NlcnZpY2VzL2pzb25Ib3Zlci5qc1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuY2xhc3MgSlNPTkhvdmVyIHtcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWFTZXJ2aWNlLCBjb250cmlidXRpb25zID0gW10sIHByb21pc2VDb25zdHJ1Y3Rvcikge1xuICAgICAgICB0aGlzLnNjaGVtYVNlcnZpY2UgPSBzY2hlbWFTZXJ2aWNlO1xuICAgICAgICB0aGlzLmNvbnRyaWJ1dGlvbnMgPSBjb250cmlidXRpb25zO1xuICAgICAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlQ29uc3RydWN0b3IgfHwgUHJvbWlzZTtcbiAgICB9XG4gICAgZG9Ib3Zlcihkb2N1bWVudCwgcG9zaXRpb24sIGRvYykge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBkb2N1bWVudC5vZmZzZXRBdChwb3NpdGlvbik7XG4gICAgICAgIGxldCBub2RlID0gZG9jLmdldE5vZGVGcm9tT2Zmc2V0KG9mZnNldCk7XG4gICAgICAgIGlmICghbm9kZSB8fCAobm9kZS50eXBlID09PSAnb2JqZWN0JyB8fCBub2RlLnR5cGUgPT09ICdhcnJheScpICYmIG9mZnNldCA+IG5vZGUub2Zmc2V0ICsgMSAmJiBvZmZzZXQgPCBub2RlLm9mZnNldCArIG5vZGUubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhvdmVyUmFuZ2VOb2RlID0gbm9kZTtcbiAgICAgICAgLy8gdXNlIHRoZSBwcm9wZXJ0eSBkZXNjcmlwdGlvbiB3aGVuIGhvdmVyaW5nIG92ZXIgYW4gb2JqZWN0IGtleVxuICAgICAgICBpZiAobm9kZS50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudC50eXBlID09PSAncHJvcGVydHknICYmIHBhcmVudC5rZXlOb2RlID09PSBub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudC52YWx1ZU5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaG92ZXJSYW5nZSA9IFJhbmdlLmNyZWF0ZShkb2N1bWVudC5wb3NpdGlvbkF0KGhvdmVyUmFuZ2VOb2RlLm9mZnNldCksIGRvY3VtZW50LnBvc2l0aW9uQXQoaG92ZXJSYW5nZU5vZGUub2Zmc2V0ICsgaG92ZXJSYW5nZU5vZGUubGVuZ3RoKSk7XG4gICAgICAgIGNvbnN0IGNyZWF0ZUhvdmVyID0gKGNvbnRlbnRzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgY29udGVudHM6IGNvbnRlbnRzLFxuICAgICAgICAgICAgICAgIHJhbmdlOiBob3ZlclJhbmdlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSBqc29uUGFyc2VyX2dldE5vZGVQYXRoKG5vZGUpO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5jb250cmlidXRpb25zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBjb250cmlidXRpb24gPSB0aGlzLmNvbnRyaWJ1dGlvbnNbaV07XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gY29udHJpYnV0aW9uLmdldEluZm9Db250cmlidXRpb24oZG9jdW1lbnQudXJpLCBsb2NhdGlvbik7XG4gICAgICAgICAgICBpZiAocHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oaHRtbENvbnRlbnQgPT4gY3JlYXRlSG92ZXIoaHRtbENvbnRlbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zY2hlbWFTZXJ2aWNlLmdldFNjaGVtYUZvclJlc291cmNlKGRvY3VtZW50LnVyaSwgZG9jKS50aGVuKChzY2hlbWEpID0+IHtcbiAgICAgICAgICAgIGlmIChzY2hlbWEgJiYgbm9kZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nU2NoZW1hcyA9IGRvYy5nZXRNYXRjaGluZ1NjaGVtYXMoc2NoZW1hLnNjaGVtYSwgbm9kZS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGxldCB0aXRsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBsZXQgbWFya2Rvd25EZXNjcmlwdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBsZXQgbWFya2Rvd25FbnVtVmFsdWVEZXNjcmlwdGlvbiA9IHVuZGVmaW5lZCwgZW51bVZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIG1hdGNoaW5nU2NoZW1hcy5ldmVyeSgocykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocy5ub2RlID09PSBub2RlICYmICFzLmludmVydGVkICYmIHMuc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSA9IHRpdGxlIHx8IHMuc2NoZW1hLnRpdGxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFya2Rvd25EZXNjcmlwdGlvbiA9IG1hcmtkb3duRGVzY3JpcHRpb24gfHwgcy5zY2hlbWEubWFya2Rvd25EZXNjcmlwdGlvbiB8fCB0b01hcmtkb3duKHMuc2NoZW1hLmRlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzLnNjaGVtYS5lbnVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaWR4ID0gcy5zY2hlbWEuZW51bS5pbmRleE9mKGpzb25QYXJzZXJfZ2V0Tm9kZVZhbHVlKG5vZGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocy5zY2hlbWEubWFya2Rvd25FbnVtRGVzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtkb3duRW51bVZhbHVlRGVzY3JpcHRpb24gPSBzLnNjaGVtYS5tYXJrZG93bkVudW1EZXNjcmlwdGlvbnNbaWR4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocy5zY2hlbWEuZW51bURlc2NyaXB0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrZG93bkVudW1WYWx1ZURlc2NyaXB0aW9uID0gdG9NYXJrZG93bihzLnNjaGVtYS5lbnVtRGVzY3JpcHRpb25zW2lkeF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFya2Rvd25FbnVtVmFsdWVEZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnVtVmFsdWUgPSBzLnNjaGVtYS5lbnVtW2lkeF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZW51bVZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW51bVZhbHVlID0gSlNPTi5zdHJpbmdpZnkoZW51bVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgICAgICAgICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRvTWFya2Rvd24odGl0bGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWFya2Rvd25EZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIlxcblxcblwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBtYXJrZG93bkRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWFya2Rvd25FbnVtVmFsdWVEZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIlxcblxcblwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBgXFxgJHt0b01hcmtkb3duQ29kZUJsb2NrKGVudW1WYWx1ZSl9XFxgOiAke21hcmtkb3duRW51bVZhbHVlRGVzY3JpcHRpb259YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUhvdmVyKFtyZXN1bHRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiB0b01hcmtkb3duKHBsYWluKSB7XG4gICAgaWYgKHBsYWluKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHBsYWluLnJlcGxhY2UoLyhbXlxcblxccl0pKFxccj9cXG4pKFteXFxuXFxyXSkvZ20sICckMVxcblxcbiQzJyk7IC8vIHNpbmdsZSBuZXcgbGluZXMgdG8gXFxuXFxuIChNYXJrZG93biBwYXJhZ3JhcGgpXG4gICAgICAgIHJldHVybiByZXMucmVwbGFjZSgvW1xcXFxgKl97fVtcXF0oKSMrXFwtLiFdL2csIFwiXFxcXCQmXCIpOyAvLyBlc2NhcGUgbWFya2Rvd24gc3ludGF4IHRva2VuczogaHR0cDovL2RhcmluZ2ZpcmViYWxsLm5ldC9wcm9qZWN0cy9tYXJrZG93bi9zeW50YXgjYmFja3NsYXNoXG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiB0b01hcmtkb3duQ29kZUJsb2NrKGNvbnRlbnQpIHtcbiAgICAvLyBzZWUgaHR0cHM6Ly9kYXJpbmdmaXJlYmFsbC5uZXQvcHJvamVjdHMvbWFya2Rvd24vc3ludGF4I3ByZWNvZGVcbiAgICBpZiAoY29udGVudC5pbmRleE9mKCdgJykgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiAnYGAgJyArIGNvbnRlbnQgKyAnIGBgJztcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL2xpYi9lc20vc2VydmljZXMvanNvblZhbGlkYXRpb24uanNcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblxuY2xhc3MgSlNPTlZhbGlkYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGpzb25TY2hlbWFTZXJ2aWNlLCBwcm9taXNlQ29uc3RydWN0b3IpIHtcbiAgICAgICAgdGhpcy5qc29uU2NoZW1hU2VydmljZSA9IGpzb25TY2hlbWFTZXJ2aWNlO1xuICAgICAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlQ29uc3RydWN0b3I7XG4gICAgICAgIHRoaXMudmFsaWRhdGlvbkVuYWJsZWQgPSB0cnVlO1xuICAgIH1cbiAgICBjb25maWd1cmUocmF3KSB7XG4gICAgICAgIGlmIChyYXcpIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGlvbkVuYWJsZWQgPSByYXcudmFsaWRhdGUgIT09IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5jb21tZW50U2V2ZXJpdHkgPSByYXcuYWxsb3dDb21tZW50cyA/IHVuZGVmaW5lZCA6IERpYWdub3N0aWNTZXZlcml0eS5FcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkb1ZhbGlkYXRpb24odGV4dERvY3VtZW50LCBqc29uRG9jdW1lbnQsIGRvY3VtZW50U2V0dGluZ3MsIHNjaGVtYSkge1xuICAgICAgICBpZiAoIXRoaXMudmFsaWRhdGlvbkVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlhZ25vc3RpY3MgPSBbXTtcbiAgICAgICAgY29uc3QgYWRkZWQgPSB7fTtcbiAgICAgICAgY29uc3QgYWRkUHJvYmxlbSA9IChwcm9ibGVtKSA9PiB7XG4gICAgICAgICAgICAvLyByZW1vdmUgZHVwbGljYXRlZCBtZXNzYWdlc1xuICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gcHJvYmxlbS5yYW5nZS5zdGFydC5saW5lICsgJyAnICsgcHJvYmxlbS5yYW5nZS5zdGFydC5jaGFyYWN0ZXIgKyAnICcgKyBwcm9ibGVtLm1lc3NhZ2U7XG4gICAgICAgICAgICBpZiAoIWFkZGVkW3NpZ25hdHVyZV0pIHtcbiAgICAgICAgICAgICAgICBhZGRlZFtzaWduYXR1cmVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBkaWFnbm9zdGljcy5wdXNoKHByb2JsZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBnZXREaWFnbm9zdGljcyA9IChzY2hlbWEpID0+IHtcbiAgICAgICAgICAgIGxldCB0cmFpbGluZ0NvbW1hU2V2ZXJpdHkgPSBkb2N1bWVudFNldHRpbmdzPy50cmFpbGluZ0NvbW1hcyA/IHRvRGlhZ25vc3RpY1NldmVyaXR5KGRvY3VtZW50U2V0dGluZ3MudHJhaWxpbmdDb21tYXMpIDogRGlhZ25vc3RpY1NldmVyaXR5LkVycm9yO1xuICAgICAgICAgICAgbGV0IGNvbW1lbnRTZXZlcml0eSA9IGRvY3VtZW50U2V0dGluZ3M/LmNvbW1lbnRzID8gdG9EaWFnbm9zdGljU2V2ZXJpdHkoZG9jdW1lbnRTZXR0aW5ncy5jb21tZW50cykgOiB0aGlzLmNvbW1lbnRTZXZlcml0eTtcbiAgICAgICAgICAgIGxldCBzY2hlbWFWYWxpZGF0aW9uID0gZG9jdW1lbnRTZXR0aW5ncz8uc2NoZW1hVmFsaWRhdGlvbiA/IHRvRGlhZ25vc3RpY1NldmVyaXR5KGRvY3VtZW50U2V0dGluZ3Muc2NoZW1hVmFsaWRhdGlvbikgOiBEaWFnbm9zdGljU2V2ZXJpdHkuV2FybmluZztcbiAgICAgICAgICAgIGxldCBzY2hlbWFSZXF1ZXN0ID0gZG9jdW1lbnRTZXR0aW5ncz8uc2NoZW1hUmVxdWVzdCA/IHRvRGlhZ25vc3RpY1NldmVyaXR5KGRvY3VtZW50U2V0dGluZ3Muc2NoZW1hUmVxdWVzdCkgOiBEaWFnbm9zdGljU2V2ZXJpdHkuV2FybmluZztcbiAgICAgICAgICAgIGlmIChzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhZGRTY2hlbWFQcm9ibGVtID0gKGVycm9yTWVzc2FnZSwgZXJyb3JDb2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqc29uRG9jdW1lbnQucm9vdCAmJiBzY2hlbWFSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhc3RSb290ID0ganNvbkRvY3VtZW50LnJvb3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eSA9IGFzdFJvb3QudHlwZSA9PT0gJ29iamVjdCcgPyBhc3RSb290LnByb3BlcnRpZXNbMF0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydHkgJiYgcHJvcGVydHkua2V5Tm9kZS52YWx1ZSA9PT0gJyRzY2hlbWEnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHByb3BlcnR5LnZhbHVlTm9kZSB8fCBwcm9wZXJ0eTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IFJhbmdlLmNyZWF0ZSh0ZXh0RG9jdW1lbnQucG9zaXRpb25BdChub2RlLm9mZnNldCksIHRleHREb2N1bWVudC5wb3NpdGlvbkF0KG5vZGUub2Zmc2V0ICsgbm9kZS5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRQcm9ibGVtKERpYWdub3N0aWMuY3JlYXRlKHJhbmdlLCBlcnJvck1lc3NhZ2UsIHNjaGVtYVJlcXVlc3QsIGVycm9yQ29kZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBSYW5nZS5jcmVhdGUodGV4dERvY3VtZW50LnBvc2l0aW9uQXQoYXN0Um9vdC5vZmZzZXQpLCB0ZXh0RG9jdW1lbnQucG9zaXRpb25BdChhc3RSb290Lm9mZnNldCArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRQcm9ibGVtKERpYWdub3N0aWMuY3JlYXRlKHJhbmdlLCBlcnJvck1lc3NhZ2UsIHNjaGVtYVJlcXVlc3QsIGVycm9yQ29kZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoc2NoZW1hLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkU2NoZW1hUHJvYmxlbShzY2hlbWEuZXJyb3JzWzBdLCBFcnJvckNvZGUuU2NoZW1hUmVzb2x2ZUVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2NoZW1hVmFsaWRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHdhcm5pbmcgb2Ygc2NoZW1hLndhcm5pbmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRTY2hlbWFQcm9ibGVtKHdhcm5pbmcsIEVycm9yQ29kZS5TY2hlbWFVbnN1cHBvcnRlZEZlYXR1cmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbWFudGljRXJyb3JzID0ganNvbkRvY3VtZW50LnZhbGlkYXRlKHRleHREb2N1bWVudCwgc2NoZW1hLnNjaGVtYSwgc2NoZW1hVmFsaWRhdGlvbiwgZG9jdW1lbnRTZXR0aW5ncz8uc2NoZW1hRHJhZnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VtYW50aWNFcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbWFudGljRXJyb3JzLmZvckVhY2goYWRkUHJvYmxlbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYUFsbG93c0NvbW1lbnRzKHNjaGVtYS5zY2hlbWEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnRTZXZlcml0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYUFsbG93c1RyYWlsaW5nQ29tbWFzKHNjaGVtYS5zY2hlbWEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nQ29tbWFTZXZlcml0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHAgb2YganNvbkRvY3VtZW50LnN5bnRheEVycm9ycykge1xuICAgICAgICAgICAgICAgIGlmIChwLmNvZGUgPT09IEVycm9yQ29kZS5UcmFpbGluZ0NvbW1hKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdHJhaWxpbmdDb21tYVNldmVyaXR5ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcC5zZXZlcml0eSA9IHRyYWlsaW5nQ29tbWFTZXZlcml0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkUHJvYmxlbShwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29tbWVudFNldmVyaXR5ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0KCdDb21tZW50cyBhcmUgbm90IHBlcm1pdHRlZCBpbiBKU09OLicpO1xuICAgICAgICAgICAgICAgIGpzb25Eb2N1bWVudC5jb21tZW50cy5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhZGRQcm9ibGVtKERpYWdub3N0aWMuY3JlYXRlKGMsIG1lc3NhZ2UsIGNvbW1lbnRTZXZlcml0eSwgRXJyb3JDb2RlLkNvbW1lbnROb3RQZXJtaXR0ZWQpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkaWFnbm9zdGljcztcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHNjaGVtYSkge1xuICAgICAgICAgICAgY29uc3QgdXJpID0gc2NoZW1hLmlkIHx8ICgnc2NoZW1hc2VydmljZTovL3VudGl0bGVkLycgKyBpZENvdW50ZXIrKyk7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGUgPSB0aGlzLmpzb25TY2hlbWFTZXJ2aWNlLnJlZ2lzdGVyRXh0ZXJuYWxTY2hlbWEoeyB1cmksIHNjaGVtYSB9KTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGUuZ2V0UmVzb2x2ZWRTY2hlbWEoKS50aGVuKHJlc29sdmVkU2NoZW1hID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0RGlhZ25vc3RpY3MocmVzb2x2ZWRTY2hlbWEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuanNvblNjaGVtYVNlcnZpY2UuZ2V0U2NoZW1hRm9yUmVzb3VyY2UodGV4dERvY3VtZW50LnVyaSwganNvbkRvY3VtZW50KS50aGVuKHNjaGVtYSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0RGlhZ25vc3RpY3Moc2NoZW1hKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldExhbmd1YWdlU3RhdHVzKHRleHREb2N1bWVudCwganNvbkRvY3VtZW50KSB7XG4gICAgICAgIHJldHVybiB7IHNjaGVtYXM6IHRoaXMuanNvblNjaGVtYVNlcnZpY2UuZ2V0U2NoZW1hVVJJc0ZvclJlc291cmNlKHRleHREb2N1bWVudC51cmksIGpzb25Eb2N1bWVudCkgfTtcbiAgICB9XG59XG5sZXQgaWRDb3VudGVyID0gMDtcbmZ1bmN0aW9uIHNjaGVtYUFsbG93c0NvbW1lbnRzKHNjaGVtYVJlZikge1xuICAgIGlmIChzY2hlbWFSZWYgJiYgdHlwZW9mIHNjaGVtYVJlZiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKGlzQm9vbGVhbihzY2hlbWFSZWYuYWxsb3dDb21tZW50cykpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWFSZWYuYWxsb3dDb21tZW50cztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hUmVmLmFsbE9mKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNjaGVtYSBvZiBzY2hlbWFSZWYuYWxsT2YpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhbGxvdyA9IHNjaGVtYUFsbG93c0NvbW1lbnRzKHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzQm9vbGVhbihhbGxvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFsbG93O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gc2NoZW1hQWxsb3dzVHJhaWxpbmdDb21tYXMoc2NoZW1hUmVmKSB7XG4gICAgaWYgKHNjaGVtYVJlZiAmJiB0eXBlb2Ygc2NoZW1hUmVmID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoaXNCb29sZWFuKHNjaGVtYVJlZi5hbGxvd1RyYWlsaW5nQ29tbWFzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYVJlZi5hbGxvd1RyYWlsaW5nQ29tbWFzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlcHJTY2hlbWFSZWYgPSBzY2hlbWFSZWY7XG4gICAgICAgIGlmIChpc0Jvb2xlYW4oZGVwclNjaGVtYVJlZlsnYWxsb3dzVHJhaWxpbmdDb21tYXMnXSkpIHsgLy8gZGVwcmVjYXRlZFxuICAgICAgICAgICAgcmV0dXJuIGRlcHJTY2hlbWFSZWZbJ2FsbG93c1RyYWlsaW5nQ29tbWFzJ107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYVJlZi5hbGxPZikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBzY2hlbWEgb2Ygc2NoZW1hUmVmLmFsbE9mKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWxsb3cgPSBzY2hlbWFBbGxvd3NUcmFpbGluZ0NvbW1hcyhzY2hlbWEpO1xuICAgICAgICAgICAgICAgIGlmIChpc0Jvb2xlYW4oYWxsb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhbGxvdztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIHRvRGlhZ25vc3RpY1NldmVyaXR5KHNldmVyaXR5TGV2ZWwpIHtcbiAgICBzd2l0Y2ggKHNldmVyaXR5TGV2ZWwpIHtcbiAgICAgICAgY2FzZSAnZXJyb3InOiByZXR1cm4gRGlhZ25vc3RpY1NldmVyaXR5LkVycm9yO1xuICAgICAgICBjYXNlICd3YXJuaW5nJzogcmV0dXJuIERpYWdub3N0aWNTZXZlcml0eS5XYXJuaW5nO1xuICAgICAgICBjYXNlICdpZ25vcmUnOiByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3ZzY29kZS1qc29uLWxhbmd1YWdlc2VydmljZS9saWIvZXNtL3V0aWxzL2NvbG9ycy5qc1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5jb25zdCBEaWdpdDAgPSA0ODtcbmNvbnN0IERpZ2l0OSA9IDU3O1xuY29uc3QgQSA9IDY1O1xuY29uc3QgYSA9IDk3O1xuY29uc3QgZiA9IDEwMjtcbmZ1bmN0aW9uIGhleERpZ2l0KGNoYXJDb2RlKSB7XG4gICAgaWYgKGNoYXJDb2RlIDwgRGlnaXQwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAoY2hhckNvZGUgPD0gRGlnaXQ5KSB7XG4gICAgICAgIHJldHVybiBjaGFyQ29kZSAtIERpZ2l0MDtcbiAgICB9XG4gICAgaWYgKGNoYXJDb2RlIDwgYSkge1xuICAgICAgICBjaGFyQ29kZSArPSAoYSAtIEEpO1xuICAgIH1cbiAgICBpZiAoY2hhckNvZGUgPj0gYSAmJiBjaGFyQ29kZSA8PSBmKSB7XG4gICAgICAgIHJldHVybiBjaGFyQ29kZSAtIGEgKyAxMDtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBjb2xvckZyb21IZXgodGV4dCkge1xuICAgIGlmICh0ZXh0WzBdICE9PSAnIycpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgc3dpdGNoICh0ZXh0Lmxlbmd0aCkge1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlZDogKGhleERpZ2l0KHRleHQuY2hhckNvZGVBdCgxKSkgKiAweDExKSAvIDI1NS4wLFxuICAgICAgICAgICAgICAgIGdyZWVuOiAoaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDIpKSAqIDB4MTEpIC8gMjU1LjAsXG4gICAgICAgICAgICAgICAgYmx1ZTogKGhleERpZ2l0KHRleHQuY2hhckNvZGVBdCgzKSkgKiAweDExKSAvIDI1NS4wLFxuICAgICAgICAgICAgICAgIGFscGhhOiAxXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlZDogKGhleERpZ2l0KHRleHQuY2hhckNvZGVBdCgxKSkgKiAweDExKSAvIDI1NS4wLFxuICAgICAgICAgICAgICAgIGdyZWVuOiAoaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDIpKSAqIDB4MTEpIC8gMjU1LjAsXG4gICAgICAgICAgICAgICAgYmx1ZTogKGhleERpZ2l0KHRleHQuY2hhckNvZGVBdCgzKSkgKiAweDExKSAvIDI1NS4wLFxuICAgICAgICAgICAgICAgIGFscGhhOiAoaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDQpKSAqIDB4MTEpIC8gMjU1LjAsXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlZDogKGhleERpZ2l0KHRleHQuY2hhckNvZGVBdCgxKSkgKiAweDEwICsgaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDIpKSkgLyAyNTUuMCxcbiAgICAgICAgICAgICAgICBncmVlbjogKGhleERpZ2l0KHRleHQuY2hhckNvZGVBdCgzKSkgKiAweDEwICsgaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDQpKSkgLyAyNTUuMCxcbiAgICAgICAgICAgICAgICBibHVlOiAoaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDUpKSAqIDB4MTAgKyBoZXhEaWdpdCh0ZXh0LmNoYXJDb2RlQXQoNikpKSAvIDI1NS4wLFxuICAgICAgICAgICAgICAgIGFscGhhOiAxXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlZDogKGhleERpZ2l0KHRleHQuY2hhckNvZGVBdCgxKSkgKiAweDEwICsgaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDIpKSkgLyAyNTUuMCxcbiAgICAgICAgICAgICAgICBncmVlbjogKGhleERpZ2l0KHRleHQuY2hhckNvZGVBdCgzKSkgKiAweDEwICsgaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDQpKSkgLyAyNTUuMCxcbiAgICAgICAgICAgICAgICBibHVlOiAoaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDUpKSAqIDB4MTAgKyBoZXhEaWdpdCh0ZXh0LmNoYXJDb2RlQXQoNikpKSAvIDI1NS4wLFxuICAgICAgICAgICAgICAgIGFscGhhOiAoaGV4RGlnaXQodGV4dC5jaGFyQ29kZUF0KDcpKSAqIDB4MTAgKyBoZXhEaWdpdCh0ZXh0LmNoYXJDb2RlQXQoOCkpKSAvIDI1NS4wXG4gICAgICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gY29sb3JGcm9tMjU2UkdCKHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhID0gMS4wKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVkOiByZWQgLyAyNTUuMCxcbiAgICAgICAgZ3JlZW46IGdyZWVuIC8gMjU1LjAsXG4gICAgICAgIGJsdWU6IGJsdWUgLyAyNTUuMCxcbiAgICAgICAgYWxwaGFcbiAgICB9O1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3ZzY29kZS1qc29uLWxhbmd1YWdlc2VydmljZS9saWIvZXNtL3NlcnZpY2VzL2pzb25Eb2N1bWVudFN5bWJvbHMuanNcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cblxuXG5cbmNsYXNzIEpTT05Eb2N1bWVudFN5bWJvbHMge1xuICAgIGNvbnN0cnVjdG9yKHNjaGVtYVNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5zY2hlbWFTZXJ2aWNlID0gc2NoZW1hU2VydmljZTtcbiAgICB9XG4gICAgZmluZERvY3VtZW50U3ltYm9scyhkb2N1bWVudCwgZG9jLCBjb250ZXh0ID0geyByZXN1bHRMaW1pdDogTnVtYmVyLk1BWF9WQUxVRSB9KSB7XG4gICAgICAgIGNvbnN0IHJvb3QgPSBkb2Mucm9vdDtcbiAgICAgICAgaWYgKCFyb290KSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxpbWl0ID0gY29udGV4dC5yZXN1bHRMaW1pdCB8fCBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAvLyBzcGVjaWFsIGhhbmRsaW5nIGZvciBrZXkgYmluZGluZ3NcbiAgICAgICAgY29uc3QgcmVzb3VyY2VTdHJpbmcgPSBkb2N1bWVudC51cmk7XG4gICAgICAgIGlmICgocmVzb3VyY2VTdHJpbmcgPT09ICd2c2NvZGU6Ly9kZWZhdWx0c2V0dGluZ3Mva2V5YmluZGluZ3MuanNvbicpIHx8IGVuZHNXaXRoKHJlc291cmNlU3RyaW5nLnRvTG93ZXJDYXNlKCksICcvdXNlci9rZXliaW5kaW5ncy5qc29uJykpIHtcbiAgICAgICAgICAgIGlmIChyb290LnR5cGUgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygcm9vdC5pdGVtcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS50eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBpdGVtLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydHkua2V5Tm9kZS52YWx1ZSA9PT0gJ2tleScgJiYgcHJvcGVydHkudmFsdWVOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gTG9jYXRpb24uY3JlYXRlKGRvY3VtZW50LnVyaSwgZ2V0UmFuZ2UoZG9jdW1lbnQsIGl0ZW0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBuYW1lOiBnZXROYW1lKHByb3BlcnR5LnZhbHVlTm9kZSksIGtpbmQ6IFN5bWJvbEtpbmQuRnVuY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGltaXQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbWl0IDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQub25SZXN1bHRMaW1pdEV4Y2VlZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5vblJlc3VsdExpbWl0RXhjZWVkZWQocmVzb3VyY2VTdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvVmlzaXQgPSBbXG4gICAgICAgICAgICB7IG5vZGU6IHJvb3QsIGNvbnRhaW5lck5hbWU6ICcnIH1cbiAgICAgICAgXTtcbiAgICAgICAgbGV0IG5leHRUb1Zpc2l0ID0gMDtcbiAgICAgICAgbGV0IGxpbWl0RXhjZWVkZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGNvbnN0IGNvbGxlY3RPdXRsaW5lRW50cmllcyA9IChub2RlLCBjb250YWluZXJOYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5pdGVtcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9WaXNpdC5wdXNoKHsgbm9kZSwgY29udGFpbmVyTmFtZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS50eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIG5vZGUucHJvcGVydGllcy5mb3JFYWNoKChwcm9wZXJ0eSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZU5vZGUgPSBwcm9wZXJ0eS52YWx1ZU5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW1pdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW1pdC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gTG9jYXRpb24uY3JlYXRlKGRvY3VtZW50LnVyaSwgZ2V0UmFuZ2UoZG9jdW1lbnQsIHByb3BlcnR5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGRDb250YWluZXJOYW1lID0gY29udGFpbmVyTmFtZSA/IGNvbnRhaW5lck5hbWUgKyAnLicgKyBwcm9wZXJ0eS5rZXlOb2RlLnZhbHVlIDogcHJvcGVydHkua2V5Tm9kZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IG5hbWU6IHRoaXMuZ2V0S2V5TGFiZWwocHJvcGVydHkpLCBraW5kOiB0aGlzLmdldFN5bWJvbEtpbmQodmFsdWVOb2RlLnR5cGUpLCBsb2NhdGlvbjogbG9jYXRpb24sIGNvbnRhaW5lck5hbWU6IGNvbnRhaW5lck5hbWUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9WaXNpdC5wdXNoKHsgbm9kZTogdmFsdWVOb2RlLCBjb250YWluZXJOYW1lOiBjaGlsZENvbnRhaW5lck5hbWUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW1pdEV4Y2VlZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBicmVhdGggZmlyc3QgdHJhdmVyc2FsXG4gICAgICAgIHdoaWxlIChuZXh0VG9WaXNpdCA8IHRvVmlzaXQubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gdG9WaXNpdFtuZXh0VG9WaXNpdCsrXTtcbiAgICAgICAgICAgIGNvbGxlY3RPdXRsaW5lRW50cmllcyhuZXh0Lm5vZGUsIG5leHQuY29udGFpbmVyTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbWl0RXhjZWVkZWQgJiYgY29udGV4dCAmJiBjb250ZXh0Lm9uUmVzdWx0TGltaXRFeGNlZWRlZCkge1xuICAgICAgICAgICAgY29udGV4dC5vblJlc3VsdExpbWl0RXhjZWVkZWQocmVzb3VyY2VTdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZpbmREb2N1bWVudFN5bWJvbHMyKGRvY3VtZW50LCBkb2MsIGNvbnRleHQgPSB7IHJlc3VsdExpbWl0OiBOdW1iZXIuTUFYX1ZBTFVFIH0pIHtcbiAgICAgICAgY29uc3Qgcm9vdCA9IGRvYy5yb290O1xuICAgICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGltaXQgPSBjb250ZXh0LnJlc3VsdExpbWl0IHx8IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgIC8vIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGtleSBiaW5kaW5nc1xuICAgICAgICBjb25zdCByZXNvdXJjZVN0cmluZyA9IGRvY3VtZW50LnVyaTtcbiAgICAgICAgaWYgKChyZXNvdXJjZVN0cmluZyA9PT0gJ3ZzY29kZTovL2RlZmF1bHRzZXR0aW5ncy9rZXliaW5kaW5ncy5qc29uJykgfHwgZW5kc1dpdGgocmVzb3VyY2VTdHJpbmcudG9Mb3dlckNhc2UoKSwgJy91c2VyL2tleWJpbmRpbmdzLmpzb24nKSkge1xuICAgICAgICAgICAgaWYgKHJvb3QudHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiByb290Lml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIGl0ZW0ucHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eS5rZXlOb2RlLnZhbHVlID09PSAna2V5JyAmJiBwcm9wZXJ0eS52YWx1ZU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBnZXRSYW5nZShkb2N1bWVudCwgaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvblJhbmdlID0gZ2V0UmFuZ2UoZG9jdW1lbnQsIHByb3BlcnR5LmtleU5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IG5hbWU6IGdldE5hbWUocHJvcGVydHkudmFsdWVOb2RlKSwga2luZDogU3ltYm9sS2luZC5GdW5jdGlvbiwgcmFuZ2UsIHNlbGVjdGlvblJhbmdlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW1pdC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGltaXQgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5vblJlc3VsdExpbWl0RXhjZWVkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9uUmVzdWx0TGltaXRFeGNlZWRlZChyZXNvdXJjZVN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGNvbnN0IHRvVmlzaXQgPSBbXG4gICAgICAgICAgICB7IG5vZGU6IHJvb3QsIHJlc3VsdCB9XG4gICAgICAgIF07XG4gICAgICAgIGxldCBuZXh0VG9WaXNpdCA9IDA7XG4gICAgICAgIGxldCBsaW1pdEV4Y2VlZGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGNvbGxlY3RPdXRsaW5lRW50cmllcyA9IChub2RlLCByZXN1bHQpID0+IHtcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICBub2RlLml0ZW1zLmZvckVhY2goKG5vZGUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGltaXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGltaXQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IGdldFJhbmdlKGRvY3VtZW50LCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3Rpb25SYW5nZSA9IHJhbmdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBTdHJpbmcoaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN5bWJvbCA9IHsgbmFtZSwga2luZDogdGhpcy5nZXRTeW1ib2xLaW5kKG5vZGUudHlwZSksIHJhbmdlLCBzZWxlY3Rpb25SYW5nZSwgY2hpbGRyZW46IFtdIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3ltYm9sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b1Zpc2l0LnB1c2goeyByZXN1bHQ6IHN5bWJvbC5jaGlsZHJlbiwgbm9kZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbWl0RXhjZWVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLnR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5wcm9wZXJ0aWVzLmZvckVhY2goKHByb3BlcnR5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlTm9kZSA9IHByb3BlcnR5LnZhbHVlTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbWl0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbWl0LS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBnZXRSYW5nZShkb2N1bWVudCwgcHJvcGVydHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvblJhbmdlID0gZ2V0UmFuZ2UoZG9jdW1lbnQsIHByb3BlcnR5LmtleU5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ltYm9sID0geyBuYW1lOiB0aGlzLmdldEtleUxhYmVsKHByb3BlcnR5KSwga2luZDogdGhpcy5nZXRTeW1ib2xLaW5kKHZhbHVlTm9kZS50eXBlKSwgcmFuZ2UsIHNlbGVjdGlvblJhbmdlLCBjaGlsZHJlbiwgZGV0YWlsOiB0aGlzLmdldERldGFpbCh2YWx1ZU5vZGUpIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3ltYm9sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b1Zpc2l0LnB1c2goeyByZXN1bHQ6IGNoaWxkcmVuLCBub2RlOiB2YWx1ZU5vZGUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW1pdEV4Y2VlZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBicmVhdGggZmlyc3QgdHJhdmVyc2FsXG4gICAgICAgIHdoaWxlIChuZXh0VG9WaXNpdCA8IHRvVmlzaXQubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gdG9WaXNpdFtuZXh0VG9WaXNpdCsrXTtcbiAgICAgICAgICAgIGNvbGxlY3RPdXRsaW5lRW50cmllcyhuZXh0Lm5vZGUsIG5leHQucmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGltaXRFeGNlZWRlZCAmJiBjb250ZXh0ICYmIGNvbnRleHQub25SZXN1bHRMaW1pdEV4Y2VlZGVkKSB7XG4gICAgICAgICAgICBjb250ZXh0Lm9uUmVzdWx0TGltaXRFeGNlZWRlZChyZXNvdXJjZVN0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZ2V0U3ltYm9sS2luZChub2RlVHlwZSkge1xuICAgICAgICBzd2l0Y2ggKG5vZGVUeXBlKSB7XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgIHJldHVybiBTeW1ib2xLaW5kLk1vZHVsZTtcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN5bWJvbEtpbmQuU3RyaW5nO1xuICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gU3ltYm9sS2luZC5OdW1iZXI7XG4gICAgICAgICAgICBjYXNlICdhcnJheSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN5bWJvbEtpbmQuQXJyYXk7XG4gICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gU3ltYm9sS2luZC5Cb29sZWFuO1xuICAgICAgICAgICAgZGVmYXVsdDogLy8gJ251bGwnXG4gICAgICAgICAgICAgICAgcmV0dXJuIFN5bWJvbEtpbmQuVmFyaWFibGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0S2V5TGFiZWwocHJvcGVydHkpIHtcbiAgICAgICAgbGV0IG5hbWUgPSBwcm9wZXJ0eS5rZXlOb2RlLnZhbHVlO1xuICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvW1xcbl0vZywgJ+KGtScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lICYmIG5hbWUudHJpbSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYFwiJHtuYW1lfVwiYDtcbiAgICB9XG4gICAgZ2V0RGV0YWlsKG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdib29sZWFuJyB8fCBub2RlLnR5cGUgPT09ICdudW1iZXInIHx8IG5vZGUudHlwZSA9PT0gJ251bGwnIHx8IG5vZGUudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcobm9kZS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID8gdW5kZWZpbmVkIDogJ1tdJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5jaGlsZHJlbi5sZW5ndGggPyB1bmRlZmluZWQgOiAne30nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZpbmREb2N1bWVudENvbG9ycyhkb2N1bWVudCwgZG9jLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjaGVtYVNlcnZpY2UuZ2V0U2NoZW1hRm9yUmVzb3VyY2UoZG9jdW1lbnQudXJpLCBkb2MpLnRoZW4oc2NoZW1hID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgaWYgKHNjaGVtYSkge1xuICAgICAgICAgICAgICAgIGxldCBsaW1pdCA9IGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQucmVzdWx0TGltaXQgPT09ICdudW1iZXInID8gY29udGV4dC5yZXN1bHRMaW1pdCA6IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hpbmdTY2hlbWFzID0gZG9jLmdldE1hdGNoaW5nU2NoZW1hcyhzY2hlbWEuc2NoZW1hKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2aXNpdGVkTm9kZSA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcyBvZiBtYXRjaGluZ1NjaGVtYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzLmludmVydGVkICYmIHMuc2NoZW1hICYmIChzLnNjaGVtYS5mb3JtYXQgPT09ICdjb2xvcicgfHwgcy5zY2hlbWEuZm9ybWF0ID09PSAnY29sb3ItaGV4JykgJiYgcy5ub2RlICYmIHMubm9kZS50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZUlkID0gU3RyaW5nKHMubm9kZS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2aXNpdGVkTm9kZVtub2RlSWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sb3IgPSBjb2xvckZyb21IZXgoanNvblBhcnNlcl9nZXROb2RlVmFsdWUocy5ub2RlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gZ2V0UmFuZ2UoZG9jdW1lbnQsIHMubm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgY29sb3IsIHJhbmdlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpdGVkTm9kZVtub2RlSWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW1pdC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW1pdCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQub25SZXN1bHRMaW1pdEV4Y2VlZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm9uUmVzdWx0TGltaXRFeGNlZWRlZChkb2N1bWVudC51cmkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldENvbG9yUHJlc2VudGF0aW9ucyhkb2N1bWVudCwgZG9jLCBjb2xvciwgcmFuZ2UpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGNvbnN0IHJlZDI1NiA9IE1hdGgucm91bmQoY29sb3IucmVkICogMjU1KSwgZ3JlZW4yNTYgPSBNYXRoLnJvdW5kKGNvbG9yLmdyZWVuICogMjU1KSwgYmx1ZTI1NiA9IE1hdGgucm91bmQoY29sb3IuYmx1ZSAqIDI1NSk7XG4gICAgICAgIGZ1bmN0aW9uIHRvVHdvRGlnaXRIZXgobikge1xuICAgICAgICAgICAgY29uc3QgciA9IG4udG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgcmV0dXJuIHIubGVuZ3RoICE9PSAyID8gJzAnICsgciA6IHI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxhYmVsO1xuICAgICAgICBpZiAoY29sb3IuYWxwaGEgPT09IDEpIHtcbiAgICAgICAgICAgIGxhYmVsID0gYCMke3RvVHdvRGlnaXRIZXgocmVkMjU2KX0ke3RvVHdvRGlnaXRIZXgoZ3JlZW4yNTYpfSR7dG9Ud29EaWdpdEhleChibHVlMjU2KX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGFiZWwgPSBgIyR7dG9Ud29EaWdpdEhleChyZWQyNTYpfSR7dG9Ud29EaWdpdEhleChncmVlbjI1Nil9JHt0b1R3b0RpZ2l0SGV4KGJsdWUyNTYpfSR7dG9Ud29EaWdpdEhleChNYXRoLnJvdW5kKGNvbG9yLmFscGhhICogMjU1KSl9YDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaCh7IGxhYmVsOiBsYWJlbCwgdGV4dEVkaXQ6IFRleHRFZGl0LnJlcGxhY2UocmFuZ2UsIEpTT04uc3RyaW5naWZ5KGxhYmVsKSkgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0UmFuZ2UoZG9jdW1lbnQsIG5vZGUpIHtcbiAgICByZXR1cm4gUmFuZ2UuY3JlYXRlKGRvY3VtZW50LnBvc2l0aW9uQXQobm9kZS5vZmZzZXQpLCBkb2N1bWVudC5wb3NpdGlvbkF0KG5vZGUub2Zmc2V0ICsgbm9kZS5sZW5ndGgpKTtcbn1cbmZ1bmN0aW9uIGdldE5hbWUobm9kZSkge1xuICAgIHJldHVybiBqc29uUGFyc2VyX2dldE5vZGVWYWx1ZShub2RlKSB8fCB0KCc8ZW1wdHk+Jyk7XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL2xpYi9lc20vc2VydmljZXMvY29uZmlndXJhdGlvbi5qc1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbmNvbnN0IHNjaGVtYUNvbnRyaWJ1dGlvbnMgPSB7XG4gICAgc2NoZW1hQXNzb2NpYXRpb25zOiBbXSxcbiAgICBzY2hlbWFzOiB7XG4gICAgICAgIC8vIGJ1bmRsZSB0aGUgc2NoZW1hLXNjaGVtYSB0byBpbmNsdWRlIChsb2NhbGl6ZWQpIGRlc2NyaXB0aW9uc1xuICAgICAgICAnaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjJzoge1xuICAgICAgICAgICAgJyRzY2hlbWEnOiAnaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjJyxcbiAgICAgICAgICAgICdkZWZpbml0aW9ucyc6IHtcbiAgICAgICAgICAgICAgICAnc2NoZW1hQXJyYXknOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ2FycmF5JyxcbiAgICAgICAgICAgICAgICAgICAgJ21pbkl0ZW1zJzogMSxcbiAgICAgICAgICAgICAgICAgICAgJ2l0ZW1zJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIydcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3Bvc2l0aXZlSW50ZWdlcic6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnaW50ZWdlcicsXG4gICAgICAgICAgICAgICAgICAgICdtaW5pbXVtJzogMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3Bvc2l0aXZlSW50ZWdlckRlZmF1bHQwJzoge1xuICAgICAgICAgICAgICAgICAgICAnYWxsT2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9wb3NpdGl2ZUludGVnZXInXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkZWZhdWx0JzogMFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnc2ltcGxlVHlwZXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICdlbnVtJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FycmF5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdib29sZWFuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbnRlZ2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdudWxsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdudW1iZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ29iamVjdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnc3RyaW5nQXJyYXknOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ2FycmF5JyxcbiAgICAgICAgICAgICAgICAgICAgJ2l0ZW1zJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnbWluSXRlbXMnOiAxLFxuICAgICAgICAgICAgICAgICAgICAndW5pcXVlSXRlbXMnOiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICd0eXBlJzogJ29iamVjdCcsXG4gICAgICAgICAgICAncHJvcGVydGllcyc6IHtcbiAgICAgICAgICAgICAgICAnaWQnOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICdmb3JtYXQnOiAndXJpJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJyRzY2hlbWEnOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICdmb3JtYXQnOiAndXJpJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3RpdGxlJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZGVzY3JpcHRpb24nOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ3N0cmluZydcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdkZWZhdWx0Jzoge30sXG4gICAgICAgICAgICAgICAgJ211bHRpcGxlT2YnOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgICAgICAgICAgICAgICAgICdtaW5pbXVtJzogMCxcbiAgICAgICAgICAgICAgICAgICAgJ2V4Y2x1c2l2ZU1pbmltdW0nOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnbWF4aW11bSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2V4Y2x1c2l2ZU1heGltdW0nOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ2Jvb2xlYW4nLFxuICAgICAgICAgICAgICAgICAgICAnZGVmYXVsdCc6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnbWluaW11bSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2V4Y2x1c2l2ZU1pbmltdW0nOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ2Jvb2xlYW4nLFxuICAgICAgICAgICAgICAgICAgICAnZGVmYXVsdCc6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnbWF4TGVuZ3RoJzoge1xuICAgICAgICAgICAgICAgICAgICAnYWxsT2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9wb3NpdGl2ZUludGVnZXInXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdtaW5MZW5ndGgnOiB7XG4gICAgICAgICAgICAgICAgICAgICdhbGxPZic6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJHJlZic6ICcjL2RlZmluaXRpb25zL3Bvc2l0aXZlSW50ZWdlckRlZmF1bHQwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncGF0dGVybic6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgJ2Zvcm1hdCc6ICdyZWdleCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdhZGRpdGlvbmFsSXRlbXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdhbnlPZic6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdib29sZWFuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJHJlZic6ICcjJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAnZGVmYXVsdCc6IHt9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnaXRlbXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdhbnlPZic6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJHJlZic6ICcjJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJHJlZic6ICcjL2RlZmluaXRpb25zL3NjaGVtYUFycmF5J1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAnZGVmYXVsdCc6IHt9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnbWF4SXRlbXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdhbGxPZic6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJHJlZic6ICcjL2RlZmluaXRpb25zL3Bvc2l0aXZlSW50ZWdlcidcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ21pbkl0ZW1zJzoge1xuICAgICAgICAgICAgICAgICAgICAnYWxsT2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9wb3NpdGl2ZUludGVnZXJEZWZhdWx0MCdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3VuaXF1ZUl0ZW1zJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdib29sZWFuJyxcbiAgICAgICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ21heFByb3BlcnRpZXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdhbGxPZic6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJHJlZic6ICcjL2RlZmluaXRpb25zL3Bvc2l0aXZlSW50ZWdlcidcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ21pblByb3BlcnRpZXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdhbGxPZic6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJHJlZic6ICcjL2RlZmluaXRpb25zL3Bvc2l0aXZlSW50ZWdlckRlZmF1bHQwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncmVxdWlyZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgICdhbGxPZic6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJHJlZic6ICcjL2RlZmluaXRpb25zL3N0cmluZ0FycmF5J1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnYWRkaXRpb25hbFByb3BlcnRpZXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdhbnlPZic6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdib29sZWFuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJHJlZic6ICcjJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAnZGVmYXVsdCc6IHt9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZGVmaW5pdGlvbnMnOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ29iamVjdCcsXG4gICAgICAgICAgICAgICAgICAgICdhZGRpdGlvbmFsUHJvcGVydGllcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICckcmVmJzogJyMnXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdkZWZhdWx0Jzoge31cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwcm9wZXJ0aWVzJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdvYmplY3QnLFxuICAgICAgICAgICAgICAgICAgICAnYWRkaXRpb25hbFByb3BlcnRpZXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnJHJlZic6ICcjJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnZGVmYXVsdCc6IHt9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncGF0dGVyblByb3BlcnRpZXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ29iamVjdCcsXG4gICAgICAgICAgICAgICAgICAgICdhZGRpdGlvbmFsUHJvcGVydGllcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICckcmVmJzogJyMnXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdkZWZhdWx0Jzoge31cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdkZXBlbmRlbmNpZXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ29iamVjdCcsXG4gICAgICAgICAgICAgICAgICAgICdhZGRpdGlvbmFsUHJvcGVydGllcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhbnlPZic6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICckcmVmJzogJyMnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICckcmVmJzogJyMvZGVmaW5pdGlvbnMvc3RyaW5nQXJyYXknXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZW51bSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnYXJyYXknLFxuICAgICAgICAgICAgICAgICAgICAnbWluSXRlbXMnOiAxLFxuICAgICAgICAgICAgICAgICAgICAndW5pcXVlSXRlbXMnOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAndHlwZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FueU9mJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICckcmVmJzogJyMvZGVmaW5pdGlvbnMvc2ltcGxlVHlwZXMnXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ2FycmF5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaXRlbXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICckcmVmJzogJyMvZGVmaW5pdGlvbnMvc2ltcGxlVHlwZXMnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbWluSXRlbXMnOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd1bmlxdWVJdGVtcyc6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2Zvcm1hdCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FueU9mJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2VudW0nOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRlLXRpbWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndXJpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2VtYWlsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2hvc3RuYW1lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lwdjQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaXB2NicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdyZWdleCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2FsbE9mJzoge1xuICAgICAgICAgICAgICAgICAgICAnYWxsT2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9zY2hlbWFBcnJheSdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2FueU9mJzoge1xuICAgICAgICAgICAgICAgICAgICAnYWxsT2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9zY2hlbWFBcnJheSdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ29uZU9mJzoge1xuICAgICAgICAgICAgICAgICAgICAnYWxsT2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9zY2hlbWFBcnJheSdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ25vdCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FsbE9mJzogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICckcmVmJzogJyMnXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2RlcGVuZGVuY2llcyc6IHtcbiAgICAgICAgICAgICAgICAnZXhjbHVzaXZlTWF4aW11bSc6IFtcbiAgICAgICAgICAgICAgICAgICAgJ21heGltdW0nXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAnZXhjbHVzaXZlTWluaW11bSc6IFtcbiAgICAgICAgICAgICAgICAgICAgJ21pbmltdW0nXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdkZWZhdWx0Jzoge31cbiAgICAgICAgfSxcbiAgICAgICAgJ2h0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDcvc2NoZW1hIyc6IHtcbiAgICAgICAgICAgICdkZWZpbml0aW9ucyc6IHtcbiAgICAgICAgICAgICAgICAnc2NoZW1hQXJyYXknOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ2FycmF5JyxcbiAgICAgICAgICAgICAgICAgICAgJ21pbkl0ZW1zJzogMSxcbiAgICAgICAgICAgICAgICAgICAgJ2l0ZW1zJzogeyAnJHJlZic6ICcjJyB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnbm9uTmVnYXRpdmVJbnRlZ2VyJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdpbnRlZ2VyJyxcbiAgICAgICAgICAgICAgICAgICAgJ21pbmltdW0nOiAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnbm9uTmVnYXRpdmVJbnRlZ2VyRGVmYXVsdDAnOiB7XG4gICAgICAgICAgICAgICAgICAgICdhbGxPZic6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXInIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7ICdkZWZhdWx0JzogMCB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdzaW1wbGVUeXBlcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2VudW0nOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXJyYXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Jvb2xlYW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ludGVnZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ251bGwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ251bWJlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnb2JqZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdzdHJpbmdBcnJheSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnYXJyYXknLFxuICAgICAgICAgICAgICAgICAgICAnaXRlbXMnOiB7ICd0eXBlJzogJ3N0cmluZycgfSxcbiAgICAgICAgICAgICAgICAgICAgJ3VuaXF1ZUl0ZW1zJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiBbXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAndHlwZSc6IFsnb2JqZWN0JywgJ2Jvb2xlYW4nXSxcbiAgICAgICAgICAgICdwcm9wZXJ0aWVzJzoge1xuICAgICAgICAgICAgICAgICckaWQnOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICdmb3JtYXQnOiAndXJpLXJlZmVyZW5jZSdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICckc2NoZW1hJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAnZm9ybWF0JzogJ3VyaSdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICckcmVmJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAnZm9ybWF0JzogJ3VyaS1yZWZlcmVuY2UnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnJGNvbW1lbnQnOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ3N0cmluZydcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd0aXRsZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2Rlc2NyaXB0aW9uJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZGVmYXVsdCc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ3JlYWRPbmx5Jzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdib29sZWFuJyxcbiAgICAgICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2V4YW1wbGVzJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdhcnJheScsXG4gICAgICAgICAgICAgICAgICAgICdpdGVtcyc6IHRydWVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdtdWx0aXBsZU9mJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICAgICAgICAgICAgICAgICAnZXhjbHVzaXZlTWluaW11bSc6IDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdtYXhpbXVtJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdudW1iZXInXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZXhjbHVzaXZlTWF4aW11bSc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ21pbmltdW0nOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ251bWJlcidcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdleGNsdXNpdmVNaW5pbXVtJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdudW1iZXInXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnbWF4TGVuZ3RoJzogeyAnJHJlZic6ICcjL2RlZmluaXRpb25zL25vbk5lZ2F0aXZlSW50ZWdlcicgfSxcbiAgICAgICAgICAgICAgICAnbWluTGVuZ3RoJzogeyAnJHJlZic6ICcjL2RlZmluaXRpb25zL25vbk5lZ2F0aXZlSW50ZWdlckRlZmF1bHQwJyB9LFxuICAgICAgICAgICAgICAgICdwYXR0ZXJuJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAnZm9ybWF0JzogJ3JlZ2V4J1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2FkZGl0aW9uYWxJdGVtcyc6IHsgJyRyZWYnOiAnIycgfSxcbiAgICAgICAgICAgICAgICAnaXRlbXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICdhbnlPZic6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgJyRyZWYnOiAnIycgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9zY2hlbWFBcnJheScgfVxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAnZGVmYXVsdCc6IHRydWVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdtYXhJdGVtcyc6IHsgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXInIH0sXG4gICAgICAgICAgICAgICAgJ21pbkl0ZW1zJzogeyAnJHJlZic6ICcjL2RlZmluaXRpb25zL25vbk5lZ2F0aXZlSW50ZWdlckRlZmF1bHQwJyB9LFxuICAgICAgICAgICAgICAgICd1bmlxdWVJdGVtcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgICAgICAgICAgICAgICAgICdkZWZhdWx0JzogZmFsc2VcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdjb250YWlucyc6IHsgJyRyZWYnOiAnIycgfSxcbiAgICAgICAgICAgICAgICAnbWF4UHJvcGVydGllcyc6IHsgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXInIH0sXG4gICAgICAgICAgICAgICAgJ21pblByb3BlcnRpZXMnOiB7ICckcmVmJzogJyMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyRGVmYXVsdDAnIH0sXG4gICAgICAgICAgICAgICAgJ3JlcXVpcmVkJzogeyAnJHJlZic6ICcjL2RlZmluaXRpb25zL3N0cmluZ0FycmF5JyB9LFxuICAgICAgICAgICAgICAgICdhZGRpdGlvbmFsUHJvcGVydGllcyc6IHsgJyRyZWYnOiAnIycgfSxcbiAgICAgICAgICAgICAgICAnZGVmaW5pdGlvbnMnOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ29iamVjdCcsXG4gICAgICAgICAgICAgICAgICAgICdhZGRpdGlvbmFsUHJvcGVydGllcyc6IHsgJyRyZWYnOiAnIycgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiB7fVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3Byb3BlcnRpZXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICd0eXBlJzogJ29iamVjdCcsXG4gICAgICAgICAgICAgICAgICAgICdhZGRpdGlvbmFsUHJvcGVydGllcyc6IHsgJyRyZWYnOiAnIycgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2RlZmF1bHQnOiB7fVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3BhdHRlcm5Qcm9wZXJ0aWVzJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdvYmplY3QnLFxuICAgICAgICAgICAgICAgICAgICAnYWRkaXRpb25hbFByb3BlcnRpZXMnOiB7ICckcmVmJzogJyMnIH0sXG4gICAgICAgICAgICAgICAgICAgICdwcm9wZXJ0eU5hbWVzJzogeyAnZm9ybWF0JzogJ3JlZ2V4JyB9LFxuICAgICAgICAgICAgICAgICAgICAnZGVmYXVsdCc6IHt9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZGVwZW5kZW5jaWVzJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdvYmplY3QnLFxuICAgICAgICAgICAgICAgICAgICAnYWRkaXRpb25hbFByb3BlcnRpZXMnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnYW55T2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyAnJHJlZic6ICcjJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9zdHJpbmdBcnJheScgfVxuICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAncHJvcGVydHlOYW1lcyc6IHsgJyRyZWYnOiAnIycgfSxcbiAgICAgICAgICAgICAgICAnY29uc3QnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdlbnVtJzoge1xuICAgICAgICAgICAgICAgICAgICAndHlwZSc6ICdhcnJheScsXG4gICAgICAgICAgICAgICAgICAgICdpdGVtcyc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICdtaW5JdGVtcyc6IDEsXG4gICAgICAgICAgICAgICAgICAgICd1bmlxdWVJdGVtcyc6IHRydWVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICd0eXBlJzoge1xuICAgICAgICAgICAgICAgICAgICAnYW55T2YnOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7ICckcmVmJzogJyMvZGVmaW5pdGlvbnMvc2ltcGxlVHlwZXMnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3R5cGUnOiAnYXJyYXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpdGVtcyc6IHsgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9zaW1wbGVUeXBlcycgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbWluSXRlbXMnOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd1bmlxdWVJdGVtcyc6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ2Zvcm1hdCc6IHsgJ3R5cGUnOiAnc3RyaW5nJyB9LFxuICAgICAgICAgICAgICAgICdjb250ZW50TWVkaWFUeXBlJzogeyAndHlwZSc6ICdzdHJpbmcnIH0sXG4gICAgICAgICAgICAgICAgJ2NvbnRlbnRFbmNvZGluZyc6IHsgJ3R5cGUnOiAnc3RyaW5nJyB9LFxuICAgICAgICAgICAgICAgICdpZic6IHsgJyRyZWYnOiAnIycgfSxcbiAgICAgICAgICAgICAgICAndGhlbic6IHsgJyRyZWYnOiAnIycgfSxcbiAgICAgICAgICAgICAgICAnZWxzZSc6IHsgJyRyZWYnOiAnIycgfSxcbiAgICAgICAgICAgICAgICAnYWxsT2YnOiB7ICckcmVmJzogJyMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXknIH0sXG4gICAgICAgICAgICAgICAgJ2FueU9mJzogeyAnJHJlZic6ICcjL2RlZmluaXRpb25zL3NjaGVtYUFycmF5JyB9LFxuICAgICAgICAgICAgICAgICdvbmVPZic6IHsgJyRyZWYnOiAnIy9kZWZpbml0aW9ucy9zY2hlbWFBcnJheScgfSxcbiAgICAgICAgICAgICAgICAnbm90JzogeyAnJHJlZic6ICcjJyB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2RlZmF1bHQnOiB0cnVlXG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgZGVzY3JpcHRpb25zID0ge1xuICAgIGlkOiB0KFwiQSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHNjaGVtYS5cIiksXG4gICAgJHNjaGVtYTogdChcIlRoZSBzY2hlbWEgdG8gdmVyaWZ5IHRoaXMgZG9jdW1lbnQgYWdhaW5zdC5cIiksXG4gICAgdGl0bGU6IHQoXCJBIGRlc2NyaXB0aXZlIHRpdGxlIG9mIHRoZSBlbGVtZW50LlwiKSxcbiAgICBkZXNjcmlwdGlvbjogdChcIkEgbG9uZyBkZXNjcmlwdGlvbiBvZiB0aGUgZWxlbWVudC4gVXNlZCBpbiBob3ZlciBtZW51cyBhbmQgc3VnZ2VzdGlvbnMuXCIpLFxuICAgIGRlZmF1bHQ6IHQoXCJBIGRlZmF1bHQgdmFsdWUuIFVzZWQgYnkgc3VnZ2VzdGlvbnMuXCIpLFxuICAgIG11bHRpcGxlT2Y6IHQoXCJBIG51bWJlciB0aGF0IHNob3VsZCBjbGVhbmx5IGRpdmlkZSB0aGUgY3VycmVudCB2YWx1ZSAoaS5lLiBoYXZlIG5vIHJlbWFpbmRlcikuXCIpLFxuICAgIG1heGltdW06IHQoXCJUaGUgbWF4aW11bSBudW1lcmljYWwgdmFsdWUsIGluY2x1c2l2ZSBieSBkZWZhdWx0LlwiKSxcbiAgICBleGNsdXNpdmVNYXhpbXVtOiB0KFwiTWFrZXMgdGhlIG1heGltdW0gcHJvcGVydHkgZXhjbHVzaXZlLlwiKSxcbiAgICBtaW5pbXVtOiB0KFwiVGhlIG1pbmltdW0gbnVtZXJpY2FsIHZhbHVlLCBpbmNsdXNpdmUgYnkgZGVmYXVsdC5cIiksXG4gICAgZXhjbHVzaXZlTWluaW11bTogdChcIk1ha2VzIHRoZSBtaW5pbXVtIHByb3BlcnR5IGV4Y2x1c2l2ZS5cIiksXG4gICAgbWF4TGVuZ3RoOiB0KFwiVGhlIG1heGltdW0gbGVuZ3RoIG9mIGEgc3RyaW5nLlwiKSxcbiAgICBtaW5MZW5ndGg6IHQoXCJUaGUgbWluaW11bSBsZW5ndGggb2YgYSBzdHJpbmcuXCIpLFxuICAgIHBhdHRlcm46IHQoXCJBIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBtYXRjaCB0aGUgc3RyaW5nIGFnYWluc3QuIEl0IGlzIG5vdCBpbXBsaWNpdGx5IGFuY2hvcmVkLlwiKSxcbiAgICBhZGRpdGlvbmFsSXRlbXM6IHQoXCJGb3IgYXJyYXlzLCBvbmx5IHdoZW4gaXRlbXMgaXMgc2V0IGFzIGFuIGFycmF5LiBJZiBpdCBpcyBhIHNjaGVtYSwgdGhlbiB0aGlzIHNjaGVtYSB2YWxpZGF0ZXMgaXRlbXMgYWZ0ZXIgdGhlIG9uZXMgc3BlY2lmaWVkIGJ5IHRoZSBpdGVtcyBhcnJheS4gSWYgaXQgaXMgZmFsc2UsIHRoZW4gYWRkaXRpb25hbCBpdGVtcyB3aWxsIGNhdXNlIHZhbGlkYXRpb24gdG8gZmFpbC5cIiksXG4gICAgaXRlbXM6IHQoXCJGb3IgYXJyYXlzLiBDYW4gZWl0aGVyIGJlIGEgc2NoZW1hIHRvIHZhbGlkYXRlIGV2ZXJ5IGVsZW1lbnQgYWdhaW5zdCBvciBhbiBhcnJheSBvZiBzY2hlbWFzIHRvIHZhbGlkYXRlIGVhY2ggaXRlbSBhZ2FpbnN0IGluIG9yZGVyICh0aGUgZmlyc3Qgc2NoZW1hIHdpbGwgdmFsaWRhdGUgdGhlIGZpcnN0IGVsZW1lbnQsIHRoZSBzZWNvbmQgc2NoZW1hIHdpbGwgdmFsaWRhdGUgdGhlIHNlY29uZCBlbGVtZW50LCBhbmQgc28gb24uXCIpLFxuICAgIG1heEl0ZW1zOiB0KFwiVGhlIG1heGltdW0gbnVtYmVyIG9mIGl0ZW1zIHRoYXQgY2FuIGJlIGluc2lkZSBhbiBhcnJheS4gSW5jbHVzaXZlLlwiKSxcbiAgICBtaW5JdGVtczogdChcIlRoZSBtaW5pbXVtIG51bWJlciBvZiBpdGVtcyB0aGF0IGNhbiBiZSBpbnNpZGUgYW4gYXJyYXkuIEluY2x1c2l2ZS5cIiksXG4gICAgdW5pcXVlSXRlbXM6IHQoXCJJZiBhbGwgb2YgdGhlIGl0ZW1zIGluIHRoZSBhcnJheSBtdXN0IGJlIHVuaXF1ZS4gRGVmYXVsdHMgdG8gZmFsc2UuXCIpLFxuICAgIG1heFByb3BlcnRpZXM6IHQoXCJUaGUgbWF4aW11bSBudW1iZXIgb2YgcHJvcGVydGllcyBhbiBvYmplY3QgY2FuIGhhdmUuIEluY2x1c2l2ZS5cIiksXG4gICAgbWluUHJvcGVydGllczogdChcIlRoZSBtaW5pbXVtIG51bWJlciBvZiBwcm9wZXJ0aWVzIGFuIG9iamVjdCBjYW4gaGF2ZS4gSW5jbHVzaXZlLlwiKSxcbiAgICByZXF1aXJlZDogdChcIkFuIGFycmF5IG9mIHN0cmluZ3MgdGhhdCBsaXN0cyB0aGUgbmFtZXMgb2YgYWxsIHByb3BlcnRpZXMgcmVxdWlyZWQgb24gdGhpcyBvYmplY3QuXCIpLFxuICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiB0KFwiRWl0aGVyIGEgc2NoZW1hIG9yIGEgYm9vbGVhbi4gSWYgYSBzY2hlbWEsIHRoZW4gdXNlZCB0byB2YWxpZGF0ZSBhbGwgcHJvcGVydGllcyBub3QgbWF0Y2hlZCBieSAncHJvcGVydGllcycgb3IgJ3BhdHRlcm5Qcm9wZXJ0aWVzJy4gSWYgZmFsc2UsIHRoZW4gYW55IHByb3BlcnRpZXMgbm90IG1hdGNoZWQgYnkgZWl0aGVyIHdpbGwgY2F1c2UgdGhpcyBzY2hlbWEgdG8gZmFpbC5cIiksXG4gICAgZGVmaW5pdGlvbnM6IHQoXCJOb3QgdXNlZCBmb3IgdmFsaWRhdGlvbi4gUGxhY2Ugc3Vic2NoZW1hcyBoZXJlIHRoYXQgeW91IHdpc2ggdG8gcmVmZXJlbmNlIGlubGluZSB3aXRoICRyZWYuXCIpLFxuICAgIHByb3BlcnRpZXM6IHQoXCJBIG1hcCBvZiBwcm9wZXJ0eSBuYW1lcyB0byBzY2hlbWFzIGZvciBlYWNoIHByb3BlcnR5LlwiKSxcbiAgICBwYXR0ZXJuUHJvcGVydGllczogdChcIkEgbWFwIG9mIHJlZ3VsYXIgZXhwcmVzc2lvbnMgb24gcHJvcGVydHkgbmFtZXMgdG8gc2NoZW1hcyBmb3IgbWF0Y2hpbmcgcHJvcGVydGllcy5cIiksXG4gICAgZGVwZW5kZW5jaWVzOiB0KFwiQSBtYXAgb2YgcHJvcGVydHkgbmFtZXMgdG8gZWl0aGVyIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIG9yIGEgc2NoZW1hLiBBbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBtZWFucyB0aGUgcHJvcGVydHkgbmFtZWQgaW4gdGhlIGtleSBkZXBlbmRzIG9uIHRoZSBwcm9wZXJ0aWVzIGluIHRoZSBhcnJheSBiZWluZyBwcmVzZW50IGluIHRoZSBvYmplY3QgaW4gb3JkZXIgdG8gYmUgdmFsaWQuIElmIHRoZSB2YWx1ZSBpcyBhIHNjaGVtYSwgdGhlbiB0aGUgc2NoZW1hIGlzIG9ubHkgYXBwbGllZCB0byB0aGUgb2JqZWN0IGlmIHRoZSBwcm9wZXJ0eSBpbiB0aGUga2V5IGV4aXN0cyBvbiB0aGUgb2JqZWN0LlwiKSxcbiAgICBlbnVtOiB0KFwiVGhlIHNldCBvZiBsaXRlcmFsIHZhbHVlcyB0aGF0IGFyZSB2YWxpZC5cIiksXG4gICAgdHlwZTogdChcIkVpdGhlciBhIHN0cmluZyBvZiBvbmUgb2YgdGhlIGJhc2ljIHNjaGVtYSB0eXBlcyAobnVtYmVyLCBpbnRlZ2VyLCBudWxsLCBhcnJheSwgb2JqZWN0LCBib29sZWFuLCBzdHJpbmcpIG9yIGFuIGFycmF5IG9mIHN0cmluZ3Mgc3BlY2lmeWluZyBhIHN1YnNldCBvZiB0aG9zZSB0eXBlcy5cIiksXG4gICAgZm9ybWF0OiB0KFwiRGVzY3JpYmVzIHRoZSBmb3JtYXQgZXhwZWN0ZWQgZm9yIHRoZSB2YWx1ZS5cIiksXG4gICAgYWxsT2Y6IHQoXCJBbiBhcnJheSBvZiBzY2hlbWFzLCBhbGwgb2Ygd2hpY2ggbXVzdCBtYXRjaC5cIiksXG4gICAgYW55T2Y6IHQoXCJBbiBhcnJheSBvZiBzY2hlbWFzLCB3aGVyZSBhdCBsZWFzdCBvbmUgbXVzdCBtYXRjaC5cIiksXG4gICAgb25lT2Y6IHQoXCJBbiBhcnJheSBvZiBzY2hlbWFzLCBleGFjdGx5IG9uZSBvZiB3aGljaCBtdXN0IG1hdGNoLlwiKSxcbiAgICBub3Q6IHQoXCJBIHNjaGVtYSB3aGljaCBtdXN0IG5vdCBtYXRjaC5cIiksXG4gICAgJGlkOiB0KFwiQSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHNjaGVtYS5cIiksXG4gICAgJHJlZjogdChcIlJlZmVyZW5jZSBhIGRlZmluaXRpb24gaG9zdGVkIG9uIGFueSBsb2NhdGlvbi5cIiksXG4gICAgJGNvbW1lbnQ6IHQoXCJDb21tZW50cyBmcm9tIHNjaGVtYSBhdXRob3JzIHRvIHJlYWRlcnMgb3IgbWFpbnRhaW5lcnMgb2YgdGhlIHNjaGVtYS5cIiksXG4gICAgcmVhZE9ubHk6IHQoXCJJbmRpY2F0ZXMgdGhhdCB0aGUgdmFsdWUgb2YgdGhlIGluc3RhbmNlIGlzIG1hbmFnZWQgZXhjbHVzaXZlbHkgYnkgdGhlIG93bmluZyBhdXRob3JpdHkuXCIpLFxuICAgIGV4YW1wbGVzOiB0KFwiU2FtcGxlIEpTT04gdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCBhIHBhcnRpY3VsYXIgc2NoZW1hLCBmb3IgdGhlIHB1cnBvc2Ugb2YgaWxsdXN0cmF0aW5nIHVzYWdlLlwiKSxcbiAgICBjb250YWluczogdChcIkFuIGFycmF5IGluc3RhbmNlIGlzIHZhbGlkIGFnYWluc3QgXFxcImNvbnRhaW5zXFxcIiBpZiBhdCBsZWFzdCBvbmUgb2YgaXRzIGVsZW1lbnRzIGlzIHZhbGlkIGFnYWluc3QgdGhlIGdpdmVuIHNjaGVtYS5cIiksXG4gICAgcHJvcGVydHlOYW1lczogdChcIklmIHRoZSBpbnN0YW5jZSBpcyBhbiBvYmplY3QsIHRoaXMga2V5d29yZCB2YWxpZGF0ZXMgaWYgZXZlcnkgcHJvcGVydHkgbmFtZSBpbiB0aGUgaW5zdGFuY2UgdmFsaWRhdGVzIGFnYWluc3QgdGhlIHByb3ZpZGVkIHNjaGVtYS5cIiksXG4gICAgY29uc3Q6IHQoXCJBbiBpbnN0YW5jZSB2YWxpZGF0ZXMgc3VjY2Vzc2Z1bGx5IGFnYWluc3QgdGhpcyBrZXl3b3JkIGlmIGl0cyB2YWx1ZSBpcyBlcXVhbCB0byB0aGUgdmFsdWUgb2YgdGhlIGtleXdvcmQuXCIpLFxuICAgIGNvbnRlbnRNZWRpYVR5cGU6IHQoXCJEZXNjcmliZXMgdGhlIG1lZGlhIHR5cGUgb2YgYSBzdHJpbmcgcHJvcGVydHkuXCIpLFxuICAgIGNvbnRlbnRFbmNvZGluZzogdChcIkRlc2NyaWJlcyB0aGUgY29udGVudCBlbmNvZGluZyBvZiBhIHN0cmluZyBwcm9wZXJ0eS5cIiksXG4gICAgaWY6IHQoXCJUaGUgdmFsaWRhdGlvbiBvdXRjb21lIG9mIHRoZSBcXFwiaWZcXFwiIHN1YnNjaGVtYSBjb250cm9scyB3aGljaCBvZiB0aGUgXFxcInRoZW5cXFwiIG9yIFxcXCJlbHNlXFxcIiBrZXl3b3JkcyBhcmUgZXZhbHVhdGVkLlwiKSxcbiAgICB0aGVuOiB0KFwiVGhlIFxcXCJpZlxcXCIgc3Vic2NoZW1hIGlzIHVzZWQgZm9yIHZhbGlkYXRpb24gd2hlbiB0aGUgXFxcImlmXFxcIiBzdWJzY2hlbWEgc3VjY2VlZHMuXCIpLFxuICAgIGVsc2U6IHQoXCJUaGUgXFxcImVsc2VcXFwiIHN1YnNjaGVtYSBpcyB1c2VkIGZvciB2YWxpZGF0aW9uIHdoZW4gdGhlIFxcXCJpZlxcXCIgc3Vic2NoZW1hIGZhaWxzLlwiKVxufTtcbmZvciAoY29uc3Qgc2NoZW1hTmFtZSBpbiBzY2hlbWFDb250cmlidXRpb25zLnNjaGVtYXMpIHtcbiAgICBjb25zdCBzY2hlbWEgPSBzY2hlbWFDb250cmlidXRpb25zLnNjaGVtYXNbc2NoZW1hTmFtZV07XG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBzY2hlbWEucHJvcGVydGllcykge1xuICAgICAgICBsZXQgcHJvcGVydHlPYmplY3QgPSBzY2hlbWEucHJvcGVydGllc1twcm9wZXJ0eV07XG4gICAgICAgIGlmICh0eXBlb2YgcHJvcGVydHlPYmplY3QgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcHJvcGVydHlPYmplY3QgPSBzY2hlbWEucHJvcGVydGllc1twcm9wZXJ0eV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uc1twcm9wZXJ0eV07XG4gICAgICAgIGlmIChkZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgcHJvcGVydHlPYmplY3RbJ2Rlc2NyaXB0aW9uJ10gPSBkZXNjcmlwdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy92c2NvZGUtdXJpL2xpYi9lc20vaW5kZXgubWpzXG4vKiBwcm92aWRlZCBkZXBlbmRlbmN5ICovIHZhciBwcm9jZXNzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5OTA3KTtcbnZhciBMSUI7KCgpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIHQ9ezQ3MDp0PT57ZnVuY3Rpb24gZSh0KXtpZihcInN0cmluZ1wiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGF0aCBtdXN0IGJlIGEgc3RyaW5nLiBSZWNlaXZlZCBcIitKU09OLnN0cmluZ2lmeSh0KSl9ZnVuY3Rpb24gcih0LGUpe2Zvcih2YXIgcixuPVwiXCIsaT0wLG89LTEscz0wLGg9MDtoPD10Lmxlbmd0aDsrK2gpe2lmKGg8dC5sZW5ndGgpcj10LmNoYXJDb2RlQXQoaCk7ZWxzZXtpZig0Nz09PXIpYnJlYWs7cj00N31pZig0Nz09PXIpe2lmKG89PT1oLTF8fDE9PT1zKTtlbHNlIGlmKG8hPT1oLTEmJjI9PT1zKXtpZihuLmxlbmd0aDwyfHwyIT09aXx8NDYhPT1uLmNoYXJDb2RlQXQobi5sZW5ndGgtMSl8fDQ2IT09bi5jaGFyQ29kZUF0KG4ubGVuZ3RoLTIpKWlmKG4ubGVuZ3RoPjIpe3ZhciBhPW4ubGFzdEluZGV4T2YoXCIvXCIpO2lmKGEhPT1uLmxlbmd0aC0xKXstMT09PWE/KG49XCJcIixpPTApOmk9KG49bi5zbGljZSgwLGEpKS5sZW5ndGgtMS1uLmxhc3RJbmRleE9mKFwiL1wiKSxvPWgscz0wO2NvbnRpbnVlfX1lbHNlIGlmKDI9PT1uLmxlbmd0aHx8MT09PW4ubGVuZ3RoKXtuPVwiXCIsaT0wLG89aCxzPTA7Y29udGludWV9ZSYmKG4ubGVuZ3RoPjA/bis9XCIvLi5cIjpuPVwiLi5cIixpPTIpfWVsc2Ugbi5sZW5ndGg+MD9uKz1cIi9cIit0LnNsaWNlKG8rMSxoKTpuPXQuc2xpY2UobysxLGgpLGk9aC1vLTE7bz1oLHM9MH1lbHNlIDQ2PT09ciYmLTEhPT1zPysrczpzPS0xfXJldHVybiBufXZhciBuPXtyZXNvbHZlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0LG49XCJcIixpPSExLG89YXJndW1lbnRzLmxlbmd0aC0xO28+PS0xJiYhaTtvLS0pe3ZhciBzO28+PTA/cz1hcmd1bWVudHNbb106KHZvaWQgMD09PXQmJih0PXByb2Nlc3MuY3dkKCkpLHM9dCksZShzKSwwIT09cy5sZW5ndGgmJihuPXMrXCIvXCIrbixpPTQ3PT09cy5jaGFyQ29kZUF0KDApKX1yZXR1cm4gbj1yKG4sIWkpLGk/bi5sZW5ndGg+MD9cIi9cIituOlwiL1wiOm4ubGVuZ3RoPjA/bjpcIi5cIn0sbm9ybWFsaXplOmZ1bmN0aW9uKHQpe2lmKGUodCksMD09PXQubGVuZ3RoKXJldHVyblwiLlwiO3ZhciBuPTQ3PT09dC5jaGFyQ29kZUF0KDApLGk9NDc9PT10LmNoYXJDb2RlQXQodC5sZW5ndGgtMSk7cmV0dXJuIDAhPT0odD1yKHQsIW4pKS5sZW5ndGh8fG58fCh0PVwiLlwiKSx0Lmxlbmd0aD4wJiZpJiYodCs9XCIvXCIpLG4/XCIvXCIrdDp0fSxpc0Fic29sdXRlOmZ1bmN0aW9uKHQpe3JldHVybiBlKHQpLHQubGVuZ3RoPjAmJjQ3PT09dC5jaGFyQ29kZUF0KDApfSxqb2luOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuXCIuXCI7Zm9yKHZhciB0LHI9MDtyPGFyZ3VtZW50cy5sZW5ndGg7KytyKXt2YXIgaT1hcmd1bWVudHNbcl07ZShpKSxpLmxlbmd0aD4wJiYodm9pZCAwPT09dD90PWk6dCs9XCIvXCIraSl9cmV0dXJuIHZvaWQgMD09PXQ/XCIuXCI6bi5ub3JtYWxpemUodCl9LHJlbGF0aXZlOmZ1bmN0aW9uKHQscil7aWYoZSh0KSxlKHIpLHQ9PT1yKXJldHVyblwiXCI7aWYoKHQ9bi5yZXNvbHZlKHQpKT09PShyPW4ucmVzb2x2ZShyKSkpcmV0dXJuXCJcIjtmb3IodmFyIGk9MTtpPHQubGVuZ3RoJiY0Nz09PXQuY2hhckNvZGVBdChpKTsrK2kpO2Zvcih2YXIgbz10Lmxlbmd0aCxzPW8taSxoPTE7aDxyLmxlbmd0aCYmNDc9PT1yLmNoYXJDb2RlQXQoaCk7KytoKTtmb3IodmFyIGE9ci5sZW5ndGgtaCxjPXM8YT9zOmEsZj0tMSx1PTA7dTw9YzsrK3Upe2lmKHU9PT1jKXtpZihhPmMpe2lmKDQ3PT09ci5jaGFyQ29kZUF0KGgrdSkpcmV0dXJuIHIuc2xpY2UoaCt1KzEpO2lmKDA9PT11KXJldHVybiByLnNsaWNlKGgrdSl9ZWxzZSBzPmMmJig0Nz09PXQuY2hhckNvZGVBdChpK3UpP2Y9dTowPT09dSYmKGY9MCkpO2JyZWFrfXZhciBsPXQuY2hhckNvZGVBdChpK3UpO2lmKGwhPT1yLmNoYXJDb2RlQXQoaCt1KSlicmVhazs0Nz09PWwmJihmPXUpfXZhciBnPVwiXCI7Zm9yKHU9aStmKzE7dTw9bzsrK3UpdSE9PW8mJjQ3IT09dC5jaGFyQ29kZUF0KHUpfHwoMD09PWcubGVuZ3RoP2crPVwiLi5cIjpnKz1cIi8uLlwiKTtyZXR1cm4gZy5sZW5ndGg+MD9nK3Iuc2xpY2UoaCtmKTooaCs9Ziw0Nz09PXIuY2hhckNvZGVBdChoKSYmKytoLHIuc2xpY2UoaCkpfSxfbWFrZUxvbmc6ZnVuY3Rpb24odCl7cmV0dXJuIHR9LGRpcm5hbWU6ZnVuY3Rpb24odCl7aWYoZSh0KSwwPT09dC5sZW5ndGgpcmV0dXJuXCIuXCI7Zm9yKHZhciByPXQuY2hhckNvZGVBdCgwKSxuPTQ3PT09cixpPS0xLG89ITAscz10Lmxlbmd0aC0xO3M+PTE7LS1zKWlmKDQ3PT09KHI9dC5jaGFyQ29kZUF0KHMpKSl7aWYoIW8pe2k9czticmVha319ZWxzZSBvPSExO3JldHVybi0xPT09aT9uP1wiL1wiOlwiLlwiOm4mJjE9PT1pP1wiLy9cIjp0LnNsaWNlKDAsaSl9LGJhc2VuYW1lOmZ1bmN0aW9uKHQscil7aWYodm9pZCAwIT09ciYmXCJzdHJpbmdcIiE9dHlwZW9mIHIpdGhyb3cgbmV3IFR5cGVFcnJvcignXCJleHRcIiBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJyk7ZSh0KTt2YXIgbixpPTAsbz0tMSxzPSEwO2lmKHZvaWQgMCE9PXImJnIubGVuZ3RoPjAmJnIubGVuZ3RoPD10Lmxlbmd0aCl7aWYoci5sZW5ndGg9PT10Lmxlbmd0aCYmcj09PXQpcmV0dXJuXCJcIjt2YXIgaD1yLmxlbmd0aC0xLGE9LTE7Zm9yKG49dC5sZW5ndGgtMTtuPj0wOy0tbil7dmFyIGM9dC5jaGFyQ29kZUF0KG4pO2lmKDQ3PT09Yyl7aWYoIXMpe2k9bisxO2JyZWFrfX1lbHNlLTE9PT1hJiYocz0hMSxhPW4rMSksaD49MCYmKGM9PT1yLmNoYXJDb2RlQXQoaCk/LTE9PS0taCYmKG89bik6KGg9LTEsbz1hKSl9cmV0dXJuIGk9PT1vP289YTotMT09PW8mJihvPXQubGVuZ3RoKSx0LnNsaWNlKGksbyl9Zm9yKG49dC5sZW5ndGgtMTtuPj0wOy0tbilpZig0Nz09PXQuY2hhckNvZGVBdChuKSl7aWYoIXMpe2k9bisxO2JyZWFrfX1lbHNlLTE9PT1vJiYocz0hMSxvPW4rMSk7cmV0dXJuLTE9PT1vP1wiXCI6dC5zbGljZShpLG8pfSxleHRuYW1lOmZ1bmN0aW9uKHQpe2UodCk7Zm9yKHZhciByPS0xLG49MCxpPS0xLG89ITAscz0wLGg9dC5sZW5ndGgtMTtoPj0wOy0taCl7dmFyIGE9dC5jaGFyQ29kZUF0KGgpO2lmKDQ3IT09YSktMT09PWkmJihvPSExLGk9aCsxKSw0Nj09PWE/LTE9PT1yP3I9aDoxIT09cyYmKHM9MSk6LTEhPT1yJiYocz0tMSk7ZWxzZSBpZighbyl7bj1oKzE7YnJlYWt9fXJldHVybi0xPT09cnx8LTE9PT1pfHwwPT09c3x8MT09PXMmJnI9PT1pLTEmJnI9PT1uKzE/XCJcIjp0LnNsaWNlKHIsaSl9LGZvcm1hdDpmdW5jdGlvbih0KXtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwicGF0aE9iamVjdFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyt0eXBlb2YgdCk7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7dmFyIHI9ZS5kaXJ8fGUucm9vdCxuPWUuYmFzZXx8KGUubmFtZXx8XCJcIikrKGUuZXh0fHxcIlwiKTtyZXR1cm4gcj9yPT09ZS5yb290P3IrbjpyK1wiL1wiK246bn0oMCx0KX0scGFyc2U6ZnVuY3Rpb24odCl7ZSh0KTt2YXIgcj17cm9vdDpcIlwiLGRpcjpcIlwiLGJhc2U6XCJcIixleHQ6XCJcIixuYW1lOlwiXCJ9O2lmKDA9PT10Lmxlbmd0aClyZXR1cm4gcjt2YXIgbixpPXQuY2hhckNvZGVBdCgwKSxvPTQ3PT09aTtvPyhyLnJvb3Q9XCIvXCIsbj0xKTpuPTA7Zm9yKHZhciBzPS0xLGg9MCxhPS0xLGM9ITAsZj10Lmxlbmd0aC0xLHU9MDtmPj1uOy0tZilpZig0NyE9PShpPXQuY2hhckNvZGVBdChmKSkpLTE9PT1hJiYoYz0hMSxhPWYrMSksNDY9PT1pPy0xPT09cz9zPWY6MSE9PXUmJih1PTEpOi0xIT09cyYmKHU9LTEpO2Vsc2UgaWYoIWMpe2g9ZisxO2JyZWFrfXJldHVybi0xPT09c3x8LTE9PT1hfHwwPT09dXx8MT09PXUmJnM9PT1hLTEmJnM9PT1oKzE/LTEhPT1hJiYoci5iYXNlPXIubmFtZT0wPT09aCYmbz90LnNsaWNlKDEsYSk6dC5zbGljZShoLGEpKTooMD09PWgmJm8/KHIubmFtZT10LnNsaWNlKDEscyksci5iYXNlPXQuc2xpY2UoMSxhKSk6KHIubmFtZT10LnNsaWNlKGgscyksci5iYXNlPXQuc2xpY2UoaCxhKSksci5leHQ9dC5zbGljZShzLGEpKSxoPjA/ci5kaXI9dC5zbGljZSgwLGgtMSk6byYmKHIuZGlyPVwiL1wiKSxyfSxzZXA6XCIvXCIsZGVsaW1pdGVyOlwiOlwiLHdpbjMyOm51bGwscG9zaXg6bnVsbH07bi5wb3NpeD1uLHQuZXhwb3J0cz1ufX0sZT17fTtmdW5jdGlvbiByKG4pe3ZhciBpPWVbbl07aWYodm9pZCAwIT09aSlyZXR1cm4gaS5leHBvcnRzO3ZhciBvPWVbbl09e2V4cG9ydHM6e319O3JldHVybiB0W25dKG8sby5leHBvcnRzLHIpLG8uZXhwb3J0c31yLmQ9KHQsZSk9Pntmb3IodmFyIG4gaW4gZSlyLm8oZSxuKSYmIXIubyh0LG4pJiZPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLHtlbnVtZXJhYmxlOiEwLGdldDplW25dfSl9LHIubz0odCxlKT0+T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsZSksci5yPXQ9PntcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfTt2YXIgbj17fTsoKCk9PntsZXQgdDtpZihyLnIobiksci5kKG4se1VSSTooKT0+ZixVdGlsczooKT0+UH0pLFwib2JqZWN0XCI9PXR5cGVvZiBwcm9jZXNzKXQ9XCJ3aW4zMlwiPT09cHJvY2Vzcy5wbGF0Zm9ybTtlbHNlIGlmKFwib2JqZWN0XCI9PXR5cGVvZiBuYXZpZ2F0b3Ipe2xldCBlPW5hdmlnYXRvci51c2VyQWdlbnQ7dD1lLmluZGV4T2YoXCJXaW5kb3dzXCIpPj0wfWNvbnN0IGU9L15cXHdbXFx3XFxkKy4tXSokLyxpPS9eXFwvLyxvPS9eXFwvXFwvLztmdW5jdGlvbiBzKHQscil7aWYoIXQuc2NoZW1lJiZyKXRocm93IG5ldyBFcnJvcihgW1VyaUVycm9yXTogU2NoZW1lIGlzIG1pc3Npbmc6IHtzY2hlbWU6IFwiXCIsIGF1dGhvcml0eTogXCIke3QuYXV0aG9yaXR5fVwiLCBwYXRoOiBcIiR7dC5wYXRofVwiLCBxdWVyeTogXCIke3QucXVlcnl9XCIsIGZyYWdtZW50OiBcIiR7dC5mcmFnbWVudH1cIn1gKTtpZih0LnNjaGVtZSYmIWUudGVzdCh0LnNjaGVtZSkpdGhyb3cgbmV3IEVycm9yKFwiW1VyaUVycm9yXTogU2NoZW1lIGNvbnRhaW5zIGlsbGVnYWwgY2hhcmFjdGVycy5cIik7aWYodC5wYXRoKWlmKHQuYXV0aG9yaXR5KXtpZighaS50ZXN0KHQucGF0aCkpdGhyb3cgbmV3IEVycm9yKCdbVXJpRXJyb3JdOiBJZiBhIFVSSSBjb250YWlucyBhbiBhdXRob3JpdHkgY29tcG9uZW50LCB0aGVuIHRoZSBwYXRoIGNvbXBvbmVudCBtdXN0IGVpdGhlciBiZSBlbXB0eSBvciBiZWdpbiB3aXRoIGEgc2xhc2ggKFwiL1wiKSBjaGFyYWN0ZXInKX1lbHNlIGlmKG8udGVzdCh0LnBhdGgpKXRocm93IG5ldyBFcnJvcignW1VyaUVycm9yXTogSWYgYSBVUkkgZG9lcyBub3QgY29udGFpbiBhbiBhdXRob3JpdHkgY29tcG9uZW50LCB0aGVuIHRoZSBwYXRoIGNhbm5vdCBiZWdpbiB3aXRoIHR3byBzbGFzaCBjaGFyYWN0ZXJzIChcIi8vXCIpJyl9Y29uc3QgaD1cIlwiLGE9XCIvXCIsYz0vXigoW146Lz8jXSs/KTopPyhcXC9cXC8oW14vPyNdKikpPyhbXj8jXSopKFxcPyhbXiNdKikpPygjKC4qKSk/LztjbGFzcyBme3N0YXRpYyBpc1VyaSh0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIGZ8fCEhdCYmXCJzdHJpbmdcIj09dHlwZW9mIHQuYXV0aG9yaXR5JiZcInN0cmluZ1wiPT10eXBlb2YgdC5mcmFnbWVudCYmXCJzdHJpbmdcIj09dHlwZW9mIHQucGF0aCYmXCJzdHJpbmdcIj09dHlwZW9mIHQucXVlcnkmJlwic3RyaW5nXCI9PXR5cGVvZiB0LnNjaGVtZSYmXCJzdHJpbmdcIj09dHlwZW9mIHQuZnNQYXRoJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LndpdGgmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQudG9TdHJpbmd9c2NoZW1lO2F1dGhvcml0eTtwYXRoO3F1ZXJ5O2ZyYWdtZW50O2NvbnN0cnVjdG9yKHQsZSxyLG4saSxvPSExKXtcIm9iamVjdFwiPT10eXBlb2YgdD8odGhpcy5zY2hlbWU9dC5zY2hlbWV8fGgsdGhpcy5hdXRob3JpdHk9dC5hdXRob3JpdHl8fGgsdGhpcy5wYXRoPXQucGF0aHx8aCx0aGlzLnF1ZXJ5PXQucXVlcnl8fGgsdGhpcy5mcmFnbWVudD10LmZyYWdtZW50fHxoKToodGhpcy5zY2hlbWU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdHx8ZT90OlwiZmlsZVwifSh0LG8pLHRoaXMuYXV0aG9yaXR5PWV8fGgsdGhpcy5wYXRoPWZ1bmN0aW9uKHQsZSl7c3dpdGNoKHQpe2Nhc2VcImh0dHBzXCI6Y2FzZVwiaHR0cFwiOmNhc2VcImZpbGVcIjplP2VbMF0hPT1hJiYoZT1hK2UpOmU9YX1yZXR1cm4gZX0odGhpcy5zY2hlbWUscnx8aCksdGhpcy5xdWVyeT1ufHxoLHRoaXMuZnJhZ21lbnQ9aXx8aCxzKHRoaXMsbykpfWdldCBmc1BhdGgoKXtyZXR1cm4gbSh0aGlzLCExKX13aXRoKHQpe2lmKCF0KXJldHVybiB0aGlzO2xldHtzY2hlbWU6ZSxhdXRob3JpdHk6cixwYXRoOm4scXVlcnk6aSxmcmFnbWVudDpvfT10O3JldHVybiB2b2lkIDA9PT1lP2U9dGhpcy5zY2hlbWU6bnVsbD09PWUmJihlPWgpLHZvaWQgMD09PXI/cj10aGlzLmF1dGhvcml0eTpudWxsPT09ciYmKHI9aCksdm9pZCAwPT09bj9uPXRoaXMucGF0aDpudWxsPT09biYmKG49aCksdm9pZCAwPT09aT9pPXRoaXMucXVlcnk6bnVsbD09PWkmJihpPWgpLHZvaWQgMD09PW8/bz10aGlzLmZyYWdtZW50Om51bGw9PT1vJiYobz1oKSxlPT09dGhpcy5zY2hlbWUmJnI9PT10aGlzLmF1dGhvcml0eSYmbj09PXRoaXMucGF0aCYmaT09PXRoaXMucXVlcnkmJm89PT10aGlzLmZyYWdtZW50P3RoaXM6bmV3IGwoZSxyLG4saSxvKX1zdGF0aWMgcGFyc2UodCxlPSExKXtjb25zdCByPWMuZXhlYyh0KTtyZXR1cm4gcj9uZXcgbChyWzJdfHxoLEMocls0XXx8aCksQyhyWzVdfHxoKSxDKHJbN118fGgpLEMocls5XXx8aCksZSk6bmV3IGwoaCxoLGgsaCxoKX1zdGF0aWMgZmlsZShlKXtsZXQgcj1oO2lmKHQmJihlPWUucmVwbGFjZSgvXFxcXC9nLGEpKSxlWzBdPT09YSYmZVsxXT09PWEpe2NvbnN0IHQ9ZS5pbmRleE9mKGEsMik7LTE9PT10PyhyPWUuc3Vic3RyaW5nKDIpLGU9YSk6KHI9ZS5zdWJzdHJpbmcoMix0KSxlPWUuc3Vic3RyaW5nKHQpfHxhKX1yZXR1cm4gbmV3IGwoXCJmaWxlXCIscixlLGgsaCl9c3RhdGljIGZyb20odCl7Y29uc3QgZT1uZXcgbCh0LnNjaGVtZSx0LmF1dGhvcml0eSx0LnBhdGgsdC5xdWVyeSx0LmZyYWdtZW50KTtyZXR1cm4gcyhlLCEwKSxlfXRvU3RyaW5nKHQ9ITEpe3JldHVybiB5KHRoaXMsdCl9dG9KU09OKCl7cmV0dXJuIHRoaXN9c3RhdGljIHJldml2ZSh0KXtpZih0KXtpZih0IGluc3RhbmNlb2YgZilyZXR1cm4gdDt7Y29uc3QgZT1uZXcgbCh0KTtyZXR1cm4gZS5fZm9ybWF0dGVkPXQuZXh0ZXJuYWwsZS5fZnNQYXRoPXQuX3NlcD09PXU/dC5mc1BhdGg6bnVsbCxlfX1yZXR1cm4gdH19Y29uc3QgdT10PzE6dm9pZCAwO2NsYXNzIGwgZXh0ZW5kcyBme19mb3JtYXR0ZWQ9bnVsbDtfZnNQYXRoPW51bGw7Z2V0IGZzUGF0aCgpe3JldHVybiB0aGlzLl9mc1BhdGh8fCh0aGlzLl9mc1BhdGg9bSh0aGlzLCExKSksdGhpcy5fZnNQYXRofXRvU3RyaW5nKHQ9ITEpe3JldHVybiB0P3kodGhpcywhMCk6KHRoaXMuX2Zvcm1hdHRlZHx8KHRoaXMuX2Zvcm1hdHRlZD15KHRoaXMsITEpKSx0aGlzLl9mb3JtYXR0ZWQpfXRvSlNPTigpe2NvbnN0IHQ9eyRtaWQ6MX07cmV0dXJuIHRoaXMuX2ZzUGF0aCYmKHQuZnNQYXRoPXRoaXMuX2ZzUGF0aCx0Ll9zZXA9dSksdGhpcy5fZm9ybWF0dGVkJiYodC5leHRlcm5hbD10aGlzLl9mb3JtYXR0ZWQpLHRoaXMucGF0aCYmKHQucGF0aD10aGlzLnBhdGgpLHRoaXMuc2NoZW1lJiYodC5zY2hlbWU9dGhpcy5zY2hlbWUpLHRoaXMuYXV0aG9yaXR5JiYodC5hdXRob3JpdHk9dGhpcy5hdXRob3JpdHkpLHRoaXMucXVlcnkmJih0LnF1ZXJ5PXRoaXMucXVlcnkpLHRoaXMuZnJhZ21lbnQmJih0LmZyYWdtZW50PXRoaXMuZnJhZ21lbnQpLHR9fWNvbnN0IGc9ezU4OlwiJTNBXCIsNDc6XCIlMkZcIiw2MzpcIiUzRlwiLDM1OlwiJTIzXCIsOTE6XCIlNUJcIiw5MzpcIiU1RFwiLDY0OlwiJTQwXCIsMzM6XCIlMjFcIiwzNjpcIiUyNFwiLDM4OlwiJTI2XCIsMzk6XCIlMjdcIiw0MDpcIiUyOFwiLDQxOlwiJTI5XCIsNDI6XCIlMkFcIiw0MzpcIiUyQlwiLDQ0OlwiJTJDXCIsNTk6XCIlM0JcIiw2MTpcIiUzRFwiLDMyOlwiJTIwXCJ9O2Z1bmN0aW9uIGQodCxlLHIpe2xldCBuLGk9LTE7Zm9yKGxldCBvPTA7bzx0Lmxlbmd0aDtvKyspe2NvbnN0IHM9dC5jaGFyQ29kZUF0KG8pO2lmKHM+PTk3JiZzPD0xMjJ8fHM+PTY1JiZzPD05MHx8cz49NDgmJnM8PTU3fHw0NT09PXN8fDQ2PT09c3x8OTU9PT1zfHwxMjY9PT1zfHxlJiY0Nz09PXN8fHImJjkxPT09c3x8ciYmOTM9PT1zfHxyJiY1OD09PXMpLTEhPT1pJiYobis9ZW5jb2RlVVJJQ29tcG9uZW50KHQuc3Vic3RyaW5nKGksbykpLGk9LTEpLHZvaWQgMCE9PW4mJihuKz10LmNoYXJBdChvKSk7ZWxzZXt2b2lkIDA9PT1uJiYobj10LnN1YnN0cigwLG8pKTtjb25zdCBlPWdbc107dm9pZCAwIT09ZT8oLTEhPT1pJiYobis9ZW5jb2RlVVJJQ29tcG9uZW50KHQuc3Vic3RyaW5nKGksbykpLGk9LTEpLG4rPWUpOi0xPT09aSYmKGk9byl9fXJldHVybi0xIT09aSYmKG4rPWVuY29kZVVSSUNvbXBvbmVudCh0LnN1YnN0cmluZyhpKSkpLHZvaWQgMCE9PW4/bjp0fWZ1bmN0aW9uIHAodCl7bGV0IGU7Zm9yKGxldCByPTA7cjx0Lmxlbmd0aDtyKyspe2NvbnN0IG49dC5jaGFyQ29kZUF0KHIpOzM1PT09bnx8NjM9PT1uPyh2b2lkIDA9PT1lJiYoZT10LnN1YnN0cigwLHIpKSxlKz1nW25dKTp2b2lkIDAhPT1lJiYoZSs9dFtyXSl9cmV0dXJuIHZvaWQgMCE9PWU/ZTp0fWZ1bmN0aW9uIG0oZSxyKXtsZXQgbjtyZXR1cm4gbj1lLmF1dGhvcml0eSYmZS5wYXRoLmxlbmd0aD4xJiZcImZpbGVcIj09PWUuc2NoZW1lP2AvLyR7ZS5hdXRob3JpdHl9JHtlLnBhdGh9YDo0Nz09PWUucGF0aC5jaGFyQ29kZUF0KDApJiYoZS5wYXRoLmNoYXJDb2RlQXQoMSk+PTY1JiZlLnBhdGguY2hhckNvZGVBdCgxKTw9OTB8fGUucGF0aC5jaGFyQ29kZUF0KDEpPj05NyYmZS5wYXRoLmNoYXJDb2RlQXQoMSk8PTEyMikmJjU4PT09ZS5wYXRoLmNoYXJDb2RlQXQoMik/cj9lLnBhdGguc3Vic3RyKDEpOmUucGF0aFsxXS50b0xvd2VyQ2FzZSgpK2UucGF0aC5zdWJzdHIoMik6ZS5wYXRoLHQmJihuPW4ucmVwbGFjZSgvXFwvL2csXCJcXFxcXCIpKSxufWZ1bmN0aW9uIHkodCxlKXtjb25zdCByPWU/cDpkO2xldCBuPVwiXCIse3NjaGVtZTppLGF1dGhvcml0eTpvLHBhdGg6cyxxdWVyeTpoLGZyYWdtZW50OmN9PXQ7aWYoaSYmKG4rPWksbis9XCI6XCIpLChvfHxcImZpbGVcIj09PWkpJiYobis9YSxuKz1hKSxvKXtsZXQgdD1vLmluZGV4T2YoXCJAXCIpO2lmKC0xIT09dCl7Y29uc3QgZT1vLnN1YnN0cigwLHQpO289by5zdWJzdHIodCsxKSx0PWUubGFzdEluZGV4T2YoXCI6XCIpLC0xPT09dD9uKz1yKGUsITEsITEpOihuKz1yKGUuc3Vic3RyKDAsdCksITEsITEpLG4rPVwiOlwiLG4rPXIoZS5zdWJzdHIodCsxKSwhMSwhMCkpLG4rPVwiQFwifW89by50b0xvd2VyQ2FzZSgpLHQ9by5sYXN0SW5kZXhPZihcIjpcIiksLTE9PT10P24rPXIobywhMSwhMCk6KG4rPXIoby5zdWJzdHIoMCx0KSwhMSwhMCksbis9by5zdWJzdHIodCkpfWlmKHMpe2lmKHMubGVuZ3RoPj0zJiY0Nz09PXMuY2hhckNvZGVBdCgwKSYmNTg9PT1zLmNoYXJDb2RlQXQoMikpe2NvbnN0IHQ9cy5jaGFyQ29kZUF0KDEpO3Q+PTY1JiZ0PD05MCYmKHM9YC8ke1N0cmluZy5mcm9tQ2hhckNvZGUodCszMil9OiR7cy5zdWJzdHIoMyl9YCl9ZWxzZSBpZihzLmxlbmd0aD49MiYmNTg9PT1zLmNoYXJDb2RlQXQoMSkpe2NvbnN0IHQ9cy5jaGFyQ29kZUF0KDApO3Q+PTY1JiZ0PD05MCYmKHM9YCR7U3RyaW5nLmZyb21DaGFyQ29kZSh0KzMyKX06JHtzLnN1YnN0cigyKX1gKX1uKz1yKHMsITAsITEpfXJldHVybiBoJiYobis9XCI/XCIsbis9cihoLCExLCExKSksYyYmKG4rPVwiI1wiLG4rPWU/YzpkKGMsITEsITEpKSxufWZ1bmN0aW9uIHYodCl7dHJ5e3JldHVybiBkZWNvZGVVUklDb21wb25lbnQodCl9Y2F0Y2h7cmV0dXJuIHQubGVuZ3RoPjM/dC5zdWJzdHIoMCwzKSt2KHQuc3Vic3RyKDMpKTp0fX1jb25zdCBiPS8oJVswLTlBLVphLXpdWzAtOUEtWmEtel0pKy9nO2Z1bmN0aW9uIEModCl7cmV0dXJuIHQubWF0Y2goYik/dC5yZXBsYWNlKGIsKHQ9PnYodCkpKTp0fXZhciBBPXIoNDcwKTtjb25zdCB3PUEucG9zaXh8fEEseD1cIi9cIjt2YXIgUDshZnVuY3Rpb24odCl7dC5qb2luUGF0aD1mdW5jdGlvbih0LC4uLmUpe3JldHVybiB0LndpdGgoe3BhdGg6dy5qb2luKHQucGF0aCwuLi5lKX0pfSx0LnJlc29sdmVQYXRoPWZ1bmN0aW9uKHQsLi4uZSl7bGV0IHI9dC5wYXRoLG49ITE7clswXSE9PXgmJihyPXgrcixuPSEwKTtsZXQgaT13LnJlc29sdmUociwuLi5lKTtyZXR1cm4gbiYmaVswXT09PXgmJiF0LmF1dGhvcml0eSYmKGk9aS5zdWJzdHJpbmcoMSkpLHQud2l0aCh7cGF0aDppfSl9LHQuZGlybmFtZT1mdW5jdGlvbih0KXtpZigwPT09dC5wYXRoLmxlbmd0aHx8dC5wYXRoPT09eClyZXR1cm4gdDtsZXQgZT13LmRpcm5hbWUodC5wYXRoKTtyZXR1cm4gMT09PWUubGVuZ3RoJiY0Nj09PWUuY2hhckNvZGVBdCgwKSYmKGU9XCJcIiksdC53aXRoKHtwYXRoOmV9KX0sdC5iYXNlbmFtZT1mdW5jdGlvbih0KXtyZXR1cm4gdy5iYXNlbmFtZSh0LnBhdGgpfSx0LmV4dG5hbWU9ZnVuY3Rpb24odCl7cmV0dXJuIHcuZXh0bmFtZSh0LnBhdGgpfX0oUHx8KFA9e30pKX0pKCksTElCPW59KSgpO2NvbnN0e1VSSTogZXNtX1VSSSxVdGlsc309TElCO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy92c2NvZGUtanNvbi1sYW5ndWFnZXNlcnZpY2UvbGliL2VzbS91dGlscy9nbG9iLmpzXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIENvcHlyaWdodCAoYykgMjAxMywgTmljayBGaXR6Z2VyYWxkXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTElDRU5DRS5tZCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5mdW5jdGlvbiBjcmVhdGVSZWdleChnbG9iLCBvcHRzKSB7XG4gICAgaWYgKHR5cGVvZiBnbG9iICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhIHN0cmluZycpO1xuICAgIH1cbiAgICBjb25zdCBzdHIgPSBTdHJpbmcoZ2xvYik7XG4gICAgLy8gVGhlIHJlZ2V4cCB3ZSBhcmUgYnVpbGRpbmcsIGFzIGEgc3RyaW5nLlxuICAgIGxldCByZVN0ciA9IFwiXCI7XG4gICAgLy8gV2hldGhlciB3ZSBhcmUgbWF0Y2hpbmcgc28gY2FsbGVkIFwiZXh0ZW5kZWRcIiBnbG9icyAobGlrZSBiYXNoKSBhbmQgc2hvdWxkXG4gICAgLy8gc3VwcG9ydCBzaW5nbGUgY2hhcmFjdGVyIG1hdGNoaW5nLCBtYXRjaGluZyByYW5nZXMgb2YgY2hhcmFjdGVycywgZ3JvdXBcbiAgICAvLyBtYXRjaGluZywgZXRjLlxuICAgIGNvbnN0IGV4dGVuZGVkID0gb3B0cyA/ICEhb3B0cy5leHRlbmRlZCA6IGZhbHNlO1xuICAgIC8vIFdoZW4gZ2xvYnN0YXIgaXMgX2ZhbHNlXyAoZGVmYXVsdCksICcvZm9vLyonIGlzIHRyYW5zbGF0ZWQgYSByZWdleHAgbGlrZVxuICAgIC8vICdeXFwvZm9vXFwvLiokJyB3aGljaCB3aWxsIG1hdGNoIGFueSBzdHJpbmcgYmVnaW5uaW5nIHdpdGggJy9mb28vJ1xuICAgIC8vIFdoZW4gZ2xvYnN0YXIgaXMgX3RydWVfLCAnL2Zvby8qJyBpcyB0cmFuc2xhdGVkIHRvIHJlZ2V4cCBsaWtlXG4gICAgLy8gJ15cXC9mb29cXC9bXi9dKiQnIHdoaWNoIHdpbGwgbWF0Y2ggYW55IHN0cmluZyBiZWdpbm5pbmcgd2l0aCAnL2Zvby8nIEJVVFxuICAgIC8vIHdoaWNoIGRvZXMgbm90IGhhdmUgYSAnLycgdG8gdGhlIHJpZ2h0IG9mIGl0LlxuICAgIC8vIEUuZy4gd2l0aCAnL2Zvby8qJyB0aGVzZSB3aWxsIG1hdGNoOiAnL2Zvby9iYXInLCAnL2Zvby9iYXIudHh0JyBidXRcbiAgICAvLyB0aGVzZSB3aWxsIG5vdCAnL2Zvby9iYXIvYmF6JywgJy9mb28vYmFyL2Jhei50eHQnXG4gICAgLy8gTGFzdGVseSwgd2hlbiBnbG9ic3RhciBpcyBfdHJ1ZV8sICcvZm9vLyoqJyBpcyBlcXVpdmVsYW50IHRvICcvZm9vLyonIHdoZW5cbiAgICAvLyBnbG9ic3RhciBpcyBfZmFsc2VfXG4gICAgY29uc3QgZ2xvYnN0YXIgPSBvcHRzID8gISFvcHRzLmdsb2JzdGFyIDogZmFsc2U7XG4gICAgLy8gSWYgd2UgYXJlIGRvaW5nIGV4dGVuZGVkIG1hdGNoaW5nLCB0aGlzIGJvb2xlYW4gaXMgdHJ1ZSB3aGVuIHdlIGFyZSBpbnNpZGVcbiAgICAvLyBhIGdyb3VwIChlZyB7Ki5odG1sLCouanN9KSwgYW5kIGZhbHNlIG90aGVyd2lzZS5cbiAgICBsZXQgaW5Hcm91cCA9IGZhbHNlO1xuICAgIC8vIFJlZ0V4cCBmbGFncyAoZWcgXCJpXCIgKSB0byBwYXNzIGluIHRvIFJlZ0V4cCBjb25zdHJ1Y3Rvci5cbiAgICBjb25zdCBmbGFncyA9IG9wdHMgJiYgdHlwZW9mIChvcHRzLmZsYWdzKSA9PT0gXCJzdHJpbmdcIiA/IG9wdHMuZmxhZ3MgOiBcIlwiO1xuICAgIGxldCBjO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBzdHIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgYyA9IHN0cltpXTtcbiAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgICBjYXNlIFwiL1wiOlxuICAgICAgICAgICAgY2FzZSBcIiRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJeXCI6XG4gICAgICAgICAgICBjYXNlIFwiK1wiOlxuICAgICAgICAgICAgY2FzZSBcIi5cIjpcbiAgICAgICAgICAgIGNhc2UgXCIoXCI6XG4gICAgICAgICAgICBjYXNlIFwiKVwiOlxuICAgICAgICAgICAgY2FzZSBcIj1cIjpcbiAgICAgICAgICAgIGNhc2UgXCIhXCI6XG4gICAgICAgICAgICBjYXNlIFwifFwiOlxuICAgICAgICAgICAgICAgIHJlU3RyICs9IFwiXFxcXFwiICsgYztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCI/XCI6XG4gICAgICAgICAgICAgICAgaWYgKGV4dGVuZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlU3RyICs9IFwiLlwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiW1wiOlxuICAgICAgICAgICAgY2FzZSBcIl1cIjpcbiAgICAgICAgICAgICAgICBpZiAoZXh0ZW5kZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVTdHIgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIntcIjpcbiAgICAgICAgICAgICAgICBpZiAoZXh0ZW5kZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5Hcm91cCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJlU3RyICs9IFwiKFwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwifVwiOlxuICAgICAgICAgICAgICAgIGlmIChleHRlbmRlZCkge1xuICAgICAgICAgICAgICAgICAgICBpbkdyb3VwID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlU3RyICs9IFwiKVwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiLFwiOlxuICAgICAgICAgICAgICAgIGlmIChpbkdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlU3RyICs9IFwifFwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVTdHIgKz0gXCJcXFxcXCIgKyBjO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIipcIjpcbiAgICAgICAgICAgICAgICAvLyBNb3ZlIG92ZXIgYWxsIGNvbnNlY3V0aXZlIFwiKlwiJ3MuXG4gICAgICAgICAgICAgICAgLy8gQWxzbyBzdG9yZSB0aGUgcHJldmlvdXMgYW5kIG5leHQgY2hhcmFjdGVyc1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZDaGFyID0gc3RyW2kgLSAxXTtcbiAgICAgICAgICAgICAgICBsZXQgc3RhckNvdW50ID0gMTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RyW2kgKyAxXSA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhckNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dENoYXIgPSBzdHJbaSArIDFdO1xuICAgICAgICAgICAgICAgIGlmICghZ2xvYnN0YXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2xvYnN0YXIgaXMgZGlzYWJsZWQsIHNvIHRyZWF0IGFueSBudW1iZXIgb2YgXCIqXCIgYXMgb25lXG4gICAgICAgICAgICAgICAgICAgIHJlU3RyICs9IFwiLipcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGdsb2JzdGFyIGlzIGVuYWJsZWQsIHNvIGRldGVybWluZSBpZiB0aGlzIGlzIGEgZ2xvYnN0YXIgc2VnbWVudFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0dsb2JzdGFyID0gc3RhckNvdW50ID4gMSAvLyBtdWx0aXBsZSBcIipcIidzXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiAocHJldkNoYXIgPT09IFwiL1wiIHx8IHByZXZDaGFyID09PSB1bmRlZmluZWQgfHwgcHJldkNoYXIgPT09ICd7JyB8fCBwcmV2Q2hhciA9PT0gJywnKSAvLyBmcm9tIHRoZSBzdGFydCBvZiB0aGUgc2VnbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgKG5leHRDaGFyID09PSBcIi9cIiB8fCBuZXh0Q2hhciA9PT0gdW5kZWZpbmVkIHx8IG5leHRDaGFyID09PSAnLCcgfHwgbmV4dENoYXIgPT09ICd9Jyk7IC8vIHRvIHRoZSBlbmQgb2YgdGhlIHNlZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzR2xvYnN0YXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hhciA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpKys7IC8vIG1vdmUgb3ZlciB0aGUgXCIvXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByZXZDaGFyID09PSAnLycgJiYgcmVTdHIuZW5kc1dpdGgoJ1xcXFwvJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZVN0ciA9IHJlU3RyLnN1YnN0cigwLCByZVN0ci5sZW5ndGggLSAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0J3MgYSBnbG9ic3Rhciwgc28gbWF0Y2ggemVybyBvciBtb3JlIHBhdGggc2VnbWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlU3RyICs9IFwiKCg/OlteL10qKD86XFwvfCQpKSopXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIG5vdCBhIGdsb2JzdGFyLCBzbyBvbmx5IG1hdGNoIG9uZSBwYXRoIHNlZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlU3RyICs9IFwiKFteL10qKVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZVN0ciArPSBjO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFdoZW4gcmVnZXhwICdnJyBmbGFnIGlzIHNwZWNpZmllZCBkb24ndFxuICAgIC8vIGNvbnN0cmFpbiB0aGUgcmVndWxhciBleHByZXNzaW9uIHdpdGggXiAmICRcbiAgICBpZiAoIWZsYWdzIHx8ICF+ZmxhZ3MuaW5kZXhPZignZycpKSB7XG4gICAgICAgIHJlU3RyID0gXCJeXCIgKyByZVN0ciArIFwiJFwiO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFJlZ0V4cChyZVN0ciwgZmxhZ3MpO1xufVxuO1xuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3ZzY29kZS1qc29uLWxhbmd1YWdlc2VydmljZS9saWIvZXNtL3NlcnZpY2VzL2pzb25TY2hlbWFTZXJ2aWNlLmpzXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cblxuXG5cblxuY29uc3QgQkFORyA9ICchJztcbmNvbnN0IFBBVEhfU0VQID0gJy8nO1xuY2xhc3MgRmlsZVBhdHRlcm5Bc3NvY2lhdGlvbiB7XG4gICAgY29uc3RydWN0b3IocGF0dGVybiwgZm9sZGVyVXJpLCB1cmlzKSB7XG4gICAgICAgIHRoaXMuZm9sZGVyVXJpID0gZm9sZGVyVXJpO1xuICAgICAgICB0aGlzLnVyaXMgPSB1cmlzO1xuICAgICAgICB0aGlzLmdsb2JXcmFwcGVycyA9IFtdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChsZXQgcGF0dGVyblN0cmluZyBvZiBwYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5jbHVkZSA9IHBhdHRlcm5TdHJpbmdbMF0gIT09IEJBTkc7XG4gICAgICAgICAgICAgICAgaWYgKCFpbmNsdWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm5TdHJpbmcgPSBwYXR0ZXJuU3RyaW5nLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhdHRlcm5TdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGF0dGVyblN0cmluZ1swXSA9PT0gUEFUSF9TRVApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm5TdHJpbmcgPSBwYXR0ZXJuU3RyaW5nLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdsb2JXcmFwcGVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4cDogY3JlYXRlUmVnZXgoJyoqLycgKyBwYXR0ZXJuU3RyaW5nLCB7IGV4dGVuZGVkOiB0cnVlLCBnbG9ic3RhcjogdHJ1ZSB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1ZGU6IGluY2x1ZGUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIGlmIChmb2xkZXJVcmkpIHtcbiAgICAgICAgICAgICAgICBmb2xkZXJVcmkgPSBub3JtYWxpemVSZXNvdXJjZUZvck1hdGNoaW5nKGZvbGRlclVyaSk7XG4gICAgICAgICAgICAgICAgaWYgKCFmb2xkZXJVcmkuZW5kc1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgICAgICAgICBmb2xkZXJVcmkgPSBmb2xkZXJVcmkgKyAnLyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZm9sZGVyVXJpID0gZm9sZGVyVXJpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmdsb2JXcmFwcGVycy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgdGhpcy51cmlzID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWF0Y2hlc1BhdHRlcm4oZmlsZU5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZm9sZGVyVXJpICYmICFmaWxlTmFtZS5zdGFydHNXaXRoKHRoaXMuZm9sZGVyVXJpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtYXRjaCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IHsgcmVnZXhwLCBpbmNsdWRlIH0gb2YgdGhpcy5nbG9iV3JhcHBlcnMpIHtcbiAgICAgICAgICAgIGlmIChyZWdleHAudGVzdChmaWxlTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBtYXRjaCA9IGluY2x1ZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH1cbiAgICBnZXRVUklzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51cmlzO1xuICAgIH1cbn1cbmNsYXNzIFNjaGVtYUhhbmRsZSB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZSwgdXJpLCB1bnJlc29sdmVkU2NoZW1hQ29udGVudCkge1xuICAgICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgICAgICB0aGlzLnVyaSA9IHVyaTtcbiAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuYW5jaG9ycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHVucmVzb2x2ZWRTY2hlbWFDb250ZW50KSB7XG4gICAgICAgICAgICB0aGlzLnVucmVzb2x2ZWRTY2hlbWEgPSB0aGlzLnNlcnZpY2UucHJvbWlzZS5yZXNvbHZlKG5ldyBVbnJlc29sdmVkU2NoZW1hKHVucmVzb2x2ZWRTY2hlbWFDb250ZW50KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0VW5yZXNvbHZlZFNjaGVtYSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnVucmVzb2x2ZWRTY2hlbWEpIHtcbiAgICAgICAgICAgIHRoaXMudW5yZXNvbHZlZFNjaGVtYSA9IHRoaXMuc2VydmljZS5sb2FkU2NoZW1hKHRoaXMudXJpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy51bnJlc29sdmVkU2NoZW1hO1xuICAgIH1cbiAgICBnZXRSZXNvbHZlZFNjaGVtYSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlc29sdmVkU2NoZW1hKSB7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmVkU2NoZW1hID0gdGhpcy5nZXRVbnJlc29sdmVkU2NoZW1hKCkudGhlbih1bnJlc29sdmVkID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJ2aWNlLnJlc29sdmVTY2hlbWFDb250ZW50KHVucmVzb2x2ZWQsIHRoaXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZWRTY2hlbWE7XG4gICAgfVxuICAgIGNsZWFyU2NoZW1hKCkge1xuICAgICAgICBjb25zdCBoYXNDaGFuZ2VzID0gISF0aGlzLnVucmVzb2x2ZWRTY2hlbWE7XG4gICAgICAgIHRoaXMucmVzb2x2ZWRTY2hlbWEgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMudW5yZXNvbHZlZFNjaGVtYSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5hbmNob3JzID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gaGFzQ2hhbmdlcztcbiAgICB9XG59XG5jbGFzcyBVbnJlc29sdmVkU2NoZW1hIHtcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEsIGVycm9ycyA9IFtdKSB7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICB9XG59XG5jbGFzcyBSZXNvbHZlZFNjaGVtYSB7XG4gICAgY29uc3RydWN0b3Ioc2NoZW1hLCBlcnJvcnMgPSBbXSwgd2FybmluZ3MgPSBbXSwgc2NoZW1hRHJhZnQpIHtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB0aGlzLndhcm5pbmdzID0gd2FybmluZ3M7XG4gICAgICAgIHRoaXMuc2NoZW1hRHJhZnQgPSBzY2hlbWFEcmFmdDtcbiAgICB9XG4gICAgZ2V0U2VjdGlvbihwYXRoKSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYVJlZiA9IHRoaXMuZ2V0U2VjdGlvblJlY3Vyc2l2ZShwYXRoLCB0aGlzLnNjaGVtYSk7XG4gICAgICAgIGlmIChzY2hlbWFSZWYpIHtcbiAgICAgICAgICAgIHJldHVybiBhc1NjaGVtYShzY2hlbWFSZWYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldFNlY3Rpb25SZWN1cnNpdmUocGF0aCwgc2NoZW1hKSB7XG4gICAgICAgIGlmICghc2NoZW1hIHx8IHR5cGVvZiBzY2hlbWEgPT09ICdib29sZWFuJyB8fCBwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0ID0gcGF0aC5zaGlmdCgpO1xuICAgICAgICBpZiAoc2NoZW1hLnByb3BlcnRpZXMgJiYgdHlwZW9mIHNjaGVtYS5wcm9wZXJ0aWVzW25leHRdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTZWN0aW9uUmVjdXJzaXZlKHBhdGgsIHNjaGVtYS5wcm9wZXJ0aWVzW25leHRdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzY2hlbWEucGF0dGVyblByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiBPYmplY3Qua2V5cyhzY2hlbWEucGF0dGVyblByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVnZXggPSBleHRlbmRlZFJlZ0V4cChwYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICBpZiAocmVnZXg/LnRlc3QobmV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VjdGlvblJlY3Vyc2l2ZShwYXRoLCBzY2hlbWEucGF0dGVyblByb3BlcnRpZXNbcGF0dGVybl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VjdGlvblJlY3Vyc2l2ZShwYXRoLCBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5leHQubWF0Y2goJ1swLTldKycpKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEuaXRlbXMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwYXJzZUludChuZXh0LCAxMCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihpbmRleCkgJiYgc2NoZW1hLml0ZW1zW2luZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTZWN0aW9uUmVjdXJzaXZlKHBhdGgsIHNjaGVtYS5pdGVtc1tpbmRleF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNjaGVtYS5pdGVtcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNlY3Rpb25SZWN1cnNpdmUocGF0aCwgc2NoZW1hLml0ZW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmNsYXNzIEpTT05TY2hlbWFTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihyZXF1ZXN0U2VydmljZSwgY29udGV4dFNlcnZpY2UsIHByb21pc2VDb25zdHJ1Y3Rvcikge1xuICAgICAgICB0aGlzLmNvbnRleHRTZXJ2aWNlID0gY29udGV4dFNlcnZpY2U7XG4gICAgICAgIHRoaXMucmVxdWVzdFNlcnZpY2UgPSByZXF1ZXN0U2VydmljZTtcbiAgICAgICAgdGhpcy5wcm9taXNlQ29uc3RydWN0b3IgPSBwcm9taXNlQ29uc3RydWN0b3IgfHwgUHJvbWlzZTtcbiAgICAgICAgdGhpcy5jYWxsT25EaXNwb3NlID0gW107XG4gICAgICAgIHRoaXMuY29udHJpYnV0aW9uU2NoZW1hcyA9IHt9O1xuICAgICAgICB0aGlzLmNvbnRyaWJ1dGlvbkFzc29jaWF0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLnNjaGVtYXNCeUlkID0ge307XG4gICAgICAgIHRoaXMuZmlsZVBhdHRlcm5Bc3NvY2lhdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkU2NoZW1hc0lkcyA9IHt9O1xuICAgIH1cbiAgICBnZXRSZWdpc3RlcmVkU2NoZW1hSWRzKGZpbHRlcikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5yZWdpc3RlcmVkU2NoZW1hc0lkcykuZmlsdGVyKGlkID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtZSA9IGVzbV9VUkkucGFyc2UoaWQpLnNjaGVtZTtcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWUgIT09ICdzY2hlbWFzZXJ2aWNlJyAmJiAoIWZpbHRlciB8fCBmaWx0ZXIoc2NoZW1lKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgcHJvbWlzZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZUNvbnN0cnVjdG9yO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB3aGlsZSAodGhpcy5jYWxsT25EaXNwb3NlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbE9uRGlzcG9zZS5wb3AoKSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uUmVzb3VyY2VDaGFuZ2UodXJpKSB7XG4gICAgICAgIC8vIGFsd2F5cyBjbGVhciB0aGlzIGxvY2FsIGNhY2hlIHdoZW4gYSByZXNvdXJjZSBjaGFuZ2VzXG4gICAgICAgIHRoaXMuY2FjaGVkU2NoZW1hRm9yUmVzb3VyY2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBoYXNDaGFuZ2VzID0gZmFsc2U7XG4gICAgICAgIHVyaSA9IG5vcm1hbGl6ZUlkKHVyaSk7XG4gICAgICAgIGNvbnN0IHRvV2FsayA9IFt1cmldO1xuICAgICAgICBjb25zdCBhbGwgPSBPYmplY3Qua2V5cyh0aGlzLnNjaGVtYXNCeUlkKS5tYXAoa2V5ID0+IHRoaXMuc2NoZW1hc0J5SWRba2V5XSk7XG4gICAgICAgIHdoaWxlICh0b1dhbGsubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyID0gdG9XYWxrLnBvcCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbGwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBhbGxbaV07XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZSAmJiAoaGFuZGxlLnVyaSA9PT0gY3VyciB8fCBoYW5kbGUuZGVwZW5kZW5jaWVzLmhhcyhjdXJyKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZS51cmkgIT09IGN1cnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvV2Fsay5wdXNoKGhhbmRsZS51cmkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGUuY2xlYXJTY2hlbWEoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzQ2hhbmdlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYWxsW2ldID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFzQ2hhbmdlcztcbiAgICB9XG4gICAgc2V0U2NoZW1hQ29udHJpYnV0aW9ucyhzY2hlbWFDb250cmlidXRpb25zKSB7XG4gICAgICAgIGlmIChzY2hlbWFDb250cmlidXRpb25zLnNjaGVtYXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYXMgPSBzY2hlbWFDb250cmlidXRpb25zLnNjaGVtYXM7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlkIGluIHNjaGVtYXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub3JtYWxpemVkSWQgPSBub3JtYWxpemVJZChpZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250cmlidXRpb25TY2hlbWFzW25vcm1hbGl6ZWRJZF0gPSB0aGlzLmFkZFNjaGVtYUhhbmRsZShub3JtYWxpemVkSWQsIHNjaGVtYXNbaWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWFDb250cmlidXRpb25zLnNjaGVtYUFzc29jaWF0aW9ucykpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYUFzc29jaWF0aW9ucyA9IHNjaGVtYUNvbnRyaWJ1dGlvbnMuc2NoZW1hQXNzb2NpYXRpb25zO1xuICAgICAgICAgICAgZm9yIChsZXQgc2NoZW1hQXNzb2NpYXRpb24gb2Ygc2NoZW1hQXNzb2NpYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXJpcyA9IHNjaGVtYUFzc29jaWF0aW9uLnVyaXMubWFwKG5vcm1hbGl6ZUlkKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhc3NvY2lhdGlvbiA9IHRoaXMuYWRkRmlsZVBhdHRlcm5Bc3NvY2lhdGlvbihzY2hlbWFBc3NvY2lhdGlvbi5wYXR0ZXJuLCBzY2hlbWFBc3NvY2lhdGlvbi5mb2xkZXJVcmksIHVyaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udHJpYnV0aW9uQXNzb2NpYXRpb25zLnB1c2goYXNzb2NpYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFkZFNjaGVtYUhhbmRsZShpZCwgdW5yZXNvbHZlZFNjaGVtYUNvbnRlbnQpIHtcbiAgICAgICAgY29uc3Qgc2NoZW1hSGFuZGxlID0gbmV3IFNjaGVtYUhhbmRsZSh0aGlzLCBpZCwgdW5yZXNvbHZlZFNjaGVtYUNvbnRlbnQpO1xuICAgICAgICB0aGlzLnNjaGVtYXNCeUlkW2lkXSA9IHNjaGVtYUhhbmRsZTtcbiAgICAgICAgcmV0dXJuIHNjaGVtYUhhbmRsZTtcbiAgICB9XG4gICAgZ2V0T3JBZGRTY2hlbWFIYW5kbGUoaWQsIHVucmVzb2x2ZWRTY2hlbWFDb250ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjaGVtYXNCeUlkW2lkXSB8fCB0aGlzLmFkZFNjaGVtYUhhbmRsZShpZCwgdW5yZXNvbHZlZFNjaGVtYUNvbnRlbnQpO1xuICAgIH1cbiAgICBhZGRGaWxlUGF0dGVybkFzc29jaWF0aW9uKHBhdHRlcm4sIGZvbGRlclVyaSwgdXJpcykge1xuICAgICAgICBjb25zdCBmcGEgPSBuZXcgRmlsZVBhdHRlcm5Bc3NvY2lhdGlvbihwYXR0ZXJuLCBmb2xkZXJVcmksIHVyaXMpO1xuICAgICAgICB0aGlzLmZpbGVQYXR0ZXJuQXNzb2NpYXRpb25zLnB1c2goZnBhKTtcbiAgICAgICAgcmV0dXJuIGZwYTtcbiAgICB9XG4gICAgcmVnaXN0ZXJFeHRlcm5hbFNjaGVtYShjb25maWcpIHtcbiAgICAgICAgY29uc3QgaWQgPSBub3JtYWxpemVJZChjb25maWcudXJpKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkU2NoZW1hc0lkc1tpZF0gPSB0cnVlO1xuICAgICAgICB0aGlzLmNhY2hlZFNjaGVtYUZvclJlc291cmNlID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoY29uZmlnLmZpbGVNYXRjaCAmJiBjb25maWcuZmlsZU1hdGNoLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5hZGRGaWxlUGF0dGVybkFzc29jaWF0aW9uKGNvbmZpZy5maWxlTWF0Y2gsIGNvbmZpZy5mb2xkZXJVcmksIFtpZF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25maWcuc2NoZW1hID8gdGhpcy5hZGRTY2hlbWFIYW5kbGUoaWQsIGNvbmZpZy5zY2hlbWEpIDogdGhpcy5nZXRPckFkZFNjaGVtYUhhbmRsZShpZCk7XG4gICAgfVxuICAgIGNsZWFyRXh0ZXJuYWxTY2hlbWFzKCkge1xuICAgICAgICB0aGlzLnNjaGVtYXNCeUlkID0ge307XG4gICAgICAgIHRoaXMuZmlsZVBhdHRlcm5Bc3NvY2lhdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkU2NoZW1hc0lkcyA9IHt9O1xuICAgICAgICB0aGlzLmNhY2hlZFNjaGVtYUZvclJlc291cmNlID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGlkIGluIHRoaXMuY29udHJpYnV0aW9uU2NoZW1hcykge1xuICAgICAgICAgICAgdGhpcy5zY2hlbWFzQnlJZFtpZF0gPSB0aGlzLmNvbnRyaWJ1dGlvblNjaGVtYXNbaWRdO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlcmVkU2NoZW1hc0lkc1tpZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgY29udHJpYnV0aW9uQXNzb2NpYXRpb24gb2YgdGhpcy5jb250cmlidXRpb25Bc3NvY2lhdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsZVBhdHRlcm5Bc3NvY2lhdGlvbnMucHVzaChjb250cmlidXRpb25Bc3NvY2lhdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UmVzb2x2ZWRTY2hlbWEoc2NoZW1hSWQpIHtcbiAgICAgICAgY29uc3QgaWQgPSBub3JtYWxpemVJZChzY2hlbWFJZCk7XG4gICAgICAgIGNvbnN0IHNjaGVtYUhhbmRsZSA9IHRoaXMuc2NoZW1hc0J5SWRbaWRdO1xuICAgICAgICBpZiAoc2NoZW1hSGFuZGxlKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hSGFuZGxlLmdldFJlc29sdmVkU2NoZW1hKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGxvYWRTY2hlbWEodXJsKSB7XG4gICAgICAgIGlmICghdGhpcy5yZXF1ZXN0U2VydmljZSkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gdCgnVW5hYmxlIHRvIGxvYWQgc2NoZW1hIGZyb20gXFwnezB9XFwnLiBObyBzY2hlbWEgcmVxdWVzdCBzZXJ2aWNlIGF2YWlsYWJsZScsIHRvRGlzcGxheVN0cmluZyh1cmwpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb21pc2UucmVzb2x2ZShuZXcgVW5yZXNvbHZlZFNjaGVtYSh7fSwgW2Vycm9yTWVzc2FnZV0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXJsLnN0YXJ0c1dpdGgoJ2h0dHA6Ly9qc29uLXNjaGVtYS5vcmcvJykpIHtcbiAgICAgICAgICAgIHVybCA9ICdodHRwcycgKyB1cmwuc3Vic3RyaW5nKDQpOyAvLyBhbHdheXMgYWNjZXNzIGpzb24tc2NoZW1hLm9yZyB3aXRoIGh0dHBzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC92c2NvZGUvaXNzdWVzLzE5NTE4OVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RTZXJ2aWNlKHVybCkudGhlbihjb250ZW50ID0+IHtcbiAgICAgICAgICAgIGlmICghY29udGVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IHQoJ1VuYWJsZSB0byBsb2FkIHNjaGVtYSBmcm9tIFxcJ3swfVxcJzogTm8gY29udGVudC4nLCB0b0Rpc3BsYXlTdHJpbmcodXJsKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVbnJlc29sdmVkU2NoZW1hKHt9LCBbZXJyb3JNZXNzYWdlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIGlmIChjb250ZW50LmNoYXJDb2RlQXQoMCkgPT09IDY1Mjc5KSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2godCgnUHJvYmxlbSByZWFkaW5nIGNvbnRlbnQgZnJvbSBcXCd7MH1cXCc6IFVURi04IHdpdGggQk9NIGRldGVjdGVkLCBvbmx5IFVURiA4IGlzIGFsbG93ZWQuJywgdG9EaXNwbGF5U3RyaW5nKHVybCkpKTtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gY29udGVudC50cmltU3RhcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzY2hlbWFDb250ZW50ID0ge307XG4gICAgICAgICAgICBjb25zdCBqc29uRXJyb3JzID0gW107XG4gICAgICAgICAgICBzY2hlbWFDb250ZW50ID0gbWFpbl9wYXJzZShjb250ZW50LCBqc29uRXJyb3JzKTtcbiAgICAgICAgICAgIGlmIChqc29uRXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHQoJ1VuYWJsZSB0byBwYXJzZSBjb250ZW50IGZyb20gXFwnezB9XFwnOiBQYXJzZSBlcnJvciBhdCBvZmZzZXQgezF9LicsIHRvRGlzcGxheVN0cmluZyh1cmwpLCBqc29uRXJyb3JzWzBdLm9mZnNldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVbnJlc29sdmVkU2NoZW1hKHNjaGVtYUNvbnRlbnQsIGVycm9ycyk7XG4gICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgbGV0IGVycm9yTWVzc2FnZSA9IGVycm9yLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBjb25zdCBlcnJvclNwbGl0ID0gZXJyb3IudG9TdHJpbmcoKS5zcGxpdCgnRXJyb3I6ICcpO1xuICAgICAgICAgICAgaWYgKGVycm9yU3BsaXQubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIC8vIG1vcmUgY29uY2lzZSBlcnJvciBtZXNzYWdlLCBVUkwgYW5kIGNvbnRleHQgYXJlIGF0dGFjaGVkIGJ5IGNhbGxlciBhbnl3YXlzXG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gZXJyb3JTcGxpdFsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmRzV2l0aChlcnJvck1lc3NhZ2UsICcuJykpIHtcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBlcnJvck1lc3NhZ2Uuc3Vic3RyKDAsIGVycm9yTWVzc2FnZS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgVW5yZXNvbHZlZFNjaGVtYSh7fSwgW3QoJ1VuYWJsZSB0byBsb2FkIHNjaGVtYSBmcm9tIFxcJ3swfVxcJzogezF9LicsIHRvRGlzcGxheVN0cmluZyh1cmwpLCBlcnJvck1lc3NhZ2UpXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXNvbHZlU2NoZW1hQ29udGVudChzY2hlbWFUb1Jlc29sdmUsIGhhbmRsZSkge1xuICAgICAgICBjb25zdCByZXNvbHZlRXJyb3JzID0gc2NoZW1hVG9SZXNvbHZlLmVycm9ycy5zbGljZSgwKTtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gc2NoZW1hVG9SZXNvbHZlLnNjaGVtYTtcbiAgICAgICAgbGV0IHNjaGVtYURyYWZ0ID0gc2NoZW1hLiRzY2hlbWEgPyBub3JtYWxpemVJZChzY2hlbWEuJHNjaGVtYSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChzY2hlbWFEcmFmdCA9PT0gJ2h0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDMvc2NoZW1hJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZS5yZXNvbHZlKG5ldyBSZXNvbHZlZFNjaGVtYSh7fSwgW3QoXCJEcmFmdC0wMyBzY2hlbWFzIGFyZSBub3Qgc3VwcG9ydGVkLlwiKV0sIFtdLCBzY2hlbWFEcmFmdCkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB1c2VzVW5zdXBwb3J0ZWRGZWF0dXJlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgY29uc3QgY29udGV4dFNlcnZpY2UgPSB0aGlzLmNvbnRleHRTZXJ2aWNlO1xuICAgICAgICBjb25zdCBmaW5kU2VjdGlvbkJ5SlNPTlBvaW50ZXIgPSAoc2NoZW1hLCBwYXRoKSA9PiB7XG4gICAgICAgICAgICBwYXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhdGgpO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSBzY2hlbWE7XG4gICAgICAgICAgICBpZiAocGF0aFswXSA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgcGF0aCA9IHBhdGguc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF0aC5zcGxpdCgnLycpLnNvbWUoKHBhcnQpID0+IHtcbiAgICAgICAgICAgICAgICBwYXJ0ID0gcGFydC5yZXBsYWNlKC9+MS9nLCAnLycpLnJlcGxhY2UoL34wL2csICd+Jyk7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnRbcGFydF07XG4gICAgICAgICAgICAgICAgcmV0dXJuICFjdXJyZW50O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZmluZFNjaGVtYUJ5SWQgPSAoc2NoZW1hLCBoYW5kbGUsIGlkKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhbmRsZS5hbmNob3JzKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlLmFuY2hvcnMgPSBjb2xsZWN0QW5jaG9ycyhzY2hlbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZS5hbmNob3JzLmdldChpZCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG1lcmdlID0gKHRhcmdldCwgc2VjdGlvbikgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2VjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChzZWN0aW9uLmhhc093blByb3BlcnR5KGtleSkgJiYga2V5ICE9PSAnaWQnICYmIGtleSAhPT0gJyRpZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzZWN0aW9uW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBtZXJnZVJlZiA9ICh0YXJnZXQsIHNvdXJjZVJvb3QsIHNvdXJjZUhhbmRsZSwgcmVmU2VnbWVudCkgPT4ge1xuICAgICAgICAgICAgbGV0IHNlY3Rpb247XG4gICAgICAgICAgICBpZiAocmVmU2VnbWVudCA9PT0gdW5kZWZpbmVkIHx8IHJlZlNlZ21lbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc2VjdGlvbiA9IHNvdXJjZVJvb3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZWZTZWdtZW50LmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgLy8gQSAkcmVmIHRvIGEgSlNPTiBQb2ludGVyIChpLmUgIy9kZWZpbml0aW9ucy9mb28pXG4gICAgICAgICAgICAgICAgc2VjdGlvbiA9IGZpbmRTZWN0aW9uQnlKU09OUG9pbnRlcihzb3VyY2VSb290LCByZWZTZWdtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEEgJHJlZiB0byBhIHN1Yi1zY2hlbWEgd2l0aCBhbiAkaWQgKGkuZSAjaGVsbG8pXG4gICAgICAgICAgICAgICAgc2VjdGlvbiA9IGZpbmRTY2hlbWFCeUlkKHNvdXJjZVJvb3QsIHNvdXJjZUhhbmRsZSwgcmVmU2VnbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VjdGlvbikge1xuICAgICAgICAgICAgICAgIG1lcmdlKHRhcmdldCwgc2VjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlRXJyb3JzLnB1c2godCgnJHJlZiBcXCd7MH1cXCcgaW4gXFwnezF9XFwnIGNhbiBub3QgYmUgcmVzb2x2ZWQuJywgcmVmU2VnbWVudCB8fCAnJywgc291cmNlSGFuZGxlLnVyaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNvbHZlRXh0ZXJuYWxMaW5rID0gKG5vZGUsIHVyaSwgcmVmU2VnbWVudCwgcGFyZW50SGFuZGxlKSA9PiB7XG4gICAgICAgICAgICBpZiAoY29udGV4dFNlcnZpY2UgJiYgIS9eW0EtWmEtel1bQS1aYS16MC05K1xcLS4rXSo6XFwvXFwvLiovLnRlc3QodXJpKSkge1xuICAgICAgICAgICAgICAgIHVyaSA9IGNvbnRleHRTZXJ2aWNlLnJlc29sdmVSZWxhdGl2ZVBhdGgodXJpLCBwYXJlbnRIYW5kbGUudXJpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVyaSA9IG5vcm1hbGl6ZUlkKHVyaSk7XG4gICAgICAgICAgICBjb25zdCByZWZlcmVuY2VkSGFuZGxlID0gdGhpcy5nZXRPckFkZFNjaGVtYUhhbmRsZSh1cmkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlZmVyZW5jZWRIYW5kbGUuZ2V0VW5yZXNvbHZlZFNjaGVtYSgpLnRoZW4odW5yZXNvbHZlZFNjaGVtYSA9PiB7XG4gICAgICAgICAgICAgICAgcGFyZW50SGFuZGxlLmRlcGVuZGVuY2llcy5hZGQodXJpKTtcbiAgICAgICAgICAgICAgICBpZiAodW5yZXNvbHZlZFNjaGVtYS5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvYyA9IHJlZlNlZ21lbnQgPyB1cmkgKyAnIycgKyByZWZTZWdtZW50IDogdXJpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlRXJyb3JzLnB1c2godCgnUHJvYmxlbXMgbG9hZGluZyByZWZlcmVuY2UgXFwnezB9XFwnOiB7MX0nLCBsb2MsIHVucmVzb2x2ZWRTY2hlbWEuZXJyb3JzWzBdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1lcmdlUmVmKG5vZGUsIHVucmVzb2x2ZWRTY2hlbWEuc2NoZW1hLCByZWZlcmVuY2VkSGFuZGxlLCByZWZTZWdtZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZVJlZnMobm9kZSwgdW5yZXNvbHZlZFNjaGVtYS5zY2hlbWEsIHJlZmVyZW5jZWRIYW5kbGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc29sdmVSZWZzID0gKG5vZGUsIHBhcmVudFNjaGVtYSwgcGFyZW50SGFuZGxlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvcGVuUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMudHJhdmVyc2VOb2Rlcyhub2RlLCBuZXh0ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWVuUmVmcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV4dC4kcmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZiA9IG5leHQuJHJlZjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VnbWVudHMgPSByZWYuc3BsaXQoJyMnLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG5leHQuJHJlZjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZ21lbnRzWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSByZWZlcmVuY2UgdG8gYW4gZXh0ZXJuYWwgc2NoZW1hXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVuUHJvbWlzZXMucHVzaChyZXNvbHZlRXh0ZXJuYWxMaW5rKG5leHQsIHNlZ21lbnRzWzBdLCBzZWdtZW50c1sxXSwgcGFyZW50SGFuZGxlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgcmVmZXJlbmNlIGluc2lkZSB0aGUgY3VycmVudCBzY2hlbWFcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2VlblJlZnMuaGFzKHJlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpZCA9IHNlZ21lbnRzWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlUmVmKG5leHQsIHBhcmVudFNjaGVtYSwgcGFyZW50SGFuZGxlLCBpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VlblJlZnMuYWRkKHJlZik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5leHQuJHJlY3Vyc2l2ZVJlZikge1xuICAgICAgICAgICAgICAgICAgICB1c2VzVW5zdXBwb3J0ZWRGZWF0dXJlcy5hZGQoJyRyZWN1cnNpdmVSZWYnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5leHQuJGR5bmFtaWNSZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlc1Vuc3VwcG9ydGVkRmVhdHVyZXMuYWRkKCckZHluYW1pY1JlZicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZS5hbGwob3BlblByb21pc2VzKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY29sbGVjdEFuY2hvcnMgPSAocm9vdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy50cmF2ZXJzZU5vZGVzKHJvb3QsIG5leHQgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gbmV4dC4kaWQgfHwgbmV4dC5pZDtcbiAgICAgICAgICAgICAgICBjb25zdCBhbmNob3IgPSBpc1N0cmluZyhpZCkgJiYgaWQuY2hhckF0KDApID09PSAnIycgPyBpZC5zdWJzdHJpbmcoMSkgOiBuZXh0LiRhbmNob3I7XG4gICAgICAgICAgICAgICAgaWYgKGFuY2hvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmhhcyhhbmNob3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlRXJyb3JzLnB1c2godCgnRHVwbGljYXRlIGFuY2hvciBkZWNsYXJhdGlvbjogXFwnezB9XFwnJywgYW5jaG9yKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0KGFuY2hvciwgbmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5leHQuJHJlY3Vyc2l2ZUFuY2hvcikge1xuICAgICAgICAgICAgICAgICAgICB1c2VzVW5zdXBwb3J0ZWRGZWF0dXJlcy5hZGQoJyRyZWN1cnNpdmVBbmNob3InKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5leHQuJGR5bmFtaWNBbmNob3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlc1Vuc3VwcG9ydGVkRmVhdHVyZXMuYWRkKCckZHluYW1pY0FuY2hvcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVSZWZzKHNjaGVtYSwgc2NoZW1hLCBoYW5kbGUpLnRoZW4oXyA9PiB7XG4gICAgICAgICAgICBsZXQgcmVzb2x2ZVdhcm5pbmdzID0gW107XG4gICAgICAgICAgICBpZiAodXNlc1Vuc3VwcG9ydGVkRmVhdHVyZXMuc2l6ZSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVXYXJuaW5ncy5wdXNoKHQoJ1RoZSBzY2hlbWEgdXNlcyBtZXRhLXNjaGVtYSBmZWF0dXJlcyAoezB9KSB0aGF0IGFyZSBub3QgeWV0IHN1cHBvcnRlZCBieSB0aGUgdmFsaWRhdG9yLicsIEFycmF5LmZyb20odXNlc1Vuc3VwcG9ydGVkRmVhdHVyZXMua2V5cygpKS5qb2luKCcsICcpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlc29sdmVkU2NoZW1hKHNjaGVtYSwgcmVzb2x2ZUVycm9ycywgcmVzb2x2ZVdhcm5pbmdzLCBzY2hlbWFEcmFmdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0cmF2ZXJzZU5vZGVzKHJvb3QsIGhhbmRsZSkge1xuICAgICAgICBpZiAoIXJvb3QgfHwgdHlwZW9mIHJvb3QgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlZW4gPSBuZXcgU2V0KCk7XG4gICAgICAgIGNvbnN0IGNvbGxlY3RFbnRyaWVzID0gKC4uLmVudHJpZXMpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChlbnRyeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9XYWxrLnB1c2goZW50cnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY29sbGVjdE1hcEVudHJpZXMgPSAoLi4ubWFwcykgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBtYXAgb2YgbWFwcykge1xuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChtYXApKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgayBpbiBtYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnRyeSA9IG1hcFtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KGVudHJ5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvV2Fsay5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY29sbGVjdEFycmF5RW50cmllcyA9ICguLi5hcnJheXMpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYXJyYXkgb2YgYXJyYXlzKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgYXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChlbnRyeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b1dhbGsucHVzaChlbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNvbGxlY3RFbnRyeU9yQXJyYXlFbnRyaWVzID0gKGl0ZW1zKSA9PiB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtcykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChlbnRyeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvV2Fsay5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KGl0ZW1zKSkge1xuICAgICAgICAgICAgICAgIHRvV2Fsay5wdXNoKGl0ZW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdG9XYWxrID0gW3Jvb3RdO1xuICAgICAgICBsZXQgbmV4dCA9IHRvV2Fsay5wb3AoKTtcbiAgICAgICAgd2hpbGUgKG5leHQpIHtcbiAgICAgICAgICAgIGlmICghc2Vlbi5oYXMobmV4dCkpIHtcbiAgICAgICAgICAgICAgICBzZWVuLmFkZChuZXh0KTtcbiAgICAgICAgICAgICAgICBoYW5kbGUobmV4dCk7XG4gICAgICAgICAgICAgICAgY29sbGVjdEVudHJpZXMobmV4dC5hZGRpdGlvbmFsSXRlbXMsIG5leHQuYWRkaXRpb25hbFByb3BlcnRpZXMsIG5leHQubm90LCBuZXh0LmNvbnRhaW5zLCBuZXh0LnByb3BlcnR5TmFtZXMsIG5leHQuaWYsIG5leHQudGhlbiwgbmV4dC5lbHNlLCBuZXh0LnVuZXZhbHVhdGVkSXRlbXMsIG5leHQudW5ldmFsdWF0ZWRQcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgICAgICBjb2xsZWN0TWFwRW50cmllcyhuZXh0LmRlZmluaXRpb25zLCBuZXh0LiRkZWZzLCBuZXh0LnByb3BlcnRpZXMsIG5leHQucGF0dGVyblByb3BlcnRpZXMsIG5leHQuZGVwZW5kZW5jaWVzLCBuZXh0LmRlcGVuZGVudFNjaGVtYXMpO1xuICAgICAgICAgICAgICAgIGNvbGxlY3RBcnJheUVudHJpZXMobmV4dC5hbnlPZiwgbmV4dC5hbGxPZiwgbmV4dC5vbmVPZiwgbmV4dC5wcmVmaXhJdGVtcyk7XG4gICAgICAgICAgICAgICAgY29sbGVjdEVudHJ5T3JBcnJheUVudHJpZXMobmV4dC5pdGVtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0ID0gdG9XYWxrLnBvcCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICBnZXRTY2hlbWFGcm9tUHJvcGVydHkocmVzb3VyY2UsIGRvY3VtZW50KSB7XG4gICAgICAgIGlmIChkb2N1bWVudC5yb290Py50eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwIG9mIGRvY3VtZW50LnJvb3QucHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIGlmIChwLmtleU5vZGUudmFsdWUgPT09ICckc2NoZW1hJyAmJiBwLnZhbHVlTm9kZT8udHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNjaGVtYUlkID0gcC52YWx1ZU5vZGUudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHRTZXJ2aWNlICYmICEvXlxcd1tcXHdcXGQrLi1dKjovLnRlc3Qoc2NoZW1hSWQpKSB7IC8vIGhhcyBzY2hlbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYUlkID0gdGhpcy5jb250ZXh0U2VydmljZS5yZXNvbHZlUmVsYXRpdmVQYXRoKHNjaGVtYUlkLCByZXNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjaGVtYUlkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXRBc3NvY2lhdGVkU2NoZW1hcyhyZXNvdXJjZSkge1xuICAgICAgICBjb25zdCBzZWVuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgY29uc3Qgc2NoZW1hcyA9IFtdO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkUmVzb3VyY2UgPSBub3JtYWxpemVSZXNvdXJjZUZvck1hdGNoaW5nKHJlc291cmNlKTtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiB0aGlzLmZpbGVQYXR0ZXJuQXNzb2NpYXRpb25zKSB7XG4gICAgICAgICAgICBpZiAoZW50cnkubWF0Y2hlc1BhdHRlcm4obm9ybWFsaXplZFJlc291cmNlKSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc2NoZW1hSWQgb2YgZW50cnkuZ2V0VVJJcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VlbltzY2hlbWFJZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYXMucHVzaChzY2hlbWFJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWVuW3NjaGVtYUlkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjaGVtYXM7XG4gICAgfVxuICAgIGdldFNjaGVtYVVSSXNGb3JSZXNvdXJjZShyZXNvdXJjZSwgZG9jdW1lbnQpIHtcbiAgICAgICAgbGV0IHNjaGVtZUlkID0gZG9jdW1lbnQgJiYgdGhpcy5nZXRTY2hlbWFGcm9tUHJvcGVydHkocmVzb3VyY2UsIGRvY3VtZW50KTtcbiAgICAgICAgaWYgKHNjaGVtZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gW3NjaGVtZUlkXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRBc3NvY2lhdGVkU2NoZW1hcyhyZXNvdXJjZSk7XG4gICAgfVxuICAgIGdldFNjaGVtYUZvclJlc291cmNlKHJlc291cmNlLCBkb2N1bWVudCkge1xuICAgICAgICBpZiAoZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIC8vIGZpcnN0IHVzZSAkc2NoZW1hIGlmIHByZXNlbnRcbiAgICAgICAgICAgIGxldCBzY2hlbWVJZCA9IHRoaXMuZ2V0U2NoZW1hRnJvbVByb3BlcnR5KHJlc291cmNlLCBkb2N1bWVudCk7XG4gICAgICAgICAgICBpZiAoc2NoZW1lSWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9IG5vcm1hbGl6ZUlkKHNjaGVtZUlkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPckFkZFNjaGVtYUhhbmRsZShpZCkuZ2V0UmVzb2x2ZWRTY2hlbWEoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jYWNoZWRTY2hlbWFGb3JSZXNvdXJjZSAmJiB0aGlzLmNhY2hlZFNjaGVtYUZvclJlc291cmNlLnJlc291cmNlID09PSByZXNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVkU2NoZW1hRm9yUmVzb3VyY2UucmVzb2x2ZWRTY2hlbWE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2NoZW1hcyA9IHRoaXMuZ2V0QXNzb2NpYXRlZFNjaGVtYXMocmVzb3VyY2UpO1xuICAgICAgICBjb25zdCByZXNvbHZlZFNjaGVtYSA9IHNjaGVtYXMubGVuZ3RoID4gMCA/IHRoaXMuY3JlYXRlQ29tYmluZWRTY2hlbWEocmVzb3VyY2UsIHNjaGVtYXMpLmdldFJlc29sdmVkU2NoZW1hKCkgOiB0aGlzLnByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLmNhY2hlZFNjaGVtYUZvclJlc291cmNlID0geyByZXNvdXJjZSwgcmVzb2x2ZWRTY2hlbWEgfTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVkU2NoZW1hO1xuICAgIH1cbiAgICBjcmVhdGVDb21iaW5lZFNjaGVtYShyZXNvdXJjZSwgc2NoZW1hSWRzKSB7XG4gICAgICAgIGlmIChzY2hlbWFJZHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRPckFkZFNjaGVtYUhhbmRsZShzY2hlbWFJZHNbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY29tYmluZWRTY2hlbWFJZCA9ICdzY2hlbWFzZXJ2aWNlOi8vY29tYmluZWRTY2hlbWEvJyArIGVuY29kZVVSSUNvbXBvbmVudChyZXNvdXJjZSk7XG4gICAgICAgICAgICBjb25zdCBjb21iaW5lZFNjaGVtYSA9IHtcbiAgICAgICAgICAgICAgICBhbGxPZjogc2NoZW1hSWRzLm1hcChzY2hlbWFJZCA9PiAoeyAkcmVmOiBzY2hlbWFJZCB9KSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRTY2hlbWFIYW5kbGUoY29tYmluZWRTY2hlbWFJZCwgY29tYmluZWRTY2hlbWEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldE1hdGNoaW5nU2NoZW1hcyhkb2N1bWVudCwganNvbkRvY3VtZW50LCBzY2hlbWEpIHtcbiAgICAgICAgaWYgKHNjaGVtYSkge1xuICAgICAgICAgICAgY29uc3QgaWQgPSBzY2hlbWEuaWQgfHwgKCdzY2hlbWFzZXJ2aWNlOi8vdW50aXRsZWQvbWF0Y2hpbmdTY2hlbWFzLycgKyBqc29uU2NoZW1hU2VydmljZV9pZENvdW50ZXIrKyk7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGUgPSB0aGlzLmFkZFNjaGVtYUhhbmRsZShpZCwgc2NoZW1hKTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGUuZ2V0UmVzb2x2ZWRTY2hlbWEoKS50aGVuKHJlc29sdmVkU2NoZW1hID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ganNvbkRvY3VtZW50LmdldE1hdGNoaW5nU2NoZW1hcyhyZXNvbHZlZFNjaGVtYS5zY2hlbWEpLmZpbHRlcihzID0+ICFzLmludmVydGVkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNjaGVtYUZvclJlc291cmNlKGRvY3VtZW50LnVyaSwganNvbkRvY3VtZW50KS50aGVuKHNjaGVtYSA9PiB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpzb25Eb2N1bWVudC5nZXRNYXRjaGluZ1NjaGVtYXMoc2NoZW1hLnNjaGVtYSkuZmlsdGVyKHMgPT4gIXMuaW52ZXJ0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5sZXQganNvblNjaGVtYVNlcnZpY2VfaWRDb3VudGVyID0gMDtcbmZ1bmN0aW9uIG5vcm1hbGl6ZUlkKGlkKSB7XG4gICAgLy8gcmVtb3ZlIHRyYWlsaW5nICcjJywgbm9ybWFsaXplIGRyaXZlIGNhcGl0YWxpemF0aW9uXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGVzbV9VUkkucGFyc2UoaWQpLnRvU3RyaW5nKHRydWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplUmVzb3VyY2VGb3JNYXRjaGluZyhyZXNvdXJjZSkge1xuICAgIC8vIHJlbW92ZSBxdWVyaWVzIGFuZCBmcmFnbWVudHMsIG5vcm1hbGl6ZSBkcml2ZSBjYXBpdGFsaXphdGlvblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBlc21fVVJJLnBhcnNlKHJlc291cmNlKS53aXRoKHsgZnJhZ21lbnQ6IG51bGwsIHF1ZXJ5OiBudWxsIH0pLnRvU3RyaW5nKHRydWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gcmVzb3VyY2U7XG4gICAgfVxufVxuZnVuY3Rpb24gdG9EaXNwbGF5U3RyaW5nKHVybCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHVyaSA9IGVzbV9VUkkucGFyc2UodXJsKTtcbiAgICAgICAgaWYgKHVyaS5zY2hlbWUgPT09ICdmaWxlJykge1xuICAgICAgICAgICAgcmV0dXJuIHVyaS5mc1BhdGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaWdub3JlXG4gICAgfVxuICAgIHJldHVybiB1cmw7XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL2xpYi9lc20vc2VydmljZXMvanNvbkZvbGRpbmcuanNcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cbmZ1bmN0aW9uIGdldEZvbGRpbmdSYW5nZXMoZG9jdW1lbnQsIGNvbnRleHQpIHtcbiAgICBjb25zdCByYW5nZXMgPSBbXTtcbiAgICBjb25zdCBuZXN0aW5nTGV2ZWxzID0gW107XG4gICAgY29uc3Qgc3RhY2sgPSBbXTtcbiAgICBsZXQgcHJldlN0YXJ0ID0gLTE7XG4gICAgY29uc3Qgc2Nhbm5lciA9IG1haW5fY3JlYXRlU2Nhbm5lcihkb2N1bWVudC5nZXRUZXh0KCksIGZhbHNlKTtcbiAgICBsZXQgdG9rZW4gPSBzY2FubmVyLnNjYW4oKTtcbiAgICBmdW5jdGlvbiBhZGRSYW5nZShyYW5nZSkge1xuICAgICAgICByYW5nZXMucHVzaChyYW5nZSk7XG4gICAgICAgIG5lc3RpbmdMZXZlbHMucHVzaChzdGFjay5sZW5ndGgpO1xuICAgIH1cbiAgICB3aGlsZSAodG9rZW4gIT09IDE3IC8qIFN5bnRheEtpbmQuRU9GICovKSB7XG4gICAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgICAgIGNhc2UgMSAvKiBTeW50YXhLaW5kLk9wZW5CcmFjZVRva2VuICovOlxuICAgICAgICAgICAgY2FzZSAzIC8qIFN5bnRheEtpbmQuT3BlbkJyYWNrZXRUb2tlbiAqLzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0TGluZSA9IGRvY3VtZW50LnBvc2l0aW9uQXQoc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpKS5saW5lO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0geyBzdGFydExpbmUsIGVuZExpbmU6IHN0YXJ0TGluZSwga2luZDogdG9rZW4gPT09IDEgLyogU3ludGF4S2luZC5PcGVuQnJhY2VUb2tlbiAqLyA/ICdvYmplY3QnIDogJ2FycmF5JyB9O1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gocmFuZ2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAyIC8qIFN5bnRheEtpbmQuQ2xvc2VCcmFjZVRva2VuICovOlxuICAgICAgICAgICAgY2FzZSA0IC8qIFN5bnRheEtpbmQuQ2xvc2VCcmFja2V0VG9rZW4gKi86IHtcbiAgICAgICAgICAgICAgICBjb25zdCBraW5kID0gdG9rZW4gPT09IDIgLyogU3ludGF4S2luZC5DbG9zZUJyYWNlVG9rZW4gKi8gPyAnb2JqZWN0JyA6ICdhcnJheSc7XG4gICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDAgJiYgc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0ua2luZCA9PT0ga2luZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5lID0gZG9jdW1lbnQucG9zaXRpb25BdChzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkpLmxpbmU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZSAmJiBsaW5lID4gcmFuZ2Uuc3RhcnRMaW5lICsgMSAmJiBwcmV2U3RhcnQgIT09IHJhbmdlLnN0YXJ0TGluZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UuZW5kTGluZSA9IGxpbmUgLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldlN0YXJ0ID0gcmFuZ2Uuc3RhcnRMaW5lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAxMyAvKiBTeW50YXhLaW5kLkJsb2NrQ29tbWVudFRyaXZpYSAqLzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0TGluZSA9IGRvY3VtZW50LnBvc2l0aW9uQXQoc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpKS5saW5lO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZExpbmUgPSBkb2N1bWVudC5wb3NpdGlvbkF0KHNjYW5uZXIuZ2V0VG9rZW5PZmZzZXQoKSArIHNjYW5uZXIuZ2V0VG9rZW5MZW5ndGgoKSkubGluZTtcbiAgICAgICAgICAgICAgICBpZiAoc2Nhbm5lci5nZXRUb2tlbkVycm9yKCkgPT09IDEgLyogU2NhbkVycm9yLlVuZXhwZWN0ZWRFbmRPZkNvbW1lbnQgKi8gJiYgc3RhcnRMaW5lICsgMSA8IGRvY3VtZW50LmxpbmVDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBzY2FubmVyLnNldFBvc2l0aW9uKGRvY3VtZW50Lm9mZnNldEF0KFBvc2l0aW9uLmNyZWF0ZShzdGFydExpbmUgKyAxLCAwKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0TGluZSA8IGVuZExpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFJhbmdlKHsgc3RhcnRMaW5lLCBlbmRMaW5lLCBraW5kOiBGb2xkaW5nUmFuZ2VLaW5kLkNvbW1lbnQgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2U3RhcnQgPSBzdGFydExpbmU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDEyIC8qIFN5bnRheEtpbmQuTGluZUNvbW1lbnRUcml2aWEgKi86IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gZG9jdW1lbnQuZ2V0VGV4dCgpLnN1YnN0cihzY2FubmVyLmdldFRva2VuT2Zmc2V0KCksIHNjYW5uZXIuZ2V0VG9rZW5MZW5ndGgoKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbSA9IHRleHQubWF0Y2goL15cXC9cXC9cXHMqIyhyZWdpb25cXGIpfChlbmRyZWdpb25cXGIpLyk7XG4gICAgICAgICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGluZSA9IGRvY3VtZW50LnBvc2l0aW9uQXQoc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpKS5saW5lO1xuICAgICAgICAgICAgICAgICAgICBpZiAobVsxXSkgeyAvLyBzdGFydCBwYXR0ZXJuIG1hdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IHsgc3RhcnRMaW5lOiBsaW5lLCBlbmRMaW5lOiBsaW5lLCBraW5kOiBGb2xkaW5nUmFuZ2VLaW5kLlJlZ2lvbiB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChyYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaSA9IHN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaSA+PSAwICYmIHN0YWNrW2ldLmtpbmQgIT09IEZvbGRpbmdSYW5nZUtpbmQuUmVnaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gc3RhY2tbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2subGVuZ3RoID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZSA+IHJhbmdlLnN0YXJ0TGluZSAmJiBwcmV2U3RhcnQgIT09IHJhbmdlLnN0YXJ0TGluZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZS5lbmRMaW5lID0gbGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2U3RhcnQgPSByYW5nZS5zdGFydExpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRva2VuID0gc2Nhbm5lci5zY2FuKCk7XG4gICAgfVxuICAgIGNvbnN0IHJhbmdlTGltaXQgPSBjb250ZXh0ICYmIGNvbnRleHQucmFuZ2VMaW1pdDtcbiAgICBpZiAodHlwZW9mIHJhbmdlTGltaXQgIT09ICdudW1iZXInIHx8IHJhbmdlcy5sZW5ndGggPD0gcmFuZ2VMaW1pdCkge1xuICAgICAgICByZXR1cm4gcmFuZ2VzO1xuICAgIH1cbiAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Lm9uUmFuZ2VMaW1pdEV4Y2VlZGVkKSB7XG4gICAgICAgIGNvbnRleHQub25SYW5nZUxpbWl0RXhjZWVkZWQoZG9jdW1lbnQudXJpKTtcbiAgICB9XG4gICAgY29uc3QgY291bnRzID0gW107XG4gICAgZm9yIChsZXQgbGV2ZWwgb2YgbmVzdGluZ0xldmVscykge1xuICAgICAgICBpZiAobGV2ZWwgPCAzMCkge1xuICAgICAgICAgICAgY291bnRzW2xldmVsXSA9IChjb3VudHNbbGV2ZWxdIHx8IDApICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgZW50cmllcyA9IDA7XG4gICAgbGV0IG1heExldmVsID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBuID0gY291bnRzW2ldO1xuICAgICAgICBpZiAobikge1xuICAgICAgICAgICAgaWYgKG4gKyBlbnRyaWVzID4gcmFuZ2VMaW1pdCkge1xuICAgICAgICAgICAgICAgIG1heExldmVsID0gaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVudHJpZXMgKz0gbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBsZXZlbCA9IG5lc3RpbmdMZXZlbHNbaV07XG4gICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBpZiAobGV2ZWwgPCBtYXhMZXZlbCB8fCAobGV2ZWwgPT09IG1heExldmVsICYmIGVudHJpZXMrKyA8IHJhbmdlTGltaXQpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocmFuZ2VzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3ZzY29kZS1qc29uLWxhbmd1YWdlc2VydmljZS9saWIvZXNtL3NlcnZpY2VzL2pzb25TZWxlY3Rpb25SYW5nZXMuanNcbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cbmZ1bmN0aW9uIGdldFNlbGVjdGlvblJhbmdlcyhkb2N1bWVudCwgcG9zaXRpb25zLCBkb2MpIHtcbiAgICBmdW5jdGlvbiBnZXRTZWxlY3Rpb25SYW5nZShwb3NpdGlvbikge1xuICAgICAgICBsZXQgb2Zmc2V0ID0gZG9jdW1lbnQub2Zmc2V0QXQocG9zaXRpb24pO1xuICAgICAgICBsZXQgbm9kZSA9IGRvYy5nZXROb2RlRnJvbU9mZnNldChvZmZzZXQsIHRydWUpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgICAgICAgICAgICAgICAgLy8gcmFuZ2Ugd2l0aG91dCBcIiwgWyBvciB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNTdGFydCA9IG5vZGUub2Zmc2V0ICsgMSwgY0VuZCA9IG5vZGUub2Zmc2V0ICsgbm9kZS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY1N0YXJ0IDwgY0VuZCAmJiBvZmZzZXQgPj0gY1N0YXJ0ICYmIG9mZnNldCA8PSBjRW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdSYW5nZShjU3RhcnQsIGNFbmQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdSYW5nZShub2RlLm9mZnNldCwgbm9kZS5vZmZzZXQgKyBub2RlLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bGwnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3Byb3BlcnR5JzpcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3UmFuZ2Uobm9kZS5vZmZzZXQsIG5vZGUub2Zmc2V0ICsgbm9kZS5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAncHJvcGVydHknIHx8IG5vZGUucGFyZW50ICYmIG5vZGUucGFyZW50LnR5cGUgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhZnRlckNvbW1hT2Zmc2V0ID0gZ2V0T2Zmc2V0QWZ0ZXJOZXh0VG9rZW4obm9kZS5vZmZzZXQgKyBub2RlLmxlbmd0aCwgNSAvKiBTeW50YXhLaW5kLkNvbW1hVG9rZW4gKi8pO1xuICAgICAgICAgICAgICAgIGlmIChhZnRlckNvbW1hT2Zmc2V0ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdSYW5nZShub2RlLm9mZnNldCwgYWZ0ZXJDb21tYU9mZnNldCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSByZXN1bHQubGVuZ3RoIC0gMTsgaW5kZXggPj0gMDsgaW5kZXgtLSkge1xuICAgICAgICAgICAgY3VycmVudCA9IFNlbGVjdGlvblJhbmdlLmNyZWF0ZShyZXN1bHRbaW5kZXhdLCBjdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBTZWxlY3Rpb25SYW5nZS5jcmVhdGUoUmFuZ2UuY3JlYXRlKHBvc2l0aW9uLCBwb3NpdGlvbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBuZXdSYW5nZShzdGFydCwgZW5kKSB7XG4gICAgICAgIHJldHVybiBSYW5nZS5jcmVhdGUoZG9jdW1lbnQucG9zaXRpb25BdChzdGFydCksIGRvY3VtZW50LnBvc2l0aW9uQXQoZW5kKSk7XG4gICAgfVxuICAgIGNvbnN0IHNjYW5uZXIgPSBtYWluX2NyZWF0ZVNjYW5uZXIoZG9jdW1lbnQuZ2V0VGV4dCgpLCB0cnVlKTtcbiAgICBmdW5jdGlvbiBnZXRPZmZzZXRBZnRlck5leHRUb2tlbihvZmZzZXQsIGV4cGVjdGVkVG9rZW4pIHtcbiAgICAgICAgc2Nhbm5lci5zZXRQb3NpdGlvbihvZmZzZXQpO1xuICAgICAgICBsZXQgdG9rZW4gPSBzY2FubmVyLnNjYW4oKTtcbiAgICAgICAgaWYgKHRva2VuID09PSBleHBlY3RlZFRva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpICsgc2Nhbm5lci5nZXRUb2tlbkxlbmd0aCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIHBvc2l0aW9ucy5tYXAoZ2V0U2VsZWN0aW9uUmFuZ2UpO1xufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3ZzY29kZS1qc29uLWxhbmd1YWdlc2VydmljZS9saWIvZXNtL3V0aWxzL2Zvcm1hdC5qc1xuXG5cbmZ1bmN0aW9uIHV0aWxzX2Zvcm1hdF9mb3JtYXQoZG9jdW1lbnRUb0Zvcm1hdCwgZm9ybWF0dGluZ09wdGlvbnMsIGZvcm1hdHRpbmdSYW5nZSkge1xuICAgIGxldCByYW5nZSA9IHVuZGVmaW5lZDtcbiAgICBpZiAoZm9ybWF0dGluZ1JhbmdlKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGRvY3VtZW50VG9Gb3JtYXQub2Zmc2V0QXQoZm9ybWF0dGluZ1JhbmdlLnN0YXJ0KTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZG9jdW1lbnRUb0Zvcm1hdC5vZmZzZXRBdChmb3JtYXR0aW5nUmFuZ2UuZW5kKSAtIG9mZnNldDtcbiAgICAgICAgcmFuZ2UgPSB7IG9mZnNldCwgbGVuZ3RoIH07XG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIHRhYlNpemU6IGZvcm1hdHRpbmdPcHRpb25zID8gZm9ybWF0dGluZ09wdGlvbnMudGFiU2l6ZSA6IDQsXG4gICAgICAgIGluc2VydFNwYWNlczogZm9ybWF0dGluZ09wdGlvbnM/Lmluc2VydFNwYWNlcyA9PT0gdHJ1ZSxcbiAgICAgICAgaW5zZXJ0RmluYWxOZXdsaW5lOiBmb3JtYXR0aW5nT3B0aW9ucz8uaW5zZXJ0RmluYWxOZXdsaW5lID09PSB0cnVlLFxuICAgICAgICBlb2w6ICdcXG4nLFxuICAgICAgICBrZWVwTGluZXM6IGZvcm1hdHRpbmdPcHRpb25zPy5rZWVwTGluZXMgPT09IHRydWVcbiAgICB9O1xuICAgIHJldHVybiBtYWluX2Zvcm1hdChkb2N1bWVudFRvRm9ybWF0LmdldFRleHQoKSwgcmFuZ2UsIG9wdGlvbnMpLm1hcChlZGl0ID0+IHtcbiAgICAgICAgcmV0dXJuIFRleHRFZGl0LnJlcGxhY2UoUmFuZ2UuY3JlYXRlKGRvY3VtZW50VG9Gb3JtYXQucG9zaXRpb25BdChlZGl0Lm9mZnNldCksIGRvY3VtZW50VG9Gb3JtYXQucG9zaXRpb25BdChlZGl0Lm9mZnNldCArIGVkaXQubGVuZ3RoKSksIGVkaXQuY29udGVudCk7XG4gICAgfSk7XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL2xpYi9lc20vdXRpbHMvcHJvcGVydHlUcmVlLmpzXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbnZhciBDb250YWluZXI7XG4oZnVuY3Rpb24gKENvbnRhaW5lcikge1xuICAgIENvbnRhaW5lcltDb250YWluZXJbXCJPYmplY3RcIl0gPSAwXSA9IFwiT2JqZWN0XCI7XG4gICAgQ29udGFpbmVyW0NvbnRhaW5lcltcIkFycmF5XCJdID0gMV0gPSBcIkFycmF5XCI7XG59KShDb250YWluZXIgfHwgKENvbnRhaW5lciA9IHt9KSk7XG5jbGFzcyBQcm9wZXJ0eVRyZWUge1xuICAgIGNvbnN0cnVjdG9yKHByb3BlcnR5TmFtZSwgYmVnaW5uaW5nTGluZU51bWJlcikge1xuICAgICAgICB0aGlzLnByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZSA/PyAnJztcbiAgICAgICAgdGhpcy5iZWdpbm5pbmdMaW5lTnVtYmVyID0gYmVnaW5uaW5nTGluZU51bWJlcjtcbiAgICAgICAgdGhpcy5jaGlsZHJlblByb3BlcnRpZXMgPSBbXTtcbiAgICAgICAgdGhpcy5sYXN0UHJvcGVydHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ub0tleU5hbWUgPSBmYWxzZTtcbiAgICB9XG4gICAgYWRkQ2hpbGRQcm9wZXJ0eShjaGlsZFByb3BlcnR5KSB7XG4gICAgICAgIGNoaWxkUHJvcGVydHkucGFyZW50ID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5Qcm9wZXJ0aWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxldCBpbnNlcnRpb25JbmRleCA9IDA7XG4gICAgICAgICAgICBpZiAoY2hpbGRQcm9wZXJ0eS5ub0tleU5hbWUpIHtcbiAgICAgICAgICAgICAgICBpbnNlcnRpb25JbmRleCA9IHRoaXMuY2hpbGRyZW5Qcm9wZXJ0aWVzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluc2VydGlvbkluZGV4ID0gYmluYXJ5U2VhcmNoT25Qcm9wZXJ0eUFycmF5KHRoaXMuY2hpbGRyZW5Qcm9wZXJ0aWVzLCBjaGlsZFByb3BlcnR5LCBjb21wYXJlUHJvcGVydGllcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5zZXJ0aW9uSW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0aW9uSW5kZXggPSAoaW5zZXJ0aW9uSW5kZXggKiAtMSkgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlblByb3BlcnRpZXMuc3BsaWNlKGluc2VydGlvbkluZGV4LCAwLCBjaGlsZFByb3BlcnR5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5Qcm9wZXJ0aWVzLnB1c2goY2hpbGRQcm9wZXJ0eSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoaWxkUHJvcGVydHk7XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcGFyZVByb3BlcnRpZXMocHJvcGVydHlUcmVlMSwgcHJvcGVydHlUcmVlMikge1xuICAgIGNvbnN0IHByb3BlcnR5TmFtZTEgPSBwcm9wZXJ0eVRyZWUxLnByb3BlcnR5TmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IHByb3BlcnR5TmFtZTIgPSBwcm9wZXJ0eVRyZWUyLnByb3BlcnR5TmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChwcm9wZXJ0eU5hbWUxIDwgcHJvcGVydHlOYW1lMikge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb3BlcnR5TmFtZTEgPiBwcm9wZXJ0eU5hbWUyKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGJpbmFyeVNlYXJjaE9uUHJvcGVydHlBcnJheShwcm9wZXJ0eVRyZWVBcnJheSwgcHJvcGVydHlUcmVlLCBjb21wYXJlX2ZuKSB7XG4gICAgY29uc3QgcHJvcGVydHlOYW1lID0gcHJvcGVydHlUcmVlLnByb3BlcnR5TmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IGZpcnN0UHJvcGVydHlJbkFycmF5TmFtZSA9IHByb3BlcnR5VHJlZUFycmF5WzBdLnByb3BlcnR5TmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IGxhc3RQcm9wZXJ0eUluQXJyYXlOYW1lID0gcHJvcGVydHlUcmVlQXJyYXlbcHJvcGVydHlUcmVlQXJyYXkubGVuZ3RoIC0gMV0ucHJvcGVydHlOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKHByb3BlcnR5TmFtZSA8IGZpcnN0UHJvcGVydHlJbkFycmF5TmFtZSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYgKHByb3BlcnR5TmFtZSA+IGxhc3RQcm9wZXJ0eUluQXJyYXlOYW1lKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eVRyZWVBcnJheS5sZW5ndGg7XG4gICAgfVxuICAgIGxldCBtID0gMDtcbiAgICBsZXQgbiA9IHByb3BlcnR5VHJlZUFycmF5Lmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKG0gPD0gbikge1xuICAgICAgICBsZXQgayA9IChuICsgbSkgPj4gMTtcbiAgICAgICAgbGV0IGNtcCA9IGNvbXBhcmVfZm4ocHJvcGVydHlUcmVlLCBwcm9wZXJ0eVRyZWVBcnJheVtrXSk7XG4gICAgICAgIGlmIChjbXAgPiAwKSB7XG4gICAgICAgICAgICBtID0gayArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY21wIDwgMCkge1xuICAgICAgICAgICAgbiA9IGsgLSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC1tIC0gMTtcbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy92c2NvZGUtanNvbi1sYW5ndWFnZXNlcnZpY2UvbGliL2VzbS91dGlscy9zb3J0LmpzXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXG5cblxuZnVuY3Rpb24gc29ydChkb2N1bWVudFRvU29ydCwgZm9ybWF0dGluZ09wdGlvbnMpIHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAuLi5mb3JtYXR0aW5nT3B0aW9ucyxcbiAgICAgICAga2VlcExpbmVzOiBmYWxzZSwgLy8ga2VlcExpbmVzIG11c3QgYmUgZmFsc2Ugc28gdGhhdCB0aGUgcHJvcGVydGllcyBhcmUgb24gc2VwYXJhdGUgbGluZXMgZm9yIHRoZSBzb3J0aW5nXG4gICAgfTtcbiAgICBjb25zdCBmb3JtYXR0ZWRKc29uU3RyaW5nID0gbWFpbi8qIFRleHREb2N1bWVudCAqLy5WLmFwcGx5RWRpdHMoZG9jdW1lbnRUb1NvcnQsIHV0aWxzX2Zvcm1hdF9mb3JtYXQoZG9jdW1lbnRUb1NvcnQsIG9wdGlvbnMsIHVuZGVmaW5lZCkpO1xuICAgIGNvbnN0IGZvcm1hdHRlZEpzb25Eb2N1bWVudCA9IG1haW4vKiBUZXh0RG9jdW1lbnQgKi8uVi5jcmVhdGUoJ3Rlc3Q6Ly90ZXN0Lmpzb24nLCAnanNvbicsIDAsIGZvcm1hdHRlZEpzb25TdHJpbmcpO1xuICAgIGNvbnN0IGpzb25Qcm9wZXJ0eVRyZWUgPSBmaW5kSnNvbmNQcm9wZXJ0eVRyZWUoZm9ybWF0dGVkSnNvbkRvY3VtZW50KTtcbiAgICBjb25zdCBzb3J0ZWRKc29uRG9jdW1lbnQgPSBzb3J0SnNvbmNEb2N1bWVudChmb3JtYXR0ZWRKc29uRG9jdW1lbnQsIGpzb25Qcm9wZXJ0eVRyZWUpO1xuICAgIGNvbnN0IGVkaXRzID0gdXRpbHNfZm9ybWF0X2Zvcm1hdChzb3J0ZWRKc29uRG9jdW1lbnQsIG9wdGlvbnMsIHVuZGVmaW5lZCk7XG4gICAgY29uc3Qgc29ydGVkQW5kRm9ybWF0dGVkSnNvbkRvY3VtZW50ID0gbWFpbi8qIFRleHREb2N1bWVudCAqLy5WLmFwcGx5RWRpdHMoc29ydGVkSnNvbkRvY3VtZW50LCBlZGl0cyk7XG4gICAgcmV0dXJuIFtUZXh0RWRpdC5yZXBsYWNlKFJhbmdlLmNyZWF0ZShQb3NpdGlvbi5jcmVhdGUoMCwgMCksIGRvY3VtZW50VG9Tb3J0LnBvc2l0aW9uQXQoZG9jdW1lbnRUb1NvcnQuZ2V0VGV4dCgpLmxlbmd0aCkpLCBzb3J0ZWRBbmRGb3JtYXR0ZWRKc29uRG9jdW1lbnQpXTtcbn1cbmZ1bmN0aW9uIGZpbmRKc29uY1Byb3BlcnR5VHJlZShmb3JtYXR0ZWREb2N1bWVudCkge1xuICAgIGNvbnN0IGZvcm1hdHRlZFN0cmluZyA9IGZvcm1hdHRlZERvY3VtZW50LmdldFRleHQoKTtcbiAgICBjb25zdCBzY2FubmVyID0gbWFpbl9jcmVhdGVTY2FubmVyKGZvcm1hdHRlZFN0cmluZywgZmFsc2UpO1xuICAgIC8vIFRoZSB0cmVlIHRoYXQgd2lsbCBiZSByZXR1cm5lZFxuICAgIGxldCByb290VHJlZSA9IG5ldyBQcm9wZXJ0eVRyZWUoKTtcbiAgICAvLyBUaGUgdHJlZSB3aGVyZSB0aGUgY3VycmVudCBwcm9wZXJ0aWVzIGNhbiBiZSBhZGRlZCBhcyBjaGlsZHJlblxuICAgIGxldCBjdXJyZW50VHJlZSA9IHJvb3RUcmVlO1xuICAgIC8vIFRoZSB0cmVlIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBwcm9wZXJ0eSBhbmFseXplZFxuICAgIGxldCBjdXJyZW50UHJvcGVydHkgPSByb290VHJlZTtcbiAgICAvLyBUaGUgdHJlZSByZXByZXNlbnRpbmcgdGhlIHByZXZpb3VzIHByb3BlcnR5IGFuYWx5emVkXG4gICAgbGV0IGxhc3RQcm9wZXJ0eSA9IHJvb3RUcmVlO1xuICAgIC8vIFRoZSBjdXJyZW50IHNjYW5uZWQgdG9rZW5cbiAgICBsZXQgdG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgLy8gTGluZSBudW1iZXIgb2YgdGhlIGxhc3QgdG9rZW4gZm91bmRcbiAgICBsZXQgbGFzdFRva2VuTGluZSA9IDA7XG4gICAgLy8gVG90YWwgbnVtYmVyIG9mIGNoYXJhY3RlcnMgb24gdGhlIGxpbmVzIHByaW9yIHRvIGN1cnJlbnQgbGluZSBcbiAgICBsZXQgbnVtYmVyT2ZDaGFyYWN0ZXJzT25QcmV2aW91c0xpbmVzID0gMDtcbiAgICAvLyBUaGUgbGFzdCB0b2tlbiBzY2FubmVkIHRoYXQgaXMgbm90IHRyaXZpYWwsIG5vciBhIGNvbW1lbnRcbiAgICBsZXQgbGFzdE5vblRyaXZpYU5vbkNvbW1lbnRUb2tlbiA9IHVuZGVmaW5lZDtcbiAgICAvLyBUaGUgc2Vjb25kIHRvIGxhc3QgdG9rZW4gc2Nhbm5lZCB0aGF0IGlzIG5vdCB0cml2aWFsLCBub3IgYSBjb21tZW50XG4gICAgbGV0IHNlY29uZFRvTGFzdE5vblRyaXZpYU5vbkNvbW1lbnRUb2tlbiA9IHVuZGVmaW5lZDtcbiAgICAvLyBMaW5lIG51bWJlciBvZiBsYXN0IHRva2VuIHRoYXQgaXMgbm90IHRyaXZpYWwsIG5vciBhIGNvbW1lbnRcbiAgICBsZXQgbGluZU9mTGFzdE5vblRyaXZpYU5vbkNvbW1lbnRUb2tlbiA9IC0xO1xuICAgIC8vIEVuZCBpbmRleCBvbiBpdHMgbGluZSBvZiBsYXN0IHRva2VuIHRoYXQgaXMgbm90IHRyaXZpYWwsIG5vciBhIGNvbW1lbnRcbiAgICBsZXQgZW5kSW5kZXhPZkxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPSAtMTtcbiAgICAvLyBMaW5lIG51bWJlciBvZiB0aGUgc3RhcnQgb2YgdGhlIHJhbmdlIG9mIGN1cnJlbnQvbmV4dCBwcm9wZXJ0eVxuICAgIGxldCBiZWdpbm5pbmdMaW5lTnVtYmVyID0gMDtcbiAgICAvLyBMaW5lIG51bWJlciBvZiB0aGUgZW5kIG9mIHRoZSByYW5nZSBvZiBjdXJyZW50L25leHQgcHJvcGVydHlcbiAgICBsZXQgZW5kTGluZU51bWJlciA9IDA7XG4gICAgLy8gU3RhY2sgaW5kaWNhdGluZyB3aGV0aGVyIHdlIGFyZSBpbnNpZGUgb2YgYW4gb2JqZWN0IG9yIGFuIGFycmF5XG4gICAgbGV0IGN1cnJlbnRDb250YWluZXJTdGFjayA9IFtdO1xuICAgIC8vIEJvb2xlYW4gaW5kaWNhdGluZyB0aGF0IHRoZSBjdXJyZW50IHByb3BlcnR5IGVuZCBsaW5lIG51bWJlciBuZWVkcyB0byBiZSB1cGRhdGVkLiBVc2VkIG9ubHkgd2hlbiBibG9jayBjb21tZW50cyBhcmUgZW5jb3VudGVyZWQuXG4gICAgbGV0IHVwZGF0ZUxhc3RQcm9wZXJ0eUVuZExpbmVOdW1iZXIgPSBmYWxzZTtcbiAgICAvLyBCb29sZWFuIGluZGljYXRpbmcgdGhhdCB0aGUgYmVnaW5uaW5nIGxpbmUgbnVtYmVyIHNob3VsZCBiZSB1cGRhdGVkLiBVc2VkIG9ubHkgd2hlbiBibG9jayBjb21tZW50cyBhcmUgZW5jb3VudGVyZWQuIFxuICAgIGxldCB1cGRhdGVCZWdpbm5pbmdMaW5lTnVtYmVyID0gZmFsc2U7XG4gICAgd2hpbGUgKCh0b2tlbiA9IHNjYW5uZXIuc2NhbigpKSAhPT0gMTcgLyogU3ludGF4S2luZC5FT0YgKi8pIHtcbiAgICAgICAgLy8gSW4gdGhlIGNhc2Ugd2hlbiBhIGJsb2NrIGNvbW1lbnQgaGFzIGJlZW4gZW5jb3VudGVyZWQgdGhhdCBzdGFydHMgb24gdGhlIHNhbWUgbGluZSBhcyB0aGUgY29tbWEgZW5kaW5nIGEgcHJvcGVydHksIHVwZGF0ZSB0aGUgZW5kIGxpbmUgb2YgdGhhdFxuICAgICAgICAvLyBwcm9wZXJ0eSBzbyB0aGF0IGl0IGNvdmVycyB0aGUgYmxvY2sgY29tbWVudC4gRm9yIGV4YW1wbGUsIGlmIHdlIGhhdmU6IFxuICAgICAgICAvLyAxLiBcImtleVwiIDoge30sIC8qIHNvbWUgYmxvY2tcbiAgICAgICAgLy8gMi4gY29tbWVudCAqL1xuICAgICAgICAvLyBUaGVuLCB0aGUgZW5kIGxpbmUgb2YgdGhlIHByb3BlcnR5IFwia2V5XCIgc2hvdWxkIGJlIGxpbmUgMiBub3QgbGluZSAxXG4gICAgICAgIGlmICh1cGRhdGVMYXN0UHJvcGVydHlFbmRMaW5lTnVtYmVyID09PSB0cnVlXG4gICAgICAgICAgICAmJiB0b2tlbiAhPT0gMTQgLyogU3ludGF4S2luZC5MaW5lQnJlYWtUcml2aWEgKi9cbiAgICAgICAgICAgICYmIHRva2VuICE9PSAxNSAvKiBTeW50YXhLaW5kLlRyaXZpYSAqL1xuICAgICAgICAgICAgJiYgdG9rZW4gIT09IDEyIC8qIFN5bnRheEtpbmQuTGluZUNvbW1lbnRUcml2aWEgKi9cbiAgICAgICAgICAgICYmIHRva2VuICE9PSAxMyAvKiBTeW50YXhLaW5kLkJsb2NrQ29tbWVudFRyaXZpYSAqL1xuICAgICAgICAgICAgJiYgY3VycmVudFByb3BlcnR5LmVuZExpbmVOdW1iZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IGVuZExpbmVOdW1iZXIgPSBzY2FubmVyLmdldFRva2VuU3RhcnRMaW5lKCk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGVuZCBsaW5lIG51bWJlciBpbiB0aGUgY2FzZSB3aGVuIHRoZSBsYXN0IHByb3BlcnR5IHZpc2l0ZWQgaXMgYSBjb250YWluZXIgKG9iamVjdCBvciBhcnJheSlcbiAgICAgICAgICAgIGlmIChzZWNvbmRUb0xhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPT09IDIgLyogU3ludGF4S2luZC5DbG9zZUJyYWNlVG9rZW4gKi9cbiAgICAgICAgICAgICAgICB8fCBzZWNvbmRUb0xhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPT09IDQgLyogU3ludGF4S2luZC5DbG9zZUJyYWNrZXRUb2tlbiAqLykge1xuICAgICAgICAgICAgICAgIGxhc3RQcm9wZXJ0eS5lbmRMaW5lTnVtYmVyID0gZW5kTGluZU51bWJlciAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGVuZCBsaW5lIG51bWJlciBpbiB0aGUgY2FzZSB3aGVuIHRoZSBsYXN0IHByb3BlcnR5IHZpc2l0ZWQgaXMgYSBzaW1wbGUgcHJvcGVydHkgXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UHJvcGVydHkuZW5kTGluZU51bWJlciA9IGVuZExpbmVOdW1iZXIgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmVnaW5uaW5nTGluZU51bWJlciA9IGVuZExpbmVOdW1iZXI7XG4gICAgICAgICAgICB1cGRhdGVMYXN0UHJvcGVydHlFbmRMaW5lTnVtYmVyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2hlbiBhIGJsb2NrIGNvbW1lbnQgZm9sbG93cyBhbiBvcGVuIGJyYWNlIG9yIGFuIG9wZW4gYnJhY2tldCwgdGhhdCBibG9jayBjb21tZW50IHNob3VsZCBiZSBhc3NvY2lhdGVkIHRvIHRoYXQgYnJhY2Ugb3IgYnJhY2tldCwgbm90IHRoZSBwcm9wZXJ0eSBiZWxvdyBpdC4gRm9yIGV4YW1wbGUsIGZvcjpcbiAgICAgICAgLy8gMS4geyAvKlxuICAgICAgICAvLyAyLiAuLi4gKi9cbiAgICAgICAgLy8gMy4gXCJrZXlcIiA6IHt9XG4gICAgICAgIC8vIDQuIH1cbiAgICAgICAgLy8gSW5zdGVhZCBvZiBhc3NvY2lhdGluZyB0aGUgYmxvY2sgY29tbWVudCB0byB0aGUgcHJvcGVydHkgb24gbGluZSAzLCBpdCBpcyBhc3NvY2lhdGUgdG8gdGhlIHByb3BlcnR5IG9uIGxpbmUgMVxuICAgICAgICBpZiAodXBkYXRlQmVnaW5uaW5nTGluZU51bWJlciA9PT0gdHJ1ZVxuICAgICAgICAgICAgJiYgdG9rZW4gIT09IDE0IC8qIFN5bnRheEtpbmQuTGluZUJyZWFrVHJpdmlhICovXG4gICAgICAgICAgICAmJiB0b2tlbiAhPT0gMTUgLyogU3ludGF4S2luZC5Ucml2aWEgKi9cbiAgICAgICAgICAgICYmIHRva2VuICE9PSAxMiAvKiBTeW50YXhLaW5kLkxpbmVDb21tZW50VHJpdmlhICovXG4gICAgICAgICAgICAmJiB0b2tlbiAhPT0gMTMgLyogU3ludGF4S2luZC5CbG9ja0NvbW1lbnRUcml2aWEgKi8pIHtcbiAgICAgICAgICAgIGJlZ2lubmluZ0xpbmVOdW1iZXIgPSBzY2FubmVyLmdldFRva2VuU3RhcnRMaW5lKCk7XG4gICAgICAgICAgICB1cGRhdGVCZWdpbm5pbmdMaW5lTnVtYmVyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBvbiBhbGwgdGhlIHByZXZpb3VzIGxpbmVzIGVhY2ggdGltZSB0aGUgbmV3IHRva2VuIGlzIG9uIGEgZGlmZmVyZW50IGxpbmUgdG8gdGhlIHByZXZpb3VzIHRva2VuXG4gICAgICAgIGlmIChzY2FubmVyLmdldFRva2VuU3RhcnRMaW5lKCkgIT09IGxhc3RUb2tlbkxpbmUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBsYXN0VG9rZW5MaW5lOyBpIDwgc2Nhbm5lci5nZXRUb2tlblN0YXJ0TGluZSgpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGhPZkxpbmUgPSBmb3JtYXR0ZWREb2N1bWVudC5nZXRUZXh0KFJhbmdlLmNyZWF0ZShQb3NpdGlvbi5jcmVhdGUoaSwgMCksIFBvc2l0aW9uLmNyZWF0ZShpICsgMSwgMCkpKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbnVtYmVyT2ZDaGFyYWN0ZXJzT25QcmV2aW91c0xpbmVzID0gbnVtYmVyT2ZDaGFyYWN0ZXJzT25QcmV2aW91c0xpbmVzICsgbGVuZ3RoT2ZMaW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdFRva2VuTGluZSA9IHNjYW5uZXIuZ2V0VG9rZW5TdGFydExpbmUoKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgICAgICAvLyBXaGVuIGEgc3RyaW5nIGlzIGZvdW5kLCBpZiBpdCBmb2xsb3dzIGFuIG9wZW4gYnJhY2Ugb3IgYSBjb21tYSB0b2tlbiBhbmQgaXQgaXMgd2l0aGluIGFuIG9iamVjdCwgdGhlbiBpdCBjb3JyZXNwb25kcyB0byBhIGtleSBuYW1lLCBub3QgYSBzaW1wbGUgc3RyaW5nXG4gICAgICAgICAgICBjYXNlIDEwIC8qIFN5bnRheEtpbmQuU3RyaW5nTGl0ZXJhbCAqLzoge1xuICAgICAgICAgICAgICAgIGlmICgobGFzdE5vblRyaXZpYU5vbkNvbW1lbnRUb2tlbiA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIHx8IGxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPT09IDEgLyogU3ludGF4S2luZC5PcGVuQnJhY2VUb2tlbiAqL1xuICAgICAgICAgICAgICAgICAgICB8fCAobGFzdE5vblRyaXZpYU5vbkNvbW1lbnRUb2tlbiA9PT0gNSAvKiBTeW50YXhLaW5kLkNvbW1hVG9rZW4gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICYmIGN1cnJlbnRDb250YWluZXJTdGFja1tjdXJyZW50Q29udGFpbmVyU3RhY2subGVuZ3RoIC0gMV0gPT09IENvbnRhaW5lci5PYmplY3QpKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiB0aGF0IGNhc2UgY3JlYXRlIHRoZSBjaGlsZCBwcm9wZXJ0eSB3aGljaCBzdGFydHMgYXQgYmVnaW5uaW5nTGluZU51bWJlciwgYWRkIGl0IHRvIHRoZSBjdXJyZW50IHRyZWVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGRQcm9wZXJ0eSA9IG5ldyBQcm9wZXJ0eVRyZWUoc2Nhbm5lci5nZXRUb2tlblZhbHVlKCksIGJlZ2lubmluZ0xpbmVOdW1iZXIpO1xuICAgICAgICAgICAgICAgICAgICBsYXN0UHJvcGVydHkgPSBjdXJyZW50UHJvcGVydHk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9wZXJ0eSA9IGN1cnJlbnRUcmVlLmFkZENoaWxkUHJvcGVydHkoY2hpbGRQcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2hlbiB0aGUgdG9rZW4gaXMgYW4gb3BlbiBicmFja2V0LCB0aGVuIHdlIGVudGVyIGludG8gYW4gYXJyYXlcbiAgICAgICAgICAgIGNhc2UgMyAvKiBTeW50YXhLaW5kLk9wZW5CcmFja2V0VG9rZW4gKi86IHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcm9vdCB0cmVlIGJlZ2lubmluZyBsaW5lIG51bWJlciBpcyBub3QgZGVmaW5lZCwgdGhlbiB0aGlzIG9wZW4gYnJhY2tldCBpcyB0aGUgZmlyc3Qgb3BlbiBicmFja2V0IGluIHRoZSBkb2N1bWVudFxuICAgICAgICAgICAgICAgIGlmIChyb290VHJlZS5iZWdpbm5pbmdMaW5lTnVtYmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdFRyZWUuYmVnaW5uaW5nTGluZU51bWJlciA9IHNjYW5uZXIuZ2V0VG9rZW5TdGFydExpbmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU3VwcG9zZSB3ZSBhcmUgaW5zaWRlIG9mIGFuIG9iamVjdCwgdGhlbiB0aGUgY3VycmVudCBhcnJheSBpcyBhc3NvY2lhdGVkIHRvIGEga2V5LCBhbmQgaGFzIGFscmVhZHkgYmVlbiBjcmVhdGVkXG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSB0aGUgZm9sbG93aW5nIGNvbmZpZ3VyYXRpb246IHtcImFcIjogXCJ2YWxcIiwgXCJhcnJheVwiOiBbLi4uXSwgXCJiXCI6IFwidmFsXCJ9XG4gICAgICAgICAgICAgICAgLy8gSW4gdGhhdCBjYXNlIG5hdmlnYXRlIGRvd24gdG8gdGhlIGNoaWxkIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDb250YWluZXJTdGFja1tjdXJyZW50Q29udGFpbmVyU3RhY2subGVuZ3RoIC0gMV0gPT09IENvbnRhaW5lci5PYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRyZWUgPSBjdXJyZW50UHJvcGVydHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFN1cHBvc2Ugd2UgYXJlIGluc2lkZSBvZiBhbiBhcnJheSwgdGhlbiBzaW5jZSB0aGUgY3VycmVudCBhcnJheSBpcyBub3QgYXNzb2NpYXRlZCB0byBhIGtleSwgaXQgaGFzIG5vdCBiZWVuIGNyZWF0ZWQgeWV0XG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSB0aGUgZm9sbG93aW5nIGNvbmZpZ3VyYXRpb246IFtcImFcIiwgWy4uLl0sIFwiYlwiXVxuICAgICAgICAgICAgICAgIC8vIEluIHRoYXQgY2FzZSBjcmVhdGUgdGhlIHByb3BlcnR5IGFuZCBuYXZpZ2F0ZSBkb3duXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudENvbnRhaW5lclN0YWNrW2N1cnJlbnRDb250YWluZXJTdGFjay5sZW5ndGggLSAxXSA9PT0gQ29udGFpbmVyLkFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkUHJvcGVydHkgPSBuZXcgUHJvcGVydHlUcmVlKHNjYW5uZXIuZ2V0VG9rZW5WYWx1ZSgpLCBiZWdpbm5pbmdMaW5lTnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRQcm9wZXJ0eS5ub0tleU5hbWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBsYXN0UHJvcGVydHkgPSBjdXJyZW50UHJvcGVydHk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9wZXJ0eSA9IGN1cnJlbnRUcmVlLmFkZENoaWxkUHJvcGVydHkoY2hpbGRQcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUcmVlID0gY3VycmVudFByb3BlcnR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udGFpbmVyU3RhY2sucHVzaChDb250YWluZXIuQXJyYXkpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9wZXJ0eS50eXBlID0gQ29udGFpbmVyLkFycmF5O1xuICAgICAgICAgICAgICAgIGJlZ2lubmluZ0xpbmVOdW1iZXIgPSBzY2FubmVyLmdldFRva2VuU3RhcnRMaW5lKCk7XG4gICAgICAgICAgICAgICAgYmVnaW5uaW5nTGluZU51bWJlcisrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2hlbiB0aGUgdG9rZW4gaXMgYW4gb3BlbiBicmFjZSwgdGhlbiB3ZSBlbnRlciBpbnRvIGFuIG9iamVjdFxuICAgICAgICAgICAgY2FzZSAxIC8qIFN5bnRheEtpbmQuT3BlbkJyYWNlVG9rZW4gKi86IHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcm9vdCB0cmVlIGJlZ2lubmluZyBsaW5lIG51bWJlciBpcyBub3QgZGVmaW5lZCwgdGhlbiB0aGlzIG9wZW4gYnJhY2UgaXMgdGhlIGZpcnN0IG9wZW4gYnJhY2UgaW4gdGhlIGRvY3VtZW50XG4gICAgICAgICAgICAgICAgaWYgKHJvb3RUcmVlLmJlZ2lubmluZ0xpbmVOdW1iZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByb290VHJlZS5iZWdpbm5pbmdMaW5lTnVtYmVyID0gc2Nhbm5lci5nZXRUb2tlblN0YXJ0TGluZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAxLiBJZiB3ZSBhcmUgaW5zaWRlIG9mIGFuIG9iamV0LCB0aGUgY3VycmVudCBvYmplY3QgaXMgYXNzb2NpYXRlZCB0byBhIGtleSBhbmQgaGFzIGFscmVhZHkgYmVlbiBjcmVhdGVkXG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSB0aGUgZm9sbG93aW5nIGNvbmZpZ3VyYXRpb246IHtcImFcIjogXCJ2YWxcIiwgXCJvYmplY3RcIjogey4uLn0sIFwiYlwiOiBcInZhbFwifVxuICAgICAgICAgICAgICAgIC8vIDIuIE90aGVyd2lzZSB0aGUgY3VycmVudCBvYmplY3QgcHJvcGVydHkgaXMgaW5zaWRlIG9mIGFuIGFycmF5LCBub3QgYXNzb2NpYXRlZCB0byBhIGtleSBuYW1lIGFuZCB0aGUgcHJvcGVydHkgaGFzIG5vdCB5ZXQgYmVlbiBjcmVhdGVkXG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSB0aGUgZm9sbG93aW5nIGNvbmZpZ3VyYXRpb246IFtcImFcIiwgey4uLn0sIFwiYlwiXVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRDb250YWluZXJTdGFja1tjdXJyZW50Q29udGFpbmVyU3RhY2subGVuZ3RoIC0gMV0gPT09IENvbnRhaW5lci5BcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZFByb3BlcnR5ID0gbmV3IFByb3BlcnR5VHJlZShzY2FubmVyLmdldFRva2VuVmFsdWUoKSwgYmVnaW5uaW5nTGluZU51bWJlcik7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkUHJvcGVydHkubm9LZXlOYW1lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFByb3BlcnR5ID0gY3VycmVudFByb3BlcnR5O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvcGVydHkgPSBjdXJyZW50VHJlZS5hZGRDaGlsZFByb3BlcnR5KGNoaWxkUHJvcGVydHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50UHJvcGVydHkudHlwZSA9IENvbnRhaW5lci5PYmplY3Q7XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRhaW5lclN0YWNrLnB1c2goQ29udGFpbmVyLk9iamVjdCk7XG4gICAgICAgICAgICAgICAgY3VycmVudFRyZWUgPSBjdXJyZW50UHJvcGVydHk7XG4gICAgICAgICAgICAgICAgYmVnaW5uaW5nTGluZU51bWJlciA9IHNjYW5uZXIuZ2V0VG9rZW5TdGFydExpbmUoKTtcbiAgICAgICAgICAgICAgICBiZWdpbm5pbmdMaW5lTnVtYmVyKys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDQgLyogU3ludGF4S2luZC5DbG9zZUJyYWNrZXRUb2tlbiAqLzoge1xuICAgICAgICAgICAgICAgIGVuZExpbmVOdW1iZXIgPSBzY2FubmVyLmdldFRva2VuU3RhcnRMaW5lKCk7XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRhaW5lclN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBsYXN0IG5vbi10cml2aWFsIG5vbi1jb21tZW50IHRva2VuIGlzIGEgY2xvc2luZyBicmFjZSBvciBicmFja2V0LCB0aGVuIHRoZSBjdXJyZW50UHJvcGVydHkgZW5kIGxpbmUgbnVtYmVyIGhhcyBub3QgYmVlbiBzZXQgeWV0IHNvIHNldCBpdFxuICAgICAgICAgICAgICAgIC8vIFRoZSBjb25maWd1cmF0aW9uIGNvbnNpZGVyZWQgaXM6IFsuLi4sIHt9XSBvciBbLi4uLCBbXV1cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFByb3BlcnR5LmVuZExpbmVOdW1iZXIgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAmJiAobGFzdE5vblRyaXZpYU5vbkNvbW1lbnRUb2tlbiA9PT0gMiAvKiBTeW50YXhLaW5kLkNsb3NlQnJhY2VUb2tlbiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgfHwgbGFzdE5vblRyaXZpYU5vbkNvbW1lbnRUb2tlbiA9PT0gNCAvKiBTeW50YXhLaW5kLkNsb3NlQnJhY2tldFRva2VuICovKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvcGVydHkuZW5kTGluZU51bWJlciA9IGVuZExpbmVOdW1iZXIgLSAxO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvcGVydHkubGFzdFByb3BlcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb3BlcnR5LmxpbmVXaGVyZVRvQWRkQ29tbWEgPSBsaW5lT2ZMYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvcGVydHkuaW5kZXhXaGVyZVRvQWRkQ29tYSA9IGVuZEluZGV4T2ZMYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuO1xuICAgICAgICAgICAgICAgICAgICBsYXN0UHJvcGVydHkgPSBjdXJyZW50UHJvcGVydHk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9wZXJ0eSA9IGN1cnJlbnRQcm9wZXJ0eSA/IGN1cnJlbnRQcm9wZXJ0eS5wYXJlbnQgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUcmVlID0gY3VycmVudFByb3BlcnR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByb290VHJlZS5lbmRMaW5lTnVtYmVyID0gZW5kTGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICBiZWdpbm5pbmdMaW5lTnVtYmVyID0gZW5kTGluZU51bWJlciArIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDIgLyogU3ludGF4S2luZC5DbG9zZUJyYWNlVG9rZW4gKi86IHtcbiAgICAgICAgICAgICAgICBlbmRMaW5lTnVtYmVyID0gc2Nhbm5lci5nZXRUb2tlblN0YXJ0TGluZSgpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250YWluZXJTdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgbm90IGluc2lkZSBvZiBhbiBlbXB0eSBvYmplY3RcbiAgICAgICAgICAgICAgICBpZiAobGFzdE5vblRyaXZpYU5vbkNvbW1lbnRUb2tlbiAhPT0gMSAvKiBTeW50YXhLaW5kLk9wZW5CcmFjZVRva2VuICovKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGN1cnJlbnQgcHJvcGVydHkgZW5kIGxpbmUgbnVtYmVyIGhhcyBub3QgeWV0IGJlZW4gZGVmaW5lZCwgZGVmaW5lIGl0XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UHJvcGVydHkuZW5kTGluZU51bWJlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvcGVydHkuZW5kTGluZU51bWJlciA9IGVuZExpbmVOdW1iZXIgLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGN1cnJlbnQgcHJvcGVydHkgaXMgYWxzbyB0aGUgbGFzdCBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb3BlcnR5Lmxhc3RQcm9wZXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbGFzdCBwcm9wZXJ0eSBvZiBhbiBvYmplY3QgaXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBsaW5lIGFuZCBpbmRleCBvZiB3aGVyZSB0byBhZGQgdGhlIGNvbW1hLCBpbiBjYXNlIGFmdGVyIHNvcnRpbmcsIGl0IGlzIG5vIGxvbmdlciB0aGUgbGFzdCBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb3BlcnR5LmxpbmVXaGVyZVRvQWRkQ29tbWEgPSBsaW5lT2ZMYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb3BlcnR5LmluZGV4V2hlcmVUb0FkZENvbWEgPSBlbmRJbmRleE9mTGFzdE5vblRyaXZpYU5vbkNvbW1lbnRUb2tlbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsYXN0UHJvcGVydHkgPSBjdXJyZW50UHJvcGVydHk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9wZXJ0eSA9IGN1cnJlbnRQcm9wZXJ0eSA/IGN1cnJlbnRQcm9wZXJ0eS5wYXJlbnQgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUcmVlID0gY3VycmVudFByb3BlcnR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByb290VHJlZS5lbmRMaW5lTnVtYmVyID0gc2Nhbm5lci5nZXRUb2tlblN0YXJ0TGluZSgpO1xuICAgICAgICAgICAgICAgIGJlZ2lubmluZ0xpbmVOdW1iZXIgPSBlbmRMaW5lTnVtYmVyICsgMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgNSAvKiBTeW50YXhLaW5kLkNvbW1hVG9rZW4gKi86IHtcbiAgICAgICAgICAgICAgICBlbmRMaW5lTnVtYmVyID0gc2Nhbm5lci5nZXRUb2tlblN0YXJ0TGluZSgpO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjdXJyZW50IGNvbnRhaW5lciBpcyBhbiBvYmplY3Qgb3IgdGhlIGN1cnJlbnQgY29udGFpbmVyIGlzIGFuIGFycmF5IGFuZCB0aGUgbGFzdCBub24tdHJpdmlhIG5vbi1jb21tZW50IHRva2VuIGlzIGEgY2xvc2luZyBicmFjZSBvciBhIGNsb3NpbmcgYnJhY2tldFxuICAgICAgICAgICAgICAgIC8vIFRoZW4gdXBkYXRlIHRoZSBlbmQgbGluZSBudW1iZXIgb2YgdGhlIGN1cnJlbnQgcHJvcGVydHlcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFByb3BlcnR5LmVuZExpbmVOdW1iZXIgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAmJiAoY3VycmVudENvbnRhaW5lclN0YWNrW2N1cnJlbnRDb250YWluZXJTdGFjay5sZW5ndGggLSAxXSA9PT0gQ29udGFpbmVyLk9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgKGN1cnJlbnRDb250YWluZXJTdGFja1tjdXJyZW50Q29udGFpbmVyU3RhY2subGVuZ3RoIC0gMV0gPT09IENvbnRhaW5lci5BcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIChsYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuID09PSAyIC8qIFN5bnRheEtpbmQuQ2xvc2VCcmFjZVRva2VuICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPT09IDQgLyogU3ludGF4S2luZC5DbG9zZUJyYWNrZXRUb2tlbiAqLykpKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvcGVydHkuZW5kTGluZU51bWJlciA9IGVuZExpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBsaW5lIGFuZCB0aGUgaW5kZXggb2YgdGhlIGNvbW1hIGluIGNhc2UgaXQgbmVlZHMgdG8gYmUgcmVtb3ZlZCBkdXJpbmcgdGhlIHNvcnRpbmdcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFByb3BlcnR5LmNvbW1hSW5kZXggPSBzY2FubmVyLmdldFRva2VuT2Zmc2V0KCkgLSBudW1iZXJPZkNoYXJhY3RlcnNPblByZXZpb3VzTGluZXM7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9wZXJ0eS5jb21tYUxpbmUgPSBlbmRMaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGFzdE5vblRyaXZpYU5vbkNvbW1lbnRUb2tlbiA9PT0gMiAvKiBTeW50YXhLaW5kLkNsb3NlQnJhY2VUb2tlbiAqL1xuICAgICAgICAgICAgICAgICAgICB8fCBsYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuID09PSA0IC8qIFN5bnRheEtpbmQuQ2xvc2VCcmFja2V0VG9rZW4gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFByb3BlcnR5ID0gY3VycmVudFByb3BlcnR5O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvcGVydHkgPSBjdXJyZW50UHJvcGVydHkgPyBjdXJyZW50UHJvcGVydHkucGFyZW50IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VHJlZSA9IGN1cnJlbnRQcm9wZXJ0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmVnaW5uaW5nTGluZU51bWJlciA9IGVuZExpbmVOdW1iZXIgKyAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAxMyAvKiBTeW50YXhLaW5kLkJsb2NrQ29tbWVudFRyaXZpYSAqLzoge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBsYXN0IG5vbiB0cml2aWEgbm9uLWNvbW1lbnQgdG9rZW4gaXMgYSBjb21tYSBhbmQgdGhlIGJsb2NrIGNvbW1lbnQgc3RhcnRzIG9uIHRoZSBzYW1lIGxpbmUgYXMgdGhlIGNvbW1hLCB0aGVuIHVwZGF0ZSB0aGUgZW5kIGxpbmUgbnVtYmVyIG9mIHRoZSBjdXJyZW50IHByb3BlcnR5LiBGb3IgZXhhbXBsZSBpZjpcbiAgICAgICAgICAgICAgICAvLyAxLiB7fSwgLyogLi4uXG4gICAgICAgICAgICAgICAgLy8gMi4gLi4qL1xuICAgICAgICAgICAgICAgIC8vIFRoZSB0aGUgcHJvcGVydHkgb24gbGluZSAxIHNob3VkIGVuZCBvbiBsaW5lIDIsIG5vdCBsaW5lIDFcbiAgICAgICAgICAgICAgICAvLyBJbiB0aGUgY2FzZSB3ZSBhcmUgaW4gYW4gYXJyYXkgd2UgdXBkYXRlIHRoZSBlbmQgbGluZSBudW1iZXIgb25seSBpZiB0aGUgc2Vjb25kIHRvIGxhc3Qgbm9uLXRyaXZpYSBub24tY29tbWVudCB0b2tlbiBpcyBhIGNsb3NpbmcgYnJhY2Ugb3IgYnJhY2tldFxuICAgICAgICAgICAgICAgIGlmIChsYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuID09PSA1IC8qIFN5bnRheEtpbmQuQ29tbWFUb2tlbiAqL1xuICAgICAgICAgICAgICAgICAgICAmJiBsaW5lT2ZMYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuID09PSBzY2FubmVyLmdldFRva2VuU3RhcnRMaW5lKClcbiAgICAgICAgICAgICAgICAgICAgJiYgKGN1cnJlbnRDb250YWluZXJTdGFja1tjdXJyZW50Q29udGFpbmVyU3RhY2subGVuZ3RoIC0gMV0gPT09IENvbnRhaW5lci5BcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgKHNlY29uZFRvTGFzdE5vblRyaXZpYU5vbkNvbW1lbnRUb2tlbiA9PT0gMiAvKiBTeW50YXhLaW5kLkNsb3NlQnJhY2VUb2tlbiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IHNlY29uZFRvTGFzdE5vblRyaXZpYU5vbkNvbW1lbnRUb2tlbiA9PT0gNCAvKiBTeW50YXhLaW5kLkNsb3NlQnJhY2tldFRva2VuICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgY3VycmVudENvbnRhaW5lclN0YWNrW2N1cnJlbnRDb250YWluZXJTdGFjay5sZW5ndGggLSAxXSA9PT0gQ29udGFpbmVyLk9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDb250YWluZXJTdGFja1tjdXJyZW50Q29udGFpbmVyU3RhY2subGVuZ3RoIC0gMV0gPT09IENvbnRhaW5lci5BcnJheSAmJiAoc2Vjb25kVG9MYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuID09PSAyIC8qIFN5bnRheEtpbmQuQ2xvc2VCcmFjZVRva2VuICovIHx8IHNlY29uZFRvTGFzdE5vblRyaXZpYU5vbkNvbW1lbnRUb2tlbiA9PT0gNCAvKiBTeW50YXhLaW5kLkNsb3NlQnJhY2tldFRva2VuICovKSB8fCBjdXJyZW50Q29udGFpbmVyU3RhY2tbY3VycmVudENvbnRhaW5lclN0YWNrLmxlbmd0aCAtIDFdID09PSBDb250YWluZXIuT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvcGVydHkuZW5kTGluZU51bWJlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUxhc3RQcm9wZXJ0eUVuZExpbmVOdW1iZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIGJsb2NrIGNvbW1lbnQgZm9sbG93cyBhbiBvcGVuIGJyYWNlIG9yIGFuIG9wZW4gdG9rZW4sIHdlIGhhdmUgdGhlIGZvbGxvd2luZyBzY2VuYXJpbzpcbiAgICAgICAgICAgICAgICAvLyB7IC8qKlxuICAgICAgICAgICAgICAgIC8vIC4uL1xuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAvLyBUaGUgYmxvY2sgY29tbWVudCBzaG91bGQgYmUgYXNzaWduZWQgdG8gdGhlIG9wZW4gYnJhY2Ugbm90IHRoZSBmaXJzdCBwcm9wZXJ0eSBiZWxvdyBpdFxuICAgICAgICAgICAgICAgIGlmICgobGFzdE5vblRyaXZpYU5vbkNvbW1lbnRUb2tlbiA9PT0gMSAvKiBTeW50YXhLaW5kLk9wZW5CcmFjZVRva2VuICovXG4gICAgICAgICAgICAgICAgICAgIHx8IGxhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPT09IDMgLyogU3ludGF4S2luZC5PcGVuQnJhY2tldFRva2VuICovKVxuICAgICAgICAgICAgICAgICAgICAmJiBsaW5lT2ZMYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuID09PSBzY2FubmVyLmdldFRva2VuU3RhcnRMaW5lKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQmVnaW5uaW5nTGluZU51bWJlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgbGFzdCBhbmQgc2Vjb25kIHRvIGxhc3Qgbm9uLXRyaXZpYSBub24tY29tbWVudCB0b2tlbnNcbiAgICAgICAgaWYgKHRva2VuICE9PSAxNCAvKiBTeW50YXhLaW5kLkxpbmVCcmVha1RyaXZpYSAqL1xuICAgICAgICAgICAgJiYgdG9rZW4gIT09IDEzIC8qIFN5bnRheEtpbmQuQmxvY2tDb21tZW50VHJpdmlhICovXG4gICAgICAgICAgICAmJiB0b2tlbiAhPT0gMTIgLyogU3ludGF4S2luZC5MaW5lQ29tbWVudFRyaXZpYSAqL1xuICAgICAgICAgICAgJiYgdG9rZW4gIT09IDE1IC8qIFN5bnRheEtpbmQuVHJpdmlhICovKSB7XG4gICAgICAgICAgICBzZWNvbmRUb0xhc3ROb25Ucml2aWFOb25Db21tZW50VG9rZW4gPSBsYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuO1xuICAgICAgICAgICAgbGFzdE5vblRyaXZpYU5vbkNvbW1lbnRUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgbGluZU9mTGFzdE5vblRyaXZpYU5vbkNvbW1lbnRUb2tlbiA9IHNjYW5uZXIuZ2V0VG9rZW5TdGFydExpbmUoKTtcbiAgICAgICAgICAgIGVuZEluZGV4T2ZMYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuID0gc2Nhbm5lci5nZXRUb2tlbk9mZnNldCgpICsgc2Nhbm5lci5nZXRUb2tlbkxlbmd0aCgpIC0gbnVtYmVyT2ZDaGFyYWN0ZXJzT25QcmV2aW91c0xpbmVzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByb290VHJlZTtcbn1cbmZ1bmN0aW9uIHNvcnRKc29uY0RvY3VtZW50KGpzb25Eb2N1bWVudCwgcHJvcGVydHlUcmVlKSB7XG4gICAgaWYgKHByb3BlcnR5VHJlZS5jaGlsZHJlblByb3BlcnRpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBqc29uRG9jdW1lbnQ7XG4gICAgfVxuICAgIGNvbnN0IHNvcnRlZEpzb25Eb2N1bWVudCA9IG1haW4vKiBUZXh0RG9jdW1lbnQgKi8uVi5jcmVhdGUoJ3Rlc3Q6Ly90ZXN0Lmpzb24nLCAnanNvbicsIDAsIGpzb25Eb2N1bWVudC5nZXRUZXh0KCkpO1xuICAgIGNvbnN0IHF1ZXVlVG9Tb3J0ID0gW107XG4gICAgdXBkYXRlU29ydGluZ1F1ZXVlKHF1ZXVlVG9Tb3J0LCBwcm9wZXJ0eVRyZWUsIHByb3BlcnR5VHJlZS5iZWdpbm5pbmdMaW5lTnVtYmVyKTtcbiAgICB3aGlsZSAocXVldWVUb1NvcnQubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBkYXRhVG9Tb3J0ID0gcXVldWVUb1NvcnQuc2hpZnQoKTtcbiAgICAgICAgY29uc3QgcHJvcGVydHlUcmVlQXJyYXkgPSBkYXRhVG9Tb3J0LnByb3BlcnR5VHJlZUFycmF5O1xuICAgICAgICBsZXQgYmVnaW5uaW5nTGluZU51bWJlciA9IGRhdGFUb1NvcnQuYmVnaW5uaW5nTGluZU51bWJlcjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wZXJ0eVRyZWVBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcHJvcGVydHlUcmVlID0gcHJvcGVydHlUcmVlQXJyYXlbaV07XG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IFJhbmdlLmNyZWF0ZShQb3NpdGlvbi5jcmVhdGUocHJvcGVydHlUcmVlLmJlZ2lubmluZ0xpbmVOdW1iZXIsIDApLCBQb3NpdGlvbi5jcmVhdGUocHJvcGVydHlUcmVlLmVuZExpbmVOdW1iZXIgKyAxLCAwKSk7XG4gICAgICAgICAgICBjb25zdCBqc29uQ29udGVudFRvUmVwbGFjZSA9IGpzb25Eb2N1bWVudC5nZXRUZXh0KHJhbmdlKTtcbiAgICAgICAgICAgIGNvbnN0IGpzb25Eb2N1bWVudFRvUmVwbGFjZSA9IG1haW4vKiBUZXh0RG9jdW1lbnQgKi8uVi5jcmVhdGUoJ3Rlc3Q6Ly90ZXN0Lmpzb24nLCAnanNvbicsIDAsIGpzb25Db250ZW50VG9SZXBsYWNlKTtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eVRyZWUubGFzdFByb3BlcnR5ID09PSB0cnVlICYmIGkgIT09IHByb3BlcnR5VHJlZUFycmF5Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lV2hlcmVUb0FkZENvbW1hID0gcHJvcGVydHlUcmVlLmxpbmVXaGVyZVRvQWRkQ29tbWEgLSBwcm9wZXJ0eVRyZWUuYmVnaW5uaW5nTGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleFdoZXJlVG9BZGRDb21tYSA9IHByb3BlcnR5VHJlZS5pbmRleFdoZXJlVG9BZGRDb21hO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVkaXQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBSYW5nZS5jcmVhdGUoUG9zaXRpb24uY3JlYXRlKGxpbmVXaGVyZVRvQWRkQ29tbWEsIGluZGV4V2hlcmVUb0FkZENvbW1hKSwgUG9zaXRpb24uY3JlYXRlKGxpbmVXaGVyZVRvQWRkQ29tbWEsIGluZGV4V2hlcmVUb0FkZENvbW1hKSksXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6ICcsJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbWFpbi8qIFRleHREb2N1bWVudCAqLy5WLnVwZGF0ZShqc29uRG9jdW1lbnRUb1JlcGxhY2UsIFtlZGl0XSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm9wZXJ0eVRyZWUubGFzdFByb3BlcnR5ID09PSBmYWxzZSAmJiBpID09PSBwcm9wZXJ0eVRyZWVBcnJheS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tbWFJbmRleCA9IHByb3BlcnR5VHJlZS5jb21tYUluZGV4O1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbW1hTGluZSA9IHByb3BlcnR5VHJlZS5jb21tYUxpbmU7XG4gICAgICAgICAgICAgICAgY29uc3QgbGluZVdoZXJlVG9SZW1vdmVDb21tYSA9IGNvbW1hTGluZSAtIHByb3BlcnR5VHJlZS5iZWdpbm5pbmdMaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVkaXQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBSYW5nZS5jcmVhdGUoUG9zaXRpb24uY3JlYXRlKGxpbmVXaGVyZVRvUmVtb3ZlQ29tbWEsIGNvbW1hSW5kZXgpLCBQb3NpdGlvbi5jcmVhdGUobGluZVdoZXJlVG9SZW1vdmVDb21tYSwgY29tbWFJbmRleCArIDEpKSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogJydcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG1haW4vKiBUZXh0RG9jdW1lbnQgKi8uVi51cGRhdGUoanNvbkRvY3VtZW50VG9SZXBsYWNlLCBbZWRpdF0sIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gcHJvcGVydHlUcmVlLmVuZExpbmVOdW1iZXIgLSBwcm9wZXJ0eVRyZWUuYmVnaW5uaW5nTGluZU51bWJlciArIDE7XG4gICAgICAgICAgICBjb25zdCBlZGl0ID0ge1xuICAgICAgICAgICAgICAgIHJhbmdlOiBSYW5nZS5jcmVhdGUoUG9zaXRpb24uY3JlYXRlKGJlZ2lubmluZ0xpbmVOdW1iZXIsIDApLCBQb3NpdGlvbi5jcmVhdGUoYmVnaW5uaW5nTGluZU51bWJlciArIGxlbmd0aCwgMCkpLFxuICAgICAgICAgICAgICAgIHRleHQ6IGpzb25Eb2N1bWVudFRvUmVwbGFjZS5nZXRUZXh0KClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBtYWluLyogVGV4dERvY3VtZW50ICovLlYudXBkYXRlKHNvcnRlZEpzb25Eb2N1bWVudCwgW2VkaXRdLCAxKTtcbiAgICAgICAgICAgIHVwZGF0ZVNvcnRpbmdRdWV1ZShxdWV1ZVRvU29ydCwgcHJvcGVydHlUcmVlLCBiZWdpbm5pbmdMaW5lTnVtYmVyKTtcbiAgICAgICAgICAgIGJlZ2lubmluZ0xpbmVOdW1iZXIgPSBiZWdpbm5pbmdMaW5lTnVtYmVyICsgbGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzb3J0ZWRKc29uRG9jdW1lbnQ7XG59XG5mdW5jdGlvbiBzb3J0UHJvcGVydGllc0Nhc2VTZW5zaXRpdmUocHJvcGVydGllcykge1xuICAgIHByb3BlcnRpZXMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICBjb25zdCBhTmFtZSA9IGEucHJvcGVydHlOYW1lID8/ICcnO1xuICAgICAgICBjb25zdCBiTmFtZSA9IGIucHJvcGVydHlOYW1lID8/ICcnO1xuICAgICAgICByZXR1cm4gYU5hbWUgPCBiTmFtZSA/IC0xIDogYU5hbWUgPiBiTmFtZSA/IDEgOiAwO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gdXBkYXRlU29ydGluZ1F1ZXVlKHF1ZXVlLCBwcm9wZXJ0eVRyZWUsIGJlZ2lubmluZ0xpbmVOdW1iZXIpIHtcbiAgICBpZiAocHJvcGVydHlUcmVlLmNoaWxkcmVuUHJvcGVydGllcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocHJvcGVydHlUcmVlLnR5cGUgPT09IENvbnRhaW5lci5PYmplY3QpIHtcbiAgICAgICAgbGV0IG1pbmltdW1CZWdpbm5pbmdMaW5lTnVtYmVyID0gSW5maW5pdHk7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGRQcm9wZXJ0eSBvZiBwcm9wZXJ0eVRyZWUuY2hpbGRyZW5Qcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGRQcm9wZXJ0eS5iZWdpbm5pbmdMaW5lTnVtYmVyIDwgbWluaW11bUJlZ2lubmluZ0xpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICBtaW5pbXVtQmVnaW5uaW5nTGluZU51bWJlciA9IGNoaWxkUHJvcGVydHkuYmVnaW5uaW5nTGluZU51bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaWZmID0gbWluaW11bUJlZ2lubmluZ0xpbmVOdW1iZXIgLSBwcm9wZXJ0eVRyZWUuYmVnaW5uaW5nTGluZU51bWJlcjtcbiAgICAgICAgYmVnaW5uaW5nTGluZU51bWJlciA9IGJlZ2lubmluZ0xpbmVOdW1iZXIgKyBkaWZmO1xuICAgICAgICBzb3J0UHJvcGVydGllc0Nhc2VTZW5zaXRpdmUocHJvcGVydHlUcmVlLmNoaWxkcmVuUHJvcGVydGllcyk7XG4gICAgICAgIHF1ZXVlLnB1c2gobmV3IFNvcnRpbmdSYW5nZShiZWdpbm5pbmdMaW5lTnVtYmVyLCBwcm9wZXJ0eVRyZWUuY2hpbGRyZW5Qcm9wZXJ0aWVzKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb3BlcnR5VHJlZS50eXBlID09PSBDb250YWluZXIuQXJyYXkpIHtcbiAgICAgICAgdXBkYXRlU29ydGluZ1F1ZXVlRm9yQXJyYXlQcm9wZXJ0aWVzKHF1ZXVlLCBwcm9wZXJ0eVRyZWUsIGJlZ2lubmluZ0xpbmVOdW1iZXIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZVNvcnRpbmdRdWV1ZUZvckFycmF5UHJvcGVydGllcyhxdWV1ZSwgcHJvcGVydHlUcmVlLCBiZWdpbm5pbmdMaW5lTnVtYmVyKSB7XG4gICAgZm9yIChjb25zdCBzdWJPYmplY3Qgb2YgcHJvcGVydHlUcmVlLmNoaWxkcmVuUHJvcGVydGllcykge1xuICAgICAgICAvLyBJZiB0aGUgY2hpbGQgcHJvcGVydHkgb2YgdGhlIGFycmF5IGlzIGFuIG9iamVjdCwgdGhlbiB5b3UgY2FuIHNvcnQgdGhlIHByb3BlcnRpZXMgd2l0aGluIHRoaXMgb2JqZWN0XG4gICAgICAgIGlmIChzdWJPYmplY3QudHlwZSA9PT0gQ29udGFpbmVyLk9iamVjdCkge1xuICAgICAgICAgICAgbGV0IG1pbmltdW1CZWdpbm5pbmdMaW5lTnVtYmVyID0gSW5maW5pdHk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkUHJvcGVydHkgb2Ygc3ViT2JqZWN0LmNoaWxkcmVuUHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZFByb3BlcnR5LmJlZ2lubmluZ0xpbmVOdW1iZXIgPCBtaW5pbXVtQmVnaW5uaW5nTGluZU51bWJlcikge1xuICAgICAgICAgICAgICAgICAgICBtaW5pbXVtQmVnaW5uaW5nTGluZU51bWJlciA9IGNoaWxkUHJvcGVydHkuYmVnaW5uaW5nTGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkaWZmID0gbWluaW11bUJlZ2lubmluZ0xpbmVOdW1iZXIgLSBzdWJPYmplY3QuYmVnaW5uaW5nTGluZU51bWJlcjtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2gobmV3IFNvcnRpbmdSYW5nZShiZWdpbm5pbmdMaW5lTnVtYmVyICsgc3ViT2JqZWN0LmJlZ2lubmluZ0xpbmVOdW1iZXIgLSBwcm9wZXJ0eVRyZWUuYmVnaW5uaW5nTGluZU51bWJlciArIGRpZmYsIHN1Yk9iamVjdC5jaGlsZHJlblByb3BlcnRpZXMpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgY2hpbGQgcHJvcGVydHkgb2YgdGhlIGFycmF5IGlzIGFuIGFycmF5LCB0aGVuIHlvdSBuZWVkIHRvIHJlY3Vyc2Ugb24gdGhlIGNoaWxkcmVuIHByb3BlcnRpZXMsIHVudGlsIHlvdSBmaW5kIGFuIG9iamVjdCB0byBzb3J0XG4gICAgICAgIGlmIChzdWJPYmplY3QudHlwZSA9PT0gQ29udGFpbmVyLkFycmF5KSB7XG4gICAgICAgICAgICB1cGRhdGVTb3J0aW5nUXVldWVGb3JBcnJheVByb3BlcnRpZXMocXVldWUsIHN1Yk9iamVjdCwgYmVnaW5uaW5nTGluZU51bWJlciArIHN1Yk9iamVjdC5iZWdpbm5pbmdMaW5lTnVtYmVyIC0gcHJvcGVydHlUcmVlLmJlZ2lubmluZ0xpbmVOdW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgU29ydGluZ1JhbmdlIHtcbiAgICBjb25zdHJ1Y3RvcihiZWdpbm5pbmdMaW5lTnVtYmVyLCBwcm9wZXJ0eVRyZWVBcnJheSkge1xuICAgICAgICB0aGlzLmJlZ2lubmluZ0xpbmVOdW1iZXIgPSBiZWdpbm5pbmdMaW5lTnVtYmVyO1xuICAgICAgICB0aGlzLnByb3BlcnR5VHJlZUFycmF5ID0gcHJvcGVydHlUcmVlQXJyYXk7XG4gICAgfVxufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3ZzY29kZS1qc29uLWxhbmd1YWdlc2VydmljZS9saWIvZXNtL3NlcnZpY2VzL2pzb25MaW5rcy5qc1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbmZ1bmN0aW9uIGZpbmRMaW5rcyhkb2N1bWVudCwgZG9jKSB7XG4gICAgY29uc3QgbGlua3MgPSBbXTtcbiAgICBkb2MudmlzaXQobm9kZSA9PiB7XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IFwicHJvcGVydHlcIiAmJiBub2RlLmtleU5vZGUudmFsdWUgPT09IFwiJHJlZlwiICYmIG5vZGUudmFsdWVOb2RlPy50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc3QgcGF0aCA9IG5vZGUudmFsdWVOb2RlLnZhbHVlO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0Tm9kZSA9IGZpbmRUYXJnZXROb2RlKGRvYywgcGF0aCk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0Tm9kZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldFBvcyA9IGRvY3VtZW50LnBvc2l0aW9uQXQodGFyZ2V0Tm9kZS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGxpbmtzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IGAke2RvY3VtZW50LnVyaX0jJHt0YXJnZXRQb3MubGluZSArIDF9LCR7dGFyZ2V0UG9zLmNoYXJhY3RlciArIDF9YCxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IGNyZWF0ZVJhbmdlKGRvY3VtZW50LCBub2RlLnZhbHVlTm9kZSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGxpbmtzKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJhbmdlKGRvY3VtZW50LCBub2RlKSB7XG4gICAgcmV0dXJuIFJhbmdlLmNyZWF0ZShkb2N1bWVudC5wb3NpdGlvbkF0KG5vZGUub2Zmc2V0ICsgMSksIGRvY3VtZW50LnBvc2l0aW9uQXQobm9kZS5vZmZzZXQgKyBub2RlLmxlbmd0aCAtIDEpKTtcbn1cbmZ1bmN0aW9uIGZpbmRUYXJnZXROb2RlKGRvYywgcGF0aCkge1xuICAgIGNvbnN0IHRva2VucyA9IHBhcnNlSlNPTlBvaW50ZXIocGF0aCk7XG4gICAgaWYgKCF0b2tlbnMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBmaW5kTm9kZSh0b2tlbnMsIGRvYy5yb290KTtcbn1cbmZ1bmN0aW9uIGZpbmROb2RlKHBvaW50ZXIsIG5vZGUpIHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChwb2ludGVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgY29uc3QgdG9rZW4gPSBwb2ludGVyLnNoaWZ0KCk7XG4gICAgaWYgKG5vZGUgJiYgbm9kZS50eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBjb25zdCBwcm9wZXJ0eU5vZGUgPSBub2RlLnByb3BlcnRpZXMuZmluZCgocHJvcGVydHlOb2RlKSA9PiBwcm9wZXJ0eU5vZGUua2V5Tm9kZS52YWx1ZSA9PT0gdG9rZW4pO1xuICAgICAgICBpZiAoIXByb3BlcnR5Tm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbmROb2RlKHBvaW50ZXIsIHByb3BlcnR5Tm9kZS52YWx1ZU5vZGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlICYmIG5vZGUudHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICBpZiAodG9rZW4ubWF0Y2goL14oMHxbMS05XVswLTldKikkLykpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gTnVtYmVyLnBhcnNlSW50KHRva2VuKTtcbiAgICAgICAgICAgIGNvbnN0IGFycmF5SXRlbSA9IG5vZGUuaXRlbXNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKCFhcnJheUl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaW5kTm9kZShwb2ludGVyLCBhcnJheUl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcGFyc2VKU09OUG9pbnRlcihwYXRoKSB7XG4gICAgaWYgKHBhdGggPT09IFwiI1wiKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKHBhdGhbMF0gIT09ICcjJyB8fCBwYXRoWzFdICE9PSAnLycpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBwYXRoLnN1YnN0cmluZygyKS5zcGxpdCgvXFwvLykubWFwKGpzb25MaW5rc191bmVzY2FwZSk7XG59XG5mdW5jdGlvbiBqc29uTGlua3NfdW5lc2NhcGUoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9+MS9nLCAnLycpLnJlcGxhY2UoL34wL2csICd+Jyk7XG59XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvdnNjb2RlLWpzb24tbGFuZ3VhZ2VzZXJ2aWNlL2xpYi9lc20vanNvbkxhbmd1YWdlU2VydmljZS5qc1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIGdldExhbmd1YWdlU2VydmljZShwYXJhbXMpIHtcbiAgICBjb25zdCBwcm9taXNlID0gcGFyYW1zLnByb21pc2VDb25zdHJ1Y3RvciB8fCBQcm9taXNlO1xuICAgIGNvbnN0IGpzb25TY2hlbWFTZXJ2aWNlID0gbmV3IEpTT05TY2hlbWFTZXJ2aWNlKHBhcmFtcy5zY2hlbWFSZXF1ZXN0U2VydmljZSwgcGFyYW1zLndvcmtzcGFjZUNvbnRleHQsIHByb21pc2UpO1xuICAgIGpzb25TY2hlbWFTZXJ2aWNlLnNldFNjaGVtYUNvbnRyaWJ1dGlvbnMoc2NoZW1hQ29udHJpYnV0aW9ucyk7XG4gICAgY29uc3QganNvbkNvbXBsZXRpb24gPSBuZXcgSlNPTkNvbXBsZXRpb24oanNvblNjaGVtYVNlcnZpY2UsIHBhcmFtcy5jb250cmlidXRpb25zLCBwcm9taXNlLCBwYXJhbXMuY2xpZW50Q2FwYWJpbGl0aWVzKTtcbiAgICBjb25zdCBqc29uSG92ZXIgPSBuZXcgSlNPTkhvdmVyKGpzb25TY2hlbWFTZXJ2aWNlLCBwYXJhbXMuY29udHJpYnV0aW9ucywgcHJvbWlzZSk7XG4gICAgY29uc3QganNvbkRvY3VtZW50U3ltYm9scyA9IG5ldyBKU09ORG9jdW1lbnRTeW1ib2xzKGpzb25TY2hlbWFTZXJ2aWNlKTtcbiAgICBjb25zdCBqc29uVmFsaWRhdGlvbiA9IG5ldyBKU09OVmFsaWRhdGlvbihqc29uU2NoZW1hU2VydmljZSwgcHJvbWlzZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29uZmlndXJlOiAoc2V0dGluZ3MpID0+IHtcbiAgICAgICAgICAgIGpzb25TY2hlbWFTZXJ2aWNlLmNsZWFyRXh0ZXJuYWxTY2hlbWFzKCk7XG4gICAgICAgICAgICBzZXR0aW5ncy5zY2hlbWFzPy5mb3JFYWNoKGpzb25TY2hlbWFTZXJ2aWNlLnJlZ2lzdGVyRXh0ZXJuYWxTY2hlbWEuYmluZChqc29uU2NoZW1hU2VydmljZSkpO1xuICAgICAgICAgICAganNvblZhbGlkYXRpb24uY29uZmlndXJlKHNldHRpbmdzKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzZXRTY2hlbWE6ICh1cmkpID0+IGpzb25TY2hlbWFTZXJ2aWNlLm9uUmVzb3VyY2VDaGFuZ2UodXJpKSxcbiAgICAgICAgZG9WYWxpZGF0aW9uOiBqc29uVmFsaWRhdGlvbi5kb1ZhbGlkYXRpb24uYmluZChqc29uVmFsaWRhdGlvbiksXG4gICAgICAgIGdldExhbmd1YWdlU3RhdHVzOiBqc29uVmFsaWRhdGlvbi5nZXRMYW5ndWFnZVN0YXR1cy5iaW5kKGpzb25WYWxpZGF0aW9uKSxcbiAgICAgICAgcGFyc2VKU09ORG9jdW1lbnQ6IChkb2N1bWVudCkgPT4ganNvblBhcnNlcl9wYXJzZShkb2N1bWVudCwgeyBjb2xsZWN0Q29tbWVudHM6IHRydWUgfSksXG4gICAgICAgIG5ld0pTT05Eb2N1bWVudDogKHJvb3QsIGRpYWdub3N0aWNzKSA9PiBuZXdKU09ORG9jdW1lbnQocm9vdCwgZGlhZ25vc3RpY3MpLFxuICAgICAgICBnZXRNYXRjaGluZ1NjaGVtYXM6IGpzb25TY2hlbWFTZXJ2aWNlLmdldE1hdGNoaW5nU2NoZW1hcy5iaW5kKGpzb25TY2hlbWFTZXJ2aWNlKSxcbiAgICAgICAgZG9SZXNvbHZlOiBqc29uQ29tcGxldGlvbi5kb1Jlc29sdmUuYmluZChqc29uQ29tcGxldGlvbiksXG4gICAgICAgIGRvQ29tcGxldGU6IGpzb25Db21wbGV0aW9uLmRvQ29tcGxldGUuYmluZChqc29uQ29tcGxldGlvbiksXG4gICAgICAgIGZpbmREb2N1bWVudFN5bWJvbHM6IGpzb25Eb2N1bWVudFN5bWJvbHMuZmluZERvY3VtZW50U3ltYm9scy5iaW5kKGpzb25Eb2N1bWVudFN5bWJvbHMpLFxuICAgICAgICBmaW5kRG9jdW1lbnRTeW1ib2xzMjoganNvbkRvY3VtZW50U3ltYm9scy5maW5kRG9jdW1lbnRTeW1ib2xzMi5iaW5kKGpzb25Eb2N1bWVudFN5bWJvbHMpLFxuICAgICAgICBmaW5kRG9jdW1lbnRDb2xvcnM6IGpzb25Eb2N1bWVudFN5bWJvbHMuZmluZERvY3VtZW50Q29sb3JzLmJpbmQoanNvbkRvY3VtZW50U3ltYm9scyksXG4gICAgICAgIGdldENvbG9yUHJlc2VudGF0aW9uczoganNvbkRvY3VtZW50U3ltYm9scy5nZXRDb2xvclByZXNlbnRhdGlvbnMuYmluZChqc29uRG9jdW1lbnRTeW1ib2xzKSxcbiAgICAgICAgZG9Ib3ZlcjoganNvbkhvdmVyLmRvSG92ZXIuYmluZChqc29uSG92ZXIpLFxuICAgICAgICBnZXRGb2xkaW5nUmFuZ2VzOiBnZXRGb2xkaW5nUmFuZ2VzLFxuICAgICAgICBnZXRTZWxlY3Rpb25SYW5nZXM6IGdldFNlbGVjdGlvblJhbmdlcyxcbiAgICAgICAgZmluZERlZmluaXRpb246ICgpID0+IFByb21pc2UucmVzb2x2ZShbXSksXG4gICAgICAgIGZpbmRMaW5rczogZmluZExpbmtzLFxuICAgICAgICBmb3JtYXQ6IChkb2N1bWVudCwgcmFuZ2UsIG9wdGlvbnMpID0+IHV0aWxzX2Zvcm1hdF9mb3JtYXQoZG9jdW1lbnQsIG9wdGlvbnMsIHJhbmdlKSxcbiAgICAgICAgc29ydDogKGRvY3VtZW50LCBvcHRpb25zKSA9PiBzb3J0KGRvY3VtZW50LCBvcHRpb25zKVxuICAgIH07XG59XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL3ZzY29kZS1sYW5ndWFnZXNlcnZlci1wcm90b2NvbC9saWIvYnJvd3Nlci9tYWluLmpzXG52YXIgYnJvd3Nlcl9tYWluID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NTAxKTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvdXRpbHMudHNcbnZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNzc3MCk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvYWNlL3JhbmdlLXNpbmdsZXRvbi50c1xuZnVuY3Rpb24gX2RlZmluZV9wcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuY2xhc3MgQWNlUmFuZ2Uge1xuICAgIHN0YXRpYyBnZXRDb25zdHJ1Y3RvcihlZGl0b3IpIHtcbiAgICAgICAgaWYgKCFBY2VSYW5nZS5faW5zdGFuY2UgJiYgZWRpdG9yKSB7XG4gICAgICAgICAgICBBY2VSYW5nZS5faW5zdGFuY2UgPSBlZGl0b3IuZ2V0U2VsZWN0aW9uUmFuZ2UoKS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQWNlUmFuZ2UuX2luc3RhbmNlO1xuICAgIH1cbn1cbl9kZWZpbmVfcHJvcGVydHkoQWNlUmFuZ2UsIFwiX2luc3RhbmNlXCIsIHZvaWQgMCk7XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy90eXBlLWNvbnZlcnRlcnMvY29tbW9uLWNvbnZlcnRlcnMudHNcblxuXG5cbnZhciBjb21tb25fY29udmVydGVyc19Db21tb25Db252ZXJ0ZXI7XG4oZnVuY3Rpb24oQ29tbW9uQ29udmVydGVyKSB7XG4gICAgZnVuY3Rpb24gbm9ybWFsaXplUmFuZ2VzKGNvbXBsZXRpb25zKSB7XG4gICAgICAgIHJldHVybiBjb21wbGV0aW9ucyAmJiBjb21wbGV0aW9ucy5tYXAoKGVsKT0+e1xuICAgICAgICAgICAgaWYgKGVsW1wicmFuZ2VcIl0pIHtcbiAgICAgICAgICAgICAgICBlbFtcInJhbmdlXCJdID0gdG9SYW5nZShlbFtcInJhbmdlXCJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIENvbW1vbkNvbnZlcnRlci5ub3JtYWxpemVSYW5nZXMgPSBub3JtYWxpemVSYW5nZXM7XG4gICAgZnVuY3Rpb24gY2xlYW5IdG1sKGh0bWwpIHtcbiAgICAgICAgcmV0dXJuIGh0bWwucmVwbGFjZSgvPGFcXHMvLCBcIjxhIHRhcmdldD0nX2JsYW5rJyBcIik7XG4gICAgfVxuICAgIENvbW1vbkNvbnZlcnRlci5jbGVhbkh0bWwgPSBjbGVhbkh0bWw7XG4gICAgZnVuY3Rpb24gdG9SYW5nZShyYW5nZSkge1xuICAgICAgICBpZiAoIXJhbmdlIHx8ICFyYW5nZS5zdGFydCB8fCAhcmFuZ2UuZW5kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IFJhbmdlID0gQWNlUmFuZ2UuZ2V0Q29uc3RydWN0b3IoKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gUmFuZ2UuZnJvbVBvaW50cyhyYW5nZS5zdGFydCwgcmFuZ2UuZW5kKTtcbiAgICB9XG4gICAgQ29tbW9uQ29udmVydGVyLnRvUmFuZ2UgPSB0b1JhbmdlO1xuICAgIGZ1bmN0aW9uIGNvbnZlcnRLaW5kKGtpbmQpIHtcbiAgICAgICAgc3dpdGNoKGtpbmQpe1xuICAgICAgICAgICAgY2FzZSBcInByaW1pdGl2ZVR5cGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJrZXl3b3JkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJyb3dzZXJfbWFpbi5Db21wbGV0aW9uSXRlbUtpbmQuS2V5d29yZDtcbiAgICAgICAgICAgIGNhc2UgXCJ2YXJpYWJsZVwiOlxuICAgICAgICAgICAgY2FzZSBcImxvY2FsVmFyaWFibGVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYnJvd3Nlcl9tYWluLkNvbXBsZXRpb25JdGVtS2luZC5WYXJpYWJsZTtcbiAgICAgICAgICAgIGNhc2UgXCJtZW1iZXJWYXJpYWJsZVwiOlxuICAgICAgICAgICAgY2FzZSBcIm1lbWJlckdldEFjY2Vzc29yXCI6XG4gICAgICAgICAgICBjYXNlIFwibWVtYmVyU2V0QWNjZXNzb3JcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYnJvd3Nlcl9tYWluLkNvbXBsZXRpb25JdGVtS2luZC5GaWVsZDtcbiAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgY2FzZSBcIm1lbWJlckZ1bmN0aW9uXCI6XG4gICAgICAgICAgICBjYXNlIFwiY29uc3RydWN0U2lnbmF0dXJlXCI6XG4gICAgICAgICAgICBjYXNlIFwiY2FsbFNpZ25hdHVyZVwiOlxuICAgICAgICAgICAgY2FzZSBcImluZGV4U2lnbmF0dXJlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJyb3dzZXJfbWFpbi5Db21wbGV0aW9uSXRlbUtpbmQuRnVuY3Rpb247XG4gICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBicm93c2VyX21haW4uQ29tcGxldGlvbkl0ZW1LaW5kLkVudW07XG4gICAgICAgICAgICBjYXNlIFwibW9kdWxlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJyb3dzZXJfbWFpbi5Db21wbGV0aW9uSXRlbUtpbmQuTW9kdWxlO1xuICAgICAgICAgICAgY2FzZSBcImNsYXNzXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJyb3dzZXJfbWFpbi5Db21wbGV0aW9uSXRlbUtpbmQuQ2xhc3M7XG4gICAgICAgICAgICBjYXNlIFwiaW50ZXJmYWNlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJyb3dzZXJfbWFpbi5Db21wbGV0aW9uSXRlbUtpbmQuSW50ZXJmYWNlO1xuICAgICAgICAgICAgY2FzZSBcIndhcm5pbmdcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYnJvd3Nlcl9tYWluLkNvbXBsZXRpb25JdGVtS2luZC5GaWxlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBicm93c2VyX21haW4uQ29tcGxldGlvbkl0ZW1LaW5kLlByb3BlcnR5O1xuICAgIH1cbiAgICBDb21tb25Db252ZXJ0ZXIuY29udmVydEtpbmQgPSBjb252ZXJ0S2luZDtcbiAgICBmdW5jdGlvbiBleGNsdWRlQnlFcnJvck1lc3NhZ2UoZGlhZ25vc3RpY3MsIGVycm9yTWVzc2FnZXNUb0lnbm9yZSwgZmllbGROYW1lID0gXCJtZXNzYWdlXCIpIHtcbiAgICAgICAgaWYgKCFlcnJvck1lc3NhZ2VzVG9JZ25vcmUpIHJldHVybiBkaWFnbm9zdGljcztcbiAgICAgICAgcmV0dXJuIGRpYWdub3N0aWNzLmZpbHRlcigoZWwpPT4hKDAsdXRpbHMvKiBjaGVja1ZhbHVlQWdhaW5zdFJlZ2V4cEFycmF5ICovLlRrKShlbFtmaWVsZE5hbWVdLCBlcnJvck1lc3NhZ2VzVG9JZ25vcmUpKTtcbiAgICB9XG4gICAgQ29tbW9uQ29udmVydGVyLmV4Y2x1ZGVCeUVycm9yTWVzc2FnZSA9IGV4Y2x1ZGVCeUVycm9yTWVzc2FnZTtcbn0pKGNvbW1vbl9jb252ZXJ0ZXJzX0NvbW1vbkNvbnZlcnRlciB8fCAoY29tbW9uX2NvbnZlcnRlcnNfQ29tbW9uQ29udmVydGVyID0ge30pKTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3R5cGUtY29udmVydGVycy9sc3AvbHNwLWNvbnZlcnRlcnMudHNcblxuXG5cblxuZnVuY3Rpb24gZnJvbVJhbmdlKHJhbmdlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgIGxpbmU6IHJhbmdlLnN0YXJ0LnJvdyxcbiAgICAgICAgICAgIGNoYXJhY3RlcjogcmFuZ2Uuc3RhcnQuY29sdW1uXG4gICAgICAgIH0sXG4gICAgICAgIGVuZDoge1xuICAgICAgICAgICAgbGluZTogcmFuZ2UuZW5kLnJvdyxcbiAgICAgICAgICAgIGNoYXJhY3RlcjogcmFuZ2UuZW5kLmNvbHVtblxuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJhbmdlRnJvbVBvc2l0aW9ucyhzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICBlbmQ6IGVuZFxuICAgIH07XG59XG5mdW5jdGlvbiB0b1JhbmdlKHJhbmdlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgIHJvdzogcmFuZ2Uuc3RhcnQubGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogcmFuZ2Uuc3RhcnQuY2hhcmFjdGVyXG4gICAgICAgIH0sXG4gICAgICAgIGVuZDoge1xuICAgICAgICAgICAgcm93OiByYW5nZS5lbmQubGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogcmFuZ2UuZW5kLmNoYXJhY3RlclxuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZyb21Qb2ludChwb2ludCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGxpbmU6IHBvaW50LnJvdyxcbiAgICAgICAgY2hhcmFjdGVyOiBwb2ludC5jb2x1bW5cbiAgICB9O1xufVxuZnVuY3Rpb24gdG9Qb2ludChwb3NpdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHJvdzogcG9zaXRpb24ubGluZSxcbiAgICAgICAgY29sdW1uOiBwb3NpdGlvbi5jaGFyYWN0ZXJcbiAgICB9O1xufVxuZnVuY3Rpb24gdG9Bbm5vdGF0aW9ucyhkaWFnbm9zdGljcykge1xuICAgIHZhciBfZGlhZ25vc3RpY3M7XG4gICAgcmV0dXJuIChfZGlhZ25vc3RpY3MgPSBkaWFnbm9zdGljcykgPT09IG51bGwgfHwgX2RpYWdub3N0aWNzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZGlhZ25vc3RpY3MubWFwKChlbCk9PntcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJvdzogZWwucmFuZ2Uuc3RhcnQubGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogZWwucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyLFxuICAgICAgICAgICAgdGV4dDogZWwubWVzc2FnZSxcbiAgICAgICAgICAgIHR5cGU6IGVsLnNldmVyaXR5ID09PSAxID8gXCJlcnJvclwiIDogZWwuc2V2ZXJpdHkgPT09IDIgPyBcIndhcm5pbmdcIiA6IFwiaW5mb1wiLFxuICAgICAgICAgICAgY29kZTogZWwuY29kZVxuICAgICAgICB9O1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZnJvbUFubm90YXRpb25zKGFubm90YXRpb25zKSB7XG4gICAgdmFyIF9hbm5vdGF0aW9ucztcbiAgICByZXR1cm4gKF9hbm5vdGF0aW9ucyA9IGFubm90YXRpb25zKSA9PT0gbnVsbCB8fCBfYW5ub3RhdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hbm5vdGF0aW9ucy5tYXAoKGVsKT0+e1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgICAgICBsaW5lOiBlbC5yb3csXG4gICAgICAgICAgICAgICAgICAgIGNoYXJhY3RlcjogZWwuY29sdW1uXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbmQ6IHtcbiAgICAgICAgICAgICAgICAgICAgbGluZTogZWwucm93LFxuICAgICAgICAgICAgICAgICAgICBjaGFyYWN0ZXI6IGVsLmNvbHVtblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZXNzYWdlOiBlbC50ZXh0LFxuICAgICAgICAgICAgc2V2ZXJpdHk6IGVsLnR5cGUgPT09IFwiZXJyb3JcIiA/IDEgOiBlbC50eXBlID09PSBcIndhcm5pbmdcIiA/IDIgOiAzLFxuICAgICAgICAgICAgY29kZTogZWxbXCJjb2RlXCJdXG4gICAgICAgIH07XG4gICAgfSk7XG59XG5mdW5jdGlvbiB0b0NvbXBsZXRpb24oaXRlbSkge1xuICAgIHZhciBfaXRlbV90ZXh0RWRpdCwgX2l0ZW1fY29tbWFuZDtcbiAgICBsZXQgaXRlbUtpbmQgPSBpdGVtLmtpbmQ7XG4gICAgbGV0IGtpbmQgPSBpdGVtS2luZCA/IE9iamVjdC5rZXlzKENvbXBsZXRpb25JdGVtS2luZClbT2JqZWN0LnZhbHVlcyhDb21wbGV0aW9uSXRlbUtpbmQpLmluZGV4T2YoaXRlbUtpbmQpXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgX2l0ZW1fdGV4dEVkaXRfbmV3VGV4dCwgX3JlZjtcbiAgICBsZXQgdGV4dCA9IChfcmVmID0gKF9pdGVtX3RleHRFZGl0X25ld1RleHQgPSAoX2l0ZW1fdGV4dEVkaXQgPSBpdGVtLnRleHRFZGl0KSA9PT0gbnVsbCB8fCBfaXRlbV90ZXh0RWRpdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2l0ZW1fdGV4dEVkaXQubmV3VGV4dCkgIT09IG51bGwgJiYgX2l0ZW1fdGV4dEVkaXRfbmV3VGV4dCAhPT0gdm9pZCAwID8gX2l0ZW1fdGV4dEVkaXRfbmV3VGV4dCA6IGl0ZW0uaW5zZXJ0VGV4dCkgIT09IG51bGwgJiYgX3JlZiAhPT0gdm9pZCAwID8gX3JlZiA6IGl0ZW0ubGFiZWw7XG4gICAgbGV0IGZpbHRlclRleHQ7XG4gICAgLy8gZmlsdGVyaW5nIHdvdWxkIGhhcHBlbiBvbiBhY2UgZWRpdG9yIHNpZGVcbiAgICAvL1RPRE86IGlmIGZpbHRlcmluZyBhbmQgc29ydGluZyBhcmUgb24gc2VydmVyIHNpZGUsIHdlIHNob3VsZCBkaXNhYmxlIEZpbHRlcmVkTGlzdCBpbiBhY2UgY29tcGxldGVyXG4gICAgaWYgKGl0ZW0uZmlsdGVyVGV4dCkge1xuICAgICAgICBjb25zdCBmaXJzdFdvcmRNYXRjaCA9IGl0ZW0uZmlsdGVyVGV4dC5tYXRjaCgvXFx3Ky8pO1xuICAgICAgICBjb25zdCBmaXJzdFdvcmQgPSBmaXJzdFdvcmRNYXRjaCA/IGZpcnN0V29yZE1hdGNoWzBdIDogbnVsbDtcbiAgICAgICAgaWYgKGZpcnN0V29yZCkge1xuICAgICAgICAgICAgY29uc3Qgd29yZFJlZ2V4ID0gbmV3IFJlZ0V4cChgXFxcXGIke2ZpcnN0V29yZH1cXFxcYmAsICdpJyk7XG4gICAgICAgICAgICBpZiAoIXdvcmRSZWdleC50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGAke2l0ZW0uZmlsdGVyVGV4dH0gJHt0ZXh0fWA7XG4gICAgICAgICAgICAgICAgZmlsdGVyVGV4dCA9IGl0ZW0uZmlsdGVyVGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGV4dC5pbmNsdWRlcyhpdGVtLmZpbHRlclRleHQpKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGAke2l0ZW0uZmlsdGVyVGV4dH0gJHt0ZXh0fWA7XG4gICAgICAgICAgICAgICAgZmlsdGVyVGV4dCA9IGl0ZW0uZmlsdGVyVGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgY29tbWFuZCA9ICgoX2l0ZW1fY29tbWFuZCA9IGl0ZW0uY29tbWFuZCkgPT09IG51bGwgfHwgX2l0ZW1fY29tbWFuZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2l0ZW1fY29tbWFuZC5jb21tYW5kKSA9PSBcImVkaXRvci5hY3Rpb24udHJpZ2dlclN1Z2dlc3RcIiA/IFwic3RhcnRBdXRvY29tcGxldGVcIiA6IHVuZGVmaW5lZDtcbiAgICBsZXQgcmFuZ2UgPSBpdGVtLnRleHRFZGl0ID8gZ2V0VGV4dEVkaXRSYW5nZShpdGVtLnRleHRFZGl0LCBmaWx0ZXJUZXh0KSA6IHVuZGVmaW5lZDtcbiAgICBsZXQgY29tcGxldGlvbiA9IHtcbiAgICAgICAgbWV0YToga2luZCxcbiAgICAgICAgY2FwdGlvbjogaXRlbS5sYWJlbCxcbiAgICAgICAgc2NvcmU6IHVuZGVmaW5lZFxuICAgIH07XG4gICAgY29tcGxldGlvbltcImNvbW1hbmRcIl0gPSBjb21tYW5kO1xuICAgIGNvbXBsZXRpb25bXCJyYW5nZVwiXSA9IHJhbmdlO1xuICAgIGNvbXBsZXRpb25bXCJpdGVtXCJdID0gaXRlbTtcbiAgICBpZiAoaXRlbS5pbnNlcnRUZXh0Rm9ybWF0ID09IEluc2VydFRleHRGb3JtYXQuU25pcHBldCkge1xuICAgICAgICBjb21wbGV0aW9uW1wic25pcHBldFwiXSA9IHRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29tcGxldGlvbltcInZhbHVlXCJdID0gdGV4dCAhPT0gbnVsbCAmJiB0ZXh0ICE9PSB2b2lkIDAgPyB0ZXh0IDogXCJcIjtcbiAgICB9XG4gICAgY29tcGxldGlvbltcImRvY3VtZW50YXRpb25cIl0gPSBpdGVtLmRvY3VtZW50YXRpb247IC8vVE9ETzogdGhpcyBpcyB3b3JrYXJvdW5kIGZvciBzZXJ2aWNlcyB3aXRoIGluc3RhbnQgY29tcGxldGlvblxuICAgIGNvbXBsZXRpb25bXCJwb3NpdGlvblwiXSA9IGl0ZW1bXCJwb3NpdGlvblwiXTtcbiAgICBjb21wbGV0aW9uW1wic2VydmljZVwiXSA9IGl0ZW1bXCJzZXJ2aWNlXCJdOyAvL1RPRE86IHNpbmNlIHdlIGhhdmUgbXVsdGlwbGUgc2VydmVycywgd2UgbmVlZCB0byBkZXRlcm1pbmUgd2hpY2hcbiAgICAvLyBzZXJ2ZXIgdG8gdXNlIGZvciByZXNvbHZpbmdcbiAgICByZXR1cm4gY29tcGxldGlvbjtcbn1cbmZ1bmN0aW9uIHRvQ29tcGxldGlvbnMoY29tcGxldGlvbnMpIHtcbiAgICBpZiAoY29tcGxldGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICBsZXQgY29tYmluZWRDb21wbGV0aW9ucyA9IGNvbXBsZXRpb25zLm1hcCgoZWwpPT57XG4gICAgICAgICAgICBpZiAoIWVsLmNvbXBsZXRpb25zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGFsbENvbXBsZXRpb25zO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZWwuY29tcGxldGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgYWxsQ29tcGxldGlvbnMgPSBlbC5jb21wbGV0aW9ucztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWxsQ29tcGxldGlvbnMgPSBlbC5jb21wbGV0aW9ucy5pdGVtcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhbGxDb21wbGV0aW9ucy5tYXAoKGl0ZW0pPT57XG4gICAgICAgICAgICAgICAgaXRlbVtcInNlcnZpY2VcIl0gPSBlbC5zZXJ2aWNlO1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLmZsYXQoKTtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkQ29tcGxldGlvbnMubWFwKChpdGVtKT0+dG9Db21wbGV0aW9uKGl0ZW0pKTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufVxuZnVuY3Rpb24gdG9SZXNvbHZlZENvbXBsZXRpb24oY29tcGxldGlvbiwgaXRlbSkge1xuICAgIGNvbXBsZXRpb25bXCJkb2NNYXJrZG93blwiXSA9IGZyb21NYXJrdXBDb250ZW50KGl0ZW0uZG9jdW1lbnRhdGlvbik7XG4gICAgcmV0dXJuIGNvbXBsZXRpb247XG59XG5mdW5jdGlvbiB0b0NvbXBsZXRpb25JdGVtKGNvbXBsZXRpb24pIHtcbiAgICBsZXQgY29tbWFuZDtcbiAgICBpZiAoY29tcGxldGlvbltcImNvbW1hbmRcIl0pIHtcbiAgICAgICAgY29tbWFuZCA9IHtcbiAgICAgICAgICAgIHRpdGxlOiBcInRyaWdnZXJTdWdnZXN0XCIsXG4gICAgICAgICAgICBjb21tYW5kOiBjb21wbGV0aW9uW1wiY29tbWFuZFwiXVxuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgX2NvbXBsZXRpb25fY2FwdGlvbjtcbiAgICBsZXQgY29tcGxldGlvbkl0ZW0gPSB7XG4gICAgICAgIGxhYmVsOiAoX2NvbXBsZXRpb25fY2FwdGlvbiA9IGNvbXBsZXRpb24uY2FwdGlvbikgIT09IG51bGwgJiYgX2NvbXBsZXRpb25fY2FwdGlvbiAhPT0gdm9pZCAwID8gX2NvbXBsZXRpb25fY2FwdGlvbiA6IFwiXCIsXG4gICAgICAgIGtpbmQ6IENvbW1vbkNvbnZlcnRlci5jb252ZXJ0S2luZChjb21wbGV0aW9uLm1ldGEpLFxuICAgICAgICBjb21tYW5kOiBjb21tYW5kLFxuICAgICAgICBpbnNlcnRUZXh0Rm9ybWF0OiBjb21wbGV0aW9uW1wic25pcHBldFwiXSA/IEluc2VydFRleHRGb3JtYXQuU25pcHBldCA6IEluc2VydFRleHRGb3JtYXQuUGxhaW5UZXh0LFxuICAgICAgICBkb2N1bWVudGF0aW9uOiBjb21wbGV0aW9uW1wiZG9jdW1lbnRhdGlvblwiXVxuICAgIH07XG4gICAgaWYgKGNvbXBsZXRpb25bXCJyYW5nZVwiXSkge1xuICAgICAgICB2YXIgX2NvbXBsZXRpb25fc25pcHBldDtcbiAgICAgICAgY29tcGxldGlvbkl0ZW0udGV4dEVkaXQgPSB7XG4gICAgICAgICAgICByYW5nZTogZnJvbVJhbmdlKGNvbXBsZXRpb25bXCJyYW5nZVwiXSksXG4gICAgICAgICAgICBuZXdUZXh0OiAoX2NvbXBsZXRpb25fc25pcHBldCA9IGNvbXBsZXRpb25bXCJzbmlwcGV0XCJdKSAhPT0gbnVsbCAmJiBfY29tcGxldGlvbl9zbmlwcGV0ICE9PSB2b2lkIDAgPyBfY29tcGxldGlvbl9zbmlwcGV0IDogY29tcGxldGlvbltcInZhbHVlXCJdXG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9jb21wbGV0aW9uX3NuaXBwZXQxO1xuICAgICAgICBjb21wbGV0aW9uSXRlbS5pbnNlcnRUZXh0ID0gKF9jb21wbGV0aW9uX3NuaXBwZXQxID0gY29tcGxldGlvbltcInNuaXBwZXRcIl0pICE9PSBudWxsICYmIF9jb21wbGV0aW9uX3NuaXBwZXQxICE9PSB2b2lkIDAgPyBfY29tcGxldGlvbl9zbmlwcGV0MSA6IGNvbXBsZXRpb25bXCJ2YWx1ZVwiXTtcbiAgICB9XG4gICAgY29tcGxldGlvbkl0ZW1bXCJmaWxlTmFtZVwiXSA9IGNvbXBsZXRpb25bXCJmaWxlTmFtZVwiXTtcbiAgICBjb21wbGV0aW9uSXRlbVtcInBvc2l0aW9uXCJdID0gY29tcGxldGlvbltcInBvc2l0aW9uXCJdO1xuICAgIGNvbXBsZXRpb25JdGVtW1wiaXRlbVwiXSA9IGNvbXBsZXRpb25bXCJpdGVtXCJdO1xuICAgIGNvbXBsZXRpb25JdGVtW1wic2VydmljZVwiXSA9IGNvbXBsZXRpb25bXCJzZXJ2aWNlXCJdOyAvL1RPRE86XG4gICAgcmV0dXJuIGNvbXBsZXRpb25JdGVtO1xufVxuZnVuY3Rpb24gZ2V0VGV4dEVkaXRSYW5nZSh0ZXh0RWRpdCwgZmlsdGVyVGV4dCkge1xuICAgIGNvbnN0IGZpbHRlckxlbmd0aCA9IGZpbHRlclRleHQgPyBmaWx0ZXJUZXh0Lmxlbmd0aCA6IDA7XG4gICAgaWYgKFwiaW5zZXJ0XCIgaW4gdGV4dEVkaXQgJiYgXCJyZXBsYWNlXCIgaW4gdGV4dEVkaXQpIHtcbiAgICAgICAgbGV0IG1lcmdlZFJhbmdlcyA9IG1lcmdlUmFuZ2VzKFtcbiAgICAgICAgICAgIHRvUmFuZ2UodGV4dEVkaXQuaW5zZXJ0KSxcbiAgICAgICAgICAgIHRvUmFuZ2UodGV4dEVkaXQucmVwbGFjZSlcbiAgICAgICAgXSk7XG4gICAgICAgIHJldHVybiBtZXJnZWRSYW5nZXNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dEVkaXQucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyIC09IGZpbHRlckxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRvUmFuZ2UodGV4dEVkaXQucmFuZ2UpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRvVG9vbHRpcChob3Zlcikge1xuICAgIHZhciBfaG92ZXJfZmluZDtcbiAgICBpZiAoIWhvdmVyKSByZXR1cm47XG4gICAgbGV0IGNvbnRlbnQgPSBob3Zlci5tYXAoKGVsKT0+e1xuICAgICAgICBpZiAoIWVsIHx8ICFlbC5jb250ZW50cykgcmV0dXJuO1xuICAgICAgICBpZiAoTWFya3VwQ29udGVudC5pcyhlbC5jb250ZW50cykpIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tTWFya3VwQ29udGVudChlbC5jb250ZW50cyk7XG4gICAgICAgIH0gZWxzZSBpZiAoTWFya2VkU3RyaW5nLmlzKGVsLmNvbnRlbnRzKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbC5jb250ZW50cyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbC5jb250ZW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBcImBgYFwiICsgZWwuY29udGVudHMudmFsdWUgKyBcImBgYFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGNvbnRlbnRzID0gZWwuY29udGVudHMubWFwKChlbCk9PntcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVsICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgXFxgXFxgXFxgJHtlbC52YWx1ZX1cXGBcXGBcXGBgO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBjb250ZW50cy5qb2luKFwiXFxuXFxuXCIpO1xuICAgICAgICB9XG4gICAgfSkuZmlsdGVyKG5vdEVtcHR5KTtcbiAgICBpZiAoY29udGVudC5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAvL1RPRE86IGl0IGNvdWxkIGJlIG1lcmdlZCB3aXRoaW4gYWxsIHJhbmdlcyBpbiBmdXR1cmVcbiAgICBsZXQgbHNwUmFuZ2UgPSAoX2hvdmVyX2ZpbmQgPSBob3Zlci5maW5kKChlbCk9PntcbiAgICAgICAgdmFyIF9lbDtcbiAgICAgICAgcmV0dXJuIChfZWwgPSBlbCkgPT09IG51bGwgfHwgX2VsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZWwucmFuZ2U7XG4gICAgfSkpID09PSBudWxsIHx8IF9ob3Zlcl9maW5kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaG92ZXJfZmluZC5yYW5nZTtcbiAgICBsZXQgcmFuZ2U7XG4gICAgaWYgKGxzcFJhbmdlKSByYW5nZSA9IHRvUmFuZ2UobHNwUmFuZ2UpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgICAgIHR5cGU6IFwibWFya2Rvd25cIixcbiAgICAgICAgICAgIHRleHQ6IGNvbnRlbnQuam9pbihcIlxcblxcblwiKVxuICAgICAgICB9LFxuICAgICAgICByYW5nZTogcmFuZ2VcbiAgICB9O1xufVxuZnVuY3Rpb24gZnJvbVNpZ25hdHVyZUhlbHAoc2lnbmF0dXJlSGVscCkge1xuICAgIGlmICghc2lnbmF0dXJlSGVscCkgcmV0dXJuO1xuICAgIGxldCBjb250ZW50ID0gc2lnbmF0dXJlSGVscC5tYXAoKGVsKT0+e1xuICAgICAgICB2YXIgX2VsLCBfZWwxO1xuICAgICAgICBpZiAoIWVsKSByZXR1cm47XG4gICAgICAgIGxldCBzaWduYXR1cmVJbmRleCA9ICgoX2VsID0gZWwpID09PSBudWxsIHx8IF9lbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2VsLmFjdGl2ZVNpZ25hdHVyZSkgfHwgMDtcbiAgICAgICAgbGV0IGFjdGl2ZVNpZ25hdHVyZSA9IGVsLnNpZ25hdHVyZXNbc2lnbmF0dXJlSW5kZXhdO1xuICAgICAgICBpZiAoIWFjdGl2ZVNpZ25hdHVyZSkgcmV0dXJuO1xuICAgICAgICBsZXQgYWN0aXZlUGFyYW0gPSAoX2VsMSA9IGVsKSA9PT0gbnVsbCB8fCBfZWwxID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZWwxLmFjdGl2ZVBhcmFtZXRlcjtcbiAgICAgICAgbGV0IGNvbnRlbnRzID0gYWN0aXZlU2lnbmF0dXJlLmxhYmVsO1xuICAgICAgICBpZiAoYWN0aXZlUGFyYW0gIT0gdW5kZWZpbmVkICYmIGFjdGl2ZVNpZ25hdHVyZS5wYXJhbWV0ZXJzICYmIGFjdGl2ZVNpZ25hdHVyZS5wYXJhbWV0ZXJzW2FjdGl2ZVBhcmFtXSkge1xuICAgICAgICAgICAgbGV0IHBhcmFtID0gYWN0aXZlU2lnbmF0dXJlLnBhcmFtZXRlcnNbYWN0aXZlUGFyYW1dLmxhYmVsO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJhbSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgY29udGVudHMgPSBjb250ZW50cy5yZXBsYWNlKHBhcmFtLCBgKioke3BhcmFtfSoqYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGl2ZVNpZ25hdHVyZS5kb2N1bWVudGF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoTWFya3VwQ29udGVudC5pcyhhY3RpdmVTaWduYXR1cmUuZG9jdW1lbnRhdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudHMgKyBcIlxcblxcblwiICsgZnJvbU1hcmt1cENvbnRlbnQoYWN0aXZlU2lnbmF0dXJlLmRvY3VtZW50YXRpb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZW50cyArPSBcIlxcblxcblwiICsgYWN0aXZlU2lnbmF0dXJlLmRvY3VtZW50YXRpb247XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRzO1xuICAgICAgICB9XG4gICAgfSkuZmlsdGVyKG5vdEVtcHR5KTtcbiAgICBpZiAoY29udGVudC5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICB0eXBlOiBcIm1hcmtkb3duXCIsXG4gICAgICAgICAgICB0ZXh0OiBjb250ZW50LmpvaW4oXCJcXG5cXG5cIilcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBmcm9tTWFya3VwQ29udGVudChjb250ZW50KSB7XG4gICAgaWYgKCFjb250ZW50KSByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb250ZW50LnZhbHVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZyb21BY2VEZWx0YShkZWx0YSwgZW9sKSB7XG4gICAgY29uc3QgdGV4dCA9IGRlbHRhLmxpbmVzLmxlbmd0aCA+IDEgPyBkZWx0YS5saW5lcy5qb2luKGVvbCkgOiBkZWx0YS5saW5lc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgICByYW5nZTogZGVsdGEuYWN0aW9uID09PSBcImluc2VydFwiID8gcmFuZ2VGcm9tUG9zaXRpb25zKGZyb21Qb2ludChkZWx0YS5zdGFydCksIGZyb21Qb2ludChkZWx0YS5zdGFydCkpIDogcmFuZ2VGcm9tUG9zaXRpb25zKGZyb21Qb2ludChkZWx0YS5zdGFydCksIGZyb21Qb2ludChkZWx0YS5lbmQpKSxcbiAgICAgICAgdGV4dDogZGVsdGEuYWN0aW9uID09PSBcImluc2VydFwiID8gdGV4dCA6IFwiXCJcbiAgICB9O1xufVxuZnVuY3Rpb24gZmlsdGVyRGlhZ25vc3RpY3MoZGlhZ25vc3RpY3MsIGZpbHRlckVycm9ycykge1xuICAgIHJldHVybiBjb21tb25fY29udmVydGVyc19Db21tb25Db252ZXJ0ZXIuZXhjbHVkZUJ5RXJyb3JNZXNzYWdlKGRpYWdub3N0aWNzLCBmaWx0ZXJFcnJvcnMuZXJyb3JNZXNzYWdlc1RvSWdub3JlKS5tYXAoKGVsKT0+e1xuICAgICAgICBpZiAoKDAsdXRpbHMvKiBjaGVja1ZhbHVlQWdhaW5zdFJlZ2V4cEFycmF5ICovLlRrKShlbC5tZXNzYWdlLCBmaWx0ZXJFcnJvcnMuZXJyb3JNZXNzYWdlc1RvVHJlYXRBc1dhcm5pbmcpKSB7XG4gICAgICAgICAgICBlbC5zZXZlcml0eSA9IGJyb3dzZXJfbWFpbi5EaWFnbm9zdGljU2V2ZXJpdHkuV2FybmluZztcbiAgICAgICAgfSBlbHNlIGlmICgoMCx1dGlscy8qIGNoZWNrVmFsdWVBZ2FpbnN0UmVnZXhwQXJyYXkgKi8uVGspKGVsLm1lc3NhZ2UsIGZpbHRlckVycm9ycy5lcnJvck1lc3NhZ2VzVG9UcmVhdEFzSW5mbykpIHtcbiAgICAgICAgICAgIGVsLnNldmVyaXR5ID0gYnJvd3Nlcl9tYWluLkRpYWdub3N0aWNTZXZlcml0eS5JbmZvcm1hdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWw7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBmcm9tRG9jdW1lbnRIaWdobGlnaHRzKGRvY3VtZW50SGlnaGxpZ2h0cykge1xuICAgIHJldHVybiBkb2N1bWVudEhpZ2hsaWdodHMubWFwKGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIGxldCBjbGFzc05hbWUgPSBlbC5raW5kID09IDIgPyBcImxhbmd1YWdlX2hpZ2hsaWdodF9yZWFkXCIgOiBlbC5raW5kID09IDMgPyBcImxhbmd1YWdlX2hpZ2hsaWdodF93cml0ZVwiIDogXCJsYW5ndWFnZV9oaWdobGlnaHRfdGV4dFwiO1xuICAgICAgICByZXR1cm4gdG9NYXJrZXJHcm91cEl0ZW0oQ29tbW9uQ29udmVydGVyLnRvUmFuZ2UodG9SYW5nZShlbC5yYW5nZSkpLCBjbGFzc05hbWUpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gdG9NYXJrZXJHcm91cEl0ZW0ocmFuZ2UsIGNsYXNzTmFtZSwgdG9vbHRpcFRleHQpIHtcbiAgICBsZXQgbWFya2VyR3JvdXBJdGVtID0ge1xuICAgICAgICByYW5nZTogcmFuZ2UsXG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXG4gICAgfTtcbiAgICBpZiAodG9vbHRpcFRleHQpIHtcbiAgICAgICAgbWFya2VyR3JvdXBJdGVtW1widG9vbHRpcFRleHRcIl0gPSB0b29sdGlwVGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIG1hcmtlckdyb3VwSXRlbTtcbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3NlcnZpY2VzL2pzb24vanNvbi1zZXJ2aWNlLnRzXG5mdW5jdGlvbiBqc29uX3NlcnZpY2VfZGVmaW5lX3Byb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5cblxuXG5jbGFzcyBKc29uU2VydmljZSBleHRlbmRzIGJhc2Vfc2VydmljZS5CYXNlU2VydmljZSB7XG4gICAgJGdldEpzb25TY2hlbWFVcmkoZG9jdW1lbnRVcmkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9uKGRvY3VtZW50VXJpLCBcInNjaGVtYVVyaVwiKTtcbiAgICB9XG4gICAgYWRkRG9jdW1lbnQoZG9jdW1lbnQpIHtcbiAgICAgICAgc3VwZXIuYWRkRG9jdW1lbnQoZG9jdW1lbnQpO1xuICAgICAgICB0aGlzLiRjb25maWd1cmVTZXJ2aWNlKGRvY3VtZW50LnVyaSk7XG4gICAgfVxuICAgIGdldFNjaGVtYU9wdGlvbihkb2N1bWVudFVyaSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPcHRpb24oZG9jdW1lbnRVcmkgIT09IG51bGwgJiYgZG9jdW1lbnRVcmkgIT09IHZvaWQgMCA/IGRvY3VtZW50VXJpIDogXCJcIiwgXCJzY2hlbWFzXCIpO1xuICAgIH1cbiAgICAkY29uZmlndXJlU2VydmljZShkb2N1bWVudFVyaSkge1xuICAgICAgICB2YXIgX3NjaGVtYXM7XG4gICAgICAgIGxldCBzY2hlbWFzID0gdGhpcy5nZXRTY2hlbWFPcHRpb24oZG9jdW1lbnRVcmkpO1xuICAgICAgICBsZXQgc2Vzc2lvbklEcyA9IGRvY3VtZW50VXJpID8gW10gOiBPYmplY3Qua2V5cyh0aGlzLmRvY3VtZW50cyk7XG4gICAgICAgIChfc2NoZW1hcyA9IHNjaGVtYXMpID09PSBudWxsIHx8IF9zY2hlbWFzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc2NoZW1hcy5mb3JFYWNoKChlbCk9PntcbiAgICAgICAgICAgIGlmIChkb2N1bWVudFVyaSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiRnZXRKc29uU2NoZW1hVXJpKGRvY3VtZW50VXJpKSA9PSBlbC51cmkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9lbDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9maWxlTWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIChfZmlsZU1hdGNoID0gKF9lbCA9IGVsKS5maWxlTWF0Y2gpICE9PSBudWxsICYmIF9maWxlTWF0Y2ggIT09IHZvaWQgMCA/IF9maWxlTWF0Y2ggOiBfZWwuZmlsZU1hdGNoID0gW107XG4gICAgICAgICAgICAgICAgICAgIGVsLmZpbGVNYXRjaC5wdXNoKGRvY3VtZW50VXJpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsLmZpbGVNYXRjaCA9IHNlc3Npb25JRHMuZmlsdGVyKChkb2N1bWVudFVyaSk9PnRoaXMuJGdldEpzb25TY2hlbWFVcmkoZG9jdW1lbnRVcmkpID09IGVsLnVyaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2VsX3NjaGVtYTtcbiAgICAgICAgICAgIGxldCBzY2hlbWEgPSAoX2VsX3NjaGVtYSA9IGVsLnNjaGVtYSkgIT09IG51bGwgJiYgX2VsX3NjaGVtYSAhPT0gdm9pZCAwID8gX2VsX3NjaGVtYSA6IHRoaXMuc2NoZW1hc1tlbC51cmldO1xuICAgICAgICAgICAgaWYgKHNjaGVtYSkgdGhpcy5zY2hlbWFzW2VsLnVyaV0gPSBzY2hlbWE7XG4gICAgICAgICAgICB0aGlzLiRzZXJ2aWNlLnJlc2V0U2NoZW1hKGVsLnVyaSk7XG4gICAgICAgICAgICBlbC5zY2hlbWEgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiRjb25maWd1cmVKc29uU2VydmljZShzY2hlbWFzKTtcbiAgICB9XG4gICAgJGNvbmZpZ3VyZUpzb25TZXJ2aWNlKHNjaGVtYXMpIHtcbiAgICAgICAgdGhpcy4kc2VydmljZS5jb25maWd1cmUoe1xuICAgICAgICAgICAgc2NoZW1hczogc2NoZW1hcyxcbiAgICAgICAgICAgIGFsbG93Q29tbWVudHM6IHRoaXMubW9kZSA9PT0gXCJqc29uNVwiLFxuICAgICAgICAgICAgdmFsaWRhdGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbW92ZURvY3VtZW50KGRvY3VtZW50KSB7XG4gICAgICAgIHZhciBfc2NoZW1hcztcbiAgICAgICAgc3VwZXIucmVtb3ZlRG9jdW1lbnQoZG9jdW1lbnQpO1xuICAgICAgICBsZXQgc2NoZW1hcyA9IHRoaXMuZ2V0T3B0aW9uKGRvY3VtZW50LnVyaSwgXCJzY2hlbWFzXCIpO1xuICAgICAgICAoX3NjaGVtYXMgPSBzY2hlbWFzKSA9PT0gbnVsbCB8fCBfc2NoZW1hcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3NjaGVtYXMuZm9yRWFjaCgoZWwpPT57XG4gICAgICAgICAgICBpZiAoZWwudXJpID09PSB0aGlzLiRnZXRKc29uU2NoZW1hVXJpKGRvY3VtZW50LnVyaSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2VsX2ZpbGVNYXRjaDtcbiAgICAgICAgICAgICAgICBlbC5maWxlTWF0Y2ggPSAoX2VsX2ZpbGVNYXRjaCA9IGVsLmZpbGVNYXRjaCkgPT09IG51bGwgfHwgX2VsX2ZpbGVNYXRjaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2VsX2ZpbGVNYXRjaC5maWx0ZXIoKHBhdHRlcm4pPT5wYXR0ZXJuICE9IGRvY3VtZW50LnVyaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiRjb25maWd1cmVKc29uU2VydmljZShzY2hlbWFzKTtcbiAgICB9XG4gICAgc2V0T3B0aW9ucyhkb2N1bWVudFVyaSwgb3B0aW9ucywgbWVyZ2UgPSBmYWxzZSkge1xuICAgICAgICBzdXBlci5zZXRPcHRpb25zKGRvY3VtZW50VXJpLCBvcHRpb25zLCBtZXJnZSk7XG4gICAgICAgIHRoaXMuJGNvbmZpZ3VyZVNlcnZpY2UoZG9jdW1lbnRVcmkpO1xuICAgIH1cbiAgICBzZXRHbG9iYWxPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIuc2V0R2xvYmFsT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdGhpcy4kY29uZmlndXJlU2VydmljZSgpO1xuICAgIH1cbiAgICBmb3JtYXQoZG9jdW1lbnQsIHJhbmdlLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBmdWxsRG9jdW1lbnQgPSB0aGlzLmdldERvY3VtZW50KGRvY3VtZW50LnVyaSk7XG4gICAgICAgIGlmICghZnVsbERvY3VtZW50KSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtdKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLiRzZXJ2aWNlLmZvcm1hdChmdWxsRG9jdW1lbnQsIHJhbmdlLCBvcHRpb25zKSk7XG4gICAgfVxuICAgIGFzeW5jIGRvSG92ZXIoZG9jdW1lbnQsIHBvc2l0aW9uKSB7XG4gICAgICAgIGxldCBmdWxsRG9jdW1lbnQgPSB0aGlzLmdldERvY3VtZW50KGRvY3VtZW50LnVyaSk7XG4gICAgICAgIGlmICghZnVsbERvY3VtZW50KSByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGpzb25Eb2N1bWVudCA9IHRoaXMuJHNlcnZpY2UucGFyc2VKU09ORG9jdW1lbnQoZnVsbERvY3VtZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHNlcnZpY2UuZG9Ib3ZlcihmdWxsRG9jdW1lbnQsIHBvc2l0aW9uLCBqc29uRG9jdW1lbnQpO1xuICAgIH1cbiAgICBhc3luYyBkb1ZhbGlkYXRpb24oZG9jdW1lbnQpIHtcbiAgICAgICAgbGV0IGZ1bGxEb2N1bWVudCA9IHRoaXMuZ2V0RG9jdW1lbnQoZG9jdW1lbnQudXJpKTtcbiAgICAgICAgaWYgKCFmdWxsRG9jdW1lbnQpIHJldHVybiBbXTtcbiAgICAgICAgbGV0IGpzb25Eb2N1bWVudCA9IHRoaXMuJHNlcnZpY2UucGFyc2VKU09ORG9jdW1lbnQoZnVsbERvY3VtZW50KTtcbiAgICAgICAgbGV0IGRpYWdub3N0aWNzID0gYXdhaXQgdGhpcy4kc2VydmljZS5kb1ZhbGlkYXRpb24oZnVsbERvY3VtZW50LCBqc29uRG9jdW1lbnQsIHtcbiAgICAgICAgICAgIHRyYWlsaW5nQ29tbWFzOiB0aGlzLm1vZGUgPT09IFwianNvbjVcIiA/IFwiaWdub3JlXCIgOiBcImVycm9yXCJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmaWx0ZXJEaWFnbm9zdGljcyhkaWFnbm9zdGljcywgdGhpcy5vcHRpb25zVG9GaWx0ZXJEaWFnbm9zdGljcyk7XG4gICAgfVxuICAgIGFzeW5jIGRvQ29tcGxldGUoZG9jdW1lbnQsIHBvc2l0aW9uKSB7XG4gICAgICAgIGxldCBmdWxsRG9jdW1lbnQgPSB0aGlzLmdldERvY3VtZW50KGRvY3VtZW50LnVyaSk7XG4gICAgICAgIGlmICghZnVsbERvY3VtZW50KSByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGpzb25Eb2N1bWVudCA9IHRoaXMuJHNlcnZpY2UucGFyc2VKU09ORG9jdW1lbnQoZnVsbERvY3VtZW50KTtcbiAgICAgICAgY29uc3QgY29tcGxldGlvbnMgPSBhd2FpdCB0aGlzLiRzZXJ2aWNlLmRvQ29tcGxldGUoZnVsbERvY3VtZW50LCBwb3NpdGlvbiwganNvbkRvY3VtZW50KTtcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRpb25zO1xuICAgIH1cbiAgICBhc3luYyBkb1Jlc29sdmUoaXRlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy4kc2VydmljZS5kb1Jlc29sdmUoaXRlbSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG1vZGUpe1xuICAgICAgICBzdXBlcihtb2RlKTtcbiAgICAgICAganNvbl9zZXJ2aWNlX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcIiRzZXJ2aWNlXCIsIHZvaWQgMCk7XG4gICAgICAgIGpzb25fc2VydmljZV9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJzY2hlbWFzXCIsIHt9KTtcbiAgICAgICAganNvbl9zZXJ2aWNlX2RlZmluZV9wcm9wZXJ0eSh0aGlzLCBcInNlcnZpY2VDYXBhYmlsaXRpZXNcIiwge1xuICAgICAgICAgICAgY29tcGxldGlvblByb3ZpZGVyOiB7XG4gICAgICAgICAgICAgICAgdHJpZ2dlckNoYXJhY3RlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgJ1wiJyxcbiAgICAgICAgICAgICAgICAgICAgJzonXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpYWdub3N0aWNQcm92aWRlcjoge1xuICAgICAgICAgICAgICAgIGludGVyRmlsZURlcGVuZGVuY2llczogdHJ1ZSxcbiAgICAgICAgICAgICAgICB3b3Jrc3BhY2VEaWFnbm9zdGljczogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRvY3VtZW50UmFuZ2VGb3JtYXR0aW5nUHJvdmlkZXI6IHRydWUsXG4gICAgICAgICAgICBkb2N1bWVudEZvcm1hdHRpbmdQcm92aWRlcjogdHJ1ZSxcbiAgICAgICAgICAgIGhvdmVyUHJvdmlkZXI6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuJHNlcnZpY2UgPSBnZXRMYW5ndWFnZVNlcnZpY2Uoe1xuICAgICAgICAgICAgc2NoZW1hUmVxdWVzdFNlcnZpY2U6ICh1cmkpPT57XG4gICAgICAgICAgICAgICAgdXJpID0gdXJpLnJlcGxhY2UoXCJmaWxlOi8vL1wiLCBcIlwiKTtcbiAgICAgICAgICAgICAgICBsZXQganNvblNjaGVtYSA9IHRoaXMuc2NoZW1hc1t1cmldO1xuICAgICAgICAgICAgICAgIGlmIChqc29uU2NoZW1hKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGpzb25TY2hlbWEpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmV0Y2ggIT09ICd1bmRlZmluZWQnICYmIC9eaHR0cHM/OlxcL1xcLy8udGVzdCh1cmkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmZXRjaCh1cmkpLnRoZW4oKHJlc3BvbnNlKT0+cmVzcG9uc2UudGV4dCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGBVbmFibGUgdG8gbG9hZCBzY2hlbWEgYXQgJHt1cml9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxufSkoKTtcblxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX2V4cG9ydHNfXztcbi8qKioqKiovIH0pKClcbjtcbn0pOyJdLCJuYW1lcyI6WyJ3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsInJvb3QiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsImFtZCIsImEiLCJpIiwiX193ZWJwYWNrX21vZHVsZXNfXyIsIl9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJwcm9jZXNzIiwiY29uc29sZSIsIl90eXBlb2YiLCJvYmoiLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsIl9yZXF1aXJlIiwiX3JlcXVpcmUkY29kZXMiLCJjb2RlcyIsIkVSUl9BTUJJR1VPVVNfQVJHVU1FTlQiLCJFUlJfSU5WQUxJRF9BUkdfVFlQRSIsIkVSUl9JTlZBTElEX0FSR19WQUxVRSIsIkVSUl9JTlZBTElEX1JFVFVSTl9WQUxVRSIsIkVSUl9NSVNTSU5HX0FSR1MiLCJBc3NlcnRpb25FcnJvciIsIl9yZXF1aXJlMiIsImluc3BlY3QiLCJfcmVxdWlyZSR0eXBlcyIsInR5cGVzIiwiaXNQcm9taXNlIiwiaXNSZWdFeHAiLCJvYmplY3RBc3NpZ24iLCJPYmplY3QiLCJhc3NpZ24iLCJvYmplY3RJcyIsImlzIiwiZXJyb3JDYWNoZSIsIk1hcCIsImlzRGVlcEVxdWFsIiwiaXNEZWVwU3RyaWN0RXF1YWwiLCJwYXJzZUV4cHJlc3Npb25BdCIsImZpbmROb2RlQXJvdW5kIiwiZGVjb2RlciIsImxhenlMb2FkQ29tcGFyaXNvbiIsImNvbXBhcmlzb24iLCJlc2NhcGVTZXF1ZW5jZXNSZWdFeHAiLCJtZXRhIiwiZXNjYXBlRm4iLCJzdHIiLCJjaGFyQ29kZUF0Iiwid2FybmVkIiwiYXNzZXJ0Iiwib2siLCJOT19FWENFUFRJT05fU0VOVElORUwiLCJpbm5lckZhaWwiLCJtZXNzYWdlIiwiRXJyb3IiLCJmYWlsIiwiYWN0dWFsIiwiZXhwZWN0ZWQiLCJvcGVyYXRvciIsInN0YWNrU3RhcnRGbiIsImFyZ3NMZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJpbnRlcm5hbE1lc3NhZ2UiLCJ1bmRlZmluZWQiLCJ3YXJuIiwiZW1pdFdhcm5pbmciLCJiaW5kIiwiZXJyQXJncyIsImVyciIsImdlbmVyYXRlZE1lc3NhZ2UiLCJpbm5lck9rIiwiZm4iLCJhcmdMZW4iLCJ2YWx1ZSIsIl9sZW4iLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwiYXBwbHkiLCJjb25jYXQiLCJlcXVhbCIsIm5vdEVxdWFsIiwiZGVlcEVxdWFsIiwibm90RGVlcEVxdWFsIiwiZGVlcFN0cmljdEVxdWFsIiwibm90RGVlcFN0cmljdEVxdWFsIiwic3RyaWN0RXF1YWwiLCJub3RTdHJpY3RFcXVhbCIsIkNvbXBhcmlzb24iLCJrZXlzIiwiX3RoaXMiLCJmb3JFYWNoIiwia2V5IiwidGVzdCIsImNvbXBhcmVFeGNlcHRpb25LZXkiLCJiIiwibmFtZSIsImV4cGVjdGVkRXhjZXB0aW9uIiwibXNnIiwicHVzaCIsImlzUHJvdG90eXBlT2YiLCJjYWxsIiwiZ2V0QWN0dWFsIiwiZSIsImNoZWNrSXNQcm9taXNlIiwidGhlbiIsImNhdGNoIiwid2FpdEZvckFjdHVhbCIsInByb21pc2VGbiIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVzdWx0UHJvbWlzZSIsImV4cGVjdHNFcnJvciIsImVycm9yIiwiZGV0YWlscyIsImZuVHlwZSIsImV4cGVjdHNOb0Vycm9yIiwidGhyb3dzIiwiX2xlbjIiLCJfa2V5MiIsInJlamVjdHMiLCJfbGVuMyIsIl9rZXkzIiwicmVzdWx0IiwiZG9lc05vdFRocm93IiwiX2xlbjQiLCJfa2V5NCIsImRvZXNOb3RSZWplY3QiLCJfbGVuNSIsIl9rZXk1IiwiaWZFcnJvciIsIm5ld0VyciIsIm9yaWdTdGFjayIsInN0YWNrIiwidG1wMiIsInNwbGl0Iiwic2hpZnQiLCJ0bXAxIiwicG9zIiwiaW5kZXhPZiIsInNsaWNlIiwiam9pbiIsInN0cmljdCIsIl9sZW42IiwiX2tleTYiLCJfb2JqZWN0U3ByZWFkIiwidGFyZ2V0Iiwic291cmNlIiwib3duS2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsInN5bSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJfZGVmaW5lUHJvcGVydHkiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX2RlZmluZVByb3BlcnRpZXMiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsInNlbGYiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwiUmVmZXJlbmNlRXJyb3IiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJfc2V0UHJvdG90eXBlT2YiLCJfd3JhcE5hdGl2ZVN1cGVyIiwiQ2xhc3MiLCJfY2FjaGUiLCJfaXNOYXRpdmVGdW5jdGlvbiIsImhhcyIsImdldCIsInNldCIsIldyYXBwZXIiLCJfY29uc3RydWN0IiwiX2dldFByb3RvdHlwZU9mIiwiaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiUmVmbGVjdCIsImNvbnN0cnVjdCIsInNoYW0iLCJQcm94eSIsIkRhdGUiLCJ0b1N0cmluZyIsIlBhcmVudCIsIkZ1bmN0aW9uIiwibyIsInAiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsImdldFByb3RvdHlwZU9mIiwiZW5kc1dpdGgiLCJzZWFyY2giLCJ0aGlzX2xlbiIsInN1YnN0cmluZyIsInJlcGVhdCIsImNvdW50IiwiTWF0aCIsImZsb29yIiwibWF4Q291bnQiLCJsb2ciLCJibHVlIiwiZ3JlZW4iLCJyZWQiLCJ3aGl0ZSIsImtSZWFkYWJsZU9wZXJhdG9yIiwic3RyaWN0RXF1YWxPYmplY3QiLCJub3RTdHJpY3RFcXVhbE9iamVjdCIsIm5vdElkZW50aWNhbCIsImtNYXhTaG9ydExlbmd0aCIsImNvcHlFcnJvciIsImluc3BlY3RWYWx1ZSIsInZhbCIsImNvbXBhY3QiLCJjdXN0b21JbnNwZWN0IiwiZGVwdGgiLCJtYXhBcnJheUxlbmd0aCIsIkluZmluaXR5Iiwic2hvd0hpZGRlbiIsImJyZWFrTGVuZ3RoIiwic2hvd1Byb3h5Iiwic29ydGVkIiwiZ2V0dGVycyIsImNyZWF0ZUVyckRpZmYiLCJvdGhlciIsInJlcyIsImxhc3RQb3MiLCJlbmQiLCJza2lwcGVkIiwiYWN0dWFsSW5zcGVjdGVkIiwiYWN0dWFsTGluZXMiLCJleHBlY3RlZExpbmVzIiwiaW5kaWNhdG9yIiwiaW5wdXRMZW5ndGgiLCJtYXhMZW5ndGgiLCJzdGRlcnIiLCJpc1RUWSIsImNvbHVtbnMiLCJwb3AiLCJtYXhMaW5lcyIsIm1heCIsIl9hY3R1YWxMaW5lcyIsInByaW50ZWRMaW5lcyIsInNraXBwZWRNc2ciLCJjdXIiLCJleHBlY3RlZExpbmUiLCJhY3R1YWxMaW5lIiwiZGl2ZXJnaW5nTGluZXMiLCJfRXJyb3IiLCJvcHRpb25zIiwibGltaXQiLCJzdGFja1RyYWNlTGltaXQiLCJTdHJpbmciLCJnZXRDb2xvckRlcHRoIiwiYmFzZSIsIl9yZXMiLCJrbm93bk9wZXJhdG9ycyIsImNvZGUiLCJjYXB0dXJlU3RhY2tUcmFjZSIsImN1c3RvbSIsInJlY3Vyc2VUaW1lcyIsImN0eCIsInV0aWwiLCJjcmVhdGVFcnJvclR5cGUiLCJCYXNlIiwiZ2V0TWVzc2FnZSIsImFyZzEiLCJhcmcyIiwiYXJnMyIsIk5vZGVFcnJvciIsIl9CYXNlIiwib25lT2YiLCJ0aGluZyIsImlzQXJyYXkiLCJsZW4iLCJtYXAiLCJzdGFydHNXaXRoIiwic3Vic3RyIiwiaW5jbHVkZXMiLCJzdGFydCIsImRldGVybWluZXIiLCJyZXBsYWNlIiwidHlwZSIsInJlYXNvbiIsImluc3BlY3RlZCIsIlJhbmdlRXJyb3IiLCJpbnB1dCIsIl9zbGljZWRUb0FycmF5IiwiYXJyIiwiX2FycmF5V2l0aEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwiX25vbkl0ZXJhYmxlUmVzdCIsIl9hcnIiLCJfbiIsIl9kIiwiX2UiLCJfaSIsIl9zIiwibmV4dCIsImRvbmUiLCJyZWdleEZsYWdzU3VwcG9ydGVkIiwiZmxhZ3MiLCJhcnJheUZyb21TZXQiLCJhcnJheSIsImFycmF5RnJvbU1hcCIsIm9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyIsIm51bWJlcklzTmFOIiwiTnVtYmVyIiwiaXNOYU4iLCJ1bmN1cnJ5VGhpcyIsImYiLCJoYXNPd25Qcm9wZXJ0eSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwib2JqZWN0VG9TdHJpbmciLCJpc0FueUFycmF5QnVmZmVyIiwiaXNBcnJheUJ1ZmZlclZpZXciLCJpc0RhdGUiLCJpc01hcCIsImlzU2V0IiwiaXNOYXRpdmVFcnJvciIsImlzQm94ZWRQcmltaXRpdmUiLCJpc051bWJlck9iamVjdCIsImlzU3RyaW5nT2JqZWN0IiwiaXNCb29sZWFuT2JqZWN0IiwiaXNCaWdJbnRPYmplY3QiLCJpc1N5bWJvbE9iamVjdCIsImlzRmxvYXQzMkFycmF5IiwiaXNGbG9hdDY0QXJyYXkiLCJpc05vbkluZGV4IiwicG93IiwiZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzIiwiY29tcGFyZSIsIngiLCJ5IiwibWluIiwiT05MWV9FTlVNRVJBQkxFIiwia1N0cmljdCIsImtMb29zZSIsImtOb0l0ZXJhdG9yIiwia0lzQXJyYXkiLCJrSXNTZXQiLCJrSXNNYXAiLCJhcmVTaW1pbGFyUmVnRXhwcyIsIlJlZ0V4cCIsImFyZVNpbWlsYXJGbG9hdEFycmF5cyIsImJ5dGVMZW5ndGgiLCJvZmZzZXQiLCJhcmVTaW1pbGFyVHlwZWRBcnJheXMiLCJVaW50OEFycmF5IiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsImFyZUVxdWFsQXJyYXlCdWZmZXJzIiwiYnVmMSIsImJ1ZjIiLCJpc0VxdWFsQm94ZWRQcmltaXRpdmUiLCJ2YWwxIiwidmFsMiIsInZhbHVlT2YiLCJCb29sZWFuIiwiQmlnSW50IiwiaW5uZXJEZWVwRXF1YWwiLCJtZW1vcyIsInZhbDFUYWciLCJ2YWwyVGFnIiwia2V5czEiLCJrZXlzMiIsImtleUNoZWNrIiwiZ2V0VGltZSIsIl9rZXlzIiwiX2tleXMyIiwic2l6ZSIsImdldEVudW1lcmFibGVzIiwiayIsIml0ZXJhdGlvblR5cGUiLCJhS2V5cyIsImJLZXlzIiwic3ltYm9sS2V5c0EiLCJzeW1ib2xLZXlzQiIsIl9zeW1ib2xLZXlzQiIsInBvc2l0aW9uIiwidmFsMk1lbW9BIiwidmFsMk1lbW9CIiwiYXJlRXEiLCJvYmpFcXVpdiIsImRlbGV0ZSIsInNldEhhc0VxdWFsRWxlbWVudCIsIm1lbW8iLCJzZXRWYWx1ZXMiLCJmaW5kTG9vc2VNYXRjaGluZ1ByaW1pdGl2ZXMiLCJwcmltIiwic2V0TWlnaHRIYXZlTG9vc2VQcmltIiwiYWx0VmFsdWUiLCJtYXBNaWdodEhhdmVMb29zZVByaW0iLCJpdGVtIiwiY3VyQiIsInNldEVxdWl2IiwiYVZhbHVlcyIsIlNldCIsImFkZCIsImJWYWx1ZXMiLCJfdmFsIiwibWFwSGFzRXF1YWxFbnRyeSIsImtleTEiLCJpdGVtMSIsImtleTIiLCJtYXBFcXVpdiIsImFFbnRyaWVzIiwiX2FFbnRyaWVzJGkiLCJpdGVtMiIsImJFbnRyaWVzIiwiX2kyIiwiX2JFbnRyaWVzJF9pIiwia2V5c0EiLCJHZXRJbnRyaW5zaWMiLCJjYWxsQmluZCIsIiRpbmRleE9mIiwiY2FsbEJvdW5kSW50cmluc2ljIiwiYWxsb3dNaXNzaW5nIiwiaW50cmluc2ljIiwic2V0RnVuY3Rpb25MZW5ndGgiLCIkVHlwZUVycm9yIiwiJGFwcGx5IiwiJGNhbGwiLCIkcmVmbGVjdEFwcGx5IiwiJGRlZmluZVByb3BlcnR5IiwiJG1heCIsIm9yaWdpbmFsRnVuY3Rpb24iLCJmdW5jIiwiYXBwbHlCaW5kIiwibm93IiwidGltZXMiLCJnIiwid2luZG93IiwiZnVuY3Rpb25zIiwiaW5mbyIsInRpbWUiLCJ0aW1lRW5kIiwidHJhY2UiLCJkaXIiLCJjb25zb2xlQXNzZXJ0IiwidHVwbGUiLCJsYWJlbCIsImR1cmF0aW9uIiwiZm9ybWF0Iiwib2JqZWN0IiwiZXhwcmVzc2lvbiIsIiRTeW50YXhFcnJvciIsImdvcGQiLCJkZWZpbmVEYXRhUHJvcGVydHkiLCJwcm9wZXJ0eSIsIm5vbkVudW1lcmFibGUiLCJub25Xcml0YWJsZSIsIm5vbkNvbmZpZ3VyYWJsZSIsImxvb3NlIiwiZGVzYyIsImhhc1N5bWJvbHMiLCJ0b1N0ciIsIm9yaWdEZWZpbmVQcm9wZXJ0eSIsImlzRnVuY3Rpb24iLCJoYXNQcm9wZXJ0eURlc2NyaXB0b3JzIiwic3VwcG9ydHNEZXNjcmlwdG9ycyIsInByZWRpY2F0ZSIsImRlZmluZVByb3BlcnRpZXMiLCJwcmVkaWNhdGVzIiwiRXZhbEVycm9yIiwiU3ludGF4RXJyb3IiLCJVUklFcnJvciIsImZpcnN0U291cmNlIiwidG8iLCJuZXh0U291cmNlIiwia2V5c0FycmF5IiwibmV4dEluZGV4IiwibmV4dEtleSIsInBvbHlmaWxsIiwiaXNDYWxsYWJsZSIsImZvckVhY2hBcnJheSIsInJlY2VpdmVyIiwiZm9yRWFjaFN0cmluZyIsInN0cmluZyIsImNoYXJBdCIsImZvckVhY2hPYmplY3QiLCJsaXN0IiwidGhpc0FyZyIsIkVSUk9SX01FU1NBR0UiLCJmdW5jVHlwZSIsImNvbmNhdHR5IiwiaiIsInNsaWN5IiwiYXJyTGlrZSIsImpvaW55Iiwiam9pbmVyIiwidGhhdCIsImJvdW5kIiwiYmluZGVyIiwiYm91bmRMZW5ndGgiLCJib3VuZEFyZ3MiLCJFbXB0eSIsImltcGxlbWVudGF0aW9uIiwiJEVycm9yIiwiJEV2YWxFcnJvciIsIiRSYW5nZUVycm9yIiwiJFJlZmVyZW5jZUVycm9yIiwiJFVSSUVycm9yIiwiJEZ1bmN0aW9uIiwiZ2V0RXZhbGxlZENvbnN0cnVjdG9yIiwiZXhwcmVzc2lvblN5bnRheCIsIiRnT1BEIiwidGhyb3dUeXBlRXJyb3IiLCJUaHJvd1R5cGVFcnJvciIsImNhbGxlZSIsImNhbGxlZVRocm93cyIsImdPUER0aHJvd3MiLCJoYXNQcm90byIsImdldFByb3RvIiwibmVlZHNFdmFsIiwiVHlwZWRBcnJheSIsIklOVFJJTlNJQ1MiLCJBZ2dyZWdhdGVFcnJvciIsIkFycmF5QnVmZmVyIiwiQXRvbWljcyIsIkJpZ0ludDY0QXJyYXkiLCJCaWdVaW50NjRBcnJheSIsIkRhdGFWaWV3IiwiZGVjb2RlVVJJIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiZW5jb2RlVVJJIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiZXZhbCIsIkZsb2F0MzJBcnJheSIsIkZsb2F0NjRBcnJheSIsIkZpbmFsaXphdGlvblJlZ2lzdHJ5IiwiSW50OEFycmF5IiwiSW50MTZBcnJheSIsIkludDMyQXJyYXkiLCJpc0Zpbml0ZSIsIkpTT04iLCJwYXJzZUZsb2F0IiwicGFyc2VJbnQiLCJTaGFyZWRBcnJheUJ1ZmZlciIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwiVWludDE2QXJyYXkiLCJVaW50MzJBcnJheSIsIldlYWtNYXAiLCJXZWFrUmVmIiwiV2Vha1NldCIsImVycm9yUHJvdG8iLCJkb0V2YWwiLCJnZW4iLCJMRUdBQ1lfQUxJQVNFUyIsImhhc093biIsIiRjb25jYXQiLCIkc3BsaWNlQXBwbHkiLCJzcGxpY2UiLCIkcmVwbGFjZSIsIiRzdHJTbGljZSIsIiRleGVjIiwiZXhlYyIsInJlUHJvcE5hbWUiLCJyZUVzY2FwZUNoYXIiLCJzdHJpbmdUb1BhdGgiLCJmaXJzdCIsImxhc3QiLCJtYXRjaCIsIm51bWJlciIsInF1b3RlIiwic3ViU3RyaW5nIiwiZ2V0QmFzZUludHJpbnNpYyIsImludHJpbnNpY05hbWUiLCJhbGlhcyIsInBhcnRzIiwiaW50cmluc2ljQmFzZU5hbWUiLCJpbnRyaW5zaWNSZWFsTmFtZSIsInNraXBGdXJ0aGVyQ2FjaGluZyIsImlzT3duIiwicGFydCIsImhhc0FycmF5TGVuZ3RoRGVmaW5lQnVnIiwiZm9vIiwiJE9iamVjdCIsIm9yaWdTeW1ib2wiLCJoYXNTeW1ib2xTaGFtIiwiaGFzTmF0aXZlU3ltYm9scyIsInN5bU9iaiIsInN5bVZhbCIsImdldE93blByb3BlcnR5TmFtZXMiLCJzeW1zIiwiaGFzVG9TdHJpbmdUYWdTaGFtcyIsInRvU3RyaW5nVGFnIiwiJGhhc093biIsImluaGVyaXRzIiwiY3RvciIsInN1cGVyQ3RvciIsInN1cGVyXyIsIlRlbXBDdG9yIiwiaGFzVG9TdHJpbmdUYWciLCJjYWxsQm91bmQiLCIkdG9TdHJpbmciLCJpc1N0YW5kYXJkQXJndW1lbnRzIiwiaXNBcmd1bWVudHMiLCJpc0xlZ2FjeUFyZ3VtZW50cyIsInN1cHBvcnRzU3RhbmRhcmRBcmd1bWVudHMiLCJmblRvU3RyIiwicmVmbGVjdEFwcGx5IiwiYmFkQXJyYXlMaWtlIiwiaXNDYWxsYWJsZU1hcmtlciIsIl8iLCJjb25zdHJ1Y3RvclJlZ2V4IiwiaXNFUzZDbGFzc0ZuIiwiaXNFUzZDbGFzc0Z1bmN0aW9uIiwiZm5TdHIiLCJ0cnlGdW5jdGlvbk9iamVjdCIsInRyeUZ1bmN0aW9uVG9TdHIiLCJvYmplY3RDbGFzcyIsImZuQ2xhc3MiLCJnZW5DbGFzcyIsImRkYUNsYXNzIiwiZGRhQ2xhc3MyIiwiZGRhQ2xhc3MzIiwiaXNJRTY4IiwiaXNEREEiLCJpc0RvY3VtZW50RG90QWxsIiwiZG9jdW1lbnQiLCJhbGwiLCJzdHJDbGFzcyIsImlzRm5SZWdleCIsImdldEdlbmVyYXRvckZ1bmMiLCJHZW5lcmF0b3JGdW5jdGlvbiIsImlzR2VuZXJhdG9yRnVuY3Rpb24iLCJnZW5lcmF0b3JGdW5jIiwiZ2V0UG9seWZpbGwiLCJzaGltIiwiTmFOIiwic2hpbU51bWJlcklzTmFOIiwidGVzdElzTmFOIiwid2hpY2hUeXBlZEFycmF5IiwiaXNUeXBlZEFycmF5Iiwic2hpbU9iamVjdElzIiwidGVzdE9iamVjdElzIiwia2V5c1NoaW0iLCJpc0FyZ3MiLCJpc0VudW1lcmFibGUiLCJoYXNEb250RW51bUJ1ZyIsImhhc1Byb3RvRW51bUJ1ZyIsImRvbnRFbnVtcyIsImVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlIiwiZXhjbHVkZWRLZXlzIiwiJGFwcGxpY2F0aW9uQ2FjaGUiLCIkY29uc29sZSIsIiRleHRlcm5hbCIsIiRmcmFtZSIsIiRmcmFtZUVsZW1lbnQiLCIkZnJhbWVzIiwiJGlubmVySGVpZ2h0IiwiJGlubmVyV2lkdGgiLCIkb25tb3pmdWxsc2NyZWVuY2hhbmdlIiwiJG9ubW96ZnVsbHNjcmVlbmVycm9yIiwiJG91dGVySGVpZ2h0IiwiJG91dGVyV2lkdGgiLCIkcGFnZVhPZmZzZXQiLCIkcGFnZVlPZmZzZXQiLCIkcGFyZW50IiwiJHNjcm9sbExlZnQiLCIkc2Nyb2xsVG9wIiwiJHNjcm9sbFgiLCIkc2Nyb2xsWSIsIiRzZWxmIiwiJHdlYmtpdEluZGV4ZWREQiIsIiR3ZWJraXRTdG9yYWdlSW5mbyIsIiR3aW5kb3ciLCJoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWciLCJlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZUlmTm90QnVnZ3kiLCJpc09iamVjdCIsImlzU3RyaW5nIiwidGhlS2V5cyIsInNraXBQcm90byIsInNraXBDb25zdHJ1Y3RvciIsIm9yaWdLZXlzIiwib3JpZ2luYWxLZXlzIiwic2hpbU9iamVjdEtleXMiLCJrZXlzV29ya3NXaXRoQXJndW1lbnRzIiwiY2FjaGVkU2V0VGltZW91dCIsImNhY2hlZENsZWFyVGltZW91dCIsImRlZmF1bHRTZXRUaW1vdXQiLCJkZWZhdWx0Q2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImNsZWFyVGltZW91dCIsInJ1blRpbWVvdXQiLCJmdW4iLCJydW5DbGVhclRpbWVvdXQiLCJtYXJrZXIiLCJxdWV1ZSIsImRyYWluaW5nIiwiY3VycmVudFF1ZXVlIiwicXVldWVJbmRleCIsImNsZWFuVXBOZXh0VGljayIsImRyYWluUXVldWUiLCJ0aW1lb3V0IiwicnVuIiwibmV4dFRpY2siLCJJdGVtIiwidGl0bGUiLCJicm93c2VyIiwiZW52IiwiYXJndiIsInZlcnNpb24iLCJ2ZXJzaW9ucyIsIm5vb3AiLCJvbiIsImFkZExpc3RlbmVyIiwib25jZSIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiZW1pdCIsInByZXBlbmRMaXN0ZW5lciIsInByZXBlbmRPbmNlTGlzdGVuZXIiLCJsaXN0ZW5lcnMiLCJiaW5kaW5nIiwiY3dkIiwiY2hkaXIiLCJ1bWFzayIsImhhc0Rlc2NyaXB0b3JzIiwiZ09QRCIsIiRmbG9vciIsImZ1bmN0aW9uTGVuZ3RoSXNDb25maWd1cmFibGUiLCJmdW5jdGlvbkxlbmd0aElzV3JpdGFibGUiLCJfX3VudXNlZF93ZWJwYWNrX21vZHVsZSIsIl9fd2VicGFja19leHBvcnRzX18iLCJkIiwiQmFzZVNlcnZpY2UiLCJ2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfcHJvdG9jb2xfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyIsInZzY29kZV9sYW5ndWFnZXNlcnZlcl9wcm90b2NvbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQiLCJuIiwiX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18iLCJ2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfdGV4dGRvY3VtZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18iLCJfZGVmaW5lX3Byb3BlcnR5IiwiYWRkRG9jdW1lbnQiLCJkb2N1bWVudHMiLCJ1cmkiLCJWIiwibGFuZ3VhZ2VJZCIsInRleHQiLCJnZXREb2N1bWVudCIsInJlbW92ZURvY3VtZW50IiwiZ2V0RG9jdW1lbnRWYWx1ZSIsIl90aGlzX2dldERvY3VtZW50IiwiZ2V0VGV4dCIsInNldFZhbHVlIiwiaWRlbnRpZmllciIsInNldEdsb2JhbE9wdGlvbnMiLCJnbG9iYWxPcHRpb25zIiwic2V0V29ya3NwYWNlIiwid29ya3NwYWNlVXJpIiwic2V0T3B0aW9ucyIsImRvY3VtZW50VXJpIiwibWVyZ2UiLCJyTCIsImdldE9wdGlvbiIsIm9wdGlvbk5hbWUiLCJhcHBseURlbHRhcyIsImRlbHRhcyIsInVwZGF0ZSIsImRvQ29tcGxldGUiLCJkb0hvdmVyIiwiZG9SZXNvbHZlIiwiZG9WYWxpZGF0aW9uIiwicmFuZ2UiLCJwcm92aWRlU2lnbmF0dXJlSGVscCIsImZpbmREb2N1bWVudEhpZ2hsaWdodHMiLCJvcHRpb25zVG9GaWx0ZXJEaWFnbm9zdGljcyIsIl90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JDb2Rlc1RvSWdub3JlIiwiX3RoaXNfZ2xvYmFsT3B0aW9uc19lcnJvckNvZGVzVG9UcmVhdEFzV2FybmluZyIsIl90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JDb2Rlc1RvVHJlYXRBc0luZm8iLCJfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yTWVzc2FnZXNUb0lnbm9yZSIsIl90aGlzX2dsb2JhbE9wdGlvbnNfZXJyb3JNZXNzYWdlc1RvVHJlYXRBc1dhcm5pbmciLCJfdGhpc19nbG9iYWxPcHRpb25zX2Vycm9yTWVzc2FnZXNUb1RyZWF0QXNJbmZvIiwiZXJyb3JDb2Rlc1RvSWdub3JlIiwiZXJyb3JDb2Rlc1RvVHJlYXRBc1dhcm5pbmciLCJlcnJvckNvZGVzVG9UcmVhdEFzSW5mbyIsImVycm9yTWVzc2FnZXNUb0lnbm9yZSIsImVycm9yTWVzc2FnZXNUb1RyZWF0QXNXYXJuaW5nIiwiZXJyb3JNZXNzYWdlc1RvVHJlYXRBc0luZm8iLCJnZXRTZW1hbnRpY1Rva2VucyIsImRpc3Bvc2UiLCJjbG9zZUNvbm5lY3Rpb24iLCJnZXRDb2RlQWN0aW9ucyIsImNvbnRleHQiLCJleGVjdXRlQ29tbWFuZCIsImNvbW1hbmQiLCJzZW5kQXBwbGllZFJlc3VsdCIsImNhbGxiYWNrSWQiLCJtb2RlIiwidGV4dERvY3VtZW50IiwiZGlhZ25vc3RpYyIsImR5bmFtaWNSZWdpc3RyYXRpb24iLCJyZWxhdGVkRG9jdW1lbnRTdXBwb3J0IiwicHVibGlzaERpYWdub3N0aWNzIiwicmVsYXRlZEluZm9ybWF0aW9uIiwidmVyc2lvblN1cHBvcnQiLCJ0YWdTdXBwb3J0IiwidmFsdWVTZXQiLCJEaWFnbm9zdGljVGFnIiwiVW5uZWNlc3NhcnkiLCJEZXByZWNhdGVkIiwiaG92ZXIiLCJjb250ZW50Rm9ybWF0Iiwic3luY2hyb25pemF0aW9uIiwid2lsbFNhdmUiLCJkaWRTYXZlIiwid2lsbFNhdmVXYWl0VW50aWwiLCJmb3JtYXR0aW5nIiwiY29tcGxldGlvbiIsImNvbXBsZXRpb25JdGVtIiwic25pcHBldFN1cHBvcnQiLCJjb21taXRDaGFyYWN0ZXJzU3VwcG9ydCIsImRvY3VtZW50YXRpb25Gb3JtYXQiLCJkZXByZWNhdGVkU3VwcG9ydCIsInByZXNlbGVjdFN1cHBvcnQiLCJjb250ZXh0U3VwcG9ydCIsInNpZ25hdHVyZUhlbHAiLCJzaWduYXR1cmVJbmZvcm1hdGlvbiIsImFjdGl2ZVBhcmFtZXRlclN1cHBvcnQiLCJkb2N1bWVudEhpZ2hsaWdodCIsInNlbWFudGljVG9rZW5zIiwibXVsdGlsaW5lVG9rZW5TdXBwb3J0Iiwib3ZlcmxhcHBpbmdUb2tlblN1cHBvcnQiLCJ0b2tlblR5cGVzIiwidG9rZW5Nb2RpZmllcnMiLCJmb3JtYXRzIiwicmVxdWVzdHMiLCJmdWxsIiwiZGVsdGEiLCJhdWdtZW50c1N5bnRheFRva2VucyIsImNvZGVBY3Rpb24iLCJ3b3Jrc3BhY2UiLCJkaWRDaGFuZ2VDb25maWd1cmF0aW9uIiwiYXBwbHlFZGl0Iiwid29ya3NwYWNlRWRpdCIsImZhaWx1cmVIYW5kbGluZyIsIm5vcm1hbGl6ZXNMaW5lRW5kaW5ncyIsImRvY3VtZW50Q2hhbmdlcyIsIlRrIiwiY2hlY2tWYWx1ZUFnYWluc3RSZWdleHBBcnJheSIsIm1lcmdlT2JqZWN0cyIsIm9iajEiLCJvYmoyIiwiZXhjbHVkZVVuZGVmaW5lZCIsImV4Y2x1ZGVVbmRlZmluZWRWYWx1ZXMiLCJtZXJnZWRPYmplY3RzIiwiZmlsdGVyZWRFbnRyaWVzIiwiZW50cmllcyIsImZyb21FbnRyaWVzIiwibm90RW1wdHkiLCJtZXJnZVJhbmdlcyIsInJhbmdlcyIsInNvcnQiLCJjb21wYXJlUG9pbnRzIiwiY21wIiwiaXNFbXB0eSIsInJvdyIsImNvbHVtbiIsInAxIiwicDIiLCJyZWdleHBBcnJheSIsImNvbnZlcnRUb1VyaSIsImZpbGVQYXRoIiwiVVJJIiwiZmlsZSIsImlzQnVmZmVyIiwiYXJnIiwiY29weSIsImZpbGwiLCJyZWFkVUludDgiLCJpc0FyZ3VtZW50c09iamVjdCIsIkJpZ0ludFN1cHBvcnRlZCIsIlN5bWJvbFN1cHBvcnRlZCIsIk9iamVjdFRvU3RyaW5nIiwibnVtYmVyVmFsdWUiLCJzdHJpbmdWYWx1ZSIsImJvb2xlYW5WYWx1ZSIsImJpZ0ludFZhbHVlIiwic3ltYm9sVmFsdWUiLCJjaGVja0JveGVkUHJpbWl0aXZlIiwicHJvdG90eXBlVmFsdWVPZiIsImlzVmlldyIsImlzRGF0YVZpZXciLCJpc1VpbnQ4QXJyYXkiLCJpc1VpbnQ4Q2xhbXBlZEFycmF5IiwiaXNVaW50MTZBcnJheSIsImlzVWludDMyQXJyYXkiLCJpc0ludDhBcnJheSIsImlzSW50MTZBcnJheSIsImlzSW50MzJBcnJheSIsImlzQmlnSW50NjRBcnJheSIsImlzQmlnVWludDY0QXJyYXkiLCJpc01hcFRvU3RyaW5nIiwid29ya2luZyIsImlzU2V0VG9TdHJpbmciLCJpc1dlYWtNYXBUb1N0cmluZyIsImlzV2Vha01hcCIsImlzV2Vha1NldFRvU3RyaW5nIiwiaXNXZWFrU2V0IiwiaXNBcnJheUJ1ZmZlclRvU3RyaW5nIiwiaXNBcnJheUJ1ZmZlciIsImlzRGF0YVZpZXdUb1N0cmluZyIsIlNoYXJlZEFycmF5QnVmZmVyQ29weSIsImlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyIsImlzU2hhcmVkQXJyYXlCdWZmZXIiLCJpc0FzeW5jRnVuY3Rpb24iLCJpc01hcEl0ZXJhdG9yIiwiaXNTZXRJdGVyYXRvciIsImlzR2VuZXJhdG9yT2JqZWN0IiwiaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlIiwibWV0aG9kIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlc2NyaXB0b3JzIiwiZm9ybWF0UmVnRXhwIiwib2JqZWN0cyIsInN0cmluZ2lmeSIsImlzTnVsbCIsImRlcHJlY2F0ZSIsIm5vRGVwcmVjYXRpb24iLCJkZXByZWNhdGVkIiwidGhyb3dEZXByZWNhdGlvbiIsInRyYWNlRGVwcmVjYXRpb24iLCJkZWJ1Z3MiLCJkZWJ1Z0VudlJlZ2V4IiwiTk9ERV9ERUJVRyIsImRlYnVnRW52IiwidG9VcHBlckNhc2UiLCJkZWJ1Z2xvZyIsInBpZCIsIm9wdHMiLCJzZWVuIiwic3R5bGl6ZSIsInN0eWxpemVOb0NvbG9yIiwiY29sb3JzIiwiaXNCb29sZWFuIiwiX2V4dGVuZCIsImlzVW5kZWZpbmVkIiwic3R5bGl6ZVdpdGhDb2xvciIsImZvcm1hdFZhbHVlIiwic3R5bGVzIiwic3R5bGVUeXBlIiwic3R5bGUiLCJhcnJheVRvSGFzaCIsImhhc2giLCJpZHgiLCJyZXQiLCJwcmltaXRpdmUiLCJmb3JtYXRQcmltaXRpdmUiLCJ2aXNpYmxlS2V5cyIsImlzRXJyb3IiLCJmb3JtYXRFcnJvciIsImJyYWNlcyIsInRvVVRDU3RyaW5nIiwib3V0cHV0IiwiZm9ybWF0QXJyYXkiLCJmb3JtYXRQcm9wZXJ0eSIsInJlZHVjZVRvU2luZ2xlU3RyaW5nIiwic2ltcGxlIiwiaXNOdW1iZXIiLCJsIiwibGluZSIsIm51bUxpbmVzRXN0IiwicmVkdWNlIiwicHJldiIsImFyIiwiaXNOdWxsT3JVbmRlZmluZWQiLCJpc1N5bWJvbCIsInJlIiwiaXNQcmltaXRpdmUiLCJwYWQiLCJtb250aHMiLCJ0aW1lc3RhbXAiLCJnZXRIb3VycyIsImdldE1pbnV0ZXMiLCJnZXRTZWNvbmRzIiwiZ2V0RGF0ZSIsImdldE1vbnRoIiwib3JpZ2luIiwicHJvcCIsImtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCIsInByb21pc2lmeSIsIm9yaWdpbmFsIiwicHJvbWlzZVJlc29sdmUiLCJwcm9taXNlUmVqZWN0IiwicHJvbWlzZSIsInJlamVjdCIsImNhbGxiYWNraWZ5T25SZWplY3RlZCIsImNiIiwibmV3UmVhc29uIiwiY2FsbGJhY2tpZnkiLCJjYWxsYmFja2lmaWVkIiwibWF5YmVDYiIsInJlaiIsIl9fY3JlYXRlQmluZGluZyIsIm0iLCJrMiIsIl9fZXNNb2R1bGUiLCJfX2V4cG9ydFN0YXIiLCJjcmVhdGVNZXNzYWdlQ29ubmVjdGlvbiIsIkJyb3dzZXJNZXNzYWdlV3JpdGVyIiwiQnJvd3Nlck1lc3NhZ2VSZWFkZXIiLCJyaWxfMSIsImRlZmF1bHQiLCJpbnN0YWxsIiwiYXBpXzEiLCJBYnN0cmFjdE1lc3NhZ2VSZWFkZXIiLCJsaXN0ZW4iLCJjYWxsYmFjayIsIl9vbkRhdGEiLCJldmVudCIsInBvcnQiLCJFbWl0dGVyIiwiX21lc3NhZ2VMaXN0ZW5lciIsImZpcmUiLCJkYXRhIiwiYWRkRXZlbnRMaXN0ZW5lciIsImZpcmVFcnJvciIsIm9ubWVzc2FnZSIsIkFic3RyYWN0TWVzc2FnZVdyaXRlciIsIndyaXRlIiwicG9zdE1lc3NhZ2UiLCJoYW5kbGVFcnJvciIsImVycm9yQ291bnQiLCJyZWFkZXIiLCJ3cml0ZXIiLCJsb2dnZXIiLCJOdWxsTG9nZ2VyIiwiQ29ubmVjdGlvblN0cmF0ZWd5IiwiY29ubmVjdGlvblN0cmF0ZWd5IiwiTWVzc2FnZUJ1ZmZlciIsIkFic3RyYWN0TWVzc2FnZUJ1ZmZlciIsImVtcHR5QnVmZmVyIiwiZnJvbVN0cmluZyIsIl9lbmNvZGluZyIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwiZW5jb2RpbmciLCJhc2NpaURlY29kZXIiLCJkZWNvZGUiLCJUZXh0RGVjb2RlciIsImFzTmF0aXZlIiwiYWxsb2NOYXRpdmUiLCJSZWFkYWJsZVN0cmVhbVdyYXBwZXIiLCJvbkNsb3NlIiwibGlzdGVuZXIiLCJzb2NrZXQiLCJEaXNwb3NhYmxlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm9uRXJyb3IiLCJvbkVuZCIsIm9uRGF0YSIsImJsb2IiLCJhcnJheUJ1ZmZlciIsIlJBTCIsIldyaXRhYmxlU3RyZWFtV3JhcHBlciIsInNlbmQiLCJjbG9zZSIsIl90ZXh0RW5jb2RlciIsIl9yaWwiLCJmcmVlemUiLCJtZXNzYWdlQnVmZmVyIiwiYXBwbGljYXRpb25Kc29uIiwiZW5jb2RlciIsImNoYXJzZXQiLCJwYXJzZSIsInN0cmVhbSIsImFzUmVhZGFibGVTdHJlYW0iLCJhc1dyaXRhYmxlU3RyZWFtIiwidGltZXIiLCJtcyIsImhhbmRsZSIsInNldEltbWVkaWF0ZSIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsIlJJTCIsIlByb2dyZXNzVHlwZSIsIlByb2dyZXNzVG9rZW4iLCJDb25uZWN0aW9uT3B0aW9ucyIsIldyaXRlYWJsZVN0cmVhbU1lc3NhZ2VXcml0ZXIiLCJNZXNzYWdlV3JpdGVyIiwiUmVhZGFibGVTdHJlYW1NZXNzYWdlUmVhZGVyIiwiTWVzc2FnZVJlYWRlciIsIlNoYXJlZEFycmF5UmVjZWl2ZXJTdHJhdGVneSIsIlNoYXJlZEFycmF5U2VuZGVyU3RyYXRlZ3kiLCJDYW5jZWxsYXRpb25Ub2tlbiIsIkNhbmNlbGxhdGlvblRva2VuU291cmNlIiwiRXZlbnQiLCJMUlVDYWNoZSIsIlRvdWNoIiwiTGlua2VkTWFwIiwiUGFyYW1ldGVyU3RydWN0dXJlcyIsIk5vdGlmaWNhdGlvblR5cGU5IiwiTm90aWZpY2F0aW9uVHlwZTgiLCJOb3RpZmljYXRpb25UeXBlNyIsIk5vdGlmaWNhdGlvblR5cGU2IiwiTm90aWZpY2F0aW9uVHlwZTUiLCJOb3RpZmljYXRpb25UeXBlNCIsIk5vdGlmaWNhdGlvblR5cGUzIiwiTm90aWZpY2F0aW9uVHlwZTIiLCJOb3RpZmljYXRpb25UeXBlMSIsIk5vdGlmaWNhdGlvblR5cGUwIiwiTm90aWZpY2F0aW9uVHlwZSIsIkVycm9yQ29kZXMiLCJSZXNwb25zZUVycm9yIiwiUmVxdWVzdFR5cGU5IiwiUmVxdWVzdFR5cGU4IiwiUmVxdWVzdFR5cGU3IiwiUmVxdWVzdFR5cGU2IiwiUmVxdWVzdFR5cGU1IiwiUmVxdWVzdFR5cGU0IiwiUmVxdWVzdFR5cGUzIiwiUmVxdWVzdFR5cGUyIiwiUmVxdWVzdFR5cGUxIiwiUmVxdWVzdFR5cGUwIiwiUmVxdWVzdFR5cGUiLCJNZXNzYWdlIiwiTWVzc2FnZVN0cmF0ZWd5IiwiQ2FuY2VsbGF0aW9uU3RyYXRlZ3kiLCJDYW5jZWxsYXRpb25TZW5kZXJTdHJhdGVneSIsIkNhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kiLCJDb25uZWN0aW9uRXJyb3IiLCJDb25uZWN0aW9uRXJyb3JzIiwiTG9nVHJhY2VOb3RpZmljYXRpb24iLCJTZXRUcmFjZU5vdGlmaWNhdGlvbiIsIlRyYWNlRm9ybWF0IiwiVHJhY2VWYWx1ZXMiLCJUcmFjZSIsIm1lc3NhZ2VzXzEiLCJsaW5rZWRNYXBfMSIsImRpc3Bvc2FibGVfMSIsImV2ZW50c18xIiwiY2FuY2VsbGF0aW9uXzEiLCJzaGFyZWRBcnJheUNhbmNlbGxhdGlvbl8xIiwibWVzc2FnZVJlYWRlcl8xIiwibWVzc2FnZVdyaXRlcl8xIiwibWVzc2FnZUJ1ZmZlcl8xIiwiY29ubmVjdGlvbl8xIiwicmFsXzEiLCJJcyIsIk5vbmUiLCJpc0NhbmNlbGxhdGlvblJlcXVlc3RlZCIsIm9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkIiwiQ2FuY2VsbGVkIiwiY2FuZGlkYXRlIiwiYm9vbGVhbiIsInNob3J0Y3V0RXZlbnQiLCJNdXRhYmxlVG9rZW4iLCJjYW5jZWwiLCJfaXNDYW5jZWxsZWQiLCJfZW1pdHRlciIsInRva2VuIiwiX3Rva2VuIiwiUmVxdWVzdENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kiLCJJZENhbmNlbGxhdGlvblJlY2VpdmVyU3RyYXRlZ3kiLCJDYW5jZWxOb3RpZmljYXRpb24iLCJQcm9ncmVzc05vdGlmaWNhdGlvbiIsIlN0YXJSZXF1ZXN0SGFuZGxlciIsIk9mZiIsIk1lc3NhZ2VzIiwiQ29tcGFjdCIsIlZlcmJvc2UiLCJ0b0xvd2VyQ2FzZSIsIlRleHQiLCJjYW5jZWxVbmRpc3BhdGNoZWQiLCJraW5kIiwiY3JlYXRlQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UiLCJzZW5kQ2FuY2VsbGF0aW9uIiwiY29ubiIsImlkIiwic2VuZE5vdGlmaWNhdGlvbiIsImNsZWFudXAiLCJzZW5kZXIiLCJoYW5kbGVNZXNzYWdlIiwiY2FuY2VsbGF0aW9uU3RyYXRlZ3kiLCJtZXNzYWdlU3RyYXRlZ3kiLCJDb25uZWN0aW9uU3RhdGUiLCJtZXNzYWdlUmVhZGVyIiwibWVzc2FnZVdyaXRlciIsIl9sb2dnZXIiLCJzZXF1ZW5jZU51bWJlciIsIm5vdGlmaWNhdGlvblNlcXVlbmNlTnVtYmVyIiwidW5rbm93blJlc3BvbnNlU2VxdWVuY2VOdW1iZXIiLCJzdGFyUmVxdWVzdEhhbmRsZXIiLCJyZXF1ZXN0SGFuZGxlcnMiLCJzdGFyTm90aWZpY2F0aW9uSGFuZGxlciIsIm5vdGlmaWNhdGlvbkhhbmRsZXJzIiwicHJvZ3Jlc3NIYW5kbGVycyIsIm1lc3NhZ2VRdWV1ZSIsInJlc3BvbnNlUHJvbWlzZXMiLCJrbm93bkNhbmNlbGVkUmVxdWVzdHMiLCJyZXF1ZXN0VG9rZW5zIiwidHJhY2VGb3JtYXQiLCJ0cmFjZXIiLCJzdGF0ZSIsIk5ldyIsImVycm9yRW1pdHRlciIsImNsb3NlRW1pdHRlciIsInVuaGFuZGxlZE5vdGlmaWNhdGlvbkVtaXR0ZXIiLCJ1bmhhbmRsZWRQcm9ncmVzc0VtaXR0ZXIiLCJkaXNwb3NlRW1pdHRlciIsImNyZWF0ZVJlcXVlc3RRdWV1ZUtleSIsImNyZWF0ZVJlc3BvbnNlUXVldWVLZXkiLCJjcmVhdGVOb3RpZmljYXRpb25RdWV1ZUtleSIsImFkZE1lc3NhZ2VUb1F1ZXVlIiwiaXNSZXF1ZXN0IiwiaXNSZXNwb25zZSIsIl9tZXNzYWdlIiwiaXNMaXN0ZW5pbmciLCJMaXN0ZW5pbmciLCJpc0Nsb3NlZCIsIkNsb3NlZCIsImlzRGlzcG9zZWQiLCJEaXNwb3NlZCIsImNsb3NlSGFuZGxlciIsInJlYWRFcnJvckhhbmRsZXIiLCJ3cml0ZUVycm9ySGFuZGxlciIsInRyaWdnZXJNZXNzYWdlUXVldWUiLCJwcm9jZXNzTWVzc2FnZVF1ZXVlIiwiaGFuZGxlUmVxdWVzdCIsImlzTm90aWZpY2F0aW9uIiwiaGFuZGxlTm90aWZpY2F0aW9uIiwiaGFuZGxlUmVzcG9uc2UiLCJoYW5kbGVJbnZhbGlkTWVzc2FnZSIsImNhbmNlbElkIiwicGFyYW1zIiwidG9DYW5jZWwiLCJzdHJhdGVneSIsInJlc3BvbnNlIiwidHJhY2VTZW5kaW5nUmVzcG9uc2UiLCJjYW5jZWxsYXRpb25Ub2tlbiIsInRyYWNlUmVjZWl2ZWROb3RpZmljYXRpb24iLCJyZXF1ZXN0TWVzc2FnZSIsInJlcGx5IiwicmVzdWx0T3JFcnJvciIsInN0YXJ0VGltZSIsImpzb25ycGMiLCJ0b0pzb24iLCJyZXBseUVycm9yIiwicmVwbHlTdWNjZXNzIiwidHJhY2VSZWNlaXZlZFJlcXVlc3QiLCJlbGVtZW50IiwicmVxdWVzdEhhbmRsZXIiLCJoYW5kbGVyIiwidG9rZW5LZXkiLCJjYW5jZWxsYXRpb25Tb3VyY2UiLCJoYW5kbGVyUmVzdWx0IiwibnVtYmVyT2ZQYXJhbXMiLCJJbnZhbGlkUGFyYW1zIiwicGFyYW1ldGVyU3RydWN0dXJlcyIsImJ5TmFtZSIsImJ5UG9zaXRpb24iLCJJbnRlcm5hbEVycm9yIiwiTWV0aG9kTm90Rm91bmQiLCJyZXNwb25zZU1lc3NhZ2UiLCJyZXNwb25zZVByb21pc2UiLCJ0cmFjZVJlY2VpdmVkUmVzcG9uc2UiLCJub3RpZmljYXRpb25IYW5kbGVyIiwicmVzcG9uc2VIYW5kbGVyIiwic3RyaW5naWZ5VHJhY2UiLCJ0cmFjZVNlbmRpbmdSZXF1ZXN0IiwibG9nTFNQTWVzc2FnZSIsInRyYWNlU2VuZGluZ05vdGlmaWNhdGlvbiIsInRpbWVyU3RhcnQiLCJsc3BNZXNzYWdlIiwiaXNMU1BNZXNzYWdlIiwidGhyb3dJZkNsb3NlZE9yRGlzcG9zZWQiLCJ0aHJvd0lmTGlzdGVuaW5nIiwiQWxyZWFkeUxpc3RlbmluZyIsInRocm93SWZOb3RMaXN0ZW5pbmciLCJ1bmRlZmluZWRUb051bGwiLCJwYXJhbSIsIm51bGxUb1VuZGVmaW5lZCIsImlzTmFtZWRQYXJhbSIsImNvbXB1dGVTaW5nbGVQYXJhbSIsImF1dG8iLCJjb21wdXRlTWVzc2FnZVBhcmFtcyIsImNvbm5lY3Rpb24iLCJtZXNzYWdlUGFyYW1zIiwicGFyYW1TdGFydCIsInBhcmFtRW5kIiwibm90aWZpY2F0aW9uTWVzc2FnZSIsIm9uTm90aWZpY2F0aW9uIiwib25Qcm9ncmVzcyIsIl90eXBlIiwic2VuZFByb2dyZXNzIiwib25VbmhhbmRsZWRQcm9ncmVzcyIsInNlbmRSZXF1ZXN0IiwiZGlzcG9zYWJsZSIsImVuYWJsZUNhbmNlbGxhdGlvbiIsInJlc29sdmVXaXRoQ2xlYW51cCIsInIiLCJyZWplY3RXaXRoQ2xlYW51cCIsIk1lc3NhZ2VXcml0ZUVycm9yIiwib25SZXF1ZXN0IiwiaGFzUGVuZGluZ1Jlc3BvbnNlIiwiX3ZhbHVlIiwiX3RyYWNlciIsInNlbmROb3RpZmljYXRpb25PclRyYWNlT3B0aW9ucyIsIl9zZW5kTm90aWZpY2F0aW9uIiwiX3RyYWNlRm9ybWF0Iiwib25VbmhhbmRsZWROb3RpZmljYXRpb24iLCJvbkRpc3Bvc2UiLCJQZW5kaW5nUmVzcG9uc2VSZWplY3RlZCIsInZhbHVlcyIsInZlcmJvc2UiLCJfZGlzcG9zYWJsZSIsIkNhbGxiYWNrTGlzdCIsImJ1Y2tldCIsIl9jYWxsYmFja3MiLCJfY29udGV4dHMiLCJyZW1vdmUiLCJmb3VuZENhbGxiYWNrV2l0aERpZmZlcmVudENvbnRleHQiLCJpbnZva2UiLCJjYWxsYmFja3MiLCJjb250ZXh0cyIsIl9ldmVudCIsInRoaXNBcmdzIiwiZGlzcG9zYWJsZXMiLCJfb3B0aW9ucyIsIm9uRmlyc3RMaXN0ZW5lckFkZCIsIl9ub29wIiwib25MYXN0TGlzdGVuZXJSZW1vdmUiLCJzdHJpbmdBcnJheSIsImV2ZXJ5IiwiZWxlbSIsIl9hIiwiRmlyc3QiLCJBc09sZCIsIkxhc3QiLCJBc05ldyIsImNsZWFyIiwiX21hcCIsIl9oZWFkIiwiX3RhaWwiLCJfc2l6ZSIsIl9zdGF0ZSIsInRvdWNoIiwicHJldmlvdXMiLCJhZGRJdGVtTGFzdCIsImFkZEl0ZW1GaXJzdCIsInJlbW92ZUl0ZW0iLCJjYWxsYmFja2ZuIiwiY3VycmVudCIsInRyaW1PbGQiLCJuZXdTaXplIiwiY3VycmVudFNpemUiLCJ0b0pTT04iLCJmcm9tSlNPTiIsIl9saW1pdCIsImNoZWNrVHJpbSIsInJhdGlvIiwiX3JhdGlvIiwicGVlayIsInJvdW5kIiwiQ1IiLCJMRiIsIkNSTEYiLCJhcHBlbmQiLCJjaHVuayIsInRvQXBwZW5kIiwiX2NodW5rcyIsIl90b3RhbExlbmd0aCIsInRyeVJlYWRIZWFkZXJzIiwibG93ZXJDYXNlS2V5cyIsImNodW5rSW5kZXgiLCJjaHVua0J5dGVzUmVhZCIsIl9yZWFkIiwiaGVhZGVycyIsImhlYWRlciIsImluZGV4IiwidHJpbSIsInRyeVJlYWRCb2R5IiwibnVtYmVyT2ZCeXRlcyIsImJ5dGVDb3VudCIsInJlc3VsdE9mZnNldCIsImNodW5rUGFydCIsInNlbWFwaG9yZV8xIiwib25QYXJ0aWFsTWVzc2FnZSIsImFzRXJyb3IiLCJmaXJlQ2xvc2UiLCJwYXJ0aWFsTWVzc2FnZUVtaXR0ZXIiLCJmaXJlUGFydGlhbE1lc3NhZ2UiLCJSZXNvbHZlZE1lc3NhZ2VSZWFkZXJPcHRpb25zIiwiZnJvbU9wdGlvbnMiLCJjb250ZW50RGVjb2RlciIsImNvbnRlbnREZWNvZGVycyIsImNvbnRlbnRUeXBlRGVjb2RlciIsImNvbnRlbnRUeXBlRGVjb2RlcnMiLCJwYXJ0aWFsTWVzc2FnZVRpbWVvdXQiLCJfcGFydGlhbE1lc3NhZ2VUaW1lb3V0IiwibmV4dE1lc3NhZ2VMZW5ndGgiLCJtZXNzYWdlVG9rZW4iLCJwYXJ0aWFsTWVzc2FnZVRpbWVyIiwicmVhZGFibGUiLCJjb250ZW50TGVuZ3RoIiwiYm9keSIsInNldFBhcnRpYWxNZXNzYWdlVGltZXIiLCJjbGVhclBhcnRpYWxNZXNzYWdlVGltZXIiLCJyZWFkU2VtYXBob3JlIiwibG9jayIsImJ5dGVzIiwid2FpdGluZ1RpbWUiLCJTZW1hcGhvcmUiLCJDb250ZW50TGVuZ3RoIiwiUmVzb2x2ZWRNZXNzYWdlV3JpdGVyT3B0aW9ucyIsImNvbnRlbnRUeXBlRW5jb2RlciIsImNvbnRlbnRFbmNvZGVyIiwid3JpdGVTZW1hcGhvcmUiLCJwYXlsb2FkIiwiZG9Xcml0ZSIsIkFic3RyYWN0TWVzc2FnZVNpZ25hdHVyZSIsIlBhcnNlRXJyb3IiLCJJbnZhbGlkUmVxdWVzdCIsImpzb25ycGNSZXNlcnZlZEVycm9yUmFuZ2VTdGFydCIsInNlcnZlckVycm9yU3RhcnQiLCJNZXNzYWdlUmVhZEVycm9yIiwiQ29ubmVjdGlvbkluYWN0aXZlIiwiU2VydmVyTm90SW5pdGlhbGl6ZWQiLCJVbmtub3duRXJyb3JDb2RlIiwianNvbnJwY1Jlc2VydmVkRXJyb3JSYW5nZUVuZCIsInNlcnZlckVycm9yRW5kIiwiX3BhcmFtZXRlclN0cnVjdHVyZXMiLCJfcmFsIiwicmFsIiwidGh1bmsiLCJfd2FpdGluZyIsInJ1bk5leHQiLCJhY3RpdmUiLCJfYWN0aXZlIiwiX2NhcGFjaXR5IiwiZG9SdW5OZXh0IiwiY2FwYWNpdHkiLCJDYW5jZWxsYXRpb25TdGF0ZSIsIkNvbnRpbnVlIiwicmVxdWVzdCIsImJ1ZmZlcnMiLCIkY2FuY2VsbGF0aW9uRGF0YSIsIl9jb25uIiwic3RvcmUiLCJTaGFyZWRBcnJheUJ1ZmZlckNhbmNlbGxhdGlvblRva2VuIiwibG9hZCIsIlNoYXJlZEFycmF5QnVmZmVyQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UiLCJjcmVhdGVQcm90b2NvbENvbm5lY3Rpb24iLCJicm93c2VyXzEiLCJMU1BFcnJvckNvZGVzIiwibHNwUmVzZXJ2ZWRFcnJvclJhbmdlU3RhcnQiLCJSZXF1ZXN0RmFpbGVkIiwiU2VydmVyQ2FuY2VsbGVkIiwiQ29udGVudE1vZGlmaWVkIiwiUmVxdWVzdENhbmNlbGxlZCIsImxzcFJlc2VydmVkRXJyb3JSYW5nZUVuZCIsInZzY29kZV9qc29ucnBjXzEiLCJQcm90b2NvbE5vdGlmaWNhdGlvblR5cGUiLCJQcm90b2NvbE5vdGlmaWNhdGlvblR5cGUwIiwiUHJvdG9jb2xSZXF1ZXN0VHlwZSIsIlByb3RvY29sUmVxdWVzdFR5cGUwIiwiUmVnaXN0cmF0aW9uVHlwZSIsIk1lc3NhZ2VEaXJlY3Rpb24iLCJDYWxsSGllcmFyY2h5T3V0Z29pbmdDYWxsc1JlcXVlc3QiLCJDYWxsSGllcmFyY2h5SW5jb21pbmdDYWxsc1JlcXVlc3QiLCJDYWxsSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QiLCJtZXNzYWdlRGlyZWN0aW9uIiwiY2xpZW50VG9TZXJ2ZXIiLCJDb2xvclByZXNlbnRhdGlvblJlcXVlc3QiLCJEb2N1bWVudENvbG9yUmVxdWVzdCIsIkNvbmZpZ3VyYXRpb25SZXF1ZXN0Iiwic2VydmVyVG9DbGllbnQiLCJEZWNsYXJhdGlvblJlcXVlc3QiLCJfX25vRHluYW1pY0ltcG9ydCIsIkRpYWdub3N0aWNSZWZyZXNoUmVxdWVzdCIsIldvcmtzcGFjZURpYWdub3N0aWNSZXF1ZXN0IiwiRG9jdW1lbnREaWFnbm9zdGljUmVxdWVzdCIsIkRvY3VtZW50RGlhZ25vc3RpY1JlcG9ydEtpbmQiLCJEaWFnbm9zdGljU2VydmVyQ2FuY2VsbGF0aW9uRGF0YSIsInJldHJpZ2dlclJlcXVlc3QiLCJGdWxsIiwiVW5jaGFuZ2VkIiwicGFydGlhbFJlc3VsdCIsIldpbGxEZWxldGVGaWxlc1JlcXVlc3QiLCJEaWREZWxldGVGaWxlc05vdGlmaWNhdGlvbiIsIkRpZFJlbmFtZUZpbGVzTm90aWZpY2F0aW9uIiwiV2lsbFJlbmFtZUZpbGVzUmVxdWVzdCIsIkRpZENyZWF0ZUZpbGVzTm90aWZpY2F0aW9uIiwiV2lsbENyZWF0ZUZpbGVzUmVxdWVzdCIsIkZpbGVPcGVyYXRpb25QYXR0ZXJuS2luZCIsImZvbGRlciIsIkZvbGRpbmdSYW5nZVJlcXVlc3QiLCJJbXBsZW1lbnRhdGlvblJlcXVlc3QiLCJJbmxheUhpbnRSZWZyZXNoUmVxdWVzdCIsIklubGF5SGludFJlc29sdmVSZXF1ZXN0IiwiSW5sYXlIaW50UmVxdWVzdCIsIklubGluZVZhbHVlUmVmcmVzaFJlcXVlc3QiLCJJbmxpbmVWYWx1ZVJlcXVlc3QiLCJXb3Jrc3BhY2VTeW1ib2xSZXF1ZXN0IiwiQ29kZUFjdGlvblJlc29sdmVSZXF1ZXN0IiwiQ29kZUFjdGlvblJlcXVlc3QiLCJEb2N1bWVudFN5bWJvbFJlcXVlc3QiLCJEb2N1bWVudEhpZ2hsaWdodFJlcXVlc3QiLCJSZWZlcmVuY2VzUmVxdWVzdCIsIkRlZmluaXRpb25SZXF1ZXN0IiwiU2lnbmF0dXJlSGVscFJlcXVlc3QiLCJTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmQiLCJIb3ZlclJlcXVlc3QiLCJDb21wbGV0aW9uUmVzb2x2ZVJlcXVlc3QiLCJDb21wbGV0aW9uUmVxdWVzdCIsIkNvbXBsZXRpb25UcmlnZ2VyS2luZCIsIlB1Ymxpc2hEaWFnbm9zdGljc05vdGlmaWNhdGlvbiIsIldhdGNoS2luZCIsIlJlbGF0aXZlUGF0dGVybiIsIkZpbGVDaGFuZ2VUeXBlIiwiRGlkQ2hhbmdlV2F0Y2hlZEZpbGVzTm90aWZpY2F0aW9uIiwiV2lsbFNhdmVUZXh0RG9jdW1lbnRXYWl0VW50aWxSZXF1ZXN0IiwiV2lsbFNhdmVUZXh0RG9jdW1lbnROb3RpZmljYXRpb24iLCJUZXh0RG9jdW1lbnRTYXZlUmVhc29uIiwiRGlkU2F2ZVRleHREb2N1bWVudE5vdGlmaWNhdGlvbiIsIkRpZENsb3NlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uIiwiRGlkQ2hhbmdlVGV4dERvY3VtZW50Tm90aWZpY2F0aW9uIiwiVGV4dERvY3VtZW50Q29udGVudENoYW5nZUV2ZW50IiwiRGlkT3BlblRleHREb2N1bWVudE5vdGlmaWNhdGlvbiIsIlRleHREb2N1bWVudFN5bmNLaW5kIiwiVGVsZW1ldHJ5RXZlbnROb3RpZmljYXRpb24iLCJMb2dNZXNzYWdlTm90aWZpY2F0aW9uIiwiU2hvd01lc3NhZ2VSZXF1ZXN0IiwiU2hvd01lc3NhZ2VOb3RpZmljYXRpb24iLCJNZXNzYWdlVHlwZSIsIkRpZENoYW5nZUNvbmZpZ3VyYXRpb25Ob3RpZmljYXRpb24iLCJFeGl0Tm90aWZpY2F0aW9uIiwiU2h1dGRvd25SZXF1ZXN0IiwiSW5pdGlhbGl6ZWROb3RpZmljYXRpb24iLCJJbml0aWFsaXplRXJyb3JDb2RlcyIsIkluaXRpYWxpemVSZXF1ZXN0IiwiV29ya0RvbmVQcm9ncmVzc09wdGlvbnMiLCJUZXh0RG9jdW1lbnRSZWdpc3RyYXRpb25PcHRpb25zIiwiU3RhdGljUmVnaXN0cmF0aW9uT3B0aW9ucyIsIlBvc2l0aW9uRW5jb2RpbmdLaW5kIiwiRmFpbHVyZUhhbmRsaW5nS2luZCIsIlJlc291cmNlT3BlcmF0aW9uS2luZCIsIlVucmVnaXN0cmF0aW9uUmVxdWVzdCIsIlJlZ2lzdHJhdGlvblJlcXVlc3QiLCJEb2N1bWVudFNlbGVjdG9yIiwiTm90ZWJvb2tDZWxsVGV4dERvY3VtZW50RmlsdGVyIiwiTm90ZWJvb2tEb2N1bWVudEZpbHRlciIsIlRleHREb2N1bWVudEZpbHRlciIsIlR5cGVIaWVyYXJjaHlTdWJ0eXBlc1JlcXVlc3QiLCJUeXBlSGllcmFyY2h5UHJlcGFyZVJlcXVlc3QiLCJNb25pa2VyUmVxdWVzdCIsIk1vbmlrZXJLaW5kIiwiVW5pcXVlbmVzc0xldmVsIiwiTGlua2VkRWRpdGluZ1JhbmdlUmVxdWVzdCIsIlNob3dEb2N1bWVudFJlcXVlc3QiLCJTZW1hbnRpY1Rva2Vuc1JlZ2lzdHJhdGlvblR5cGUiLCJTZW1hbnRpY1Rva2Vuc1JlZnJlc2hSZXF1ZXN0IiwiU2VtYW50aWNUb2tlbnNSYW5nZVJlcXVlc3QiLCJTZW1hbnRpY1Rva2Vuc0RlbHRhUmVxdWVzdCIsIlNlbWFudGljVG9rZW5zUmVxdWVzdCIsIlRva2VuRm9ybWF0IiwiV29ya0RvbmVQcm9ncmVzc0NhbmNlbE5vdGlmaWNhdGlvbiIsIldvcmtEb25lUHJvZ3Jlc3NDcmVhdGVSZXF1ZXN0IiwiV29ya0RvbmVQcm9ncmVzcyIsIlNlbGVjdGlvblJhbmdlUmVxdWVzdCIsIkRpZENoYW5nZVdvcmtzcGFjZUZvbGRlcnNOb3RpZmljYXRpb24iLCJXb3Jrc3BhY2VGb2xkZXJzUmVxdWVzdCIsIlR5cGVEZWZpbml0aW9uUmVxdWVzdCIsIkFwcGx5V29ya3NwYWNlRWRpdFJlcXVlc3QiLCJFeGVjdXRlQ29tbWFuZFJlcXVlc3QiLCJQcmVwYXJlUmVuYW1lUmVxdWVzdCIsIlJlbmFtZVJlcXVlc3QiLCJQcmVwYXJlU3VwcG9ydERlZmF1bHRCZWhhdmlvciIsIkRvY3VtZW50T25UeXBlRm9ybWF0dGluZ1JlcXVlc3QiLCJEb2N1bWVudFJhbmdlRm9ybWF0dGluZ1JlcXVlc3QiLCJEb2N1bWVudEZvcm1hdHRpbmdSZXF1ZXN0IiwiRG9jdW1lbnRMaW5rUmVzb2x2ZVJlcXVlc3QiLCJEb2N1bWVudExpbmtSZXF1ZXN0IiwiQ29kZUxlbnNSZWZyZXNoUmVxdWVzdCIsIkNvZGVMZW5zUmVzb2x2ZVJlcXVlc3QiLCJDb2RlTGVuc1JlcXVlc3QiLCJXb3Jrc3BhY2VTeW1ib2xSZXNvbHZlUmVxdWVzdCIsIkRpZENsb3NlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiIsIkRpZFNhdmVOb3RlYm9va0RvY3VtZW50Tm90aWZpY2F0aW9uIiwiRGlkQ2hhbmdlTm90ZWJvb2tEb2N1bWVudE5vdGlmaWNhdGlvbiIsIk5vdGVib29rQ2VsbEFycmF5Q2hhbmdlIiwiRGlkT3Blbk5vdGVib29rRG9jdW1lbnROb3RpZmljYXRpb24iLCJOb3RlYm9va0RvY3VtZW50U3luY1JlZ2lzdHJhdGlvblR5cGUiLCJOb3RlYm9va0RvY3VtZW50IiwiTm90ZWJvb2tDZWxsIiwiRXhlY3V0aW9uU3VtbWFyeSIsIk5vdGVib29rQ2VsbEtpbmQiLCJUeXBlSGllcmFyY2h5U3VwZXJ0eXBlc1JlcXVlc3QiLCJ2c2NvZGVfbGFuZ3VhZ2VzZXJ2ZXJfdHlwZXNfMSIsInByb3RvY29sX2ltcGxlbWVudGF0aW9uXzEiLCJwcm90b2NvbF90eXBlRGVmaW5pdGlvbl8xIiwicHJvdG9jb2xfd29ya3NwYWNlRm9sZGVyXzEiLCJwcm90b2NvbF9jb25maWd1cmF0aW9uXzEiLCJwcm90b2NvbF9jb2xvclByb3ZpZGVyXzEiLCJwcm90b2NvbF9mb2xkaW5nUmFuZ2VfMSIsInByb3RvY29sX2RlY2xhcmF0aW9uXzEiLCJwcm90b2NvbF9zZWxlY3Rpb25SYW5nZV8xIiwicHJvdG9jb2xfcHJvZ3Jlc3NfMSIsInByb3RvY29sX2NhbGxIaWVyYXJjaHlfMSIsInByb3RvY29sX3NlbWFudGljVG9rZW5zXzEiLCJwcm90b2NvbF9zaG93RG9jdW1lbnRfMSIsInByb3RvY29sX2xpbmtlZEVkaXRpbmdSYW5nZV8xIiwicHJvdG9jb2xfZmlsZU9wZXJhdGlvbnNfMSIsInByb3RvY29sX21vbmlrZXJfMSIsInByb3RvY29sX3R5cGVIaWVyYXJjaHlfMSIsInByb3RvY29sX2lubGluZVZhbHVlXzEiLCJwcm90b2NvbF9pbmxheUhpbnRfMSIsInByb3RvY29sX2RpYWdub3N0aWNfMSIsInByb3RvY29sX25vdGVib29rXzEiLCJsYW5ndWFnZSIsInNjaGVtZSIsInBhdHRlcm4iLCJvYmplY3RMaXRlcmFsIiwibm90ZWJvb2tUeXBlIiwibm90ZWJvb2siLCJDcmVhdGUiLCJSZW5hbWUiLCJEZWxldGUiLCJBYm9ydCIsIlRyYW5zYWN0aW9uYWwiLCJUZXh0T25seVRyYW5zYWN0aW9uYWwiLCJVbmRvIiwiVVRGOCIsIlVURjE2IiwiVVRGMzIiLCJoYXNJZCIsImRvY3VtZW50U2VsZWN0b3IiLCJ3b3JrRG9uZVByb2dyZXNzIiwiaGFzV29ya0RvbmVQcm9ncmVzcyIsInVua25vd25Qcm90b2NvbFZlcnNpb24iLCJXYXJuaW5nIiwiSW5mbyIsIkxvZyIsIkluY3JlbWVudGFsIiwiaXNJbmNyZW1lbnRhbCIsInJhbmdlTGVuZ3RoIiwiaXNGdWxsIiwiTWFudWFsIiwiQWZ0ZXJEZWxheSIsIkZvY3VzT3V0IiwiQ3JlYXRlZCIsIkNoYW5nZWQiLCJEZWxldGVkIiwiYmFzZVVyaSIsIldvcmtzcGFjZUZvbGRlciIsIkNoYW5nZSIsIkludm9rZWQiLCJUcmlnZ2VyQ2hhcmFjdGVyIiwiVHJpZ2dlckZvckluY29tcGxldGVDb21wbGV0aW9ucyIsIkNvbnRlbnRDaGFuZ2UiLCJJZGVudGlmaWVyIiwicHJvamVjdCIsImdyb3VwIiwiZ2xvYmFsIiwiJGltcG9ydCIsIiRleHBvcnQiLCJsb2NhbCIsIk1hcmt1cCIsIkNvZGUiLCJleGVjdXRpb25PcmRlciIsInN1Y2Nlc3MiLCJ1aW50ZWdlciIsImVxdWFscyIsIm9uZSIsIkRvY3VtZW50VXJpIiwibWV0YWRhdGEiLCJkaWZmIiwidHdvIiwiZXhlY3V0aW9uU3VtbWFyeSIsImVxdWFsc01ldGFkYXRhIiwib25lQXJyYXkiLCJvdGhlckFycmF5Iiwib25lS2V5cyIsIm90aGVyS2V5cyIsImNlbGxzIiwiaW50ZWdlciIsInR5cGVkQXJyYXkiLCJyZWdpc3RyYXRpb25NZXRob2QiLCJkZWxldGVDb3VudCIsIlJlbGF0aXZlIiwiY2hlY2siLCJBbm5vdGF0ZWRUZXh0RWRpdCIsIkNoYW5nZUFubm90YXRpb24iLCJDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllciIsIkNvZGVBY3Rpb24iLCJDb2RlQWN0aW9uQ29udGV4dCIsIkNvZGVBY3Rpb25LaW5kIiwiQ29kZUFjdGlvblRyaWdnZXJLaW5kIiwiQ29kZURlc2NyaXB0aW9uIiwiQ29kZUxlbnMiLCJDb2xvciIsIkNvbG9ySW5mb3JtYXRpb24iLCJDb2xvclByZXNlbnRhdGlvbiIsIkNvbW1hbmQiLCJDb21wbGV0aW9uSXRlbSIsIkNvbXBsZXRpb25JdGVtS2luZCIsIkNvbXBsZXRpb25JdGVtTGFiZWxEZXRhaWxzIiwiQ29tcGxldGlvbkl0ZW1UYWciLCJDb21wbGV0aW9uTGlzdCIsIkNyZWF0ZUZpbGUiLCJEZWxldGVGaWxlIiwiRGlhZ25vc3RpYyIsIkRpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24iLCJEaWFnbm9zdGljU2V2ZXJpdHkiLCJEb2N1bWVudEhpZ2hsaWdodCIsIkRvY3VtZW50SGlnaGxpZ2h0S2luZCIsIkRvY3VtZW50TGluayIsIkRvY3VtZW50U3ltYm9sIiwiRU9MIiwiRm9sZGluZ1JhbmdlIiwiRm9sZGluZ1JhbmdlS2luZCIsIkZvcm1hdHRpbmdPcHRpb25zIiwiSG92ZXIiLCJJbmxheUhpbnQiLCJJbmxheUhpbnRLaW5kIiwiSW5sYXlIaW50TGFiZWxQYXJ0IiwiSW5saW5lVmFsdWVDb250ZXh0IiwiSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb24iLCJJbmxpbmVWYWx1ZVRleHQiLCJJbmxpbmVWYWx1ZVZhcmlhYmxlTG9va3VwIiwiSW5zZXJ0UmVwbGFjZUVkaXQiLCJJbnNlcnRUZXh0Rm9ybWF0IiwiSW5zZXJ0VGV4dE1vZGUiLCJMb2NhdGlvbiIsIkxvY2F0aW9uTGluayIsIk1hcmtlZFN0cmluZyIsIk1hcmt1cENvbnRlbnQiLCJNYXJrdXBLaW5kIiwiT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIiwiUGFyYW1ldGVySW5mb3JtYXRpb24iLCJQb3NpdGlvbiIsIlJhbmdlIiwiUmVuYW1lRmlsZSIsIlNlbGVjdGlvblJhbmdlIiwiU2VtYW50aWNUb2tlbk1vZGlmaWVycyIsIlNlbWFudGljVG9rZW5UeXBlcyIsIlNlbWFudGljVG9rZW5zIiwiU2lnbmF0dXJlSW5mb3JtYXRpb24iLCJTeW1ib2xJbmZvcm1hdGlvbiIsIlN5bWJvbEtpbmQiLCJTeW1ib2xUYWciLCJUZXh0RG9jdW1lbnQiLCJUZXh0RG9jdW1lbnRFZGl0IiwiVGV4dERvY3VtZW50SWRlbnRpZmllciIsIlRleHREb2N1bWVudEl0ZW0iLCJUZXh0RWRpdCIsIlZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIiLCJXb3Jrc3BhY2VDaGFuZ2UiLCJXb3Jrc3BhY2VFZGl0IiwiV29ya3NwYWNlU3ltYm9sIiwiTUlOX1ZBTFVFIiwiTUFYX1ZBTFVFIiwiY2hhcmFjdGVyIiwidGhyZWUiLCJmb3VyIiwidGFyZ2V0VXJpIiwidGFyZ2V0UmFuZ2UiLCJ0YXJnZXRTZWxlY3Rpb25SYW5nZSIsIm9yaWdpblNlbGVjdGlvblJhbmdlIiwiYWxwaGEiLCJudW1iZXJSYW5nZSIsImNvbG9yIiwidGV4dEVkaXQiLCJhZGRpdGlvbmFsVGV4dEVkaXRzIiwiQ29tbWVudCIsIkltcG9ydHMiLCJSZWdpb24iLCJzdGFydExpbmUiLCJlbmRMaW5lIiwic3RhcnRDaGFyYWN0ZXIiLCJlbmRDaGFyYWN0ZXIiLCJjb2xsYXBzZWRUZXh0IiwiZGVmaW5lZCIsImxvY2F0aW9uIiwiSW5mb3JtYXRpb24iLCJIaW50IiwiaHJlZiIsInNldmVyaXR5IiwiY29kZURlc2NyaXB0aW9uIiwibmV3VGV4dCIsImluc2VydCIsImRlbCIsIm5lZWRzQ29uZmlybWF0aW9uIiwiZGVzY3JpcHRpb24iLCJhbm5vdGF0aW9uIiwiYW5ub3RhdGlvbklkIiwiZWRpdHMiLCJvdmVyd3JpdGUiLCJpZ25vcmVJZkV4aXN0cyIsIm9sZFVyaSIsIm5ld1VyaSIsInJlY3Vyc2l2ZSIsImlnbm9yZUlmTm90RXhpc3RzIiwiY2hhbmdlcyIsImNoYW5nZSIsIlRleHRFZGl0Q2hhbmdlSW1wbCIsImNoYW5nZUFubm90YXRpb25zIiwiZWRpdCIsImFzc2VydENoYW5nZUFubm90YXRpb25zIiwibWFuYWdlIiwiQ2hhbmdlQW5ub3RhdGlvbnMiLCJhbm5vdGF0aW9ucyIsIl9hbm5vdGF0aW9ucyIsIl9jb3VudGVyIiwiaWRPckFubm90YXRpb24iLCJuZXh0SWQiLCJfdGV4dEVkaXRDaGFuZ2VzIiwiX3dvcmtzcGFjZUVkaXQiLCJfY2hhbmdlQW5ub3RhdGlvbnMiLCJ0ZXh0RWRpdENoYW5nZSIsImluaXREb2N1bWVudENoYW5nZXMiLCJnZXRUZXh0RWRpdENoYW5nZSIsInRleHREb2N1bWVudEVkaXQiLCJpbml0Q2hhbmdlcyIsImNyZWF0ZUZpbGUiLCJvcHRpb25zT3JBbm5vdGF0aW9uIiwib3BlcmF0aW9uIiwicmVuYW1lRmlsZSIsImRlbGV0ZUZpbGUiLCJQbGFpblRleHQiLCJNYXJrZG93biIsIk1ldGhvZCIsIkZpZWxkIiwiVmFyaWFibGUiLCJJbnRlcmZhY2UiLCJNb2R1bGUiLCJQcm9wZXJ0eSIsIlVuaXQiLCJWYWx1ZSIsIkVudW0iLCJLZXl3b3JkIiwiU25pcHBldCIsIkZpbGUiLCJSZWZlcmVuY2UiLCJGb2xkZXIiLCJFbnVtTWVtYmVyIiwiQ29uc3RhbnQiLCJTdHJ1Y3QiLCJPcGVyYXRvciIsIlR5cGVQYXJhbWV0ZXIiLCJhc0lzIiwiYWRqdXN0SW5kZW50YXRpb24iLCJkZXRhaWwiLCJpdGVtcyIsImlzSW5jb21wbGV0ZSIsImZyb21QbGFpblRleHQiLCJwbGFpblRleHQiLCJjb250ZW50cyIsImRvY3VtZW50YXRpb24iLCJwYXJhbWV0ZXJzIiwiUmVhZCIsIldyaXRlIiwiTmFtZXNwYWNlIiwiUGFja2FnZSIsIktleSIsIk51bGwiLCJjb250YWluZXJOYW1lIiwic2VsZWN0aW9uUmFuZ2UiLCJjaGlsZHJlbiIsInRhZ3MiLCJRdWlja0ZpeCIsIlJlZmFjdG9yIiwiUmVmYWN0b3JFeHRyYWN0IiwiUmVmYWN0b3JJbmxpbmUiLCJSZWZhY3RvclJld3JpdGUiLCJTb3VyY2UiLCJTb3VyY2VPcmdhbml6ZUltcG9ydHMiLCJTb3VyY2VGaXhBbGwiLCJBdXRvbWF0aWMiLCJkaWFnbm9zdGljcyIsIm9ubHkiLCJ0cmlnZ2VyS2luZCIsImtpbmRPckNvbW1hbmRPckVkaXQiLCJjaGVja0tpbmQiLCJpc1ByZWZlcnJlZCIsInRhYlNpemUiLCJpbnNlcnRTcGFjZXMiLCJwYXJlbnQiLCJyZXN1bHRJZCIsInZhcmlhYmxlTmFtZSIsImNhc2VTZW5zaXRpdmVMb29rdXAiLCJmcmFtZUlkIiwic3RvcHBlZExvY2F0aW9uIiwiVHlwZSIsIlBhcmFtZXRlciIsInRvb2x0aXAiLCJ0ZXh0RWRpdHMiLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsImNvbnRlbnQiLCJGdWxsVGV4dERvY3VtZW50IiwibGluZUNvdW50IiwicG9zaXRpb25BdCIsIm9mZnNldEF0IiwiYXBwbHlFZGl0cyIsInNvcnRlZEVkaXRzIiwibWVyZ2VTb3J0IiwibGFzdE1vZGlmaWVkT2Zmc2V0Iiwic3RhcnRPZmZzZXQiLCJlbmRPZmZzZXQiLCJsZWZ0IiwicmlnaHQiLCJsZWZ0SWR4IiwicmlnaHRJZHgiLCJfdXJpIiwiX2xhbmd1YWdlSWQiLCJfdmVyc2lvbiIsIl9jb250ZW50IiwiX2xpbmVPZmZzZXRzIiwiZ2V0TGluZU9mZnNldHMiLCJsaW5lT2Zmc2V0cyIsImlzTGluZVN0YXJ0IiwiY2giLCJsb3ciLCJoaWdoIiwibWlkIiwibGluZU9mZnNldCIsIm5leHRMaW5lT2Zmc2V0IiwiYXZhaWxhYmxlVHlwZWRBcnJheXMiLCJnbG9iYWxUaGlzIiwidHlwZWRBcnJheXMiLCIkc2xpY2UiLCJjYWNoZSIsInByb3RvIiwic3VwZXJQcm90byIsInRyeVR5cGVkQXJyYXlzIiwidHJ5QWxsVHlwZWRBcnJheXMiLCJmb3VuZCIsImdldHRlciIsInRyeVNsaWNlcyIsInRyeUFsbFNsaWNlcyIsInRhZyIsInBvc3NpYmxlTmFtZXMiLCJvdXQiLCJfX3VudXNlZF93ZWJwYWNrX19fd2VicGFja19tb2R1bGVfXyIsImdldFdlbGxmb3JtZWRSYW5nZSIsImFkZGVkTGluZU9mZnNldHMiLCJjb21wdXRlTGluZU9mZnNldHMiLCJlbnN1cmVCZWZvcmVFT0wiLCJpc0VPTCIsImdldFdlbGxmb3JtZWRFZGl0Iiwic3BhbnMiLCJpc0F0TGluZVN0YXJ0IiwidGV4dE9mZnNldCIsImNoYXIiLCJfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18iLCJtb2R1bGVJZCIsImNhY2hlZE1vZHVsZSIsImRlZmluaXRpb24iLCJKc29uU2VydmljZSIsImJhc2Vfc2VydmljZSIsImNyZWF0ZVNjYW5uZXIiLCJpZ25vcmVUcml2aWEiLCJ0b2tlbk9mZnNldCIsImxpbmVOdW1iZXIiLCJsaW5lU3RhcnRPZmZzZXQiLCJ0b2tlbkxpbmVTdGFydE9mZnNldCIsInByZXZUb2tlbkxpbmVTdGFydE9mZnNldCIsInNjYW5FcnJvciIsInNjYW5IZXhEaWdpdHMiLCJleGFjdCIsImRpZ2l0cyIsInNldFBvc2l0aW9uIiwibmV3UG9zaXRpb24iLCJzY2FuTnVtYmVyIiwiaXNEaWdpdCIsInNjYW5TdHJpbmciLCJjaDIiLCJjaDMiLCJmcm9tQ2hhckNvZGUiLCJpc0xpbmVCcmVhayIsInNjYW5OZXh0IiwiaXNXaGl0ZVNwYWNlIiwic2FmZUxlbmd0aCIsImNvbW1lbnRDbG9zZWQiLCJpc1Vua25vd25Db250ZW50Q2hhcmFjdGVyIiwic2Nhbk5leHROb25Ucml2aWEiLCJnZXRQb3NpdGlvbiIsInNjYW4iLCJnZXRUb2tlbiIsImdldFRva2VuVmFsdWUiLCJnZXRUb2tlbk9mZnNldCIsImdldFRva2VuTGVuZ3RoIiwiZ2V0VG9rZW5TdGFydExpbmUiLCJnZXRUb2tlblN0YXJ0Q2hhcmFjdGVyIiwiZ2V0VG9rZW5FcnJvciIsIkNoYXJhY3RlckNvZGVzIiwiY2FjaGVkU3BhY2VzIiwibWF4Q2FjaGVkVmFsdWVzIiwiY2FjaGVkQnJlYWtMaW5lc1dpdGhTcGFjZXMiLCJzdXBwb3J0ZWRFb2xzIiwiZm9ybWF0X2Zvcm1hdCIsImRvY3VtZW50VGV4dCIsImluaXRpYWxJbmRlbnRMZXZlbCIsImZvcm1hdFRleHQiLCJmb3JtYXRUZXh0U3RhcnQiLCJyYW5nZVN0YXJ0IiwicmFuZ2VFbmQiLCJmb3JtYXRfaXNFT0wiLCJjb21wdXRlSW5kZW50TGV2ZWwiLCJlb2wiLCJnZXRFT0wiLCJlb2xGYXN0UGF0aFN1cHBvcnRlZCIsIm51bWJlckxpbmVCcmVha3MiLCJpbmRlbnRMZXZlbCIsImluZGVudFZhbHVlIiwiaW5kZW50VHlwZSIsInNjYW5uZXIiLCJoYXNFcnJvciIsIm5ld0xpbmVzQW5kSW5kZW50IiwiYW1vdW50T2ZTcGFjZXMiLCJrZWVwTGluZXMiLCJlZGl0T3BlcmF0aW9ucyIsImFkZEVkaXQiLCJmaXJzdFRva2VuIiwiZmlyc3RUb2tlblN0YXJ0IiwiaW5pdGlhbEluZGVudCIsImZpcnN0VG9rZW5FbmQiLCJzZWNvbmRUb2tlbiIsInJlcGxhY2VDb250ZW50IiwibmVlZHNMaW5lQnJlYWsiLCJjb21tZW50VG9rZW5TdGFydCIsImluc2VydEZpbmFsTmV3bGluZSIsInNlY29uZFRva2VuU3RhcnQiLCJzIiwibkNoYXJzIiwiUGFyc2VPcHRpb25zIiwiREVGQVVMVCIsImFsbG93VHJhaWxpbmdDb21tYSIsImdldExvY2F0aW9uIiwic2VnbWVudHMiLCJlYXJseVJldHVybkV4Y2VwdGlvbiIsInByZXZpb3VzTm9kZSIsInByZXZpb3VzTm9kZUluc3QiLCJpc0F0UHJvcGVydHlLZXkiLCJzZXRQcmV2aW91c05vZGUiLCJjb2xvbk9mZnNldCIsInZpc2l0Iiwib25PYmplY3RCZWdpbiIsIm9uT2JqZWN0UHJvcGVydHkiLCJvbk9iamVjdEVuZCIsIm9uQXJyYXlCZWdpbiIsIm9uQXJyYXlFbmQiLCJvbkxpdGVyYWxWYWx1ZSIsImdldE5vZGVUeXBlIiwib25TZXBhcmF0b3IiLCJzZXAiLCJwYXRoIiwibWF0Y2hlcyIsImVycm9ycyIsImN1cnJlbnRQcm9wZXJ0eSIsImN1cnJlbnRQYXJlbnQiLCJwcmV2aW91c1BhcmVudHMiLCJvblZhbHVlIiwidmlzaXRvciIsInBhcnNlcl9wYXJzZVRyZWUiLCJlbnN1cmVQcm9wZXJ0eUNvbXBsZXRlIiwidmFsdWVOb2RlIiwicGFyc2VyX2ZpbmROb2RlQXRMb2NhdGlvbiIsIm5vZGUiLCJzZWdtZW50IiwicHJvcGVydHlOb2RlIiwiZ2V0Tm9kZVBhdGgiLCJnZXROb2RlVmFsdWUiLCJjb250YWlucyIsImluY2x1ZGVSaWdodEJvdW5kIiwiZmluZE5vZGVBdE9mZnNldCIsIl9zY2FubmVyIiwiX2pzb25QYXRoIiwic3VwcHJlc3NlZENhbGxiYWNrcyIsInRvTm9BcmdWaXNpdCIsInZpc2l0RnVuY3Rpb24iLCJ0b09uZUFyZ1Zpc2l0IiwidG9PbmVBcmdWaXNpdFdpdGhQYXRoIiwidG9CZWdpblZpc2l0IiwiY2JSZXR1cm4iLCJ0b0VuZFZpc2l0Iiwib25Db21tZW50IiwiZGlzYWxsb3dDb21tZW50cyIsInNraXBVbnRpbEFmdGVyIiwic2tpcFVudGlsIiwicGFyc2VTdHJpbmciLCJpc1ZhbHVlIiwicGFyc2VMaXRlcmFsIiwidG9rZW5WYWx1ZSIsInBhcnNlUHJvcGVydHkiLCJwYXJzZVZhbHVlIiwicGFyc2VPYmplY3QiLCJuZWVkc0NvbW1hIiwicGFyc2VBcnJheSIsImlzRmlyc3RFbGVtZW50IiwiYWxsb3dFbXB0eUNvbnRlbnQiLCJzdHJpcENvbW1lbnRzIiwicmVwbGFjZUNoIiwicmVtb3ZlUHJvcGVydHkiLCJzZXRQcm9wZXJ0eSIsIm9yaWdpbmFsUGF0aCIsInBhcnNlVHJlZSIsImxhc3RTZWdtZW50IiwiZmluZE5vZGVBdExvY2F0aW9uIiwid2l0aEZvcm1hdHRpbmciLCJleGlzdGluZyIsInByb3BlcnR5SW5kZXgiLCJyZW1vdmVCZWdpbiIsInJlbW92ZUVuZCIsIm5ld1Byb3BlcnR5IiwiZ2V0SW5zZXJ0aW9uSW5kZXgiLCJpbnNlcnRJbmRleCIsInJlbW92YWxJbmRleCIsInRvUmVtb3ZlIiwicGFyZW50RW5kT2Zmc2V0IiwiaXNBcnJheUluc2VydGlvbiIsInRvTW9kaWZ5IiwiZm9ybWF0dGluZ09wdGlvbnMiLCJiZWdpbiIsImVkaXRMZW5ndGgiLCJpc1dTIiwibWFpbl9jcmVhdGVTY2FubmVyIiwiU2NhbkVycm9yIiwiU3ludGF4S2luZCIsIm1haW5fZ2V0TG9jYXRpb24iLCJtYWluX3BhcnNlIiwibWFpbl9wYXJzZVRyZWUiLCJtYWluX2ZpbmROb2RlQXRMb2NhdGlvbiIsIm1haW5fZmluZE5vZGVBdE9mZnNldCIsIm1haW5fZ2V0Tm9kZVBhdGgiLCJtYWluX2dldE5vZGVWYWx1ZSIsIm1haW5fdmlzaXQiLCJtYWluX3N0cmlwQ29tbWVudHMiLCJQYXJzZUVycm9yQ29kZSIsInByaW50UGFyc2VFcnJvckNvZGUiLCJtYWluX2Zvcm1hdCIsIm1vZGlmeSIsImlzRGVmaW5lZCIsImhheXN0YWNrIiwibmVlZGxlIiwibGFzdEluZGV4T2YiLCJjb252ZXJ0U2ltcGxlMlJlZ0V4cFBhdHRlcm4iLCJzdHJpbmdzX3JlcGVhdCIsImV4dGVuZGVkUmVnRXhwIiwic3RyaW5nTGVuZ3RoIiwianNvbl9zZXJ2aWNlX1VSSSIsIm1haW5fTWFya3VwQ29udGVudCIsIm1haW5fQ29tcGxldGlvbkl0ZW1LaW5kIiwibWFpbl9JbnNlcnRUZXh0Rm9ybWF0IiwibWFpbl9NYXJrZWRTdHJpbmciLCJTdHJpbmdWYWx1ZSIsImNyZWF0ZVNuaXBwZXQiLCJJbmxpbmVDb21wbGV0aW9uSXRlbSIsImluc2VydFRleHQiLCJmaWx0ZXJUZXh0IiwiSW5saW5lQ29tcGxldGlvbkxpc3QiLCJJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmQiLCJTZWxlY3RlZENvbXBsZXRpb25JbmZvIiwiSW5saW5lQ29tcGxldGlvbkNvbnRleHQiLCJzZWxlY3RlZENvbXBsZXRpb25JbmZvIiwibWFpbiIsIkVycm9yQ29kZSIsIlNjaGVtYURyYWZ0IiwiQ2xpZW50Q2FwYWJpbGl0aWVzIiwiTEFURVNUIiwibGFiZWxEZXRhaWxzU3VwcG9ydCIsInJlYWRGaWxlRnJvbVVyaSIsInByb3RvY29sIiwiZmV0Y2giLCJyZWFkRmlsZUZyb21Gc1BhdGgiLCJidW5kbGUiLCJjb25maWciLCJjb25maWcyIiwiZmlsZUNvbnRlbnQiLCJmc1BhdGgiLCJpc0J1aWx0aW5FeHRlbnNpb24iLCJVUkwiLCJ1cmlDb250ZW50IiwidCIsImZpcnN0QXJnIiwiZm9ybWF0QXJncyIsInJlcGxhY2VtZW50cyIsImNvbW1lbnQiLCJtZXNzYWdlRnJvbUJ1bmRsZSIsImJyb3dzZXJfZm9ybWF0IiwiX2Zvcm1hdDJSZWdleHAiLCJ0ZW1wbGF0ZSIsImpzb24iLCJlcnJvck1lc3NhZ2UiLCJBU1ROb2RlSW1wbCIsIk51bGxBU1ROb2RlSW1wbCIsIkJvb2xlYW5BU1ROb2RlSW1wbCIsImJvb2xWYWx1ZSIsIkFycmF5QVNUTm9kZUltcGwiLCJOdW1iZXJBU1ROb2RlSW1wbCIsImlzSW50ZWdlciIsIlN0cmluZ0FTVE5vZGVJbXBsIiwiUHJvcGVydHlBU1ROb2RlSW1wbCIsImtleU5vZGUiLCJPYmplY3RBU1ROb2RlSW1wbCIsInByb3BlcnRpZXMiLCJhc1NjaGVtYSIsInNjaGVtYSIsIkVudW1NYXRjaCIsInNjaGVtYURyYWZ0RnJvbUlkIiwidjMiLCJ2NCIsInY2IiwidjciLCJ2MjAxOV8wOSIsInYyMDIwXzEyIiwiRXZhbHVhdGlvbkNvbnRleHQiLCJzY2hlbWFEcmFmdCIsIlNjaGVtYUNvbGxlY3RvciIsInNjaGVtYXMiLCJpbmNsdWRlIiwiZm9jdXNPZmZzZXQiLCJqc29uUGFyc2VyX2NvbnRhaW5zIiwiZXhjbHVkZSIsIm5ld1N1YiIsIk5vT3BTY2hlbWFDb2xsZWN0b3IiLCJfc2NoZW1hIiwiX290aGVyIiwiX25vZGUiLCJWYWxpZGF0aW9uUmVzdWx0IiwiaGFzUHJvYmxlbXMiLCJwcm9ibGVtcyIsInZhbGlkYXRpb25SZXN1bHQiLCJwcm9wZXJ0aWVzTWF0Y2hlcyIsInByb3BlcnRpZXNWYWx1ZU1hdGNoZXMiLCJtZXJnZVByb2Nlc3NlZFByb3BlcnRpZXMiLCJtZXJnZUVudW1WYWx1ZXMiLCJlbnVtVmFsdWVNYXRjaCIsImVudW1WYWx1ZXMiLCJFbnVtVmFsdWVNaXNtYXRjaCIsInYiLCJtZXJnZVByb3BlcnR5TWF0Y2giLCJwcm9wZXJ0eVZhbGlkYXRpb25SZXN1bHQiLCJwcmltYXJ5VmFsdWVNYXRjaGVzIiwicHJvY2Vzc2VkUHJvcGVydGllcyIsIm5ld0pTT05Eb2N1bWVudCIsIkpTT05Eb2N1bWVudCIsImpzb25QYXJzZXJfZ2V0Tm9kZVZhbHVlIiwianNvblBhcnNlcl9nZXROb2RlUGF0aCIsImdldE5vZGVGcm9tT2Zmc2V0IiwiZG9WaXNpdCIsImN0biIsInZhbGlkYXRlIiwiZ2V0U2NoZW1hRHJhZnQiLCJnZXRNYXRjaGluZ1NjaGVtYXMiLCJtYXRjaGluZ1NjaGVtYXMiLCJzeW50YXhFcnJvcnMiLCJjb21tZW50cyIsImZhbGxCYWNrIiwic2NoZW1hSWQiLCIkc2NoZW1hIiwiX3ZhbGlkYXRlTm9kZSIsIl92YWxpZGF0ZU9iamVjdE5vZGUiLCJfdmFsaWRhdGVBcnJheU5vZGUiLCJfdmFsaWRhdGVTdHJpbmdOb2RlIiwiX3ZhbGlkYXRlTnVtYmVyTm9kZSIsIm1hdGNoZXNUeXBlIiwic29tZSIsImFsbE9mIiwic3ViU2NoZW1hUmVmIiwic3ViVmFsaWRhdGlvblJlc3VsdCIsInN1Yk1hdGNoaW5nU2NoZW1hcyIsIm5vdFNjaGVtYSIsIm5vdCIsImludmVydGVkIiwidGVzdEFsdGVybmF0aXZlcyIsImFsdGVybmF0aXZlcyIsIm1heE9uZU1hdGNoIiwiYmVzdE1hdGNoIiwic3ViU2NoZW1hIiwiY29tcGFyZVJlc3VsdCIsImFueU9mIiwidGVzdEJyYW5jaCIsInRlc3RDb25kaXRpb24iLCJpZlNjaGVtYSIsInRoZW5TY2hlbWEiLCJlbHNlU2NoZW1hIiwiaWYiLCJlbHNlIiwiZW51bSIsImNvbnN0IiwiZGVwcmVjYXRpb25NZXNzYWdlIiwidGFyZ2V0Tm9kZSIsIm5vcm1hbGl6ZUZsb2F0cyIsImZsb2F0IiwibXVsdGlwbGllciIsIm11bHRpcGxlT2YiLCJyZW1haW5kZXIiLCJub3JtTXVsdGlwbGVPZiIsIm5vcm1WYWx1ZSIsImFicyIsImdldEV4Y2x1c2l2ZUxpbWl0IiwiZXhjbHVzaXZlIiwiZ2V0TGltaXQiLCJleGNsdXNpdmVNaW5pbXVtIiwibWluaW11bSIsImV4Y2x1c2l2ZU1heGltdW0iLCJtYXhpbXVtIiwibWluTGVuZ3RoIiwicmVnZXgiLCJwYXR0ZXJuRXJyb3JNZXNzYWdlIiwicHJlZml4SXRlbXNTY2hlbWFzIiwiYWRkaXRpb25hbEl0ZW1TY2hlbWEiLCJwcmVmaXhJdGVtcyIsImFkZGl0aW9uYWxJdGVtcyIsIml0ZW1WYWxpZGF0aW9uUmVzdWx0IiwiY29udGFpbnNTY2hlbWEiLCJjb250YWluc0NvdW50IiwibWluQ29udGFpbnMiLCJtYXhDb250YWlucyIsInVuZXZhbHVhdGVkSXRlbXMiLCJtaW5JdGVtcyIsIm1heEl0ZW1zIiwidW5pcXVlSXRlbXMiLCJoYXNEdXBsaWNhdGVzIiwic2VlbktleXMiLCJ1bnByb2Nlc3NlZFByb3BlcnRpZXMiLCJyZXF1aXJlZCIsInByb3BlcnR5TmFtZSIsInByb3BlcnR5UHJvY2Vzc2VkIiwicHJvcGVydHlTY2hlbWEiLCJjaGlsZCIsInBhdHRlcm5Qcm9wZXJ0aWVzIiwicHJvcGVydHlQYXR0ZXJuIiwicHJvY2Vzc2VkIiwiYWRkaXRpb25hbFByb3BlcnRpZXMiLCJ1bmV2YWx1YXRlZFByb3BlcnRpZXMiLCJtYXhQcm9wZXJ0aWVzIiwibWluUHJvcGVydGllcyIsImRlcGVuZGVudFJlcXVpcmVkIiwicHJvcGVydHlEZXBzIiwiX3ZhbGlkYXRlUHJvcGVydHlEZXBlbmRlbmNpZXMiLCJkZXBlbmRlbnRTY2hlbWFzIiwiZGVwZW5kZW5jaWVzIiwicHJvcGVydHlOYW1lcyIsInByb3BlcnR5RGVwIiwicmVxdWlyZWRQcm9wIiwianNvblBhcnNlcl9wYXJzZSIsImxhc3RQcm9ibGVtT2Zmc2V0IiwiY29tbWVudFJhbmdlcyIsImNvbGxlY3RDb21tZW50cyIsIl9zY2FuTmV4dCIsIl9jaGVja1NjYW5FcnJvciIsIl9hY2NlcHQiLCJfZXJyb3JBdFJhbmdlIiwiX2Vycm9yIiwiX2ZpbmFsaXplIiwiSW52YWxpZFVuaWNvZGUiLCJJbnZhbGlkRXNjYXBlQ2hhcmFjdGVyIiwiVW5leHBlY3RlZEVuZE9mTnVtYmVyIiwiVW5leHBlY3RlZEVuZE9mQ29tbWVudCIsIlVuZXhwZWN0ZWRFbmRPZlN0cmluZyIsIkludmFsaWRDaGFyYWN0ZXIiLCJfcGFyc2VBcnJheSIsIlZhbHVlRXhwZWN0ZWQiLCJjb21tYU9mZnNldCIsIlRyYWlsaW5nQ29tbWEiLCJDb21tYUV4cGVjdGVkIiwiX3BhcnNlVmFsdWUiLCJDb21tYU9yQ2xvc2VCYWNrZXRFeHBlY3RlZCIsImtleVBsYWNlaG9sZGVyIiwiX3BhcnNlUHJvcGVydHkiLCJrZXlzU2VlbiIsIl9wYXJzZVN0cmluZyIsIlByb3BlcnR5S2V5c011c3RCZURvdWJsZXF1b3RlZCIsIkR1cGxpY2F0ZUtleSIsIkNvbG9uRXhwZWN0ZWQiLCJfcGFyc2VPYmplY3QiLCJQcm9wZXJ0eUV4cGVjdGVkIiwiQ29tbWFPckNsb3NlQnJhY2VFeHBlY3RlZCIsIl9wYXJzZU51bWJlciIsIlVuZGVmaW5lZCIsIl9wYXJzZUxpdGVyYWwiLCJfcm9vdCIsInN0cmluZ2lmeU9iamVjdCIsImluZGVudCIsInN0cmluZ2lmeUxpdGVyYWwiLCJuZXdJbmRlbnQiLCJ2YWx1ZUNvbW1pdENoYXJhY3RlcnMiLCJwcm9wZXJ0eUNvbW1pdENoYXJhY3RlcnMiLCJKU09OQ29tcGxldGlvbiIsImNvbnRyaWJ1dGlvbnMiLCJyZXNvbHZlQ29tcGxldGlvbiIsInJlc29sdmVyIiwicHJvbWlzZUNvbnN0cnVjdG9yIiwiZG9jIiwiaXNJbkNvbW1lbnQiLCJjdXJyZW50V29yZCIsImdldEN1cnJlbnRXb3JkIiwib3ZlcndyaXRlUmFuZ2UiLCJvdmVyd3JpdGVTdGFydCIsInN1cHBvcnRzQ29tbWl0Q2hhcmFjdGVycyIsInByb3Bvc2VkIiwiY29sbGVjdG9yIiwic3VnZ2VzdGlvbiIsInNob3J0ZW5kZWRMYWJlbCIsImNvbW1pdENoYXJhY3RlcnMiLCJsYWJlbERldGFpbHMiLCJzZXRBc0luY29tcGxldGUiLCJnZXROdW1iZXJPZlByb3Bvc2FscyIsInNjaGVtYVNlcnZpY2UiLCJnZXRTY2hlbWFGb3JSZXNvdXJjZSIsImNvbGxlY3Rpb25Qcm9taXNlcyIsImFkZFZhbHVlIiwiY3VycmVudEtleSIsInNlcGFyYXRvckFmdGVyIiwiZXZhbHVhdGVTZXBhcmF0b3JBZnRlciIsImdldFByb3BlcnR5Q29tcGxldGlvbnMiLCJnZXRTY2hlbWFMZXNzUHJvcGVydHlDb21wbGV0aW9ucyIsImNvbnRyaWJ1dGlvbiIsImNvbGxlY3RQcm9taXNlIiwiY29sbGVjdFByb3BlcnR5Q29tcGxldGlvbnMiLCJnZXRMYWJlbEZvclZhbHVlIiwiZ2V0SW5zZXJ0VGV4dEZvclByb3BlcnR5IiwiaW5zZXJ0VGV4dEZvcm1hdCIsImdldFZhbHVlQ29tcGxldGlvbnMiLCJnZXRTY2hlbWFMZXNzVmFsdWVDb21wbGV0aW9ucyIsImdldENvbnRyaWJ1dGVkVmFsdWVDb21wbGV0aW9ucyIsIm9mZnNldEZvclNlcGFyYXRvciIsImFkZEZpbGxlclZhbHVlQ29tcGxldGlvbnMiLCJzY2hlbWFQcm9wZXJ0aWVzIiwiZG9Ob3RTdWdnZXN0IiwicHJvcG9zYWwiLCJnZXRGaWx0ZXJUZXh0Rm9yVmFsdWUiLCJmcm9tTWFya3VwIiwibWFya2Rvd25EZXNjcmlwdGlvbiIsInN1Z2dlc3RTb3J0VGV4dCIsInNvcnRUZXh0Iiwic2NoZW1hUHJvcGVydHlOYW1lcyIsInByb3BlcnR5TmFtZUNvbXBsZXRpb25JdGVtIiwiZW51bURlc2NyaXB0aW9uIiwibWFya2Rvd25FbnVtRGVzY3JpcHRpb25zIiwiZW51bURlc2NyaXB0aW9ucyIsImNvbGxlY3RDb21wbGV0aW9uc0ZvclNpbWlsYXJPYmplY3QiLCJnZXRJbnNlcnRUZXh0Rm9yVmFsdWUiLCJwYXJlbnRLZXkiLCJnZXRTdWdnZXN0aW9uS2luZCIsImNvbGxlY3RTdWdnZXN0aW9uc0ZvclZhbHVlcyIsImdldExhYmVsVGV4dEZvck1hdGNoaW5nTm9kZSIsImdldEluc2VydFRleHRGb3JNYXRjaGluZ05vZGUiLCJhZGRCb29sZWFuVmFsdWVDb21wbGV0aW9uIiwiYWRkRG9sbGFyU2NoZW1hQ29tcGxldGlvbnMiLCJhZGRTY2hlbWFWYWx1ZUNvbXBsZXRpb25zIiwiYyIsImV4aXN0aW5nVmFsdWVzIiwiZmluZEl0ZW1BdE9mZnNldCIsInByb3BlcnR5TWF0Y2hlZCIsImFkZE51bGxWYWx1ZUNvbXBsZXRpb24iLCJjb2xsZWN0RGVmYXVsdENvbXBsZXRpb25zIiwiY29sbGVjdFZhbHVlQ29tcGxldGlvbnMiLCJhZGRFbnVtVmFsdWVDb21wbGV0aW9ucyIsImFkZERlZmF1bHRWYWx1ZUNvbXBsZXRpb25zIiwiY29sbGVjdFR5cGVzIiwiYXJyYXlEZXB0aCIsImhhc1Byb3Bvc2FscyIsImRvZXNTdXBwb3J0c0xhYmVsRGV0YWlscyIsImV4YW1wbGVzIiwiZXhhbXBsZSIsImRlZmF1bHRTbmlwcGV0cyIsImdldEluc2VydFRleHRGb3JTbmlwcGV0VmFsdWUiLCJnZXRGaWx0ZXJUZXh0Rm9yU25pcHBldFZhbHVlIiwiZ2V0TGFiZWxGb3JTbmlwcGV0VmFsdWUiLCJib2R5VGV4dCIsInByZWZpeCIsInN1ZmZpeCIsImVubSIsImRvZXNTdXBwb3J0TWFya2Rvd24iLCJnZXRJbnNlcnRUZXh0Rm9yR3Vlc3NlZFZhbHVlIiwic2NoZW1hSWRzIiwiZ2V0UmVnaXN0ZXJlZFNjaGVtYUlkcyIsImdldFZhbHVlRnJvbUxhYmVsIiwiZ2V0SW5zZXJ0VGV4dEZvclBsYWluVGV4dCIsInJlcGxhY2VyIiwic25pcHBldFZhbHVlIiwicHJvcGVydHlUZXh0IiwicmVzdWx0VGV4dCIsIm5WYWx1ZVByb3Bvc2FscyIsIm1hcmt1cFN0cmluZyIsInN1cHBvcnRzTWFya2Rvd24iLCJjbGllbnRDYXBhYmlsaXRpZXMiLCJkb2VzU3VwcG9ydHNDb21taXRDaGFyYWN0ZXJzIiwiSlNPTkhvdmVyIiwiaG92ZXJSYW5nZU5vZGUiLCJob3ZlclJhbmdlIiwiY3JlYXRlSG92ZXIiLCJnZXRJbmZvQ29udHJpYnV0aW9uIiwiaHRtbENvbnRlbnQiLCJtYXJrZG93bkVudW1WYWx1ZURlc2NyaXB0aW9uIiwiZW51bVZhbHVlIiwidG9NYXJrZG93biIsInRvTWFya2Rvd25Db2RlQmxvY2siLCJwbGFpbiIsIkpTT05WYWxpZGF0aW9uIiwiY29uZmlndXJlIiwicmF3IiwidmFsaWRhdGlvbkVuYWJsZWQiLCJjb21tZW50U2V2ZXJpdHkiLCJhbGxvd0NvbW1lbnRzIiwianNvbkRvY3VtZW50IiwiZG9jdW1lbnRTZXR0aW5ncyIsImFkZGVkIiwiYWRkUHJvYmxlbSIsInByb2JsZW0iLCJzaWduYXR1cmUiLCJnZXREaWFnbm9zdGljcyIsInRyYWlsaW5nQ29tbWFTZXZlcml0eSIsInRyYWlsaW5nQ29tbWFzIiwidG9EaWFnbm9zdGljU2V2ZXJpdHkiLCJzY2hlbWFWYWxpZGF0aW9uIiwic2NoZW1hUmVxdWVzdCIsImFkZFNjaGVtYVByb2JsZW0iLCJlcnJvckNvZGUiLCJhc3RSb290IiwiU2NoZW1hUmVzb2x2ZUVycm9yIiwid2FybmluZyIsIndhcm5pbmdzIiwiU2NoZW1hVW5zdXBwb3J0ZWRGZWF0dXJlIiwic2VtYW50aWNFcnJvcnMiLCJzY2hlbWFBbGxvd3NDb21tZW50cyIsInNjaGVtYUFsbG93c1RyYWlsaW5nQ29tbWFzIiwiQ29tbWVudE5vdFBlcm1pdHRlZCIsImlkQ291bnRlciIsImpzb25TY2hlbWFTZXJ2aWNlIiwicmVnaXN0ZXJFeHRlcm5hbFNjaGVtYSIsImdldFJlc29sdmVkU2NoZW1hIiwicmVzb2x2ZWRTY2hlbWEiLCJnZXRMYW5ndWFnZVN0YXR1cyIsImdldFNjaGVtYVVSSXNGb3JSZXNvdXJjZSIsInNjaGVtYVJlZiIsImFsbG93IiwiYWxsb3dUcmFpbGluZ0NvbW1hcyIsImRlcHJTY2hlbWFSZWYiLCJzZXZlcml0eUxldmVsIiwiRGlnaXQwIiwiRGlnaXQ5IiwiQSIsImhleERpZ2l0IiwiY2hhckNvZGUiLCJjb2xvckZyb21IZXgiLCJjb2xvckZyb20yNTZSR0IiLCJKU09ORG9jdW1lbnRTeW1ib2xzIiwiZmluZERvY3VtZW50U3ltYm9scyIsInJlc3VsdExpbWl0IiwicmVzb3VyY2VTdHJpbmciLCJnZXRSYW5nZSIsImdldE5hbWUiLCJvblJlc3VsdExpbWl0RXhjZWVkZWQiLCJ0b1Zpc2l0IiwibmV4dFRvVmlzaXQiLCJsaW1pdEV4Y2VlZGVkIiwiY29sbGVjdE91dGxpbmVFbnRyaWVzIiwiY2hpbGRDb250YWluZXJOYW1lIiwiZ2V0S2V5TGFiZWwiLCJnZXRTeW1ib2xLaW5kIiwiZmluZERvY3VtZW50U3ltYm9sczIiLCJzeW1ib2wiLCJnZXREZXRhaWwiLCJub2RlVHlwZSIsImZpbmREb2N1bWVudENvbG9ycyIsInZpc2l0ZWROb2RlIiwibm9kZUlkIiwiZ2V0Q29sb3JQcmVzZW50YXRpb25zIiwicmVkMjU2IiwiZ3JlZW4yNTYiLCJibHVlMjU2IiwidG9Ud29EaWdpdEhleCIsInNjaGVtYUNvbnRyaWJ1dGlvbnMiLCJzY2hlbWFBc3NvY2lhdGlvbnMiLCJkZXNjcmlwdGlvbnMiLCJkZWZpbml0aW9ucyIsIiRpZCIsIiRyZWYiLCIkY29tbWVudCIsInJlYWRPbmx5IiwiY29udGVudE1lZGlhVHlwZSIsImNvbnRlbnRFbmNvZGluZyIsInNjaGVtYU5hbWUiLCJwcm9wZXJ0eU9iamVjdCIsIkxJQiIsImgiLCJub3JtYWxpemUiLCJpc0Fic29sdXRlIiwicmVsYXRpdmUiLCJ1IiwiX21ha2VMb25nIiwiZGlybmFtZSIsImJhc2VuYW1lIiwiZXh0bmFtZSIsImV4dCIsImRlbGltaXRlciIsIndpbjMyIiwicG9zaXgiLCJVdGlscyIsIlAiLCJwbGF0Zm9ybSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImF1dGhvcml0eSIsInF1ZXJ5IiwiZnJhZ21lbnQiLCJpc1VyaSIsIndpdGgiLCJDIiwiZnJvbSIsInJldml2ZSIsIl9mb3JtYXR0ZWQiLCJleHRlcm5hbCIsIl9mc1BhdGgiLCJfc2VwIiwiJG1pZCIsInciLCJqb2luUGF0aCIsInJlc29sdmVQYXRoIiwiZXNtX1VSSSIsImNyZWF0ZVJlZ2V4IiwiZ2xvYiIsInJlU3RyIiwiZXh0ZW5kZWQiLCJnbG9ic3RhciIsImluR3JvdXAiLCJwcmV2Q2hhciIsInN0YXJDb3VudCIsIm5leHRDaGFyIiwiaXNHbG9ic3RhciIsIkJBTkciLCJQQVRIX1NFUCIsIkZpbGVQYXR0ZXJuQXNzb2NpYXRpb24iLCJtYXRjaGVzUGF0dGVybiIsImZpbGVOYW1lIiwiZm9sZGVyVXJpIiwicmVnZXhwIiwiZ2xvYldyYXBwZXJzIiwiZ2V0VVJJcyIsInVyaXMiLCJwYXR0ZXJuU3RyaW5nIiwibm9ybWFsaXplUmVzb3VyY2VGb3JNYXRjaGluZyIsIlNjaGVtYUhhbmRsZSIsImdldFVucmVzb2x2ZWRTY2hlbWEiLCJ1bnJlc29sdmVkU2NoZW1hIiwic2VydmljZSIsImxvYWRTY2hlbWEiLCJ1bnJlc29sdmVkIiwicmVzb2x2ZVNjaGVtYUNvbnRlbnQiLCJjbGVhclNjaGVtYSIsImhhc0NoYW5nZXMiLCJhbmNob3JzIiwidW5yZXNvbHZlZFNjaGVtYUNvbnRlbnQiLCJVbnJlc29sdmVkU2NoZW1hIiwiUmVzb2x2ZWRTY2hlbWEiLCJnZXRTZWN0aW9uIiwiZ2V0U2VjdGlvblJlY3Vyc2l2ZSIsIkpTT05TY2hlbWFTZXJ2aWNlIiwicmVnaXN0ZXJlZFNjaGVtYXNJZHMiLCJjYWxsT25EaXNwb3NlIiwib25SZXNvdXJjZUNoYW5nZSIsImNhY2hlZFNjaGVtYUZvclJlc291cmNlIiwibm9ybWFsaXplSWQiLCJ0b1dhbGsiLCJzY2hlbWFzQnlJZCIsImN1cnIiLCJzZXRTY2hlbWFDb250cmlidXRpb25zIiwibm9ybWFsaXplZElkIiwiY29udHJpYnV0aW9uU2NoZW1hcyIsImFkZFNjaGVtYUhhbmRsZSIsInNjaGVtYUFzc29jaWF0aW9uIiwiYXNzb2NpYXRpb24iLCJhZGRGaWxlUGF0dGVybkFzc29jaWF0aW9uIiwiY29udHJpYnV0aW9uQXNzb2NpYXRpb25zIiwic2NoZW1hSGFuZGxlIiwiZ2V0T3JBZGRTY2hlbWFIYW5kbGUiLCJmcGEiLCJmaWxlUGF0dGVybkFzc29jaWF0aW9ucyIsImZpbGVNYXRjaCIsImNsZWFyRXh0ZXJuYWxTY2hlbWFzIiwiY29udHJpYnV0aW9uQXNzb2NpYXRpb24iLCJ1cmwiLCJyZXF1ZXN0U2VydmljZSIsInRvRGlzcGxheVN0cmluZyIsInRyaW1TdGFydCIsInNjaGVtYUNvbnRlbnQiLCJqc29uRXJyb3JzIiwiZXJyb3JTcGxpdCIsInNjaGVtYVRvUmVzb2x2ZSIsInJlc29sdmVFcnJvcnMiLCJ1c2VzVW5zdXBwb3J0ZWRGZWF0dXJlcyIsImNvbnRleHRTZXJ2aWNlIiwiZmluZFNlY3Rpb25CeUpTT05Qb2ludGVyIiwiZmluZFNjaGVtYUJ5SWQiLCJjb2xsZWN0QW5jaG9ycyIsInNlY3Rpb24iLCJtZXJnZVJlZiIsInNvdXJjZVJvb3QiLCJzb3VyY2VIYW5kbGUiLCJyZWZTZWdtZW50IiwicmVzb2x2ZUV4dGVybmFsTGluayIsInBhcmVudEhhbmRsZSIsInJlc29sdmVSZWxhdGl2ZVBhdGgiLCJyZWZlcmVuY2VkSGFuZGxlIiwibG9jIiwicmVzb2x2ZVJlZnMiLCJwYXJlbnRTY2hlbWEiLCJvcGVuUHJvbWlzZXMiLCJ0cmF2ZXJzZU5vZGVzIiwic2VlblJlZnMiLCJyZWYiLCIkcmVjdXJzaXZlUmVmIiwiJGR5bmFtaWNSZWYiLCJhbmNob3IiLCIkYW5jaG9yIiwiJHJlY3Vyc2l2ZUFuY2hvciIsIiRkeW5hbWljQW5jaG9yIiwicmVzb2x2ZVdhcm5pbmdzIiwiY29sbGVjdEVudHJpZXMiLCJlbnRyeSIsImNvbGxlY3RNYXBFbnRyaWVzIiwibWFwcyIsImNvbGxlY3RBcnJheUVudHJpZXMiLCJhcnJheXMiLCJjb2xsZWN0RW50cnlPckFycmF5RW50cmllcyIsIiRkZWZzIiwiZ2V0U2NoZW1hRnJvbVByb3BlcnR5IiwicmVzb3VyY2UiLCJnZXRBc3NvY2lhdGVkU2NoZW1hcyIsIm5vcm1hbGl6ZWRSZXNvdXJjZSIsInNjaGVtZUlkIiwiY3JlYXRlQ29tYmluZWRTY2hlbWEiLCJjb21iaW5lZFNjaGVtYUlkIiwiY29tYmluZWRTY2hlbWEiLCJqc29uU2NoZW1hU2VydmljZV9pZENvdW50ZXIiLCJnZXRGb2xkaW5nUmFuZ2VzIiwibmVzdGluZ0xldmVscyIsInByZXZTdGFydCIsImFkZFJhbmdlIiwicmFuZ2VMaW1pdCIsIm9uUmFuZ2VMaW1pdEV4Y2VlZGVkIiwiY291bnRzIiwibGV2ZWwiLCJtYXhMZXZlbCIsImdldFNlbGVjdGlvblJhbmdlcyIsInBvc2l0aW9ucyIsImdldFNlbGVjdGlvblJhbmdlIiwiY1N0YXJ0IiwiY0VuZCIsIm5ld1JhbmdlIiwiYWZ0ZXJDb21tYU9mZnNldCIsImdldE9mZnNldEFmdGVyTmV4dFRva2VuIiwiZXhwZWN0ZWRUb2tlbiIsInV0aWxzX2Zvcm1hdF9mb3JtYXQiLCJkb2N1bWVudFRvRm9ybWF0IiwiZm9ybWF0dGluZ1JhbmdlIiwiQ29udGFpbmVyIiwiUHJvcGVydHlUcmVlIiwiYWRkQ2hpbGRQcm9wZXJ0eSIsImNoaWxkUHJvcGVydHkiLCJjaGlsZHJlblByb3BlcnRpZXMiLCJpbnNlcnRpb25JbmRleCIsIm5vS2V5TmFtZSIsImJpbmFyeVNlYXJjaE9uUHJvcGVydHlBcnJheSIsImNvbXBhcmVQcm9wZXJ0aWVzIiwiYmVnaW5uaW5nTGluZU51bWJlciIsImxhc3RQcm9wZXJ0eSIsInByb3BlcnR5VHJlZTEiLCJwcm9wZXJ0eVRyZWUyIiwicHJvcGVydHlOYW1lMSIsInByb3BlcnR5TmFtZTIiLCJwcm9wZXJ0eVRyZWVBcnJheSIsInByb3BlcnR5VHJlZSIsImNvbXBhcmVfZm4iLCJmaXJzdFByb3BlcnR5SW5BcnJheU5hbWUiLCJsYXN0UHJvcGVydHlJbkFycmF5TmFtZSIsImRvY3VtZW50VG9Tb3J0IiwiZm9ybWF0dGVkSnNvblN0cmluZyIsImZvcm1hdHRlZEpzb25Eb2N1bWVudCIsImpzb25Qcm9wZXJ0eVRyZWUiLCJmaW5kSnNvbmNQcm9wZXJ0eVRyZWUiLCJzb3J0ZWRKc29uRG9jdW1lbnQiLCJzb3J0SnNvbmNEb2N1bWVudCIsInNvcnRlZEFuZEZvcm1hdHRlZEpzb25Eb2N1bWVudCIsImZvcm1hdHRlZERvY3VtZW50IiwiZm9ybWF0dGVkU3RyaW5nIiwicm9vdFRyZWUiLCJjdXJyZW50VHJlZSIsImxhc3RUb2tlbkxpbmUiLCJudW1iZXJPZkNoYXJhY3RlcnNPblByZXZpb3VzTGluZXMiLCJsYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuIiwic2Vjb25kVG9MYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuIiwibGluZU9mTGFzdE5vblRyaXZpYU5vbkNvbW1lbnRUb2tlbiIsImVuZEluZGV4T2ZMYXN0Tm9uVHJpdmlhTm9uQ29tbWVudFRva2VuIiwiZW5kTGluZU51bWJlciIsImN1cnJlbnRDb250YWluZXJTdGFjayIsInVwZGF0ZUxhc3RQcm9wZXJ0eUVuZExpbmVOdW1iZXIiLCJ1cGRhdGVCZWdpbm5pbmdMaW5lTnVtYmVyIiwibGVuZ3RoT2ZMaW5lIiwibGluZVdoZXJlVG9BZGRDb21tYSIsImluZGV4V2hlcmVUb0FkZENvbWEiLCJjb21tYUluZGV4IiwiY29tbWFMaW5lIiwicXVldWVUb1NvcnQiLCJ1cGRhdGVTb3J0aW5nUXVldWUiLCJkYXRhVG9Tb3J0IiwianNvbkNvbnRlbnRUb1JlcGxhY2UiLCJqc29uRG9jdW1lbnRUb1JlcGxhY2UiLCJpbmRleFdoZXJlVG9BZGRDb21tYSIsImxpbmVXaGVyZVRvUmVtb3ZlQ29tbWEiLCJzb3J0UHJvcGVydGllc0Nhc2VTZW5zaXRpdmUiLCJhTmFtZSIsImJOYW1lIiwibWluaW11bUJlZ2lubmluZ0xpbmVOdW1iZXIiLCJTb3J0aW5nUmFuZ2UiLCJ1cGRhdGVTb3J0aW5nUXVldWVGb3JBcnJheVByb3BlcnRpZXMiLCJzdWJPYmplY3QiLCJmaW5kTGlua3MiLCJsaW5rcyIsImZpbmRUYXJnZXROb2RlIiwidGFyZ2V0UG9zIiwiY3JlYXRlUmFuZ2UiLCJ0b2tlbnMiLCJwYXJzZUpTT05Qb2ludGVyIiwiZmluZE5vZGUiLCJwb2ludGVyIiwiZmluZCIsImFycmF5SXRlbSIsImpzb25MaW5rc191bmVzY2FwZSIsImdldExhbmd1YWdlU2VydmljZSIsInNjaGVtYVJlcXVlc3RTZXJ2aWNlIiwid29ya3NwYWNlQ29udGV4dCIsImpzb25Db21wbGV0aW9uIiwianNvbkhvdmVyIiwianNvbkRvY3VtZW50U3ltYm9scyIsImpzb25WYWxpZGF0aW9uIiwic2V0dGluZ3MiLCJyZXNldFNjaGVtYSIsInBhcnNlSlNPTkRvY3VtZW50IiwiZmluZERlZmluaXRpb24iLCJicm93c2VyX21haW4iLCJ1dGlscyIsIkFjZVJhbmdlIiwiZ2V0Q29uc3RydWN0b3IiLCJlZGl0b3IiLCJfaW5zdGFuY2UiLCJjb21tb25fY29udmVydGVyc19Db21tb25Db252ZXJ0ZXIiLCJDb21tb25Db252ZXJ0ZXIiLCJub3JtYWxpemVSYW5nZXMiLCJjb21wbGV0aW9ucyIsImVsIiwidG9SYW5nZSIsImNsZWFuSHRtbCIsImh0bWwiLCJmcm9tUG9pbnRzIiwiY29udmVydEtpbmQiLCJleGNsdWRlQnlFcnJvck1lc3NhZ2UiLCJmaWVsZE5hbWUiLCJmcm9tUmFuZ2UiLCJyYW5nZUZyb21Qb3NpdGlvbnMiLCJmcm9tUG9pbnQiLCJwb2ludCIsInRvUG9pbnQiLCJ0b0Fubm90YXRpb25zIiwiX2RpYWdub3N0aWNzIiwiZnJvbUFubm90YXRpb25zIiwidG9Db21wbGV0aW9uIiwiX2l0ZW1fdGV4dEVkaXQiLCJfaXRlbV9jb21tYW5kIiwiaXRlbUtpbmQiLCJfaXRlbV90ZXh0RWRpdF9uZXdUZXh0IiwiX3JlZiIsImZpcnN0V29yZE1hdGNoIiwiZmlyc3RXb3JkIiwid29yZFJlZ2V4IiwiZ2V0VGV4dEVkaXRSYW5nZSIsImNhcHRpb24iLCJzY29yZSIsInRvQ29tcGxldGlvbnMiLCJjb21iaW5lZENvbXBsZXRpb25zIiwiYWxsQ29tcGxldGlvbnMiLCJmbGF0IiwidG9SZXNvbHZlZENvbXBsZXRpb24iLCJmcm9tTWFya3VwQ29udGVudCIsInRvQ29tcGxldGlvbkl0ZW0iLCJfY29tcGxldGlvbl9jYXB0aW9uIiwiX2NvbXBsZXRpb25fc25pcHBldCIsIl9jb21wbGV0aW9uX3NuaXBwZXQxIiwiZmlsdGVyTGVuZ3RoIiwibWVyZ2VkUmFuZ2VzIiwidG9Ub29sdGlwIiwiX2hvdmVyX2ZpbmQiLCJsc3BSYW5nZSIsIl9lbCIsImZyb21TaWduYXR1cmVIZWxwIiwiX2VsMSIsInNpZ25hdHVyZUluZGV4IiwiYWN0aXZlU2lnbmF0dXJlIiwic2lnbmF0dXJlcyIsImFjdGl2ZVBhcmFtIiwiYWN0aXZlUGFyYW1ldGVyIiwiZnJvbUFjZURlbHRhIiwibGluZXMiLCJhY3Rpb24iLCJmaWx0ZXJEaWFnbm9zdGljcyIsImZpbHRlckVycm9ycyIsImZyb21Eb2N1bWVudEhpZ2hsaWdodHMiLCJkb2N1bWVudEhpZ2hsaWdodHMiLCJjbGFzc05hbWUiLCJ0b01hcmtlckdyb3VwSXRlbSIsInRvb2x0aXBUZXh0IiwibWFya2VyR3JvdXBJdGVtIiwianNvbl9zZXJ2aWNlX2RlZmluZV9wcm9wZXJ0eSIsIiRnZXRKc29uU2NoZW1hVXJpIiwiJGNvbmZpZ3VyZVNlcnZpY2UiLCJnZXRTY2hlbWFPcHRpb24iLCJfc2NoZW1hcyIsInNlc3Npb25JRHMiLCJfZmlsZU1hdGNoIiwiX2VsX3NjaGVtYSIsIiRzZXJ2aWNlIiwiJGNvbmZpZ3VyZUpzb25TZXJ2aWNlIiwiX2VsX2ZpbGVNYXRjaCIsImZ1bGxEb2N1bWVudCIsImNvbXBsZXRpb25Qcm92aWRlciIsInRyaWdnZXJDaGFyYWN0ZXJzIiwiZGlhZ25vc3RpY1Byb3ZpZGVyIiwiaW50ZXJGaWxlRGVwZW5kZW5jaWVzIiwid29ya3NwYWNlRGlhZ25vc3RpY3MiLCJkb2N1bWVudFJhbmdlRm9ybWF0dGluZ1Byb3ZpZGVyIiwiZG9jdW1lbnRGb3JtYXR0aW5nUHJvdmlkZXIiLCJob3ZlclByb3ZpZGVyIiwianNvblNjaGVtYSJdLCJzb3VyY2VSb290IjoiIn0=