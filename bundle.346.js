(self["webpackChunkace_linters_root"] = self["webpackChunkace_linters_root"] || []).push([[346],{

/***/ 5346:
/***/ ((module) => {

/*! For license information please see yaml-service.js.LICENSE.txt */
!function (e, t) { if (true)
    module.exports = t();
else { var r, n; } }(self, (() => (() => { var e = { 1696: (e, t, n) => {
        "use strict";
        var r = n(4406), o = n(3716);
        function i(e) { return i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e; } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e; }, i(e); }
        var s, a, u = n(7515).codes, c = u.ERR_AMBIGUOUS_ARGUMENT, l = u.ERR_INVALID_ARG_TYPE, p = u.ERR_INVALID_ARG_VALUE, f = u.ERR_INVALID_RETURN_VALUE, d = u.ERR_MISSING_ARGS, h = n(4082), m = n(3335).inspect, g = n(3335).types, y = g.isPromise, v = g.isRegExp, b = Object.assign ? Object.assign : n(4956).assign, D = Object.is ? Object.is : n(4679);
        function E() { var e = n(6796); s = e.isDeepEqual, a = e.isDeepStrictEqual; }
        new Map;
        var C = !1, w = e.exports = T, A = {};
        function S(e) { if (e.message instanceof Error)
            throw e.message; throw new h(e); }
        function x(e, t, n, r) { if (!n) {
            var o = !1;
            if (0 === t)
                o = !0, r = "No value argument passed to `assert.ok()`";
            else if (r instanceof Error)
                throw r;
            var i = new h({ actual: n, expected: !0, message: r, operator: "==", stackStartFn: e });
            throw i.generatedMessage = o, i;
        } }
        function T() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n]; x.apply(void 0, [T, t.length].concat(t)); }
        w.fail = function e(t, n, i, s, a) { var u, c = arguments.length; if (0 === c)
            u = "Failed";
        else if (1 === c)
            i = t, t = void 0;
        else {
            if (!1 === C) {
                C = !0;
                var l = r.emitWarning ? r.emitWarning : o.warn.bind(o);
                l("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
            }
            2 === c && (s = "!=");
        } if (i instanceof Error)
            throw i; var p = { actual: t, expected: n, operator: void 0 === s ? "fail" : s, stackStartFn: a || e }; void 0 !== i && (p.message = i); var f = new h(p); throw u && (f.message = u, f.generatedMessage = !0), f; }, w.AssertionError = h, w.ok = T, w.equal = function e(t, n, r) { if (arguments.length < 2)
            throw new d("actual", "expected"); t != n && S({ actual: t, expected: n, message: r, operator: "==", stackStartFn: e }); }, w.notEqual = function e(t, n, r) { if (arguments.length < 2)
            throw new d("actual", "expected"); t == n && S({ actual: t, expected: n, message: r, operator: "!=", stackStartFn: e }); }, w.deepEqual = function e(t, n, r) { if (arguments.length < 2)
            throw new d("actual", "expected"); void 0 === s && E(), s(t, n) || S({ actual: t, expected: n, message: r, operator: "deepEqual", stackStartFn: e }); }, w.notDeepEqual = function e(t, n, r) { if (arguments.length < 2)
            throw new d("actual", "expected"); void 0 === s && E(), s(t, n) && S({ actual: t, expected: n, message: r, operator: "notDeepEqual", stackStartFn: e }); }, w.deepStrictEqual = function e(t, n, r) { if (arguments.length < 2)
            throw new d("actual", "expected"); void 0 === s && E(), a(t, n) || S({ actual: t, expected: n, message: r, operator: "deepStrictEqual", stackStartFn: e }); }, w.notDeepStrictEqual = function e(t, n, r) { if (arguments.length < 2)
            throw new d("actual", "expected"); void 0 === s && E(), a(t, n) && S({ actual: t, expected: n, message: r, operator: "notDeepStrictEqual", stackStartFn: e }); }, w.strictEqual = function e(t, n, r) { if (arguments.length < 2)
            throw new d("actual", "expected"); D(t, n) || S({ actual: t, expected: n, message: r, operator: "strictEqual", stackStartFn: e }); }, w.notStrictEqual = function e(t, n, r) { if (arguments.length < 2)
            throw new d("actual", "expected"); D(t, n) && S({ actual: t, expected: n, message: r, operator: "notStrictEqual", stackStartFn: e }); };
        var k = function e(t, n, r) { var o = this; !function (e, t) { if (!(e instanceof t))
            throw new TypeError("Cannot call a class as a function"); }(this, e), n.forEach((function (e) { e in t && (void 0 !== r && "string" == typeof r[e] && v(t[e]) && t[e].test(r[e]) ? o[e] = r[e] : o[e] = t[e]); })); };
        function F(e, t, n, r, o, i) { if (!(n in e) || !a(e[n], t[n])) {
            if (!r) {
                var s = new k(e, o), u = new k(t, o, e), c = new h({ actual: s, expected: u, operator: "deepStrictEqual", stackStartFn: i });
                throw c.actual = e, c.expected = t, c.operator = i.name, c;
            }
            S({ actual: e, expected: t, message: r, operator: i.name, stackStartFn: i });
        } }
        function O(e, t, n, r) { if ("function" != typeof t) {
            if (v(t))
                return t.test(e);
            if (2 === arguments.length)
                throw new l("expected", ["Function", "RegExp"], t);
            if ("object" !== i(e) || null === e) {
                var o = new h({ actual: e, expected: t, message: n, operator: "deepStrictEqual", stackStartFn: r });
                throw o.operator = r.name, o;
            }
            var a = Object.keys(t);
            if (t instanceof Error)
                a.push("name", "message");
            else if (0 === a.length)
                throw new p("error", t, "may not be an empty object");
            return void 0 === s && E(), a.forEach((function (o) { "string" == typeof e[o] && v(t[o]) && t[o].test(e[o]) || F(e, t, o, n, a, r); })), !0;
        } return void 0 !== t.prototype && e instanceof t || !Error.isPrototypeOf(t) && !0 === t.call({}, e); }
        function _(e) { if ("function" != typeof e)
            throw new l("fn", "Function", e); try {
            e();
        }
        catch (e) {
            return e;
        } return A; }
        function N(e) { return y(e) || null !== e && "object" === i(e) && "function" == typeof e.then && "function" == typeof e.catch; }
        function P(e) { return Promise.resolve().then((function () { var t; if ("function" == typeof e) {
            if (!N(t = e()))
                throw new f("instance of Promise", "promiseFn", t);
        }
        else {
            if (!N(e))
                throw new l("promiseFn", ["Function", "Promise"], e);
            t = e;
        } return Promise.resolve().then((function () { return t; })).then((function () { return A; })).catch((function (e) { return e; })); })); }
        function M(e, t, n, r) { if ("string" == typeof n) {
            if (4 === arguments.length)
                throw new l("error", ["Object", "Error", "Function", "RegExp"], n);
            if ("object" === i(t) && null !== t) {
                if (t.message === n)
                    throw new c("error/message", 'The error message "'.concat(t.message, '" is identical to the message.'));
            }
            else if (t === n)
                throw new c("error/message", 'The error "'.concat(t, '" is identical to the message.'));
            r = n, n = void 0;
        }
        else if (null != n && "object" !== i(n) && "function" != typeof n)
            throw new l("error", ["Object", "Error", "Function", "RegExp"], n); if (t === A) {
            var o = "";
            n && n.name && (o += " (".concat(n.name, ")")), o += r ? ": ".concat(r) : ".";
            var s = "rejects" === e.name ? "rejection" : "exception";
            S({ actual: void 0, expected: n, operator: e.name, message: "Missing expected ".concat(s).concat(o), stackStartFn: e });
        } if (n && !O(t, n, r, e))
            throw t; }
        function R(e, t, n, r) { if (t !== A) {
            if ("string" == typeof n && (r = n, n = void 0), !n || O(t, n)) {
                var o = r ? ": ".concat(r) : ".", i = "doesNotReject" === e.name ? "rejection" : "exception";
                S({ actual: t, expected: n, operator: e.name, message: "Got unwanted ".concat(i).concat(o, "\n") + 'Actual message: "'.concat(t && t.message, '"'), stackStartFn: e });
            }
            throw t;
        } }
        function I() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n]; x.apply(void 0, [I, t.length].concat(t)); }
        w.throws = function e(t) { for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++)
            r[o - 1] = arguments[o]; M.apply(void 0, [e, _(t)].concat(r)); }, w.rejects = function e(t) { for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++)
            r[o - 1] = arguments[o]; return P(t).then((function (t) { return M.apply(void 0, [e, t].concat(r)); })); }, w.doesNotThrow = function e(t) { for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++)
            r[o - 1] = arguments[o]; R.apply(void 0, [e, _(t)].concat(r)); }, w.doesNotReject = function e(t) { for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++)
            r[o - 1] = arguments[o]; return P(t).then((function (t) { return R.apply(void 0, [e, t].concat(r)); })); }, w.ifError = function e(t) { if (null != t) {
            var n = "ifError got unwanted exception: ";
            "object" === i(t) && "string" == typeof t.message ? 0 === t.message.length && t.constructor ? n += t.constructor.name : n += t.message : n += m(t);
            var r = new h({ actual: t, expected: null, operator: "ifError", message: n, stackStartFn: e }), o = t.stack;
            if ("string" == typeof o) {
                var s = o.split("\n");
                s.shift();
                for (var a = r.stack.split("\n"), u = 0; u < s.length; u++) {
                    var c = a.indexOf(s[u]);
                    if (-1 !== c) {
                        a = a.slice(0, c);
                        break;
                    }
                }
                r.stack = "".concat(a.join("\n"), "\n").concat(s.join("\n"));
            }
            throw r;
        } }, w.strict = b(I, w, { equal: w.strictEqual, deepEqual: w.deepStrictEqual, notEqual: w.notStrictEqual, notDeepEqual: w.notDeepStrictEqual }), w.strict.strict = w.strict;
    }, 4082: (e, t, n) => {
        "use strict";
        var r = n(4406);
        function o(e, t, n) { return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e; }
        function i(e, t) { for (var n = 0; n < t.length; n++) {
            var r = t[n];
            r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
        } }
        function s(e, t) { return !t || "object" !== d(t) && "function" != typeof t ? a(e) : t; }
        function a(e) { if (void 0 === e)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
        function u(e) { var t = "function" == typeof Map ? new Map : void 0; return u = function (e) { if (null === e || (n = e, -1 === Function.toString.call(n).indexOf("[native code]")))
            return e; var n; if ("function" != typeof e)
            throw new TypeError("Super expression must either be null or a function"); if (void 0 !== t) {
            if (t.has(e))
                return t.get(e);
            t.set(e, r);
        } function r() { return l(e, arguments, f(this).constructor); } return r.prototype = Object.create(e.prototype, { constructor: { value: r, enumerable: !1, writable: !0, configurable: !0 } }), p(r, e); }, u(e); }
        function c() { if ("undefined" == typeof Reflect || !Reflect.construct)
            return !1; if (Reflect.construct.sham)
            return !1; if ("function" == typeof Proxy)
            return !0; try {
            return Date.prototype.toString.call(Reflect.construct(Date, [], (function () { }))), !0;
        }
        catch (e) {
            return !1;
        } }
        function l(e, t, n) { return l = c() ? Reflect.construct : function (e, t, n) { var r = [null]; r.push.apply(r, t); var o = new (Function.bind.apply(e, r)); return n && p(o, n.prototype), o; }, l.apply(null, arguments); }
        function p(e, t) { return p = Object.setPrototypeOf || function (e, t) { return e.__proto__ = t, e; }, p(e, t); }
        function f(e) { return f = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) { return e.__proto__ || Object.getPrototypeOf(e); }, f(e); }
        function d(e) { return d = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e; } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e; }, d(e); }
        var h = n(3335).inspect, m = n(7515).codes.ERR_INVALID_ARG_TYPE;
        function g(e, t, n) { return (void 0 === n || n > e.length) && (n = e.length), e.substring(n - t.length, n) === t; }
        var y = "", v = "", b = "", D = "", E = { deepStrictEqual: "Expected values to be strictly deep-equal:", strictEqual: "Expected values to be strictly equal:", strictEqualObject: 'Expected "actual" to be reference-equal to "expected":', deepEqual: "Expected values to be loosely deep-equal:", equal: "Expected values to be loosely equal:", notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:', notStrictEqual: 'Expected "actual" to be strictly unequal to:', notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":', notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:', notEqual: 'Expected "actual" to be loosely unequal to:', notIdentical: "Values identical but not reference-equal:" };
        function C(e) { var t = Object.keys(e), n = Object.create(Object.getPrototypeOf(e)); return t.forEach((function (t) { n[t] = e[t]; })), Object.defineProperty(n, "message", { value: e.message }), n; }
        function w(e) { return h(e, { compact: !1, customInspect: !1, depth: 1e3, maxArrayLength: 1 / 0, showHidden: !1, breakLength: 1 / 0, showProxy: !1, sorted: !0, getters: !0 }); }
        var A = function (e) { function t(e) { var n; if (function (e, t) { if (!(e instanceof t))
            throw new TypeError("Cannot call a class as a function"); }(this, t), "object" !== d(e) || null === e)
            throw new m("options", "Object", e); var o = e.message, i = e.operator, u = e.stackStartFn, c = e.actual, l = e.expected, p = Error.stackTraceLimit; if (Error.stackTraceLimit = 0, null != o)
            n = s(this, f(t).call(this, String(o)));
        else if (r.stderr && r.stderr.isTTY && (r.stderr && r.stderr.getColorDepth && 1 !== r.stderr.getColorDepth() ? (y = "[34m", v = "[32m", D = "[39m", b = "[31m") : (y = "", v = "", D = "", b = "")), "object" === d(c) && null !== c && "object" === d(l) && null !== l && "stack" in c && c instanceof Error && "stack" in l && l instanceof Error && (c = C(c), l = C(l)), "deepStrictEqual" === i || "strictEqual" === i)
            n = s(this, f(t).call(this, function (e, t, n) { var o = "", i = "", s = 0, a = "", u = !1, c = w(e), l = c.split("\n"), p = w(t).split("\n"), f = 0, h = ""; if ("strictEqual" === n && "object" === d(e) && "object" === d(t) && null !== e && null !== t && (n = "strictEqualObject"), 1 === l.length && 1 === p.length && l[0] !== p[0]) {
                var m = l[0].length + p[0].length;
                if (m <= 10) {
                    if (!("object" === d(e) && null !== e || "object" === d(t) && null !== t || 0 === e && 0 === t))
                        return "".concat(E[n], "\n\n") + "".concat(l[0], " !== ").concat(p[0], "\n");
                }
                else if ("strictEqualObject" !== n && m < (r.stderr && r.stderr.isTTY ? r.stderr.columns : 80)) {
                    for (; l[0][f] === p[0][f];)
                        f++;
                    f > 2 && (h = "\n  ".concat(function (e, t) { if (t = Math.floor(t), 0 == e.length || 0 == t)
                        return ""; var n = e.length * t; for (t = Math.floor(Math.log(t) / Math.log(2)); t;)
                        e += e, t--; return e + e.substring(0, n - e.length); }(" ", f), "^"), f = 0);
                }
            } for (var C = l[l.length - 1], A = p[p.length - 1]; C === A && (f++ < 2 ? a = "\n  ".concat(C).concat(a) : o = C, l.pop(), p.pop(), 0 !== l.length && 0 !== p.length);)
                C = l[l.length - 1], A = p[p.length - 1]; var S = Math.max(l.length, p.length); if (0 === S) {
                var x = c.split("\n");
                if (x.length > 30)
                    for (x[26] = "".concat(y, "...").concat(D); x.length > 27;)
                        x.pop();
                return "".concat(E.notIdentical, "\n\n").concat(x.join("\n"), "\n");
            } f > 3 && (a = "\n".concat(y, "...").concat(D).concat(a), u = !0), "" !== o && (a = "\n  ".concat(o).concat(a), o = ""); var T = 0, k = E[n] + "\n".concat(v, "+ actual").concat(D, " ").concat(b, "- expected").concat(D), F = " ".concat(y, "...").concat(D, " Lines skipped"); for (f = 0; f < S; f++) {
                var O = f - s;
                if (l.length < f + 1)
                    O > 1 && f > 2 && (O > 4 ? (i += "\n".concat(y, "...").concat(D), u = !0) : O > 3 && (i += "\n  ".concat(p[f - 2]), T++), i += "\n  ".concat(p[f - 1]), T++), s = f, o += "\n".concat(b, "-").concat(D, " ").concat(p[f]), T++;
                else if (p.length < f + 1)
                    O > 1 && f > 2 && (O > 4 ? (i += "\n".concat(y, "...").concat(D), u = !0) : O > 3 && (i += "\n  ".concat(l[f - 2]), T++), i += "\n  ".concat(l[f - 1]), T++), s = f, i += "\n".concat(v, "+").concat(D, " ").concat(l[f]), T++;
                else {
                    var _ = p[f], N = l[f], P = N !== _ && (!g(N, ",") || N.slice(0, -1) !== _);
                    P && g(_, ",") && _.slice(0, -1) === N && (P = !1, N += ","), P ? (O > 1 && f > 2 && (O > 4 ? (i += "\n".concat(y, "...").concat(D), u = !0) : O > 3 && (i += "\n  ".concat(l[f - 2]), T++), i += "\n  ".concat(l[f - 1]), T++), s = f, i += "\n".concat(v, "+").concat(D, " ").concat(N), o += "\n".concat(b, "-").concat(D, " ").concat(_), T += 2) : (i += o, o = "", 1 !== O && 0 !== f || (i += "\n  ".concat(N), T++));
                }
                if (T > 20 && f < S - 2)
                    return "".concat(k).concat(F, "\n").concat(i, "\n").concat(y, "...").concat(D).concat(o, "\n") + "".concat(y, "...").concat(D);
            } return "".concat(k).concat(u ? F : "", "\n").concat(i).concat(o).concat(a).concat(h); }(c, l, i)));
        else if ("notDeepStrictEqual" === i || "notStrictEqual" === i) {
            var h = E[i], A = w(c).split("\n");
            if ("notStrictEqual" === i && "object" === d(c) && null !== c && (h = E.notStrictEqualObject), A.length > 30)
                for (A[26] = "".concat(y, "...").concat(D); A.length > 27;)
                    A.pop();
            n = 1 === A.length ? s(this, f(t).call(this, "".concat(h, " ").concat(A[0]))) : s(this, f(t).call(this, "".concat(h, "\n\n").concat(A.join("\n"), "\n")));
        }
        else {
            var S = w(c), x = "", T = E[i];
            "notDeepEqual" === i || "notEqual" === i ? (S = "".concat(E[i], "\n\n").concat(S)).length > 1024 && (S = "".concat(S.slice(0, 1021), "...")) : (x = "".concat(w(l)), S.length > 512 && (S = "".concat(S.slice(0, 509), "...")), x.length > 512 && (x = "".concat(x.slice(0, 509), "...")), "deepEqual" === i || "equal" === i ? S = "".concat(T, "\n\n").concat(S, "\n\nshould equal\n\n") : x = " ".concat(i, " ").concat(x)), n = s(this, f(t).call(this, "".concat(S).concat(x)));
        } return Error.stackTraceLimit = p, n.generatedMessage = !o, Object.defineProperty(a(n), "name", { value: "AssertionError [ERR_ASSERTION]", enumerable: !1, writable: !0, configurable: !0 }), n.code = "ERR_ASSERTION", n.actual = c, n.expected = l, n.operator = i, Error.captureStackTrace && Error.captureStackTrace(a(n), u), n.stack, n.name = "AssertionError", s(n); } var n, u; return function (e, t) { if ("function" != typeof t && null !== t)
            throw new TypeError("Super expression must either be null or a function"); e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && p(e, t); }(t, e), n = t, u = [{ key: "toString", value: function () { return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message); } }, { key: h.custom, value: function (e, t) { return h(this, function (e) { for (var t = 1; t < arguments.length; t++) {
                    var n = null != arguments[t] ? arguments[t] : {}, r = Object.keys(n);
                    "function" == typeof Object.getOwnPropertySymbols && (r = r.concat(Object.getOwnPropertySymbols(n).filter((function (e) { return Object.getOwnPropertyDescriptor(n, e).enumerable; })))), r.forEach((function (t) { o(e, t, n[t]); }));
                } return e; }({}, t, { customInspect: !1, depth: 0 })); } }], u && i(n.prototype, u), t; }(u(Error));
        e.exports = A;
    }, 7515: (e, t, n) => {
        "use strict";
        function r(e) { return r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e; } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e; }, r(e); }
        function o(e) { return o = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) { return e.__proto__ || Object.getPrototypeOf(e); }, o(e); }
        function i(e, t) { return i = Object.setPrototypeOf || function (e, t) { return e.__proto__ = t, e; }, i(e, t); }
        var s, a, u = {};
        function c(e, t, n) { n || (n = Error); var s = function (n) { function s(n, i, a) { var u; return function (e, t) { if (!(e instanceof t))
            throw new TypeError("Cannot call a class as a function"); }(this, s), u = function (e, t) { return !t || "object" !== r(t) && "function" != typeof t ? function (e) { if (void 0 === e)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }(e) : t; }(this, o(s).call(this, function (e, n, r) { return "string" == typeof t ? t : t(e, n, r); }(n, i, a))), u.code = e, u; } return function (e, t) { if ("function" != typeof t && null !== t)
            throw new TypeError("Super expression must either be null or a function"); e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), t && i(e, t); }(s, n), s; }(n); u[e] = s; }
        function l(e, t) { if (Array.isArray(e)) {
            var n = e.length;
            return e = e.map((function (e) { return String(e); })), n > 2 ? "one of ".concat(t, " ").concat(e.slice(0, n - 1).join(", "), ", or ") + e[n - 1] : 2 === n ? "one of ".concat(t, " ").concat(e[0], " or ").concat(e[1]) : "of ".concat(t, " ").concat(e[0]);
        } return "of ".concat(t, " ").concat(String(e)); }
        c("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError), c("ERR_INVALID_ARG_TYPE", (function (e, t, o) { var i, a, u, c, p; if (void 0 === s && (s = n(1696)), s("string" == typeof e, "'name' must be a string"), "string" == typeof t && (a = "not ", t.substr(0, a.length) === a) ? (i = "must not be", t = t.replace(/^not /, "")) : i = "must be", function (e, t, n) { return (void 0 === n || n > e.length) && (n = e.length), e.substring(n - t.length, n) === t; }(e, " argument"))
            u = "The ".concat(e, " ").concat(i, " ").concat(l(t, "type"));
        else {
            var f = ("number" != typeof p && (p = 0), p + ".".length > (c = e).length || -1 === c.indexOf(".", p) ? "argument" : "property");
            u = 'The "'.concat(e, '" ').concat(f, " ").concat(i, " ").concat(l(t, "type"));
        } return u + ". Received type ".concat(r(o)); }), TypeError), c("ERR_INVALID_ARG_VALUE", (function (e, t) { var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "is invalid"; void 0 === a && (a = n(3335)); var o = a.inspect(t); return o.length > 128 && (o = "".concat(o.slice(0, 128), "...")), "The argument '".concat(e, "' ").concat(r, ". Received ").concat(o); }), TypeError, RangeError), c("ERR_INVALID_RETURN_VALUE", (function (e, t, n) { var o; return o = n && n.constructor && n.constructor.name ? "instance of ".concat(n.constructor.name) : "type ".concat(r(n)), "Expected ".concat(e, ' to be returned from the "').concat(t, '"') + " function but got ".concat(o, "."); }), TypeError), c("ERR_MISSING_ARGS", (function () { for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
            t[r] = arguments[r]; void 0 === s && (s = n(1696)), s(t.length > 0, "At least one arg needs to be specified"); var o = "The ", i = t.length; switch (t = t.map((function (e) { return '"'.concat(e, '"'); })), i) {
            case 1:
                o += "".concat(t[0], " argument");
                break;
            case 2:
                o += "".concat(t[0], " and ").concat(t[1], " arguments");
                break;
            default: o += t.slice(0, i - 1).join(", "), o += ", and ".concat(t[i - 1], " arguments");
        } return "".concat(o, " must be specified"); }), TypeError), e.exports.codes = u;
    }, 6796: (e, t, n) => {
        "use strict";
        function r(e, t) { return function (e) { if (Array.isArray(e))
            return e; }(e) || function (e, t) { var n = [], r = !0, o = !1, i = void 0; try {
            for (var s, a = e[Symbol.iterator](); !(r = (s = a.next()).done) && (n.push(s.value), !t || n.length !== t); r = !0)
                ;
        }
        catch (e) {
            o = !0, i = e;
        }
        finally {
            try {
                r || null == a.return || a.return();
            }
            finally {
                if (o)
                    throw i;
            }
        } return n; }(e, t) || function () { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }(); }
        function o(e) { return o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e; } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e; }, o(e); }
        var i = void 0 !== /a/g.flags, s = function (e) { var t = []; return e.forEach((function (e) { return t.push(e); })), t; }, a = function (e) { var t = []; return e.forEach((function (e, n) { return t.push([n, e]); })), t; }, u = Object.is ? Object.is : n(4679), c = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function () { return []; }, l = Number.isNaN ? Number.isNaN : n(4782);
        function p(e) { return e.call.bind(e); }
        var f = p(Object.prototype.hasOwnProperty), d = p(Object.prototype.propertyIsEnumerable), h = p(Object.prototype.toString), m = n(3335).types, g = m.isAnyArrayBuffer, y = m.isArrayBufferView, v = m.isDate, b = m.isMap, D = m.isRegExp, E = m.isSet, C = m.isNativeError, w = m.isBoxedPrimitive, A = m.isNumberObject, S = m.isStringObject, x = m.isBooleanObject, T = m.isBigIntObject, k = m.isSymbolObject, F = m.isFloat32Array, O = m.isFloat64Array;
        function _(e) { if (0 === e.length || e.length > 10)
            return !0; for (var t = 0; t < e.length; t++) {
            var n = e.charCodeAt(t);
            if (n < 48 || n > 57)
                return !0;
        } return 10 === e.length && e >= Math.pow(2, 32); }
        function N(e) { return Object.keys(e).filter(_).concat(c(e).filter(Object.prototype.propertyIsEnumerable.bind(e))); }
        function P(e, t) { if (e === t)
            return 0; for (var n = e.length, r = t.length, o = 0, i = Math.min(n, r); o < i; ++o)
            if (e[o] !== t[o]) {
                n = e[o], r = t[o];
                break;
            } return n < r ? -1 : r < n ? 1 : 0; }
        function M(e, t, n, r) { if (e === t)
            return 0 !== e || !n || u(e, t); if (n) {
            if ("object" !== o(e))
                return "number" == typeof e && l(e) && l(t);
            if ("object" !== o(t) || null === e || null === t)
                return !1;
            if (Object.getPrototypeOf(e) !== Object.getPrototypeOf(t))
                return !1;
        }
        else {
            if (null === e || "object" !== o(e))
                return (null === t || "object" !== o(t)) && e == t;
            if (null === t || "object" !== o(t))
                return !1;
        } var s, a, c, p, f = h(e); if (f !== h(t))
            return !1; if (Array.isArray(e)) {
            if (e.length !== t.length)
                return !1;
            var d = N(e), m = N(t);
            return d.length === m.length && I(e, t, n, r, 1, d);
        } if ("[object Object]" === f && (!b(e) && b(t) || !E(e) && E(t)))
            return !1; if (v(e)) {
            if (!v(t) || Date.prototype.getTime.call(e) !== Date.prototype.getTime.call(t))
                return !1;
        }
        else if (D(e)) {
            if (!D(t) || (c = e, p = t, !(i ? c.source === p.source && c.flags === p.flags : RegExp.prototype.toString.call(c) === RegExp.prototype.toString.call(p))))
                return !1;
        }
        else if (C(e) || e instanceof Error) {
            if (e.message !== t.message || e.name !== t.name)
                return !1;
        }
        else {
            if (y(e)) {
                if (n || !F(e) && !O(e)) {
                    if (!function (e, t) { return e.byteLength === t.byteLength && 0 === P(new Uint8Array(e.buffer, e.byteOffset, e.byteLength), new Uint8Array(t.buffer, t.byteOffset, t.byteLength)); }(e, t))
                        return !1;
                }
                else if (!function (e, t) { if (e.byteLength !== t.byteLength)
                    return !1; for (var n = 0; n < e.byteLength; n++)
                    if (e[n] !== t[n])
                        return !1; return !0; }(e, t))
                    return !1;
                var _ = N(e), M = N(t);
                return _.length === M.length && I(e, t, n, r, 0, _);
            }
            if (E(e))
                return !(!E(t) || e.size !== t.size) && I(e, t, n, r, 2);
            if (b(e))
                return !(!b(t) || e.size !== t.size) && I(e, t, n, r, 3);
            if (g(e)) {
                if (a = t, (s = e).byteLength !== a.byteLength || 0 !== P(new Uint8Array(s), new Uint8Array(a)))
                    return !1;
            }
            else if (w(e) && !function (e, t) { return A(e) ? A(t) && u(Number.prototype.valueOf.call(e), Number.prototype.valueOf.call(t)) : S(e) ? S(t) && String.prototype.valueOf.call(e) === String.prototype.valueOf.call(t) : x(e) ? x(t) && Boolean.prototype.valueOf.call(e) === Boolean.prototype.valueOf.call(t) : T(e) ? T(t) && BigInt.prototype.valueOf.call(e) === BigInt.prototype.valueOf.call(t) : k(t) && Symbol.prototype.valueOf.call(e) === Symbol.prototype.valueOf.call(t); }(e, t))
                return !1;
        } return I(e, t, n, r, 0); }
        function R(e, t) { return t.filter((function (t) { return d(e, t); })); }
        function I(e, t, n, r, o, i) { if (5 === arguments.length) {
            i = Object.keys(e);
            var s = Object.keys(t);
            if (i.length !== s.length)
                return !1;
        } for (var a = 0; a < i.length; a++)
            if (!f(t, i[a]))
                return !1; if (n && 5 === arguments.length) {
            var u = c(e);
            if (0 !== u.length) {
                var l = 0;
                for (a = 0; a < u.length; a++) {
                    var p = u[a];
                    if (d(e, p)) {
                        if (!d(t, p))
                            return !1;
                        i.push(p), l++;
                    }
                    else if (d(t, p))
                        return !1;
                }
                var h = c(t);
                if (u.length !== h.length && R(t, h).length !== l)
                    return !1;
            }
            else {
                var m = c(t);
                if (0 !== m.length && 0 !== R(t, m).length)
                    return !1;
            }
        } if (0 === i.length && (0 === o || 1 === o && 0 === e.length || 0 === e.size))
            return !0; if (void 0 === r)
            r = { val1: new Map, val2: new Map, position: 0 };
        else {
            var g = r.val1.get(e);
            if (void 0 !== g) {
                var y = r.val2.get(t);
                if (void 0 !== y)
                    return g === y;
            }
            r.position++;
        } r.val1.set(e, r.position), r.val2.set(t, r.position); var v = U(e, t, n, i, r, o); return r.val1.delete(e), r.val2.delete(t), v; }
        function j(e, t, n, r) { for (var o = s(e), i = 0; i < o.length; i++) {
            var a = o[i];
            if (M(t, a, n, r))
                return e.delete(a), !0;
        } return !1; }
        function B(e) { switch (o(e)) {
            case "undefined": return null;
            case "object": return;
            case "symbol": return !1;
            case "string": e = +e;
            case "number": if (l(e))
                return !1;
        } return !0; }
        function L(e, t, n) { var r = B(n); return null != r ? r : t.has(r) && !e.has(r); }
        function q(e, t, n, r, o) { var i = B(n); if (null != i)
            return i; var s = t.get(i); return !(void 0 === s && !t.has(i) || !M(r, s, !1, o)) && !e.has(i) && M(r, s, !1, o); }
        function $(e, t, n, r, o, i) { for (var a = s(e), u = 0; u < a.length; u++) {
            var c = a[u];
            if (M(n, c, o, i) && M(r, t.get(c), o, i))
                return e.delete(c), !0;
        } return !1; }
        function U(e, t, n, i, u, c) { var l = 0; if (2 === c) {
            if (!function (e, t, n, r) { for (var i = null, a = s(e), u = 0; u < a.length; u++) {
                var c = a[u];
                if ("object" === o(c) && null !== c)
                    null === i && (i = new Set), i.add(c);
                else if (!t.has(c)) {
                    if (n)
                        return !1;
                    if (!L(e, t, c))
                        return !1;
                    null === i && (i = new Set), i.add(c);
                }
            } if (null !== i) {
                for (var l = s(t), p = 0; p < l.length; p++) {
                    var f = l[p];
                    if ("object" === o(f) && null !== f) {
                        if (!j(i, f, n, r))
                            return !1;
                    }
                    else if (!n && !e.has(f) && !j(i, f, n, r))
                        return !1;
                }
                return 0 === i.size;
            } return !0; }(e, t, n, u))
                return !1;
        }
        else if (3 === c) {
            if (!function (e, t, n, i) { for (var s = null, u = a(e), c = 0; c < u.length; c++) {
                var l = r(u[c], 2), p = l[0], f = l[1];
                if ("object" === o(p) && null !== p)
                    null === s && (s = new Set), s.add(p);
                else {
                    var d = t.get(p);
                    if (void 0 === d && !t.has(p) || !M(f, d, n, i)) {
                        if (n)
                            return !1;
                        if (!q(e, t, p, f, i))
                            return !1;
                        null === s && (s = new Set), s.add(p);
                    }
                }
            } if (null !== s) {
                for (var h = a(t), m = 0; m < h.length; m++) {
                    var g = r(h[m], 2), y = (p = g[0], g[1]);
                    if ("object" === o(p) && null !== p) {
                        if (!$(s, e, p, y, n, i))
                            return !1;
                    }
                    else if (!(n || e.has(p) && M(e.get(p), y, !1, i) || $(s, e, p, y, !1, i)))
                        return !1;
                }
                return 0 === s.size;
            } return !0; }(e, t, n, u))
                return !1;
        }
        else if (1 === c)
            for (; l < e.length; l++) {
                if (!f(e, l)) {
                    if (f(t, l))
                        return !1;
                    for (var p = Object.keys(e); l < p.length; l++) {
                        var d = p[l];
                        if (!f(t, d) || !M(e[d], t[d], n, u))
                            return !1;
                    }
                    return p.length === Object.keys(t).length;
                }
                if (!f(t, l) || !M(e[l], t[l], n, u))
                    return !1;
            } for (l = 0; l < i.length; l++) {
            var h = i[l];
            if (!M(e[h], t[h], n, u))
                return !1;
        } return !0; }
        e.exports = { isDeepEqual: function (e, t) { return M(e, t, !1); }, isDeepStrictEqual: function (e, t) { return M(e, t, !0); } };
    }, 5766: (e, t) => {
        "use strict";
        t.byteLength = function (e) { var t = u(e), n = t[0], r = t[1]; return 3 * (n + r) / 4 - r; }, t.toByteArray = function (e) { var t, n, i = u(e), s = i[0], a = i[1], c = new o(function (e, t, n) { return 3 * (t + n) / 4 - n; }(0, s, a)), l = 0, p = a > 0 ? s - 4 : s; for (n = 0; n < p; n += 4)
            t = r[e.charCodeAt(n)] << 18 | r[e.charCodeAt(n + 1)] << 12 | r[e.charCodeAt(n + 2)] << 6 | r[e.charCodeAt(n + 3)], c[l++] = t >> 16 & 255, c[l++] = t >> 8 & 255, c[l++] = 255 & t; return 2 === a && (t = r[e.charCodeAt(n)] << 2 | r[e.charCodeAt(n + 1)] >> 4, c[l++] = 255 & t), 1 === a && (t = r[e.charCodeAt(n)] << 10 | r[e.charCodeAt(n + 1)] << 4 | r[e.charCodeAt(n + 2)] >> 2, c[l++] = t >> 8 & 255, c[l++] = 255 & t), c; }, t.fromByteArray = function (e) { for (var t, r = e.length, o = r % 3, i = [], s = 16383, a = 0, u = r - o; a < u; a += s)
            i.push(c(e, a, a + s > u ? u : a + s)); return 1 === o ? (t = e[r - 1], i.push(n[t >> 2] + n[t << 4 & 63] + "==")) : 2 === o && (t = (e[r - 2] << 8) + e[r - 1], i.push(n[t >> 10] + n[t >> 4 & 63] + n[t << 2 & 63] + "=")), i.join(""); };
        for (var n = [], r = [], o = "undefined" != typeof Uint8Array ? Uint8Array : Array, i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s = 0, a = i.length; s < a; ++s)
            n[s] = i[s], r[i.charCodeAt(s)] = s;
        function u(e) { var t = e.length; if (t % 4 > 0)
            throw new Error("Invalid string. Length must be a multiple of 4"); var n = e.indexOf("="); return -1 === n && (n = t), [n, n === t ? 0 : 4 - n % 4]; }
        function c(e, t, r) { for (var o, i, s = [], a = t; a < r; a += 3)
            o = (e[a] << 16 & 16711680) + (e[a + 1] << 8 & 65280) + (255 & e[a + 2]), s.push(n[(i = o) >> 18 & 63] + n[i >> 12 & 63] + n[i >> 6 & 63] + n[63 & i]); return s.join(""); }
        r["-".charCodeAt(0)] = 62, r["_".charCodeAt(0)] = 63;
    }, 8834: (e, t, n) => {
        "use strict";
        var r = n(3716);
        const o = n(5766), i = n(2333), s = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
        t.lW = c, t.h2 = 50;
        const a = 2147483647;
        function u(e) { if (e > a)
            throw new RangeError('The value "' + e + '" is invalid for option "size"'); const t = new Uint8Array(e); return Object.setPrototypeOf(t, c.prototype), t; }
        function c(e, t, n) { if ("number" == typeof e) {
            if ("string" == typeof t)
                throw new TypeError('The "string" argument must be of type string. Received type number');
            return f(e);
        } return l(e, t, n); }
        function l(e, t, n) { if ("string" == typeof e)
            return function (e, t) { if ("string" == typeof t && "" !== t || (t = "utf8"), !c.isEncoding(t))
                throw new TypeError("Unknown encoding: " + t); const n = 0 | g(e, t); let r = u(n); const o = r.write(e, t); return o !== n && (r = r.slice(0, o)), r; }(e, t); if (ArrayBuffer.isView(e))
            return function (e) { if (G(e, Uint8Array)) {
                const t = new Uint8Array(e);
                return h(t.buffer, t.byteOffset, t.byteLength);
            } return d(e); }(e); if (null == e)
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e); if (G(e, ArrayBuffer) || e && G(e.buffer, ArrayBuffer))
            return h(e, t, n); if ("undefined" != typeof SharedArrayBuffer && (G(e, SharedArrayBuffer) || e && G(e.buffer, SharedArrayBuffer)))
            return h(e, t, n); if ("number" == typeof e)
            throw new TypeError('The "value" argument must not be of type number. Received type number'); const r = e.valueOf && e.valueOf(); if (null != r && r !== e)
            return c.from(r, t, n); const o = function (e) { if (c.isBuffer(e)) {
            const t = 0 | m(e.length), n = u(t);
            return 0 === n.length || e.copy(n, 0, 0, t), n;
        } return void 0 !== e.length ? "number" != typeof e.length || X(e.length) ? u(0) : d(e) : "Buffer" === e.type && Array.isArray(e.data) ? d(e.data) : void 0; }(e); if (o)
            return o; if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof e[Symbol.toPrimitive])
            return c.from(e[Symbol.toPrimitive]("string"), t, n); throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e); }
        function p(e) { if ("number" != typeof e)
            throw new TypeError('"size" argument must be of type number'); if (e < 0)
            throw new RangeError('The value "' + e + '" is invalid for option "size"'); }
        function f(e) { return p(e), u(e < 0 ? 0 : 0 | m(e)); }
        function d(e) { const t = e.length < 0 ? 0 : 0 | m(e.length), n = u(t); for (let r = 0; r < t; r += 1)
            n[r] = 255 & e[r]; return n; }
        function h(e, t, n) { if (t < 0 || e.byteLength < t)
            throw new RangeError('"offset" is outside of buffer bounds'); if (e.byteLength < t + (n || 0))
            throw new RangeError('"length" is outside of buffer bounds'); let r; return r = void 0 === t && void 0 === n ? new Uint8Array(e) : void 0 === n ? new Uint8Array(e, t) : new Uint8Array(e, t, n), Object.setPrototypeOf(r, c.prototype), r; }
        function m(e) { if (e >= a)
            throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + a.toString(16) + " bytes"); return 0 | e; }
        function g(e, t) { if (c.isBuffer(e))
            return e.length; if (ArrayBuffer.isView(e) || G(e, ArrayBuffer))
            return e.byteLength; if ("string" != typeof e)
            throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e); const n = e.length, r = arguments.length > 2 && !0 === arguments[2]; if (!r && 0 === n)
            return 0; let o = !1; for (;;)
            switch (t) {
                case "ascii":
                case "latin1":
                case "binary": return n;
                case "utf8":
                case "utf-8": return H(e).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le": return 2 * n;
                case "hex": return n >>> 1;
                case "base64": return Y(e).length;
                default:
                    if (o)
                        return r ? -1 : H(e).length;
                    t = ("" + t).toLowerCase(), o = !0;
            } }
        function y(e, t, n) { let r = !1; if ((void 0 === t || t < 0) && (t = 0), t > this.length)
            return ""; if ((void 0 === n || n > this.length) && (n = this.length), n <= 0)
            return ""; if ((n >>>= 0) <= (t >>>= 0))
            return ""; for (e || (e = "utf8");;)
            switch (e) {
                case "hex": return _(this, t, n);
                case "utf8":
                case "utf-8": return T(this, t, n);
                case "ascii": return F(this, t, n);
                case "latin1":
                case "binary": return O(this, t, n);
                case "base64": return x(this, t, n);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le": return N(this, t, n);
                default:
                    if (r)
                        throw new TypeError("Unknown encoding: " + e);
                    e = (e + "").toLowerCase(), r = !0;
            } }
        function v(e, t, n) { const r = e[t]; e[t] = e[n], e[n] = r; }
        function b(e, t, n, r, o) { if (0 === e.length)
            return -1; if ("string" == typeof n ? (r = n, n = 0) : n > 2147483647 ? n = 2147483647 : n < -2147483648 && (n = -2147483648), X(n = +n) && (n = o ? 0 : e.length - 1), n < 0 && (n = e.length + n), n >= e.length) {
            if (o)
                return -1;
            n = e.length - 1;
        }
        else if (n < 0) {
            if (!o)
                return -1;
            n = 0;
        } if ("string" == typeof t && (t = c.from(t, r)), c.isBuffer(t))
            return 0 === t.length ? -1 : D(e, t, n, r, o); if ("number" == typeof t)
            return t &= 255, "function" == typeof Uint8Array.prototype.indexOf ? o ? Uint8Array.prototype.indexOf.call(e, t, n) : Uint8Array.prototype.lastIndexOf.call(e, t, n) : D(e, [t], n, r, o); throw new TypeError("val must be string, number or Buffer"); }
        function D(e, t, n, r, o) { let i, s = 1, a = e.length, u = t.length; if (void 0 !== r && ("ucs2" === (r = String(r).toLowerCase()) || "ucs-2" === r || "utf16le" === r || "utf-16le" === r)) {
            if (e.length < 2 || t.length < 2)
                return -1;
            s = 2, a /= 2, u /= 2, n /= 2;
        } function c(e, t) { return 1 === s ? e[t] : e.readUInt16BE(t * s); } if (o) {
            let r = -1;
            for (i = n; i < a; i++)
                if (c(e, i) === c(t, -1 === r ? 0 : i - r)) {
                    if (-1 === r && (r = i), i - r + 1 === u)
                        return r * s;
                }
                else
                    -1 !== r && (i -= i - r), r = -1;
        }
        else
            for (n + u > a && (n = a - u), i = n; i >= 0; i--) {
                let n = !0;
                for (let r = 0; r < u; r++)
                    if (c(e, i + r) !== c(t, r)) {
                        n = !1;
                        break;
                    }
                if (n)
                    return i;
            } return -1; }
        function E(e, t, n, r) { n = Number(n) || 0; const o = e.length - n; r ? (r = Number(r)) > o && (r = o) : r = o; const i = t.length; let s; for (r > i / 2 && (r = i / 2), s = 0; s < r; ++s) {
            const r = parseInt(t.substr(2 * s, 2), 16);
            if (X(r))
                return s;
            e[n + s] = r;
        } return s; }
        function C(e, t, n, r) { return J(H(t, e.length - n), e, n, r); }
        function w(e, t, n, r) { return J(function (e) { const t = []; for (let n = 0; n < e.length; ++n)
            t.push(255 & e.charCodeAt(n)); return t; }(t), e, n, r); }
        function A(e, t, n, r) { return J(Y(t), e, n, r); }
        function S(e, t, n, r) { return J(function (e, t) { let n, r, o; const i = []; for (let s = 0; s < e.length && !((t -= 2) < 0); ++s)
            n = e.charCodeAt(s), r = n >> 8, o = n % 256, i.push(o), i.push(r); return i; }(t, e.length - n), e, n, r); }
        function x(e, t, n) { return 0 === t && n === e.length ? o.fromByteArray(e) : o.fromByteArray(e.slice(t, n)); }
        function T(e, t, n) { n = Math.min(e.length, n); const r = []; let o = t; for (; o < n;) {
            const t = e[o];
            let i = null, s = t > 239 ? 4 : t > 223 ? 3 : t > 191 ? 2 : 1;
            if (o + s <= n) {
                let n, r, a, u;
                switch (s) {
                    case 1:
                        t < 128 && (i = t);
                        break;
                    case 2:
                        n = e[o + 1], 128 == (192 & n) && (u = (31 & t) << 6 | 63 & n, u > 127 && (i = u));
                        break;
                    case 3:
                        n = e[o + 1], r = e[o + 2], 128 == (192 & n) && 128 == (192 & r) && (u = (15 & t) << 12 | (63 & n) << 6 | 63 & r, u > 2047 && (u < 55296 || u > 57343) && (i = u));
                        break;
                    case 4: n = e[o + 1], r = e[o + 2], a = e[o + 3], 128 == (192 & n) && 128 == (192 & r) && 128 == (192 & a) && (u = (15 & t) << 18 | (63 & n) << 12 | (63 & r) << 6 | 63 & a, u > 65535 && u < 1114112 && (i = u));
                }
            }
            null === i ? (i = 65533, s = 1) : i > 65535 && (i -= 65536, r.push(i >>> 10 & 1023 | 55296), i = 56320 | 1023 & i), r.push(i), o += s;
        } return function (e) { const t = e.length; if (t <= k)
            return String.fromCharCode.apply(String, e); let n = "", r = 0; for (; r < t;)
            n += String.fromCharCode.apply(String, e.slice(r, r += k)); return n; }(r); }
        c.TYPED_ARRAY_SUPPORT = function () { try {
            const e = new Uint8Array(1), t = { foo: function () { return 42; } };
            return Object.setPrototypeOf(t, Uint8Array.prototype), Object.setPrototypeOf(e, t), 42 === e.foo();
        }
        catch (e) {
            return !1;
        } }(), c.TYPED_ARRAY_SUPPORT || void 0 === r || "function" != typeof r.error || r.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(c.prototype, "parent", { enumerable: !0, get: function () { if (c.isBuffer(this))
                return this.buffer; } }), Object.defineProperty(c.prototype, "offset", { enumerable: !0, get: function () { if (c.isBuffer(this))
                return this.byteOffset; } }), c.poolSize = 8192, c.from = function (e, t, n) { return l(e, t, n); }, Object.setPrototypeOf(c.prototype, Uint8Array.prototype), Object.setPrototypeOf(c, Uint8Array), c.alloc = function (e, t, n) { return function (e, t, n) { return p(e), e <= 0 ? u(e) : void 0 !== t ? "string" == typeof n ? u(e).fill(t, n) : u(e).fill(t) : u(e); }(e, t, n); }, c.allocUnsafe = function (e) { return f(e); }, c.allocUnsafeSlow = function (e) { return f(e); }, c.isBuffer = function (e) { return null != e && !0 === e._isBuffer && e !== c.prototype; }, c.compare = function (e, t) { if (G(e, Uint8Array) && (e = c.from(e, e.offset, e.byteLength)), G(t, Uint8Array) && (t = c.from(t, t.offset, t.byteLength)), !c.isBuffer(e) || !c.isBuffer(t))
            throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'); if (e === t)
            return 0; let n = e.length, r = t.length; for (let o = 0, i = Math.min(n, r); o < i; ++o)
            if (e[o] !== t[o]) {
                n = e[o], r = t[o];
                break;
            } return n < r ? -1 : r < n ? 1 : 0; }, c.isEncoding = function (e) { switch (String(e).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le": return !0;
            default: return !1;
        } }, c.concat = function (e, t) { if (!Array.isArray(e))
            throw new TypeError('"list" argument must be an Array of Buffers'); if (0 === e.length)
            return c.alloc(0); let n; if (void 0 === t)
            for (t = 0, n = 0; n < e.length; ++n)
                t += e[n].length; const r = c.allocUnsafe(t); let o = 0; for (n = 0; n < e.length; ++n) {
            let t = e[n];
            if (G(t, Uint8Array))
                o + t.length > r.length ? (c.isBuffer(t) || (t = c.from(t)), t.copy(r, o)) : Uint8Array.prototype.set.call(r, t, o);
            else {
                if (!c.isBuffer(t))
                    throw new TypeError('"list" argument must be an Array of Buffers');
                t.copy(r, o);
            }
            o += t.length;
        } return r; }, c.byteLength = g, c.prototype._isBuffer = !0, c.prototype.swap16 = function () { const e = this.length; if (e % 2 != 0)
            throw new RangeError("Buffer size must be a multiple of 16-bits"); for (let t = 0; t < e; t += 2)
            v(this, t, t + 1); return this; }, c.prototype.swap32 = function () { const e = this.length; if (e % 4 != 0)
            throw new RangeError("Buffer size must be a multiple of 32-bits"); for (let t = 0; t < e; t += 4)
            v(this, t, t + 3), v(this, t + 1, t + 2); return this; }, c.prototype.swap64 = function () { const e = this.length; if (e % 8 != 0)
            throw new RangeError("Buffer size must be a multiple of 64-bits"); for (let t = 0; t < e; t += 8)
            v(this, t, t + 7), v(this, t + 1, t + 6), v(this, t + 2, t + 5), v(this, t + 3, t + 4); return this; }, c.prototype.toString = function () { const e = this.length; return 0 === e ? "" : 0 === arguments.length ? T(this, 0, e) : y.apply(this, arguments); }, c.prototype.toLocaleString = c.prototype.toString, c.prototype.equals = function (e) { if (!c.isBuffer(e))
            throw new TypeError("Argument must be a Buffer"); return this === e || 0 === c.compare(this, e); }, c.prototype.inspect = function () { let e = ""; const n = t.h2; return e = this.toString("hex", 0, n).replace(/(.{2})/g, "$1 ").trim(), this.length > n && (e += " ... "), "<Buffer " + e + ">"; }, s && (c.prototype[s] = c.prototype.inspect), c.prototype.compare = function (e, t, n, r, o) { if (G(e, Uint8Array) && (e = c.from(e, e.offset, e.byteLength)), !c.isBuffer(e))
            throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e); if (void 0 === t && (t = 0), void 0 === n && (n = e ? e.length : 0), void 0 === r && (r = 0), void 0 === o && (o = this.length), t < 0 || n > e.length || r < 0 || o > this.length)
            throw new RangeError("out of range index"); if (r >= o && t >= n)
            return 0; if (r >= o)
            return -1; if (t >= n)
            return 1; if (this === e)
            return 0; let i = (o >>>= 0) - (r >>>= 0), s = (n >>>= 0) - (t >>>= 0); const a = Math.min(i, s), u = this.slice(r, o), l = e.slice(t, n); for (let e = 0; e < a; ++e)
            if (u[e] !== l[e]) {
                i = u[e], s = l[e];
                break;
            } return i < s ? -1 : s < i ? 1 : 0; }, c.prototype.includes = function (e, t, n) { return -1 !== this.indexOf(e, t, n); }, c.prototype.indexOf = function (e, t, n) { return b(this, e, t, n, !0); }, c.prototype.lastIndexOf = function (e, t, n) { return b(this, e, t, n, !1); }, c.prototype.write = function (e, t, n, r) { if (void 0 === t)
            r = "utf8", n = this.length, t = 0;
        else if (void 0 === n && "string" == typeof t)
            r = t, n = this.length, t = 0;
        else {
            if (!isFinite(t))
                throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            t >>>= 0, isFinite(n) ? (n >>>= 0, void 0 === r && (r = "utf8")) : (r = n, n = void 0);
        } const o = this.length - t; if ((void 0 === n || n > o) && (n = o), e.length > 0 && (n < 0 || t < 0) || t > this.length)
            throw new RangeError("Attempt to write outside buffer bounds"); r || (r = "utf8"); let i = !1; for (;;)
            switch (r) {
                case "hex": return E(this, e, t, n);
                case "utf8":
                case "utf-8": return C(this, e, t, n);
                case "ascii":
                case "latin1":
                case "binary": return w(this, e, t, n);
                case "base64": return A(this, e, t, n);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le": return S(this, e, t, n);
                default:
                    if (i)
                        throw new TypeError("Unknown encoding: " + r);
                    r = ("" + r).toLowerCase(), i = !0;
            } }, c.prototype.toJSON = function () { return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) }; };
        const k = 4096;
        function F(e, t, n) { let r = ""; n = Math.min(e.length, n); for (let o = t; o < n; ++o)
            r += String.fromCharCode(127 & e[o]); return r; }
        function O(e, t, n) { let r = ""; n = Math.min(e.length, n); for (let o = t; o < n; ++o)
            r += String.fromCharCode(e[o]); return r; }
        function _(e, t, n) { const r = e.length; (!t || t < 0) && (t = 0), (!n || n < 0 || n > r) && (n = r); let o = ""; for (let r = t; r < n; ++r)
            o += Q[e[r]]; return o; }
        function N(e, t, n) { const r = e.slice(t, n); let o = ""; for (let e = 0; e < r.length - 1; e += 2)
            o += String.fromCharCode(r[e] + 256 * r[e + 1]); return o; }
        function P(e, t, n) { if (e % 1 != 0 || e < 0)
            throw new RangeError("offset is not uint"); if (e + t > n)
            throw new RangeError("Trying to access beyond buffer length"); }
        function M(e, t, n, r, o, i) { if (!c.isBuffer(e))
            throw new TypeError('"buffer" argument must be a Buffer instance'); if (t > o || t < i)
            throw new RangeError('"value" argument is out of bounds'); if (n + r > e.length)
            throw new RangeError("Index out of range"); }
        function R(e, t, n, r, o) { V(t, r, o, e, n, 7); let i = Number(t & BigInt(4294967295)); e[n++] = i, i >>= 8, e[n++] = i, i >>= 8, e[n++] = i, i >>= 8, e[n++] = i; let s = Number(t >> BigInt(32) & BigInt(4294967295)); return e[n++] = s, s >>= 8, e[n++] = s, s >>= 8, e[n++] = s, s >>= 8, e[n++] = s, n; }
        function I(e, t, n, r, o) { V(t, r, o, e, n, 7); let i = Number(t & BigInt(4294967295)); e[n + 7] = i, i >>= 8, e[n + 6] = i, i >>= 8, e[n + 5] = i, i >>= 8, e[n + 4] = i; let s = Number(t >> BigInt(32) & BigInt(4294967295)); return e[n + 3] = s, s >>= 8, e[n + 2] = s, s >>= 8, e[n + 1] = s, s >>= 8, e[n] = s, n + 8; }
        function j(e, t, n, r, o, i) { if (n + r > e.length)
            throw new RangeError("Index out of range"); if (n < 0)
            throw new RangeError("Index out of range"); }
        function B(e, t, n, r, o) { return t = +t, n >>>= 0, o || j(e, 0, n, 4), i.write(e, t, n, r, 23, 4), n + 4; }
        function L(e, t, n, r, o) { return t = +t, n >>>= 0, o || j(e, 0, n, 8), i.write(e, t, n, r, 52, 8), n + 8; }
        c.prototype.slice = function (e, t) { const n = this.length; (e = ~~e) < 0 ? (e += n) < 0 && (e = 0) : e > n && (e = n), (t = void 0 === t ? n : ~~t) < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n), t < e && (t = e); const r = this.subarray(e, t); return Object.setPrototypeOf(r, c.prototype), r; }, c.prototype.readUintLE = c.prototype.readUIntLE = function (e, t, n) { e >>>= 0, t >>>= 0, n || P(e, t, this.length); let r = this[e], o = 1, i = 0; for (; ++i < t && (o *= 256);)
            r += this[e + i] * o; return r; }, c.prototype.readUintBE = c.prototype.readUIntBE = function (e, t, n) { e >>>= 0, t >>>= 0, n || P(e, t, this.length); let r = this[e + --t], o = 1; for (; t > 0 && (o *= 256);)
            r += this[e + --t] * o; return r; }, c.prototype.readUint8 = c.prototype.readUInt8 = function (e, t) { return e >>>= 0, t || P(e, 1, this.length), this[e]; }, c.prototype.readUint16LE = c.prototype.readUInt16LE = function (e, t) { return e >>>= 0, t || P(e, 2, this.length), this[e] | this[e + 1] << 8; }, c.prototype.readUint16BE = c.prototype.readUInt16BE = function (e, t) { return e >>>= 0, t || P(e, 2, this.length), this[e] << 8 | this[e + 1]; }, c.prototype.readUint32LE = c.prototype.readUInt32LE = function (e, t) { return e >>>= 0, t || P(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + 16777216 * this[e + 3]; }, c.prototype.readUint32BE = c.prototype.readUInt32BE = function (e, t) { return e >>>= 0, t || P(e, 4, this.length), 16777216 * this[e] + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]); }, c.prototype.readBigUInt64LE = Z((function (e) { W(e >>>= 0, "offset"); const t = this[e], n = this[e + 7]; void 0 !== t && void 0 !== n || K(e, this.length - 8); const r = t + 256 * this[++e] + 65536 * this[++e] + this[++e] * 2 ** 24, o = this[++e] + 256 * this[++e] + 65536 * this[++e] + n * 2 ** 24; return BigInt(r) + (BigInt(o) << BigInt(32)); })), c.prototype.readBigUInt64BE = Z((function (e) { W(e >>>= 0, "offset"); const t = this[e], n = this[e + 7]; void 0 !== t && void 0 !== n || K(e, this.length - 8); const r = t * 2 ** 24 + 65536 * this[++e] + 256 * this[++e] + this[++e], o = this[++e] * 2 ** 24 + 65536 * this[++e] + 256 * this[++e] + n; return (BigInt(r) << BigInt(32)) + BigInt(o); })), c.prototype.readIntLE = function (e, t, n) { e >>>= 0, t >>>= 0, n || P(e, t, this.length); let r = this[e], o = 1, i = 0; for (; ++i < t && (o *= 256);)
            r += this[e + i] * o; return o *= 128, r >= o && (r -= Math.pow(2, 8 * t)), r; }, c.prototype.readIntBE = function (e, t, n) { e >>>= 0, t >>>= 0, n || P(e, t, this.length); let r = t, o = 1, i = this[e + --r]; for (; r > 0 && (o *= 256);)
            i += this[e + --r] * o; return o *= 128, i >= o && (i -= Math.pow(2, 8 * t)), i; }, c.prototype.readInt8 = function (e, t) { return e >>>= 0, t || P(e, 1, this.length), 128 & this[e] ? -1 * (255 - this[e] + 1) : this[e]; }, c.prototype.readInt16LE = function (e, t) { e >>>= 0, t || P(e, 2, this.length); const n = this[e] | this[e + 1] << 8; return 32768 & n ? 4294901760 | n : n; }, c.prototype.readInt16BE = function (e, t) { e >>>= 0, t || P(e, 2, this.length); const n = this[e + 1] | this[e] << 8; return 32768 & n ? 4294901760 | n : n; }, c.prototype.readInt32LE = function (e, t) { return e >>>= 0, t || P(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24; }, c.prototype.readInt32BE = function (e, t) { return e >>>= 0, t || P(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]; }, c.prototype.readBigInt64LE = Z((function (e) { W(e >>>= 0, "offset"); const t = this[e], n = this[e + 7]; void 0 !== t && void 0 !== n || K(e, this.length - 8); const r = this[e + 4] + 256 * this[e + 5] + 65536 * this[e + 6] + (n << 24); return (BigInt(r) << BigInt(32)) + BigInt(t + 256 * this[++e] + 65536 * this[++e] + this[++e] * 2 ** 24); })), c.prototype.readBigInt64BE = Z((function (e) { W(e >>>= 0, "offset"); const t = this[e], n = this[e + 7]; void 0 !== t && void 0 !== n || K(e, this.length - 8); const r = (t << 24) + 65536 * this[++e] + 256 * this[++e] + this[++e]; return (BigInt(r) << BigInt(32)) + BigInt(this[++e] * 2 ** 24 + 65536 * this[++e] + 256 * this[++e] + n); })), c.prototype.readFloatLE = function (e, t) { return e >>>= 0, t || P(e, 4, this.length), i.read(this, e, !0, 23, 4); }, c.prototype.readFloatBE = function (e, t) { return e >>>= 0, t || P(e, 4, this.length), i.read(this, e, !1, 23, 4); }, c.prototype.readDoubleLE = function (e, t) { return e >>>= 0, t || P(e, 8, this.length), i.read(this, e, !0, 52, 8); }, c.prototype.readDoubleBE = function (e, t) { return e >>>= 0, t || P(e, 8, this.length), i.read(this, e, !1, 52, 8); }, c.prototype.writeUintLE = c.prototype.writeUIntLE = function (e, t, n, r) { e = +e, t >>>= 0, n >>>= 0, r || M(this, e, t, n, Math.pow(2, 8 * n) - 1, 0); let o = 1, i = 0; for (this[t] = 255 & e; ++i < n && (o *= 256);)
            this[t + i] = e / o & 255; return t + n; }, c.prototype.writeUintBE = c.prototype.writeUIntBE = function (e, t, n, r) { e = +e, t >>>= 0, n >>>= 0, r || M(this, e, t, n, Math.pow(2, 8 * n) - 1, 0); let o = n - 1, i = 1; for (this[t + o] = 255 & e; --o >= 0 && (i *= 256);)
            this[t + o] = e / i & 255; return t + n; }, c.prototype.writeUint8 = c.prototype.writeUInt8 = function (e, t, n) { return e = +e, t >>>= 0, n || M(this, e, t, 1, 255, 0), this[t] = 255 & e, t + 1; }, c.prototype.writeUint16LE = c.prototype.writeUInt16LE = function (e, t, n) { return e = +e, t >>>= 0, n || M(this, e, t, 2, 65535, 0), this[t] = 255 & e, this[t + 1] = e >>> 8, t + 2; }, c.prototype.writeUint16BE = c.prototype.writeUInt16BE = function (e, t, n) { return e = +e, t >>>= 0, n || M(this, e, t, 2, 65535, 0), this[t] = e >>> 8, this[t + 1] = 255 & e, t + 2; }, c.prototype.writeUint32LE = c.prototype.writeUInt32LE = function (e, t, n) { return e = +e, t >>>= 0, n || M(this, e, t, 4, 4294967295, 0), this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = 255 & e, t + 4; }, c.prototype.writeUint32BE = c.prototype.writeUInt32BE = function (e, t, n) { return e = +e, t >>>= 0, n || M(this, e, t, 4, 4294967295, 0), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e, t + 4; }, c.prototype.writeBigUInt64LE = Z((function (e, t = 0) { return R(this, e, t, BigInt(0), BigInt("0xffffffffffffffff")); })), c.prototype.writeBigUInt64BE = Z((function (e, t = 0) { return I(this, e, t, BigInt(0), BigInt("0xffffffffffffffff")); })), c.prototype.writeIntLE = function (e, t, n, r) { if (e = +e, t >>>= 0, !r) {
            const r = Math.pow(2, 8 * n - 1);
            M(this, e, t, n, r - 1, -r);
        } let o = 0, i = 1, s = 0; for (this[t] = 255 & e; ++o < n && (i *= 256);)
            e < 0 && 0 === s && 0 !== this[t + o - 1] && (s = 1), this[t + o] = (e / i >> 0) - s & 255; return t + n; }, c.prototype.writeIntBE = function (e, t, n, r) { if (e = +e, t >>>= 0, !r) {
            const r = Math.pow(2, 8 * n - 1);
            M(this, e, t, n, r - 1, -r);
        } let o = n - 1, i = 1, s = 0; for (this[t + o] = 255 & e; --o >= 0 && (i *= 256);)
            e < 0 && 0 === s && 0 !== this[t + o + 1] && (s = 1), this[t + o] = (e / i >> 0) - s & 255; return t + n; }, c.prototype.writeInt8 = function (e, t, n) { return e = +e, t >>>= 0, n || M(this, e, t, 1, 127, -128), e < 0 && (e = 255 + e + 1), this[t] = 255 & e, t + 1; }, c.prototype.writeInt16LE = function (e, t, n) { return e = +e, t >>>= 0, n || M(this, e, t, 2, 32767, -32768), this[t] = 255 & e, this[t + 1] = e >>> 8, t + 2; }, c.prototype.writeInt16BE = function (e, t, n) { return e = +e, t >>>= 0, n || M(this, e, t, 2, 32767, -32768), this[t] = e >>> 8, this[t + 1] = 255 & e, t + 2; }, c.prototype.writeInt32LE = function (e, t, n) { return e = +e, t >>>= 0, n || M(this, e, t, 4, 2147483647, -2147483648), this[t] = 255 & e, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24, t + 4; }, c.prototype.writeInt32BE = function (e, t, n) { return e = +e, t >>>= 0, n || M(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e, t + 4; }, c.prototype.writeBigInt64LE = Z((function (e, t = 0) { return R(this, e, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff")); })), c.prototype.writeBigInt64BE = Z((function (e, t = 0) { return I(this, e, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff")); })), c.prototype.writeFloatLE = function (e, t, n) { return B(this, e, t, !0, n); }, c.prototype.writeFloatBE = function (e, t, n) { return B(this, e, t, !1, n); }, c.prototype.writeDoubleLE = function (e, t, n) { return L(this, e, t, !0, n); }, c.prototype.writeDoubleBE = function (e, t, n) { return L(this, e, t, !1, n); }, c.prototype.copy = function (e, t, n, r) { if (!c.isBuffer(e))
            throw new TypeError("argument should be a Buffer"); if (n || (n = 0), r || 0 === r || (r = this.length), t >= e.length && (t = e.length), t || (t = 0), r > 0 && r < n && (r = n), r === n)
            return 0; if (0 === e.length || 0 === this.length)
            return 0; if (t < 0)
            throw new RangeError("targetStart out of bounds"); if (n < 0 || n >= this.length)
            throw new RangeError("Index out of range"); if (r < 0)
            throw new RangeError("sourceEnd out of bounds"); r > this.length && (r = this.length), e.length - t < r - n && (r = e.length - t + n); const o = r - n; return this === e && "function" == typeof Uint8Array.prototype.copyWithin ? this.copyWithin(t, n, r) : Uint8Array.prototype.set.call(e, this.subarray(n, r), t), o; }, c.prototype.fill = function (e, t, n, r) { if ("string" == typeof e) {
            if ("string" == typeof t ? (r = t, t = 0, n = this.length) : "string" == typeof n && (r = n, n = this.length), void 0 !== r && "string" != typeof r)
                throw new TypeError("encoding must be a string");
            if ("string" == typeof r && !c.isEncoding(r))
                throw new TypeError("Unknown encoding: " + r);
            if (1 === e.length) {
                const t = e.charCodeAt(0);
                ("utf8" === r && t < 128 || "latin1" === r) && (e = t);
            }
        }
        else
            "number" == typeof e ? e &= 255 : "boolean" == typeof e && (e = Number(e)); if (t < 0 || this.length < t || this.length < n)
            throw new RangeError("Out of range index"); if (n <= t)
            return this; let o; if (t >>>= 0, n = void 0 === n ? this.length : n >>> 0, e || (e = 0), "number" == typeof e)
            for (o = t; o < n; ++o)
                this[o] = e;
        else {
            const i = c.isBuffer(e) ? e : c.from(e, r), s = i.length;
            if (0 === s)
                throw new TypeError('The value "' + e + '" is invalid for argument "value"');
            for (o = 0; o < n - t; ++o)
                this[o + t] = i[o % s];
        } return this; };
        const q = {};
        function $(e, t, n) { q[e] = class extends n {
            constructor() { super(), Object.defineProperty(this, "message", { value: t.apply(this, arguments), writable: !0, configurable: !0 }), this.name = `${this.name} [${e}]`, this.stack, delete this.name; }
            get code() { return e; }
            set code(e) { Object.defineProperty(this, "code", { configurable: !0, enumerable: !0, value: e, writable: !0 }); }
            toString() { return `${this.name} [${e}]: ${this.message}`; }
        }; }
        function U(e) { let t = "", n = e.length; const r = "-" === e[0] ? 1 : 0; for (; n >= r + 4; n -= 3)
            t = `_${e.slice(n - 3, n)}${t}`; return `${e.slice(0, n)}${t}`; }
        function V(e, t, n, r, o, i) { if (e > n || e < t) {
            const r = "bigint" == typeof t ? "n" : "";
            let o;
            throw o = i > 3 ? 0 === t || t === BigInt(0) ? `>= 0${r} and < 2${r} ** ${8 * (i + 1)}${r}` : `>= -(2${r} ** ${8 * (i + 1) - 1}${r}) and < 2 ** ${8 * (i + 1) - 1}${r}` : `>= ${t}${r} and <= ${n}${r}`, new q.ERR_OUT_OF_RANGE("value", o, e);
        } !function (e, t, n) { W(t, "offset"), void 0 !== e[t] && void 0 !== e[t + n] || K(t, e.length - (n + 1)); }(r, o, i); }
        function W(e, t) { if ("number" != typeof e)
            throw new q.ERR_INVALID_ARG_TYPE(t, "number", e); }
        function K(e, t, n) { if (Math.floor(e) !== e)
            throw W(e, n), new q.ERR_OUT_OF_RANGE(n || "offset", "an integer", e); if (t < 0)
            throw new q.ERR_BUFFER_OUT_OF_BOUNDS; throw new q.ERR_OUT_OF_RANGE(n || "offset", `>= ${n ? 1 : 0} and <= ${t}`, e); }
        $("ERR_BUFFER_OUT_OF_BOUNDS", (function (e) { return e ? `${e} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"; }), RangeError), $("ERR_INVALID_ARG_TYPE", (function (e, t) { return `The "${e}" argument must be of type number. Received type ${typeof t}`; }), TypeError), $("ERR_OUT_OF_RANGE", (function (e, t, n) { let r = `The value of "${e}" is out of range.`, o = n; return Number.isInteger(n) && Math.abs(n) > 2 ** 32 ? o = U(String(n)) : "bigint" == typeof n && (o = String(n), (n > BigInt(2) ** BigInt(32) || n < -(BigInt(2) ** BigInt(32))) && (o = U(o)), o += "n"), r += ` It must be ${t}. Received ${o}`, r; }), RangeError);
        const z = /[^+/0-9A-Za-z-_]/g;
        function H(e, t) { let n; t = t || 1 / 0; const r = e.length; let o = null; const i = []; for (let s = 0; s < r; ++s) {
            if (n = e.charCodeAt(s), n > 55295 && n < 57344) {
                if (!o) {
                    if (n > 56319) {
                        (t -= 3) > -1 && i.push(239, 191, 189);
                        continue;
                    }
                    if (s + 1 === r) {
                        (t -= 3) > -1 && i.push(239, 191, 189);
                        continue;
                    }
                    o = n;
                    continue;
                }
                if (n < 56320) {
                    (t -= 3) > -1 && i.push(239, 191, 189), o = n;
                    continue;
                }
                n = 65536 + (o - 55296 << 10 | n - 56320);
            }
            else
                o && (t -= 3) > -1 && i.push(239, 191, 189);
            if (o = null, n < 128) {
                if ((t -= 1) < 0)
                    break;
                i.push(n);
            }
            else if (n < 2048) {
                if ((t -= 2) < 0)
                    break;
                i.push(n >> 6 | 192, 63 & n | 128);
            }
            else if (n < 65536) {
                if ((t -= 3) < 0)
                    break;
                i.push(n >> 12 | 224, n >> 6 & 63 | 128, 63 & n | 128);
            }
            else {
                if (!(n < 1114112))
                    throw new Error("Invalid code point");
                if ((t -= 4) < 0)
                    break;
                i.push(n >> 18 | 240, n >> 12 & 63 | 128, n >> 6 & 63 | 128, 63 & n | 128);
            }
        } return i; }
        function Y(e) { return o.toByteArray(function (e) { if ((e = (e = e.split("=")[0]).trim().replace(z, "")).length < 2)
            return ""; for (; e.length % 4 != 0;)
            e += "="; return e; }(e)); }
        function J(e, t, n, r) { let o; for (o = 0; o < r && !(o + n >= t.length || o >= e.length); ++o)
            t[o + n] = e[o]; return o; }
        function G(e, t) { return e instanceof t || null != e && null != e.constructor && null != e.constructor.name && e.constructor.name === t.name; }
        function X(e) { return e != e; }
        const Q = function () { const e = "0123456789abcdef", t = new Array(256); for (let n = 0; n < 16; ++n) {
            const r = 16 * n;
            for (let o = 0; o < 16; ++o)
                t[r + o] = e[n] + e[o];
        } return t; }();
        function Z(e) { return "undefined" == typeof BigInt ? ee : e; }
        function ee() { throw new Error("BigInt not supported"); }
    }, 2680: (e, t, n) => {
        "use strict";
        var r = n(7286), o = n(9429), i = o(r("String.prototype.indexOf"));
        e.exports = function (e, t) { var n = r(e, !!t); return "function" == typeof n && i(e, ".prototype.") > -1 ? o(n) : n; };
    }, 9429: (e, t, n) => {
        "use strict";
        var r = n(4090), o = n(7286), i = o("%Function.prototype.apply%"), s = o("%Function.prototype.call%"), a = o("%Reflect.apply%", !0) || r.call(s, i), u = o("%Object.getOwnPropertyDescriptor%", !0), c = o("%Object.defineProperty%", !0), l = o("%Math.max%");
        if (c)
            try {
                c({}, "a", { value: 1 });
            }
            catch (e) {
                c = null;
            }
        e.exports = function (e) { var t = a(r, s, arguments); if (u && c) {
            var n = u(t, "length");
            n.configurable && c(t, "length", { value: 1 + l(0, e.length - (arguments.length - 1)) });
        } return t; };
        var p = function () { return a(r, i, arguments); };
        c ? c(e.exports, "apply", { value: p }) : e.exports.apply = p;
    }, 3716: (e, t, n) => { var r = n(3335), o = n(1696); function i() { return (new Date).getTime(); } var s, a = Array.prototype.slice, u = {}; s = void 0 !== n.g && n.g.console ? n.g.console : "undefined" != typeof window && window.console ? window.console : {}; for (var c = [[function () { }, "log"], [function () { s.log.apply(s, arguments); }, "info"], [function () { s.log.apply(s, arguments); }, "warn"], [function () { s.warn.apply(s, arguments); }, "error"], [function (e) { u[e] = i(); }, "time"], [function (e) { var t = u[e]; if (!t)
                throw new Error("No such label: " + e); delete u[e]; var n = i() - t; s.log(e + ": " + n + "ms"); }, "timeEnd"], [function () { var e = new Error; e.name = "Trace", e.message = r.format.apply(null, arguments), s.error(e.stack); }, "trace"], [function (e) { s.log(r.inspect(e) + "\n"); }, "dir"], [function (e) { if (!e) {
                var t = a.call(arguments, 1);
                o.ok(!1, r.format.apply(null, t));
            } }, "assert"]], l = 0; l < c.length; l++) {
        var p = c[l], f = p[0], d = p[1];
        s[d] || (s[d] = f);
    } e.exports = s; }, 4926: (e, t, n) => {
        "use strict";
        var r = n(3464), o = "function" == typeof Symbol && "symbol" == typeof Symbol("foo"), i = Object.prototype.toString, s = Array.prototype.concat, a = Object.defineProperty, u = n(1181)(), c = a && u, l = function (e, t, n, r) { if (t in e)
            if (!0 === r) {
                if (e[t] === n)
                    return;
            }
            else if ("function" != typeof (o = r) || "[object Function]" !== i.call(o) || !r())
                return; var o; c ? a(e, t, { configurable: !0, enumerable: !1, value: n, writable: !0 }) : e[t] = n; }, p = function (e, t) { var n = arguments.length > 2 ? arguments[2] : {}, i = r(t); o && (i = s.call(i, Object.getOwnPropertySymbols(t))); for (var a = 0; a < i.length; a += 1)
            l(e, i[a], t[i[a]], n[i[a]]); };
        p.supportsDescriptors = !!c, e.exports = p;
    }, 4956: e => {
        "use strict";
        function t(e, t) { if (null == e)
            throw new TypeError("Cannot convert first argument to object"); for (var n = Object(e), r = 1; r < arguments.length; r++) {
            var o = arguments[r];
            if (null != o)
                for (var i = Object.keys(Object(o)), s = 0, a = i.length; s < a; s++) {
                    var u = i[s], c = Object.getOwnPropertyDescriptor(o, u);
                    void 0 !== c && c.enumerable && (n[u] = o[u]);
                }
        } return n; }
        e.exports = { assign: t, polyfill: function () { Object.assign || Object.defineProperty(Object, "assign", { enumerable: !1, configurable: !0, writable: !0, value: t }); } };
    }, 3243: (e, t, n) => {
        "use strict";
        var r = n(9680), o = Object.prototype.toString, i = Object.prototype.hasOwnProperty, s = function (e, t, n) { for (var r = 0, o = e.length; r < o; r++)
            i.call(e, r) && (null == n ? t(e[r], r, e) : t.call(n, e[r], r, e)); }, a = function (e, t, n) { for (var r = 0, o = e.length; r < o; r++)
            null == n ? t(e.charAt(r), r, e) : t.call(n, e.charAt(r), r, e); }, u = function (e, t, n) { for (var r in e)
            i.call(e, r) && (null == n ? t(e[r], r, e) : t.call(n, e[r], r, e)); };
        e.exports = function (e, t, n) { if (!r(t))
            throw new TypeError("iterator must be a function"); var i; arguments.length >= 3 && (i = n), "[object Array]" === o.call(e) ? s(e, t, i) : "string" == typeof e ? a(e, t, i) : u(e, t, i); };
    }, 7795: e => {
        "use strict";
        var t = "Function.prototype.bind called on incompatible ", n = Array.prototype.slice, r = Object.prototype.toString, o = "[object Function]";
        e.exports = function (e) { var i = this; if ("function" != typeof i || r.call(i) !== o)
            throw new TypeError(t + i); for (var s, a = n.call(arguments, 1), u = function () { if (this instanceof s) {
            var t = i.apply(this, a.concat(n.call(arguments)));
            return Object(t) === t ? t : this;
        } return i.apply(e, a.concat(n.call(arguments))); }, c = Math.max(0, i.length - a.length), l = [], p = 0; p < c; p++)
            l.push("$" + p); if (s = Function("binder", "return function (" + l.join(",") + "){ return binder.apply(this,arguments); }")(u), i.prototype) {
            var f = function () { };
            f.prototype = i.prototype, s.prototype = new f, f.prototype = null;
        } return s; };
    }, 4090: (e, t, n) => {
        "use strict";
        var r = n(7795);
        e.exports = Function.prototype.bind || r;
    }, 7286: (e, t, n) => {
        "use strict";
        var r, o = SyntaxError, i = Function, s = TypeError, a = function (e) { try {
            return i('"use strict"; return (' + e + ").constructor;")();
        }
        catch (e) { } }, u = Object.getOwnPropertyDescriptor;
        if (u)
            try {
                u({}, "");
            }
            catch (e) {
                u = null;
            }
        var c = function () { throw new s; }, l = u ? function () { try {
            return c;
        }
        catch (e) {
            try {
                return u(arguments, "callee").get;
            }
            catch (e) {
                return c;
            }
        } }() : c, p = n(2636)(), f = Object.getPrototypeOf || function (e) { return e.__proto__; }, d = {}, h = "undefined" == typeof Uint8Array ? r : f(Uint8Array), m = { "%AggregateError%": "undefined" == typeof AggregateError ? r : AggregateError, "%Array%": Array, "%ArrayBuffer%": "undefined" == typeof ArrayBuffer ? r : ArrayBuffer, "%ArrayIteratorPrototype%": p ? f([][Symbol.iterator]()) : r, "%AsyncFromSyncIteratorPrototype%": r, "%AsyncFunction%": d, "%AsyncGenerator%": d, "%AsyncGeneratorFunction%": d, "%AsyncIteratorPrototype%": d, "%Atomics%": "undefined" == typeof Atomics ? r : Atomics, "%BigInt%": "undefined" == typeof BigInt ? r : BigInt, "%Boolean%": Boolean, "%DataView%": "undefined" == typeof DataView ? r : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%eval%": eval, "%EvalError%": EvalError, "%Float32Array%": "undefined" == typeof Float32Array ? r : Float32Array, "%Float64Array%": "undefined" == typeof Float64Array ? r : Float64Array, "%FinalizationRegistry%": "undefined" == typeof FinalizationRegistry ? r : FinalizationRegistry, "%Function%": i, "%GeneratorFunction%": d, "%Int8Array%": "undefined" == typeof Int8Array ? r : Int8Array, "%Int16Array%": "undefined" == typeof Int16Array ? r : Int16Array, "%Int32Array%": "undefined" == typeof Int32Array ? r : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": p ? f(f([][Symbol.iterator]())) : r, "%JSON%": "object" == typeof JSON ? JSON : r, "%Map%": "undefined" == typeof Map ? r : Map, "%MapIteratorPrototype%": "undefined" != typeof Map && p ? f((new Map)[Symbol.iterator]()) : r, "%Math%": Math, "%Number%": Number, "%Object%": Object, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": "undefined" == typeof Promise ? r : Promise, "%Proxy%": "undefined" == typeof Proxy ? r : Proxy, "%RangeError%": RangeError, "%ReferenceError%": ReferenceError, "%Reflect%": "undefined" == typeof Reflect ? r : Reflect, "%RegExp%": RegExp, "%Set%": "undefined" == typeof Set ? r : Set, "%SetIteratorPrototype%": "undefined" != typeof Set && p ? f((new Set)[Symbol.iterator]()) : r, "%SharedArrayBuffer%": "undefined" == typeof SharedArrayBuffer ? r : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": p ? f(""[Symbol.iterator]()) : r, "%Symbol%": p ? Symbol : r, "%SyntaxError%": o, "%ThrowTypeError%": l, "%TypedArray%": h, "%TypeError%": s, "%Uint8Array%": "undefined" == typeof Uint8Array ? r : Uint8Array, "%Uint8ClampedArray%": "undefined" == typeof Uint8ClampedArray ? r : Uint8ClampedArray, "%Uint16Array%": "undefined" == typeof Uint16Array ? r : Uint16Array, "%Uint32Array%": "undefined" == typeof Uint32Array ? r : Uint32Array, "%URIError%": URIError, "%WeakMap%": "undefined" == typeof WeakMap ? r : WeakMap, "%WeakRef%": "undefined" == typeof WeakRef ? r : WeakRef, "%WeakSet%": "undefined" == typeof WeakSet ? r : WeakSet }, g = function e(t) { var n; if ("%AsyncFunction%" === t)
            n = a("async function () {}");
        else if ("%GeneratorFunction%" === t)
            n = a("function* () {}");
        else if ("%AsyncGeneratorFunction%" === t)
            n = a("async function* () {}");
        else if ("%AsyncGenerator%" === t) {
            var r = e("%AsyncGeneratorFunction%");
            r && (n = r.prototype);
        }
        else if ("%AsyncIteratorPrototype%" === t) {
            var o = e("%AsyncGenerator%");
            o && (n = f(o.prototype));
        } return m[t] = n, n; }, y = { "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, v = n(4090), b = n(3198), D = v.call(Function.call, Array.prototype.concat), E = v.call(Function.apply, Array.prototype.splice), C = v.call(Function.call, String.prototype.replace), w = v.call(Function.call, String.prototype.slice), A = v.call(Function.call, RegExp.prototype.exec), S = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, x = /\\(\\)?/g, T = function (e) { var t = w(e, 0, 1), n = w(e, -1); if ("%" === t && "%" !== n)
            throw new o("invalid intrinsic syntax, expected closing `%`"); if ("%" === n && "%" !== t)
            throw new o("invalid intrinsic syntax, expected opening `%`"); var r = []; return C(e, S, (function (e, t, n, o) { r[r.length] = n ? C(o, x, "$1") : t || e; })), r; }, k = function (e, t) { var n, r = e; if (b(y, r) && (r = "%" + (n = y[r])[0] + "%"), b(m, r)) {
            var i = m[r];
            if (i === d && (i = g(r)), void 0 === i && !t)
                throw new s("intrinsic " + e + " exists, but is not available. Please file an issue!");
            return { alias: n, name: r, value: i };
        } throw new o("intrinsic " + e + " does not exist!"); };
        e.exports = function (e, t) { if ("string" != typeof e || 0 === e.length)
            throw new s("intrinsic name must be a non-empty string"); if (arguments.length > 1 && "boolean" != typeof t)
            throw new s('"allowMissing" argument must be a boolean'); if (null === A(/^%?[^%]*%?$/, e))
            throw new o("`%` may not be present anywhere but at the beginning and end of the intrinsic name"); var n = T(e), r = n.length > 0 ? n[0] : "", i = k("%" + r + "%", t), a = i.name, c = i.value, l = !1, p = i.alias; p && (r = p[0], E(n, D([0, 1], p))); for (var f = 1, d = !0; f < n.length; f += 1) {
            var h = n[f], g = w(h, 0, 1), y = w(h, -1);
            if (('"' === g || "'" === g || "`" === g || '"' === y || "'" === y || "`" === y) && g !== y)
                throw new o("property names with quotes must have matching quotes");
            if ("constructor" !== h && d || (l = !0), b(m, a = "%" + (r += "." + h) + "%"))
                c = m[a];
            else if (null != c) {
                if (!(h in c)) {
                    if (!t)
                        throw new s("base intrinsic for " + e + " exists, but the property is not available.");
                    return;
                }
                if (u && f + 1 >= n.length) {
                    var v = u(c, h);
                    c = (d = !!v) && "get" in v && !("originalValue" in v.get) ? v.get : c[h];
                }
                else
                    d = b(c, h), c = c[h];
                d && !l && (m[a] = c);
            }
        } return c; };
    }, 326: (e, t, n) => {
        "use strict";
        var r = n(7286)("%Object.getOwnPropertyDescriptor%", !0);
        if (r)
            try {
                r([], "length");
            }
            catch (e) {
                r = null;
            }
        e.exports = r;
    }, 1181: (e, t, n) => {
        "use strict";
        var r = n(7286)("%Object.defineProperty%", !0), o = function () { if (r)
            try {
                return r({}, "a", { value: 1 }), !0;
            }
            catch (e) {
                return !1;
            } return !1; };
        o.hasArrayLengthDefineBug = function () { if (!o())
            return null; try {
            return 1 !== r([], "length", { value: 1 }).length;
        }
        catch (e) {
            return !0;
        } }, e.exports = o;
    }, 2636: (e, t, n) => {
        "use strict";
        var r = "undefined" != typeof Symbol && Symbol, o = n(6679);
        e.exports = function () { return "function" == typeof r && "function" == typeof Symbol && "symbol" == typeof r("foo") && "symbol" == typeof Symbol("bar") && o(); };
    }, 6679: e => {
        "use strict";
        e.exports = function () { if ("function" != typeof Symbol || "function" != typeof Object.getOwnPropertySymbols)
            return !1; if ("symbol" == typeof Symbol.iterator)
            return !0; var e = {}, t = Symbol("test"), n = Object(t); if ("string" == typeof t)
            return !1; if ("[object Symbol]" !== Object.prototype.toString.call(t))
            return !1; if ("[object Symbol]" !== Object.prototype.toString.call(n))
            return !1; for (t in e[t] = 42, e)
            return !1; if ("function" == typeof Object.keys && 0 !== Object.keys(e).length)
            return !1; if ("function" == typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(e).length)
            return !1; var r = Object.getOwnPropertySymbols(e); if (1 !== r.length || r[0] !== t)
            return !1; if (!Object.prototype.propertyIsEnumerable.call(e, t))
            return !1; if ("function" == typeof Object.getOwnPropertyDescriptor) {
            var o = Object.getOwnPropertyDescriptor(e, t);
            if (42 !== o.value || !0 !== o.enumerable)
                return !1;
        } return !0; };
    }, 7226: (e, t, n) => {
        "use strict";
        var r = n(6679);
        e.exports = function () { return r() && !!Symbol.toStringTag; };
    }, 3198: (e, t, n) => {
        "use strict";
        var r = n(4090);
        e.exports = r.call(Function.call, Object.prototype.hasOwnProperty);
    }, 2333: (e, t) => { t.read = function (e, t, n, r, o) { var i, s, a = 8 * o - r - 1, u = (1 << a) - 1, c = u >> 1, l = -7, p = n ? o - 1 : 0, f = n ? -1 : 1, d = e[t + p]; for (p += f, i = d & (1 << -l) - 1, d >>= -l, l += a; l > 0; i = 256 * i + e[t + p], p += f, l -= 8)
        ; for (s = i & (1 << -l) - 1, i >>= -l, l += r; l > 0; s = 256 * s + e[t + p], p += f, l -= 8)
        ; if (0 === i)
        i = 1 - c;
    else {
        if (i === u)
            return s ? NaN : 1 / 0 * (d ? -1 : 1);
        s += Math.pow(2, r), i -= c;
    } return (d ? -1 : 1) * s * Math.pow(2, i - r); }, t.write = function (e, t, n, r, o, i) { var s, a, u, c = 8 * i - o - 1, l = (1 << c) - 1, p = l >> 1, f = 23 === o ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = r ? 0 : i - 1, h = r ? 1 : -1, m = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0; for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (a = isNaN(t) ? 1 : 0, s = l) : (s = Math.floor(Math.log(t) / Math.LN2), t * (u = Math.pow(2, -s)) < 1 && (s--, u *= 2), (t += s + p >= 1 ? f / u : f * Math.pow(2, 1 - p)) * u >= 2 && (s++, u /= 2), s + p >= l ? (a = 0, s = l) : s + p >= 1 ? (a = (t * u - 1) * Math.pow(2, o), s += p) : (a = t * Math.pow(2, p - 1) * Math.pow(2, o), s = 0)); o >= 8; e[n + d] = 255 & a, d += h, a /= 256, o -= 8)
        ; for (s = s << o | a, c += o; c > 0; e[n + d] = 255 & s, d += h, s /= 256, c -= 8)
        ; e[n + d - h] |= 128 * m; }; }, 1285: e => { "function" == typeof Object.create ? e.exports = function (e, t) { t && (e.super_ = t, e.prototype = Object.create(t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })); } : e.exports = function (e, t) { if (t) {
        e.super_ = t;
        var n = function () { };
        n.prototype = t.prototype, e.prototype = new n, e.prototype.constructor = e;
    } }; }, 2635: (e, t, n) => {
        "use strict";
        var r = n(7226)(), o = n(2680)("Object.prototype.toString"), i = function (e) { return !(r && e && "object" == typeof e && Symbol.toStringTag in e) && "[object Arguments]" === o(e); }, s = function (e) { return !!i(e) || null !== e && "object" == typeof e && "number" == typeof e.length && e.length >= 0 && "[object Array]" !== o(e) && "[object Function]" === o(e.callee); }, a = function () { return i(arguments); }();
        i.isLegacyArguments = s, e.exports = a ? i : s;
    }, 9680: e => {
        "use strict";
        var t, n, r = Function.prototype.toString, o = "object" == typeof Reflect && null !== Reflect && Reflect.apply;
        if ("function" == typeof o && "function" == typeof Object.defineProperty)
            try {
                t = Object.defineProperty({}, "length", { get: function () { throw n; } }), n = {}, o((function () { throw 42; }), null, t);
            }
            catch (e) {
                e !== n && (o = null);
            }
        else
            o = null;
        var i = /^\s*class\b/, s = function (e) { try {
            var t = r.call(e);
            return i.test(t);
        }
        catch (e) {
            return !1;
        } }, a = function (e) { try {
            return !s(e) && (r.call(e), !0);
        }
        catch (e) {
            return !1;
        } }, u = Object.prototype.toString, c = "function" == typeof Symbol && !!Symbol.toStringTag, l = !(0 in [,]), p = function () { return !1; };
        if ("object" == typeof document) {
            var f = document.all;
            u.call(f) === u.call(document.all) && (p = function (e) { if ((l || !e) && (void 0 === e || "object" == typeof e))
                try {
                    var t = u.call(e);
                    return ("[object HTMLAllCollection]" === t || "[object HTML document.all class]" === t || "[object HTMLCollection]" === t || "[object Object]" === t) && null == e("");
                }
                catch (e) { } return !1; });
        }
        e.exports = o ? function (e) { if (p(e))
            return !0; if (!e)
            return !1; if ("function" != typeof e && "object" != typeof e)
            return !1; try {
            o(e, null, t);
        }
        catch (e) {
            if (e !== n)
                return !1;
        } return !s(e) && a(e); } : function (e) { if (p(e))
            return !0; if (!e)
            return !1; if ("function" != typeof e && "object" != typeof e)
            return !1; if (c)
            return a(e); if (s(e))
            return !1; var t = u.call(e); return !("[object Function]" !== t && "[object GeneratorFunction]" !== t && !/^\[object HTML/.test(t)) && a(e); };
    }, 3138: (e, t, n) => {
        "use strict";
        var r, o = Object.prototype.toString, i = Function.prototype.toString, s = /^\s*(?:function)?\*/, a = n(7226)(), u = Object.getPrototypeOf;
        e.exports = function (e) { if ("function" != typeof e)
            return !1; if (s.test(i.call(e)))
            return !0; if (!a)
            return "[object GeneratorFunction]" === o.call(e); if (!u)
            return !1; if (void 0 === r) {
            var t = function () { if (!a)
                return !1; try {
                return Function("return function*() {}")();
            }
            catch (e) { } }();
            r = !!t && u(t);
        } return u(e) === r; };
    }, 7053: e => {
        "use strict";
        e.exports = function (e) { return e != e; };
    }, 4782: (e, t, n) => {
        "use strict";
        var r = n(9429), o = n(4926), i = n(7053), s = n(755), a = n(5346), u = r(s(), Number);
        o(u, { getPolyfill: s, implementation: i, shim: a }), e.exports = u;
    }, 755: (e, t, n) => {
        "use strict";
        var r = n(7053);
        e.exports = function () { return Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a") ? Number.isNaN : r; };
    }, 5346: (e, t, n) => {
        "use strict";
        var r = n(4926), o = n(755);
        e.exports = function () { var e = o(); return r(Number, { isNaN: e }, { isNaN: function () { return Number.isNaN !== e; } }), e; };
    }, 198: (e, t, n) => {
        "use strict";
        var r = n(3243), o = n(2191), i = n(2680), s = i("Object.prototype.toString"), a = n(7226)(), u = n(326), c = "undefined" == typeof globalThis ? n.g : globalThis, l = o(), p = i("Array.prototype.indexOf", !0) || function (e, t) { for (var n = 0; n < e.length; n += 1)
            if (e[n] === t)
                return n; return -1; }, f = i("String.prototype.slice"), d = {}, h = Object.getPrototypeOf;
        a && u && h && r(l, (function (e) { var t = new c[e]; if (Symbol.toStringTag in t) {
            var n = h(t), r = u(n, Symbol.toStringTag);
            if (!r) {
                var o = h(n);
                r = u(o, Symbol.toStringTag);
            }
            d[e] = r.get;
        } })), e.exports = function (e) { if (!e || "object" != typeof e)
            return !1; if (!a || !(Symbol.toStringTag in e)) {
            var t = f(s(e), 8, -1);
            return p(l, t) > -1;
        } return !!u && function (e) { var t = !1; return r(d, (function (n, r) { if (!t)
            try {
                t = n.call(e) === r;
            }
            catch (e) { } })), t; }(e); };
    }, 8169: e => {
        "use strict";
        var t = function (e) { return e != e; };
        e.exports = function (e, n) { return 0 === e && 0 === n ? 1 / e == 1 / n : e === n || !(!t(e) || !t(n)); };
    }, 4679: (e, t, n) => {
        "use strict";
        var r = n(4926), o = n(9429), i = n(8169), s = n(8070), a = n(191), u = o(s(), Object);
        r(u, { getPolyfill: s, implementation: i, shim: a }), e.exports = u;
    }, 8070: (e, t, n) => {
        "use strict";
        var r = n(8169);
        e.exports = function () { return "function" == typeof Object.is ? Object.is : r; };
    }, 191: (e, t, n) => {
        "use strict";
        var r = n(8070), o = n(4926);
        e.exports = function () { var e = r(); return o(Object, { is: e }, { is: function () { return Object.is !== e; } }), e; };
    }, 5691: (e, t, n) => {
        "use strict";
        var r;
        if (!Object.keys) {
            var o = Object.prototype.hasOwnProperty, i = Object.prototype.toString, s = n(801), a = Object.prototype.propertyIsEnumerable, u = !a.call({ toString: null }, "toString"), c = a.call((function () { }), "prototype"), l = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"], p = function (e) { var t = e.constructor; return t && t.prototype === e; }, f = { $applicationCache: !0, $console: !0, $external: !0, $frame: !0, $frameElement: !0, $frames: !0, $innerHeight: !0, $innerWidth: !0, $onmozfullscreenchange: !0, $onmozfullscreenerror: !0, $outerHeight: !0, $outerWidth: !0, $pageXOffset: !0, $pageYOffset: !0, $parent: !0, $scrollLeft: !0, $scrollTop: !0, $scrollX: !0, $scrollY: !0, $self: !0, $webkitIndexedDB: !0, $webkitStorageInfo: !0, $window: !0 }, d = function () { if ("undefined" == typeof window)
                return !1; for (var e in window)
                try {
                    if (!f["$" + e] && o.call(window, e) && null !== window[e] && "object" == typeof window[e])
                        try {
                            p(window[e]);
                        }
                        catch (e) {
                            return !0;
                        }
                }
                catch (e) {
                    return !0;
                } return !1; }();
            r = function (e) { var t = null !== e && "object" == typeof e, n = "[object Function]" === i.call(e), r = s(e), a = t && "[object String]" === i.call(e), f = []; if (!t && !n && !r)
                throw new TypeError("Object.keys called on a non-object"); var h = c && n; if (a && e.length > 0 && !o.call(e, 0))
                for (var m = 0; m < e.length; ++m)
                    f.push(String(m)); if (r && e.length > 0)
                for (var g = 0; g < e.length; ++g)
                    f.push(String(g));
            else
                for (var y in e)
                    h && "prototype" === y || !o.call(e, y) || f.push(String(y)); if (u)
                for (var v = function (e) { if ("undefined" == typeof window || !d)
                    return p(e); try {
                    return p(e);
                }
                catch (e) {
                    return !1;
                } }(e), b = 0; b < l.length; ++b)
                    v && "constructor" === l[b] || !o.call(e, l[b]) || f.push(l[b]); return f; };
        }
        e.exports = r;
    }, 3464: (e, t, n) => {
        "use strict";
        var r = Array.prototype.slice, o = n(801), i = Object.keys, s = i ? function (e) { return i(e); } : n(5691), a = Object.keys;
        s.shim = function () { if (Object.keys) {
            var e = function () { var e = Object.keys(arguments); return e && e.length === arguments.length; }(1, 2);
            e || (Object.keys = function (e) { return o(e) ? a(r.call(e)) : a(e); });
        }
        else
            Object.keys = s; return Object.keys || s; }, e.exports = s;
    }, 801: e => {
        "use strict";
        var t = Object.prototype.toString;
        e.exports = function (e) { var n = t.call(e), r = "[object Arguments]" === n; return r || (r = "[object Array]" !== n && null !== e && "object" == typeof e && "number" == typeof e.length && e.length >= 0 && "[object Function]" === t.call(e.callee)), r; };
    }, 4406: e => { var t, n, r = e.exports = {}; function o() { throw new Error("setTimeout has not been defined"); } function i() { throw new Error("clearTimeout has not been defined"); } function s(e) { if (t === setTimeout)
        return setTimeout(e, 0); if ((t === o || !t) && setTimeout)
        return t = setTimeout, setTimeout(e, 0); try {
        return t(e, 0);
    }
    catch (n) {
        try {
            return t.call(null, e, 0);
        }
        catch (n) {
            return t.call(this, e, 0);
        }
    } } !function () { try {
        t = "function" == typeof setTimeout ? setTimeout : o;
    }
    catch (e) {
        t = o;
    } try {
        n = "function" == typeof clearTimeout ? clearTimeout : i;
    }
    catch (e) {
        n = i;
    } }(); var a, u = [], c = !1, l = -1; function p() { c && a && (c = !1, a.length ? u = a.concat(u) : l = -1, u.length && f()); } function f() { if (!c) {
        var e = s(p);
        c = !0;
        for (var t = u.length; t;) {
            for (a = u, u = []; ++l < t;)
                a && a[l].run();
            l = -1, t = u.length;
        }
        a = null, c = !1, function (e) { if (n === clearTimeout)
            return clearTimeout(e); if ((n === i || !n) && clearTimeout)
            return n = clearTimeout, clearTimeout(e); try {
            n(e);
        }
        catch (t) {
            try {
                return n.call(null, e);
            }
            catch (t) {
                return n.call(this, e);
            }
        } }(e);
    } } function d(e, t) { this.fun = e, this.array = t; } function h() { } r.nextTick = function (e) { var t = new Array(arguments.length - 1); if (arguments.length > 1)
        for (var n = 1; n < arguments.length; n++)
            t[n - 1] = arguments[n]; u.push(new d(e, t)), 1 !== u.length || c || s(f); }, d.prototype.run = function () { this.fun.apply(null, this.array); }, r.title = "browser", r.browser = !0, r.env = {}, r.argv = [], r.version = "", r.versions = {}, r.on = h, r.addListener = h, r.once = h, r.off = h, r.removeListener = h, r.removeAllListeners = h, r.emit = h, r.prependListener = h, r.prependOnceListener = h, r.listeners = function (e) { return []; }, r.binding = function (e) { throw new Error("process.binding is not supported"); }, r.cwd = function () { return "/"; }, r.chdir = function (e) { throw new Error("process.chdir is not supported"); }, r.umask = function () { return 0; }; }, 3401: (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }), t.BaseService = void 0;
        const r = n(6508), o = n(4881);
        t.BaseService = class {
            mode;
            documents = {};
            options = {};
            globalOptions = {};
            constructor(e) { this.mode = e; }
            addDocument(e) { this.documents[e.uri] = o.TextDocument.create(e.uri, e.languageId, e.version, e.text); }
            getDocument(e) { return this.documents[e]; }
            removeDocument(e) { delete this.documents[e.uri], this.options[e.uri] && delete this.options[e.uri]; }
            getDocumentValue(e) { return this.getDocument(e).getText(); }
            setValue(e, t) { let n = this.getDocument(e.uri); n && (n = o.TextDocument.create(n.uri, n.languageId, n.version, t), this.documents[n.uri] = n); }
            setGlobalOptions(e) { this.globalOptions = e ?? {}; }
            setOptions(e, t, n = !1) { this.options[e] = n ? (0, r.mergeObjects)(t, this.options[e]) : t; }
            getOption(e, t) { return this.options[e] && this.options[e][t] ? this.options[e][t] : this.globalOptions[t]; }
            applyDeltas(e, t) { let n = this.getDocument(e.uri); n && o.TextDocument.update(n, t, e.version); }
            async doComplete(e, t) { return null; }
            async doHover(e, t) { return null; }
            async doResolve(e) { return null; }
            async doValidation(e) { return []; }
            format(e, t, n) { return []; }
            async provideSignatureHelp(e, t) { return null; }
            async findDocumentHighlights(e, t) { return []; }
        };
    }, 6984: (e, t, n) => {
        "use strict";
        var r, o, i, s = n(4406), a = n(3716), u = n(8834).lW;
        Object.defineProperty(t, "__esModule", { value: !0 }), t.getLanguageService = t.YAMLValidation = t.YAMLSchemaService = t.SettingsState = void 0;
        var c, l, p, f = Object.create, d = Object.defineProperty, h = Object.getOwnPropertyDescriptor, m = Object.getOwnPropertyNames, g = Object.getPrototypeOf, y = Object.prototype.hasOwnProperty, v = (e, t) => function () { return t || (0, e[m(e)[0]])((t = { exports: {} }).exports, t), t.exports; }, b = (e, t, n) => (n = null != e ? f(g(e)) : {}, ((e, t, n, r) => { if (t && "object" == typeof t || "function" == typeof t)
            for (let n of m(t))
                y.call(e, n) || undefined === n || d(e, n, { get: () => t[n], enumerable: !(r = h(t, n)) || r.enumerable }); return e; })(!t && e && e.__esModule ? n : d(n, "default", { value: e, enumerable: !0 }), e)), D = v({ "../../node_modules/path-browserify/index.js"(e, t) { function n(e) { if ("string" != typeof e)
                throw new TypeError("Path must be a string. Received " + JSON.stringify(e)); } function r(e, t) { for (var n, r = "", o = 0, i = -1, s = 0, a = 0; a <= e.length; ++a) {
                if (a < e.length)
                    n = e.charCodeAt(a);
                else {
                    if (47 === n)
                        break;
                    n = 47;
                }
                if (47 === n) {
                    if (i === a - 1 || 1 === s)
                        ;
                    else if (i !== a - 1 && 2 === s) {
                        if (r.length < 2 || 2 !== o || 46 !== r.charCodeAt(r.length - 1) || 46 !== r.charCodeAt(r.length - 2))
                            if (r.length > 2) {
                                var u = r.lastIndexOf("/");
                                if (u !== r.length - 1) {
                                    -1 === u ? (r = "", o = 0) : o = (r = r.slice(0, u)).length - 1 - r.lastIndexOf("/"), i = a, s = 0;
                                    continue;
                                }
                            }
                            else if (2 === r.length || 1 === r.length) {
                                r = "", o = 0, i = a, s = 0;
                                continue;
                            }
                        t && (r.length > 0 ? r += "/.." : r = "..", o = 2);
                    }
                    else
                        r.length > 0 ? r += "/" + e.slice(i + 1, a) : r = e.slice(i + 1, a), o = a - i - 1;
                    i = a, s = 0;
                }
                else
                    46 === n && -1 !== s ? ++s : s = -1;
            } return r; } var o = { resolve: function () { for (var e, t = "", o = !1, i = arguments.length - 1; i >= -1 && !o; i--) {
                    var a;
                    i >= 0 ? a = arguments[i] : (void 0 === e && (e = s.cwd()), a = e), n(a), 0 !== a.length && (t = a + "/" + t, o = 47 === a.charCodeAt(0));
                } return t = r(t, !o), o ? t.length > 0 ? "/" + t : "/" : t.length > 0 ? t : "."; }, normalize: function (e) { if (n(e), 0 === e.length)
                    return "."; var t = 47 === e.charCodeAt(0), o = 47 === e.charCodeAt(e.length - 1); return 0 !== (e = r(e, !t)).length || t || (e = "."), e.length > 0 && o && (e += "/"), t ? "/" + e : e; }, isAbsolute: function (e) { return n(e), e.length > 0 && 47 === e.charCodeAt(0); }, join: function () { if (0 === arguments.length)
                    return "."; for (var e, t = 0; t < arguments.length; ++t) {
                    var r = arguments[t];
                    n(r), r.length > 0 && (void 0 === e ? e = r : e += "/" + r);
                } return void 0 === e ? "." : o.normalize(e); }, relative: function (e, t) { if (n(e), n(t), e === t)
                    return ""; if ((e = o.resolve(e)) === (t = o.resolve(t)))
                    return ""; for (var r = 1; r < e.length && 47 === e.charCodeAt(r); ++r)
                    ; for (var i = e.length, s = i - r, a = 1; a < t.length && 47 === t.charCodeAt(a); ++a)
                    ; for (var u = t.length - a, c = s < u ? s : u, l = -1, p = 0; p <= c; ++p) {
                    if (p === c) {
                        if (u > c) {
                            if (47 === t.charCodeAt(a + p))
                                return t.slice(a + p + 1);
                            if (0 === p)
                                return t.slice(a + p);
                        }
                        else
                            s > c && (47 === e.charCodeAt(r + p) ? l = p : 0 === p && (l = 0));
                        break;
                    }
                    var f = e.charCodeAt(r + p);
                    if (f !== t.charCodeAt(a + p))
                        break;
                    47 === f && (l = p);
                } var d = ""; for (p = r + l + 1; p <= i; ++p)
                    p !== i && 47 !== e.charCodeAt(p) || (0 === d.length ? d += ".." : d += "/.."); return d.length > 0 ? d + t.slice(a + l) : (a += l, 47 === t.charCodeAt(a) && ++a, t.slice(a)); }, _makeLong: function (e) { return e; }, dirname: function (e) { if (n(e), 0 === e.length)
                    return "."; for (var t = e.charCodeAt(0), r = 47 === t, o = -1, i = !0, s = e.length - 1; s >= 1; --s)
                    if (47 === (t = e.charCodeAt(s))) {
                        if (!i) {
                            o = s;
                            break;
                        }
                    }
                    else
                        i = !1; return -1 === o ? r ? "/" : "." : r && 1 === o ? "//" : e.slice(0, o); }, basename: function (e, t) { if (void 0 !== t && "string" != typeof t)
                    throw new TypeError('"ext" argument must be a string'); n(e); var r, o = 0, i = -1, s = !0; if (void 0 !== t && t.length > 0 && t.length <= e.length) {
                    if (t.length === e.length && t === e)
                        return "";
                    var a = t.length - 1, u = -1;
                    for (r = e.length - 1; r >= 0; --r) {
                        var c = e.charCodeAt(r);
                        if (47 === c) {
                            if (!s) {
                                o = r + 1;
                                break;
                            }
                        }
                        else
                            -1 === u && (s = !1, u = r + 1), a >= 0 && (c === t.charCodeAt(a) ? -1 == --a && (i = r) : (a = -1, i = u));
                    }
                    return o === i ? i = u : -1 === i && (i = e.length), e.slice(o, i);
                } for (r = e.length - 1; r >= 0; --r)
                    if (47 === e.charCodeAt(r)) {
                        if (!s) {
                            o = r + 1;
                            break;
                        }
                    }
                    else
                        -1 === i && (s = !1, i = r + 1); return -1 === i ? "" : e.slice(o, i); }, extname: function (e) { n(e); for (var t = -1, r = 0, o = -1, i = !0, s = 0, a = e.length - 1; a >= 0; --a) {
                    var u = e.charCodeAt(a);
                    if (47 !== u)
                        -1 === o && (i = !1, o = a + 1), 46 === u ? -1 === t ? t = a : 1 !== s && (s = 1) : -1 !== t && (s = -1);
                    else if (!i) {
                        r = a + 1;
                        break;
                    }
                } return -1 === t || -1 === o || 0 === s || 1 === s && t === o - 1 && t === r + 1 ? "" : e.slice(t, o); }, format: function (e) { if (null === e || "object" != typeof e)
                    throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof e); return function (e, t) { var n = t.dir || t.root, r = t.base || (t.name || "") + (t.ext || ""); return n ? n === t.root ? n + r : n + "/" + r : r; }(0, e); }, parse: function (e) { n(e); var t = { root: "", dir: "", base: "", ext: "", name: "" }; if (0 === e.length)
                    return t; var r, o = e.charCodeAt(0), i = 47 === o; i ? (t.root = "/", r = 1) : r = 0; for (var s = -1, a = 0, u = -1, c = !0, l = e.length - 1, p = 0; l >= r; --l)
                    if (47 !== (o = e.charCodeAt(l)))
                        -1 === u && (c = !1, u = l + 1), 46 === o ? -1 === s ? s = l : 1 !== p && (p = 1) : -1 !== s && (p = -1);
                    else if (!c) {
                        a = l + 1;
                        break;
                    } return -1 === s || -1 === u || 0 === p || 1 === p && s === u - 1 && s === a + 1 ? -1 !== u && (t.base = t.name = 0 === a && i ? e.slice(1, u) : e.slice(a, u)) : (0 === a && i ? (t.name = e.slice(1, s), t.base = e.slice(1, u)) : (t.name = e.slice(a, s), t.base = e.slice(a, u)), t.ext = e.slice(s, u)), a > 0 ? t.dir = e.slice(0, a - 1) : i && (t.dir = "/"), t; }, sep: "/", delimiter: ":", win32: null, posix: null }; o.posix = o, t.exports = o; } }), E = v({ "../../node_modules/yaml-language-server/node_modules/ajv/dist/refs/json-schema-draft-07.json"(e, t) { t.exports = { $schema: "http://json-schema.org/draft-07/schema#", $id: "http://json-schema.org/draft-07/schema#", title: "Core schema meta-schema", definitions: { schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } }, nonNegativeInteger: { type: "integer", minimum: 0 }, nonNegativeIntegerDefault0: { allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }] }, simpleTypes: { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] }, stringArray: { type: "array", items: { type: "string" }, uniqueItems: !0, default: [] } }, type: ["object", "boolean"], properties: { $id: { type: "string", format: "uri-reference" }, $schema: { type: "string", format: "uri" }, $ref: { type: "string", format: "uri-reference" }, $comment: { type: "string" }, title: { type: "string" }, description: { type: "string" }, default: !0, readOnly: { type: "boolean", default: !1 }, examples: { type: "array", items: !0 }, multipleOf: { type: "number", exclusiveMinimum: 0 }, maximum: { type: "number" }, exclusiveMaximum: { type: "number" }, minimum: { type: "number" }, exclusiveMinimum: { type: "number" }, maxLength: { $ref: "#/definitions/nonNegativeInteger" }, minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, pattern: { type: "string", format: "regex" }, additionalItems: { $ref: "#" }, items: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }], default: !0 }, maxItems: { $ref: "#/definitions/nonNegativeInteger" }, minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, uniqueItems: { type: "boolean", default: !1 }, contains: { $ref: "#" }, maxProperties: { $ref: "#/definitions/nonNegativeInteger" }, minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, required: { $ref: "#/definitions/stringArray" }, additionalProperties: { $ref: "#" }, definitions: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, properties: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, patternProperties: { type: "object", additionalProperties: { $ref: "#" }, propertyNames: { format: "regex" }, default: {} }, dependencies: { type: "object", additionalProperties: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }] } }, propertyNames: { $ref: "#" }, const: !0, enum: { type: "array", items: !0, minItems: 1, uniqueItems: !0 }, type: { anyOf: [{ $ref: "#/definitions/simpleTypes" }, { type: "array", items: { $ref: "#/definitions/simpleTypes" }, minItems: 1, uniqueItems: !0 }] }, format: { type: "string" }, contentMediaType: { type: "string" }, contentEncoding: { type: "string" }, if: { $ref: "#" }, then: { $ref: "#" }, else: { $ref: "#" }, allOf: { $ref: "#/definitions/schemaArray" }, anyOf: { $ref: "#/definitions/schemaArray" }, oneOf: { $ref: "#/definitions/schemaArray" }, not: { $ref: "#" } }, default: !0 }; } }), C = v({ "../../node_modules/prettier/standalone.js"(e, t) { var o; o = function () { var e = "prettier", t = "2.0.5", r = "Prettier is an opinionated code formatter", o = "./bin/prettier.js", i = "prettier/prettier", s = "https://prettier.io", u = "James Long", c = "./index.js", l = { node: ">=10.13.0" }, p = { "@angular/compiler": "9.0.5", "@babel/code-frame": "7.8.0", "@babel/parser": "7.9.4", "@glimmer/syntax": "0.50.0", "@iarna/toml": "2.2.3", "@typescript-eslint/typescript-estree": "2.26.0", "angular-estree-parser": "1.3.0", "angular-html-parser": "1.4.0", camelcase: "5.3.1", chalk: "4.0.0", "ci-info": "watson/ci-info#f43f6a1cefff47fb361c88cf4b943fdbcaafe540", "cjk-regex": "2.0.0", cosmiconfig: "6.0.0", dashify: "2.0.0", dedent: "0.7.0", diff: "4.0.2", editorconfig: "0.15.3", "editorconfig-to-prettier": "0.1.1", "escape-string-regexp": "2.0.0", esutils: "2.0.3", "fast-glob": "3.2.2", "find-parent-dir": "0.3.0", "find-project-root": "1.1.1", "flow-parser": "0.122.0", "get-stream": "5.1.0", globby: "11.0.0", graphql: "15.0.0", "html-element-attributes": "2.2.1", "html-styles": "1.0.0", "html-tag-names": "1.1.5", ignore: "4.0.6", "jest-docblock": "25.2.6", "json-stable-stringify": "1.0.1", leven: "3.1.0", "lines-and-columns": "1.1.6", "linguist-languages": "7.9.0", lodash: "4.17.15", mem: "6.0.1", minimatch: "3.0.4", minimist: "1.2.5", "n-readlines": "1.0.0", "please-upgrade-node": "3.2.0", "postcss-less": "3.1.4", "postcss-media-query-parser": "0.2.3", "postcss-scss": "2.0.0", "postcss-selector-parser": "2.2.3", "postcss-values-parser": "2.0.1", "regexp-util": "1.2.2", "remark-math": "1.0.6", "remark-parse": "5.0.0", resolve: "1.16.1", semver: "7.1.3", srcset: "2.0.1", "string-width": "4.2.0", typescript: "3.8.3", "unicode-regex": "3.0.0", unified: "9.0.0", vnopts: "1.0.2", "yaml-unist-parser": "1.1.1" }, f = { "@babel/core": "7.9.0", "@babel/preset-env": "7.9.0", "@rollup/plugin-alias": "3.0.1", "@rollup/plugin-commonjs": "11.0.2", "@rollup/plugin-json": "4.0.2", "@rollup/plugin-node-resolve": "7.1.1", "@rollup/plugin-replace": "2.3.1", "babel-loader": "8.1.0", benchmark: "2.1.4", "builtin-modules": "3.1.0", codecov: "3.6.5", "cross-env": "7.0.2", cspell: "4.0.55", eslint: "6.8.0", "eslint-config-prettier": "6.10.1", "eslint-formatter-friendly": "7.0.0", "eslint-plugin-import": "2.20.2", "eslint-plugin-prettier": "3.1.2", "eslint-plugin-react": "7.19.0", "eslint-plugin-unicorn": "18.0.1", execa: "4.0.0", jest: "25.2.7", "jest-snapshot-serializer-ansi": "1.0.0", "jest-snapshot-serializer-raw": "1.1.0", "jest-watch-typeahead": "0.5.0", prettier: "2.0.4", rimraf: "3.0.2", rollup: "2.3.2", "rollup-plugin-babel": "4.4.0", "rollup-plugin-node-globals": "1.4.0", "rollup-plugin-terser": "5.3.0", shelljs: "0.8.3", "snapshot-diff": "0.7.0", "strip-ansi": "6.0.0", "synchronous-promise": "2.0.10", tempy: "0.5.0", "terser-webpack-plugin": "2.3.5", webpack: "4.42.1" }, d = { prepublishOnly: 'echo "Error: must publish from dist/" && exit 1', "prepare-release": "yarn && yarn build && yarn test:dist", test: "jest", "test:dist": "cross-env NODE_ENV=production jest", "test:dist-standalone": "cross-env NODE_ENV=production TEST_STANDALONE=1 jest tests/", "test:integration": "jest tests_integration", "perf:repeat": "yarn && yarn build && cross-env NODE_ENV=production node ./dist/bin-prettier.js --debug-repeat ${PERF_REPEAT:-1000} --loglevel debug ${PERF_FILE:-./index.js} > /dev/null", "perf:repeat-inspect": "yarn && yarn build && cross-env NODE_ENV=production node --inspect-brk ./dist/bin-prettier.js --debug-repeat ${PERF_REPEAT:-1000} --loglevel debug ${PERF_FILE:-./index.js} > /dev/null", "perf:benchmark": "yarn && yarn build && cross-env NODE_ENV=production node ./dist/bin-prettier.js --debug-benchmark --loglevel debug ${PERF_FILE:-./index.js} > /dev/null", "lint:typecheck": "tsc", "lint:eslint": "cross-env EFF_NO_LINK_RULES=true eslint . --format friendly", "lint:changelog": "node ./scripts/lint-changelog.js", "lint:prettier": 'prettier "**/*.{md,json,yml,html,css}" --check', "lint:dist": 'eslint --no-eslintrc --no-ignore --env=es6,browser --parser-options=ecmaVersion:2016 "dist/!(bin-prettier|index|third-party).js"', "lint:spellcheck": "cspell {bin,scripts,src,website}/**/*.js {docs,website/blog,changelog_unreleased}/**/*.md", "lint:deps": "node ./scripts/check-deps.js", build: "node --max-old-space-size=3072 ./scripts/build/build.js", "build-docs": "node ./scripts/build-docs.js" }, h = { name: e, version: t, description: r, bin: o, repository: i, homepage: s, author: u, license: "MIT", main: c, engines: l, dependencies: p, devDependencies: f, scripts: d }, m = Object.freeze({ __proto__: null, name: e, version: t, description: r, bin: o, repository: i, homepage: s, author: u, license: "MIT", main: c, engines: l, dependencies: p, devDependencies: f, scripts: d, default: h }); function g() { } function y(e, t, n, r, o) { for (var i = 0, s = t.length, a = 0, u = 0; i < s; i++) {
                var c = t[i];
                if (c.removed) {
                    if (c.value = e.join(r.slice(u, u + c.count)), u += c.count, i && t[i - 1].added) {
                        var l = t[i - 1];
                        t[i - 1] = t[i], t[i] = l;
                    }
                }
                else {
                    if (!c.added && o) {
                        var p = n.slice(a, a + c.count);
                        p = p.map((function (e, t) { var n = r[u + t]; return n.length > e.length ? n : e; })), c.value = e.join(p);
                    }
                    else
                        c.value = e.join(n.slice(a, a + c.count));
                    a += c.count, c.added || (u += c.count);
                }
            } var f = t[s - 1]; return s > 1 && "string" == typeof f.value && (f.added || f.removed) && e.equals("", f.value) && (t[s - 2].value += f.value, t.pop()), t; } function v(e) { return { newPos: e.newPos, components: e.components.slice(0) }; } g.prototype = { diff: function (e, t) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r = n.callback; "function" == typeof n && (r = n, n = {}), this.options = n; var o = this; function i(e) { return r ? (setTimeout((function () { r(void 0, e); }), 0), !0) : e; } e = this.castInput(e), t = this.castInput(t), e = this.removeEmpty(this.tokenize(e)); var s = (t = this.removeEmpty(this.tokenize(t))).length, a = e.length, u = 1, c = s + a, l = [{ newPos: -1, components: [] }], p = this.extractCommon(l[0], t, e, 0); if (l[0].newPos + 1 >= s && p + 1 >= a)
                    return i([{ value: this.join(t), count: t.length }]); function f() { for (var n = -1 * u; n <= u; n += 2) {
                    var r = void 0, c = l[n - 1], p = l[n + 1], f = (p ? p.newPos : 0) - n;
                    c && (l[n - 1] = void 0);
                    var d = c && c.newPos + 1 < s, h = p && 0 <= f && f < a;
                    if (d || h) {
                        if (!d || h && c.newPos < p.newPos ? (r = v(p), o.pushComponent(r.components, void 0, !0)) : ((r = c).newPos++, o.pushComponent(r.components, !0, void 0)), f = o.extractCommon(r, t, e, n), r.newPos + 1 >= s && f + 1 >= a)
                            return i(y(o, r.components, t, e, o.useLongestToken));
                        l[n] = r;
                    }
                    else
                        l[n] = void 0;
                } u++; } if (r)
                    !function e() { setTimeout((function () { if (u > c)
                        return r(); f() || e(); }), 0); }();
                else
                    for (; u <= c;) {
                        var d = f();
                        if (d)
                            return d;
                    } }, pushComponent: function (e, t, n) { var r = e[e.length - 1]; r && r.added === t && r.removed === n ? e[e.length - 1] = { count: r.count + 1, added: t, removed: n } : e.push({ count: 1, added: t, removed: n }); }, extractCommon: function (e, t, n, r) { for (var o = t.length, i = n.length, s = e.newPos, a = s - r, u = 0; s + 1 < o && a + 1 < i && this.equals(t[s + 1], n[a + 1]);)
                    s++, a++, u++; return u && e.components.push({ count: u }), e.newPos = s, a; }, equals: function (e, t) { return this.options.comparator ? this.options.comparator(e, t) : e === t || this.options.ignoreCase && e.toLowerCase() === t.toLowerCase(); }, removeEmpty: function (e) { for (var t = [], n = 0; n < e.length; n++)
                    e[n] && t.push(e[n]); return t; }, castInput: function (e) { return e; }, tokenize: function (e) { return e.split(""); }, join: function (e) { return e.join(""); } }; var b = new g; function D(e, t) { if ("function" == typeof e)
                t.callback = e;
            else if (e)
                for (var n in e)
                    e.hasOwnProperty(n) && (t[n] = e[n]); return t; } var E = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/, C = /\S/, w = new g; w.equals = function (e, t) { return this.options.ignoreCase && (e = e.toLowerCase(), t = t.toLowerCase()), e === t || this.options.ignoreWhitespace && !C.test(e) && !C.test(t); }, w.tokenize = function (e) { for (var t = e.split(/(\s+|[()[\]{}'"]|\b)/), n = 0; n < t.length - 1; n++)
                !t[n + 1] && t[n + 2] && E.test(t[n]) && E.test(t[n + 2]) && (t[n] += t[n + 2], t.splice(n + 1, 2), n--); return t; }; var A = new g; function S(e, t, n) { return A.diff(e, t, n); } A.tokenize = function (e) { var t = [], n = e.split(/(\n|\r\n)/); n[n.length - 1] || n.pop(); for (var r = 0; r < n.length; r++) {
                var o = n[r];
                r % 2 && !this.options.newlineIsToken ? t[t.length - 1] += o : (this.options.ignoreWhitespace && (o = o.trim()), t.push(o));
            } return t; }; var x = new g; x.tokenize = function (e) { return e.split(/(\S.+?[.!?])(?=\s+|$)/); }; var T = new g; function k(e) { return (k = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e; } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e; })(e); } function F(e) { return function (e) { if (Array.isArray(e)) {
                for (var t = 0, n = new Array(e.length); t < e.length; t++)
                    n[t] = e[t];
                return n;
            } }(e) || function (e) { if (Symbol.iterator in Object(e) || "[object Arguments]" === Object.prototype.toString.call(e))
                return Array.from(e); }(e) || function () { throw new TypeError("Invalid attempt to spread non-iterable instance"); }(); } T.tokenize = function (e) { return e.split(/([{}:;,]|\s+)/); }; var O = Object.prototype.toString, _ = new g; function N(e, t, n, r, o) { var i, s; for (t = t || [], n = n || [], r && (e = r(o, e)), i = 0; i < t.length; i += 1)
                if (t[i] === e)
                    return n[i]; if ("[object Array]" === O.call(e)) {
                for (t.push(e), s = new Array(e.length), n.push(s), i = 0; i < e.length; i += 1)
                    s[i] = N(e[i], t, n, r, o);
                return t.pop(), n.pop(), s;
            } if (e && e.toJSON && (e = e.toJSON()), "object" === k(e) && null !== e) {
                t.push(e), s = {}, n.push(s);
                var a, u = [];
                for (a in e)
                    e.hasOwnProperty(a) && u.push(a);
                for (u.sort(), i = 0; i < u.length; i += 1)
                    s[a = u[i]] = N(e[a], t, n, r, a);
                t.pop(), n.pop();
            }
            else
                s = e; return s; } _.useLongestToken = !0, _.tokenize = A.tokenize, _.castInput = function (e) { var t = this.options, n = t.undefinedReplacement, r = t.stringifyReplacer, o = void 0 === r ? function (e, t) { return void 0 === t ? n : t; } : r; return "string" == typeof e ? e : JSON.stringify(N(e, null, null, o), o, "  "); }, _.equals = function (e, t) { return g.prototype.equals.call(_, e.replace(/,([\r\n])/g, "$1"), t.replace(/,([\r\n])/g, "$1")); }; var P = new g; function M(e) { var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = e.split(/\r\n|[\n\v\f\r\x85]/), r = e.match(/\r\n|[\n\v\f\r\x85]/g) || [], o = [], i = 0; function s() { var e = {}; for (o.push(e); i < n.length;) {
                var r = n[i];
                if (/^(\-\-\-|\+\+\+|@@)\s/.test(r))
                    break;
                var s = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(r);
                s && (e.index = s[1]), i++;
            } for (a(e), a(e), e.hunks = []; i < n.length;) {
                var c = n[i];
                if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(c))
                    break;
                if (/^@@/.test(c))
                    e.hunks.push(u());
                else {
                    if (c && t.strict)
                        throw new Error("Unknown line " + (i + 1) + " " + JSON.stringify(c));
                    i++;
                }
            } } function a(e) { var t = /^(---|\+\+\+)\s+(.*)$/.exec(n[i]); if (t) {
                var r = "---" === t[1] ? "old" : "new", o = t[2].split("\t", 2), s = o[0].replace(/\\\\/g, "\\");
                /^".*"$/.test(s) && (s = s.substr(1, s.length - 2)), e[r + "FileName"] = s, e[r + "Header"] = (o[1] || "").trim(), i++;
            } } function u() { for (var e = i, o = n[i++].split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/), s = { oldStart: +o[1], oldLines: +o[2] || 1, newStart: +o[3], newLines: +o[4] || 1, lines: [], linedelimiters: [] }, a = 0, u = 0; i < n.length && !(0 === n[i].indexOf("--- ") && i + 2 < n.length && 0 === n[i + 1].indexOf("+++ ") && 0 === n[i + 2].indexOf("@@")); i++) {
                var c = 0 == n[i].length && i != n.length - 1 ? " " : n[i][0];
                if ("+" !== c && "-" !== c && " " !== c && "\\" !== c)
                    break;
                s.lines.push(n[i]), s.linedelimiters.push(r[i] || "\n"), "+" === c ? a++ : "-" === c ? u++ : " " === c && (a++, u++);
            } if (a || 1 !== s.newLines || (s.newLines = 0), u || 1 !== s.oldLines || (s.oldLines = 0), t.strict) {
                if (a !== s.newLines)
                    throw new Error("Added line count did not match for hunk at line " + (e + 1));
                if (u !== s.oldLines)
                    throw new Error("Removed line count did not match for hunk at line " + (e + 1));
            } return s; } for (; i < n.length;)
                s(); return o; } function R(e, t, n) { var r = !0, o = !1, i = !1, s = 1; return function a() { if (r && !i) {
                if (o ? s++ : r = !1, e + s <= n)
                    return s;
                i = !0;
            } if (!o)
                return i || (r = !0), t <= e - s ? -s++ : (o = !0, a()); }; } function I(e, t) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; if ("string" == typeof t && (t = M(t)), Array.isArray(t)) {
                if (t.length > 1)
                    throw new Error("applyPatch only works with a single input.");
                t = t[0];
            } var r, o, i = e.split(/\r\n|[\n\v\f\r\x85]/), s = e.match(/\r\n|[\n\v\f\r\x85]/g) || [], a = t.hunks, u = n.compareLine || function (e, t, n, r) { return t === r; }, c = 0, l = n.fuzzFactor || 0, p = 0, f = 0; function d(e, t) { for (var n = 0; n < e.lines.length; n++) {
                var r = e.lines[n], o = r.length > 0 ? r[0] : " ", s = r.length > 0 ? r.substr(1) : r;
                if (" " === o || "-" === o) {
                    if (!u(t + 1, i[t], o, s) && ++c > l)
                        return !1;
                    t++;
                }
            } return !0; } for (var h = 0; h < a.length; h++) {
                for (var m = a[h], g = i.length - m.oldLines, y = 0, v = f + m.oldStart - 1, b = R(v, p, g); void 0 !== y; y = b())
                    if (d(m, v + y)) {
                        m.offset = f += y;
                        break;
                    }
                if (void 0 === y)
                    return !1;
                p = m.offset + m.oldStart + m.oldLines;
            } for (var D = 0, E = 0; E < a.length; E++) {
                var C = a[E], w = C.oldStart + C.offset + D - 1;
                D += C.newLines - C.oldLines, w < 0 && (w = 0);
                for (var A = 0; A < C.lines.length; A++) {
                    var S = C.lines[A], x = S.length > 0 ? S[0] : " ", T = S.length > 0 ? S.substr(1) : S, k = C.linedelimiters[A];
                    if (" " === x)
                        w++;
                    else if ("-" === x)
                        i.splice(w, 1), s.splice(w, 1);
                    else if ("+" === x)
                        i.splice(w, 0, T), s.splice(w, 0, k), w++;
                    else if ("\\" === x) {
                        var F = C.lines[A - 1] ? C.lines[A - 1][0] : null;
                        "+" === F ? r = !0 : "-" === F && (o = !0);
                    }
                }
            } if (r)
                for (; !i[i.length - 1];)
                    i.pop(), s.pop();
            else
                o && (i.push(""), s.push("\n")); for (var O = 0; O < i.length - 1; O++)
                i[O] = i[O] + s[O]; return i.join(""); } function j(e, t, n, r, o, i, s) { s || (s = {}), void 0 === s.context && (s.context = 4); var a = S(n, r, s); function u(e) { return e.map((function (e) { return " " + e; })); } a.push({ value: "", lines: [] }); for (var c = [], l = 0, p = 0, f = [], d = 1, h = 1, m = function (e) { var t = a[e], o = t.lines || t.value.replace(/\n$/, "").split("\n"); if (t.lines = o, t.added || t.removed) {
                var i;
                if (!l) {
                    var m = a[e - 1];
                    l = d, p = h, m && (f = s.context > 0 ? u(m.lines.slice(-s.context)) : [], l -= f.length, p -= f.length);
                }
                (i = f).push.apply(i, F(o.map((function (e) { return (t.added ? "+" : "-") + e; })))), t.added ? h += o.length : d += o.length;
            }
            else {
                if (l)
                    if (o.length <= 2 * s.context && e < a.length - 2) {
                        var g;
                        (g = f).push.apply(g, F(u(o)));
                    }
                    else {
                        var y, v = Math.min(o.length, s.context);
                        (y = f).push.apply(y, F(u(o.slice(0, v))));
                        var b = { oldStart: l, oldLines: d - l + v, newStart: p, newLines: h - p + v, lines: f };
                        if (e >= a.length - 2 && o.length <= s.context) {
                            var D = /\n$/.test(n), E = /\n$/.test(r), C = 0 == o.length && f.length > b.oldLines;
                            !D && C && f.splice(b.oldLines, 0, "\\ No newline at end of file"), (D || C) && E || f.push("\\ No newline at end of file");
                        }
                        c.push(b), l = 0, p = 0, f = [];
                    }
                d += o.length, h += o.length;
            } }, g = 0; g < a.length; g++)
                m(g); return { oldFileName: e, newFileName: t, oldHeader: o, newHeader: i, hunks: c }; } function B(e, t, n, r, o, i, s) { var a = j(e, t, n, r, o, i, s), u = []; e == t && u.push("Index: " + e), u.push("==================================================================="), u.push("--- " + a.oldFileName + (void 0 === a.oldHeader ? "" : "\t" + a.oldHeader)), u.push("+++ " + a.newFileName + (void 0 === a.newHeader ? "" : "\t" + a.newHeader)); for (var c = 0; c < a.hunks.length; c++) {
                var l = a.hunks[c];
                u.push("@@ -" + l.oldStart + "," + l.oldLines + " +" + l.newStart + "," + l.newLines + " @@"), u.push.apply(u, l.lines);
            } return u.join("\n") + "\n"; } function L(e, t) { if (t.length > e.length)
                return !1; for (var n = 0; n < t.length; n++)
                if (t[n] !== e[n])
                    return !1; return !0; } function q(e) { var t = te(e.lines), n = t.oldLines, r = t.newLines; void 0 !== n ? e.oldLines = n : delete e.oldLines, void 0 !== r ? e.newLines = r : delete e.newLines; } function $(e, t) { if ("string" == typeof e) {
                if (/^@@/m.test(e) || /^Index:/m.test(e))
                    return M(e)[0];
                if (!t)
                    throw new Error("Must provide a base reference or pass in a patch");
                return j(void 0, void 0, t, e);
            } return e; } function U(e) { return e.newFileName && e.newFileName !== e.oldFileName; } function V(e, t, n) { return t === n ? t : (e.conflict = !0, { mine: t, theirs: n }); } function W(e, t) { return e.oldStart < t.oldStart && e.oldStart + e.oldLines < t.oldStart; } function K(e, t) { return { oldStart: e.oldStart, oldLines: e.oldLines, newStart: e.newStart + t, newLines: e.newLines, lines: e.lines }; } function z(e, t, n, r, o) { var i = { offset: t, lines: n, index: 0 }, s = { offset: r, lines: o, index: 0 }; for (G(e, i, s), G(e, s, i); i.index < i.lines.length && s.index < s.lines.length;) {
                var a = i.lines[i.index], u = s.lines[s.index];
                if ("-" !== a[0] && "+" !== a[0] || "-" !== u[0] && "+" !== u[0])
                    if ("+" === a[0] && " " === u[0]) {
                        var c;
                        (c = e.lines).push.apply(c, F(Q(i)));
                    }
                    else if ("+" === u[0] && " " === a[0]) {
                        var l;
                        (l = e.lines).push.apply(l, F(Q(s)));
                    }
                    else
                        "-" === a[0] && " " === u[0] ? Y(e, i, s) : "-" === u[0] && " " === a[0] ? Y(e, s, i, !0) : a === u ? (e.lines.push(a), i.index++, s.index++) : J(e, Q(i), Q(s));
                else
                    H(e, i, s);
            } X(e, i), X(e, s), q(e); } function H(e, t, n) { var r, o, i = Q(t), s = Q(n); if (Z(i) && Z(s)) {
                var a, u;
                if (L(i, s) && ee(n, i, i.length - s.length))
                    return void (a = e.lines).push.apply(a, F(i));
                if (L(s, i) && ee(t, s, s.length - i.length))
                    return void (u = e.lines).push.apply(u, F(s));
            }
            else if (o = s, (r = i).length === o.length && L(r, o)) {
                var c;
                return void (c = e.lines).push.apply(c, F(i));
            } J(e, i, s); } function Y(e, t, n, r) { var o, i = Q(t), s = function (e, t) { for (var n = [], r = [], o = 0, i = !1, s = !1; o < t.length && e.index < e.lines.length;) {
                var a = e.lines[e.index], u = t[o];
                if ("+" === u[0])
                    break;
                if (i = i || " " !== a[0], r.push(u), o++, "+" === a[0])
                    for (s = !0; "+" === a[0];)
                        n.push(a), a = e.lines[++e.index];
                u.substr(1) === a.substr(1) ? (n.push(a), e.index++) : s = !0;
            } if ("+" === (t[o] || "")[0] && i && (s = !0), s)
                return n; for (; o < t.length;)
                r.push(t[o++]); return { merged: r, changes: n }; }(n, i); s.merged ? (o = e.lines).push.apply(o, F(s.merged)) : J(e, r ? s : i, r ? i : s); } function J(e, t, n) { e.conflict = !0, e.lines.push({ conflict: !0, mine: t, theirs: n }); } function G(e, t, n) { for (; t.offset < n.offset && t.index < t.lines.length;) {
                var r = t.lines[t.index++];
                e.lines.push(r), t.offset++;
            } } function X(e, t) { for (; t.index < t.lines.length;) {
                var n = t.lines[t.index++];
                e.lines.push(n);
            } } function Q(e) { for (var t = [], n = e.lines[e.index][0]; e.index < e.lines.length;) {
                var r = e.lines[e.index];
                if ("-" === n && "+" === r[0] && (n = "+"), n !== r[0])
                    break;
                t.push(r), e.index++;
            } return t; } function Z(e) { return e.reduce((function (e, t) { return e && "-" === t[0]; }), !0); } function ee(e, t, n) { for (var r = 0; r < n; r++) {
                var o = t[t.length - n + r].substr(1);
                if (e.lines[e.index + r] !== " " + o)
                    return !1;
            } return e.index += n, !0; } function te(e) { var t = 0, n = 0; return e.forEach((function (e) { if ("string" != typeof e) {
                var r = te(e.mine), o = te(e.theirs);
                void 0 !== t && (r.oldLines === o.oldLines ? t += r.oldLines : t = void 0), void 0 !== n && (r.newLines === o.newLines ? n += r.newLines : n = void 0);
            }
            else
                void 0 === n || "+" !== e[0] && " " !== e[0] || n++, void 0 === t || "-" !== e[0] && " " !== e[0] || t++; })), { oldLines: t, newLines: n }; } P.tokenize = function (e) { return e.slice(); }, P.join = P.removeEmpty = function (e) { return e; }; var ne = Object.freeze({ __proto__: null, Diff: g, diffChars: function (e, t, n) { return b.diff(e, t, n); }, diffWords: function (e, t, n) { return n = D(n, { ignoreWhitespace: !0 }), w.diff(e, t, n); }, diffWordsWithSpace: function (e, t, n) { return w.diff(e, t, n); }, diffLines: S, diffTrimmedLines: function (e, t, n) { var r = D(n, { ignoreWhitespace: !0 }); return A.diff(e, t, r); }, diffSentences: function (e, t, n) { return x.diff(e, t, n); }, diffCss: function (e, t, n) { return T.diff(e, t, n); }, diffJson: function (e, t, n) { return _.diff(e, t, n); }, diffArrays: function (e, t, n) { return P.diff(e, t, n); }, structuredPatch: j, createTwoFilesPatch: B, createPatch: function (e, t, n, r, o, i) { return B(e, e, t, n, r, o, i); }, applyPatch: I, applyPatches: function (e, t) { "string" == typeof e && (e = M(e)); var n = 0; !function r() { var o = e[n++]; if (!o)
                    return t.complete(); t.loadFile(o, (function (e, n) { if (e)
                    return t.complete(e); var i = I(n, o, t); t.patched(o, i, (function (e) { if (e)
                    return t.complete(e); r(); })); })); }(); }, parsePatch: M, merge: function (e, t, n) { e = $(e, n), t = $(t, n); var r = {}; (e.index || t.index) && (r.index = e.index || t.index), (e.newFileName || t.newFileName) && (U(e) ? U(t) ? (r.oldFileName = V(r, e.oldFileName, t.oldFileName), r.newFileName = V(r, e.newFileName, t.newFileName), r.oldHeader = V(r, e.oldHeader, t.oldHeader), r.newHeader = V(r, e.newHeader, t.newHeader)) : (r.oldFileName = e.oldFileName, r.newFileName = e.newFileName, r.oldHeader = e.oldHeader, r.newHeader = e.newHeader) : (r.oldFileName = t.oldFileName || e.oldFileName, r.newFileName = t.newFileName || e.newFileName, r.oldHeader = t.oldHeader || e.oldHeader, r.newHeader = t.newHeader || e.newHeader)), r.hunks = []; for (var o = 0, i = 0, s = 0, a = 0; o < e.hunks.length || i < t.hunks.length;) {
                    var u = e.hunks[o] || { oldStart: 1 / 0 }, c = t.hunks[i] || { oldStart: 1 / 0 };
                    if (W(u, c))
                        r.hunks.push(K(u, s)), o++, a += u.newLines - u.oldLines;
                    else if (W(c, u))
                        r.hunks.push(K(c, a)), i++, s += c.newLines - c.oldLines;
                    else {
                        var l = { oldStart: Math.min(u.oldStart, c.oldStart), oldLines: 0, newStart: Math.min(u.newStart + s, c.oldStart + a), newLines: 0, lines: [] };
                        z(l, u.oldStart, u.lines, c.oldStart, c.lines), i++, o++, r.hunks.push(l);
                    }
                } return r; }, convertChangesToDMP: function (e) { for (var t, n, r = [], o = 0; o < e.length; o++)
                    n = (t = e[o]).added ? 1 : t.removed ? -1 : 0, r.push([n, t.value]); return r; }, convertChangesToXML: function (e) { for (var t = [], n = 0; n < e.length; n++) {
                    var r = e[n];
                    r.added ? t.push("<ins>") : r.removed && t.push("<del>"), t.push(r.value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;")), r.added ? t.push("</ins>") : r.removed && t.push("</del>");
                } return t.join(""); }, canonicalize: N }), re = Object.freeze({ __proto__: null, default: {} }); const oe = /[\\/]/; function ie(e) { return e.split(oe).pop(); } var se = Object.freeze({ __proto__: null, extname: function (e) { const t = ie(e), n = t.lastIndexOf("."); return -1 === n ? "" : t.slice(n); }, basename: ie, isAbsolute: function () { return !0; } }), ae = void 0 !== n.g ? n.g : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, ue = [], ce = [], le = "undefined" != typeof Uint8Array ? Uint8Array : Array, pe = !1; function fe() { pe = !0; for (var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", t = 0, n = e.length; t < n; ++t)
                ue[t] = e[t], ce[e.charCodeAt(t)] = t; ce["-".charCodeAt(0)] = 62, ce["_".charCodeAt(0)] = 63; } function de(e, t, n) { for (var r, o, i = [], s = t; s < n; s += 3)
                r = (e[s] << 16) + (e[s + 1] << 8) + e[s + 2], i.push(ue[(o = r) >> 18 & 63] + ue[o >> 12 & 63] + ue[o >> 6 & 63] + ue[63 & o]); return i.join(""); } function he(e) { var t; pe || fe(); for (var n = e.length, r = n % 3, o = "", i = [], s = 16383, a = 0, u = n - r; a < u; a += s)
                i.push(de(e, a, a + s > u ? u : a + s)); return 1 === r ? (t = e[n - 1], o += ue[t >> 2], o += ue[t << 4 & 63], o += "==") : 2 === r && (t = (e[n - 2] << 8) + e[n - 1], o += ue[t >> 10], o += ue[t >> 4 & 63], o += ue[t << 2 & 63], o += "="), i.push(o), i.join(""); } function me(e, t, n, r, o) { var i, s, a = 8 * o - r - 1, u = (1 << a) - 1, c = u >> 1, l = -7, p = n ? o - 1 : 0, f = n ? -1 : 1, d = e[t + p]; for (p += f, i = d & (1 << -l) - 1, d >>= -l, l += a; l > 0; i = 256 * i + e[t + p], p += f, l -= 8)
                ; for (s = i & (1 << -l) - 1, i >>= -l, l += r; l > 0; s = 256 * s + e[t + p], p += f, l -= 8)
                ; if (0 === i)
                i = 1 - c;
            else {
                if (i === u)
                    return s ? NaN : 1 / 0 * (d ? -1 : 1);
                s += Math.pow(2, r), i -= c;
            } return (d ? -1 : 1) * s * Math.pow(2, i - r); } function ge(e, t, n, r, o, i) { var s, a, u, c = 8 * i - o - 1, l = (1 << c) - 1, p = l >> 1, f = 23 === o ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = r ? 0 : i - 1, h = r ? 1 : -1, m = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0; for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (a = isNaN(t) ? 1 : 0, s = l) : (s = Math.floor(Math.log(t) / Math.LN2), t * (u = Math.pow(2, -s)) < 1 && (s--, u *= 2), (t += s + p >= 1 ? f / u : f * Math.pow(2, 1 - p)) * u >= 2 && (s++, u /= 2), s + p >= l ? (a = 0, s = l) : s + p >= 1 ? (a = (t * u - 1) * Math.pow(2, o), s += p) : (a = t * Math.pow(2, p - 1) * Math.pow(2, o), s = 0)); o >= 8; e[n + d] = 255 & a, d += h, a /= 256, o -= 8)
                ; for (s = s << o | a, c += o; c > 0; e[n + d] = 255 & s, d += h, s /= 256, c -= 8)
                ; e[n + d - h] |= 128 * m; } var ye = {}.toString, ve = Array.isArray || function (e) { return "[object Array]" == ye.call(e); }; function be() { return Ee.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823; } function De(e, t) { if (be() < t)
                throw new RangeError("Invalid typed array length"); return Ee.TYPED_ARRAY_SUPPORT ? (e = new Uint8Array(t)).__proto__ = Ee.prototype : (null === e && (e = new Ee(t)), e.length = t), e; } function Ee(e, t, n) { if (!(Ee.TYPED_ARRAY_SUPPORT || this instanceof Ee))
                return new Ee(e, t, n); if ("number" == typeof e) {
                if ("string" == typeof t)
                    throw new Error("If encoding is specified then the first argument must be a string");
                return Ae(this, e);
            } return Ce(this, e, t, n); } function Ce(e, t, n, r) { if ("number" == typeof t)
                throw new TypeError('"value" argument must not be a number'); return "undefined" != typeof ArrayBuffer && t instanceof ArrayBuffer ? function (e, t, n, r) { if (t.byteLength, n < 0 || t.byteLength < n)
                throw new RangeError("'offset' is out of bounds"); if (t.byteLength < n + (r || 0))
                throw new RangeError("'length' is out of bounds"); return t = void 0 === n && void 0 === r ? new Uint8Array(t) : void 0 === r ? new Uint8Array(t, n) : new Uint8Array(t, n, r), Ee.TYPED_ARRAY_SUPPORT ? (e = t).__proto__ = Ee.prototype : e = Se(e, t), e; }(e, t, n, r) : "string" == typeof t ? function (e, t, n) { if ("string" == typeof n && "" !== n || (n = "utf8"), !Ee.isEncoding(n))
                throw new TypeError('"encoding" must be a valid string encoding'); var r = 0 | ke(t, n), o = (e = De(e, r)).write(t, n); return o !== r && (e = e.slice(0, o)), e; }(e, t, n) : function (e, t) { if (Te(t)) {
                var n = 0 | xe(t.length);
                return 0 === (e = De(e, n)).length || t.copy(e, 0, 0, n), e;
            } if (t) {
                if ("undefined" != typeof ArrayBuffer && t.buffer instanceof ArrayBuffer || "length" in t)
                    return "number" != typeof t.length || (r = t.length) != r ? De(e, 0) : Se(e, t);
                if ("Buffer" === t.type && ve(t.data))
                    return Se(e, t.data);
            } var r; throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object."); }(e, t); } function we(e) { if ("number" != typeof e)
                throw new TypeError('"size" argument must be a number'); if (e < 0)
                throw new RangeError('"size" argument must not be negative'); } function Ae(e, t) { if (we(t), e = De(e, t < 0 ? 0 : 0 | xe(t)), !Ee.TYPED_ARRAY_SUPPORT)
                for (var n = 0; n < t; ++n)
                    e[n] = 0; return e; } function Se(e, t) { var n = t.length < 0 ? 0 : 0 | xe(t.length); e = De(e, n); for (var r = 0; r < n; r += 1)
                e[r] = 255 & t[r]; return e; } function xe(e) { if (e >= be())
                throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + be().toString(16) + " bytes"); return 0 | e; } function Te(e) { return !(null == e || !e._isBuffer); } function ke(e, t) { if (Te(e))
                return e.length; if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(e) || e instanceof ArrayBuffer))
                return e.byteLength; "string" != typeof e && (e = "" + e); var n = e.length; if (0 === n)
                return 0; for (var r = !1;;)
                switch (t) {
                    case "ascii":
                    case "latin1":
                    case "binary": return n;
                    case "utf8":
                    case "utf-8":
                    case void 0: return et(e).length;
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le": return 2 * n;
                    case "hex": return n >>> 1;
                    case "base64": return tt(e).length;
                    default:
                        if (r)
                            return et(e).length;
                        t = ("" + t).toLowerCase(), r = !0;
                } } function Fe(e, t, n) { var r = !1; if ((void 0 === t || t < 0) && (t = 0), t > this.length)
                return ""; if ((void 0 === n || n > this.length) && (n = this.length), n <= 0)
                return ""; if ((n >>>= 0) <= (t >>>= 0))
                return ""; for (e || (e = "utf8");;)
                switch (e) {
                    case "hex": return We(this, t, n);
                    case "utf8":
                    case "utf-8": return qe(this, t, n);
                    case "ascii": return Ue(this, t, n);
                    case "latin1":
                    case "binary": return Ve(this, t, n);
                    case "base64": return Le(this, t, n);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le": return Ke(this, t, n);
                    default:
                        if (r)
                            throw new TypeError("Unknown encoding: " + e);
                        e = (e + "").toLowerCase(), r = !0;
                } } function Oe(e, t, n) { var r = e[t]; e[t] = e[n], e[n] = r; } function _e(e, t, n, r, o) { if (0 === e.length)
                return -1; if ("string" == typeof n ? (r = n, n = 0) : n > 2147483647 ? n = 2147483647 : n < -2147483648 && (n = -2147483648), n = +n, isNaN(n) && (n = o ? 0 : e.length - 1), n < 0 && (n = e.length + n), n >= e.length) {
                if (o)
                    return -1;
                n = e.length - 1;
            }
            else if (n < 0) {
                if (!o)
                    return -1;
                n = 0;
            } if ("string" == typeof t && (t = Ee.from(t, r)), Te(t))
                return 0 === t.length ? -1 : Ne(e, t, n, r, o); if ("number" == typeof t)
                return t &= 255, Ee.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? o ? Uint8Array.prototype.indexOf.call(e, t, n) : Uint8Array.prototype.lastIndexOf.call(e, t, n) : Ne(e, [t], n, r, o); throw new TypeError("val must be string, number or Buffer"); } function Ne(e, t, n, r, o) { var i, s = 1, a = e.length, u = t.length; if (void 0 !== r && ("ucs2" === (r = String(r).toLowerCase()) || "ucs-2" === r || "utf16le" === r || "utf-16le" === r)) {
                if (e.length < 2 || t.length < 2)
                    return -1;
                s = 2, a /= 2, u /= 2, n /= 2;
            } function c(e, t) { return 1 === s ? e[t] : e.readUInt16BE(t * s); } if (o) {
                var l = -1;
                for (i = n; i < a; i++)
                    if (c(e, i) === c(t, -1 === l ? 0 : i - l)) {
                        if (-1 === l && (l = i), i - l + 1 === u)
                            return l * s;
                    }
                    else
                        -1 !== l && (i -= i - l), l = -1;
            }
            else
                for (n + u > a && (n = a - u), i = n; i >= 0; i--) {
                    for (var p = !0, f = 0; f < u; f++)
                        if (c(e, i + f) !== c(t, f)) {
                            p = !1;
                            break;
                        }
                    if (p)
                        return i;
                } return -1; } function Pe(e, t, n, r) { n = Number(n) || 0; var o = e.length - n; r ? (r = Number(r)) > o && (r = o) : r = o; var i = t.length; if (i % 2 != 0)
                throw new TypeError("Invalid hex string"); r > i / 2 && (r = i / 2); for (var s = 0; s < r; ++s) {
                var a = parseInt(t.substr(2 * s, 2), 16);
                if (isNaN(a))
                    return s;
                e[n + s] = a;
            } return s; } function Me(e, t, n, r) { return nt(et(t, e.length - n), e, n, r); } function Re(e, t, n, r) { return nt(function (e) { for (var t = [], n = 0; n < e.length; ++n)
                t.push(255 & e.charCodeAt(n)); return t; }(t), e, n, r); } function Ie(e, t, n, r) { return Re(e, t, n, r); } function je(e, t, n, r) { return nt(tt(t), e, n, r); } function Be(e, t, n, r) { return nt(function (e, t) { for (var n, r, o, i = [], s = 0; s < e.length && !((t -= 2) < 0); ++s)
                r = (n = e.charCodeAt(s)) >> 8, o = n % 256, i.push(o), i.push(r); return i; }(t, e.length - n), e, n, r); } function Le(e, t, n) { return 0 === t && n === e.length ? he(e) : he(e.slice(t, n)); } function qe(e, t, n) { n = Math.min(e.length, n); for (var r = [], o = t; o < n;) {
                var i, s, a, u, c = e[o], l = null, p = c > 239 ? 4 : c > 223 ? 3 : c > 191 ? 2 : 1;
                if (o + p <= n)
                    switch (p) {
                        case 1:
                            c < 128 && (l = c);
                            break;
                        case 2:
                            128 == (192 & (i = e[o + 1])) && (u = (31 & c) << 6 | 63 & i) > 127 && (l = u);
                            break;
                        case 3:
                            i = e[o + 1], s = e[o + 2], 128 == (192 & i) && 128 == (192 & s) && (u = (15 & c) << 12 | (63 & i) << 6 | 63 & s) > 2047 && (u < 55296 || u > 57343) && (l = u);
                            break;
                        case 4: i = e[o + 1], s = e[o + 2], a = e[o + 3], 128 == (192 & i) && 128 == (192 & s) && 128 == (192 & a) && (u = (15 & c) << 18 | (63 & i) << 12 | (63 & s) << 6 | 63 & a) > 65535 && u < 1114112 && (l = u);
                    }
                null === l ? (l = 65533, p = 1) : l > 65535 && (l -= 65536, r.push(l >>> 10 & 1023 | 55296), l = 56320 | 1023 & l), r.push(l), o += p;
            } return function (e) { var t = e.length; if (t <= $e)
                return String.fromCharCode.apply(String, e); for (var n = "", r = 0; r < t;)
                n += String.fromCharCode.apply(String, e.slice(r, r += $e)); return n; }(r); } Ee.TYPED_ARRAY_SUPPORT = void 0 === ae.TYPED_ARRAY_SUPPORT || ae.TYPED_ARRAY_SUPPORT, Ee.poolSize = 8192, Ee._augment = function (e) { return e.__proto__ = Ee.prototype, e; }, Ee.from = function (e, t, n) { return Ce(null, e, t, n); }, Ee.TYPED_ARRAY_SUPPORT && (Ee.prototype.__proto__ = Uint8Array.prototype, Ee.__proto__ = Uint8Array), Ee.alloc = function (e, t, n) { return function (e, t, n, r) { return we(t), t <= 0 ? De(e, t) : void 0 !== n ? "string" == typeof r ? De(e, t).fill(n, r) : De(e, t).fill(n) : De(e, t); }(null, e, t, n); }, Ee.allocUnsafe = function (e) { return Ae(null, e); }, Ee.allocUnsafeSlow = function (e) { return Ae(null, e); }, Ee.isBuffer = function (e) { return null != e && (!!e._isBuffer || rt(e) || function (e) { return "function" == typeof e.readFloatLE && "function" == typeof e.slice && rt(e.slice(0, 0)); }(e)); }, Ee.compare = function (e, t) { if (!Te(e) || !Te(t))
                throw new TypeError("Arguments must be Buffers"); if (e === t)
                return 0; for (var n = e.length, r = t.length, o = 0, i = Math.min(n, r); o < i; ++o)
                if (e[o] !== t[o]) {
                    n = e[o], r = t[o];
                    break;
                } return n < r ? -1 : r < n ? 1 : 0; }, Ee.isEncoding = function (e) { switch (String(e).toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le": return !0;
                default: return !1;
            } }, Ee.concat = function (e, t) { if (!ve(e))
                throw new TypeError('"list" argument must be an Array of Buffers'); if (0 === e.length)
                return Ee.alloc(0); var n; if (void 0 === t)
                for (t = 0, n = 0; n < e.length; ++n)
                    t += e[n].length; var r = Ee.allocUnsafe(t), o = 0; for (n = 0; n < e.length; ++n) {
                var i = e[n];
                if (!Te(i))
                    throw new TypeError('"list" argument must be an Array of Buffers');
                i.copy(r, o), o += i.length;
            } return r; }, Ee.byteLength = ke, Ee.prototype._isBuffer = !0, Ee.prototype.swap16 = function () { var e = this.length; if (e % 2 != 0)
                throw new RangeError("Buffer size must be a multiple of 16-bits"); for (var t = 0; t < e; t += 2)
                Oe(this, t, t + 1); return this; }, Ee.prototype.swap32 = function () { var e = this.length; if (e % 4 != 0)
                throw new RangeError("Buffer size must be a multiple of 32-bits"); for (var t = 0; t < e; t += 4)
                Oe(this, t, t + 3), Oe(this, t + 1, t + 2); return this; }, Ee.prototype.swap64 = function () { var e = this.length; if (e % 8 != 0)
                throw new RangeError("Buffer size must be a multiple of 64-bits"); for (var t = 0; t < e; t += 8)
                Oe(this, t, t + 7), Oe(this, t + 1, t + 6), Oe(this, t + 2, t + 5), Oe(this, t + 3, t + 4); return this; }, Ee.prototype.toString = function () { var e = 0 | this.length; return 0 === e ? "" : 0 === arguments.length ? qe(this, 0, e) : Fe.apply(this, arguments); }, Ee.prototype.equals = function (e) { if (!Te(e))
                throw new TypeError("Argument must be a Buffer"); return this === e || 0 === Ee.compare(this, e); }, Ee.prototype.inspect = function () { var e = ""; return this.length > 0 && (e = this.toString("hex", 0, 50).match(/.{2}/g).join(" "), this.length > 50 && (e += " ... ")), "<Buffer " + e + ">"; }, Ee.prototype.compare = function (e, t, n, r, o) { if (!Te(e))
                throw new TypeError("Argument must be a Buffer"); if (void 0 === t && (t = 0), void 0 === n && (n = e ? e.length : 0), void 0 === r && (r = 0), void 0 === o && (o = this.length), t < 0 || n > e.length || r < 0 || o > this.length)
                throw new RangeError("out of range index"); if (r >= o && t >= n)
                return 0; if (r >= o)
                return -1; if (t >= n)
                return 1; if (this === e)
                return 0; for (var i = (o >>>= 0) - (r >>>= 0), s = (n >>>= 0) - (t >>>= 0), a = Math.min(i, s), u = this.slice(r, o), c = e.slice(t, n), l = 0; l < a; ++l)
                if (u[l] !== c[l]) {
                    i = u[l], s = c[l];
                    break;
                } return i < s ? -1 : s < i ? 1 : 0; }, Ee.prototype.includes = function (e, t, n) { return -1 !== this.indexOf(e, t, n); }, Ee.prototype.indexOf = function (e, t, n) { return _e(this, e, t, n, !0); }, Ee.prototype.lastIndexOf = function (e, t, n) { return _e(this, e, t, n, !1); }, Ee.prototype.write = function (e, t, n, r) { if (void 0 === t)
                r = "utf8", n = this.length, t = 0;
            else if (void 0 === n && "string" == typeof t)
                r = t, n = this.length, t = 0;
            else {
                if (!isFinite(t))
                    throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                t |= 0, isFinite(n) ? (n |= 0, void 0 === r && (r = "utf8")) : (r = n, n = void 0);
            } var o = this.length - t; if ((void 0 === n || n > o) && (n = o), e.length > 0 && (n < 0 || t < 0) || t > this.length)
                throw new RangeError("Attempt to write outside buffer bounds"); r || (r = "utf8"); for (var i = !1;;)
                switch (r) {
                    case "hex": return Pe(this, e, t, n);
                    case "utf8":
                    case "utf-8": return Me(this, e, t, n);
                    case "ascii": return Re(this, e, t, n);
                    case "latin1":
                    case "binary": return Ie(this, e, t, n);
                    case "base64": return je(this, e, t, n);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le": return Be(this, e, t, n);
                    default:
                        if (i)
                            throw new TypeError("Unknown encoding: " + r);
                        r = ("" + r).toLowerCase(), i = !0;
                } }, Ee.prototype.toJSON = function () { return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) }; }; var $e = 4096; function Ue(e, t, n) { var r = ""; n = Math.min(e.length, n); for (var o = t; o < n; ++o)
                r += String.fromCharCode(127 & e[o]); return r; } function Ve(e, t, n) { var r = ""; n = Math.min(e.length, n); for (var o = t; o < n; ++o)
                r += String.fromCharCode(e[o]); return r; } function We(e, t, n) { var r, o = e.length; (!t || t < 0) && (t = 0), (!n || n < 0 || n > o) && (n = o); for (var i = "", s = t; s < n; ++s)
                i += (r = e[s]) < 16 ? "0" + r.toString(16) : r.toString(16); return i; } function Ke(e, t, n) { for (var r = e.slice(t, n), o = "", i = 0; i < r.length; i += 2)
                o += String.fromCharCode(r[i] + 256 * r[i + 1]); return o; } function ze(e, t, n) { if (e % 1 != 0 || e < 0)
                throw new RangeError("offset is not uint"); if (e + t > n)
                throw new RangeError("Trying to access beyond buffer length"); } function He(e, t, n, r, o, i) { if (!Te(e))
                throw new TypeError('"buffer" argument must be a Buffer instance'); if (t > o || t < i)
                throw new RangeError('"value" argument is out of bounds'); if (n + r > e.length)
                throw new RangeError("Index out of range"); } function Ye(e, t, n, r) { t < 0 && (t = 65535 + t + 1); for (var o = 0, i = Math.min(e.length - n, 2); o < i; ++o)
                e[n + o] = (t & 255 << 8 * (r ? o : 1 - o)) >>> 8 * (r ? o : 1 - o); } function Je(e, t, n, r) { t < 0 && (t = 4294967295 + t + 1); for (var o = 0, i = Math.min(e.length - n, 4); o < i; ++o)
                e[n + o] = t >>> 8 * (r ? o : 3 - o) & 255; } function Ge(e, t, n, r, o, i) { if (n + r > e.length)
                throw new RangeError("Index out of range"); if (n < 0)
                throw new RangeError("Index out of range"); } function Xe(e, t, n, r, o) { return o || Ge(e, 0, n, 4), ge(e, t, n, r, 23, 4), n + 4; } function Qe(e, t, n, r, o) { return o || Ge(e, 0, n, 8), ge(e, t, n, r, 52, 8), n + 8; } Ee.prototype.slice = function (e, t) { var n, r = this.length; if ((e = ~~e) < 0 ? (e += r) < 0 && (e = 0) : e > r && (e = r), (t = void 0 === t ? r : ~~t) < 0 ? (t += r) < 0 && (t = 0) : t > r && (t = r), t < e && (t = e), Ee.TYPED_ARRAY_SUPPORT)
                (n = this.subarray(e, t)).__proto__ = Ee.prototype;
            else {
                var o = t - e;
                n = new Ee(o, void 0);
                for (var i = 0; i < o; ++i)
                    n[i] = this[i + e];
            } return n; }, Ee.prototype.readUIntLE = function (e, t, n) { e |= 0, t |= 0, n || ze(e, t, this.length); for (var r = this[e], o = 1, i = 0; ++i < t && (o *= 256);)
                r += this[e + i] * o; return r; }, Ee.prototype.readUIntBE = function (e, t, n) { e |= 0, t |= 0, n || ze(e, t, this.length); for (var r = this[e + --t], o = 1; t > 0 && (o *= 256);)
                r += this[e + --t] * o; return r; }, Ee.prototype.readUInt8 = function (e, t) { return t || ze(e, 1, this.length), this[e]; }, Ee.prototype.readUInt16LE = function (e, t) { return t || ze(e, 2, this.length), this[e] | this[e + 1] << 8; }, Ee.prototype.readUInt16BE = function (e, t) { return t || ze(e, 2, this.length), this[e] << 8 | this[e + 1]; }, Ee.prototype.readUInt32LE = function (e, t) { return t || ze(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + 16777216 * this[e + 3]; }, Ee.prototype.readUInt32BE = function (e, t) { return t || ze(e, 4, this.length), 16777216 * this[e] + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]); }, Ee.prototype.readIntLE = function (e, t, n) { e |= 0, t |= 0, n || ze(e, t, this.length); for (var r = this[e], o = 1, i = 0; ++i < t && (o *= 256);)
                r += this[e + i] * o; return r >= (o *= 128) && (r -= Math.pow(2, 8 * t)), r; }, Ee.prototype.readIntBE = function (e, t, n) { e |= 0, t |= 0, n || ze(e, t, this.length); for (var r = t, o = 1, i = this[e + --r]; r > 0 && (o *= 256);)
                i += this[e + --r] * o; return i >= (o *= 128) && (i -= Math.pow(2, 8 * t)), i; }, Ee.prototype.readInt8 = function (e, t) { return t || ze(e, 1, this.length), 128 & this[e] ? -1 * (255 - this[e] + 1) : this[e]; }, Ee.prototype.readInt16LE = function (e, t) { t || ze(e, 2, this.length); var n = this[e] | this[e + 1] << 8; return 32768 & n ? 4294901760 | n : n; }, Ee.prototype.readInt16BE = function (e, t) { t || ze(e, 2, this.length); var n = this[e + 1] | this[e] << 8; return 32768 & n ? 4294901760 | n : n; }, Ee.prototype.readInt32LE = function (e, t) { return t || ze(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24; }, Ee.prototype.readInt32BE = function (e, t) { return t || ze(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]; }, Ee.prototype.readFloatLE = function (e, t) { return t || ze(e, 4, this.length), me(this, e, !0, 23, 4); }, Ee.prototype.readFloatBE = function (e, t) { return t || ze(e, 4, this.length), me(this, e, !1, 23, 4); }, Ee.prototype.readDoubleLE = function (e, t) { return t || ze(e, 8, this.length), me(this, e, !0, 52, 8); }, Ee.prototype.readDoubleBE = function (e, t) { return t || ze(e, 8, this.length), me(this, e, !1, 52, 8); }, Ee.prototype.writeUIntLE = function (e, t, n, r) { e = +e, t |= 0, n |= 0, r || He(this, e, t, n, Math.pow(2, 8 * n) - 1, 0); var o = 1, i = 0; for (this[t] = 255 & e; ++i < n && (o *= 256);)
                this[t + i] = e / o & 255; return t + n; }, Ee.prototype.writeUIntBE = function (e, t, n, r) { e = +e, t |= 0, n |= 0, r || He(this, e, t, n, Math.pow(2, 8 * n) - 1, 0); var o = n - 1, i = 1; for (this[t + o] = 255 & e; --o >= 0 && (i *= 256);)
                this[t + o] = e / i & 255; return t + n; }, Ee.prototype.writeUInt8 = function (e, t, n) { return e = +e, t |= 0, n || He(this, e, t, 1, 255, 0), Ee.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), this[t] = 255 & e, t + 1; }, Ee.prototype.writeUInt16LE = function (e, t, n) { return e = +e, t |= 0, n || He(this, e, t, 2, 65535, 0), Ee.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8) : Ye(this, e, t, !0), t + 2; }, Ee.prototype.writeUInt16BE = function (e, t, n) { return e = +e, t |= 0, n || He(this, e, t, 2, 65535, 0), Ee.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8, this[t + 1] = 255 & e) : Ye(this, e, t, !1), t + 2; }, Ee.prototype.writeUInt32LE = function (e, t, n) { return e = +e, t |= 0, n || He(this, e, t, 4, 4294967295, 0), Ee.TYPED_ARRAY_SUPPORT ? (this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = 255 & e) : Je(this, e, t, !0), t + 4; }, Ee.prototype.writeUInt32BE = function (e, t, n) { return e = +e, t |= 0, n || He(this, e, t, 4, 4294967295, 0), Ee.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e) : Je(this, e, t, !1), t + 4; }, Ee.prototype.writeIntLE = function (e, t, n, r) { if (e = +e, t |= 0, !r) {
                var o = Math.pow(2, 8 * n - 1);
                He(this, e, t, n, o - 1, -o);
            } var i = 0, s = 1, a = 0; for (this[t] = 255 & e; ++i < n && (s *= 256);)
                e < 0 && 0 === a && 0 !== this[t + i - 1] && (a = 1), this[t + i] = (e / s >> 0) - a & 255; return t + n; }, Ee.prototype.writeIntBE = function (e, t, n, r) { if (e = +e, t |= 0, !r) {
                var o = Math.pow(2, 8 * n - 1);
                He(this, e, t, n, o - 1, -o);
            } var i = n - 1, s = 1, a = 0; for (this[t + i] = 255 & e; --i >= 0 && (s *= 256);)
                e < 0 && 0 === a && 0 !== this[t + i + 1] && (a = 1), this[t + i] = (e / s >> 0) - a & 255; return t + n; }, Ee.prototype.writeInt8 = function (e, t, n) { return e = +e, t |= 0, n || He(this, e, t, 1, 127, -128), Ee.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), e < 0 && (e = 255 + e + 1), this[t] = 255 & e, t + 1; }, Ee.prototype.writeInt16LE = function (e, t, n) { return e = +e, t |= 0, n || He(this, e, t, 2, 32767, -32768), Ee.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8) : Ye(this, e, t, !0), t + 2; }, Ee.prototype.writeInt16BE = function (e, t, n) { return e = +e, t |= 0, n || He(this, e, t, 2, 32767, -32768), Ee.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8, this[t + 1] = 255 & e) : Ye(this, e, t, !1), t + 2; }, Ee.prototype.writeInt32LE = function (e, t, n) { return e = +e, t |= 0, n || He(this, e, t, 4, 2147483647, -2147483648), Ee.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24) : Je(this, e, t, !0), t + 4; }, Ee.prototype.writeInt32BE = function (e, t, n) { return e = +e, t |= 0, n || He(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), Ee.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e) : Je(this, e, t, !1), t + 4; }, Ee.prototype.writeFloatLE = function (e, t, n) { return Xe(this, e, t, !0, n); }, Ee.prototype.writeFloatBE = function (e, t, n) { return Xe(this, e, t, !1, n); }, Ee.prototype.writeDoubleLE = function (e, t, n) { return Qe(this, e, t, !0, n); }, Ee.prototype.writeDoubleBE = function (e, t, n) { return Qe(this, e, t, !1, n); }, Ee.prototype.copy = function (e, t, n, r) { if (n || (n = 0), r || 0 === r || (r = this.length), t >= e.length && (t = e.length), t || (t = 0), r > 0 && r < n && (r = n), r === n)
                return 0; if (0 === e.length || 0 === this.length)
                return 0; if (t < 0)
                throw new RangeError("targetStart out of bounds"); if (n < 0 || n >= this.length)
                throw new RangeError("sourceStart out of bounds"); if (r < 0)
                throw new RangeError("sourceEnd out of bounds"); r > this.length && (r = this.length), e.length - t < r - n && (r = e.length - t + n); var o, i = r - n; if (this === e && n < t && t < r)
                for (o = i - 1; o >= 0; --o)
                    e[o + t] = this[o + n];
            else if (i < 1e3 || !Ee.TYPED_ARRAY_SUPPORT)
                for (o = 0; o < i; ++o)
                    e[o + t] = this[o + n];
            else
                Uint8Array.prototype.set.call(e, this.subarray(n, n + i), t); return i; }, Ee.prototype.fill = function (e, t, n, r) { if ("string" == typeof e) {
                if ("string" == typeof t ? (r = t, t = 0, n = this.length) : "string" == typeof n && (r = n, n = this.length), 1 === e.length) {
                    var o = e.charCodeAt(0);
                    o < 256 && (e = o);
                }
                if (void 0 !== r && "string" != typeof r)
                    throw new TypeError("encoding must be a string");
                if ("string" == typeof r && !Ee.isEncoding(r))
                    throw new TypeError("Unknown encoding: " + r);
            }
            else
                "number" == typeof e && (e &= 255); if (t < 0 || this.length < t || this.length < n)
                throw new RangeError("Out of range index"); if (n <= t)
                return this; var i; if (t >>>= 0, n = void 0 === n ? this.length : n >>> 0, e || (e = 0), "number" == typeof e)
                for (i = t; i < n; ++i)
                    this[i] = e;
            else {
                var s = Te(e) ? e : et(new Ee(e, r).toString()), a = s.length;
                for (i = 0; i < n - t; ++i)
                    this[i + t] = s[i % a];
            } return this; }; var Ze = /[^+\/0-9A-Za-z-_]/g; function et(e, t) { var n; t = t || 1 / 0; for (var r = e.length, o = null, i = [], s = 0; s < r; ++s) {
                if ((n = e.charCodeAt(s)) > 55295 && n < 57344) {
                    if (!o) {
                        if (n > 56319) {
                            (t -= 3) > -1 && i.push(239, 191, 189);
                            continue;
                        }
                        if (s + 1 === r) {
                            (t -= 3) > -1 && i.push(239, 191, 189);
                            continue;
                        }
                        o = n;
                        continue;
                    }
                    if (n < 56320) {
                        (t -= 3) > -1 && i.push(239, 191, 189), o = n;
                        continue;
                    }
                    n = 65536 + (o - 55296 << 10 | n - 56320);
                }
                else
                    o && (t -= 3) > -1 && i.push(239, 191, 189);
                if (o = null, n < 128) {
                    if ((t -= 1) < 0)
                        break;
                    i.push(n);
                }
                else if (n < 2048) {
                    if ((t -= 2) < 0)
                        break;
                    i.push(n >> 6 | 192, 63 & n | 128);
                }
                else if (n < 65536) {
                    if ((t -= 3) < 0)
                        break;
                    i.push(n >> 12 | 224, n >> 6 & 63 | 128, 63 & n | 128);
                }
                else {
                    if (!(n < 1114112))
                        throw new Error("Invalid code point");
                    if ((t -= 4) < 0)
                        break;
                    i.push(n >> 18 | 240, n >> 12 & 63 | 128, n >> 6 & 63 | 128, 63 & n | 128);
                }
            } return i; } function tt(e) { return function (e) { var t, n, r, o, i, s; pe || fe(); var a = e.length; if (a % 4 > 0)
                throw new Error("Invalid string. Length must be a multiple of 4"); i = "=" === e[a - 2] ? 2 : "=" === e[a - 1] ? 1 : 0, s = new le(3 * a / 4 - i), r = i > 0 ? a - 4 : a; var u = 0; for (t = 0, n = 0; t < r; t += 4, n += 3)
                o = ce[e.charCodeAt(t)] << 18 | ce[e.charCodeAt(t + 1)] << 12 | ce[e.charCodeAt(t + 2)] << 6 | ce[e.charCodeAt(t + 3)], s[u++] = o >> 16 & 255, s[u++] = o >> 8 & 255, s[u++] = 255 & o; return 2 === i ? (o = ce[e.charCodeAt(t)] << 2 | ce[e.charCodeAt(t + 1)] >> 4, s[u++] = 255 & o) : 1 === i && (o = ce[e.charCodeAt(t)] << 10 | ce[e.charCodeAt(t + 1)] << 4 | ce[e.charCodeAt(t + 2)] >> 2, s[u++] = o >> 8 & 255, s[u++] = 255 & o), s; }(function (e) { if ((e = function (e) { return e.trim ? e.trim() : e.replace(/^\s+|\s+$/g, ""); }(e).replace(Ze, "")).length < 2)
                return ""; for (; e.length % 4 != 0;)
                e += "="; return e; }(e)); } function nt(e, t, n, r) { for (var o = 0; o < r && !(o + n >= t.length || o >= e.length); ++o)
                t[o + n] = e[o]; return o; } function rt(e) { return !!e.constructor && "function" == typeof e.constructor.isBuffer && e.constructor.isBuffer(e); } var ot = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : void 0 !== n.g ? n.g : "undefined" != typeof self ? self : {}; function it(e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e; } function st(e, t) { return e(t = { exports: {} }, t.exports), t.exports; } function at(e) { return e && e.default || e; } var ut = at(re); class ct extends Error {
            } class lt extends Error {
            } class pt extends Error {
            } var ft = { ConfigError: ct, DebugError: lt, UndefinedParserError: pt }; function dt(e, t) { if (null == e)
                return {}; var n, r, o = {}, i = Object.keys(e); for (r = 0; r < i.length; r++)
                n = i[r], t.indexOf(n) >= 0 || (o[n] = e[n]); return o; } function ht(e, t) { return t || (t = e.slice(0)), Object.freeze(Object.defineProperties(e, { raw: { value: Object.freeze(t) } })); } function mt() { throw new Error("setTimeout has not been defined"); } function gt() { throw new Error("clearTimeout has not been defined"); } var yt = mt, vt = gt; function bt(e) { if (yt === setTimeout)
                return setTimeout(e, 0); if ((yt === mt || !yt) && setTimeout)
                return yt = setTimeout, setTimeout(e, 0); try {
                return yt(e, 0);
            }
            catch (t) {
                try {
                    return yt.call(null, e, 0);
                }
                catch (t) {
                    return yt.call(this, e, 0);
                }
            } } "function" == typeof ae.setTimeout && (yt = setTimeout), "function" == typeof ae.clearTimeout && (vt = clearTimeout); var Dt, Et = [], Ct = !1, wt = -1; function At() { Ct && Dt && (Ct = !1, Dt.length ? Et = Dt.concat(Et) : wt = -1, Et.length && St()); } function St() { if (!Ct) {
                var e = bt(At);
                Ct = !0;
                for (var t = Et.length; t;) {
                    for (Dt = Et, Et = []; ++wt < t;)
                        Dt && Dt[wt].run();
                    wt = -1, t = Et.length;
                }
                Dt = null, Ct = !1, function (e) { if (vt === clearTimeout)
                    return clearTimeout(e); if ((vt === gt || !vt) && clearTimeout)
                    return vt = clearTimeout, clearTimeout(e); try {
                    vt(e);
                }
                catch (t) {
                    try {
                        return vt.call(null, e);
                    }
                    catch (t) {
                        return vt.call(this, e);
                    }
                } }(e);
            } } function xt(e, t) { this.fun = e, this.array = t; } function Tt() { } xt.prototype.run = function () { this.fun.apply(null, this.array); }; var kt = Tt, Ft = Tt, Ot = Tt, _t = Tt, Nt = Tt, Pt = Tt, Mt = Tt, Rt = ae.performance || {}, It = Rt.now || Rt.mozNow || Rt.msNow || Rt.oNow || Rt.webkitNow || function () { return (new Date).getTime(); }, jt = new Date, Bt = { nextTick: function (e) { var t = new Array(arguments.length - 1); if (arguments.length > 1)
                    for (var n = 1; n < arguments.length; n++)
                        t[n - 1] = arguments[n]; Et.push(new xt(e, t)), 1 !== Et.length || Ct || bt(St); }, title: "browser", browser: !0, env: {}, argv: [], version: "", versions: {}, on: kt, addListener: Ft, once: Ot, off: _t, removeListener: Nt, removeAllListeners: Pt, emit: Mt, binding: function (e) { throw new Error("process.binding is not supported"); }, cwd: function () { return "/"; }, chdir: function (e) { throw new Error("process.chdir is not supported"); }, umask: function () { return 0; }, hrtime: function (e) { var t = .001 * It.call(Rt), n = Math.floor(t), r = Math.floor(t % 1 * 1e9); return e && (n -= e[0], (r -= e[1]) < 0 && (n--, r += 1e9)), [n, r]; }, platform: "browser", release: {}, config: {}, uptime: function () { return (new Date - jt) / 1e3; } }, Lt = "object" == typeof Bt && Bt.env && Bt.env.NODE_DEBUG && /\bsemver\b/i.test(Bt.env.NODE_DEBUG) ? (...e) => a.error("SEMVER", ...e) : () => { }, qt = { SEMVER_SPEC_VERSION: "2.0.0", MAX_LENGTH: 256, MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991, MAX_SAFE_COMPONENT_LENGTH: 16 }, $t = st((function (e, t) { const { MAX_SAFE_COMPONENT_LENGTH: n } = qt, r = (t = e.exports = {}).re = [], o = t.src = [], i = t.t = {}; let s = 0; const a = (e, t, n) => { const a = s++; Lt(a, t), i[e] = a, o[a] = t, r[a] = new RegExp(t, n ? "g" : void 0); }; a("NUMERICIDENTIFIER", "0|[1-9]\\d*"), a("NUMERICIDENTIFIERLOOSE", "[0-9]+"), a("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), a("MAINVERSION", "(".concat(o[i.NUMERICIDENTIFIER], ")\\.") + "(".concat(o[i.NUMERICIDENTIFIER], ")\\.") + "(".concat(o[i.NUMERICIDENTIFIER], ")")), a("MAINVERSIONLOOSE", "(".concat(o[i.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(o[i.NUMERICIDENTIFIERLOOSE], ")\\.") + "(".concat(o[i.NUMERICIDENTIFIERLOOSE], ")")), a("PRERELEASEIDENTIFIER", "(?:".concat(o[i.NUMERICIDENTIFIER], "|").concat(o[i.NONNUMERICIDENTIFIER], ")")), a("PRERELEASEIDENTIFIERLOOSE", "(?:".concat(o[i.NUMERICIDENTIFIERLOOSE], "|").concat(o[i.NONNUMERICIDENTIFIER], ")")), a("PRERELEASE", "(?:-(".concat(o[i.PRERELEASEIDENTIFIER], "(?:\\.").concat(o[i.PRERELEASEIDENTIFIER], ")*))")), a("PRERELEASELOOSE", "(?:-?(".concat(o[i.PRERELEASEIDENTIFIERLOOSE], "(?:\\.").concat(o[i.PRERELEASEIDENTIFIERLOOSE], ")*))")), a("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), a("BUILD", "(?:\\+(".concat(o[i.BUILDIDENTIFIER], "(?:\\.").concat(o[i.BUILDIDENTIFIER], ")*))")), a("FULLPLAIN", "v?".concat(o[i.MAINVERSION]).concat(o[i.PRERELEASE], "?").concat(o[i.BUILD], "?")), a("FULL", "^".concat(o[i.FULLPLAIN], "$")), a("LOOSEPLAIN", "[v=\\s]*".concat(o[i.MAINVERSIONLOOSE]).concat(o[i.PRERELEASELOOSE], "?").concat(o[i.BUILD], "?")), a("LOOSE", "^".concat(o[i.LOOSEPLAIN], "$")), a("GTLT", "((?:<|>)?=?)"), a("XRANGEIDENTIFIERLOOSE", "".concat(o[i.NUMERICIDENTIFIERLOOSE], "|x|X|\\*")), a("XRANGEIDENTIFIER", "".concat(o[i.NUMERICIDENTIFIER], "|x|X|\\*")), a("XRANGEPLAIN", "[v=\\s]*(".concat(o[i.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(o[i.XRANGEIDENTIFIER], ")") + "(?:\\.(".concat(o[i.XRANGEIDENTIFIER], ")") + "(?:".concat(o[i.PRERELEASE], ")?").concat(o[i.BUILD], "?") + ")?)?"), a("XRANGEPLAINLOOSE", "[v=\\s]*(".concat(o[i.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(o[i.XRANGEIDENTIFIERLOOSE], ")") + "(?:\\.(".concat(o[i.XRANGEIDENTIFIERLOOSE], ")") + "(?:".concat(o[i.PRERELEASELOOSE], ")?").concat(o[i.BUILD], "?") + ")?)?"), a("XRANGE", "^".concat(o[i.GTLT], "\\s*").concat(o[i.XRANGEPLAIN], "$")), a("XRANGELOOSE", "^".concat(o[i.GTLT], "\\s*").concat(o[i.XRANGEPLAINLOOSE], "$")), a("COERCE", "".concat("(^|[^\\d])(\\d{1,").concat(n, "})") + "(?:\\.(\\d{1,".concat(n, "}))?") + "(?:\\.(\\d{1,".concat(n, "}))?") + "(?:$|[^\\d])"), a("COERCERTL", o[i.COERCE], !0), a("LONETILDE", "(?:~>?)"), a("TILDETRIM", "(\\s*)".concat(o[i.LONETILDE], "\\s+"), !0), t.tildeTrimReplace = "$1~", a("TILDE", "^".concat(o[i.LONETILDE]).concat(o[i.XRANGEPLAIN], "$")), a("TILDELOOSE", "^".concat(o[i.LONETILDE]).concat(o[i.XRANGEPLAINLOOSE], "$")), a("LONECARET", "(?:\\^)"), a("CARETTRIM", "(\\s*)".concat(o[i.LONECARET], "\\s+"), !0), t.caretTrimReplace = "$1^", a("CARET", "^".concat(o[i.LONECARET]).concat(o[i.XRANGEPLAIN], "$")), a("CARETLOOSE", "^".concat(o[i.LONECARET]).concat(o[i.XRANGEPLAINLOOSE], "$")), a("COMPARATORLOOSE", "^".concat(o[i.GTLT], "\\s*(").concat(o[i.LOOSEPLAIN], ")$|^$")), a("COMPARATOR", "^".concat(o[i.GTLT], "\\s*(").concat(o[i.FULLPLAIN], ")$|^$")), a("COMPARATORTRIM", "(\\s*)".concat(o[i.GTLT], "\\s*(").concat(o[i.LOOSEPLAIN], "|").concat(o[i.XRANGEPLAIN], ")"), !0), t.comparatorTrimReplace = "$1$2$3", a("HYPHENRANGE", "^\\s*(".concat(o[i.XRANGEPLAIN], ")") + "\\s+-\\s+" + "(".concat(o[i.XRANGEPLAIN], ")") + "\\s*$"), a("HYPHENRANGELOOSE", "^\\s*(".concat(o[i.XRANGEPLAINLOOSE], ")") + "\\s+-\\s+" + "(".concat(o[i.XRANGEPLAINLOOSE], ")") + "\\s*$"), a("STAR", "(<|>)?=?\\s*\\*"); })); $t.re, $t.src, $t.t, $t.tildeTrimReplace, $t.caretTrimReplace, $t.comparatorTrimReplace; const Ut = /^[0-9]+$/, Vt = (e, t) => { const n = Ut.test(e), r = Ut.test(t); return n && r && (e = +e, t = +t), e === t ? 0 : n && !r ? -1 : r && !n ? 1 : e < t ? -1 : 1; }; var Wt = { compareIdentifiers: Vt, rcompareIdentifiers: (e, t) => Vt(t, e) }; const { MAX_LENGTH: Kt, MAX_SAFE_INTEGER: zt } = qt, { re: Ht, t: Yt } = $t, { compareIdentifiers: Jt } = Wt; class Gt {
                constructor(e, t) { if (t && "object" == typeof t || (t = { loose: !!t, includePrerelease: !1 }), e instanceof Gt) {
                    if (e.loose === !!t.loose && e.includePrerelease === !!t.includePrerelease)
                        return e;
                    e = e.version;
                }
                else if ("string" != typeof e)
                    throw new TypeError("Invalid Version: ".concat(e)); if (e.length > Kt)
                    throw new TypeError("version is longer than ".concat(Kt, " characters")); Lt("SemVer", e, t), this.options = t, this.loose = !!t.loose, this.includePrerelease = !!t.includePrerelease; const n = e.trim().match(t.loose ? Ht[Yt.LOOSE] : Ht[Yt.FULL]); if (!n)
                    throw new TypeError("Invalid Version: ".concat(e)); if (this.raw = e, this.major = +n[1], this.minor = +n[2], this.patch = +n[3], this.major > zt || this.major < 0)
                    throw new TypeError("Invalid major version"); if (this.minor > zt || this.minor < 0)
                    throw new TypeError("Invalid minor version"); if (this.patch > zt || this.patch < 0)
                    throw new TypeError("Invalid patch version"); n[4] ? this.prerelease = n[4].split(".").map((e => { if (/^[0-9]+$/.test(e)) {
                    const t = +e;
                    if (t >= 0 && t < zt)
                        return t;
                } return e; })) : this.prerelease = [], this.build = n[5] ? n[5].split(".") : [], this.format(); }
                format() { return this.version = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch), this.prerelease.length && (this.version += "-".concat(this.prerelease.join("."))), this.version; }
                toString() { return this.version; }
                compare(e) { if (Lt("SemVer.compare", this.version, this.options, e), !(e instanceof Gt)) {
                    if ("string" == typeof e && e === this.version)
                        return 0;
                    e = new Gt(e, this.options);
                } return e.version === this.version ? 0 : this.compareMain(e) || this.comparePre(e); }
                compareMain(e) { return e instanceof Gt || (e = new Gt(e, this.options)), Jt(this.major, e.major) || Jt(this.minor, e.minor) || Jt(this.patch, e.patch); }
                comparePre(e) { if (e instanceof Gt || (e = new Gt(e, this.options)), this.prerelease.length && !e.prerelease.length)
                    return -1; if (!this.prerelease.length && e.prerelease.length)
                    return 1; if (!this.prerelease.length && !e.prerelease.length)
                    return 0; let t = 0; do {
                    const n = this.prerelease[t], r = e.prerelease[t];
                    if (Lt("prerelease compare", t, n, r), void 0 === n && void 0 === r)
                        return 0;
                    if (void 0 === r)
                        return 1;
                    if (void 0 === n)
                        return -1;
                    if (n !== r)
                        return Jt(n, r);
                } while (++t); }
                compareBuild(e) { e instanceof Gt || (e = new Gt(e, this.options)); let t = 0; do {
                    const n = this.build[t], r = e.build[t];
                    if (Lt("prerelease compare", t, n, r), void 0 === n && void 0 === r)
                        return 0;
                    if (void 0 === r)
                        return 1;
                    if (void 0 === n)
                        return -1;
                    if (n !== r)
                        return Jt(n, r);
                } while (++t); }
                inc(e, t) { switch (e) {
                    case "premajor":
                        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t);
                        break;
                    case "preminor":
                        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t);
                        break;
                    case "prepatch":
                        this.prerelease.length = 0, this.inc("patch", t), this.inc("pre", t);
                        break;
                    case "prerelease":
                        0 === this.prerelease.length && this.inc("patch", t), this.inc("pre", t);
                        break;
                    case "major":
                        0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                        break;
                    case "minor":
                        0 === this.patch && 0 !== this.prerelease.length || this.minor++, this.patch = 0, this.prerelease = [];
                        break;
                    case "patch":
                        0 === this.prerelease.length && this.patch++, this.prerelease = [];
                        break;
                    case "pre":
                        if (0 === this.prerelease.length)
                            this.prerelease = [0];
                        else {
                            let e = this.prerelease.length;
                            for (; --e >= 0;)
                                "number" == typeof this.prerelease[e] && (this.prerelease[e]++, e = -2);
                            -1 === e && this.prerelease.push(0);
                        }
                        t && (this.prerelease[0] === t ? isNaN(this.prerelease[1]) && (this.prerelease = [t, 0]) : this.prerelease = [t, 0]);
                        break;
                    default: throw new Error("invalid increment argument: ".concat(e));
                } return this.format(), this.raw = this.version, this; }
            } var Xt = Gt, Qt = (e, t, n) => new Xt(e, n).compare(new Xt(t, n)), Zt = st((function (e) { e.exports = function (e) { var t = void 0; t = "string" == typeof e ? [e] : e.raw; for (var n = "", r = 0; r < t.length; r++)
                n += t[r].replace(/\\\n[ \t]*/g, "").replace(/\\`/g, "`"), r < (arguments.length <= 1 ? 0 : arguments.length - 1) && (n += arguments.length <= r + 1 ? void 0 : arguments[r + 1]); var o = n.split("\n"), i = null; return o.forEach((function (e) { var t = e.match(/^(\s+)\S+/); if (t) {
                var n = t[1].length;
                i = i ? Math.min(i, n) : n;
            } })), null !== i && (n = o.map((function (e) { return " " === e[0] ? e.slice(i) : e; })).join("\n")), (n = n.trim()).replace(/\\n/g, "\n"); }; })); function en() { const e = ht(["\n      Require either '@prettier' or '@format' to be present in the file's first docblock comment\n      in order for it to be formatted.\n    "]); return en = function () { return e; }, e; } function tn() { const e = ht(["\n      Format code starting at a given character offset.\n      The range will extend backwards to the start of the first line containing the selected statement.\n      This option cannot be used with --cursor-offset.\n    "]); return tn = function () { return e; }, e; } function nn() { const e = ht(["\n      Format code ending at a given character offset (exclusive).\n      The range will extend forwards to the end of the selected statement.\n      This option cannot be used with --cursor-offset.\n    "]); return nn = function () { return e; }, e; } function rn() { const e = ht(["\n      Custom directory that contains prettier plugins in node_modules subdirectory.\n      Overrides default behavior when plugins are searched relatively to the location of Prettier.\n      Multiple values are accepted.\n    "]); return rn = function () { return e; }, e; } function on() { const e = ht(["\n          Maintain existing\n          (mixed values within one file are normalised by looking at what's used after the first line)\n        "]); return on = function () { return e; }, e; } function sn() { const e = ht(["\n      Print (to stderr) where a cursor at the given position would move to after formatting.\n      This option cannot be used with --range-start and --range-end.\n    "]); return sn = function () { return e; }, e; } const an = "Config", un = "Editor", cn = "Other", ln = "Global", pn = "Special"; var fn = { CATEGORY_CONFIG: an, CATEGORY_EDITOR: un, CATEGORY_FORMAT: "Format", CATEGORY_OTHER: cn, CATEGORY_OUTPUT: "Output", CATEGORY_GLOBAL: ln, CATEGORY_SPECIAL: pn, options: { cursorOffset: { since: "1.4.0", category: pn, type: "int", default: -1, range: { start: -1, end: 1 / 0, step: 1 }, description: Zt(sn()), cliCategory: un }, endOfLine: { since: "1.15.0", category: ln, type: "choice", default: [{ since: "1.15.0", value: "auto" }, { since: "2.0.0", value: "lf" }], description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: Zt(on()) }] }, filepath: { since: "1.4.0", category: pn, type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: cn, cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { since: "1.8.0", category: pn, type: "boolean", default: !1, description: "Insert @format pragma into file's first docblock comment.", cliCategory: cn }, parser: { since: "0.0.10", category: ln, type: "choice", default: [{ since: "0.0.10", value: "babylon" }, { since: "1.13.0", value: void 0 }], description: "Which parser to use.", exception: e => "string" == typeof e || "function" == typeof e, choices: [{ value: "flow", description: "Flow" }, { value: "babel", since: "1.16.0", description: "JavaScript" }, { value: "babel-flow", since: "1.16.0", description: "Flow" }, { value: "babel-ts", since: "2.0.0", description: "TypeScript" }, { value: "typescript", since: "1.4.0", description: "TypeScript" }, { value: "css", since: "1.7.1", description: "CSS" }, { value: "less", since: "1.7.1", description: "Less" }, { value: "scss", since: "1.7.1", description: "SCSS" }, { value: "json", since: "1.5.0", description: "JSON" }, { value: "json5", since: "1.13.0", description: "JSON5" }, { value: "json-stringify", since: "1.13.0", description: "JSON.stringify" }, { value: "graphql", since: "1.5.0", description: "GraphQL" }, { value: "markdown", since: "1.8.0", description: "Markdown" }, { value: "mdx", since: "1.15.0", description: "MDX" }, { value: "vue", since: "1.10.0", description: "Vue" }, { value: "yaml", since: "1.14.0", description: "YAML" }, { value: "glimmer", since: null, description: "Handlebars" }, { value: "html", since: "1.15.0", description: "HTML" }, { value: "angular", since: "1.15.0", description: "Angular" }, { value: "lwc", since: "1.17.0", description: "Lightning Web Components" }] }, plugins: { since: "1.10.0", type: "path", array: !0, default: [{ value: [] }], category: ln, description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: e => "string" == typeof e || "object" == typeof e, cliName: "plugin", cliCategory: an }, pluginSearchDirs: { since: "1.13.0", type: "path", array: !0, default: [{ value: [] }], category: ln, description: Zt(rn()), exception: e => "string" == typeof e || "object" == typeof e, cliName: "plugin-search-dir", cliCategory: an }, printWidth: { since: "0.0.0", category: ln, type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: 1 / 0, step: 1 } }, rangeEnd: { since: "1.4.0", category: pn, type: "int", default: 1 / 0, range: { start: 0, end: 1 / 0, step: 1 }, description: Zt(nn()), cliCategory: un }, rangeStart: { since: "1.4.0", category: pn, type: "int", default: 0, range: { start: 0, end: 1 / 0, step: 1 }, description: Zt(tn()), cliCategory: un }, requirePragma: { since: "1.7.0", category: pn, type: "boolean", default: !1, description: Zt(en()), cliCategory: cn }, tabWidth: { type: "int", category: ln, default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: 1 / 0, step: 1 } }, useTabs: { since: "1.0.0", category: ln, type: "boolean", default: !1, description: "Indent with tabs instead of spaces." } } }, dn = at(m); const hn = Qt, mn = (e, t, n) => Qt(e, t, n) < 0, gn = (e, t, n) => Qt(e, t, n) >= 0, yn = dn.version, vn = fn.options; var bn = { getSupportInfo: function ({ plugins: e = [], showUnreleased: t = !1, showDeprecated: n = !1, showInternal: r = !1 } = {}) { const o = yn.split("-", 1)[0], i = (s = Object.assign({}, ...e.map((({ options: e }) => e)), vn), "name", Object.entries(s).map((([e, t]) => Object.assign({ name: e }, t)))).filter((e => a(e) && u(e))).sort(((e, t) => e.name === t.name ? 0 : e.name < t.name ? -1 : 1)).map((function (e) { return r ? e : dt(e, ["cliName", "cliCategory", "cliDescription"]); })).map((t => { t = Object.assign({}, t), Array.isArray(t.default) && (t.default = 1 === t.default.length ? t.default[0].value : t.default.filter(a).sort(((e, t) => hn(t.since, e.since)))[0].value), Array.isArray(t.choices) && (t.choices = t.choices.filter((e => a(e) && u(e)))); const n = e.filter((e => e.defaultOptions && void 0 !== e.defaultOptions[t.name])).reduce(((e, n) => (e[n.name] = n.defaultOptions[t.name], e)), {}); return Object.assign({}, t, { pluginDefaults: n }); })); var s; return { languages: e.reduce(((e, t) => e.concat(t.languages || [])), []).filter(a), options: i }; function a(e) { return t || !("since" in e) || e.since && gn(o, e.since); } function u(e) { return n || !("deprecated" in e) || e.deprecated && mn(o, e.deprecated); } } }, Dn = function (e, t) { return (Dn = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t; } || function (e, t) { for (var n in t)
                t.hasOwnProperty(n) && (e[n] = t[n]); })(e, t); }, En = function () { return En = Object.assign || function (e) { for (var t, n = 1, r = arguments.length; n < r; n++)
                for (var o in t = arguments[n])
                    Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]); return e; }, En.apply(this, arguments); }; function Cn(e) { var t = "function" == typeof Symbol && e[Symbol.iterator], n = 0; return t ? t.call(e) : { next: function () { return e && n >= e.length && (e = void 0), { value: e && e[n++], done: !e }; } }; } function wn(e, t) { var n = "function" == typeof Symbol && e[Symbol.iterator]; if (!n)
                return e; var r, o, i = n.call(e), s = []; try {
                for (; (void 0 === t || t-- > 0) && !(r = i.next()).done;)
                    s.push(r.value);
            }
            catch (e) {
                o = { error: e };
            }
            finally {
                try {
                    r && !r.done && (n = i.return) && n.call(i);
                }
                finally {
                    if (o)
                        throw o.error;
                }
            } return s; } function An(e) { return this instanceof An ? (this.v = e, this) : new An(e); } var Sn = Object.freeze({ __proto__: null, __extends: function (e, t) { function n() { this.constructor = e; } Dn(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n); }, get __assign() { return En; }, __rest: function (e, t) { var n = {}; for (var r in e)
                    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]); if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
                    var o = 0;
                    for (r = Object.getOwnPropertySymbols(e); o < r.length; o++)
                        t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
                } return n; }, __decorate: function (e, t, n, r) { var o, i = arguments.length, s = i < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
                    s = Reflect.decorate(e, t, n, r);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        (o = e[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(t, n, s) : o(t, n)) || s); return i > 3 && s && Object.defineProperty(t, n, s), s; }, __param: function (e, t) { return function (n, r) { t(n, r, e); }; }, __metadata: function (e, t) { if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
                    return Reflect.metadata(e, t); }, __awaiter: function (e, t, n, r) { return new (n || (n = Promise))((function (o, i) { function s(e) { try {
                    u(r.next(e));
                }
                catch (e) {
                    i(e);
                } } function a(e) { try {
                    u(r.throw(e));
                }
                catch (e) {
                    i(e);
                } } function u(e) { e.done ? o(e.value) : new n((function (t) { t(e.value); })).then(s, a); } u((r = r.apply(e, t || [])).next()); })); }, __generator: function (e, t) { var n, r, o, i, s = { label: 0, sent: function () { if (1 & o[0])
                        throw o[1]; return o[1]; }, trys: [], ops: [] }; return i = { next: a(0), throw: a(1), return: a(2) }, "function" == typeof Symbol && (i[Symbol.iterator] = function () { return this; }), i; function a(i) { return function (a) { return function (i) { if (n)
                    throw new TypeError("Generator is already executing."); for (; s;)
                    try {
                        if (n = 1, r && (o = 2 & i[0] ? r.return : i[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, i[1])).done)
                            return o;
                        switch (r = 0, o && (i = [2 & i[0], o.value]), i[0]) {
                            case 0:
                            case 1:
                                o = i;
                                break;
                            case 4: return s.label++, { value: i[1], done: !1 };
                            case 5:
                                s.label++, r = i[1], i = [0];
                                continue;
                            case 7:
                                i = s.ops.pop(), s.trys.pop();
                                continue;
                            default:
                                if (!((o = (o = s.trys).length > 0 && o[o.length - 1]) || 6 !== i[0] && 2 !== i[0])) {
                                    s = 0;
                                    continue;
                                }
                                if (3 === i[0] && (!o || i[1] > o[0] && i[1] < o[3])) {
                                    s.label = i[1];
                                    break;
                                }
                                if (6 === i[0] && s.label < o[1]) {
                                    s.label = o[1], o = i;
                                    break;
                                }
                                if (o && s.label < o[2]) {
                                    s.label = o[2], s.ops.push(i);
                                    break;
                                }
                                o[2] && s.ops.pop(), s.trys.pop();
                                continue;
                        }
                        i = t.call(e, s);
                    }
                    catch (e) {
                        i = [6, e], r = 0;
                    }
                    finally {
                        n = o = 0;
                    } if (5 & i[0])
                    throw i[1]; return { value: i[0] ? i[1] : void 0, done: !0 }; }([i, a]); }; } }, __exportStar: function (e, t) { for (var n in e)
                    t.hasOwnProperty(n) || (t[n] = e[n]); }, __values: Cn, __read: wn, __spread: function () { for (var e = [], t = 0; t < arguments.length; t++)
                    e = e.concat(wn(arguments[t])); return e; }, __spreadArrays: function () { for (var e = 0, t = 0, n = arguments.length; t < n; t++)
                    e += arguments[t].length; var r = Array(e), o = 0; for (t = 0; t < n; t++)
                    for (var i = arguments[t], s = 0, a = i.length; s < a; s++, o++)
                        r[o] = i[s]; return r; }, __await: An, __asyncGenerator: function (e, t, n) { if (!Symbol.asyncIterator)
                    throw new TypeError("Symbol.asyncIterator is not defined."); var r, o = n.apply(e, t || []), i = []; return r = {}, s("next"), s("throw"), s("return"), r[Symbol.asyncIterator] = function () { return this; }, r; function s(e) { o[e] && (r[e] = function (t) { return new Promise((function (n, r) { i.push([e, t, n, r]) > 1 || a(e, t); })); }); } function a(e, t) { try {
                    (n = o[e](t)).value instanceof An ? Promise.resolve(n.value.v).then(u, c) : l(i[0][2], n);
                }
                catch (e) {
                    l(i[0][3], e);
                } var n; } function u(e) { a("next", e); } function c(e) { a("throw", e); } function l(e, t) { e(t), i.shift(), i.length && a(i[0][0], i[0][1]); } }, __asyncDelegator: function (e) { var t, n; return t = {}, r("next"), r("throw", (function (e) { throw e; })), r("return"), t[Symbol.iterator] = function () { return this; }, t; function r(r, o) { t[r] = e[r] ? function (t) { return (n = !n) ? { value: An(e[r](t)), done: "return" === r } : o ? o(t) : t; } : o; } }, __asyncValues: function (e) { if (!Symbol.asyncIterator)
                    throw new TypeError("Symbol.asyncIterator is not defined."); var t, n = e[Symbol.asyncIterator]; return n ? n.call(e) : (e = Cn(e), t = {}, r("next"), r("throw"), r("return"), t[Symbol.asyncIterator] = function () { return this; }, t); function r(n) { t[n] = e[n] && function (t) { return new Promise((function (r, o) { !function (e, t, n, r) { Promise.resolve(r).then((function (t) { e({ value: t, done: n }); }), t); }(r, o, (t = e[n](t)).done, t.value); })); }; } }, __makeTemplateObject: function (e, t) { return Object.defineProperty ? Object.defineProperty(e, "raw", { value: t }) : e.raw = t, e; }, __importStar: function (e) { if (e && e.__esModule)
                    return e; var t = {}; if (null != e)
                    for (var n in e)
                        Object.hasOwnProperty.call(e, n) && (t[n] = e[n]); return t.default = e, t; }, __importDefault: function (e) { return e && e.__esModule ? e : { default: e }; } }), xn = st((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.apiDescriptor = { key: e => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(e) ? e : JSON.stringify(e), value(e) { if (null === e || "object" != typeof e)
                    return JSON.stringify(e); if (Array.isArray(e))
                    return "[".concat(e.map((e => t.apiDescriptor.value(e))).join(", "), "]"); const n = Object.keys(e); return 0 === n.length ? "{}" : "{ ".concat(n.map((n => "".concat(t.apiDescriptor.key(n), ": ").concat(t.apiDescriptor.value(e[n])))).join(", "), " }"); }, pair: ({ key: e, value: n }) => t.apiDescriptor.value({ [e]: n }) }; })); it(xn), xn.apiDescriptor; var Tn = at(Sn), kn = st((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), Tn.__exportStar(xn, t); })); it(kn); var Fn = /[|\\{}()[\]^$+*?.]/g, On = function (e) { if ("string" != typeof e)
                throw new TypeError("Expected a string"); return e.replace(Fn, "\\$&"); }, _n = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] }, Nn = st((function (e) { var t = {}; for (var n in _n)
                _n.hasOwnProperty(n) && (t[_n[n]] = n); var r = e.exports = { rgb: { channels: 3, labels: "rgb" }, hsl: { channels: 3, labels: "hsl" }, hsv: { channels: 3, labels: "hsv" }, hwb: { channels: 3, labels: "hwb" }, cmyk: { channels: 4, labels: "cmyk" }, xyz: { channels: 3, labels: "xyz" }, lab: { channels: 3, labels: "lab" }, lch: { channels: 3, labels: "lch" }, hex: { channels: 1, labels: ["hex"] }, keyword: { channels: 1, labels: ["keyword"] }, ansi16: { channels: 1, labels: ["ansi16"] }, ansi256: { channels: 1, labels: ["ansi256"] }, hcg: { channels: 3, labels: ["h", "c", "g"] }, apple: { channels: 3, labels: ["r16", "g16", "b16"] }, gray: { channels: 1, labels: ["gray"] } }; for (var o in r)
                if (r.hasOwnProperty(o)) {
                    if (!("channels" in r[o]))
                        throw new Error("missing channels property: " + o);
                    if (!("labels" in r[o]))
                        throw new Error("missing channel labels property: " + o);
                    if (r[o].labels.length !== r[o].channels)
                        throw new Error("channel and label counts mismatch: " + o);
                    var i = r[o].channels, s = r[o].labels;
                    delete r[o].channels, delete r[o].labels, Object.defineProperty(r[o], "channels", { value: i }), Object.defineProperty(r[o], "labels", { value: s });
                } r.rgb.hsl = function (e) { var t, n, r = e[0] / 255, o = e[1] / 255, i = e[2] / 255, s = Math.min(r, o, i), a = Math.max(r, o, i), u = a - s; return a === s ? t = 0 : r === a ? t = (o - i) / u : o === a ? t = 2 + (i - r) / u : i === a && (t = 4 + (r - o) / u), (t = Math.min(60 * t, 360)) < 0 && (t += 360), n = (s + a) / 2, [t, 100 * (a === s ? 0 : n <= .5 ? u / (a + s) : u / (2 - a - s)), 100 * n]; }, r.rgb.hsv = function (e) { var t, n, r, o, i, s = e[0] / 255, a = e[1] / 255, u = e[2] / 255, c = Math.max(s, a, u), l = c - Math.min(s, a, u), p = function (e) { return (c - e) / 6 / l + .5; }; return 0 === l ? o = i = 0 : (i = l / c, t = p(s), n = p(a), r = p(u), s === c ? o = r - n : a === c ? o = 1 / 3 + t - r : u === c && (o = 2 / 3 + n - t), o < 0 ? o += 1 : o > 1 && (o -= 1)), [360 * o, 100 * i, 100 * c]; }, r.rgb.hwb = function (e) { var t = e[0], n = e[1], o = e[2]; return [r.rgb.hsl(e)[0], 1 / 255 * Math.min(t, Math.min(n, o)) * 100, 100 * (o = 1 - 1 / 255 * Math.max(t, Math.max(n, o)))]; }, r.rgb.cmyk = function (e) { var t, n = e[0] / 255, r = e[1] / 255, o = e[2] / 255; return [100 * ((1 - n - (t = Math.min(1 - n, 1 - r, 1 - o))) / (1 - t) || 0), 100 * ((1 - r - t) / (1 - t) || 0), 100 * ((1 - o - t) / (1 - t) || 0), 100 * t]; }, r.rgb.keyword = function (e) { var n = t[e]; if (n)
                return n; var r, o, i, s = 1 / 0; for (var a in _n)
                if (_n.hasOwnProperty(a)) {
                    var u = (o = e, i = _n[a], Math.pow(o[0] - i[0], 2) + Math.pow(o[1] - i[1], 2) + Math.pow(o[2] - i[2], 2));
                    u < s && (s = u, r = a);
                } return r; }, r.keyword.rgb = function (e) { return _n[e]; }, r.rgb.xyz = function (e) { var t = e[0] / 255, n = e[1] / 255, r = e[2] / 255; return [100 * (.4124 * (t = t > .04045 ? Math.pow((t + .055) / 1.055, 2.4) : t / 12.92) + .3576 * (n = n > .04045 ? Math.pow((n + .055) / 1.055, 2.4) : n / 12.92) + .1805 * (r = r > .04045 ? Math.pow((r + .055) / 1.055, 2.4) : r / 12.92)), 100 * (.2126 * t + .7152 * n + .0722 * r), 100 * (.0193 * t + .1192 * n + .9505 * r)]; }, r.rgb.lab = function (e) { var t = r.rgb.xyz(e), n = t[0], o = t[1], i = t[2]; return o /= 100, i /= 108.883, n = (n /= 95.047) > .008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116, [116 * (o = o > .008856 ? Math.pow(o, 1 / 3) : 7.787 * o + 16 / 116) - 16, 500 * (n - o), 200 * (o - (i = i > .008856 ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116))]; }, r.hsl.rgb = function (e) { var t, n, r, o, i, s = e[0] / 360, a = e[1] / 100, u = e[2] / 100; if (0 === a)
                return [i = 255 * u, i, i]; t = 2 * u - (n = u < .5 ? u * (1 + a) : u + a - u * a), o = [0, 0, 0]; for (var c = 0; c < 3; c++)
                (r = s + 1 / 3 * -(c - 1)) < 0 && r++, r > 1 && r--, i = 6 * r < 1 ? t + 6 * (n - t) * r : 2 * r < 1 ? n : 3 * r < 2 ? t + (n - t) * (2 / 3 - r) * 6 : t, o[c] = 255 * i; return o; }, r.hsl.hsv = function (e) { var t = e[0], n = e[1] / 100, r = e[2] / 100, o = n, i = Math.max(r, .01); return n *= (r *= 2) <= 1 ? r : 2 - r, o *= i <= 1 ? i : 2 - i, [t, 100 * (0 === r ? 2 * o / (i + o) : 2 * n / (r + n)), (r + n) / 2 * 100]; }, r.hsv.rgb = function (e) { var t = e[0] / 60, n = e[1] / 100, r = e[2] / 100, o = Math.floor(t) % 6, i = t - Math.floor(t), s = 255 * r * (1 - n), a = 255 * r * (1 - n * i), u = 255 * r * (1 - n * (1 - i)); switch (r *= 255, o) {
                case 0: return [r, u, s];
                case 1: return [a, r, s];
                case 2: return [s, r, u];
                case 3: return [s, a, r];
                case 4: return [u, s, r];
                case 5: return [r, s, a];
            } }, r.hsv.hsl = function (e) { var t, n, r, o = e[0], i = e[1] / 100, s = e[2] / 100, a = Math.max(s, .01); return r = (2 - i) * s, n = i * a, [o, 100 * (n = (n /= (t = (2 - i) * a) <= 1 ? t : 2 - t) || 0), 100 * (r /= 2)]; }, r.hwb.rgb = function (e) { var t, n, r, o, i, s, a, u = e[0] / 360, c = e[1] / 100, l = e[2] / 100, p = c + l; switch (p > 1 && (c /= p, l /= p), r = 6 * u - (t = Math.floor(6 * u)), 0 != (1 & t) && (r = 1 - r), o = c + r * ((n = 1 - l) - c), t) {
                default:
                case 6:
                case 0:
                    i = n, s = o, a = c;
                    break;
                case 1:
                    i = o, s = n, a = c;
                    break;
                case 2:
                    i = c, s = n, a = o;
                    break;
                case 3:
                    i = c, s = o, a = n;
                    break;
                case 4:
                    i = o, s = c, a = n;
                    break;
                case 5: i = n, s = c, a = o;
            } return [255 * i, 255 * s, 255 * a]; }, r.cmyk.rgb = function (e) { var t = e[0] / 100, n = e[1] / 100, r = e[2] / 100, o = e[3] / 100; return [255 * (1 - Math.min(1, t * (1 - o) + o)), 255 * (1 - Math.min(1, n * (1 - o) + o)), 255 * (1 - Math.min(1, r * (1 - o) + o))]; }, r.xyz.rgb = function (e) { var t, n, r, o = e[0] / 100, i = e[1] / 100, s = e[2] / 100; return n = -.9689 * o + 1.8758 * i + .0415 * s, r = .0557 * o + -.204 * i + 1.057 * s, t = (t = 3.2406 * o + -1.5372 * i + -.4986 * s) > .0031308 ? 1.055 * Math.pow(t, 1 / 2.4) - .055 : 12.92 * t, n = n > .0031308 ? 1.055 * Math.pow(n, 1 / 2.4) - .055 : 12.92 * n, r = r > .0031308 ? 1.055 * Math.pow(r, 1 / 2.4) - .055 : 12.92 * r, [255 * (t = Math.min(Math.max(0, t), 1)), 255 * (n = Math.min(Math.max(0, n), 1)), 255 * (r = Math.min(Math.max(0, r), 1))]; }, r.xyz.lab = function (e) { var t = e[0], n = e[1], r = e[2]; return n /= 100, r /= 108.883, t = (t /= 95.047) > .008856 ? Math.pow(t, 1 / 3) : 7.787 * t + 16 / 116, [116 * (n = n > .008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116) - 16, 500 * (t - n), 200 * (n - (r = r > .008856 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116))]; }, r.lab.xyz = function (e) { var t, n, r, o = e[0]; t = e[1] / 500 + (n = (o + 16) / 116), r = n - e[2] / 200; var i = Math.pow(n, 3), s = Math.pow(t, 3), a = Math.pow(r, 3); return n = i > .008856 ? i : (n - 16 / 116) / 7.787, t = s > .008856 ? s : (t - 16 / 116) / 7.787, r = a > .008856 ? a : (r - 16 / 116) / 7.787, [t *= 95.047, n *= 100, r *= 108.883]; }, r.lab.lch = function (e) { var t, n = e[0], r = e[1], o = e[2]; return (t = 360 * Math.atan2(o, r) / 2 / Math.PI) < 0 && (t += 360), [n, Math.sqrt(r * r + o * o), t]; }, r.lch.lab = function (e) { var t, n = e[0], r = e[1]; return t = e[2] / 360 * 2 * Math.PI, [n, r * Math.cos(t), r * Math.sin(t)]; }, r.rgb.ansi16 = function (e) { var t = e[0], n = e[1], o = e[2], i = 1 in arguments ? arguments[1] : r.rgb.hsv(e)[2]; if (0 === (i = Math.round(i / 50)))
                return 30; var s = 30 + (Math.round(o / 255) << 2 | Math.round(n / 255) << 1 | Math.round(t / 255)); return 2 === i && (s += 60), s; }, r.hsv.ansi16 = function (e) { return r.rgb.ansi16(r.hsv.rgb(e), e[2]); }, r.rgb.ansi256 = function (e) { var t = e[0], n = e[1], r = e[2]; return t === n && n === r ? t < 8 ? 16 : t > 248 ? 231 : Math.round((t - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t / 255 * 5) + 6 * Math.round(n / 255 * 5) + Math.round(r / 255 * 5); }, r.ansi16.rgb = function (e) { var t = e % 10; if (0 === t || 7 === t)
                return e > 50 && (t += 3.5), [t = t / 10.5 * 255, t, t]; var n = .5 * (1 + ~~(e > 50)); return [(1 & t) * n * 255, (t >> 1 & 1) * n * 255, (t >> 2 & 1) * n * 255]; }, r.ansi256.rgb = function (e) { if (e >= 232) {
                var t = 10 * (e - 232) + 8;
                return [t, t, t];
            } var n; return e -= 16, [Math.floor(e / 36) / 5 * 255, Math.floor((n = e % 36) / 6) / 5 * 255, n % 6 / 5 * 255]; }, r.rgb.hex = function (e) { var t = (((255 & Math.round(e[0])) << 16) + ((255 & Math.round(e[1])) << 8) + (255 & Math.round(e[2]))).toString(16).toUpperCase(); return "000000".substring(t.length) + t; }, r.hex.rgb = function (e) { var t = e.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i); if (!t)
                return [0, 0, 0]; var n = t[0]; 3 === t[0].length && (n = n.split("").map((function (e) { return e + e; })).join("")); var r = parseInt(n, 16); return [r >> 16 & 255, r >> 8 & 255, 255 & r]; }, r.rgb.hcg = function (e) { var t, n = e[0] / 255, r = e[1] / 255, o = e[2] / 255, i = Math.max(Math.max(n, r), o), s = Math.min(Math.min(n, r), o), a = i - s; return t = a <= 0 ? 0 : i === n ? (r - o) / a % 6 : i === r ? 2 + (o - n) / a : 4 + (n - r) / a + 4, t /= 6, [360 * (t %= 1), 100 * a, 100 * (a < 1 ? s / (1 - a) : 0)]; }, r.hsl.hcg = function (e) { var t, n = e[1] / 100, r = e[2] / 100, o = 0; return (t = r < .5 ? 2 * n * r : 2 * n * (1 - r)) < 1 && (o = (r - .5 * t) / (1 - t)), [e[0], 100 * t, 100 * o]; }, r.hsv.hcg = function (e) { var t = e[1] / 100, n = e[2] / 100, r = t * n, o = 0; return r < 1 && (o = (n - r) / (1 - r)), [e[0], 100 * r, 100 * o]; }, r.hcg.rgb = function (e) { var t = e[0] / 360, n = e[1] / 100, r = e[2] / 100; if (0 === n)
                return [255 * r, 255 * r, 255 * r]; var o, i = [0, 0, 0], s = t % 1 * 6, a = s % 1, u = 1 - a; switch (Math.floor(s)) {
                case 0:
                    i[0] = 1, i[1] = a, i[2] = 0;
                    break;
                case 1:
                    i[0] = u, i[1] = 1, i[2] = 0;
                    break;
                case 2:
                    i[0] = 0, i[1] = 1, i[2] = a;
                    break;
                case 3:
                    i[0] = 0, i[1] = u, i[2] = 1;
                    break;
                case 4:
                    i[0] = a, i[1] = 0, i[2] = 1;
                    break;
                default: i[0] = 1, i[1] = 0, i[2] = u;
            } return o = (1 - n) * r, [255 * (n * i[0] + o), 255 * (n * i[1] + o), 255 * (n * i[2] + o)]; }, r.hcg.hsv = function (e) { var t = e[1] / 100, n = t + e[2] / 100 * (1 - t), r = 0; return n > 0 && (r = t / n), [e[0], 100 * r, 100 * n]; }, r.hcg.hsl = function (e) { var t = e[1] / 100, n = e[2] / 100 * (1 - t) + .5 * t, r = 0; return n > 0 && n < .5 ? r = t / (2 * n) : n >= .5 && n < 1 && (r = t / (2 * (1 - n))), [e[0], 100 * r, 100 * n]; }, r.hcg.hwb = function (e) { var t = e[1] / 100, n = t + e[2] / 100 * (1 - t); return [e[0], 100 * (n - t), 100 * (1 - n)]; }, r.hwb.hcg = function (e) { var t = e[1] / 100, n = 1 - e[2] / 100, r = n - t, o = 0; return r < 1 && (o = (n - r) / (1 - r)), [e[0], 100 * r, 100 * o]; }, r.apple.rgb = function (e) { return [e[0] / 65535 * 255, e[1] / 65535 * 255, e[2] / 65535 * 255]; }, r.rgb.apple = function (e) { return [e[0] / 255 * 65535, e[1] / 255 * 65535, e[2] / 255 * 65535]; }, r.gray.rgb = function (e) { return [e[0] / 100 * 255, e[0] / 100 * 255, e[0] / 100 * 255]; }, r.gray.hsl = r.gray.hsv = function (e) { return [0, 0, e[0]]; }, r.gray.hwb = function (e) { return [0, 100, e[0]]; }, r.gray.cmyk = function (e) { return [0, 0, 0, e[0]]; }, r.gray.lab = function (e) { return [e[0], 0, 0]; }, r.gray.hex = function (e) { var t = 255 & Math.round(e[0] / 100 * 255), n = ((t << 16) + (t << 8) + t).toString(16).toUpperCase(); return "000000".substring(n.length) + n; }, r.rgb.gray = function (e) { return [(e[0] + e[1] + e[2]) / 3 / 255 * 100]; }; })); function Pn(e, t) { return function (n) { return t(e(n)); }; } function Mn(e, t) { for (var n = [t[e].parent, e], r = Nn[t[e].parent][e], o = t[e].parent; t[o].parent;)
                n.unshift(t[o].parent), r = Pn(Nn[t[o].parent][o], r), o = t[o].parent; return r.conversion = n, r; } Nn.rgb, Nn.hsl, Nn.hsv, Nn.hwb, Nn.cmyk, Nn.xyz, Nn.lab, Nn.lch, Nn.hex, Nn.keyword, Nn.ansi16, Nn.ansi256, Nn.hcg, Nn.apple, Nn.gray; var Rn = {}; Object.keys(Nn).forEach((function (e) { Rn[e] = {}, Object.defineProperty(Rn[e], "channels", { value: Nn[e].channels }), Object.defineProperty(Rn[e], "labels", { value: Nn[e].labels }); var t = function (e) { for (var t = function (e) { var t = function () { for (var e = {}, t = Object.keys(Nn), n = t.length, r = 0; r < n; r++)
                e[t[r]] = { distance: -1, parent: null }; return e; }(), n = [e]; for (t[e].distance = 0; n.length;)
                for (var r = n.pop(), o = Object.keys(Nn[r]), i = o.length, s = 0; s < i; s++) {
                    var a = o[s], u = t[a];
                    -1 === u.distance && (u.distance = t[r].distance + 1, u.parent = r, n.unshift(a));
                } return t; }(e), n = {}, r = Object.keys(t), o = r.length, i = 0; i < o; i++) {
                var s = r[i];
                null !== t[s].parent && (n[s] = Mn(s, t));
            } return n; }(e); Object.keys(t).forEach((function (n) { var r = t[n]; Rn[e][n] = function (e) { var t = function (t) { if (null == t)
                return t; arguments.length > 1 && (t = Array.prototype.slice.call(arguments)); var n = e(t); if ("object" == typeof n)
                for (var r = n.length, o = 0; o < r; o++)
                    n[o] = Math.round(n[o]); return n; }; return "conversion" in e && (t.conversion = e.conversion), t; }(r), Rn[e][n].raw = function (e) { var t = function (t) { return null == t ? t : (arguments.length > 1 && (t = Array.prototype.slice.call(arguments)), e(t)); }; return "conversion" in e && (t.conversion = e.conversion), t; }(r); })); })); var In = Rn, jn = st((function (e) { const t = (e, t) => function () { const n = e.apply(In, arguments); return "[".concat(n + t, "m"); }, n = (e, t) => function () { const n = e.apply(In, arguments); return "[".concat(38 + t, ";5;").concat(n, "m"); }, r = (e, t) => function () { const n = e.apply(In, arguments); return "[".concat(38 + t, ";2;").concat(n[0], ";").concat(n[1], ";").concat(n[2], "m"); }; Object.defineProperty(e, "exports", { enumerable: !0, get: function () { const e = new Map, o = { modifier: { reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29] }, color: { black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], gray: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39] }, bgColor: { bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49] } }; o.color.grey = o.color.gray; for (const t of Object.keys(o)) {
                    const n = o[t];
                    for (const t of Object.keys(n)) {
                        const r = n[t];
                        o[t] = { open: "[".concat(r[0], "m"), close: "[".concat(r[1], "m") }, n[t] = o[t], e.set(r[0], r[1]);
                    }
                    Object.defineProperty(o, t, { value: n, enumerable: !1 }), Object.defineProperty(o, "codes", { value: e, enumerable: !1 });
                } const i = e => e, s = (e, t, n) => [e, t, n]; o.color.close = "[39m", o.bgColor.close = "[49m", o.color.ansi = { ansi: t(i, 0) }, o.color.ansi256 = { ansi256: n(i, 0) }, o.color.ansi16m = { rgb: r(s, 0) }, o.bgColor.ansi = { ansi: t(i, 10) }, o.bgColor.ansi256 = { ansi256: n(i, 10) }, o.bgColor.ansi16m = { rgb: r(s, 10) }; for (let e of Object.keys(In)) {
                    if ("object" != typeof In[e])
                        continue;
                    const i = In[e];
                    "ansi16" === e && (e = "ansi"), "ansi16" in i && (o.color.ansi[e] = t(i.ansi16, 0), o.bgColor.ansi[e] = t(i.ansi16, 10)), "ansi256" in i && (o.color.ansi256[e] = n(i.ansi256, 0), o.bgColor.ansi256[e] = n(i.ansi256, 10)), "rgb" in i && (o.color.ansi16m[e] = r(i.rgb, 0), o.bgColor.ansi16m[e] = r(i.rgb, 10));
                } return o; } }); })), Bn = { EOL: "\n" }, Ln = (e, t) => { t = t || Bt.argv; const n = e.startsWith("-") ? "" : 1 === e.length ? "-" : "--", r = t.indexOf(n + e), o = t.indexOf("--"); return -1 !== r && (-1 === o || r < o); }; const qn = Bt.env; let $n; function Un(e) { const t = function (e) { if (!1 === $n)
                return 0; if (Ln("color=16m") || Ln("color=full") || Ln("color=truecolor"))
                return 3; if (Ln("color=256"))
                return 2; if (e && !e.isTTY && !0 !== $n)
                return 0; const t = $n ? 1 : 0; if ("win32" === Bt.platform) {
                const e = Bn.release().split(".");
                return Number(Bt.versions.node.split(".")[0]) >= 8 && Number(e[0]) >= 10 && Number(e[2]) >= 10586 ? Number(e[2]) >= 14931 ? 3 : 2 : 1;
            } if ("CI" in qn)
                return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((e => e in qn)) || "codeship" === qn.CI_NAME ? 1 : t; if ("TEAMCITY_VERSION" in qn)
                return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(qn.TEAMCITY_VERSION) ? 1 : 0; if ("truecolor" === qn.COLORTERM)
                return 3; if ("TERM_PROGRAM" in qn) {
                const e = parseInt((qn.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
                switch (qn.TERM_PROGRAM) {
                    case "iTerm.app": return e >= 3 ? 3 : 2;
                    case "Apple_Terminal": return 2;
                }
            } return /-256(color)?$/i.test(qn.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(qn.TERM) || "COLORTERM" in qn ? 1 : (qn.TERM, t); }(e); return function (e) { return 0 !== e && { level: e, hasBasic: !0, has256: e >= 2, has16m: e >= 3 }; }(t); } Ln("no-color") || Ln("no-colors") || Ln("color=false") ? $n = !1 : (Ln("color") || Ln("colors") || Ln("color=true") || Ln("color=always")) && ($n = !0), "FORCE_COLOR" in qn && ($n = 0 === qn.FORCE_COLOR.length || 0 !== parseInt(qn.FORCE_COLOR, 10)); var Vn = { supportsColor: Un, stdout: Un(Bt.stdout), stderr: Un(Bt.stderr) }; const Wn = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, Kn = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, zn = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, Hn = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, Yn = new Map([["n", "\n"], ["r", "\r"], ["t", "\t"], ["b", "\b"], ["f", "\f"], ["v", "\v"], ["0", "\0"], ["\\", "\\"], ["e", ""], ["a", ""]]); function Jn(e) { return "u" === e[0] && 5 === e.length || "x" === e[0] && 3 === e.length ? String.fromCharCode(parseInt(e.slice(1), 16)) : Yn.get(e) || e; } function Gn(e, t) { const n = [], r = t.trim().split(/\s*,\s*/g); let o; for (const t of r)
                if (isNaN(t)) {
                    if (!(o = t.match(zn)))
                        throw new Error("Invalid Chalk template style argument: ".concat(t, " (in style '").concat(e, "')"));
                    n.push(o[2].replace(Hn, ((e, t, n) => t ? Jn(t) : n)));
                }
                else
                    n.push(Number(t)); return n; } function Xn(e) { Kn.lastIndex = 0; const t = []; let n; for (; null !== (n = Kn.exec(e));) {
                const e = n[1];
                if (n[2]) {
                    const r = Gn(e, n[2]);
                    t.push([e].concat(r));
                }
                else
                    t.push([e]);
            } return t; } function Qn(e, t) { const n = {}; for (const e of t)
                for (const t of e.styles)
                    n[t[0]] = e.inverse ? null : t.slice(1); let r = e; for (const e of Object.keys(n))
                if (Array.isArray(n[e])) {
                    if (!(e in r))
                        throw new Error("Unknown Chalk style: ".concat(e));
                    r = n[e].length > 0 ? r[e].apply(r, n[e]) : r[e];
                } return r; } var Zn = (e, t) => { const n = [], r = []; let o = []; if (t.replace(Wn, ((t, i, s, a, u, c) => { if (i)
                o.push(Jn(i));
            else if (a) {
                const t = o.join("");
                o = [], r.push(0 === n.length ? t : Qn(e, n)(t)), n.push({ inverse: s, styles: Xn(a) });
            }
            else if (u) {
                if (0 === n.length)
                    throw new Error("Found extraneous } in Chalk template literal");
                r.push(Qn(e, n)(o.join(""))), o = [], n.pop();
            }
            else
                o.push(c); })), r.push(o.join("")), n.length > 0) {
                const e = "Chalk template literal is missing ".concat(n.length, " closing bracket").concat(1 === n.length ? "" : "s", " (`}`)");
                throw new Error(e);
            } return r.join(""); }, er = st((function (e) { const t = Vn.stdout, n = "win32" === Bt.platform && !(Bt.env.TERM || "").toLowerCase().startsWith("xterm"), r = ["ansi", "ansi", "ansi256", "ansi16m"], o = new Set(["gray"]), i = Object.create(null); function s(e, n) { n = n || {}; const r = t ? t.level : 0; e.level = void 0 === n.level ? r : n.level, e.enabled = "enabled" in n ? n.enabled : e.level > 0; } function a(e) { if (!this || !(this instanceof a) || this.template) {
                const t = {};
                return s(t, e), t.template = function () { const e = [].slice.call(arguments); return p.apply(null, [t.template].concat(e)); }, Object.setPrototypeOf(t, a.prototype), Object.setPrototypeOf(t.template, t), t.template.constructor = a, t.template;
            } s(this, e); } n && (jn.blue.open = "[94m"); for (const e of Object.keys(jn))
                jn[e].closeRe = new RegExp(On(jn[e].close), "g"), i[e] = { get() { const t = jn[e]; return c.call(this, this._styles ? this._styles.concat(t) : [t], this._empty, e); } }; i.visible = { get() { return c.call(this, this._styles || [], !0, "visible"); } }, jn.color.closeRe = new RegExp(On(jn.color.close), "g"); for (const e of Object.keys(jn.color.ansi))
                o.has(e) || (i[e] = { get() { const t = this.level; return function () { const n = jn.color[r[t]][e].apply(null, arguments), o = { open: n, close: jn.color.close, closeRe: jn.color.closeRe }; return c.call(this, this._styles ? this._styles.concat(o) : [o], this._empty, e); }; } }); jn.bgColor.closeRe = new RegExp(On(jn.bgColor.close), "g"); for (const e of Object.keys(jn.bgColor.ansi))
                o.has(e) || (i["bg" + e[0].toUpperCase() + e.slice(1)] = { get() { const t = this.level; return function () { const n = jn.bgColor[r[t]][e].apply(null, arguments), o = { open: n, close: jn.bgColor.close, closeRe: jn.bgColor.closeRe }; return c.call(this, this._styles ? this._styles.concat(o) : [o], this._empty, e); }; } }); const u = Object.defineProperties((() => { }), i); function c(e, t, n) { const r = function e() { return l.apply(e, arguments); }; r._styles = e, r._empty = t; const o = this; return Object.defineProperty(r, "level", { enumerable: !0, get: () => o.level, set(e) { o.level = e; } }), Object.defineProperty(r, "enabled", { enumerable: !0, get: () => o.enabled, set(e) { o.enabled = e; } }), r.hasGrey = this.hasGrey || "gray" === n || "grey" === n, r.__proto__ = u, r; } function l() { const e = arguments, t = e.length; let r = String(arguments[0]); if (0 === t)
                return ""; if (t > 1)
                for (let n = 1; n < t; n++)
                    r += " " + e[n]; if (!this.enabled || this.level <= 0 || !r)
                return this._empty ? "" : r; const o = jn.dim.open; n && this.hasGrey && (jn.dim.open = ""); for (const e of this._styles.slice().reverse())
                r = e.open + r.replace(e.closeRe, e.open) + e.close, r = r.replace(/\r?\n/g, "".concat(e.close, "$&").concat(e.open)); return jn.dim.open = o, r; } function p(e, t) { if (!Array.isArray(t))
                return [].slice.call(arguments, 1).join(" "); const n = [].slice.call(arguments, 2), r = [t.raw[0]]; for (let e = 1; e < t.length; e++)
                r.push(String(n[e - 1]).replace(/[{}\\]/g, "\\$&")), r.push(String(t.raw[e])); return Zn(e, r.join("")); } Object.defineProperties(a.prototype, i), e.exports = a(), e.exports.supportsColor = t, e.exports.default = e.exports; })), tr = (er.supportsColor, st((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.commonDeprecatedHandler = (e, t, { descriptor: n }) => { const r = ["".concat(er.default.yellow("string" == typeof e ? n.key(e) : n.pair(e)), " is deprecated")]; return t && r.push("we now treat it as ".concat(er.default.blue("string" == typeof t ? n.key(t) : n.pair(t)))), r.join("; ") + "."; }; }))); it(tr), tr.commonDeprecatedHandler; var nr = st((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), Tn.__exportStar(tr, t); })); it(nr); var rr = st((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.commonInvalidHandler = (e, t, n) => ["Invalid ".concat(er.default.red(n.descriptor.key(e)), " value."), "Expected ".concat(er.default.blue(n.schemas[e].expected(n)), ","), "but received ".concat(er.default.red(n.descriptor.value(t)), ".")].join(" "); })); it(rr), rr.commonInvalidHandler; var or = st((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), Tn.__exportStar(rr, t); })); it(or); var ir = [], sr = [], ar = st((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.levenUnknownHandler = (e, t, { descriptor: n, logger: r, schemas: o }) => { const i = ["Ignored unknown option ".concat(er.default.yellow(n.pair({ key: e, value: t })), ".")], s = Object.keys(o).sort().find((t => function (e, t) { if (e === t)
                return 0; var n = e; e.length > t.length && (e = t, t = n); var r = e.length, o = t.length; if (0 === r)
                return o; if (0 === o)
                return r; for (; r > 0 && e.charCodeAt(~-r) === t.charCodeAt(~-o);)
                r--, o--; if (0 === r)
                return o; for (var i, s, a, u, c = 0; c < r && e.charCodeAt(c) === t.charCodeAt(c);)
                c++; if (o -= c, 0 == (r -= c))
                return o; for (var l = 0, p = 0; l < r;)
                sr[c + l] = e.charCodeAt(c + l), ir[l] = ++l; for (; p < o;)
                for (i = t.charCodeAt(c + p), a = p++, s = p, l = 0; l < r; l++)
                    u = i === sr[c + l] ? a : a + 1, a = ir[l], s = ir[l] = a > s ? u > s ? s + 1 : u : u > a ? a + 1 : u; return s; }(e, t) < 3)); s && i.push("Did you mean ".concat(er.default.blue(n.key(s)), "?")), r.warn(i.join(" ")); }; })); it(ar), ar.levenUnknownHandler; var ur = st((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), Tn.__exportStar(ar, t); })); it(ur); var cr = st((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), Tn.__exportStar(nr, t), Tn.__exportStar(or, t), Tn.__exportStar(ur, t); })); it(cr); var lr = st((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }); const n = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"]; function r(e, t) { const r = new e(t), s = Object.create(r); for (const e of n)
                e in t && (s[e] = i(t[e], r, o.prototype[e].length)); return s; } t.createSchema = r; class o {
                constructor(e) { this.name = e.name; }
                static create(e) { return r(this, e); }
                default(e) { }
                expected(e) { return "nothing"; }
                validate(e, t) { return !1; }
                deprecated(e, t) { return !1; }
                forward(e, t) { }
                redirect(e, t) { }
                overlap(e, t, n) { return e; }
                preprocess(e, t) { return e; }
                postprocess(e, t) { return e; }
            } function i(e, t, n) { return "function" == typeof e ? (...r) => e(...r.slice(0, n - 1), t, ...r.slice(n - 1)) : () => e; } t.Schema = o; })); it(lr), lr.createSchema, lr.Schema; var pr = st((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }); class n extends lr.Schema {
                constructor(e) { super(e), this._sourceName = e.sourceName; }
                expected(e) { return e.schemas[this._sourceName].expected(e); }
                validate(e, t) { return t.schemas[this._sourceName].validate(e, t); }
                redirect(e, t) { return this._sourceName; }
            } t.AliasSchema = n; })); it(pr), pr.AliasSchema; var fr = st((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }); class n extends lr.Schema {
                expected() { return "anything"; }
                validate() { return !0; }
            } t.AnySchema = n; })); it(fr), fr.AnySchema; var dr = st((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }); class n extends lr.Schema {
                constructor(e) { var { valueSchema: t, name: n = t.name } = e, r = Tn.__rest(e, ["valueSchema", "name"]); super(Object.assign({}, r, { name: n })), this._valueSchema = t; }
                expected(e) { return "an array of ".concat(this._valueSchema.expected(e)); }
                validate(e, t) { if (!Array.isArray(e))
                    return !1; const n = []; for (const r of e) {
                    const e = t.normalizeValidateResult(this._valueSchema.validate(r, t), r);
                    !0 !== e && n.push(e.value);
                } return 0 === n.length || { value: n }; }
                deprecated(e, t) { const n = []; for (const r of e) {
                    const e = t.normalizeDeprecatedResult(this._valueSchema.deprecated(r, t), r);
                    !1 !== e && n.push(...e.map((({ value: e }) => ({ value: [e] }))));
                } return n; }
                forward(e, t) { const n = []; for (const o of e) {
                    const e = t.normalizeForwardResult(this._valueSchema.forward(o, t), o);
                    n.push(...e.map(r));
                } return n; }
                redirect(e, t) { const n = [], o = []; for (const i of e) {
                    const e = t.normalizeRedirectResult(this._valueSchema.redirect(i, t), i);
                    "remain" in e && n.push(e.remain), o.push(...e.redirect.map(r));
                } return 0 === n.length ? { redirect: o } : { redirect: o, remain: n }; }
                overlap(e, t) { return e.concat(t); }
            } function r({ from: e, to: t }) { return { from: [e], to: t }; } t.ArraySchema = n; })); it(dr), dr.ArraySchema; var hr = st((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }); class n extends lr.Schema {
                expected() { return "true or false"; }
                validate(e) { return "boolean" == typeof e; }
            } t.BooleanSchema = n; })); it(hr), hr.BooleanSchema; var mr = st((function (e, t) { function n(e, t) { return "string" == typeof e || "key" in e ? { from: t, to: e } : "from" in e ? { from: e.from, to: e.to } : { from: t, to: e.to }; } function r(e, t) { return void 0 === e ? [] : Array.isArray(e) ? e.map((e => n(e, t))) : [n(e, t)]; } Object.defineProperty(t, "__esModule", { value: !0 }), t.recordFromArray = function (e, t) { const n = Object.create(null); for (const r of e) {
                const e = r[t];
                if (n[e])
                    throw new Error("Duplicate ".concat(t, " ").concat(JSON.stringify(e)));
                n[e] = r;
            } return n; }, t.mapFromArray = function (e, t) { const n = new Map; for (const r of e) {
                const e = r[t];
                if (n.has(e))
                    throw new Error("Duplicate ".concat(t, " ").concat(JSON.stringify(e)));
                n.set(e, r);
            } return n; }, t.createAutoChecklist = function () { const e = Object.create(null); return t => { const n = JSON.stringify(t); return !!e[n] || (e[n] = !0, !1); }; }, t.partition = function (e, t) { const n = [], r = []; for (const o of e)
                t(o) ? n.push(o) : r.push(o); return [n, r]; }, t.isInt = function (e) { return e === Math.floor(e); }, t.comparePrimitive = function (e, t) { if (e === t)
                return 0; const n = typeof e, r = typeof t, o = ["undefined", "object", "boolean", "number", "string"]; return n !== r ? o.indexOf(n) - o.indexOf(r) : "string" !== n ? Number(e) - Number(t) : e.localeCompare(t); }, t.normalizeDefaultResult = function (e) { return void 0 === e ? {} : e; }, t.normalizeValidateResult = function (e, t) { return !0 === e || (!1 === e ? { value: t } : e); }, t.normalizeDeprecatedResult = function (e, t, n = !1) { return !1 !== e && (!0 === e ? !!n || [{ value: t }] : "value" in e ? [e] : 0 !== e.length && e); }, t.normalizeTransferResult = n, t.normalizeForwardResult = r, t.normalizeRedirectResult = function (e, t) { const n = r("object" == typeof e && "redirect" in e ? e.redirect : e, t); return 0 === n.length ? { remain: t, redirect: n } : "object" == typeof e && "remain" in e ? { remain: e.remain, redirect: n } : { redirect: n }; }; })); it(mr), mr.recordFromArray, mr.mapFromArray, mr.createAutoChecklist, mr.partition, mr.isInt, mr.comparePrimitive, mr.normalizeDefaultResult, mr.normalizeValidateResult, mr.normalizeDeprecatedResult, mr.normalizeTransferResult, mr.normalizeForwardResult, mr.normalizeRedirectResult; var gr = st((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }); class n extends lr.Schema {
                constructor(e) { super(e), this._choices = mr.mapFromArray(e.choices.map((e => e && "object" == typeof e ? e : { value: e })), "value"); }
                expected({ descriptor: e }) { const t = Array.from(this._choices.keys()).map((e => this._choices.get(e))).filter((e => !e.deprecated)).map((e => e.value)).sort(mr.comparePrimitive).map(e.value), n = t.slice(0, -2), r = t.slice(-2); return n.concat(r.join(" or ")).join(", "); }
                validate(e) { return this._choices.has(e); }
                deprecated(e) { const t = this._choices.get(e); return !(!t || !t.deprecated) && { value: e }; }
                forward(e) { const t = this._choices.get(e); return t ? t.forward : void 0; }
                redirect(e) { const t = this._choices.get(e); return t ? t.redirect : void 0; }
            } t.ChoiceSchema = n; })); it(gr), gr.ChoiceSchema; var yr = st((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }); class n extends lr.Schema {
                expected() { return "a number"; }
                validate(e, t) { return "number" == typeof e; }
            } t.NumberSchema = n; })); it(yr), yr.NumberSchema; var vr = st((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }); class n extends yr.NumberSchema {
                expected() { return "an integer"; }
                validate(e, t) { return !0 === t.normalizeValidateResult(super.validate(e, t), e) && mr.isInt(e); }
            } t.IntegerSchema = n; })); it(vr), vr.IntegerSchema; var br = st((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }); class n extends lr.Schema {
                expected() { return "a string"; }
                validate(e) { return "string" == typeof e; }
            } t.StringSchema = n; })); it(br), br.StringSchema; var Dr = st((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), Tn.__exportStar(pr, t), Tn.__exportStar(fr, t), Tn.__exportStar(dr, t), Tn.__exportStar(hr, t), Tn.__exportStar(gr, t), Tn.__exportStar(vr, t), Tn.__exportStar(yr, t), Tn.__exportStar(br, t); })); it(Dr); var Er = st((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.defaultDescriptor = xn.apiDescriptor, t.defaultUnknownHandler = ar.levenUnknownHandler, t.defaultInvalidHandler = or.commonInvalidHandler, t.defaultDeprecatedHandler = tr.commonDeprecatedHandler; })); it(Er), Er.defaultDescriptor, Er.defaultUnknownHandler, Er.defaultInvalidHandler, Er.defaultDeprecatedHandler; var Cr = st((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.normalize = (e, t, r) => new n(t, r).normalize(e); class n {
                constructor(e, t) { const { logger: n = a, descriptor: r = Er.defaultDescriptor, unknown: o = Er.defaultUnknownHandler, invalid: i = Er.defaultInvalidHandler, deprecated: s = Er.defaultDeprecatedHandler } = t || {}; this._utils = { descriptor: r, logger: n || { warn: () => { } }, schemas: mr.recordFromArray(e, "name"), normalizeDefaultResult: mr.normalizeDefaultResult, normalizeDeprecatedResult: mr.normalizeDeprecatedResult, normalizeForwardResult: mr.normalizeForwardResult, normalizeRedirectResult: mr.normalizeRedirectResult, normalizeValidateResult: mr.normalizeValidateResult }, this._unknownHandler = o, this._invalidHandler = i, this._deprecatedHandler = s, this.cleanHistory(); }
                cleanHistory() { this._hasDeprecationWarned = mr.createAutoChecklist(); }
                normalize(e) { const t = {}, n = [e], r = () => { for (; 0 !== n.length;) {
                    const e = n.shift(), r = this._applyNormalization(e, t);
                    n.push(...r);
                } }; r(); for (const e of Object.keys(this._utils.schemas)) {
                    const r = this._utils.schemas[e];
                    if (!(e in t)) {
                        const t = mr.normalizeDefaultResult(r.default(this._utils));
                        "value" in t && n.push({ [e]: t.value });
                    }
                } r(); for (const e of Object.keys(this._utils.schemas)) {
                    const n = this._utils.schemas[e];
                    e in t && (t[e] = n.postprocess(t[e], this._utils));
                } return t; }
                _applyNormalization(e, t) { const n = [], [r, o] = mr.partition(Object.keys(e), (e => e in this._utils.schemas)); for (const o of r) {
                    const r = this._utils.schemas[o], i = r.preprocess(e[o], this._utils), s = mr.normalizeValidateResult(r.validate(i, this._utils), i);
                    if (!0 !== s) {
                        const { value: e } = s, t = this._invalidHandler(o, e, this._utils);
                        throw "string" == typeof t ? new Error(t) : t;
                    }
                    const a = ({ from: e, to: t }) => { n.push("string" == typeof t ? { [t]: e } : { [t.key]: t.value }); }, u = ({ value: e, redirectTo: t }) => { const n = mr.normalizeDeprecatedResult(r.deprecated(e, this._utils), i, !0); if (!1 !== n)
                        if (!0 === n)
                            this._hasDeprecationWarned(o) || this._utils.logger.warn(this._deprecatedHandler(o, t, this._utils));
                        else
                            for (const { value: e } of n) {
                                const n = { key: o, value: e };
                                if (!this._hasDeprecationWarned(n)) {
                                    const r = "string" == typeof t ? { key: t, value: e } : t;
                                    this._utils.logger.warn(this._deprecatedHandler(n, r, this._utils));
                                }
                            } };
                    mr.normalizeForwardResult(r.forward(i, this._utils), i).forEach(a);
                    const c = mr.normalizeRedirectResult(r.redirect(i, this._utils), i);
                    if (c.redirect.forEach(a), "remain" in c) {
                        const e = c.remain;
                        t[o] = o in t ? r.overlap(t[o], e, this._utils) : e, u({ value: e });
                    }
                    for (const { from: e, to: t } of c.redirect)
                        u({ value: e, redirectTo: t });
                } for (const r of o) {
                    const o = e[r], i = this._unknownHandler(r, o, this._utils);
                    if (i)
                        for (const e of Object.keys(i)) {
                            const r = { [e]: i[e] };
                            e in this._utils.schemas ? n.push(r) : Object.assign(t, r);
                        }
                } return n; }
            } t.Normalizer = n; })); it(Cr), Cr.normalize, Cr.Normalizer; var wr = st((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), Tn.__exportStar(kn, t), Tn.__exportStar(cr, t), Tn.__exportStar(Dr, t), Tn.__exportStar(Cr, t), Tn.__exportStar(lr, t); })); it(wr); const Ar = [], Sr = [], xr = (e, t) => { if (e === t)
                return 0; const n = e; e.length > t.length && (e = t, t = n); let r = e.length, o = t.length; for (; r > 0 && e.charCodeAt(~-r) === t.charCodeAt(~-o);)
                r--, o--; let i, s, a, u, c = 0; for (; c < r && e.charCodeAt(c) === t.charCodeAt(c);)
                c++; if (r -= c, o -= c, 0 === r)
                return o; let l = 0, p = 0; for (; l < r;)
                Sr[l] = e.charCodeAt(c + l), Ar[l] = ++l; for (; p < o;)
                for (i = t.charCodeAt(c + p), a = p++, s = p, l = 0; l < r; l++)
                    u = i === Sr[l] ? a : a + 1, a = Ar[l], s = Ar[l] = a > s ? u > s ? s + 1 : u : u > a ? a + 1 : u; return s; }; var Tr = xr, kr = xr; Tr.default = kr; var Fr = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] }; const Or = {}; for (const e of Object.keys(Fr))
                Or[Fr[e]] = e; const _r = { rgb: { channels: 3, labels: "rgb" }, hsl: { channels: 3, labels: "hsl" }, hsv: { channels: 3, labels: "hsv" }, hwb: { channels: 3, labels: "hwb" }, cmyk: { channels: 4, labels: "cmyk" }, xyz: { channels: 3, labels: "xyz" }, lab: { channels: 3, labels: "lab" }, lch: { channels: 3, labels: "lch" }, hex: { channels: 1, labels: ["hex"] }, keyword: { channels: 1, labels: ["keyword"] }, ansi16: { channels: 1, labels: ["ansi16"] }, ansi256: { channels: 1, labels: ["ansi256"] }, hcg: { channels: 3, labels: ["h", "c", "g"] }, apple: { channels: 3, labels: ["r16", "g16", "b16"] }, gray: { channels: 1, labels: ["gray"] } }; var Nr = _r; for (const e of Object.keys(_r)) {
                if (!("channels" in _r[e]))
                    throw new Error("missing channels property: " + e);
                if (!("labels" in _r[e]))
                    throw new Error("missing channel labels property: " + e);
                if (_r[e].labels.length !== _r[e].channels)
                    throw new Error("channel and label counts mismatch: " + e);
                const { channels: t, labels: n } = _r[e];
                delete _r[e].channels, delete _r[e].labels, Object.defineProperty(_r[e], "channels", { value: t }), Object.defineProperty(_r[e], "labels", { value: n });
            } function Pr(e, t) { return function (n) { return t(e(n)); }; } function Mr(e, t) { const n = [t[e].parent, e]; let r = Nr[t[e].parent][e], o = t[e].parent; for (; t[o].parent;)
                n.unshift(t[o].parent), r = Pr(Nr[t[o].parent][o], r), o = t[o].parent; return r.conversion = n, r; } _r.rgb.hsl = function (e) { const t = e[0] / 255, n = e[1] / 255, r = e[2] / 255, o = Math.min(t, n, r), i = Math.max(t, n, r), s = i - o; let a, u; i === o ? a = 0 : t === i ? a = (n - r) / s : n === i ? a = 2 + (r - t) / s : r === i && (a = 4 + (t - n) / s), a = Math.min(60 * a, 360), a < 0 && (a += 360); const c = (o + i) / 2; return u = i === o ? 0 : c <= .5 ? s / (i + o) : s / (2 - i - o), [a, 100 * u, 100 * c]; }, _r.rgb.hsv = function (e) { let t, n, r, o, i; const s = e[0] / 255, a = e[1] / 255, u = e[2] / 255, c = Math.max(s, a, u), l = c - Math.min(s, a, u), p = function (e) { return (c - e) / 6 / l + .5; }; return 0 === l ? (o = 0, i = 0) : (i = l / c, t = p(s), n = p(a), r = p(u), s === c ? o = r - n : a === c ? o = 1 / 3 + t - r : u === c && (o = 2 / 3 + n - t), o < 0 ? o += 1 : o > 1 && (o -= 1)), [360 * o, 100 * i, 100 * c]; }, _r.rgb.hwb = function (e) { const t = e[0], n = e[1]; let r = e[2]; const o = _r.rgb.hsl(e)[0], i = 1 / 255 * Math.min(t, Math.min(n, r)); return r = 1 - 1 / 255 * Math.max(t, Math.max(n, r)), [o, 100 * i, 100 * r]; }, _r.rgb.cmyk = function (e) { const t = e[0] / 255, n = e[1] / 255, r = e[2] / 255, o = Math.min(1 - t, 1 - n, 1 - r); return [100 * ((1 - t - o) / (1 - o) || 0), 100 * ((1 - n - o) / (1 - o) || 0), 100 * ((1 - r - o) / (1 - o) || 0), 100 * o]; }, _r.rgb.keyword = function (e) { const t = Or[e]; if (t)
                return t; let n, r = 1 / 0; for (const t of Object.keys(Fr)) {
                const s = (i = Fr[t], ((o = e)[0] - i[0]) ** 2 + (o[1] - i[1]) ** 2 + (o[2] - i[2]) ** 2);
                s < r && (r = s, n = t);
            } var o, i; return n; }, _r.keyword.rgb = function (e) { return Fr[e]; }, _r.rgb.xyz = function (e) { let t = e[0] / 255, n = e[1] / 255, r = e[2] / 255; return t = t > .04045 ? ((t + .055) / 1.055) ** 2.4 : t / 12.92, n = n > .04045 ? ((n + .055) / 1.055) ** 2.4 : n / 12.92, r = r > .04045 ? ((r + .055) / 1.055) ** 2.4 : r / 12.92, [100 * (.4124 * t + .3576 * n + .1805 * r), 100 * (.2126 * t + .7152 * n + .0722 * r), 100 * (.0193 * t + .1192 * n + .9505 * r)]; }, _r.rgb.lab = function (e) { const t = _r.rgb.xyz(e); let n = t[0], r = t[1], o = t[2]; return n /= 95.047, r /= 100, o /= 108.883, n = n > .008856 ? n ** (1 / 3) : 7.787 * n + 16 / 116, r = r > .008856 ? r ** (1 / 3) : 7.787 * r + 16 / 116, o = o > .008856 ? o ** (1 / 3) : 7.787 * o + 16 / 116, [116 * r - 16, 500 * (n - r), 200 * (r - o)]; }, _r.hsl.rgb = function (e) { const t = e[0] / 360, n = e[1] / 100, r = e[2] / 100; let o, i, s; if (0 === n)
                return s = 255 * r, [s, s, s]; o = r < .5 ? r * (1 + n) : r + n - r * n; const a = 2 * r - o, u = [0, 0, 0]; for (let e = 0; e < 3; e++)
                i = t + 1 / 3 * -(e - 1), i < 0 && i++, i > 1 && i--, s = 6 * i < 1 ? a + 6 * (o - a) * i : 2 * i < 1 ? o : 3 * i < 2 ? a + (o - a) * (2 / 3 - i) * 6 : a, u[e] = 255 * s; return u; }, _r.hsl.hsv = function (e) { const t = e[0]; let n = e[1] / 100, r = e[2] / 100, o = n; const i = Math.max(r, .01); return r *= 2, n *= r <= 1 ? r : 2 - r, o *= i <= 1 ? i : 2 - i, [t, 100 * (0 === r ? 2 * o / (i + o) : 2 * n / (r + n)), (r + n) / 2 * 100]; }, _r.hsv.rgb = function (e) { const t = e[0] / 60, n = e[1] / 100; let r = e[2] / 100; const o = Math.floor(t) % 6, i = t - Math.floor(t), s = 255 * r * (1 - n), a = 255 * r * (1 - n * i), u = 255 * r * (1 - n * (1 - i)); switch (r *= 255, o) {
                case 0: return [r, u, s];
                case 1: return [a, r, s];
                case 2: return [s, r, u];
                case 3: return [s, a, r];
                case 4: return [u, s, r];
                case 5: return [r, s, a];
            } }, _r.hsv.hsl = function (e) { const t = e[0], n = e[1] / 100, r = e[2] / 100, o = Math.max(r, .01); let i, s; s = (2 - n) * r; const a = (2 - n) * o; return i = n * o, i /= a <= 1 ? a : 2 - a, i = i || 0, s /= 2, [t, 100 * i, 100 * s]; }, _r.hwb.rgb = function (e) { const t = e[0] / 360; let n = e[1] / 100, r = e[2] / 100; const o = n + r; let i; o > 1 && (n /= o, r /= o); const s = Math.floor(6 * t), a = 1 - r; i = 6 * t - s, 0 != (1 & s) && (i = 1 - i); const u = n + i * (a - n); let c, l, p; switch (s) {
                default:
                case 6:
                case 0:
                    c = a, l = u, p = n;
                    break;
                case 1:
                    c = u, l = a, p = n;
                    break;
                case 2:
                    c = n, l = a, p = u;
                    break;
                case 3:
                    c = n, l = u, p = a;
                    break;
                case 4:
                    c = u, l = n, p = a;
                    break;
                case 5: c = a, l = n, p = u;
            } return [255 * c, 255 * l, 255 * p]; }, _r.cmyk.rgb = function (e) { const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100, o = e[3] / 100; return [255 * (1 - Math.min(1, t * (1 - o) + o)), 255 * (1 - Math.min(1, n * (1 - o) + o)), 255 * (1 - Math.min(1, r * (1 - o) + o))]; }, _r.xyz.rgb = function (e) { const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100; let o, i, s; return o = 3.2406 * t + -1.5372 * n + -.4986 * r, i = -.9689 * t + 1.8758 * n + .0415 * r, s = .0557 * t + -.204 * n + 1.057 * r, o = o > .0031308 ? 1.055 * o ** (1 / 2.4) - .055 : 12.92 * o, i = i > .0031308 ? 1.055 * i ** (1 / 2.4) - .055 : 12.92 * i, s = s > .0031308 ? 1.055 * s ** (1 / 2.4) - .055 : 12.92 * s, o = Math.min(Math.max(0, o), 1), i = Math.min(Math.max(0, i), 1), s = Math.min(Math.max(0, s), 1), [255 * o, 255 * i, 255 * s]; }, _r.xyz.lab = function (e) { let t = e[0], n = e[1], r = e[2]; return t /= 95.047, n /= 100, r /= 108.883, t = t > .008856 ? t ** (1 / 3) : 7.787 * t + 16 / 116, n = n > .008856 ? n ** (1 / 3) : 7.787 * n + 16 / 116, r = r > .008856 ? r ** (1 / 3) : 7.787 * r + 16 / 116, [116 * n - 16, 500 * (t - n), 200 * (n - r)]; }, _r.lab.xyz = function (e) { let t, n, r; n = (e[0] + 16) / 116, t = e[1] / 500 + n, r = n - e[2] / 200; const o = n ** 3, i = t ** 3, s = r ** 3; return n = o > .008856 ? o : (n - 16 / 116) / 7.787, t = i > .008856 ? i : (t - 16 / 116) / 7.787, r = s > .008856 ? s : (r - 16 / 116) / 7.787, t *= 95.047, n *= 100, r *= 108.883, [t, n, r]; }, _r.lab.lch = function (e) { const t = e[0], n = e[1], r = e[2]; let o; return o = 360 * Math.atan2(r, n) / 2 / Math.PI, o < 0 && (o += 360), [t, Math.sqrt(n * n + r * r), o]; }, _r.lch.lab = function (e) { const t = e[0], n = e[1], r = e[2] / 360 * 2 * Math.PI; return [t, n * Math.cos(r), n * Math.sin(r)]; }, _r.rgb.ansi16 = function (e, t = null) { const [n, r, o] = e; let i = null === t ? _r.rgb.hsv(e)[2] : t; if (i = Math.round(i / 50), 0 === i)
                return 30; let s = 30 + (Math.round(o / 255) << 2 | Math.round(r / 255) << 1 | Math.round(n / 255)); return 2 === i && (s += 60), s; }, _r.hsv.ansi16 = function (e) { return _r.rgb.ansi16(_r.hsv.rgb(e), e[2]); }, _r.rgb.ansi256 = function (e) { const t = e[0], n = e[1], r = e[2]; return t === n && n === r ? t < 8 ? 16 : t > 248 ? 231 : Math.round((t - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t / 255 * 5) + 6 * Math.round(n / 255 * 5) + Math.round(r / 255 * 5); }, _r.ansi16.rgb = function (e) { let t = e % 10; if (0 === t || 7 === t)
                return e > 50 && (t += 3.5), t = t / 10.5 * 255, [t, t, t]; const n = .5 * (1 + ~~(e > 50)); return [(1 & t) * n * 255, (t >> 1 & 1) * n * 255, (t >> 2 & 1) * n * 255]; }, _r.ansi256.rgb = function (e) { if (e >= 232) {
                const t = 10 * (e - 232) + 8;
                return [t, t, t];
            } let t; return e -= 16, [Math.floor(e / 36) / 5 * 255, Math.floor((t = e % 36) / 6) / 5 * 255, t % 6 / 5 * 255]; }, _r.rgb.hex = function (e) { const t = (((255 & Math.round(e[0])) << 16) + ((255 & Math.round(e[1])) << 8) + (255 & Math.round(e[2]))).toString(16).toUpperCase(); return "000000".substring(t.length) + t; }, _r.hex.rgb = function (e) { const t = e.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i); if (!t)
                return [0, 0, 0]; let n = t[0]; 3 === t[0].length && (n = n.split("").map((e => e + e)).join("")); const r = parseInt(n, 16); return [r >> 16 & 255, r >> 8 & 255, 255 & r]; }, _r.rgb.hcg = function (e) { const t = e[0] / 255, n = e[1] / 255, r = e[2] / 255, o = Math.max(Math.max(t, n), r), i = Math.min(Math.min(t, n), r), s = o - i; let a, u; return a = s < 1 ? i / (1 - s) : 0, u = s <= 0 ? 0 : o === t ? (n - r) / s % 6 : o === n ? 2 + (r - t) / s : 4 + (t - n) / s, u /= 6, u %= 1, [360 * u, 100 * s, 100 * a]; }, _r.hsl.hcg = function (e) { const t = e[1] / 100, n = e[2] / 100, r = n < .5 ? 2 * t * n : 2 * t * (1 - n); let o = 0; return r < 1 && (o = (n - .5 * r) / (1 - r)), [e[0], 100 * r, 100 * o]; }, _r.hsv.hcg = function (e) { const t = e[1] / 100, n = e[2] / 100, r = t * n; let o = 0; return r < 1 && (o = (n - r) / (1 - r)), [e[0], 100 * r, 100 * o]; }, _r.hcg.rgb = function (e) { const t = e[0] / 360, n = e[1] / 100, r = e[2] / 100; if (0 === n)
                return [255 * r, 255 * r, 255 * r]; const o = [0, 0, 0], i = t % 1 * 6, s = i % 1, a = 1 - s; let u = 0; switch (Math.floor(i)) {
                case 0:
                    o[0] = 1, o[1] = s, o[2] = 0;
                    break;
                case 1:
                    o[0] = a, o[1] = 1, o[2] = 0;
                    break;
                case 2:
                    o[0] = 0, o[1] = 1, o[2] = s;
                    break;
                case 3:
                    o[0] = 0, o[1] = a, o[2] = 1;
                    break;
                case 4:
                    o[0] = s, o[1] = 0, o[2] = 1;
                    break;
                default: o[0] = 1, o[1] = 0, o[2] = a;
            } return u = (1 - n) * r, [255 * (n * o[0] + u), 255 * (n * o[1] + u), 255 * (n * o[2] + u)]; }, _r.hcg.hsv = function (e) { const t = e[1] / 100, n = t + e[2] / 100 * (1 - t); let r = 0; return n > 0 && (r = t / n), [e[0], 100 * r, 100 * n]; }, _r.hcg.hsl = function (e) { const t = e[1] / 100, n = e[2] / 100 * (1 - t) + .5 * t; let r = 0; return n > 0 && n < .5 ? r = t / (2 * n) : n >= .5 && n < 1 && (r = t / (2 * (1 - n))), [e[0], 100 * r, 100 * n]; }, _r.hcg.hwb = function (e) { const t = e[1] / 100, n = t + e[2] / 100 * (1 - t); return [e[0], 100 * (n - t), 100 * (1 - n)]; }, _r.hwb.hcg = function (e) { const t = e[1] / 100, n = 1 - e[2] / 100, r = n - t; let o = 0; return r < 1 && (o = (n - r) / (1 - r)), [e[0], 100 * r, 100 * o]; }, _r.apple.rgb = function (e) { return [e[0] / 65535 * 255, e[1] / 65535 * 255, e[2] / 65535 * 255]; }, _r.rgb.apple = function (e) { return [e[0] / 255 * 65535, e[1] / 255 * 65535, e[2] / 255 * 65535]; }, _r.gray.rgb = function (e) { return [e[0] / 100 * 255, e[0] / 100 * 255, e[0] / 100 * 255]; }, _r.gray.hsl = function (e) { return [0, 0, e[0]]; }, _r.gray.hsv = _r.gray.hsl, _r.gray.hwb = function (e) { return [0, 100, e[0]]; }, _r.gray.cmyk = function (e) { return [0, 0, 0, e[0]]; }, _r.gray.lab = function (e) { return [e[0], 0, 0]; }, _r.gray.hex = function (e) { const t = 255 & Math.round(e[0] / 100 * 255), n = ((t << 16) + (t << 8) + t).toString(16).toUpperCase(); return "000000".substring(n.length) + n; }, _r.rgb.gray = function (e) { return [(e[0] + e[1] + e[2]) / 3 / 255 * 100]; }; const Rr = {}; Object.keys(Nr).forEach((e => { Rr[e] = {}, Object.defineProperty(Rr[e], "channels", { value: Nr[e].channels }), Object.defineProperty(Rr[e], "labels", { value: Nr[e].labels }); const t = function (e) { const t = function (e) { const t = function () { const e = {}, t = Object.keys(Nr); for (let n = t.length, r = 0; r < n; r++)
                e[t[r]] = { distance: -1, parent: null }; return e; }(), n = [e]; for (t[e].distance = 0; n.length;) {
                const e = n.pop(), r = Object.keys(Nr[e]);
                for (let o = r.length, i = 0; i < o; i++) {
                    const o = r[i], s = t[o];
                    -1 === s.distance && (s.distance = t[e].distance + 1, s.parent = e, n.unshift(o));
                }
            } return t; }(e), n = {}, r = Object.keys(t); for (let e = r.length, o = 0; o < e; o++) {
                const e = r[o];
                null !== t[e].parent && (n[e] = Mr(e, t));
            } return n; }(e); Object.keys(t).forEach((n => { const r = t[n]; Rr[e][n] = function (e) { const t = function (...t) { const n = t[0]; if (null == n)
                return n; n.length > 1 && (t = n); const r = e(t); if ("object" == typeof r)
                for (let e = r.length, t = 0; t < e; t++)
                    r[t] = Math.round(r[t]); return r; }; return "conversion" in e && (t.conversion = e.conversion), t; }(r), Rr[e][n].raw = function (e) { const t = function (...t) { const n = t[0]; return null == n ? n : (n.length > 1 && (t = n), e(t)); }; return "conversion" in e && (t.conversion = e.conversion), t; }(r); })); })); var Ir = Rr, jr = st((function (e) { const t = (e, t) => (...n) => { const r = e(...n); return "[".concat(r + t, "m"); }, n = (e, t) => (...n) => { const r = e(...n); return "[".concat(38 + t, ";5;").concat(r, "m"); }, r = (e, t) => (...n) => { const r = e(...n); return "[".concat(38 + t, ";2;").concat(r[0], ";").concat(r[1], ";").concat(r[2], "m"); }, o = e => e, i = (e, t, n) => [e, t, n], s = (e, t, n) => { Object.defineProperty(e, t, { get: () => { const r = n(); return Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0 }), r; }, enumerable: !0, configurable: !0 }); }; let a; const u = (e, t, n, r) => { void 0 === a && (a = Ir); const o = r ? 10 : 0, i = {}; for (const [r, s] of Object.entries(a)) {
                const a = "ansi16" === r ? "ansi" : r;
                r === t ? i[a] = e(n, o) : "object" == typeof s && (i[a] = e(s[t], o));
            } return i; }; Object.defineProperty(e, "exports", { enumerable: !0, get: function () { const e = new Map, a = { modifier: { reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29] }, color: { black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], blackBright: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39] }, bgColor: { bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49] } }; a.color.gray = a.color.blackBright, a.bgColor.bgGray = a.bgColor.bgBlackBright, a.color.grey = a.color.blackBright, a.bgColor.bgGrey = a.bgColor.bgBlackBright; for (const [t, n] of Object.entries(a)) {
                    for (const [t, r] of Object.entries(n))
                        a[t] = { open: "[".concat(r[0], "m"), close: "[".concat(r[1], "m") }, n[t] = a[t], e.set(r[0], r[1]);
                    Object.defineProperty(a, t, { value: n, enumerable: !1 });
                } return Object.defineProperty(a, "codes", { value: e, enumerable: !1 }), a.color.close = "[39m", a.bgColor.close = "[49m", s(a.color, "ansi", (() => u(t, "ansi16", o, !1))), s(a.color, "ansi256", (() => u(n, "ansi256", o, !1))), s(a.color, "ansi16m", (() => u(r, "rgb", i, !1))), s(a.bgColor, "ansi", (() => u(t, "ansi16", o, !0))), s(a.bgColor, "ansi256", (() => u(n, "ansi256", o, !0))), s(a.bgColor, "ansi16m", (() => u(r, "rgb", i, !0))), a; } }); })), Br = () => !1, Lr = (e, t = Bt.argv) => { const n = e.startsWith("-") ? "" : 1 === e.length ? "-" : "--", r = t.indexOf(n + e), o = t.indexOf("--"); return -1 !== r && (-1 === o || r < o); }; const { env: qr } = Bt; let $r; function Ur(e) { return 0 !== e && { level: e, hasBasic: !0, has256: e >= 2, has16m: e >= 3 }; } function Vr(e, t) { if (0 === $r)
                return 0; if (Lr("color=16m") || Lr("color=full") || Lr("color=truecolor"))
                return 3; if (Lr("color=256"))
                return 2; if (e && !t && void 0 === $r)
                return 0; const n = $r || 0; if ("dumb" === qr.TERM)
                return n; if ("win32" === Bt.platform) {
                const e = Bn.release().split(".");
                return Number(e[0]) >= 10 && Number(e[2]) >= 10586 ? Number(e[2]) >= 14931 ? 3 : 2 : 1;
            } if ("CI" in qr)
                return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((e => e in qr)) || "codeship" === qr.CI_NAME ? 1 : n; if ("TEAMCITY_VERSION" in qr)
                return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(qr.TEAMCITY_VERSION) ? 1 : 0; if ("GITHUB_ACTIONS" in qr)
                return 1; if ("truecolor" === qr.COLORTERM)
                return 3; if ("TERM_PROGRAM" in qr) {
                const e = parseInt((qr.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
                switch (qr.TERM_PROGRAM) {
                    case "iTerm.app": return e >= 3 ? 3 : 2;
                    case "Apple_Terminal": return 2;
                }
            } return /-256(color)?$/i.test(qr.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(qr.TERM) || "COLORTERM" in qr ? 1 : n; } Lr("no-color") || Lr("no-colors") || Lr("color=false") || Lr("color=never") ? $r = 0 : (Lr("color") || Lr("colors") || Lr("color=true") || Lr("color=always")) && ($r = 1), "FORCE_COLOR" in qr && ($r = "true" === qr.FORCE_COLOR ? 1 : "false" === qr.FORCE_COLOR ? 0 : 0 === qr.FORCE_COLOR.length ? 1 : Math.min(parseInt(qr.FORCE_COLOR, 10), 3)); var Wr = { supportsColor: function (e) { return Ur(Vr(e, e && e.isTTY)); }, stdout: Ur(Vr(!0, Br(1))), stderr: Ur(Vr(!0, Br(2))) }; const Kr = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, zr = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, Hr = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, Yr = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi, Jr = new Map([["n", "\n"], ["r", "\r"], ["t", "\t"], ["b", "\b"], ["f", "\f"], ["v", "\v"], ["0", "\0"], ["\\", "\\"], ["e", ""], ["a", ""]]); function Gr(e) { const t = "u" === e[0], n = "{" === e[1]; return t && !n && 5 === e.length || "x" === e[0] && 3 === e.length ? String.fromCharCode(parseInt(e.slice(1), 16)) : t && n ? String.fromCodePoint(parseInt(e.slice(2, -1), 16)) : Jr.get(e) || e; } function Xr(e, t) { const n = [], r = t.trim().split(/\s*,\s*/g); let o; for (const t of r) {
                const r = Number(t);
                if (Number.isNaN(r)) {
                    if (!(o = t.match(Hr)))
                        throw new Error("Invalid Chalk template style argument: ".concat(t, " (in style '").concat(e, "')"));
                    n.push(o[2].replace(Yr, ((e, t, n) => t ? Gr(t) : n)));
                }
                else
                    n.push(r);
            } return n; } function Qr(e) { zr.lastIndex = 0; const t = []; let n; for (; null !== (n = zr.exec(e));) {
                const e = n[1];
                if (n[2]) {
                    const r = Xr(e, n[2]);
                    t.push([e].concat(r));
                }
                else
                    t.push([e]);
            } return t; } function Zr(e, t) { const n = {}; for (const e of t)
                for (const t of e.styles)
                    n[t[0]] = e.inverse ? null : t.slice(1); let r = e; for (const [e, t] of Object.entries(n))
                if (Array.isArray(t)) {
                    if (!(e in r))
                        throw new Error("Unknown Chalk style: ".concat(e));
                    r = t.length > 0 ? r[e](...t) : r[e];
                } return r; } var eo = (e, t) => { const n = [], r = []; let o = []; if (t.replace(Kr, ((t, i, s, a, u, c) => { if (i)
                o.push(Gr(i));
            else if (a) {
                const t = o.join("");
                o = [], r.push(0 === n.length ? t : Zr(e, n)(t)), n.push({ inverse: s, styles: Qr(a) });
            }
            else if (u) {
                if (0 === n.length)
                    throw new Error("Found extraneous } in Chalk template literal");
                r.push(Zr(e, n)(o.join(""))), o = [], n.pop();
            }
            else
                o.push(c); })), r.push(o.join("")), n.length > 0) {
                const e = "Chalk template literal is missing ".concat(n.length, " closing bracket").concat(1 === n.length ? "" : "s", " (`}`)");
                throw new Error(e);
            } return r.join(""); }; const { stdout: to, stderr: no } = Wr, { stringReplaceAll: ro, stringEncaseCRLFWithFirstIndex: oo } = { stringReplaceAll: (e, t, n) => { let r = e.indexOf(t); if (-1 === r)
                    return e; const o = t.length; let i = 0, s = ""; do {
                    s += e.substr(i, r - i) + t + n, i = r + o, r = e.indexOf(t, i);
                } while (-1 !== r); return s += e.substr(i), s; }, stringEncaseCRLFWithFirstIndex: (e, t, n, r) => { let o = 0, i = ""; do {
                    const s = "\r" === e[r - 1];
                    i += e.substr(o, (s ? r - 1 : r) - o) + t + (s ? "\r\n" : "\n") + n, o = r + 1, r = e.indexOf("\n", o);
                } while (-1 !== r); return i += e.substr(o), i; } }, io = ["ansi", "ansi", "ansi256", "ansi16m"], so = Object.create(null); class ao {
                constructor(e) { return uo(e); }
            } const uo = e => { const t = {}; return ((e, t = {}) => { if (t.level && !(Number.isInteger(t.level) && t.level >= 0 && t.level <= 3))
                throw new Error("The `level` option should be an integer from 0 to 3"); const n = to ? to.level : 0; e.level = void 0 === t.level ? n : t.level; })(t, e), t.template = (...e) => yo(t.template, ...e), Object.setPrototypeOf(t, co.prototype), Object.setPrototypeOf(t.template, t), t.template.constructor = () => { throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead."); }, t.template.Instance = ao, t.template; }; function co(e) { return uo(e); } for (const [e, t] of Object.entries(jr))
                so[e] = { get() { const n = ho(this, fo(t.open, t.close, this._styler), this._isEmpty); return Object.defineProperty(this, e, { value: n }), n; } }; so.visible = { get() { const e = ho(this, this._styler, !0); return Object.defineProperty(this, "visible", { value: e }), e; } }; const lo = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"]; for (const e of lo)
                so[e] = { get() { const { level: t } = this; return function (...n) { const r = fo(jr.color[io[t]][e](...n), jr.color.close, this._styler); return ho(this, r, this._isEmpty); }; } }; for (const e of lo)
                so["bg" + e[0].toUpperCase() + e.slice(1)] = { get() { const { level: t } = this; return function (...n) { const r = fo(jr.bgColor[io[t]][e](...n), jr.bgColor.close, this._styler); return ho(this, r, this._isEmpty); }; } }; const po = Object.defineProperties((() => { }), Object.assign({}, so, { level: { enumerable: !0, get() { return this._generator.level; }, set(e) { this._generator.level = e; } } })), fo = (e, t, n) => { let r, o; return void 0 === n ? (r = e, o = t) : (r = n.openAll + e, o = t + n.closeAll), { open: e, close: t, openAll: r, closeAll: o, parent: n }; }, ho = (e, t, n) => { const r = (...e) => mo(r, 1 === e.length ? "" + e[0] : e.join(" ")); return Object.setPrototypeOf(r, po), r._generator = e, r._styler = t, r._isEmpty = n, r; }, mo = (e, t) => { if (e.level <= 0 || !t)
                return e._isEmpty ? "" : t; let n = e._styler; if (void 0 === n)
                return t; const { openAll: r, closeAll: o } = n; if (-1 !== t.indexOf(""))
                for (; void 0 !== n;)
                    t = ro(t, n.close, n.open), n = n.parent; const i = t.indexOf("\n"); return -1 !== i && (t = oo(t, o, r, i)), r + t + o; }; let go; const yo = (e, ...t) => { const [n] = t; if (!Array.isArray(n))
                return t.join(" "); const r = t.slice(1), o = [n.raw[0]]; for (let e = 1; e < n.length; e++)
                o.push(String(r[e - 1]).replace(/[{}\\]/g, "\\$&"), String(n.raw[e])); return void 0 === go && (go = eo), go(e, o.join("")); }; Object.defineProperties(co.prototype, so); const vo = co(); vo.supportsColor = to, vo.stderr = co({ level: no ? no.level : 0 }), vo.stderr.supportsColor = no; var bo = vo; const Do = { key: e => 1 === e.length ? "-".concat(e) : "--".concat(e), value: e => wr.apiDescriptor.value(e), pair: ({ key: e, value: t }) => !1 === t ? "--no-".concat(e) : !0 === t ? Do.key(e) : "" === t ? "".concat(Do.key(e), " without an argument") : "".concat(Do.key(e), "=").concat(t) }; class Eo extends wr.ChoiceSchema {
                constructor({ name: e, flags: t }) { super({ name: e, choices: t }), this._flags = t.slice().sort(); }
                preprocess(e, t) { if ("string" == typeof e && 0 !== e.length && !this._flags.includes(e)) {
                    const n = this._flags.find((t => Tr(t, e) < 3));
                    if (n)
                        return t.logger.warn(["Unknown flag ".concat(bo.yellow(t.descriptor.value(e)), ","), "did you mean ".concat(bo.blue(t.descriptor.value(n)), "?")].join(" ")), n;
                } return e; }
                expected() { return "a flag"; }
            } let Co; function wo(e, t, { logger: n, isCLI: r = !1, passThrough: o = !1 } = {}) { const i = o ? Array.isArray(o) ? (e, t) => o.includes(e) ? { [e]: t } : void 0 : (e, t) => ({ [e]: t }) : wr.levenUnknownHandler, s = r ? Do : wr.apiDescriptor, a = function (e, { isCLI: t }) { const n = []; t && n.push(wr.AnySchema.create({ name: "_" })); for (const r of e)
                n.push(Ao(r, { isCLI: t, optionInfos: e })), r.alias && t && n.push(wr.AliasSchema.create({ name: r.alias, sourceName: r.name })); return n; }(t, { isCLI: r }), u = new wr.Normalizer(a, { logger: n, unknown: i, descriptor: s }), c = !1 !== n; c && Co && (u._hasDeprecationWarned = Co); const l = u.normalize(e); return c && (Co = u._hasDeprecationWarned), l; } function Ao(e, { isCLI: t, optionInfos: n }) { let r; const o = { name: e.name }, i = {}; switch (e.type) {
                case "int":
                    r = wr.IntegerSchema, t && (o.preprocess = e => Number(e));
                    break;
                case "string":
                case "path":
                    r = wr.StringSchema;
                    break;
                case "choice":
                    r = wr.ChoiceSchema, o.choices = e.choices.map((t => "object" == typeof t && t.redirect ? Object.assign({}, t, { redirect: { to: { key: e.name, value: t.redirect } } }) : t));
                    break;
                case "boolean":
                    r = wr.BooleanSchema;
                    break;
                case "flag":
                    r = Eo, o.flags = n.map((e => [].concat(e.alias || [], e.description ? e.name : [], e.oppositeDescription ? "no-".concat(e.name) : []))).reduce(((e, t) => e.concat(t)), []);
                    break;
                default: throw new Error("Unexpected type ".concat(e.type));
            } if (e.exception ? o.validate = (t, n, r) => e.exception(t) || n.validate(t, r) : o.validate = (e, t, n) => void 0 === e || t.validate(e, n), e.redirect && (i.redirect = t => t ? { to: { key: e.redirect.option, value: e.redirect.value } } : void 0), e.deprecated && (i.deprecated = !0), t && !e.array) {
                const e = o.preprocess || (e => e);
                o.preprocess = (t, n, r) => n.preprocess(e(Array.isArray(t) ? t[t.length - 1] : t), r);
            } return e.array ? wr.ArraySchema.create(Object.assign({}, t ? { preprocess: e => [].concat(e) } : {}, {}, i, { valueSchema: r.create(o) })) : r.create(Object.assign({}, o, {}, i)); } var So = function (e, t, n) { return wo(e, t, n); }, xo = e => e[e.length - 1]; function To(e, t) { return !(t = t || {}).ignoreDecorators && e.declaration && e.declaration.decorators && e.declaration.decorators.length > 0 ? To(e.declaration.decorators[0]) : !t.ignoreDecorators && e.decorators && e.decorators.length > 0 ? To(e.decorators[0]) : e.__location ? e.__location.startOffset : e.range ? e.range[0] : "number" == typeof e.start ? e.start : e.loc ? e.loc.start : null; } function ko(e) { const t = e.nodes && xo(e.nodes); if (t && e.source && !e.source.end && (e = t), e.__location)
                return e.__location.endOffset; const n = e.range ? e.range[1] : "number" == typeof e.end ? e.end : null; return e.typeAnnotation ? Math.max(n, ko(e.typeAnnotation)) : e.loc && !n ? e.loc.end : n; } var Fo = { locStart: To, locEnd: ko, composeLoc: function (e, t = e) { const n = "number" == typeof t ? t : -1, r = To(e), o = -1 !== n ? r + n : ko(t), i = e.loc.start; return { start: r, end: o, range: [r, o], loc: { start: i, end: -1 !== n ? { line: i.line, column: i.column + n } : t.loc.end } }; } }, Oo = st((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g, t.matchToToken = function (e) { var t = { type: "invalid", value: e[0], closed: void 0 }; return e[1] ? (t.type = "string", t.closed = !(!e[3] && !e[4])) : e[5] ? t.type = "comment" : e[6] ? (t.type = "comment", t.closed = !!e[7]) : e[8] ? t.type = "regex" : e[9] ? t.type = "number" : e[10] ? t.type = "name" : e[11] ? t.type = "punctuator" : e[12] && (t.type = "whitespace"), t; }; })); it(Oo), Oo.matchToToken; var _o = st((function (e) { !function () { function t(e) { if (null == e)
                return !1; switch (e.type) {
                case "BlockStatement":
                case "BreakStatement":
                case "ContinueStatement":
                case "DebuggerStatement":
                case "DoWhileStatement":
                case "EmptyStatement":
                case "ExpressionStatement":
                case "ForInStatement":
                case "ForStatement":
                case "IfStatement":
                case "LabeledStatement":
                case "ReturnStatement":
                case "SwitchStatement":
                case "ThrowStatement":
                case "TryStatement":
                case "VariableDeclaration":
                case "WhileStatement":
                case "WithStatement": return !0;
            } return !1; } function n(e) { switch (e.type) {
                case "IfStatement": return null != e.alternate ? e.alternate : e.consequent;
                case "LabeledStatement":
                case "ForStatement":
                case "ForInStatement":
                case "WhileStatement":
                case "WithStatement": return e.body;
            } return null; } e.exports = { isExpression: function (e) { if (null == e)
                    return !1; switch (e.type) {
                    case "ArrayExpression":
                    case "AssignmentExpression":
                    case "BinaryExpression":
                    case "CallExpression":
                    case "ConditionalExpression":
                    case "FunctionExpression":
                    case "Identifier":
                    case "Literal":
                    case "LogicalExpression":
                    case "MemberExpression":
                    case "NewExpression":
                    case "ObjectExpression":
                    case "SequenceExpression":
                    case "ThisExpression":
                    case "UnaryExpression":
                    case "UpdateExpression": return !0;
                } return !1; }, isStatement: t, isIterationStatement: function (e) { if (null == e)
                    return !1; switch (e.type) {
                    case "DoWhileStatement":
                    case "ForInStatement":
                    case "ForStatement":
                    case "WhileStatement": return !0;
                } return !1; }, isSourceElement: function (e) { return t(e) || null != e && "FunctionDeclaration" === e.type; }, isProblematicIfStatement: function (e) { var t; if ("IfStatement" !== e.type)
                    return !1; if (null == e.alternate)
                    return !1; t = e.consequent; do {
                    if ("IfStatement" === t.type && null == t.alternate)
                        return !0;
                    t = n(t);
                } while (t); return !1; }, trailingStatement: n }; }(); })), No = (_o.isExpression, _o.isStatement, _o.isIterationStatement, _o.isSourceElement, _o.isProblematicIfStatement, _o.trailingStatement, st((function (e) { !function () { var t, n, r, o, i, s; function a(e) { return e <= 65535 ? String.fromCharCode(e) : String.fromCharCode(Math.floor((e - 65536) / 1024) + 55296) + String.fromCharCode((e - 65536) % 1024 + 56320); } for (n = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/ }, t = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/, NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ }, r = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279], o = new Array(128), s = 0; s < 128; ++s)
                o[s] = s >= 97 && s <= 122 || s >= 65 && s <= 90 || 36 === s || 95 === s; for (i = new Array(128), s = 0; s < 128; ++s)
                i[s] = s >= 97 && s <= 122 || s >= 65 && s <= 90 || s >= 48 && s <= 57 || 36 === s || 95 === s; e.exports = { isDecimalDigit: function (e) { return 48 <= e && e <= 57; }, isHexDigit: function (e) { return 48 <= e && e <= 57 || 97 <= e && e <= 102 || 65 <= e && e <= 70; }, isOctalDigit: function (e) { return e >= 48 && e <= 55; }, isWhiteSpace: function (e) { return 32 === e || 9 === e || 11 === e || 12 === e || 160 === e || e >= 5760 && r.indexOf(e) >= 0; }, isLineTerminator: function (e) { return 10 === e || 13 === e || 8232 === e || 8233 === e; }, isIdentifierStartES5: function (e) { return e < 128 ? o[e] : n.NonAsciiIdentifierStart.test(a(e)); }, isIdentifierPartES5: function (e) { return e < 128 ? i[e] : n.NonAsciiIdentifierPart.test(a(e)); }, isIdentifierStartES6: function (e) { return e < 128 ? o[e] : t.NonAsciiIdentifierStart.test(a(e)); }, isIdentifierPartES6: function (e) { return e < 128 ? i[e] : t.NonAsciiIdentifierPart.test(a(e)); } }; }(); }))), Po = (No.isDecimalDigit, No.isHexDigit, No.isOctalDigit, No.isWhiteSpace, No.isLineTerminator, No.isIdentifierStartES5, No.isIdentifierPartES5, No.isIdentifierStartES6, No.isIdentifierPartES6, st((function (e) { !function () { var t = No; function n(e, t) { return !(!t && "yield" === e) && r(e, t); } function r(e, t) { if (t && function (e) { switch (e) {
                case "implements":
                case "interface":
                case "package":
                case "private":
                case "protected":
                case "public":
                case "static":
                case "let": return !0;
                default: return !1;
            } }(e))
                return !0; switch (e.length) {
                case 2: return "if" === e || "in" === e || "do" === e;
                case 3: return "var" === e || "for" === e || "new" === e || "try" === e;
                case 4: return "this" === e || "else" === e || "case" === e || "void" === e || "with" === e || "enum" === e;
                case 5: return "while" === e || "break" === e || "catch" === e || "throw" === e || "const" === e || "yield" === e || "class" === e || "super" === e;
                case 6: return "return" === e || "typeof" === e || "delete" === e || "switch" === e || "export" === e || "import" === e;
                case 7: return "default" === e || "finally" === e || "extends" === e;
                case 8: return "function" === e || "continue" === e || "debugger" === e;
                case 10: return "instanceof" === e;
                default: return !1;
            } } function o(e, t) { return "null" === e || "true" === e || "false" === e || n(e, t); } function i(e, t) { return "null" === e || "true" === e || "false" === e || r(e, t); } function s(e) { var n, r, o; if (0 === e.length)
                return !1; if (o = e.charCodeAt(0), !t.isIdentifierStartES5(o))
                return !1; for (n = 1, r = e.length; n < r; ++n)
                if (o = e.charCodeAt(n), !t.isIdentifierPartES5(o))
                    return !1; return !0; } function a(e) { var n, r, o, i, s; if (0 === e.length)
                return !1; for (s = t.isIdentifierStartES6, n = 0, r = e.length; n < r; ++n) {
                if (55296 <= (o = e.charCodeAt(n)) && o <= 56319) {
                    if (++n >= r)
                        return !1;
                    if (!(56320 <= (i = e.charCodeAt(n)) && i <= 57343))
                        return !1;
                    o = 1024 * (o - 55296) + (i - 56320) + 65536;
                }
                if (!s(o))
                    return !1;
                s = t.isIdentifierPartES6;
            } return !0; } e.exports = { isKeywordES5: n, isKeywordES6: r, isReservedWordES5: o, isReservedWordES6: i, isRestrictedWord: function (e) { return "eval" === e || "arguments" === e; }, isIdentifierNameES5: s, isIdentifierNameES6: a, isIdentifierES5: function (e, t) { return s(e) && !o(e, t); }, isIdentifierES6: function (e, t) { return a(e) && !i(e, t); } }; }(); }))), Mo = (Po.isKeywordES5, Po.isKeywordES6, Po.isReservedWordES5, Po.isReservedWordES6, Po.isRestrictedWord, Po.isIdentifierNameES5, Po.isIdentifierNameES6, Po.isIdentifierES5, Po.isIdentifierES6, st((function (e, t) { t.ast = _o, t.code = No, t.keyword = Po; }))), Ro = (Mo.ast, Mo.code, Mo.keyword, /[|\\{}()[\]^$+*?.]/g), Io = function (e) { if ("string" != typeof e)
                throw new TypeError("Expected a string"); return e.replace(Ro, "\\$&"); }, jo = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] }, Bo = st((function (e) { var t = {}; for (var n in jo)
                jo.hasOwnProperty(n) && (t[jo[n]] = n); var r = e.exports = { rgb: { channels: 3, labels: "rgb" }, hsl: { channels: 3, labels: "hsl" }, hsv: { channels: 3, labels: "hsv" }, hwb: { channels: 3, labels: "hwb" }, cmyk: { channels: 4, labels: "cmyk" }, xyz: { channels: 3, labels: "xyz" }, lab: { channels: 3, labels: "lab" }, lch: { channels: 3, labels: "lch" }, hex: { channels: 1, labels: ["hex"] }, keyword: { channels: 1, labels: ["keyword"] }, ansi16: { channels: 1, labels: ["ansi16"] }, ansi256: { channels: 1, labels: ["ansi256"] }, hcg: { channels: 3, labels: ["h", "c", "g"] }, apple: { channels: 3, labels: ["r16", "g16", "b16"] }, gray: { channels: 1, labels: ["gray"] } }; for (var o in r)
                if (r.hasOwnProperty(o)) {
                    if (!("channels" in r[o]))
                        throw new Error("missing channels property: " + o);
                    if (!("labels" in r[o]))
                        throw new Error("missing channel labels property: " + o);
                    if (r[o].labels.length !== r[o].channels)
                        throw new Error("channel and label counts mismatch: " + o);
                    var i = r[o].channels, s = r[o].labels;
                    delete r[o].channels, delete r[o].labels, Object.defineProperty(r[o], "channels", { value: i }), Object.defineProperty(r[o], "labels", { value: s });
                } r.rgb.hsl = function (e) { var t, n, r = e[0] / 255, o = e[1] / 255, i = e[2] / 255, s = Math.min(r, o, i), a = Math.max(r, o, i), u = a - s; return a === s ? t = 0 : r === a ? t = (o - i) / u : o === a ? t = 2 + (i - r) / u : i === a && (t = 4 + (r - o) / u), (t = Math.min(60 * t, 360)) < 0 && (t += 360), n = (s + a) / 2, [t, 100 * (a === s ? 0 : n <= .5 ? u / (a + s) : u / (2 - a - s)), 100 * n]; }, r.rgb.hsv = function (e) { var t, n, r, o, i, s = e[0] / 255, a = e[1] / 255, u = e[2] / 255, c = Math.max(s, a, u), l = c - Math.min(s, a, u), p = function (e) { return (c - e) / 6 / l + .5; }; return 0 === l ? o = i = 0 : (i = l / c, t = p(s), n = p(a), r = p(u), s === c ? o = r - n : a === c ? o = 1 / 3 + t - r : u === c && (o = 2 / 3 + n - t), o < 0 ? o += 1 : o > 1 && (o -= 1)), [360 * o, 100 * i, 100 * c]; }, r.rgb.hwb = function (e) { var t = e[0], n = e[1], o = e[2]; return [r.rgb.hsl(e)[0], 1 / 255 * Math.min(t, Math.min(n, o)) * 100, 100 * (o = 1 - 1 / 255 * Math.max(t, Math.max(n, o)))]; }, r.rgb.cmyk = function (e) { var t, n = e[0] / 255, r = e[1] / 255, o = e[2] / 255; return [100 * ((1 - n - (t = Math.min(1 - n, 1 - r, 1 - o))) / (1 - t) || 0), 100 * ((1 - r - t) / (1 - t) || 0), 100 * ((1 - o - t) / (1 - t) || 0), 100 * t]; }, r.rgb.keyword = function (e) { var n = t[e]; if (n)
                return n; var r, o, i, s = 1 / 0; for (var a in jo)
                if (jo.hasOwnProperty(a)) {
                    var u = (o = e, i = jo[a], Math.pow(o[0] - i[0], 2) + Math.pow(o[1] - i[1], 2) + Math.pow(o[2] - i[2], 2));
                    u < s && (s = u, r = a);
                } return r; }, r.keyword.rgb = function (e) { return jo[e]; }, r.rgb.xyz = function (e) { var t = e[0] / 255, n = e[1] / 255, r = e[2] / 255; return [100 * (.4124 * (t = t > .04045 ? Math.pow((t + .055) / 1.055, 2.4) : t / 12.92) + .3576 * (n = n > .04045 ? Math.pow((n + .055) / 1.055, 2.4) : n / 12.92) + .1805 * (r = r > .04045 ? Math.pow((r + .055) / 1.055, 2.4) : r / 12.92)), 100 * (.2126 * t + .7152 * n + .0722 * r), 100 * (.0193 * t + .1192 * n + .9505 * r)]; }, r.rgb.lab = function (e) { var t = r.rgb.xyz(e), n = t[0], o = t[1], i = t[2]; return o /= 100, i /= 108.883, n = (n /= 95.047) > .008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116, [116 * (o = o > .008856 ? Math.pow(o, 1 / 3) : 7.787 * o + 16 / 116) - 16, 500 * (n - o), 200 * (o - (i = i > .008856 ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116))]; }, r.hsl.rgb = function (e) { var t, n, r, o, i, s = e[0] / 360, a = e[1] / 100, u = e[2] / 100; if (0 === a)
                return [i = 255 * u, i, i]; t = 2 * u - (n = u < .5 ? u * (1 + a) : u + a - u * a), o = [0, 0, 0]; for (var c = 0; c < 3; c++)
                (r = s + 1 / 3 * -(c - 1)) < 0 && r++, r > 1 && r--, i = 6 * r < 1 ? t + 6 * (n - t) * r : 2 * r < 1 ? n : 3 * r < 2 ? t + (n - t) * (2 / 3 - r) * 6 : t, o[c] = 255 * i; return o; }, r.hsl.hsv = function (e) { var t = e[0], n = e[1] / 100, r = e[2] / 100, o = n, i = Math.max(r, .01); return n *= (r *= 2) <= 1 ? r : 2 - r, o *= i <= 1 ? i : 2 - i, [t, 100 * (0 === r ? 2 * o / (i + o) : 2 * n / (r + n)), (r + n) / 2 * 100]; }, r.hsv.rgb = function (e) { var t = e[0] / 60, n = e[1] / 100, r = e[2] / 100, o = Math.floor(t) % 6, i = t - Math.floor(t), s = 255 * r * (1 - n), a = 255 * r * (1 - n * i), u = 255 * r * (1 - n * (1 - i)); switch (r *= 255, o) {
                case 0: return [r, u, s];
                case 1: return [a, r, s];
                case 2: return [s, r, u];
                case 3: return [s, a, r];
                case 4: return [u, s, r];
                case 5: return [r, s, a];
            } }, r.hsv.hsl = function (e) { var t, n, r, o = e[0], i = e[1] / 100, s = e[2] / 100, a = Math.max(s, .01); return r = (2 - i) * s, n = i * a, [o, 100 * (n = (n /= (t = (2 - i) * a) <= 1 ? t : 2 - t) || 0), 100 * (r /= 2)]; }, r.hwb.rgb = function (e) { var t, n, r, o, i, s, a, u = e[0] / 360, c = e[1] / 100, l = e[2] / 100, p = c + l; switch (p > 1 && (c /= p, l /= p), r = 6 * u - (t = Math.floor(6 * u)), 0 != (1 & t) && (r = 1 - r), o = c + r * ((n = 1 - l) - c), t) {
                default:
                case 6:
                case 0:
                    i = n, s = o, a = c;
                    break;
                case 1:
                    i = o, s = n, a = c;
                    break;
                case 2:
                    i = c, s = n, a = o;
                    break;
                case 3:
                    i = c, s = o, a = n;
                    break;
                case 4:
                    i = o, s = c, a = n;
                    break;
                case 5: i = n, s = c, a = o;
            } return [255 * i, 255 * s, 255 * a]; }, r.cmyk.rgb = function (e) { var t = e[0] / 100, n = e[1] / 100, r = e[2] / 100, o = e[3] / 100; return [255 * (1 - Math.min(1, t * (1 - o) + o)), 255 * (1 - Math.min(1, n * (1 - o) + o)), 255 * (1 - Math.min(1, r * (1 - o) + o))]; }, r.xyz.rgb = function (e) { var t, n, r, o = e[0] / 100, i = e[1] / 100, s = e[2] / 100; return n = -.9689 * o + 1.8758 * i + .0415 * s, r = .0557 * o + -.204 * i + 1.057 * s, t = (t = 3.2406 * o + -1.5372 * i + -.4986 * s) > .0031308 ? 1.055 * Math.pow(t, 1 / 2.4) - .055 : 12.92 * t, n = n > .0031308 ? 1.055 * Math.pow(n, 1 / 2.4) - .055 : 12.92 * n, r = r > .0031308 ? 1.055 * Math.pow(r, 1 / 2.4) - .055 : 12.92 * r, [255 * (t = Math.min(Math.max(0, t), 1)), 255 * (n = Math.min(Math.max(0, n), 1)), 255 * (r = Math.min(Math.max(0, r), 1))]; }, r.xyz.lab = function (e) { var t = e[0], n = e[1], r = e[2]; return n /= 100, r /= 108.883, t = (t /= 95.047) > .008856 ? Math.pow(t, 1 / 3) : 7.787 * t + 16 / 116, [116 * (n = n > .008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116) - 16, 500 * (t - n), 200 * (n - (r = r > .008856 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116))]; }, r.lab.xyz = function (e) { var t, n, r, o = e[0]; t = e[1] / 500 + (n = (o + 16) / 116), r = n - e[2] / 200; var i = Math.pow(n, 3), s = Math.pow(t, 3), a = Math.pow(r, 3); return n = i > .008856 ? i : (n - 16 / 116) / 7.787, t = s > .008856 ? s : (t - 16 / 116) / 7.787, r = a > .008856 ? a : (r - 16 / 116) / 7.787, [t *= 95.047, n *= 100, r *= 108.883]; }, r.lab.lch = function (e) { var t, n = e[0], r = e[1], o = e[2]; return (t = 360 * Math.atan2(o, r) / 2 / Math.PI) < 0 && (t += 360), [n, Math.sqrt(r * r + o * o), t]; }, r.lch.lab = function (e) { var t, n = e[0], r = e[1]; return t = e[2] / 360 * 2 * Math.PI, [n, r * Math.cos(t), r * Math.sin(t)]; }, r.rgb.ansi16 = function (e) { var t = e[0], n = e[1], o = e[2], i = 1 in arguments ? arguments[1] : r.rgb.hsv(e)[2]; if (0 === (i = Math.round(i / 50)))
                return 30; var s = 30 + (Math.round(o / 255) << 2 | Math.round(n / 255) << 1 | Math.round(t / 255)); return 2 === i && (s += 60), s; }, r.hsv.ansi16 = function (e) { return r.rgb.ansi16(r.hsv.rgb(e), e[2]); }, r.rgb.ansi256 = function (e) { var t = e[0], n = e[1], r = e[2]; return t === n && n === r ? t < 8 ? 16 : t > 248 ? 231 : Math.round((t - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t / 255 * 5) + 6 * Math.round(n / 255 * 5) + Math.round(r / 255 * 5); }, r.ansi16.rgb = function (e) { var t = e % 10; if (0 === t || 7 === t)
                return e > 50 && (t += 3.5), [t = t / 10.5 * 255, t, t]; var n = .5 * (1 + ~~(e > 50)); return [(1 & t) * n * 255, (t >> 1 & 1) * n * 255, (t >> 2 & 1) * n * 255]; }, r.ansi256.rgb = function (e) { if (e >= 232) {
                var t = 10 * (e - 232) + 8;
                return [t, t, t];
            } var n; return e -= 16, [Math.floor(e / 36) / 5 * 255, Math.floor((n = e % 36) / 6) / 5 * 255, n % 6 / 5 * 255]; }, r.rgb.hex = function (e) { var t = (((255 & Math.round(e[0])) << 16) + ((255 & Math.round(e[1])) << 8) + (255 & Math.round(e[2]))).toString(16).toUpperCase(); return "000000".substring(t.length) + t; }, r.hex.rgb = function (e) { var t = e.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i); if (!t)
                return [0, 0, 0]; var n = t[0]; 3 === t[0].length && (n = n.split("").map((function (e) { return e + e; })).join("")); var r = parseInt(n, 16); return [r >> 16 & 255, r >> 8 & 255, 255 & r]; }, r.rgb.hcg = function (e) { var t, n = e[0] / 255, r = e[1] / 255, o = e[2] / 255, i = Math.max(Math.max(n, r), o), s = Math.min(Math.min(n, r), o), a = i - s; return t = a <= 0 ? 0 : i === n ? (r - o) / a % 6 : i === r ? 2 + (o - n) / a : 4 + (n - r) / a + 4, t /= 6, [360 * (t %= 1), 100 * a, 100 * (a < 1 ? s / (1 - a) : 0)]; }, r.hsl.hcg = function (e) { var t, n = e[1] / 100, r = e[2] / 100, o = 0; return (t = r < .5 ? 2 * n * r : 2 * n * (1 - r)) < 1 && (o = (r - .5 * t) / (1 - t)), [e[0], 100 * t, 100 * o]; }, r.hsv.hcg = function (e) { var t = e[1] / 100, n = e[2] / 100, r = t * n, o = 0; return r < 1 && (o = (n - r) / (1 - r)), [e[0], 100 * r, 100 * o]; }, r.hcg.rgb = function (e) { var t = e[0] / 360, n = e[1] / 100, r = e[2] / 100; if (0 === n)
                return [255 * r, 255 * r, 255 * r]; var o, i = [0, 0, 0], s = t % 1 * 6, a = s % 1, u = 1 - a; switch (Math.floor(s)) {
                case 0:
                    i[0] = 1, i[1] = a, i[2] = 0;
                    break;
                case 1:
                    i[0] = u, i[1] = 1, i[2] = 0;
                    break;
                case 2:
                    i[0] = 0, i[1] = 1, i[2] = a;
                    break;
                case 3:
                    i[0] = 0, i[1] = u, i[2] = 1;
                    break;
                case 4:
                    i[0] = a, i[1] = 0, i[2] = 1;
                    break;
                default: i[0] = 1, i[1] = 0, i[2] = u;
            } return o = (1 - n) * r, [255 * (n * i[0] + o), 255 * (n * i[1] + o), 255 * (n * i[2] + o)]; }, r.hcg.hsv = function (e) { var t = e[1] / 100, n = t + e[2] / 100 * (1 - t), r = 0; return n > 0 && (r = t / n), [e[0], 100 * r, 100 * n]; }, r.hcg.hsl = function (e) { var t = e[1] / 100, n = e[2] / 100 * (1 - t) + .5 * t, r = 0; return n > 0 && n < .5 ? r = t / (2 * n) : n >= .5 && n < 1 && (r = t / (2 * (1 - n))), [e[0], 100 * r, 100 * n]; }, r.hcg.hwb = function (e) { var t = e[1] / 100, n = t + e[2] / 100 * (1 - t); return [e[0], 100 * (n - t), 100 * (1 - n)]; }, r.hwb.hcg = function (e) { var t = e[1] / 100, n = 1 - e[2] / 100, r = n - t, o = 0; return r < 1 && (o = (n - r) / (1 - r)), [e[0], 100 * r, 100 * o]; }, r.apple.rgb = function (e) { return [e[0] / 65535 * 255, e[1] / 65535 * 255, e[2] / 65535 * 255]; }, r.rgb.apple = function (e) { return [e[0] / 255 * 65535, e[1] / 255 * 65535, e[2] / 255 * 65535]; }, r.gray.rgb = function (e) { return [e[0] / 100 * 255, e[0] / 100 * 255, e[0] / 100 * 255]; }, r.gray.hsl = r.gray.hsv = function (e) { return [0, 0, e[0]]; }, r.gray.hwb = function (e) { return [0, 100, e[0]]; }, r.gray.cmyk = function (e) { return [0, 0, 0, e[0]]; }, r.gray.lab = function (e) { return [e[0], 0, 0]; }, r.gray.hex = function (e) { var t = 255 & Math.round(e[0] / 100 * 255), n = ((t << 16) + (t << 8) + t).toString(16).toUpperCase(); return "000000".substring(n.length) + n; }, r.rgb.gray = function (e) { return [(e[0] + e[1] + e[2]) / 3 / 255 * 100]; }; })); function Lo(e, t) { return function (n) { return t(e(n)); }; } function qo(e, t) { for (var n = [t[e].parent, e], r = Bo[t[e].parent][e], o = t[e].parent; t[o].parent;)
                n.unshift(t[o].parent), r = Lo(Bo[t[o].parent][o], r), o = t[o].parent; return r.conversion = n, r; } Bo.rgb, Bo.hsl, Bo.hsv, Bo.hwb, Bo.cmyk, Bo.xyz, Bo.lab, Bo.lch, Bo.hex, Bo.keyword, Bo.ansi16, Bo.ansi256, Bo.hcg, Bo.apple, Bo.gray; var $o = {}; Object.keys(Bo).forEach((function (e) { $o[e] = {}, Object.defineProperty($o[e], "channels", { value: Bo[e].channels }), Object.defineProperty($o[e], "labels", { value: Bo[e].labels }); var t = function (e) { for (var t = function (e) { var t = function () { for (var e = {}, t = Object.keys(Bo), n = t.length, r = 0; r < n; r++)
                e[t[r]] = { distance: -1, parent: null }; return e; }(), n = [e]; for (t[e].distance = 0; n.length;)
                for (var r = n.pop(), o = Object.keys(Bo[r]), i = o.length, s = 0; s < i; s++) {
                    var a = o[s], u = t[a];
                    -1 === u.distance && (u.distance = t[r].distance + 1, u.parent = r, n.unshift(a));
                } return t; }(e), n = {}, r = Object.keys(t), o = r.length, i = 0; i < o; i++) {
                var s = r[i];
                null !== t[s].parent && (n[s] = qo(s, t));
            } return n; }(e); Object.keys(t).forEach((function (n) { var r = t[n]; $o[e][n] = function (e) { var t = function (t) { if (null == t)
                return t; arguments.length > 1 && (t = Array.prototype.slice.call(arguments)); var n = e(t); if ("object" == typeof n)
                for (var r = n.length, o = 0; o < r; o++)
                    n[o] = Math.round(n[o]); return n; }; return "conversion" in e && (t.conversion = e.conversion), t; }(r), $o[e][n].raw = function (e) { var t = function (t) { return null == t ? t : (arguments.length > 1 && (t = Array.prototype.slice.call(arguments)), e(t)); }; return "conversion" in e && (t.conversion = e.conversion), t; }(r); })); })); var Uo = $o, Vo = st((function (e) { const t = (e, t) => function () { const n = e.apply(Uo, arguments); return "[".concat(n + t, "m"); }, n = (e, t) => function () { const n = e.apply(Uo, arguments); return "[".concat(38 + t, ";5;").concat(n, "m"); }, r = (e, t) => function () { const n = e.apply(Uo, arguments); return "[".concat(38 + t, ";2;").concat(n[0], ";").concat(n[1], ";").concat(n[2], "m"); }; Object.defineProperty(e, "exports", { enumerable: !0, get: function () { const e = new Map, o = { modifier: { reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29] }, color: { black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], gray: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39] }, bgColor: { bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49] } }; o.color.grey = o.color.gray; for (const t of Object.keys(o)) {
                    const n = o[t];
                    for (const t of Object.keys(n)) {
                        const r = n[t];
                        o[t] = { open: "[".concat(r[0], "m"), close: "[".concat(r[1], "m") }, n[t] = o[t], e.set(r[0], r[1]);
                    }
                    Object.defineProperty(o, t, { value: n, enumerable: !1 }), Object.defineProperty(o, "codes", { value: e, enumerable: !1 });
                } const i = e => e, s = (e, t, n) => [e, t, n]; o.color.close = "[39m", o.bgColor.close = "[49m", o.color.ansi = { ansi: t(i, 0) }, o.color.ansi256 = { ansi256: n(i, 0) }, o.color.ansi16m = { rgb: r(s, 0) }, o.bgColor.ansi = { ansi: t(i, 10) }, o.bgColor.ansi256 = { ansi256: n(i, 10) }, o.bgColor.ansi16m = { rgb: r(s, 10) }; for (let e of Object.keys(Uo)) {
                    if ("object" != typeof Uo[e])
                        continue;
                    const i = Uo[e];
                    "ansi16" === e && (e = "ansi"), "ansi16" in i && (o.color.ansi[e] = t(i.ansi16, 0), o.bgColor.ansi[e] = t(i.ansi16, 10)), "ansi256" in i && (o.color.ansi256[e] = n(i.ansi256, 0), o.bgColor.ansi256[e] = n(i.ansi256, 10)), "rgb" in i && (o.color.ansi16m[e] = r(i.rgb, 0), o.bgColor.ansi16m[e] = r(i.rgb, 10));
                } return o; } }); })); const Wo = Bt.env; let Ko; function zo(e) { const t = function (e) { if (!1 === Ko)
                return 0; if (Ln("color=16m") || Ln("color=full") || Ln("color=truecolor"))
                return 3; if (Ln("color=256"))
                return 2; if (e && !e.isTTY && !0 !== Ko)
                return 0; const t = Ko ? 1 : 0; if ("win32" === Bt.platform) {
                const e = Bn.release().split(".");
                return Number(Bt.versions.node.split(".")[0]) >= 8 && Number(e[0]) >= 10 && Number(e[2]) >= 10586 ? Number(e[2]) >= 14931 ? 3 : 2 : 1;
            } if ("CI" in Wo)
                return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((e => e in Wo)) || "codeship" === Wo.CI_NAME ? 1 : t; if ("TEAMCITY_VERSION" in Wo)
                return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Wo.TEAMCITY_VERSION) ? 1 : 0; if ("truecolor" === Wo.COLORTERM)
                return 3; if ("TERM_PROGRAM" in Wo) {
                const e = parseInt((Wo.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
                switch (Wo.TERM_PROGRAM) {
                    case "iTerm.app": return e >= 3 ? 3 : 2;
                    case "Apple_Terminal": return 2;
                }
            } return /-256(color)?$/i.test(Wo.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(Wo.TERM) || "COLORTERM" in Wo ? 1 : (Wo.TERM, t); }(e); return function (e) { return 0 !== e && { level: e, hasBasic: !0, has256: e >= 2, has16m: e >= 3 }; }(t); } Ln("no-color") || Ln("no-colors") || Ln("color=false") ? Ko = !1 : (Ln("color") || Ln("colors") || Ln("color=true") || Ln("color=always")) && (Ko = !0), "FORCE_COLOR" in Wo && (Ko = 0 === Wo.FORCE_COLOR.length || 0 !== parseInt(Wo.FORCE_COLOR, 10)); var Ho = { supportsColor: zo, stdout: zo(Bt.stdout), stderr: zo(Bt.stderr) }; const Yo = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, Jo = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, Go = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, Xo = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, Qo = new Map([["n", "\n"], ["r", "\r"], ["t", "\t"], ["b", "\b"], ["f", "\f"], ["v", "\v"], ["0", "\0"], ["\\", "\\"], ["e", ""], ["a", ""]]); function Zo(e) { return "u" === e[0] && 5 === e.length || "x" === e[0] && 3 === e.length ? String.fromCharCode(parseInt(e.slice(1), 16)) : Qo.get(e) || e; } function ei(e, t) { const n = [], r = t.trim().split(/\s*,\s*/g); let o; for (const t of r)
                if (isNaN(t)) {
                    if (!(o = t.match(Go)))
                        throw new Error("Invalid Chalk template style argument: ".concat(t, " (in style '").concat(e, "')"));
                    n.push(o[2].replace(Xo, ((e, t, n) => t ? Zo(t) : n)));
                }
                else
                    n.push(Number(t)); return n; } function ti(e) { Jo.lastIndex = 0; const t = []; let n; for (; null !== (n = Jo.exec(e));) {
                const e = n[1];
                if (n[2]) {
                    const r = ei(e, n[2]);
                    t.push([e].concat(r));
                }
                else
                    t.push([e]);
            } return t; } function ni(e, t) { const n = {}; for (const e of t)
                for (const t of e.styles)
                    n[t[0]] = e.inverse ? null : t.slice(1); let r = e; for (const e of Object.keys(n))
                if (Array.isArray(n[e])) {
                    if (!(e in r))
                        throw new Error("Unknown Chalk style: ".concat(e));
                    r = n[e].length > 0 ? r[e].apply(r, n[e]) : r[e];
                } return r; } var ri = (e, t) => { const n = [], r = []; let o = []; if (t.replace(Yo, ((t, i, s, a, u, c) => { if (i)
                o.push(Zo(i));
            else if (a) {
                const t = o.join("");
                o = [], r.push(0 === n.length ? t : ni(e, n)(t)), n.push({ inverse: s, styles: ti(a) });
            }
            else if (u) {
                if (0 === n.length)
                    throw new Error("Found extraneous } in Chalk template literal");
                r.push(ni(e, n)(o.join(""))), o = [], n.pop();
            }
            else
                o.push(c); })), r.push(o.join("")), n.length > 0) {
                const e = "Chalk template literal is missing ".concat(n.length, " closing bracket").concat(1 === n.length ? "" : "s", " (`}`)");
                throw new Error(e);
            } return r.join(""); }, oi = st((function (e) { const t = Ho.stdout, n = "win32" === Bt.platform && !(Bt.env.TERM || "").toLowerCase().startsWith("xterm"), r = ["ansi", "ansi", "ansi256", "ansi16m"], o = new Set(["gray"]), i = Object.create(null); function s(e, n) { n = n || {}; const r = t ? t.level : 0; e.level = void 0 === n.level ? r : n.level, e.enabled = "enabled" in n ? n.enabled : e.level > 0; } function a(e) { if (!this || !(this instanceof a) || this.template) {
                const t = {};
                return s(t, e), t.template = function () { const e = [].slice.call(arguments); return p.apply(null, [t.template].concat(e)); }, Object.setPrototypeOf(t, a.prototype), Object.setPrototypeOf(t.template, t), t.template.constructor = a, t.template;
            } s(this, e); } n && (Vo.blue.open = "[94m"); for (const e of Object.keys(Vo))
                Vo[e].closeRe = new RegExp(Io(Vo[e].close), "g"), i[e] = { get() { const t = Vo[e]; return c.call(this, this._styles ? this._styles.concat(t) : [t], this._empty, e); } }; i.visible = { get() { return c.call(this, this._styles || [], !0, "visible"); } }, Vo.color.closeRe = new RegExp(Io(Vo.color.close), "g"); for (const e of Object.keys(Vo.color.ansi))
                o.has(e) || (i[e] = { get() { const t = this.level; return function () { const n = Vo.color[r[t]][e].apply(null, arguments), o = { open: n, close: Vo.color.close, closeRe: Vo.color.closeRe }; return c.call(this, this._styles ? this._styles.concat(o) : [o], this._empty, e); }; } }); Vo.bgColor.closeRe = new RegExp(Io(Vo.bgColor.close), "g"); for (const e of Object.keys(Vo.bgColor.ansi))
                o.has(e) || (i["bg" + e[0].toUpperCase() + e.slice(1)] = { get() { const t = this.level; return function () { const n = Vo.bgColor[r[t]][e].apply(null, arguments), o = { open: n, close: Vo.bgColor.close, closeRe: Vo.bgColor.closeRe }; return c.call(this, this._styles ? this._styles.concat(o) : [o], this._empty, e); }; } }); const u = Object.defineProperties((() => { }), i); function c(e, t, n) { const r = function e() { return l.apply(e, arguments); }; r._styles = e, r._empty = t; const o = this; return Object.defineProperty(r, "level", { enumerable: !0, get: () => o.level, set(e) { o.level = e; } }), Object.defineProperty(r, "enabled", { enumerable: !0, get: () => o.enabled, set(e) { o.enabled = e; } }), r.hasGrey = this.hasGrey || "gray" === n || "grey" === n, r.__proto__ = u, r; } function l() { const e = arguments, t = e.length; let r = String(arguments[0]); if (0 === t)
                return ""; if (t > 1)
                for (let n = 1; n < t; n++)
                    r += " " + e[n]; if (!this.enabled || this.level <= 0 || !r)
                return this._empty ? "" : r; const o = Vo.dim.open; n && this.hasGrey && (Vo.dim.open = ""); for (const e of this._styles.slice().reverse())
                r = e.open + r.replace(e.closeRe, e.open) + e.close, r = r.replace(/\r?\n/g, "".concat(e.close, "$&").concat(e.open)); return Vo.dim.open = o, r; } function p(e, t) { if (!Array.isArray(t))
                return [].slice.call(arguments, 1).join(" "); const n = [].slice.call(arguments, 2), r = [t.raw[0]]; for (let e = 1; e < t.length; e++)
                r.push(String(n[e - 1]).replace(/[{}\\]/g, "\\$&")), r.push(String(t.raw[e])); return ri(e, r.join("")); } Object.defineProperties(a.prototype, i), e.exports = a(), e.exports.supportsColor = t, e.exports.default = e.exports; })), ii = (oi.supportsColor, st((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.shouldHighlight = l, t.getChalk = p, t.default = function (e, t = {}) { if (l(t)) {
                return function (e, t) { return t.replace(n.default, (function (...t) { const o = function (e) { const [t, o] = e.slice(-2), i = (0, n.matchToToken)(e); if ("name" === i.type) {
                    if (r.default.keyword.isReservedWordES6(i.value))
                        return "keyword";
                    if (u.test(i.value) && ("<" === o[t - 1] || "</" == o.substr(t - 2, 2)))
                        return "jsx_tag";
                    if (i.value[0] !== i.value[0].toLowerCase())
                        return "capitalized";
                } return "punctuator" === i.type && c.test(i.value) ? "bracket" : "invalid" !== i.type || "@" !== i.value && "#" !== i.value ? i.type : "punctuator"; }(t), i = e[o]; return i ? t[0].split(a).map((e => i(e))).join("\n") : t[0]; })); }({ keyword: (o = p(t)).cyan, capitalized: o.yellow, jsx_tag: o.yellow, punctuator: o.yellow, number: o.magenta, string: o.green, regex: o.magenta, comment: o.grey, invalid: o.white.bgRed.bold }, e);
            } var o; return e; }; var n = function (e) { if (e && e.__esModule)
                return e; if (null === e || "object" != typeof e && "function" != typeof e)
                return { default: e }; var t = s(); if (t && t.has(e))
                return t.get(e); var n = {}, r = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var i = r ? Object.getOwnPropertyDescriptor(e, o) : null;
                    i && (i.get || i.set) ? Object.defineProperty(n, o, i) : n[o] = e[o];
                } return n.default = e, t && t.set(e, n), n; }(Oo), r = i(Mo), o = i(oi); function i(e) { return e && e.__esModule ? e : { default: e }; } function s() { if ("function" != typeof WeakMap)
                return null; var e = new WeakMap; return s = function () { return e; }, e; } const a = /\r\n|[\n\r\u2028\u2029]/, u = /^[a-z][\w-]*$/i, c = /^[()[\]{}]$/; function l(e) { return o.default.supportsColor || e.forceColor; } function p(e) { let t = o.default; return e.forceColor && (t = new o.default.constructor({ enabled: !0, level: 1 })), t; } }))); it(ii), ii.shouldHighlight, ii.getChalk; var si = st((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.codeFrameColumns = s, t.default = function (e, t, n, r = {}) { if (!o) {
                o = !0;
                const e = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
                Bt.emitWarning ? Bt.emitWarning(e, "DeprecationWarning") : (new Error(e).name = "DeprecationWarning", a.warn(new Error(e)));
            } return s(e, { start: { column: n = Math.max(n, 0), line: t } }, r); }; var n = function (e) { if (e && e.__esModule)
                return e; if (null === e || "object" != typeof e && "function" != typeof e)
                return { default: e }; var t = r(); if (t && t.has(e))
                return t.get(e); var n = {}, o = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var i in e)
                if (Object.prototype.hasOwnProperty.call(e, i)) {
                    var s = o ? Object.getOwnPropertyDescriptor(e, i) : null;
                    s && (s.get || s.set) ? Object.defineProperty(n, i, s) : n[i] = e[i];
                } return n.default = e, t && t.set(e, n), n; }(ii); function r() { if ("function" != typeof WeakMap)
                return null; var e = new WeakMap; return r = function () { return e; }, e; } let o = !1; const i = /\r\n|[\n\r\u2028\u2029]/; function s(e, t, r = {}) { const o = (r.highlightCode || r.forceColor) && (0, n.shouldHighlight)(r), s = (0, n.getChalk)(r), a = function (e) { return { gutter: e.grey, marker: e.red.bold, message: e.red.bold }; }(s), u = (e, t) => o ? e(t) : t, c = e.split(i), { start: l, end: p, markerLines: f } = function (e, t, n) { const r = Object.assign({ column: 0, line: -1 }, e.start), o = Object.assign({}, r, {}, e.end), { linesAbove: i = 2, linesBelow: s = 3 } = n || {}, a = r.line, u = r.column, c = o.line, l = o.column; let p = Math.max(a - (i + 1), 0), f = Math.min(t.length, c + s); -1 === a && (p = 0), -1 === c && (f = t.length); const d = c - a, h = {}; if (d)
                for (let e = 0; e <= d; e++) {
                    const n = e + a;
                    if (u)
                        if (0 === e) {
                            const e = t[n - 1].length;
                            h[n] = [u, e - u + 1];
                        }
                        else if (e === d)
                            h[n] = [0, l];
                        else {
                            const r = t[n - e].length;
                            h[n] = [0, r];
                        }
                    else
                        h[n] = !0;
                }
            else
                h[a] = u === l ? !u || [u, 0] : [u, l - u]; return { start: p, end: f, markerLines: h }; }(t, c, r), d = t.start && "number" == typeof t.start.column, h = String(p).length; let m = (o ? (0, n.default)(e, r) : e).split(i).slice(l, p).map(((e, t) => { const n = l + 1 + t, o = " ".concat(n).slice(-h), i = " ".concat(o, " | "), s = f[n], c = !f[n + 1]; if (s) {
                let t = "";
                if (Array.isArray(s)) {
                    const n = e.slice(0, Math.max(s[0] - 1, 0)).replace(/[^\t]/g, " "), o = s[1] || 1;
                    t = ["\n ", u(a.gutter, i.replace(/\d/g, " ")), n, u(a.marker, "^").repeat(o)].join(""), c && r.message && (t += " " + u(a.message, r.message));
                }
                return [u(a.marker, ">"), u(a.gutter, i), e, t].join("");
            } return " ".concat(u(a.gutter, i)).concat(e); })).join("\n"); return r.message && !d && (m = "".concat(" ".repeat(h + 1)).concat(r.message, "\n").concat(m)), o ? s.reset(m) : m; } })); it(si), si.codeFrameColumns; const { ConfigError: ai } = ft, { locStart: ui, locEnd: ci } = Fo, li = Object.getOwnPropertyNames, pi = Object.getOwnPropertyDescriptor; function fi(e) { const t = {}; for (const n of e.plugins)
                if (n.parsers)
                    for (const e of li(n.parsers))
                        Object.defineProperty(t, e, pi(n.parsers, e)); return t; } function di(e, t) { if (t = t || fi(e), "function" == typeof e.parser)
                return { parse: e.parser, astFormat: "estree", locStart: ui, locEnd: ci }; if ("string" == typeof e.parser) {
                if (Object.prototype.hasOwnProperty.call(t, e.parser))
                    return t[e.parser];
                throw new ai("Couldn't resolve parser \"".concat(e.parser, '". Parsers must be explicitly added to the standalone bundle.'));
            } } var hi = { parse: function (e, t) { const n = fi(t), r = Object.keys(n).reduce(((e, t) => Object.defineProperty(e, t, { enumerable: !0, get: () => n[t].parse })), {}), o = di(t, n); try {
                    return o.preprocess && (e = o.preprocess(e, t)), { text: e, ast: o.parse(e, r, t) };
                }
                catch (t) {
                    const { loc: n } = t;
                    if (n) {
                        const r = si;
                        throw t.codeFrame = r.codeFrameColumns(e, n, { highlightCode: !0 }), t.message += "\n" + t.codeFrame, t;
                    }
                    throw t.stack;
                } }, resolveParser: di }; const { UndefinedParserError: mi } = ft, { getSupportInfo: gi } = bn, { resolveParser: yi } = hi, vi = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null }; function bi(e, t) { const n = se.basename(e).toLowerCase(), r = gi({ plugins: t }).languages.filter((e => null !== e.since)); let o = r.find((e => e.extensions && e.extensions.some((e => n.endsWith(e))) || e.filenames && e.filenames.find((e => e.toLowerCase() === n)))); if (!o && !n.includes(".")) {
                const t = function (e) { if ("string" != typeof e)
                    return ""; let t; try {
                    t = ut.openSync(e, "r");
                }
                catch (e) {
                    return "";
                } try {
                    const e = new class {
                        constructor(e, t) { (t = t || {}).readChunk || (t.readChunk = 1024), t.newLineCharacter ? t.newLineCharacter = t.newLineCharacter.charCodeAt(0) : t.newLineCharacter = 10, this.fd = "number" == typeof e ? e : ut.openSync(e, "r"), this.options = t, this.newLineCharacter = t.newLineCharacter, this.reset(); }
                        _searchInBuffer(e, t) { let n = -1; for (let r = 0; r <= e.length; r++)
                            if (e[r] === t) {
                                n = r;
                                break;
                            } return n; }
                        reset() { this.eofReached = !1, this.linesCache = [], this.fdPosition = 0; }
                        close() { ut.closeSync(this.fd), this.fd = null; }
                        _extractLines(e) { let t; const n = []; let r = 0, o = 0; for (;;) {
                            let i = e[r++];
                            if (i === this.newLineCharacter)
                                t = e.slice(o, r), n.push(t), o = r;
                            else if (!i)
                                break;
                        } let i = e.slice(o, r); return i.length && n.push(i), n; }
                        _readChunk(e) { let t, n = 0; const r = []; do {
                            const e = new Ee(this.options.readChunk);
                            t = ut.readSync(this.fd, e, 0, this.options.readChunk, this.fdPosition), n += t, this.fdPosition = this.fdPosition + t, r.push(e);
                        } while (t && -1 === this._searchInBuffer(r[r.length - 1], this.options.newLineCharacter)); let o = Ee.concat(r); return t < this.options.readChunk && (this.eofReached = !0, o = o.slice(0, n)), n && (this.linesCache = this._extractLines(o), e && (this.linesCache[0] = Ee.concat([e, this.linesCache[0]]))), n; }
                        next() { if (!this.fd)
                            return !1; let e, t = !1; return this.eofReached && 0 === this.linesCache.length || (this.linesCache.length || (e = this._readChunk()), this.linesCache.length && (t = this.linesCache.shift(), 10 !== t[t.length - 1] && (e = this._readChunk(t), e && (t = this.linesCache.shift()))), this.eofReached && 0 === this.linesCache.length && this.close(), t && t[t.length - 1] === this.newLineCharacter && (t = t.slice(0, t.length - 1))), t; }
                    }(t).next().toString("utf8"), n = e.match(/^#!\/(?:usr\/)?bin\/env\s+(\S+)/);
                    if (n)
                        return n[1];
                    const r = e.match(/^#!\/(?:usr\/(?:local\/)?)?bin\/(\S+)/);
                    return r ? r[1] : "";
                }
                catch (e) {
                    return "";
                }
                finally {
                    try {
                        ut.closeSync(t);
                    }
                    catch (e) { }
                } }(e);
                o = r.find((e => e.interpreters && e.interpreters.includes(t)));
            } return o && o.parsers[0]; } var Di = { normalize: function (e, t) { t = t || {}; const n = Object.assign({}, e), r = gi({ plugins: e.plugins, showUnreleased: !0, showDeprecated: !0 }).options, o = Object.assign({}, vi, {}, function (e) { for (var t = -1, n = null == e ? 0 : e.length, r = {}; ++t < n;) {
                    var o = e[t];
                    r[o[0]] = o[1];
                } return r; }(r.filter((e => void 0 !== e.default)).map((e => [e.name, e.default])))); if (!n.parser)
                    if (n.filepath) {
                        if (n.parser = bi(n.filepath, n.plugins), !n.parser)
                            throw new mi("No parser could be inferred for file: ".concat(n.filepath));
                    }
                    else
                        (t.logger || a).warn("No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred."), n.parser = "babel"; const i = yi(So(n, [r.find((e => "parser" === e.name))], { passThrough: !0, logger: !1 })); n.astFormat = i.astFormat, n.locEnd = i.locEnd, n.locStart = i.locStart; const s = function (e) { const { astFormat: t } = e; if (!t)
                    throw new Error("getPlugin() requires astFormat to be set"); const n = e.plugins.find((e => e.printers && e.printers[t])); if (!n)
                    throw new Error("Couldn't find plugin for AST format \"".concat(t, '"')); return n; }(n); n.printer = s.printers[n.astFormat]; const u = r.filter((e => e.pluginDefaults && void 0 !== e.pluginDefaults[s.name])).reduce(((e, t) => Object.assign(e, { [t.name]: t.pluginDefaults[s.name] })), {}), c = Object.assign({}, o, {}, u); return Object.keys(c).forEach((e => { null == n[e] && (n[e] = c[e]); })), "json" === n.parser && (n.trailingComma = "none"), So(n, r, Object.assign({ passThrough: Object.keys(vi) }, t)); }, hiddenDefaults: vi, inferParser: bi }, Ei = function e(t, n, r) { if (Array.isArray(t))
                return t.map((t => e(t, n, r))).filter(Boolean); if (!t || "object" != typeof t)
                return t; const o = {}; for (const r of Object.keys(t))
                "function" != typeof t[r] && (o[r] = e(t[r], n, t)); if (n.printer.massageAstNode) {
                const e = n.printer.massageAstNode(t, o, r);
                if (null === e)
                    return;
                if (e)
                    return e;
            } return o; }; function Ci() { } function wi(e) { return { type: "concat", parts: e }; } function Ai(e) { return { type: "indent", contents: e }; } function Si(e, t) { return { type: "align", contents: t, n: e }; } function xi(e, t) { return { type: "group", id: (t = t || {}).id, contents: e, break: !!t.shouldBreak, expandedStates: t.expandedStates }; } Ci.ok = function () { }, Ci.strictEqual = function () { }; const Ti = { type: "break-parent" }, ki = wi([{ type: "line", hard: !0 }, Ti]), Fi = wi([{ type: "line", hard: !0, literal: !0 }, Ti]); var Oi = { concat: wi, join: function (e, t) { const n = []; for (let r = 0; r < t.length; r++)
                    0 !== r && n.push(e), n.push(t[r]); return wi(n); }, line: { type: "line" }, softline: { type: "line", soft: !0 }, hardline: ki, literalline: Fi, group: xi, conditionalGroup: function (e, t) { return xi(e[0], Object.assign({}, t, { expandedStates: e })); }, fill: function (e) { return { type: "fill", parts: e }; }, lineSuffix: function (e) { return { type: "line-suffix", contents: e }; }, lineSuffixBoundary: { type: "line-suffix-boundary" }, cursor: { type: "cursor", placeholder: Symbol("cursor") }, breakParent: Ti, ifBreak: function (e, t, n) { return { type: "if-break", breakContents: e, flatContents: t, groupId: (n = n || {}).groupId }; }, trim: { type: "trim" }, indent: Ai, align: Si, addAlignmentToDoc: function (e, t, n) { let r = e; if (t > 0) {
                    for (let e = 0; e < Math.floor(t / n); ++e)
                        r = Ai(r);
                    r = Si(t % n, r), r = Si(-1 / 0, r);
                } return r; }, markAsRoot: function (e) { return Si({ type: "root" }, e); }, dedentToRoot: function (e) { return Si(-1 / 0, e); }, dedent: function (e) { return Si(-1, e); } }; const _i = e => !Number.isNaN(e) && e >= 4352 && (e <= 4447 || 9001 === e || 9002 === e || 11904 <= e && e <= 12871 && 12351 !== e || 12880 <= e && e <= 19903 || 19968 <= e && e <= 42182 || 43360 <= e && e <= 43388 || 44032 <= e && e <= 55203 || 63744 <= e && e <= 64255 || 65040 <= e && e <= 65049 || 65072 <= e && e <= 65131 || 65281 <= e && e <= 65376 || 65504 <= e && e <= 65510 || 110592 <= e && e <= 110593 || 127488 <= e && e <= 127569 || 131072 <= e && e <= 262141); var Ni = _i, Pi = _i; Ni.default = Pi; const Mi = e => { if ("string" != typeof (e = e.replace(/\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g, "  ")) || 0 === e.length)
                return 0; e = (e => "string" == typeof e ? e.replace((({ onlyFirst: e = !1 } = {}) => { const t = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|"); return new RegExp(t, e ? void 0 : "g"); })(), "") : e)(e); let t = 0; for (let n = 0; n < e.length; n++) {
                const r = e.codePointAt(n);
                r <= 31 || r >= 127 && r <= 159 || r >= 768 && r <= 879 || (r > 65535 && n++, t += Ni(r) ? 2 : 1);
            } return t; }; var Ri = Mi, Ii = Mi; Ri.default = Ii; const ji = /[|\\{}()[\]^$+*?.-]/g; var Bi = e => { if ("string" != typeof e)
                throw new TypeError("Expected a string"); return e.replace(ji, "\\$&"); }; const Li = /[^\x20-\x7F]/; function qi(e) { return (t, n, r) => { const o = r && r.backwards; if (!1 === n)
                return !1; const { length: i } = t; let s = n; for (; s >= 0 && s < i;) {
                const n = t.charAt(s);
                if (e instanceof RegExp) {
                    if (!e.test(n))
                        return s;
                }
                else if (!e.includes(n))
                    return s;
                o ? s-- : s++;
            } return (-1 === s || s === i) && s; }; } const $i = qi(/\s/), Ui = qi(" \t"), Vi = qi(",; \t"), Wi = qi(/[^\r\n]/); function Ki(e, t) { if (!1 === t)
                return !1; if ("/" === e.charAt(t) && "*" === e.charAt(t + 1))
                for (let n = t + 2; n < e.length; ++n)
                    if ("*" === e.charAt(n) && "/" === e.charAt(n + 1))
                        return n + 2; return t; } function zi(e, t) { return !1 !== t && ("/" === e.charAt(t) && "/" === e.charAt(t + 1) ? Wi(e, t) : t); } function Hi(e, t, n) { const r = n && n.backwards; if (!1 === t)
                return !1; const o = e.charAt(t); if (r) {
                if ("\r" === e.charAt(t - 1) && "\n" === o)
                    return t - 2;
                if ("\n" === o || "\r" === o || "\u2028" === o || "\u2029" === o)
                    return t - 1;
            }
            else {
                if ("\r" === o && "\n" === e.charAt(t + 1))
                    return t + 2;
                if ("\n" === o || "\r" === o || "\u2028" === o || "\u2029" === o)
                    return t + 1;
            } return t; } function Yi(e, t, n) { const r = Ui(e, (n = n || {}).backwards ? t - 1 : t, n); return r !== Hi(e, r, n); } function Ji(e, t) { let n = null, r = t; for (; r !== n;)
                n = r, r = Vi(e, r), r = Ki(e, r), r = Ui(e, r); return r = zi(e, r), r = Hi(e, r), !1 !== r && Yi(e, r); } function Gi(e, t) { let n = null, r = t; for (; r !== n;)
                n = r, r = Ui(e, r), r = Ki(e, r), r = zi(e, r), r = Hi(e, r); return r; } function Xi(e, t, n) { return Gi(e, n(t)); } const Qi = {}; function Zi(e) { return Qi[e]; } [["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].forEach(((e, t) => { e.forEach((e => { Qi[e] = t; })); })); const es = { "==": !0, "!=": !0, "===": !0, "!==": !0 }, ts = { "*": !0, "/": !0, "%": !0 }, ns = { ">>": !0, ">>>": !0, "<<": !0 }; function rs(e) { return e.left ? rs(e.left) : e; } function os(e, t, n) { let r = 0; for (let o = n = n || 0; o < e.length; ++o)
                "\t" === e[o] ? r = r + t - r % t : r++; return r; } function is(e, t) { const n = e.slice(1, -1), r = { quote: '"', regex: /"/g }, o = { quote: "'", regex: /'/g }, i = "'" === t ? o : r, s = i === o ? r : o; let a = i.quote; return (n.includes(i.quote) || n.includes(s.quote)) && (a = (n.match(i.regex) || []).length > (n.match(s.regex) || []).length ? s.quote : i.quote), a; } function ss(e, t, n) { const r = '"' === t ? "'" : '"', o = e.replace(/\\([\s\S])|(['"])/g, ((e, o, i) => o === r ? o : i === t ? "\\" + i : i || (n && /^[^\\nrvtbfux\r\n\u2028\u2029"'0-7]$/.test(o) ? o : "\\" + o))); return t + o + t; } function as(e) { return e && (e.comments && e.comments.length > 0 && e.comments.some((e => us(e) && !e.unignore)) || e.prettierIgnore); } function us(e) { return "prettier-ignore" === e.value.trim(); } function cs(e, t) { (e.comments || (e.comments = [])).push(t), t.printed = !1, "JSXText" === e.type && (t.printed = !0); } var ls = { replaceEndOfLineWith: function (e, t) { const n = []; for (const r of e.split("\n"))
                    0 !== n.length && n.push(t), n.push(r); return n; }, getStringWidth: function (e) { return e ? Li.test(e) ? Ri(e) : e.length : 0; }, getMaxContinuousCount: function (e, t) { const n = e.match(new RegExp("(".concat(Bi(t), ")+"), "g")); return null === n ? 0 : n.reduce(((e, n) => Math.max(e, n.length / t.length)), 0); }, getMinNotPresentContinuousCount: function (e, t) { const n = e.match(new RegExp("(".concat(Bi(t), ")+"), "g")); if (null === n)
                    return 0; const r = new Map; let o = 0; for (const e of n) {
                    const n = e.length / t.length;
                    r.set(n, !0), n > o && (o = n);
                } for (let e = 1; e < o; e++)
                    if (!r.get(e))
                        return e; return o + 1; }, getPrecedence: Zi, shouldFlatten: function (e, t) { return !(Zi(t) !== Zi(e) || "**" === e || es[e] && es[t] || "%" === t && ts[e] || "%" === e && ts[t] || t !== e && ts[t] && ts[e] || ns[e] && ns[t]); }, isBitwiseOperator: function (e) { return !!ns[e] || "|" === e || "^" === e || "&" === e; }, getPenultimate: function (e) { return e.length > 1 ? e[e.length - 2] : null; }, getLast: xo, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: Gi, getNextNonSpaceNonCommentCharacterIndex: Xi, getNextNonSpaceNonCommentCharacter: function (e, t, n) { return e.charAt(Xi(e, t, n)); }, skip: qi, skipWhitespace: $i, skipSpaces: Ui, skipToLineEnd: Vi, skipEverythingButNewLine: Wi, skipInlineComment: Ki, skipTrailingComment: zi, skipNewline: Hi, isNextLineEmptyAfterIndex: Ji, isNextLineEmpty: function (e, t, n) { return Ji(e, n(t)); }, isPreviousLineEmpty: function (e, t, n) { let r = n(t) - 1; return r = Ui(e, r, { backwards: !0 }), r = Hi(e, r, { backwards: !0 }), r = Ui(e, r, { backwards: !0 }), r !== Hi(e, r, { backwards: !0 }); }, hasNewline: Yi, hasNewlineInRange: function (e, t, n) { for (let r = t; r < n; ++r)
                    if ("\n" === e.charAt(r))
                        return !0; return !1; }, hasSpaces: function (e, t, n) { return Ui(e, (n = n || {}).backwards ? t - 1 : t, n) !== t; }, setLocStart: function (e, t) { e.range ? e.range[0] = t : e.start = t; }, setLocEnd: function (e, t) { e.range ? e.range[1] = t : e.end = t; }, startsWithNoLookaheadToken: function e(t, n) { switch ((t = rs(t)).type) {
                    case "FunctionExpression":
                    case "ClassExpression":
                    case "DoExpression": return n;
                    case "ObjectExpression": return !0;
                    case "MemberExpression":
                    case "OptionalMemberExpression": return e(t.object, n);
                    case "TaggedTemplateExpression": return "FunctionExpression" !== t.tag.type && e(t.tag, n);
                    case "CallExpression":
                    case "OptionalCallExpression": return "FunctionExpression" !== t.callee.type && e(t.callee, n);
                    case "ConditionalExpression": return e(t.test, n);
                    case "UpdateExpression": return !t.prefix && e(t.argument, n);
                    case "BindExpression": return t.object && e(t.object, n);
                    case "SequenceExpression": return e(t.expressions[0], n);
                    case "TSAsExpression": return e(t.expression, n);
                    default: return !1;
                } }, getAlignmentSize: os, getIndentSize: function (e, t) { const n = e.lastIndexOf("\n"); return -1 === n ? 0 : os(e.slice(n + 1).match(/^[ \t]*/)[0], t); }, getPreferredQuote: is, printString: function (e, t, n) { const r = e.slice(1, -1), o = !r.includes('"') && !r.includes("'"), i = "json" === t.parser ? '"' : t.__isInHtmlAttribute ? "'" : is(e, t.singleQuote ? "'" : '"'); return n ? o ? i + r + i : e : ss(r, i, !("css" === t.parser || "less" === t.parser || "scss" === t.parser || t.embeddedInHtml)); }, printNumber: function (e) { return e.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, ""); }, hasIgnoreComment: function (e) { return as(e.getValue()); }, hasNodeIgnoreComment: as, isNodeIgnoreComment: us, makeString: ss, addLeadingComment: function (e, t) { t.leading = !0, t.trailing = !1, cs(e, t); }, addDanglingComment: function (e, t) { t.leading = !1, t.trailing = !1, cs(e, t); }, addTrailingComment: function (e, t) { t.leading = !1, t.trailing = !0, cs(e, t); }, isWithinParentArrayProperty: function (e, t) { const n = e.getValue(), r = e.getParentNode(); if (null == r)
                    return !1; if (!Array.isArray(r[t]))
                    return !1; const o = e.getName(); return r[t][o] === n; } }, ps = { guessEndOfLine: function (e) { const t = e.indexOf("\r"); return t >= 0 ? "\n" === e.charAt(t + 1) ? "crlf" : "cr" : "lf"; }, convertEndOfLineToChars: function (e) { switch (e) {
                    case "cr": return "\r";
                    case "crlf": return "\r\n";
                    default: return "\n";
                } } }; const { getStringWidth: fs } = ls, { convertEndOfLineToChars: ds } = ps, { concat: hs, fill: ms, cursor: gs } = Oi; let ys; function vs(e, t) { return Ds(e, { type: "indent" }, t); } function bs(e, t, n) { return t === -1 / 0 ? e.root || { value: "", length: 0, queue: [] } : t < 0 ? Ds(e, { type: "dedent" }, n) : t ? "root" === t.type ? Object.assign({}, e, { root: e }) : Ds(e, "string" == typeof t ? { type: "stringAlign", n: t } : { type: "numberAlign", n: t }, n) : e; } function Ds(e, t, n) { const r = "dedent" === t.type ? e.queue.slice(0, -1) : e.queue.concat(t); let o = "", i = 0, s = 0, a = 0; for (const e of r)
                switch (e.type) {
                    case "indent":
                        l(), n.useTabs ? u(1) : c(n.tabWidth);
                        break;
                    case "stringAlign":
                        l(), o += e.n, i += e.n.length;
                        break;
                    case "numberAlign":
                        s += 1, a += e.n;
                        break;
                    default: throw new Error("Unexpected type '".concat(e.type, "'"));
                } return p(), Object.assign({}, e, { value: o, length: i, queue: r }); function u(e) { o += "\t".repeat(e), i += n.tabWidth * e; } function c(e) { o += " ".repeat(e), i += e; } function l() { n.useTabs ? (s > 0 && u(s), f()) : p(); } function p() { a > 0 && c(a), f(); } function f() { s = 0, a = 0; } } function Es(e) { if (0 === e.length)
                return 0; let t = 0; for (; e.length > 0 && "string" == typeof e[e.length - 1] && e[e.length - 1].match(/^[ \t]*$/);)
                t += e.pop().length; if (e.length && "string" == typeof e[e.length - 1]) {
                const n = e[e.length - 1].replace(/[ \t]*$/, "");
                t += e[e.length - 1].length - n.length, e[e.length - 1] = n;
            } return t; } function Cs(e, t, n, r, o) { let i = t.length; const s = [e], a = []; for (; n >= 0;) {
                if (0 === s.length) {
                    if (0 === i)
                        return !0;
                    s.push(t[i - 1]), i--;
                    continue;
                }
                const [e, u, c] = s.pop();
                if ("string" == typeof c)
                    a.push(c), n -= fs(c);
                else
                    switch (c.type) {
                        case "concat":
                            for (let t = c.parts.length - 1; t >= 0; t--)
                                s.push([e, u, c.parts[t]]);
                            break;
                        case "indent":
                            s.push([vs(e, r), u, c.contents]);
                            break;
                        case "align":
                            s.push([bs(e, c.n, r), u, c.contents]);
                            break;
                        case "trim":
                            n += Es(a);
                            break;
                        case "group":
                            if (o && c.break)
                                return !1;
                            s.push([e, c.break ? 1 : u, c.contents]), c.id && (ys[c.id] = s[s.length - 1][1]);
                            break;
                        case "fill":
                            for (let t = c.parts.length - 1; t >= 0; t--)
                                s.push([e, u, c.parts[t]]);
                            break;
                        case "if-break": {
                            const t = c.groupId ? ys[c.groupId] : u;
                            1 === t && c.breakContents && s.push([e, u, c.breakContents]), 2 === t && c.flatContents && s.push([e, u, c.flatContents]);
                            break;
                        }
                        case "line": switch (u) {
                            case 2:
                                if (!c.hard) {
                                    c.soft || (a.push(" "), n -= 1);
                                    break;
                                }
                                return !0;
                            case 1: return !0;
                        }
                    }
            } return !1; } const ws = {}; function As(e, t, n, r) { const o = [e]; for (; 0 !== o.length;) {
                const e = o.pop();
                if (e === ws) {
                    n(o.pop());
                    continue;
                }
                let i = !0;
                if (t && !1 === t(e) && (i = !1), n && (o.push(e), o.push(ws)), i)
                    if ("concat" === e.type || "fill" === e.type)
                        for (let t = e.parts.length - 1; t >= 0; --t)
                            o.push(e.parts[t]);
                    else if ("if-break" === e.type)
                        e.flatContents && o.push(e.flatContents), e.breakContents && o.push(e.breakContents);
                    else if ("group" === e.type && e.expandedStates)
                        if (r)
                            for (let t = e.expandedStates.length - 1; t >= 0; --t)
                                o.push(e.expandedStates[t]);
                        else
                            o.push(e.contents);
                    else
                        e.contents && o.push(e.contents);
            } } function Ss(e, t) { if ("concat" === e.type || "fill" === e.type) {
                const n = e.parts.map((e => Ss(e, t)));
                return t(Object.assign({}, e, { parts: n }));
            } if ("if-break" === e.type) {
                const n = e.breakContents && Ss(e.breakContents, t), r = e.flatContents && Ss(e.flatContents, t);
                return t(Object.assign({}, e, { breakContents: n, flatContents: r }));
            } if (e.contents) {
                const n = Ss(e.contents, t);
                return t(Object.assign({}, e, { contents: n }));
            } return t(e); } function xs(e, t, n) { let r = n, o = !1; return As(e, (function (e) { const n = t(e); if (void 0 !== n && (o = !0, r = n), o)
                return !1; })), r; } function Ts(e) { return "string" != typeof e && ("line" === e.type || void 0); } function ks(e) { return !("group" !== e.type || !e.break) || !("line" !== e.type || !e.hard) || "break-parent" === e.type || void 0; } function Fs(e) { if (e.length > 0) {
                const t = e[e.length - 1];
                t.expandedStates || (t.break = !0);
            } return null; } function Os(e) { return "line" !== e.type || e.hard ? "if-break" === e.type ? e.flatContents || "" : e : e.soft ? "" : " "; } function _s(e) { if ("concat" === e.type) {
                const t = [];
                for (let n = 0; n < e.parts.length; ++n) {
                    const r = e.parts[n];
                    if ("string" != typeof r && "concat" === r.type)
                        t.push(..._s(r).parts);
                    else {
                        const e = _s(r);
                        "" !== e && t.push(e);
                    }
                }
                return Object.assign({}, e, { parts: t });
            } return "if-break" === e.type ? Object.assign({}, e, { breakContents: null != e.breakContents ? _s(e.breakContents) : null, flatContents: null != e.flatContents ? _s(e.flatContents) : null }) : "group" === e.type ? Object.assign({}, e, { contents: _s(e.contents), expandedStates: e.expandedStates ? e.expandedStates.map(_s) : e.expandedStates }) : e.contents ? Object.assign({}, e, { contents: _s(e.contents) }) : e; } function Ns(e) { if ("string" == typeof e)
                return JSON.stringify(e); if ("line" === e.type)
                return e.literal ? "literalline" : e.hard ? "hardline" : e.soft ? "softline" : "line"; if ("break-parent" === e.type)
                return "breakParent"; if ("trim" === e.type)
                return "trim"; if ("concat" === e.type)
                return "[" + e.parts.map(Ns).join(", ") + "]"; if ("indent" === e.type)
                return "indent(" + Ns(e.contents) + ")"; if ("align" === e.type)
                return e.n === -1 / 0 ? "dedentToRoot(" + Ns(e.contents) + ")" : e.n < 0 ? "dedent(" + Ns(e.contents) + ")" : "root" === e.n.type ? "markAsRoot(" + Ns(e.contents) + ")" : "align(" + JSON.stringify(e.n) + ", " + Ns(e.contents) + ")"; if ("if-break" === e.type)
                return "ifBreak(" + Ns(e.breakContents) + (e.flatContents ? ", " + Ns(e.flatContents) : "") + ")"; if ("group" === e.type)
                return e.expandedStates ? "conditionalGroup([" + e.expandedStates.map(Ns).join(",") + "])" : (e.break ? "wrappedGroup" : "group") + "(" + Ns(e.contents) + ")"; if ("fill" === e.type)
                return "fill(" + e.parts.map(Ns).join(", ") + ")"; if ("line-suffix" === e.type)
                return "lineSuffix(" + Ns(e.contents) + ")"; if ("line-suffix-boundary" === e.type)
                return "lineSuffixBoundary"; throw new Error("Unknown doc type " + e.type); } var Ps = { builders: Oi, printer: { printDocToString: function (e, t) { ys = {}; const n = t.printWidth, r = ds(t.endOfLine); let o = 0; const i = [[{ value: "", length: 0, queue: [] }, 1, e]], s = []; let a = !1, u = []; for (; 0 !== i.length;) {
                        const [e, c, l] = i.pop();
                        if ("string" == typeof l) {
                            const e = "\n" !== r && l.includes("\n") ? l.replace(/\n/g, r) : l;
                            s.push(e), o += fs(e);
                        }
                        else
                            switch (l.type) {
                                case "cursor":
                                    s.push(gs.placeholder);
                                    break;
                                case "concat":
                                    for (let t = l.parts.length - 1; t >= 0; t--)
                                        i.push([e, c, l.parts[t]]);
                                    break;
                                case "indent":
                                    i.push([vs(e, t), c, l.contents]);
                                    break;
                                case "align":
                                    i.push([bs(e, l.n, t), c, l.contents]);
                                    break;
                                case "trim":
                                    o -= Es(s);
                                    break;
                                case "group":
                                    switch (c) {
                                        case 2: if (!a) {
                                            i.push([e, l.break ? 1 : 2, l.contents]);
                                            break;
                                        }
                                        case 1: {
                                            a = !1;
                                            const r = [e, 2, l.contents], s = n - o;
                                            if (!l.break && Cs(r, i, s, t))
                                                i.push(r);
                                            else if (l.expandedStates) {
                                                const n = l.expandedStates[l.expandedStates.length - 1];
                                                if (l.break) {
                                                    i.push([e, 1, n]);
                                                    break;
                                                }
                                                for (let r = 1; r < l.expandedStates.length + 1; r++) {
                                                    if (r >= l.expandedStates.length) {
                                                        i.push([e, 1, n]);
                                                        break;
                                                    }
                                                    {
                                                        const n = [e, 2, l.expandedStates[r]];
                                                        if (Cs(n, i, s, t)) {
                                                            i.push(n);
                                                            break;
                                                        }
                                                    }
                                                }
                                            }
                                            else
                                                i.push([e, 1, l.contents]);
                                            break;
                                        }
                                    }
                                    l.id && (ys[l.id] = i[i.length - 1][1]);
                                    break;
                                case "fill": {
                                    const r = n - o, { parts: s } = l;
                                    if (0 === s.length)
                                        break;
                                    const [a, u] = s, p = [e, 2, a], f = [e, 1, a], d = Cs(p, [], r, t, !0);
                                    if (1 === s.length) {
                                        d ? i.push(p) : i.push(f);
                                        break;
                                    }
                                    const h = [e, 2, u], m = [e, 1, u];
                                    if (2 === s.length) {
                                        d ? (i.push(h), i.push(p)) : (i.push(m), i.push(f));
                                        break;
                                    }
                                    s.splice(0, 2);
                                    const g = [e, c, ms(s)], y = s[0];
                                    Cs([e, 2, hs([a, u, y])], [], r, t, !0) ? (i.push(g), i.push(h), i.push(p)) : d ? (i.push(g), i.push(m), i.push(p)) : (i.push(g), i.push(m), i.push(f));
                                    break;
                                }
                                case "if-break": {
                                    const t = l.groupId ? ys[l.groupId] : c;
                                    1 === t && l.breakContents && i.push([e, c, l.breakContents]), 2 === t && l.flatContents && i.push([e, c, l.flatContents]);
                                    break;
                                }
                                case "line-suffix":
                                    u.push([e, c, l.contents]);
                                    break;
                                case "line-suffix-boundary":
                                    u.length > 0 && i.push([e, c, { type: "line", hard: !0 }]);
                                    break;
                                case "line": switch (c) {
                                    case 2:
                                        if (!l.hard) {
                                            l.soft || (s.push(" "), o += 1);
                                            break;
                                        }
                                        a = !0;
                                    case 1:
                                        if (u.length) {
                                            i.push([e, c, l]), i.push(...u.reverse()), u = [];
                                            break;
                                        }
                                        l.literal ? e.root ? (s.push(r, e.root.value), o = e.root.length) : (s.push(r), o = 0) : (o -= Es(s), s.push(r + e.value), o = e.length);
                                }
                            }
                    } const c = s.indexOf(gs.placeholder); if (-1 !== c) {
                        const e = s.indexOf(gs.placeholder, c + 1), t = s.slice(0, c).join(""), n = s.slice(c + 1, e).join("");
                        return { formatted: t + n + s.slice(e + 1).join(""), cursorNodeStart: t.length, cursorNodeText: n };
                    } return { formatted: s.join("") }; } }, utils: { isEmpty: function (e) { return "string" == typeof e && 0 === e.length; }, willBreak: function (e) { return xs(e, ks, !1); }, isLineNext: function (e) { return xs(e, Ts, !1); }, traverseDoc: As, findInDoc: xs, mapDoc: Ss, propagateBreaks: function (e) { const t = new Set, n = []; As(e, (function (e) { if ("break-parent" === e.type && Fs(n), "group" === e.type) {
                        if (n.push(e), t.has(e))
                            return !1;
                        t.add(e);
                    } }), (function (e) { "group" === e.type && n.pop().break && Fs(n); }), !0); }, removeLines: function (e) { return Ss(e, Os); }, stripTrailingHardline: function e(t) { if ("concat" === t.type && 0 !== t.parts.length) {
                        const n = t.parts[t.parts.length - 1];
                        if ("concat" === n.type)
                            return 2 === n.parts.length && n.parts[0].hard && "break-parent" === n.parts[1].type ? { type: "concat", parts: t.parts.slice(0, -1) } : { type: "concat", parts: t.parts.slice(0, -1).concat(e(n)) };
                    } return t; } }, debug: { printDocToDebug: e => Ns(_s(e)) } }; const { getMaxContinuousCount: Ms, getStringWidth: Rs, getAlignmentSize: Is, getIndentSize: js, skip: Bs, skipWhitespace: Ls, skipSpaces: qs, skipNewline: $s, skipToLineEnd: Us, skipEverythingButNewLine: Vs, skipInlineComment: Ws, skipTrailingComment: Ks, hasNewline: zs, hasNewlineInRange: Hs, hasSpaces: Ys, isNextLineEmpty: Js, isNextLineEmptyAfterIndex: Gs, isPreviousLineEmpty: Xs, getNextNonSpaceNonCommentCharacterIndex: Qs, makeString: Zs, addLeadingComment: ea, addDanglingComment: ta, addTrailingComment: na } = ls; var ra = { getMaxContinuousCount: Ms, getStringWidth: Rs, getAlignmentSize: Is, getIndentSize: js, skip: Bs, skipWhitespace: Ls, skipSpaces: qs, skipNewline: $s, skipToLineEnd: Us, skipEverythingButNewLine: Vs, skipInlineComment: Ws, skipTrailingComment: Ks, hasNewline: zs, hasNewlineInRange: Hs, hasSpaces: Ys, isNextLineEmpty: Js, isNextLineEmptyAfterIndex: Gs, isPreviousLineEmpty: Xs, getNextNonSpaceNonCommentCharacterIndex: Qs, makeString: Zs, addLeadingComment: ea, addDanglingComment: ta, addTrailingComment: na }; const { concat: oa, line: ia, hardline: sa, breakParent: aa, indent: ua, lineSuffix: ca, join: la, cursor: pa } = Ps.builders, { hasNewline: fa, skipNewline: da, isPreviousLineEmpty: ha } = ls, { addLeadingComment: ma, addDanglingComment: ga, addTrailingComment: ya } = ra, va = Symbol("child-nodes"); function ba(e, t, n) { if (!e)
                return; const { printer: r, locStart: o, locEnd: i } = t; if (n) {
                if (r.canAttachComment && r.canAttachComment(e)) {
                    let t;
                    for (t = n.length - 1; t >= 0 && !(o(n[t]) <= o(e) && i(n[t]) <= i(e)); --t)
                        ;
                    return void n.splice(t + 1, 0, e);
                }
            }
            else if (e[va])
                return e[va]; const s = r.getCommentChildNodes && r.getCommentChildNodes(e, t) || "object" == typeof e && Object.keys(e).filter((e => "enclosingNode" !== e && "precedingNode" !== e && "followingNode" !== e)).map((t => e[t])); return s ? (n || Object.defineProperty(e, va, { value: n = [], enumerable: !1 }), s.forEach((e => { ba(e, t, n); })), n) : void 0; } function Da(e, t, n) { const { locStart: r, locEnd: o } = n, i = ba(e, n); let s, a, u = 0, c = i.length; for (; u < c;) {
                const e = u + c >> 1, l = i[e];
                if (r(l) - r(t) <= 0 && o(t) - o(l) <= 0)
                    return t.enclosingNode = l, void Da(l, t, n);
                if (o(l) - r(t) <= 0)
                    s = l, u = e + 1;
                else {
                    if (!(o(t) - r(l) <= 0))
                        throw new Error("Comment location overlaps with node location");
                    a = l, c = e;
                }
            } if (t.enclosingNode && "TemplateLiteral" === t.enclosingNode.type) {
                const { quasis: e } = t.enclosingNode, r = wa(e, t, n);
                s && wa(e, s, n) !== r && (s = null), a && wa(e, a, n) !== r && (a = null);
            } s && (t.precedingNode = s), a && (t.followingNode = a); } function Ea(e, t, n) { const r = e.length; if (0 === r)
                return; const { precedingNode: o, followingNode: i, enclosingNode: s } = e[0], a = n.printer.getGapRegex && n.printer.getGapRegex(s) || /^[\s(]*$/; let u, c = n.locStart(i); for (u = r; u > 0; --u) {
                const r = e[u - 1];
                Ci.strictEqual(r.precedingNode, o), Ci.strictEqual(r.followingNode, i);
                const s = t.slice(n.locEnd(r), c);
                if (!a.test(s))
                    break;
                c = n.locStart(r);
            } e.forEach(((e, t) => { t < u ? ya(o, e) : ma(i, e); })), e.length = 0; } function Ca(e, t) { return e.getValue().printed = !0, t.printer.printComment(e, t); } function wa(e, t, n) { const r = n.locStart(t) - 1; for (let t = 1; t < e.length; ++t)
                if (r < (o = e[t], void 0 !== o.start ? { start: o.start, end: o.end } : { start: o.range[0], end: o.range[1] }).start)
                    return t - 1; var o; return 0; } function Aa(e, t, n) { return e.getNode() === t.cursorNode && e.getValue() ? oa([pa, n, pa]) : n; } var Sa = { attach: function (e, t, n, r) { if (!Array.isArray(e))
                    return; const o = [], { locStart: i, locEnd: s } = r; e.forEach(((a, u) => { if ("json" === r.parser || "json5" === r.parser || "__js_expression" === r.parser || "__vue_expression" === r.parser) {
                    if (i(a) - i(t) <= 0)
                        return void ma(t, a);
                    if (s(a) - s(t) >= 0)
                        return void ya(t, a);
                } Da(t, a, r); const { precedingNode: c, enclosingNode: l, followingNode: p } = a, f = r.printer.handleComments && r.printer.handleComments.ownLine ? r.printer.handleComments.ownLine : () => !1, d = r.printer.handleComments && r.printer.handleComments.endOfLine ? r.printer.handleComments.endOfLine : () => !1, h = r.printer.handleComments && r.printer.handleComments.remaining ? r.printer.handleComments.remaining : () => !1, m = e.length - 1 === u; if (fa(n, i(a), { backwards: !0 }))
                    f(a, n, r, t, m) || (p ? ma(p, a) : c ? ya(c, a) : ga(l || t, a));
                else if (fa(n, s(a)))
                    d(a, n, r, t, m) || (c ? ya(c, a) : p ? ma(p, a) : ga(l || t, a));
                else if (h(a, n, r, t, m))
                    ;
                else if (c && p) {
                    const e = o.length;
                    e > 0 && o[e - 1].followingNode !== a.followingNode && Ea(o, n, r), o.push(a);
                }
                else
                    c ? ya(c, a) : p ? ma(p, a) : ga(l || t, a); })), Ea(o, n, r), e.forEach((e => { delete e.precedingNode, delete e.enclosingNode, delete e.followingNode; })); }, printComments: function (e, t, n, r) { const o = e.getValue(), i = t(e), s = o && o.comments; if (!s || 0 === s.length)
                    return Aa(e, n, i); const a = [], u = [r ? ";" : "", i]; return e.each((e => { const t = e.getValue(), { leading: r, trailing: o } = t; if (r) {
                    const r = function (e, t, n) { const r = e.getValue(), o = Ca(e, n); if (!o)
                        return ""; if (n.printer.isBlockComment && n.printer.isBlockComment(r)) {
                        const e = fa(n.originalText, n.locEnd(r)) ? fa(n.originalText, n.locStart(r), { backwards: !0 }) ? sa : ia : " ";
                        return oa([o, e]);
                    } return oa([o, sa]); }(e, 0, n);
                    if (!r)
                        return;
                    a.push(r);
                    const o = n.originalText, i = da(o, n.locEnd(t));
                    !1 !== i && fa(o, i) && a.push(sa);
                }
                else
                    o && u.push(function (e, t, n) { const r = e.getValue(), o = Ca(e, n); if (!o)
                        return ""; const i = n.printer.isBlockComment && n.printer.isBlockComment(r), s = e.getNode(1), a = e.getNode(2), u = a && ("ClassDeclaration" === a.type || "ClassExpression" === a.type) && a.superClass === s; if (fa(n.originalText, n.locStart(r), { backwards: !0 })) {
                        const e = ha(n.originalText, r, n.locStart);
                        return ca(oa([sa, e ? sa : "", o]));
                    } return oa(i || u ? [" ", o] : [ca(oa([" ", o])), i ? "" : aa]); }(e, 0, n)); }), "comments"), Aa(e, n, oa(a.concat(u))); }, printDanglingComments: function (e, t, n, r) { const o = [], i = e.getValue(); return i && i.comments ? (e.each((e => { const n = e.getValue(); !n || n.leading || n.trailing || r && !r(n) || o.push(Ca(e, t)); }), "comments"), 0 === o.length ? "" : n ? la(sa, o) : ua(oa([sa, la(sa, o)]))) : ""; }, getSortedChildNodes: ba }; function xa(e, t) { const n = Ta(e.stack, t); return -1 === n ? null : e.stack[n]; } function Ta(e, t) { for (let n = e.length - 1; n >= 0; n -= 2) {
                const r = e[n];
                if (r && !Array.isArray(r) && --t < 0)
                    return n;
            } return -1; } var ka = class {
                constructor(e) { this.stack = [e]; }
                getName() { const { stack: e } = this, { length: t } = e; return t > 1 ? e[t - 2] : null; }
                getValue() { return xo(this.stack); }
                getNode(e = 0) { return xa(this, e); }
                getParentNode(e = 0) { return xa(this, e + 1); }
                call(e, ...t) { const { stack: n } = this, { length: r } = n; let o = xo(n); for (const e of t)
                    o = o[e], n.push(e, o); const i = e(this); return n.length = r, i; }
                callParent(e, t = 0) { const n = Ta(this.stack, t + 1), r = this.stack.splice(n + 1), o = e(this); return this.stack.push(...r), o; }
                each(e, ...t) { const { stack: n } = this, { length: r } = n; let o = xo(n); for (const e of t)
                    o = o[e], n.push(e, o); for (let t = 0; t < o.length; ++t)
                    t in o && (n.push(t, o[t]), e(this), n.length -= 2); n.length = r; }
                map(e, ...t) { const { stack: n } = this, { length: r } = n; let o = xo(n); for (const e of t)
                    o = o[e], n.push(e, o); const i = new Array(o.length); for (let t = 0; t < o.length; ++t)
                    t in o && (n.push(t, o[t]), i[t] = e(this, t), n.length -= 2); return n.length = r, i; }
                match(...e) { let t = this.stack.length - 1, n = null, r = this.stack[t--]; for (const o of e) {
                    if (void 0 === r)
                        return !1;
                    let e = null;
                    if ("number" == typeof n && (e = n, n = this.stack[t--], r = this.stack[t--]), o && !o(r, n, e))
                        return !1;
                    n = this.stack[t--], r = this.stack[t--];
                } return !0; }
            }; const { normalize: Fa } = Di; var Oa = function (e, t, n, r) { if (n.printer.embed)
                return n.printer.embed(e, t, ((e, t) => function (e, t, n, r) { const o = Fa(Object.assign({}, n, {}, t, { parentParser: n.parser, embeddedInHtml: !(!n.embeddedInHtml && "html" !== n.parser && "vue" !== n.parser && "angular" !== n.parser && "lwc" !== n.parser), originalText: e }), { passThrough: !0 }), i = hi.parse(e, o), { ast: s } = i; e = i.text; const a = s.comments; return delete s.comments, Sa.attach(a, s, e, o), r(s, o); }(e, t, n, r)), n); }; const _a = Ps, Na = _a.builders, { concat: Pa, hardline: Ma, addAlignmentToDoc: Ra } = Na, Ia = _a.utils; function ja(e, t, n = 0) { const { printer: r } = t; r.preprocess && (e = r.preprocess(e, t)); const o = new Map; let i = function e(n, i) { const s = n.getValue(), a = s && "object" == typeof s && void 0 === i; if (a && o.has(s))
                return o.get(s); let u; return u = r.willPrintOwnComments && r.willPrintOwnComments(n, t) ? Ba(n, t, e, i) : Sa.printComments(n, (n => Ba(n, t, e, i)), t, i && i.needsSemi), a && o.set(s, u), u; }(new ka(e)); return n > 0 && (i = Ra(Pa([Ma, i]), n, t.tabWidth)), Ia.propagateBreaks(i), i; } function Ba(e, t, n, r) { Ci.ok(e instanceof ka); const o = e.getValue(), { printer: i } = t; if (i.hasPrettierIgnore && i.hasPrettierIgnore(e))
                return t.originalText.slice(t.locStart(o), t.locEnd(o)); if (o)
                try {
                    const r = Oa(e, n, t, ja);
                    if (r)
                        return r;
                }
                catch (e) {
                    if (ot.PRETTIER_DEBUG)
                        throw e;
                } return i.print(e, t, n, r); } var La = ja; function qa(e, t, n, r, o) { r = r || (() => !0), o = o || []; const i = n.locStart(e, n.locStart), s = n.locEnd(e, n.locEnd); if (i <= t && t <= s) {
                for (const i of Sa.getSortedChildNodes(e, n)) {
                    const s = qa(i, t, n, r, [e].concat(o));
                    if (s)
                        return s;
                }
                if (r(e))
                    return { node: e, parentNodes: o };
            } } function $a(e, t) { if (null == t)
                return !1; const n = ["FunctionDeclaration", "BlockStatement", "BreakStatement", "ContinueStatement", "DebuggerStatement", "DoWhileStatement", "EmptyStatement", "ExpressionStatement", "ForInStatement", "ForStatement", "IfStatement", "LabeledStatement", "ReturnStatement", "SwitchStatement", "ThrowStatement", "TryStatement", "VariableDeclaration", "WhileStatement", "WithStatement", "ClassDeclaration", "ImportDeclaration", "ExportDefaultDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration", "TypeAlias", "InterfaceDeclaration", "TypeAliasDeclaration", "ExportAssignment", "ExportDeclaration"], r = ["ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral"], o = ["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]; switch (e.parser) {
                case "flow":
                case "babel":
                case "babel-flow":
                case "babel-ts":
                case "typescript": return n.includes(t.type);
                case "json": return r.includes(t.type);
                case "graphql": return o.includes(t.kind);
                case "vue": return "root" !== t.tag;
            } return !1; } var Ua = { calculateRange: function (e, t, n) { const r = e.slice(t.rangeStart, t.rangeEnd), o = Math.max(t.rangeStart + r.search(/\S/), t.rangeStart); let i; for (i = t.rangeEnd; i > t.rangeStart && !e[i - 1].match(/\S/); --i)
                    ; const s = qa(n, o, t, (e => $a(t, e))), a = qa(n, i, t, (e => $a(t, e))); if (!s || !a)
                    return { rangeStart: 0, rangeEnd: 0 }; const u = function (e, t, n) { let r = e.node, o = t.node; if (r === o)
                    return { startNode: r, endNode: o }; for (const r of t.parentNodes) {
                    if (!("Program" !== r.type && "File" !== r.type && n.locStart(r) >= n.locStart(e.node)))
                        break;
                    o = r;
                } for (const o of e.parentNodes) {
                    if (!("Program" !== o.type && "File" !== o.type && n.locEnd(o) <= n.locEnd(t.node)))
                        break;
                    r = o;
                } return { startNode: r, endNode: o }; }(s, a, t), { startNode: c, endNode: l } = u; return { rangeStart: Math.min(t.locStart(c, t.locStart), t.locStart(l, t.locStart)), rangeEnd: Math.max(t.locEnd(c, t.locEnd), t.locEnd(l, t.locEnd)) }; }, findNodeAtOffset: qa }, Va = at(ne); const Wa = Di.normalize, { guessEndOfLine: Ka, convertEndOfLineToChars: za } = ps, { printer: { printDocToString: Ha }, debug: { printDocToDebug: Ya } } = Ps, Ja = Symbol("cursor"), Ga = { cursorOffset: "<<<PRETTIER_CURSOR>>>", rangeStart: "<<<PRETTIER_RANGE_START>>>", rangeEnd: "<<<PRETTIER_RANGE_END>>>" }; function Xa(e, t, n) { const r = t.comments; return r && (delete t.comments, Sa.attach(r, t, e, n)), t.tokens = [], n.originalText = "yaml" === n.parser ? e : e.trimEnd(), r; } function Qa(e, t, n) { if (!e || !e.trim().length)
                return { formatted: "", cursorOffset: 0 }; n = n || 0; const r = hi.parse(e, t), { ast: o } = r; if (e = r.text, t.cursorOffset >= 0) {
                const e = Ua.findNodeAtOffset(o, t.cursorOffset, t);
                e && e.node && (t.cursorNode = e.node);
            } const i = Xa(e, o, t), s = La(o, t, n), a = Ha(s, t); if (function (e) { if (e) {
                for (let t = 0; t < e.length; ++t)
                    if (ls.isNodeIgnoreComment(e[t]))
                        return;
                e.forEach((e => { if (!e.printed)
                    throw new Error('Comment "' + e.value.trim() + '" was not printed. Please report this error!'); delete e.printed; }));
            } }(i), n > 0) {
                const e = a.formatted.trim();
                void 0 !== a.cursorNodeStart && (a.cursorNodeStart -= a.formatted.indexOf(e)), a.formatted = e + za(t.endOfLine);
            } if (t.cursorOffset >= 0) {
                let n, r, o, i, s;
                if (t.cursorNode && a.cursorNodeText ? (n = t.locStart(t.cursorNode), r = e.slice(n, t.locEnd(t.cursorNode)), o = t.cursorOffset - n, i = a.cursorNodeStart, s = a.cursorNodeText) : (n = 0, r = e, o = t.cursorOffset, i = 0, s = a.formatted), r === s)
                    return { formatted: a.formatted, cursorOffset: i + o };
                const u = r.split("");
                u.splice(o, 0, Ja);
                const c = s.split(""), l = Va.diffArrays(u, c);
                let p = i;
                for (const e of l)
                    if (e.removed) {
                        if (e.value.includes(Ja))
                            break;
                    }
                    else
                        p += e.count;
                return { formatted: a.formatted, cursorOffset: p };
            } return { formatted: a.formatted }; } function Za(e, t) { const n = hi.resolveParser(t), r = !n.hasPragma || n.hasPragma(e); if (t.requirePragma && !r)
                return { formatted: e }; "auto" === t.endOfLine && (t.endOfLine = Ka(e)); const o = t.cursorOffset >= 0, i = t.rangeStart > 0, s = t.rangeEnd < e.length; if (e.includes("\r")) {
                const n = [o && "cursorOffset", i && "rangeStart", s && "rangeEnd"].filter(Boolean).sort(((e, n) => t[e] - t[n]));
                for (let r = n.length - 1; r >= 0; r--) {
                    const o = n[r];
                    e = e.slice(0, t[o]) + Ga[o] + e.slice(t[o]);
                }
                e = e.replace(/\r\n?/g, "\n");
                for (let r = 0; r < n.length; r++) {
                    const o = n[r];
                    e = e.replace(Ga[o], ((e, n) => (t[o] = n, "")));
                }
            } const a = "\ufeff" === e.charAt(0); a && (e = e.slice(1), o && t.cursorOffset++, i && t.rangeStart++, s && t.rangeEnd++), o || (t.cursorOffset = -1), t.rangeStart < 0 && (t.rangeStart = 0), t.rangeEnd > e.length && (t.rangeEnd = e.length); const u = i || s ? function (e, t) { const n = hi.parse(e, t), { ast: r } = n; e = n.text; const o = Ua.calculateRange(e, t, r), { rangeStart: i, rangeEnd: s } = o, a = e.slice(i, s), u = Math.min(i, e.lastIndexOf("\n", i) + 1), c = e.slice(u, i), l = ls.getAlignmentSize(c, t.tabWidth), p = Qa(a, Object.assign({}, t, { rangeStart: 0, rangeEnd: 1 / 0, cursorOffset: t.cursorOffset >= i && t.cursorOffset < s ? t.cursorOffset - i : -1 }), l), f = p.formatted.trimEnd(), d = e.slice(0, i), h = e.slice(s); let m, { cursorOffset: g } = t; if (t.cursorOffset >= s ? g = t.cursorOffset - s + (i + f.length) : void 0 !== p.cursorOffset && (g = p.cursorOffset + i), "lf" === t.endOfLine)
                m = d + f + h;
            else {
                const e = za(t.endOfLine);
                if (g >= 0) {
                    const t = [d, f, h];
                    let n = 0, r = g;
                    for (; n < t.length;) {
                        const e = t[n];
                        if (r < e.length) {
                            t[n] = t[n].slice(0, r) + Ga.cursorOffset + t[n].slice(r);
                            break;
                        }
                        n++, r -= e.length;
                    }
                    const [o, i, s] = t;
                    m = (o.replace(/\n/g, e) + i + s.replace(/\n/g, e)).replace(Ga.cursorOffset, ((e, t) => (g = t, "")));
                }
                else
                    m = d.replace(/\n/g, e) + f + h.replace(/\n/g, e);
            } return { formatted: m, cursorOffset: g }; }(e, t) : Qa(t.insertPragma && t.printer.insertPragma && !r ? t.printer.insertPragma(e) : e, t); return a && (u.formatted = "\ufeff" + u.formatted, o && u.cursorOffset++), u; } var eu = { formatWithCursor: (e, t) => Za(e, t = Wa(t)), parse(e, t, n) { t = Wa(t), e.includes("\r") && (e = e.replace(/\r\n?/g, "\n")); const r = hi.parse(e, t); return n && (r.ast = Ei(r.ast, t)), r; }, formatAST(e, t) { t = Wa(t); const n = La(e, t); return Ha(n, t); }, formatDoc: (e, t) => Za(Ya(e), t = Wa(Object.assign({}, t, { parser: "babel" }))).formatted, printToDoc(e, t) { t = Wa(t); const n = hi.parse(e, t), { ast: r } = n; return Xa(e = n.text, r, t), La(r, t); }, printDocToString: (e, t) => Ha(e, Wa(t)) }; const { builders: { hardline: tu, literalline: nu, concat: ru, markAsRoot: ou }, utils: { mapDoc: iu } } = Ps; const su = e => { if ("string" != typeof e)
                throw new TypeError("Expected a string"); const t = e.match(/(?:\r?\n)/g) || []; if (0 === t.length)
                return; const n = t.filter((e => "\r\n" === e)).length; return n > t.length - n ? "\r\n" : "\n"; }; var au = su; au.graceful = e => "string" == typeof e && su(e) || "\n"; var uu = st((function (e, t) { function n() { const e = Bn; return n = function () { return e; }, e; } function r() { const e = (t = au) && t.__esModule ? t : { default: t }; var t; return r = function () { return e; }, e; } Object.defineProperty(t, "__esModule", { value: !0 }), t.extract = function (e) { const t = e.match(s); return t ? t[0].trimLeft() : ""; }, t.strip = function (e) { const t = e.match(s); return t && t[0] ? e.substring(t[0].length) : e; }, t.parse = function (e) { return f(e).pragmas; }, t.parseWithComments = f, t.print = function ({ comments: e = "", pragmas: t = {} }) { const o = (0, r().default)(e) || n().EOL, i = Object.keys(t), s = i.map((e => d(e, t[e]))).reduce(((e, t) => e.concat(t)), []).map((e => " * " + e + o)).join(""); if (!e) {
                if (0 === i.length)
                    return "";
                if (1 === i.length && !Array.isArray(t[i[0]])) {
                    const e = t[i[0]];
                    return "".concat("/**", " ").concat(d(i[0], e)[0]).concat(" */");
                }
            } const a = e.split(o).map((e => "".concat(" *", " ").concat(e))).join(o) + o; return "/**" + o + (e ? a : "") + (e && i.length ? " *" + o : "") + s + " */"; }; const o = /\*\/$/, i = /^\/\*\*/, s = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, a = /(^|\s+)\/\/([^\r\n]*)/g, u = /^(\r?\n)+/, c = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, l = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, p = /(\r?\n|^) *\* ?/g; function f(e) { const t = (0, r().default)(e) || n().EOL; e = e.replace(i, "").replace(o, "").replace(p, "$1"); let s = ""; for (; s !== e;)
                s = e, e = e.replace(c, "".concat(t, "$1 $2").concat(t)); e = e.replace(u, "").trimRight(); const f = Object.create(null), d = e.replace(l, "").replace(u, "").trimRight(); let h; for (; h = l.exec(e);) {
                const e = h[2].replace(a, "");
                "string" == typeof f[h[1]] || Array.isArray(f[h[1]]) ? f[h[1]] = [].concat(f[h[1]], e) : f[h[1]] = e;
            } return { comments: d, pragmas: f }; } function d(e, t) { return [].concat(t).map((t => "@".concat(e, " ").concat(t).trim())); } })); it(uu), uu.extract, uu.strip, uu.parse, uu.parseWithComments, uu.print; var cu = { hasPragma: function (e) { const t = Object.keys(uu.parse(uu.extract(e))); return t.includes("prettier") || t.includes("format"); }, insertPragma: function (e) { const t = uu.parseWithComments(uu.extract(e)), n = Object.assign({ format: "" }, t.pragmas), r = uu.print({ pragmas: n, comments: t.comments.replace(/^(\s+?\r?\n)+/, "") }).replace(/(\r\n|\r)/g, "\n"), o = uu.strip(e); return r + (o.startsWith("\n") ? "\n" : "\n\n") + o; } }; const lu = { "---": "yaml", "+++": "toml" }; var pu = function (e) { const t = Object.keys(lu).map(Bi).join("|"), n = e.match(new RegExp("^(".concat(t, ")[^\\n\\S]*\\n(?:([\\s\\S]*?)\\n)?\\1[^\\n\\S]*(\\n|$)"))); if (null === n)
                return { frontMatter: null, content: e }; const [r, o, i] = n; return { frontMatter: { type: lu[o], value: i, raw: r.replace(/\n$/, "") }, content: r.replace(/[^\n]/g, " ") + e.slice(r.length) }; }, fu = { hasPragma: function (e) { return cu.hasPragma(pu(e).content); }, insertPragma: function (e) { const { frontMatter: t, content: n } = pu(e); return (t ? t.raw + "\n\n" : "") + cu.insertPragma(n); } }, du = function (e, t) { let n = 0; for (let r = 0; r < e.line - 1; ++r)
                if (n = t.indexOf("\n", n) + 1, -1 === n)
                    return -1; return n + e.column; }; const { getLast: hu, skipEverythingButNewLine: mu } = ls; var gu = { calculateLoc: function e(t, n) { if (t && "object" == typeof t) {
                    t.source && (t.source.startOffset = function (e, t) { return e.source ? du(e.source.start, t) - 1 : null; }(t, n), t.source.endOffset = function (e, t) { if ("css-comment" === e.type && e.inline)
                        return mu(t, e.source.startOffset); const n = e.nodes && hu(e.nodes); return n && e.source && !e.source.end && (e = n), e.source && e.source.end ? du(e.source.end, t) : null; }(t, n));
                    for (const r in t)
                        e(t[r], n);
                } }, replaceQuotesInInlineComments: function (e) { let t, n = "initial", r = "initial", o = !1; const i = []; for (let s = 0; s < e.length; s++) {
                    const a = e[s];
                    switch (n) {
                        case "initial":
                            if ("'" === a) {
                                n = "single-quotes";
                                continue;
                            }
                            if ('"' === a) {
                                n = "double-quotes";
                                continue;
                            }
                            if (("u" === a || "U" === a) && "url(" === e.slice(s, s + 4).toLowerCase()) {
                                n = "url", s += 3;
                                continue;
                            }
                            if ("*" === a && "/" === e[s - 1]) {
                                n = "comment-block";
                                continue;
                            }
                            if ("/" === a && "/" === e[s - 1]) {
                                n = "comment-inline", t = s - 1;
                                continue;
                            }
                            continue;
                        case "single-quotes":
                            if ("'" === a && "\\" !== e[s - 1] && (n = r, r = "initial"), "\n" === a || "\r" === a)
                                return e;
                            continue;
                        case "double-quotes":
                            if ('"' === a && "\\" !== e[s - 1] && (n = r, r = "initial"), "\n" === a || "\r" === a)
                                return e;
                            continue;
                        case "url":
                            if (")" === a && (n = "initial"), "\n" === a || "\r" === a)
                                return e;
                            if ("'" === a) {
                                n = "single-quotes", r = "url";
                                continue;
                            }
                            if ('"' === a) {
                                n = "double-quotes", r = "url";
                                continue;
                            }
                            continue;
                        case "comment-block":
                            "/" === a && "*" === e[s - 1] && (n = "initial");
                            continue;
                        case "comment-inline":
                            '"' !== a && "'" !== a || (o = !0), "\n" !== a && "\r" !== a || (o && i.push([t, s]), n = "initial", o = !1);
                            continue;
                    }
                } for (const [t, n] of i)
                    e = e.slice(0, t) + e.slice(t, n).replace(/'/g, "￾").replace(/"/g, "￿") + e.slice(n); return e; }, restoreQuotesInInlineComments: function (e) { return e.replace(/\ufffe/g, "'").replace(/\uffff/g, '"'); } }; const yu = ["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]; function vu(e, t) { const n = [].concat(t); let r, o = -1; for (; r = e.getParentNode(++o);)
                if (n.includes(r.type))
                    return o; return -1; } function bu(e, t) { const n = vu(e, t); return -1 === n ? null : e.getParentNode(n); } function Du(e) { return "value-operator" === e.type && "*" === e.value; } function Eu(e) { return "value-operator" === e.type && "/" === e.value; } function Cu(e) { return "value-operator" === e.type && "+" === e.value; } function wu(e) { return "value-operator" === e.type && "-" === e.value; } function Au(e) { return "value-operator" === e.type && "%" === e.value; } function Su(e) { return "value-comma_group" === e.type && e.groups && e.groups[1] && "value-colon" === e.groups[1].type; } function xu(e) { return "value-paren_group" === e.type && e.groups && e.groups[0] && Su(e.groups[0]); } var Tu = { getAncestorCounter: vu, getAncestorNode: bu, getPropOfDeclNode: function (e) { const t = bu(e, "css-decl"); return t && t.prop && t.prop.toLowerCase(); }, maybeToLowerCase: function (e) { return e.includes("$") || e.includes("@") || e.includes("#") || e.startsWith("%") || e.startsWith("--") || e.startsWith(":--") || e.includes("(") && e.includes(")") ? e : e.toLowerCase(); }, insideValueFunctionNode: function (e, t) { const n = bu(e, "value-func"); return n && n.value && n.value.toLowerCase() === t; }, insideICSSRuleNode: function (e) { const t = bu(e, "css-rule"); return t && t.raws && t.raws.selector && (t.raws.selector.startsWith(":import") || t.raws.selector.startsWith(":export")); }, insideAtRuleNode: function (e, t) { const n = [].concat(t), r = bu(e, "css-atrule"); return r && n.includes(r.name.toLowerCase()); }, insideURLFunctionInImportAtRuleNode: function (e) { const t = e.getValue(), n = bu(e, "css-atrule"); return n && "import" === n.name && "url" === t.groups[0].value && 2 === t.groups.length; }, isKeyframeAtRuleKeywords: function (e, t) { const n = bu(e, "css-atrule"); return n && n.name && n.name.toLowerCase().endsWith("keyframes") && ["from", "to"].includes(t.toLowerCase()); }, isWideKeywords: function (e) { return ["initial", "inherit", "unset", "revert"].includes(e.toLowerCase()); }, isSCSS: function (e, t) { return "less" === e || "scss" === e ? "scss" === e : /(\w\s*:\s*[^}:]+|#){|@import[^\n]+(?:url|,)/.test(t); }, isLastNode: function (e, t) { const n = e.getParentNode(); if (!n)
                    return !1; const { nodes: r } = n; return r && r.indexOf(t) === r.length - 1; }, isLessParser: function (e) { return "css" === e.parser || "less" === e.parser; }, isSCSSControlDirectiveNode: function (e) { return "css-atrule" === e.type && ["if", "else", "for", "each", "while"].includes(e.name); }, isDetachedRulesetDeclarationNode: function (e) { return !!e.selector && ("string" == typeof e.selector && /^@.+:.*$/.test(e.selector) || e.selector.value && /^@.+:.*$/.test(e.selector.value)); }, isRelationalOperatorNode: function (e) { return "value-word" === e.type && ["<", ">", "<=", ">="].includes(e.value); }, isEqualityOperatorNode: function (e) { return "value-word" === e.type && ["==", "!="].includes(e.value); }, isMultiplicationNode: Du, isDivisionNode: Eu, isAdditionNode: Cu, isSubtractionNode: wu, isModuloNode: Au, isMathOperatorNode: function (e) { return Du(e) || Eu(e) || Cu(e) || wu(e) || Au(e); }, isEachKeywordNode: function (e) { return "value-word" === e.type && "in" === e.value; }, isForKeywordNode: function (e) { return "value-word" === e.type && ["from", "through", "end"].includes(e.value); }, isURLFunctionNode: function (e) { return "value-func" === e.type && "url" === e.value.toLowerCase(); }, isIfElseKeywordNode: function (e) { return "value-word" === e.type && ["and", "or", "not"].includes(e.value); }, hasComposesNode: function (e) { return e.value && "value-root" === e.value.type && e.value.group && "value-value" === e.value.group.type && "composes" === e.prop.toLowerCase(); }, hasParensAroundNode: function (e) { return e.value && e.value.group && e.value.group.group && "value-paren_group" === e.value.group.group.type && null !== e.value.group.group.open && null !== e.value.group.group.close; }, hasEmptyRawBefore: function (e) { return e.raws && "" === e.raws.before; }, isSCSSNestedPropertyNode: function (e) { return !!e.selector && e.selector.replace(/\/\*.*?\*\//, "").replace(/\/\/.*?\n/, "").trim().endsWith(":"); }, isDetachedRulesetCallNode: function (e) { return e.raws && e.raws.params && /^\(\s*\)$/.test(e.raws.params); }, isTemplatePlaceholderNode: function (e) { return e.name.startsWith("prettier-placeholder"); }, isTemplatePropNode: function (e) { return e.prop.startsWith("@prettier-placeholder"); }, isPostcssSimpleVarNode: function (e, t) { return "$$" === e.value && "value-func" === e.type && t && "value-word" === t.type && !t.raws.before; }, isKeyValuePairNode: Su, isKeyValuePairInParenGroupNode: xu, isSCSSMapItemNode: function (e) { const t = e.getValue(); if (0 === t.groups.length)
                    return !1; const n = e.getParentNode(1); if (!(xu(t) || n && xu(n)))
                    return !1; const r = bu(e, "css-decl"); return !!(r && r.prop && r.prop.startsWith("$")) || !!xu(n) || "value-func" === n.type; }, isInlineValueCommentNode: function (e) { return "value-comment" === e.type && e.inline; }, isHashNode: function (e) { return "value-word" === e.type && "#" === e.value; }, isLeftCurlyBraceNode: function (e) { return "value-word" === e.type && "{" === e.value; }, isRightCurlyBraceNode: function (e) { return "value-word" === e.type && "}" === e.value; }, isWordNode: function (e) { return ["value-word", "value-atword"].includes(e.type); }, isColonNode: function (e) { return "value-colon" === e.type; }, isMediaAndSupportsKeywords: function (e) { return e.value && ["not", "and", "or"].includes(e.value.toLowerCase()); }, isColorAdjusterFuncNode: function (e) { return "value-func" === e.type && yu.includes(e.value.toLowerCase()); }, lastLineHasInlineComment: function (e) { return /\/\//.test(e.split(/[\r\n]/).pop()); } }; const { insertPragma: ku } = fu, { printNumber: Fu, printString: Ou, hasIgnoreComment: _u, hasNewline: Nu } = ls, { isNextLineEmpty: Pu } = ra, { restoreQuotesInInlineComments: Mu } = gu, { builders: { concat: Ru, join: Iu, line: ju, hardline: Bu, softline: Lu, group: qu, fill: $u, indent: Uu, dedent: Vu, ifBreak: Wu }, utils: { removeLines: Ku } } = Ps, { getAncestorNode: zu, getPropOfDeclNode: Hu, maybeToLowerCase: Yu, insideValueFunctionNode: Ju, insideICSSRuleNode: Gu, insideAtRuleNode: Xu, insideURLFunctionInImportAtRuleNode: Qu, isKeyframeAtRuleKeywords: Zu, isWideKeywords: ec, isSCSS: tc, isLastNode: nc, isLessParser: rc, isSCSSControlDirectiveNode: oc, isDetachedRulesetDeclarationNode: ic, isRelationalOperatorNode: sc, isEqualityOperatorNode: ac, isMultiplicationNode: uc, isDivisionNode: cc, isAdditionNode: lc, isSubtractionNode: pc, isMathOperatorNode: fc, isEachKeywordNode: dc, isForKeywordNode: hc, isURLFunctionNode: mc, isIfElseKeywordNode: gc, hasComposesNode: yc, hasParensAroundNode: vc, hasEmptyRawBefore: bc, isKeyValuePairNode: Dc, isDetachedRulesetCallNode: Ec, isTemplatePlaceholderNode: Cc, isTemplatePropNode: wc, isPostcssSimpleVarNode: Ac, isSCSSMapItemNode: Sc, isInlineValueCommentNode: xc, isHashNode: Tc, isLeftCurlyBraceNode: kc, isRightCurlyBraceNode: Fc, isWordNode: Oc, isColonNode: _c, isMediaAndSupportsKeywords: Nc, isColorAdjusterFuncNode: Pc, lastLineHasInlineComment: Mc } = Tu; function Rc(e) { switch (e.trailingComma) {
                case "all":
                case "es5": return !0;
                default: return !1;
            } } function Ic(e, t, n) { const r = e.getValue(), o = []; let i = 0; return e.map((e => { const s = r.nodes[i - 1]; if (s && "css-comment" === s.type && "prettier-ignore" === s.text.trim()) {
                const n = e.getValue();
                o.push(t.originalText.slice(t.locStart(n), t.locEnd(n)));
            }
            else
                o.push(e.call(n)); i !== r.nodes.length - 1 && ("css-comment" === r.nodes[i + 1].type && !Nu(t.originalText, t.locStart(r.nodes[i + 1]), { backwards: !0 }) && "yaml" !== r.nodes[i].type && "toml" !== r.nodes[i].type || "css-atrule" === r.nodes[i + 1].type && "else" === r.nodes[i + 1].name && "css-comment" !== r.nodes[i].type ? o.push(" ") : (o.push(t.__isHTMLStyleAttribute ? ju : Bu), Pu(t.originalText, e.getValue(), t.locEnd) && "yaml" !== r.nodes[i].type && "toml" !== r.nodes[i].type && o.push(Bu))), i++; }), "nodes"), Ru(o); } const jc = /(['"])(?:(?!\1)[^\\]|\\[\s\S])*\1/g, Bc = new RegExp(jc.source + "|" + "(".concat(/[$@]?[a-zA-Z_\u0080-\uFFFF][\w\-\u0080-\uFFFF]*/g.source, ")?") + "(".concat(/(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g.source, ")") + "(".concat(/[a-zA-Z]+/g.source, ")?"), "g"); function Lc(e, t) { return e.replace(jc, (e => Ou(e, t))); } function qc(e, t) { const n = t.singleQuote ? "'" : '"'; return e.includes('"') || e.includes("'") ? e : n + e + n; } function $c(e) { return e.replace(Bc, ((e, t, n, r, o) => !n && r ? Uc(r) + Yu(o || "") : e)); } function Uc(e) { return Fu(e).replace(/\.0(?=$|e)/, ""); } var Vc = { print: function (e, t, n) { const r = e.getValue(); if (!r)
                    return ""; if ("string" == typeof r)
                    return r; switch (r.type) {
                    case "yaml":
                    case "toml": return Ru([r.raw, Bu]);
                    case "css-root": {
                        const r = Ic(e, t, n);
                        return r.parts.length ? Ru([r, t.__isHTMLStyleAttribute ? "" : Bu]) : r;
                    }
                    case "css-comment": {
                        const e = r.inline || r.raws.inline, n = t.originalText.slice(t.locStart(r), t.locEnd(r));
                        return e ? n.trimEnd() : n;
                    }
                    case "css-rule": return Ru([e.call(n, "selector"), r.important ? " !important" : "", r.nodes ? Ru([r.selector && "selector-unknown" === r.selector.type && Mc(r.selector.value) ? ju : " ", "{", r.nodes.length > 0 ? Uu(Ru([Bu, Ic(e, t, n)])) : "", Bu, "}", ic(r) ? ";" : ""]) : ";"]);
                    case "css-decl": {
                        const o = e.getParentNode();
                        return Ru([r.raws.before.replace(/[\s;]/g, ""), Gu(e) ? r.prop : Yu(r.prop), ":" === r.raws.between.trim() ? ":" : r.raws.between.trim(), r.extend ? "" : " ", yc(r) ? Ku(e.call(n, "value")) : e.call(n, "value"), r.raws.important ? r.raws.important.replace(/\s*!\s*important/i, " !important") : r.important ? " !important" : "", r.raws.scssDefault ? r.raws.scssDefault.replace(/\s*!default/i, " !default") : r.scssDefault ? " !default" : "", r.raws.scssGlobal ? r.raws.scssGlobal.replace(/\s*!global/i, " !global") : r.scssGlobal ? " !global" : "", r.nodes ? Ru([" {", Uu(Ru([Lu, Ic(e, t, n)])), Lu, "}"]) : wc(r) && !o.raws.semicolon && ";" !== t.originalText[t.locEnd(r) - 1] ? "" : ";"]);
                    }
                    case "css-atrule": {
                        const o = e.getParentNode(), i = Cc(r) && !o.raws.semicolon && ";" !== t.originalText[t.locEnd(r) - 1];
                        if (rc(t)) {
                            if (r.mixin)
                                return Ru([e.call(n, "selector"), r.important ? " !important" : "", i ? "" : ";"]);
                            if (r.function)
                                return Ru([r.name, Ru([e.call(n, "params")]), i ? "" : ";"]);
                            if (r.variable)
                                return Ru(["@", r.name, ": ", r.value ? Ru([e.call(n, "value")]) : "", r.raws.between.trim() ? r.raws.between.trim() + " " : "", r.nodes ? Ru(["{", Uu(Ru([r.nodes.length > 0 ? Lu : "", Ic(e, t, n)])), Lu, "}"]) : "", i ? "" : ";"]);
                        }
                        return Ru(["@", Ec(r) || r.name.endsWith(":") ? r.name : Yu(r.name), r.params ? Ru([Ec(r) ? "" : Cc(r) ? "" === r.raws.afterName ? "" : r.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(r.raws.afterName) ? Ru([Bu, Bu]) : /^\s*\n/.test(r.raws.afterName) ? Bu : " " : " ", e.call(n, "params")]) : "", r.selector ? Uu(Ru([" ", e.call(n, "selector")])) : "", r.value ? qu(Ru([" ", e.call(n, "value"), oc(r) ? vc(r) ? " " : ju : ""])) : "else" === r.name ? " " : "", r.nodes ? Ru([oc(r) ? "" : " ", "{", Uu(Ru([r.nodes.length > 0 ? Lu : "", Ic(e, t, n)])), Lu, "}"]) : i ? "" : ";"]);
                    }
                    case "media-query-list": {
                        const t = [];
                        return e.each((e => { const r = e.getValue(); "media-query" === r.type && "" === r.value || t.push(e.call(n)); }), "nodes"), qu(Uu(Iu(ju, t)));
                    }
                    case "media-query": return Ru([Iu(" ", e.map(n, "nodes")), nc(e, r) ? "" : ","]);
                    case "media-type":
                    case "media-value": return $c(Lc(r.value, t));
                    case "media-feature-expression": return r.nodes ? Ru(["(", Ru(e.map(n, "nodes")), ")"]) : r.value;
                    case "media-feature": return Yu(Lc(r.value.replace(/ +/g, " "), t));
                    case "media-colon":
                    case "value-comma": return Ru([r.value, " "]);
                    case "media-keyword":
                    case "selector-string": return Lc(r.value, t);
                    case "media-url": return Lc(r.value.replace(/^url\(\s+/gi, "url(").replace(/\s+\)$/gi, ")"), t);
                    case "media-unknown":
                    case "selector-comment":
                    case "selector-nesting":
                    case "value-paren":
                    case "value-operator":
                    case "value-unicode-range":
                    case "value-unknown": return r.value;
                    case "selector-root": return qu(Ru([Xu(e, "custom-selector") ? Ru([zu(e, "css-atrule").customSelector, ju]) : "", Iu(Ru([",", Xu(e, ["extend", "custom-selector", "nest"]) ? ju : Bu]), e.map(n, "nodes"))]));
                    case "selector-selector": return qu(Uu(Ru(e.map(n, "nodes"))));
                    case "selector-tag": {
                        const t = e.getParentNode(), n = t && t.nodes.indexOf(r), o = n && t.nodes[n - 1];
                        return Ru([r.namespace ? Ru([!0 === r.namespace ? "" : r.namespace.trim(), "|"]) : "", "selector-nesting" === o.type ? r.value : $c(Zu(e, r.value) ? r.value.toLowerCase() : r.value)]);
                    }
                    case "selector-id": return Ru(["#", r.value]);
                    case "selector-class": return Ru([".", $c(Lc(r.value, t))]);
                    case "selector-attribute": return Ru(["[", r.namespace ? Ru([!0 === r.namespace ? "" : r.namespace.trim(), "|"]) : "", r.attribute.trim(), r.operator ? r.operator : "", r.value ? qc(Lc(r.value.trim(), t), t) : "", r.insensitive ? " i" : "", "]"]);
                    case "selector-combinator": {
                        if ("+" === r.value || ">" === r.value || "~" === r.value || ">>>" === r.value) {
                            const t = e.getParentNode(), n = "selector-selector" === t.type && t.nodes[0] === r ? "" : ju;
                            return Ru([n, r.value, nc(e, r) ? "" : " "]);
                        }
                        const n = r.value.trim().startsWith("(") ? ju : "", o = $c(Lc(r.value.trim(), t)) || ju;
                        return Ru([n, o]);
                    }
                    case "selector-universal": return Ru([r.namespace ? Ru([!0 === r.namespace ? "" : r.namespace.trim(), "|"]) : "", r.value]);
                    case "selector-pseudo": return Ru([Yu(r.value), r.nodes && r.nodes.length > 0 ? Ru(["(", Iu(", ", e.map(n, "nodes")), ")"]) : ""]);
                    case "selector-unknown": {
                        const n = zu(e, "css-rule");
                        if (n && n.isSCSSNesterProperty)
                            return $c(Lc(Yu(r.value), t));
                        const o = e.getParentNode();
                        if (o.raws && o.raws.selector) {
                            const e = t.locStart(o), n = e + o.raws.selector.length;
                            return t.originalText.slice(e, n).trim();
                        }
                        return r.value;
                    }
                    case "value-value":
                    case "value-root": return e.call(n, "group");
                    case "value-comment": return Ru([r.inline ? "//" : "/*", Mu(r.value), r.inline ? "" : "*/"]);
                    case "value-comma_group": {
                        const t = e.getParentNode(), o = e.getParentNode(1), i = Hu(e), s = i && "value-value" === t.type && ("grid" === i || i.startsWith("grid-template")), a = zu(e, "css-atrule"), u = a && oc(a), c = e.map(n, "groups"), l = [], p = Ju(e, "url");
                        let f = !1, d = !1;
                        for (let t = 0; t < r.groups.length; ++t) {
                            l.push(c[t]);
                            const n = r.groups[t - 1], i = r.groups[t], h = r.groups[t + 1], m = r.groups[t + 2];
                            if (p) {
                                (h && lc(h) || lc(i)) && l.push(" ");
                                continue;
                            }
                            if (!h)
                                continue;
                            if (!n && "--" === i.value && "value-atword" === h.type)
                                continue;
                            const g = "value-string" === i.type && i.value.startsWith("#{"), y = f && "value-string" === h.type && h.value.endsWith("}");
                            if (g || y) {
                                f = !f;
                                continue;
                            }
                            if (f)
                                continue;
                            if (_c(i) || _c(h))
                                continue;
                            if ("value-atword" === i.type && "" === i.value)
                                continue;
                            if ("~" === i.value)
                                continue;
                            if (i.value && i.value.includes("\\") && h && "value-comment" !== h.type)
                                continue;
                            if (n && n.value && n.value.indexOf("\\") === n.value.length - 1 && "value-operator" === i.type && "/" === i.value)
                                continue;
                            if ("\\" === i.value)
                                continue;
                            if (Ac(i, h))
                                continue;
                            if (Tc(i) || kc(i) || Fc(h) || kc(h) && bc(h) || Fc(i) && bc(h))
                                continue;
                            if ("--" === i.value && Tc(h))
                                continue;
                            const v = fc(i), b = fc(h);
                            if ((v && Tc(h) || b && Fc(i)) && bc(h))
                                continue;
                            if (Ju(e, "calc") && (lc(i) || lc(h) || pc(i) || pc(h)) && bc(h))
                                continue;
                            const D = (lc(i) || pc(i)) && 0 === t && ("value-number" === h.type || h.isHex) && o && Pc(o) && !bc(h), E = m && "value-func" === m.type || m && Oc(m) || "value-func" === i.type || Oc(i), C = "value-func" === h.type || Oc(h) || n && "value-func" === n.type || n && Oc(n);
                            (uc(h) || uc(i) || Ju(e, "calc") || D || !(cc(h) && !E || cc(i) && !C || lc(h) && !E || lc(i) && !C || pc(h) || pc(i)) || !(bc(h) || v && (!n || n && fc(n)))) && (xc(i) ? l.push(Bu) : u && (ac(h) || sc(h) || gc(h) || dc(i) || hc(i)) || a && "namespace" === a.name.toLowerCase() ? l.push(" ") : s ? i.source && h.source && i.source.start.line !== h.source.start.line ? (l.push(Bu), d = !0) : l.push(" ") : b ? l.push(" ") : l.push(ju));
                        }
                        return d && l.unshift(Bu), u ? qu(Uu(Ru(l))) : Qu(e) ? qu($u(l)) : qu(Uu($u(l)));
                    }
                    case "value-paren_group": {
                        const o = e.getParentNode();
                        if (o && mc(o) && (1 === r.groups.length || r.groups.length > 0 && "value-comma_group" === r.groups[0].type && r.groups[0].groups.length > 0 && "value-word" === r.groups[0].groups[0].type && r.groups[0].groups[0].value.startsWith("data:")))
                            return Ru([r.open ? e.call(n, "open") : "", Iu(",", e.map(n, "groups")), r.close ? e.call(n, "close") : ""]);
                        if (!r.open) {
                            const t = e.map(n, "groups"), r = [];
                            for (let e = 0; e < t.length; e++)
                                0 !== e && r.push(Ru([",", ju])), r.push(t[e]);
                            return qu(Uu($u(r)));
                        }
                        const i = Sc(e), s = r.groups[r.groups.length - 1], a = s && "value-comment" === s.type;
                        return qu(Ru([r.open ? e.call(n, "open") : "", Uu(Ru([Lu, Iu(Ru([",", ju]), e.map((e => { const t = e.getValue(), r = n(e); return Dc(t) && "value-comma_group" === t.type && t.groups && t.groups[2] && "value-paren_group" === t.groups[2].type ? (r.contents.contents.parts[1] = qu(r.contents.contents.parts[1]), qu(Vu(r))) : r; }), "groups"))])), Wu(!a && tc(t.parser, t.originalText) && i && Rc(t) ? "," : ""), Lu, r.close ? e.call(n, "close") : ""]), { shouldBreak: i });
                    }
                    case "value-func": return Ru([r.value, Xu(e, "supports") && Nc(r) ? " " : "", e.call(n, "group")]);
                    case "value-number": return Ru([Uc(r.value), Yu(r.unit)]);
                    case "value-word": return r.isColor && r.isHex || ec(r.value) ? r.value.toLowerCase() : r.value;
                    case "value-colon": return Ru([r.value, Ju(e, "url") ? "" : ju]);
                    case "value-string": return Ou(r.raws.quote + r.value + r.raws.quote, t);
                    case "value-atword": return Ru(["@", r.value]);
                    default: throw new Error("Unknown postcss type ".concat(JSON.stringify(r.type)));
                } }, embed: function (e, t, n) { const r = e.getValue(); return "yaml" === r.type ? ou(ru(["---", tu, r.value.trim() ? (o = n(r.value, { parser: "yaml" }), iu(o, (e => "string" == typeof e && e.includes("\n") ? ru(e.split(/(\n)/g).map(((e, t) => t % 2 == 0 ? e : nu))) : e))) : "", "---", tu])) : null; var o; }, insertPragma: ku, hasPrettierIgnore: _u, massageAstNode: function (e, t, n) { if (["raw", "raws", "sourceIndex", "source", "before", "after", "trailingComma"].forEach((e => { delete t[e]; })), "yaml" === e.type && delete t.value, "css-comment" === e.type && "css-root" === n.type && 0 !== n.nodes.length && (n.nodes[0] === e || ("yaml" === n.nodes[0].type || "toml" === n.nodes[0].type) && n.nodes[1] === e) && (delete t.text, /^\*\s*@(format|prettier)\s*$/.test(e.text)))
                    return null; if ("media-query" !== e.type && "media-query-list" !== e.type && "media-feature-expression" !== e.type || delete t.value, "css-rule" === e.type && delete t.params, "selector-combinator" === e.type && (t.value = t.value.replace(/\s+/g, " ")), "media-feature" === e.type && (t.value = t.value.replace(/ /g, "")), ("value-word" === e.type && (e.isColor && e.isHex || ["initial", "inherit", "unset", "revert"].includes(t.value.replace().toLowerCase())) || "media-feature" === e.type || "selector-root-invalid" === e.type || "selector-pseudo" === e.type) && (t.value = t.value.toLowerCase()), "css-decl" === e.type && (t.prop = t.prop.toLowerCase()), "css-atrule" !== e.type && "css-import" !== e.type || (t.name = t.name.toLowerCase()), "value-number" === e.type && (t.unit = t.unit.toLowerCase()), "media-feature" !== e.type && "media-keyword" !== e.type && "media-type" !== e.type && "media-unknown" !== e.type && "media-url" !== e.type && "media-value" !== e.type && "selector-attribute" !== e.type && "selector-string" !== e.type && "selector-class" !== e.type && "selector-combinator" !== e.type && "value-string" !== e.type || !t.value || (t.value = t.value.replace(/'/g, '"').replace(/\\([^a-fA-F\d])/g, "$1")), "selector-attribute" === e.type && (t.attribute = t.attribute.trim(), t.namespace && "string" == typeof t.namespace && (t.namespace = t.namespace.trim(), 0 === t.namespace.length && (t.namespace = !0)), t.value && (t.value = t.value.trim().replace(/^['"]|['"]$/g, ""), delete t.quoted)), "media-value" !== e.type && "media-type" !== e.type && "value-number" !== e.type && "selector-root-invalid" !== e.type && "selector-class" !== e.type && "selector-combinator" !== e.type && "selector-tag" !== e.type || !t.value || (t.value = t.value.replace(/([\d.eE+-]+)([a-zA-Z]*)/g, ((e, t, n) => { const r = Number(t); return isNaN(r) ? e : r + n.toLowerCase(); }))), "selector-tag" === e.type) {
                    const n = e.value.toLowerCase();
                    ["from", "to"].includes(n) && (t.value = n);
                } "css-atrule" === e.type && "supports" === e.name.toLowerCase() && delete t.value, "selector-unknown" === e.type && delete t.value; } }; const Wc = "Common"; var Kc = { bracketSpacing: { since: "0.0.0", category: Wc, type: "boolean", default: !0, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { since: "0.0.0", category: Wc, type: "boolean", default: !1, description: "Use single quotes instead of double quotes." }, proseWrap: { since: "1.8.2", category: Wc, type: "choice", default: [{ since: "1.8.2", value: !0 }, { since: "1.9.0", value: "preserve" }], description: "How to wrap prose.", choices: [{ since: "1.9.0", value: "always", description: "Wrap prose if it exceeds the print width." }, { since: "1.9.0", value: "never", description: "Do not wrap prose." }, { since: "1.9.0", value: "preserve", description: "Wrap prose as-is." }] } }, zc = { singleQuote: Kc.singleQuote }, Hc = function (e, t) { const { languageId: n } = e, r = dt(e, ["languageId"]); return Object.assign({ linguistLanguageId: n }, r, {}, t(e)); }, Yc = "markup", Jc = "source.css", Gc = "text/css", Xc = "#563d7c", Qc = [".css"], Zc = { name: "CSS", type: Yc, tmScope: Jc, aceMode: "css", codemirrorMode: "css", codemirrorMimeType: Gc, color: Xc, extensions: Qc, languageId: 50 }, el = Object.freeze({ __proto__: null, name: "CSS", type: Yc, tmScope: Jc, aceMode: "css", codemirrorMode: "css", codemirrorMimeType: Gc, color: Xc, extensions: Qc, languageId: 50, default: Zc }), tl = "PostCSS", nl = "markup", rl = "source.postcss", ol = [".pcss", ".postcss"], il = "text", sl = 262764437, al = { name: tl, type: nl, tmScope: rl, group: "CSS", extensions: ol, aceMode: il, languageId: sl }, ul = Object.freeze({ __proto__: null, name: tl, type: nl, tmScope: rl, group: "CSS", extensions: ol, aceMode: il, languageId: sl, default: al }), cl = "Less", ll = "markup", pl = [".less"], fl = "source.css.less", dl = "less", hl = "text/css", ml = { name: cl, type: ll, group: "CSS", extensions: pl, tmScope: fl, aceMode: dl, codemirrorMode: "css", codemirrorMimeType: hl, languageId: 198 }, gl = Object.freeze({ __proto__: null, name: cl, type: ll, group: "CSS", extensions: pl, tmScope: fl, aceMode: dl, codemirrorMode: "css", codemirrorMimeType: hl, languageId: 198, default: ml }), yl = "SCSS", vl = "markup", bl = "source.css.scss", Dl = "scss", El = "text/x-scss", Cl = [".scss"], wl = { name: yl, type: vl, tmScope: bl, group: "CSS", aceMode: Dl, codemirrorMode: "css", codemirrorMimeType: El, extensions: Cl, languageId: 329 }, Al = Object.freeze({ __proto__: null, name: yl, type: vl, tmScope: bl, group: "CSS", aceMode: Dl, codemirrorMode: "css", codemirrorMimeType: El, extensions: Cl, languageId: 329, default: wl }), Sl = at(el), xl = at(ul), Tl = at(gl), kl = at(Al), Fl = { languages: [Hc(Sl, (() => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["css"] }))), Hc(xl, (() => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["postcss"] }))), Hc(Tl, (() => ({ since: "1.4.0", parsers: ["less"], vscodeLanguageIds: ["less"] }))), Hc(kl, (() => ({ since: "1.4.0", parsers: ["scss"], vscodeLanguageIds: ["scss"] })))], options: zc, printers: { postcss: Vc } }; const { concat: Ol, join: _l, hardline: Nl, line: Pl, softline: Ml, group: Rl, indent: Il, ifBreak: jl } = Ps.builders, { hasIgnoreComment: Bl } = ls, { isNextLineEmpty: Ll } = ra, { insertPragma: ql } = { hasPragma: function (e) { return /^\s*#[^\n\S]*@(format|prettier)\s*(\n|$)/.test(e); }, insertPragma: function (e) { return "# @format\n\n" + e; } }; function $l(e, t, n) { return 0 === n.directives.length ? "" : Ol([" ", Rl(Il(Ol([Ml, _l(Ol([jl("", " "), Ml]), e.map(t, "directives"))])))]); } function Ul(e, t, n) { const r = e.getValue().length; return e.map(((e, o) => { const i = n(e); return Ll(t.originalText, e.getValue(), t.locEnd) && o < r - 1 ? Ol([i, Nl]) : i; })); } function Vl(e, t, n) { return "," === n.originalText.slice(e.loc.end, t.loc.start).replace(/#.*/g, "").trim() ? ", " : " & "; } function Wl(e, t, n) { const r = e.getNode(), o = [], { interfaces: i } = r, s = e.map((e => n(e)), "interfaces"); for (let e = 0; e < i.length; e++) {
                const n = i[e];
                e > 0 && o.push(Vl(i[e - 1], n, t)), o.push(s[e]);
            } return o; } var Kl = { print: function (e, t, n) { const r = e.getValue(); if (!r)
                    return ""; if ("string" == typeof r)
                    return r; switch (r.kind) {
                    case "Document": {
                        const o = [];
                        return e.map(((e, i) => { o.push(Ol([e.call(n)])), i !== r.definitions.length - 1 && (o.push(Nl), Ll(t.originalText, e.getValue(), t.locEnd) && o.push(Nl)); }), "definitions"), Ol([Ol(o), Nl]);
                    }
                    case "OperationDefinition": {
                        const o = "{" !== t.originalText[t.locStart(r)], i = !!r.name;
                        return Ol([o ? r.operation : "", o && i ? Ol([" ", e.call(n, "name")]) : "", r.variableDefinitions && r.variableDefinitions.length ? Rl(Ol(["(", Il(Ol([Ml, _l(Ol([jl("", ", "), Ml]), e.map(n, "variableDefinitions"))])), Ml, ")"])) : "", $l(e, n, r), r.selectionSet && (o || i) ? " " : "", e.call(n, "selectionSet")]);
                    }
                    case "FragmentDefinition": return Ol(["fragment ", e.call(n, "name"), r.variableDefinitions && r.variableDefinitions.length ? Rl(Ol(["(", Il(Ol([Ml, _l(Ol([jl("", ", "), Ml]), e.map(n, "variableDefinitions"))])), Ml, ")"])) : "", " on ", e.call(n, "typeCondition"), $l(e, n, r), " ", e.call(n, "selectionSet")]);
                    case "SelectionSet": return Ol(["{", Il(Ol([Nl, _l(Nl, e.call((e => Ul(e, t, n)), "selections"))])), Nl, "}"]);
                    case "Field": return Rl(Ol([r.alias ? Ol([e.call(n, "alias"), ": "]) : "", e.call(n, "name"), r.arguments.length > 0 ? Rl(Ol(["(", Il(Ol([Ml, _l(Ol([jl("", ", "), Ml]), e.call((e => Ul(e, t, n)), "arguments"))])), Ml, ")"])) : "", $l(e, n, r), r.selectionSet ? " " : "", e.call(n, "selectionSet")]));
                    case "Name":
                    case "IntValue":
                    case "FloatValue":
                    case "EnumValue": return r.value;
                    case "StringValue": return r.block ? Ol(['"""', Nl, _l(Nl, r.value.replace(/"""/g, "\\$&").split("\n")), Nl, '"""']) : Ol(['"', r.value.replace(/["\\]/g, "\\$&").replace(/\n/g, "\\n"), '"']);
                    case "BooleanValue": return r.value ? "true" : "false";
                    case "NullValue": return "null";
                    case "Variable": return Ol(["$", e.call(n, "name")]);
                    case "ListValue": return Rl(Ol(["[", Il(Ol([Ml, _l(Ol([jl("", ", "), Ml]), e.map(n, "values"))])), Ml, "]"]));
                    case "ObjectValue": return Rl(Ol(["{", t.bracketSpacing && r.fields.length > 0 ? " " : "", Il(Ol([Ml, _l(Ol([jl("", ", "), Ml]), e.map(n, "fields"))])), Ml, jl("", t.bracketSpacing && r.fields.length > 0 ? " " : ""), "}"]));
                    case "ObjectField":
                    case "Argument": return Ol([e.call(n, "name"), ": ", e.call(n, "value")]);
                    case "Directive": return Ol(["@", e.call(n, "name"), r.arguments.length > 0 ? Rl(Ol(["(", Il(Ol([Ml, _l(Ol([jl("", ", "), Ml]), e.call((e => Ul(e, t, n)), "arguments"))])), Ml, ")"])) : ""]);
                    case "NamedType": return e.call(n, "name");
                    case "VariableDefinition": return Ol([e.call(n, "variable"), ": ", e.call(n, "type"), r.defaultValue ? Ol([" = ", e.call(n, "defaultValue")]) : "", $l(e, n, r)]);
                    case "TypeExtensionDefinition": return Ol(["extend ", e.call(n, "definition")]);
                    case "ObjectTypeExtension":
                    case "ObjectTypeDefinition": return Ol([e.call(n, "description"), r.description ? Nl : "", "ObjectTypeExtension" === r.kind ? "extend " : "", "type ", e.call(n, "name"), r.interfaces.length > 0 ? Ol([" implements ", Ol(Wl(e, t, n))]) : "", $l(e, n, r), r.fields.length > 0 ? Ol([" {", Il(Ol([Nl, _l(Nl, e.call((e => Ul(e, t, n)), "fields"))])), Nl, "}"]) : ""]);
                    case "FieldDefinition": return Ol([e.call(n, "description"), r.description ? Nl : "", e.call(n, "name"), r.arguments.length > 0 ? Rl(Ol(["(", Il(Ol([Ml, _l(Ol([jl("", ", "), Ml]), e.call((e => Ul(e, t, n)), "arguments"))])), Ml, ")"])) : "", ": ", e.call(n, "type"), $l(e, n, r)]);
                    case "DirectiveDefinition": return Ol([e.call(n, "description"), r.description ? Nl : "", "directive ", "@", e.call(n, "name"), r.arguments.length > 0 ? Rl(Ol(["(", Il(Ol([Ml, _l(Ol([jl("", ", "), Ml]), e.call((e => Ul(e, t, n)), "arguments"))])), Ml, ")"])) : "", r.repeatable ? " repeatable" : "", Ol([" on ", _l(" | ", e.map(n, "locations"))])]);
                    case "EnumTypeExtension":
                    case "EnumTypeDefinition": return Ol([e.call(n, "description"), r.description ? Nl : "", "EnumTypeExtension" === r.kind ? "extend " : "", "enum ", e.call(n, "name"), $l(e, n, r), r.values.length > 0 ? Ol([" {", Il(Ol([Nl, _l(Nl, e.call((e => Ul(e, t, n)), "values"))])), Nl, "}"]) : ""]);
                    case "EnumValueDefinition": return Ol([e.call(n, "description"), r.description ? Nl : "", e.call(n, "name"), $l(e, n, r)]);
                    case "InputValueDefinition": return Ol([e.call(n, "description"), r.description ? r.description.block ? Nl : Pl : "", e.call(n, "name"), ": ", e.call(n, "type"), r.defaultValue ? Ol([" = ", e.call(n, "defaultValue")]) : "", $l(e, n, r)]);
                    case "InputObjectTypeExtension":
                    case "InputObjectTypeDefinition": return Ol([e.call(n, "description"), r.description ? Nl : "", "InputObjectTypeExtension" === r.kind ? "extend " : "", "input ", e.call(n, "name"), $l(e, n, r), r.fields.length > 0 ? Ol([" {", Il(Ol([Nl, _l(Nl, e.call((e => Ul(e, t, n)), "fields"))])), Nl, "}"]) : ""]);
                    case "SchemaDefinition": return Ol(["schema", $l(e, n, r), " {", r.operationTypes.length > 0 ? Il(Ol([Nl, _l(Nl, e.call((e => Ul(e, t, n)), "operationTypes"))])) : "", Nl, "}"]);
                    case "OperationTypeDefinition": return Ol([e.call(n, "operation"), ": ", e.call(n, "type")]);
                    case "InterfaceTypeExtension":
                    case "InterfaceTypeDefinition": return Ol([e.call(n, "description"), r.description ? Nl : "", "InterfaceTypeExtension" === r.kind ? "extend " : "", "interface ", e.call(n, "name"), $l(e, n, r), r.fields.length > 0 ? Ol([" {", Il(Ol([Nl, _l(Nl, e.call((e => Ul(e, t, n)), "fields"))])), Nl, "}"]) : ""]);
                    case "FragmentSpread": return Ol(["...", e.call(n, "name"), $l(e, n, r)]);
                    case "InlineFragment": return Ol(["...", r.typeCondition ? Ol([" on ", e.call(n, "typeCondition")]) : "", $l(e, n, r), " ", e.call(n, "selectionSet")]);
                    case "UnionTypeExtension":
                    case "UnionTypeDefinition": return Rl(Ol([e.call(n, "description"), r.description ? Nl : "", Rl(Ol(["UnionTypeExtension" === r.kind ? "extend " : "", "union ", e.call(n, "name"), $l(e, n, r), r.types.length > 0 ? Ol([" =", jl("", " "), Il(Ol([jl(Ol([Pl, "  "])), _l(Ol([Pl, "| "]), e.map(n, "types"))]))]) : ""]))]));
                    case "ScalarTypeExtension":
                    case "ScalarTypeDefinition": return Ol([e.call(n, "description"), r.description ? Nl : "", "ScalarTypeExtension" === r.kind ? "extend " : "", "scalar ", e.call(n, "name"), $l(e, n, r)]);
                    case "NonNullType": return Ol([e.call(n, "type"), "!"]);
                    case "ListType": return Ol(["[", e.call(n, "type"), "]"]);
                    default: throw new Error("unknown graphql type: " + JSON.stringify(r.kind));
                } }, massageAstNode: function (e, t) { delete t.loc, delete t.comments; }, hasPrettierIgnore: Bl, insertPragma: ql, printComment: function (e) { const t = e.getValue(); if ("Comment" === t.kind)
                    return "#" + t.value.trimEnd(); throw new Error("Not a comment: " + JSON.stringify(t)); }, canAttachComment: function (e) { return e.kind && "Comment" !== e.kind; } }, zl = { bracketSpacing: Kc.bracketSpacing }, Hl = "GraphQL", Yl = "data", Jl = [".graphql", ".gql", ".graphqls"], Gl = "source.graphql", Xl = "text", Ql = { name: Hl, type: Yl, extensions: Jl, tmScope: Gl, aceMode: Xl, languageId: 139 }, Zl = { languages: [Hc(at(Object.freeze({ __proto__: null, name: Hl, type: Yl, extensions: Jl, tmScope: Gl, aceMode: Xl, languageId: 139, default: Ql })), (() => ({ since: "1.5.0", parsers: ["graphql"], vscodeLanguageIds: ["graphql"] })))], options: zl, printers: { graphql: Kl } }; function ep(e, t) { return e && t.some((t => e.type === t)); } function tp(e, t) { const n = e.getValue(), r = e.getParentNode(0) || {}, o = r.children || r.body || [], i = o.indexOf(n); return -1 !== i && o[i + t]; } function np(e, t = 1) { return tp(e, -t); } function rp(e) { return tp(e, 1); } function op(e) { return ep(e, ["MustacheCommentStatement"]) && "string" == typeof e.value && "prettier-ignore" === e.value.trim(); } var ip = { getNextNode: rp, getPreviousNode: np, hasPrettierIgnore: function (e) { const t = e.getValue(), n = np(e, 2); return op(t) || op(n); }, isGlimmerComponent: function (e) { return ep(e, ["ElementNode"]) && "string" == typeof e.tag && ((t = e.tag[0]).toUpperCase() === t || e.tag.includes(".")); var t; }, isNextNodeOfSomeType: function (e, t) { return ep(rp(e), t); }, isNodeOfSomeType: ep, isParentOfSomeType: function (e, t) { return ep(e.getParentNode(0), t); }, isPreviousNodeOfSomeType: function (e, t) { return ep(np(e), t); }, isWhitespaceNode: function (e) { return ep(e, ["TextNode"]) && !/\S/.test(e.chars); } }; const { concat: sp, join: ap, softline: up, hardline: cp, line: lp, group: pp, indent: fp, ifBreak: dp } = Ps.builders, { getNextNode: hp, getPreviousNode: mp, hasPrettierIgnore: gp, isGlimmerComponent: yp, isNextNodeOfSomeType: vp, isParentOfSomeType: bp, isPreviousNodeOfSomeType: Dp, isWhitespaceNode: Ep } = ip, Cp = ["area", "base", "br", "col", "embed", "hr", "img", "input", "link", "meta", "param", "source", "track", "wbr"]; function wp(e, t, n) { return sp(e.map(((r, o) => { const i = e.getValue(), s = 0 === o, a = o === e.getParentNode(0).children.length - 1 && !s; return Ep(i) && a ? n(r, t, n) : s ? sp([up, n(r, t, n)]) : n(r, t, n); }), "children")); } function Ap(e, t) { const n = { quote: '"', regex: /"/g }, r = { quote: "'", regex: /'/g }, o = t.singleQuote ? r : n, i = o === r ? n : r; let s = !1; (e.includes(o.quote) || e.includes(i.quote)) && (s = (e.match(o.regex) || []).length > (e.match(i.regex) || []).length); const a = s ? i : o, u = e.replace(a.regex, "\\".concat(a.quote)); return sp([a.quote, u, a.quote]); } function Sp(e, t) { return e.call(t, "path"); } function xp(e, t) { const n = e.getValue(); let r = []; return n.params.length > 0 && (r = r.concat(e.map(t, "params"))), n.hash && n.hash.pairs.length > 0 && r.push(e.call(t, "hash")), r; } function Tp(e, t) { const n = [Sp(e, t), ...xp(e, t)]; return fp(pp(ap(lp, n))); } function kp(e) { const t = e.getValue(); return t.program && t.program.blockParams.length ? sp([" as |", t.program.blockParams.join(" "), "|"]) : ""; } function Fp(e, t, { open: n = !1, close: r = !1 } = {}) { return pp(sp([n ? "{{~#" : "{{#", Tp(e, t), kp(e), up, r ? "~}}" : "}}"])); } function Op(e, t, { open: n = !1, close: r = !1 } = {}) { return sp([n ? "{{~/" : "{{/", e.call(t, "path"), r ? "~}}" : "}}"]); } function _p(e) { return (e = "string" == typeof e ? e : "").split("\n").length - 1; } function Np(e = 0, t = 0) { return new Array(Math.min(e, t)).fill(cp); } function Pp(e, t, n) { let r = 0, o = 0; for (;;) {
                if (o === e.length)
                    return null;
                let i = e.indexOf("\n", o);
                if (-1 === i && (i = e.length), r === t)
                    return o + n > i ? null : o + n;
                if (-1 === i)
                    return null;
                r += 1, o = i + 1;
            } } var Mp = { print: function (e, t, n) { const r = e.getValue(); if (!r)
                    return ""; if (gp(e)) {
                    const e = Pp(t.originalText, r.loc.start.line - 1, r.loc.start.column), n = Pp(t.originalText, r.loc.end.line - 1, r.loc.end.column);
                    return t.originalText.slice(e, n);
                } switch (r.type) {
                    case "Block":
                    case "Program":
                    case "Template": return pp(sp(e.map(n, "body")));
                    case "ElementNode": {
                        const o = r.children.length > 0, i = r.children.some((e => !Ep(e))), s = yp(r) && (!o || !i) || Cp.includes(r.tag), a = s ? sp([" />", up]) : ">", u = s ? "/>" : ">", c = (e, t) => fp(sp([r.attributes.length ? lp : "", ap(lp, e.map(t, "attributes")), r.modifiers.length ? lp : "", ap(lp, e.map(t, "modifiers")), r.comments.length ? lp : "", ap(lp, e.map(t, "comments"))])), l = hp(e);
                        return sp([pp(sp(["<", r.tag, c(e, n), r.blockParams.length ? " as |".concat(r.blockParams.join(" "), "|") : "", dp(up, ""), dp(u, a)])), s ? "" : pp(sp([i ? fp(wp(e, t, n)) : "", dp(o ? cp : "", ""), sp(["</", r.tag, ">"])])), l && "ElementNode" === l.type ? cp : ""]);
                    }
                    case "BlockStatement": {
                        const t = e.getParentNode(1), o = t && t.inverse && 1 === t.inverse.body.length && t.inverse.body[0] === r && "if" === t.inverse.body[0].path.parts[0], i = r.inverse && 1 === r.inverse.body.length && "BlockStatement" === r.inverse.body[0].type && "if" === r.inverse.body[0].path.parts[0], s = i ? e => e : fp, a = (r.inverseStrip.open ? "{{~" : "{{") + "else" + (r.inverseStrip.close ? "~}}" : "}}");
                        if (r.inverse)
                            return sp([o ? sp([r.openStrip.open ? "{{~else " : "{{else ", Tp(e, n), r.openStrip.close ? "~}}" : "}}"]) : Fp(e, n, r.openStrip), fp(sp([cp, e.call(n, "program")])), r.inverse && !i ? sp([cp, a]) : "", r.inverse ? s(sp([cp, e.call(n, "inverse")])) : "", o ? "" : sp([cp, Op(e, n, r.closeStrip)])]);
                        if (o)
                            return sp([sp([r.openStrip.open ? "{{~else" : "{{else ", Tp(e, n), r.openStrip.close ? "~}}" : "}}"]), fp(sp([cp, e.call(n, "program")]))]);
                        const u = r.program.body.some((e => !Ep(e)));
                        return sp([Fp(e, n, r.openStrip), pp(sp([fp(sp([up, e.call(n, "program")])), u ? cp : up, Op(e, n, r.closeStrip)]))]);
                    }
                    case "ElementModifierStatement": return pp(sp(["{{", Tp(e, n), up, "}}"]));
                    case "MustacheStatement": {
                        const t = !1 === r.escaped, { open: o, close: i } = r.strip, s = (t ? "{{{" : "{{") + (o ? "~" : ""), a = (i ? "~" : "") + (t ? "}}}" : "}}"), u = bp(e, ["AttrNode", "ConcatStatement", "ElementNode"]) ? [s, fp(up)] : [s];
                        return pp(sp([...u, Tp(e, n), up, a]));
                    }
                    case "SubExpression": {
                        const t = xp(e, n), r = t.length > 0 ? fp(sp([lp, pp(ap(lp, t))])) : "";
                        return pp(sp(["(", Sp(e, n), r, up, ")"]));
                    }
                    case "AttrNode": {
                        const o = "TextNode" === r.value.type;
                        if (o && "" === r.value.chars && r.value.loc.start.column === r.value.loc.end.column)
                            return sp([r.name]);
                        const i = e.call(n, "value"), s = o ? Ap(i.parts.join(), t) : i;
                        return sp([r.name, "=", s]);
                    }
                    case "ConcatStatement": return sp(['"', sp(e.map((e => n(e)), "parts").filter((e => "" !== e))), '"']);
                    case "Hash": return sp([ap(lp, e.map(n, "pairs"))]);
                    case "HashPair": return sp([r.key, "=", e.call(n, "value")]);
                    case "TextNode": {
                        const t = 2, n = !mp(e), i = !hp(e), s = !/\S/.test(r.chars), a = _p(r.chars), u = "Block" === e.getParentNode(0).type, c = "ElementNode" === e.getParentNode(0).type, l = "Template" === e.getParentNode(0).type;
                        let p = _p(((o = "string" == typeof (o = r.chars) ? o : "").match(/^([^\S\r\n]*[\r\n])+/g) || [])[0] || ""), f = function (e) { return _p(((e = "string" == typeof e ? e : "").match(/([\r\n][^\S\r\n]*)+$/g) || [])[0] || ""); }(r.chars);
                        if ((n || i) && s && (u || c || l))
                            return "";
                        s && a ? (p = Math.min(a, t), f = 0) : (vp(e, ["BlockStatement", "ElementNode"]) && (f = Math.max(f, 1)), (Dp(e, ["ElementNode"]) || Dp(e, ["BlockStatement"])) && (p = Math.max(p, 1)));
                        let d = "", h = "";
                        if (e.stack.includes("attributes")) {
                            const t = e.getParentNode(0);
                            if ("ConcatStatement" === t.type) {
                                const { parts: e } = t, n = e.indexOf(r);
                                n > 0 && "MustacheStatement" === e[n - 1].type && (d = " "), n < e.length - 1 && "MustacheStatement" === e[n + 1].type && (h = " ");
                            }
                        }
                        else
                            0 === f && vp(e, ["MustacheStatement"]) && (h = " "), 0 === p && Dp(e, ["MustacheStatement"]) && (d = " "), n && (p = 0, d = ""), i && (f = 0, h = "");
                        return sp([...Np(p, t), r.chars.replace(/^[\s ]+/g, d).replace(/[\s ]+$/, h), ...Np(f, t)].filter(Boolean));
                    }
                    case "MustacheCommentStatement": {
                        const e = r.value.includes("}}") ? "--" : "";
                        return sp(["{{!", e, r.value, e, "}}"]);
                    }
                    case "PathExpression": return r.original;
                    case "BooleanLiteral":
                    case "NumberLiteral": return String(r.value);
                    case "CommentStatement": return sp(["\x3c!--", r.value, "--\x3e"]);
                    case "StringLiteral": return Ap(r.value, t);
                    case "UndefinedLiteral": return "undefined";
                    case "NullLiteral": return "null";
                    default: throw new Error("unknown glimmer type: " + JSON.stringify(r.type));
                } var o; }, massageAstNode: function (e, t) { if (delete t.loc, delete t.selfClosing, "TextNode" === e.type) {
                    const n = e.chars.trim();
                    if (!n)
                        return null;
                    t.chars = n;
                } } }, Rp = "Handlebars", Ip = "markup", jp = "HTML", Bp = ["hbs", "htmlbars"], Lp = [".handlebars", ".hbs"], qp = "text.html.handlebars", $p = "handlebars", Up = { name: Rp, type: Ip, group: jp, aliases: Bp, extensions: Lp, tmScope: qp, aceMode: $p, languageId: 155 }, Vp = { languages: [Hc(at(Object.freeze({ __proto__: null, name: Rp, type: Ip, group: jp, aliases: Bp, extensions: Lp, tmScope: qp, aceMode: $p, languageId: 155, default: Up })), (() => ({ since: null, parsers: ["glimmer"], vscodeLanguageIds: ["handlebars"] })))], printers: { glimmer: Mp } }, Wp = Object.freeze({ __proto__: null, default: ["a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "bgsound", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "command", "content", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "image", "img", "input", "ins", "isindex", "kbd", "keygen", "label", "legend", "li", "link", "listing", "main", "map", "mark", "marquee", "math", "menu", "menuitem", "meta", "meter", "multicol", "nav", "nextid", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "plaintext", "pre", "progress", "q", "rb", "rbc", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr", "xmp"] }), Kp = ["accesskey", "charset", "coords", "download", "href", "hreflang", "name", "ping", "referrerpolicy", "rel", "rev", "shape", "tabindex", "target", "type"], zp = ["title"], Hp = ["align", "alt", "archive", "code", "codebase", "height", "hspace", "name", "object", "vspace", "width"], Yp = ["accesskey", "alt", "coords", "download", "href", "hreflang", "nohref", "ping", "referrerpolicy", "rel", "shape", "tabindex", "target", "type"], Jp = ["autoplay", "controls", "crossorigin", "loop", "muted", "preload", "src"], Gp = ["href", "target"], Xp = ["color", "face", "size"], Qp = ["dir"], Zp = ["cite"], ef = ["alink", "background", "bgcolor", "link", "text", "vlink"], tf = ["clear"], nf = ["accesskey", "autofocus", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "name", "tabindex", "type", "value"], rf = ["height", "width"], of = ["align"], sf = ["align", "char", "charoff", "span", "valign", "width"], af = ["align", "char", "charoff", "span", "valign", "width"], uf = ["value"], cf = ["cite", "datetime"], lf = ["open"], pf = ["title"], ff = ["open"], df = ["compact"], hf = ["align"], mf = ["compact"], gf = ["height", "src", "type", "width"], yf = ["disabled", "form", "name"], vf = ["color", "face", "size"], bf = ["accept", "accept-charset", "action", "autocomplete", "enctype", "method", "name", "novalidate", "target"], Df = ["frameborder", "longdesc", "marginheight", "marginwidth", "name", "noresize", "scrolling", "src"], Ef = ["cols", "rows"], Cf = ["align"], wf = ["align"], Af = ["align"], Sf = ["align"], xf = ["align"], Tf = ["align"], kf = ["profile"], Ff = ["align", "noshade", "size", "width"], Of = ["manifest", "version"], _f = ["align", "allow", "allowfullscreen", "allowpaymentrequest", "allowusermedia", "frameborder", "height", "longdesc", "marginheight", "marginwidth", "name", "referrerpolicy", "sandbox", "scrolling", "src", "srcdoc", "width"], Nf = ["align", "alt", "border", "crossorigin", "decoding", "height", "hspace", "ismap", "longdesc", "name", "referrerpolicy", "sizes", "src", "srcset", "usemap", "vspace", "width"], Pf = ["accept", "accesskey", "align", "alt", "autocomplete", "autofocus", "checked", "dirname", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "height", "ismap", "list", "max", "maxlength", "min", "minlength", "multiple", "name", "pattern", "placeholder", "readonly", "required", "size", "src", "step", "tabindex", "title", "type", "usemap", "value", "width"], Mf = ["cite", "datetime"], Rf = ["prompt"], If = ["accesskey", "for", "form"], jf = ["accesskey", "align"], Bf = ["type", "value"], Lf = ["as", "charset", "color", "crossorigin", "href", "hreflang", "imagesizes", "imagesrcset", "integrity", "media", "nonce", "referrerpolicy", "rel", "rev", "sizes", "target", "title", "type"], qf = ["name"], $f = ["compact"], Uf = ["charset", "content", "http-equiv", "name", "scheme"], Vf = ["high", "low", "max", "min", "optimum", "value"], Wf = ["align", "archive", "border", "classid", "codebase", "codetype", "data", "declare", "form", "height", "hspace", "name", "standby", "tabindex", "type", "typemustmatch", "usemap", "vspace", "width"], Kf = ["compact", "reversed", "start", "type"], zf = ["disabled", "label"], Hf = ["disabled", "label", "selected", "value"], Yf = ["for", "form", "name"], Jf = ["align"], Gf = ["name", "type", "value", "valuetype"], Xf = ["width"], Qf = ["max", "value"], Zf = ["cite"], ed = ["async", "charset", "crossorigin", "defer", "integrity", "language", "nomodule", "nonce", "referrerpolicy", "src", "type"], td = ["autocomplete", "autofocus", "disabled", "form", "multiple", "name", "required", "size", "tabindex"], nd = ["name"], rd = ["media", "sizes", "src", "srcset", "type"], od = ["media", "nonce", "title", "type"], id = ["align", "bgcolor", "border", "cellpadding", "cellspacing", "frame", "rules", "summary", "width"], sd = ["align", "char", "charoff", "valign"], ad = ["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"], ud = ["accesskey", "autocomplete", "autofocus", "cols", "dirname", "disabled", "form", "maxlength", "minlength", "name", "placeholder", "readonly", "required", "rows", "tabindex", "wrap"], cd = ["align", "char", "charoff", "valign"], ld = ["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"], pd = ["align", "char", "charoff", "valign"], fd = ["datetime"], dd = ["align", "bgcolor", "char", "charoff", "valign"], hd = ["default", "kind", "label", "src", "srclang"], md = ["compact", "type"], gd = ["autoplay", "controls", "crossorigin", "height", "loop", "muted", "playsinline", "poster", "preload", "src", "width"], yd = { "*": ["accesskey", "autocapitalize", "autofocus", "class", "contenteditable", "dir", "draggable", "enterkeyhint", "hidden", "id", "inputmode", "is", "itemid", "itemprop", "itemref", "itemscope", "itemtype", "lang", "nonce", "slot", "spellcheck", "style", "tabindex", "title", "translate"], a: Kp, abbr: zp, applet: Hp, area: Yp, audio: Jp, base: Gp, basefont: Xp, bdo: Qp, blockquote: Zp, body: ef, br: tf, button: nf, canvas: rf, caption: of, col: sf, colgroup: af, data: uf, del: cf, details: lf, dfn: pf, dialog: ff, dir: df, div: hf, dl: mf, embed: gf, fieldset: yf, font: vf, form: bf, frame: Df, frameset: Ef, h1: Cf, h2: wf, h3: Af, h4: Sf, h5: xf, h6: Tf, head: kf, hr: Ff, html: Of, iframe: _f, img: Nf, input: Pf, ins: Mf, isindex: Rf, label: If, legend: jf, li: Bf, link: Lf, map: qf, menu: $f, meta: Uf, meter: Vf, object: Wf, ol: Kf, optgroup: zf, option: Hf, output: Yf, p: Jf, param: Gf, pre: Xf, progress: Qf, q: Zf, script: ed, select: td, slot: nd, source: rd, style: od, table: id, tbody: sd, td: ad, textarea: ud, tfoot: cd, th: ld, thead: pd, time: fd, tr: dd, track: hd, ul: md, video: gd }, vd = Object.freeze({ __proto__: null, a: Kp, abbr: zp, applet: Hp, area: Yp, audio: Jp, base: Gp, basefont: Xp, bdo: Qp, blockquote: Zp, body: ef, br: tf, button: nf, canvas: rf, caption: of, col: sf, colgroup: af, data: uf, del: cf, details: lf, dfn: pf, dialog: ff, dir: df, div: hf, dl: mf, embed: gf, fieldset: yf, font: vf, form: bf, frame: Df, frameset: Ef, h1: Cf, h2: wf, h3: Af, h4: Sf, h5: xf, h6: Tf, head: kf, hr: Ff, html: Of, iframe: _f, img: Nf, input: Pf, ins: Mf, isindex: Rf, label: If, legend: jf, li: Bf, link: Lf, map: qf, menu: $f, meta: Uf, meter: Vf, object: Wf, ol: Kf, optgroup: zf, option: Hf, output: Yf, p: Jf, param: Gf, pre: Xf, progress: Qf, q: Zf, script: ed, select: td, slot: nd, source: rd, style: od, table: id, tbody: sd, td: ad, textarea: ud, tfoot: cd, th: ld, thead: pd, time: fd, tr: dd, track: hd, ul: md, video: gd, default: yd }), bd = at(Wp), Dd = at(vd); const { CSS_DISPLAY_TAGS: Ed, CSS_DISPLAY_DEFAULT: Cd, CSS_WHITE_SPACE_TAGS: wd, CSS_WHITE_SPACE_DEFAULT: Ad } = { CSS_DISPLAY_TAGS: { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "none", rp: "none", script: "block", source: "block", style: "none", template: "inline", track: "block", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", fieldset: "block", button: "inline-block", video: "inline-block", audio: "inline-block" }, CSS_DISPLAY_DEFAULT: "inline", CSS_WHITE_SPACE_TAGS: { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" }, CSS_WHITE_SPACE_DEFAULT: "normal" }, Sd = xd(bd); function xd(e) { const t = Object.create(null); for (const n of e)
                t[n] = !0; return t; } function Td(e, t) { return !(!e.endSourceSpan || ("element" !== e.type || "template" !== e.fullName || !e.attrMap.lang || "html" === e.attrMap.lang) && ("ieConditionalComment" !== e.type || !e.lastChild || e.lastChild.isSelfClosing || e.lastChild.endSourceSpan) && ("ieConditionalComment" !== e.type || e.complete) && ("vue" !== t.parser || "element" !== e.type || "root" !== e.parent.type || ["template", "style", "script", "html"].includes(e.fullName)) && (!Ld(e) || !e.children.some((e => "text" !== e.type && "interpolation" !== e.type)))); } function kd(e) { return "attribute" !== e.type && !!e.parent && "number" == typeof e.index && 0 !== e.index && function (e) { return "comment" === e.type && "prettier-ignore" === e.value.trim(); }(e.parent.children[e.index - 1]); } function Fd(e) { return "element" === e.type && ("script" === e.fullName || "style" === e.fullName || "svg:style" === e.fullName || qd(e) && ("script" === e.name || "style" === e.name)); } function Od(e) { return "yaml" === e.type || "toml" === e.type; } function _d(e) { return $d(e).startsWith("pre"); } function Nd(e) { return "element" === e.type && 0 !== e.children.length && (["html", "head", "ul", "ol", "select"].includes(e.name) || e.cssDisplay.startsWith("table") && "table-cell" !== e.cssDisplay); } function Pd(e) { return jd(e) || "element" === e.type && "br" === e.fullName || Md(e); } function Md(e) { return Rd(e) && Id(e); } function Rd(e) { return e.hasLeadingSpaces && (e.prev ? e.prev.sourceSpan.end.line < e.sourceSpan.start.line : "root" === e.parent.type || e.parent.startSourceSpan.end.line < e.sourceSpan.start.line); } function Id(e) { return e.hasTrailingSpaces && (e.next ? e.next.sourceSpan.start.line > e.sourceSpan.end.line : "root" === e.parent.type || e.parent.endSourceSpan && e.parent.endSourceSpan.start.line > e.sourceSpan.end.line); } function jd(e) { switch (e.type) {
                case "ieConditionalComment":
                case "comment":
                case "directive": return !0;
                case "element": return ["script", "select"].includes(e.name);
            } return !1; } function Bd(e) { return "block" === e || "list-item" === e || e.startsWith("table"); } function Ld(e) { return $d(e).startsWith("pre"); } function qd(e) { return "element" === e.type && !e.hasExplicitNamespace && !["html", "svg"].includes(e.namespace); } function $d(e) { return "element" === e.type && (!e.namespace || qd(e)) && wd[e.name] || Ad; } var Ud = { HTML_ELEMENT_ATTRIBUTES: function (e, t) { const n = Object.create(null); for (const r of Object.keys(e))
                    n[r] = t(e[r], r); return n; }(Dd, xd), HTML_TAGS: Sd, canHaveInterpolation: function (e) { return e.children && !Fd(e); }, countChars: function (e, t) { let n = 0; for (let r = 0; r < e.length; r++)
                    e[r] === t && n++; return n; }, countParents: function (e, t = (() => !0)) { let n = 0; for (let r = e.stack.length - 1; r >= 0; r--) {
                    const o = e.stack[r];
                    o && "object" == typeof o && !Array.isArray(o) && t(o) && n++;
                } return n; }, dedentString: function (e, t = function (e) { let t = 1 / 0; for (const n of e.split("\n")) {
                    if (0 === n.length)
                        continue;
                    if (/\S/.test(n[0]))
                        return 0;
                    const e = n.match(/^\s*/)[0].length;
                    n.length !== e && e < t && (t = e);
                } return t === 1 / 0 ? 0 : t; }(e)) { return 0 === t ? e : e.split("\n").map((e => e.slice(t))).join("\n"); }, forceBreakChildren: Nd, forceBreakContent: function (e) { return Nd(e) || "element" === e.type && 0 !== e.children.length && (["body", "script", "style"].includes(e.name) || e.children.some((e => function (e) { return e.children && e.children.some((e => "text" !== e.type)); }(e)))) || e.firstChild && e.firstChild === e.lastChild && Rd(e.firstChild) && (!e.lastChild.isTrailingSpaceSensitive || Id(e.lastChild)); }, forceNextEmptyLine: function (e) { return Od(e) || e.next && e.sourceSpan.end.line + 1 < e.next.sourceSpan.start.line; }, getLastDescendant: function e(t) { return t.lastChild ? e(t.lastChild) : t; }, getNodeCssStyleDisplay: function (e, t) { if (e.prev && "comment" === e.prev.type) {
                    const t = e.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
                    if (t)
                        return t[1];
                } let n = !1; if ("element" === e.type && "svg" === e.namespace) {
                    if (!function (e, t) { let n = e; for (; n;) {
                        if ("svg:foreignObject" === n.fullName)
                            return !0;
                        n = n.parent;
                    } return !1; }(e))
                        return "svg" === e.name ? "inline-block" : "block";
                    n = !0;
                } switch (t.htmlWhitespaceSensitivity) {
                    case "strict": return "inline";
                    case "ignore": return "block";
                    default: return "element" === e.type && (!e.namespace || n || qd(e)) && Ed[e.name] || Cd;
                } }, getNodeCssStyleWhiteSpace: $d, getPrettierIgnoreAttributeCommentData: function (e) { const t = e.trim().match(/^prettier-ignore-attribute(?:\s+([^]+))?$/); return !!t && (!t[1] || t[1].split(/\s+/)); }, hasPrettierIgnore: kd, identity: function (e) { return e; }, inferScriptParser: function (e) { if ("script" === e.name && !e.attrMap.src) {
                    if (!e.attrMap.lang && !e.attrMap.type || "module" === e.attrMap.type || "text/javascript" === e.attrMap.type || "text/babel" === e.attrMap.type || "application/javascript" === e.attrMap.type || "jsx" === e.attrMap.lang)
                        return "babel";
                    if ("application/x-typescript" === e.attrMap.type || "ts" === e.attrMap.lang || "tsx" === e.attrMap.lang)
                        return "typescript";
                    if ("text/markdown" === e.attrMap.type)
                        return "markdown";
                    if (e.attrMap.type.endsWith("json") || e.attrMap.type.endsWith("importmap"))
                        return "json";
                    if ("text/x-handlebars-template" === e.attrMap.type)
                        return "glimmer";
                } if ("style" === e.name) {
                    if (!e.attrMap.lang || "postcss" === e.attrMap.lang || "css" === e.attrMap.lang)
                        return "css";
                    if ("scss" === e.attrMap.lang)
                        return "scss";
                    if ("less" === e.attrMap.lang)
                        return "less";
                } return null; }, isDanglingSpaceSensitiveNode: function (e) { return !(Bd(t = e.cssDisplay) || "inline-block" === t || Fd(e)); var t; }, isFrontMatterNode: Od, isIndentationSensitiveNode: _d, isLeadingSpaceSensitiveNode: function (e) { const t = !(Od(e) || ("text" !== e.type && "interpolation" !== e.type || !e.prev || "text" !== e.prev.type && "interpolation" !== e.prev.type) && (!e.parent || "none" === e.parent.cssDisplay || !Ld(e.parent) && (!e.prev && ("root" === e.parent.type || Ld(e) && e.parent || Fd(e.parent) || (n = e.parent.cssDisplay, Bd(n) || "inline-block" === n)) || e.prev && !function (e) { return !Bd(e); }(e.prev.cssDisplay)))); var n; return t && !e.prev && e.parent && e.parent.tagDefinition && e.parent.tagDefinition.ignoreFirstLf ? "interpolation" === e.type : t; }, isPreLikeNode: Ld, isScriptLikeTag: Fd, isTextLikeNode: function (e) { return "text" === e.type || "comment" === e.type; }, isTrailingSpaceSensitiveNode: function (e) { return !(Od(e) || ("text" !== e.type && "interpolation" !== e.type || !e.next || "text" !== e.next.type && "interpolation" !== e.next.type) && (!e.parent || "none" === e.parent.cssDisplay || !Ld(e.parent) && (!e.next && ("root" === e.parent.type || Ld(e) && e.parent || Fd(e.parent) || (t = e.parent.cssDisplay, Bd(t) || "inline-block" === t)) || e.next && !function (e) { return !Bd(e); }(e.next.cssDisplay)))); var t; }, isWhitespaceSensitiveNode: function (e) { return Fd(e) || "interpolation" === e.type || _d(e); }, isUnknownNamespace: qd, normalizeParts: function (e) { const t = [], n = e.slice(); for (; 0 !== n.length;) {
                    const e = n.shift();
                    e && ("concat" !== e.type ? 0 === t.length || "string" != typeof t[t.length - 1] || "string" != typeof e ? t.push(e) : t.push(t.pop() + e) : n.unshift(...e.parts));
                } return t; }, preferHardlineAsLeadingSpaces: function (e) { return jd(e) || e.prev && Pd(e.prev) || Md(e); }, preferHardlineAsTrailingSpaces: Pd, shouldNotPrintClosingTag: function (e, t) { return !e.isSelfClosing && !e.endSourceSpan && (kd(e) || Td(e.parent, t)); }, shouldPreserveContent: Td, unescapeQuoteEntities: function (e) { return e.replace(/&apos;/g, "'").replace(/&quot;/g, '"'); } }; const { canHaveInterpolation: Vd, getNodeCssStyleDisplay: Wd, isDanglingSpaceSensitiveNode: Kd, isIndentationSensitiveNode: zd, isLeadingSpaceSensitiveNode: Hd, isTrailingSpaceSensitiveNode: Yd, isWhitespaceSensitiveNode: Jd } = Ud, Gd = [function (e) { return e.map((e => { if ("element" === e.type && e.tagDefinition.ignoreFirstLf && 0 !== e.children.length && "text" === e.children[0].type && "\n" === e.children[0].value[0]) {
                    const [t, ...n] = e.children;
                    return e.clone({ children: 1 === t.value.length ? n : [t.clone({ value: t.value.slice(1) }), ...n] });
                } return e; })); }, function (e) { const t = e => "element" === e.type && e.prev && "ieConditionalStartComment" === e.prev.type && e.prev.sourceSpan.end.offset === e.startSourceSpan.start.offset && e.firstChild && "ieConditionalEndComment" === e.firstChild.type && e.firstChild.sourceSpan.start.offset === e.startSourceSpan.end.offset; return e.map((e => { if (e.children) {
                    const n = e.children.map(t);
                    if (n.some(Boolean)) {
                        const t = [];
                        for (let r = 0; r < e.children.length; r++) {
                            const o = e.children[r];
                            if (!n[r + 1])
                                if (n[r]) {
                                    const e = o.prev, n = o.firstChild, r = o.sourceSpan.constructor, i = new r(e.sourceSpan.start, n.sourceSpan.end), s = new r(i.start, o.sourceSpan.end);
                                    t.push(o.clone({ condition: e.condition, sourceSpan: s, startSourceSpan: i, children: o.children.slice(1) }));
                                }
                                else
                                    t.push(o);
                        }
                        return e.clone({ children: t });
                    }
                } return e; })); }, function (e) { return function (e, t, n) { return e.map((e => { if (e.children) {
                    const r = e.children.map(t);
                    if (r.some(Boolean)) {
                        const t = [];
                        for (let o = 0; o < e.children.length; o++) {
                            const i = e.children[o];
                            if ("text" !== i.type && !r[o]) {
                                t.push(i);
                                continue;
                            }
                            const s = "text" === i.type ? i : i.clone({ type: "text", value: n(i) });
                            if (0 === t.length || "text" !== t[t.length - 1].type) {
                                t.push(s);
                                continue;
                            }
                            const a = t.pop(), u = a.sourceSpan.constructor;
                            t.push(a.clone({ value: a.value + s.value, sourceSpan: new u(a.sourceSpan.start, s.sourceSpan.end) }));
                        }
                        return e.clone({ children: t });
                    }
                } return e; })); }(e, (e => "cdata" === e.type), (e => "<![CDATA[".concat(e.value, "]]>"))); }, function (e, t) { if ("html" === t.parser)
                    return e; const n = /\{\{([\s\S]+?)\}\}/g; return e.map((e => { if (!Vd(e))
                    return e; const t = []; for (const r of e.children) {
                    if ("text" !== r.type) {
                        t.push(r);
                        continue;
                    }
                    const e = r.sourceSpan.constructor;
                    let o = r.sourceSpan.start, i = null;
                    const s = r.value.split(n);
                    for (let n = 0; n < s.length; n++, o = i) {
                        const r = s[n];
                        n % 2 != 0 ? (i = o.moveBy(r.length + 4), t.push({ type: "interpolation", sourceSpan: new e(o, i), children: 0 === r.length ? [] : [{ type: "text", value: r, sourceSpan: new e(o.moveBy(2), i.moveBy(-2)) }] })) : (i = o.moveBy(r.length), 0 !== r.length && t.push({ type: "text", value: r, sourceSpan: new e(o, i) }));
                    }
                } return e.clone({ children: t }); })); }, function (e) { const t = "whitespace"; return e.map((e => { if (!e.children)
                    return e; if (0 === e.children.length || 1 === e.children.length && "text" === e.children[0].type && 0 === e.children[0].value.trim().length)
                    return e.clone({ children: [], hasDanglingSpaces: 0 !== e.children.length }); const n = Jd(e), r = zd(e); return e.clone({ isWhitespaceSensitive: n, isIndentationSensitive: r, children: e.children.reduce(((e, r) => { if ("text" !== r.type || n)
                        return e.concat(r); const o = [], [, i, s, a] = r.value.match(/^(\s*)([\s\S]*?)(\s*)$/); i && o.push({ type: t }); const u = r.sourceSpan.constructor; return s && o.push({ type: "text", value: s, sourceSpan: new u(r.sourceSpan.start.moveBy(i.length), r.sourceSpan.end.moveBy(-a.length)) }), a && o.push({ type: t }), e.concat(o); }), []).reduce(((e, n, r, o) => { if (n.type === t)
                        return e; const i = 0 !== r && o[r - 1].type === t, s = r !== o.length - 1 && o[r + 1].type === t; return e.concat(Object.assign({}, n, { hasLeadingSpaces: i, hasTrailingSpaces: s })); }), []) }); })); }, function (e, t) { return e.map((e => Object.assign(e, { cssDisplay: Wd(e, t) }))); }, function (e) { return e.map((e => Object.assign(e, { isSelfClosing: !e.children || "element" === e.type && (e.tagDefinition.isVoid || e.startSourceSpan === e.endSourceSpan) }))); }, function (e, t) { return e.map((e => "element" !== e.type ? e : Object.assign(e, { hasHtmComponentClosingTag: e.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(t.originalText.slice(e.endSourceSpan.start.offset, e.endSourceSpan.end.offset)) }))); }, function (e) { return e.map((e => e.children ? 0 === e.children.length ? e.clone({ isDanglingSpaceSensitive: Kd(e) }) : e.clone({ children: e.children.map((e => Object.assign({}, e, { isLeadingSpaceSensitive: Hd(e), isTrailingSpaceSensitive: Yd(e) }))).map(((e, t, n) => Object.assign({}, e, { isLeadingSpaceSensitive: (0 === t || n[t - 1].isTrailingSpaceSensitive) && e.isLeadingSpaceSensitive, isTrailingSpaceSensitive: (t === n.length - 1 || n[t + 1].isLeadingSpaceSensitive) && e.isTrailingSpaceSensitive }))) }) : e)); }, function (e) { const t = e => "element" === e.type && 0 === e.attrs.length && 1 === e.children.length && "text" === e.firstChild.type && !/[^\S\xA0]/.test(e.children[0].value) && !e.firstChild.hasLeadingSpaces && !e.firstChild.hasTrailingSpaces && e.isLeadingSpaceSensitive && !e.hasLeadingSpaces && e.isTrailingSpaceSensitive && !e.hasTrailingSpaces && e.prev && "text" === e.prev.type && e.next && "text" === e.next.type; return e.map((e => { if (e.children) {
                    const n = e.children.map(t);
                    if (n.some(Boolean)) {
                        const t = [];
                        for (let r = 0; r < e.children.length; r++) {
                            const o = e.children[r];
                            if (n[r]) {
                                const n = t.pop(), i = e.children[++r], s = e.sourceSpan.constructor, { isTrailingSpaceSensitive: a, hasTrailingSpaces: u } = i;
                                t.push(n.clone({ value: n.value + "<".concat(o.rawName, ">") + o.firstChild.value + "</".concat(o.rawName, ">") + i.value, sourceSpan: new s(n.sourceSpan.start, i.sourceSpan.end), isTrailingSpaceSensitive: a, hasTrailingSpaces: u }));
                            }
                            else
                                t.push(o);
                        }
                        return e.clone({ children: t });
                    }
                } return e; })); }]; const { builders: { concat: Xd, group: Qd } } = Ps; var Zd = { isVueEventBindingExpression: function (e) { const t = e.trim(); return /^([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/.test(t) || /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/.test(t); }, printVueFor: function (e, t) { const { left: n, operator: r, right: o } = function (e) { const t = /,([^,}\]]*)(?:,([^,}\]]*))?$/, n = e.match(/([^]*?)\s+(in|of)\s+([^]*)/); if (!n)
                    return; const r = {}; r.for = n[3].trim(); const o = n[1].trim().replace(/^\(|\)$/g, ""), i = o.match(t); return i ? (r.alias = o.replace(t, ""), r.iterator1 = i[1].trim(), i[2] && (r.iterator2 = i[2].trim())) : r.alias = o, { left: "".concat([r.alias, r.iterator1, r.iterator2].filter(Boolean).join(",")), operator: n[2], right: r.for }; }(e); return Xd([Qd(t("function _(".concat(n, ") {}"), { parser: "babel", __isVueForBindingLeft: !0 })), " ", r, " ", t(o, { parser: "__js_expression" })]); }, printVueSlotScope: function (e, t) { return t("function _(".concat(e, ") {}"), { parser: "babel", __isVueSlotScope: !0 }); } }; const eh = /^\d+$/; const { builders: { concat: th, ifBreak: nh, join: rh, line: oh } } = Ps, ih = e => { return (t = e.split(",").map((e => { const t = {}; return e.trim().split(/\s+/).forEach(((e, n) => { if (0 === n)
                return void (t.url = e); const r = e.slice(0, e.length - 1), o = e[e.length - 1], i = parseInt(r, 10), s = parseFloat(r); if ("w" === o && eh.test(r))
                t.width = i;
            else if ("h" === o && eh.test(r))
                t.height = i;
            else {
                if ("x" !== o || Number.isNaN(s))
                    throw new Error("Invalid srcset descriptor: ".concat(e));
                t.density = s;
            } })), t; }))).sort().filter(((e, n) => JSON.stringify(e) !== JSON.stringify(t[n - 1]))); var t; }; var sh = { printImgSrcset: function (e) { const t = ih(e), n = t.some((e => e.width)), r = t.some((e => e.height)); if (n + r + t.some((e => e.density)) > 1)
                    throw new Error("Mixed descriptor in srcset is not supported"); const o = n ? "width" : r ? "height" : "density", i = n ? "w" : r ? "h" : "x", s = e => Math.max(...e), a = t.map((e => e.url)), u = s(a.map((e => e.length))), c = t.map((e => e[o])).map((e => e ? e.toString() : "")), l = c.map((e => { const t = e.indexOf("."); return -1 === t ? e.length : t; })), p = s(l); return rh(th([",", oh]), a.map(((e, t) => { const n = [e], r = c[t]; if (r) {
                    const o = u - e.length + 1, s = p - l[t], a = " ".repeat(o + s);
                    n.push(nh(a, " "), r + i);
                } return th(n); }))); }, printClassNames: function (e) { return e.trim().split(/\s+/).join(" "); } }; const { builders: ah, utils: { stripTrailingHardline: uh, mapDoc: ch } } = Ps, { breakParent: lh, dedentToRoot: ph, fill: fh, group: dh, hardline: hh, ifBreak: mh, indent: gh, join: yh, line: vh, literalline: bh, markAsRoot: Dh, softline: Eh } = ah, { countChars: Ch, countParents: wh, dedentString: Ah, forceBreakChildren: Sh, forceBreakContent: xh, forceNextEmptyLine: Th, getLastDescendant: kh, getPrettierIgnoreAttributeCommentData: Fh, hasPrettierIgnore: Oh, inferScriptParser: _h, isScriptLikeTag: Nh, isTextLikeNode: Ph, normalizeParts: Mh, preferHardlineAsLeadingSpaces: Rh, shouldNotPrintClosingTag: Ih, shouldPreserveContent: jh, unescapeQuoteEntities: Bh } = Ud, { replaceEndOfLineWith: Lh } = ls, { insertPragma: qh } = { hasPragma: function (e) { return /^\s*<!--\s*@(format|prettier)\s*-->/.test(e); }, insertPragma: function (e) { return "\x3c!-- @format --\x3e\n\n" + e.replace(/^\s*\n/, ""); } }, { printVueFor: $h, printVueSlotScope: Uh, isVueEventBindingExpression: Vh } = Zd, { printImgSrcset: Wh, printClassNames: Kh } = sh; function zh(e) { const t = Mh(e); return 0 === t.length ? "" : 1 === t.length ? t[0] : ah.concat(t); } function Hh(e, t, n) { const r = e.getValue(); if (Sh(r))
                return zh([lh, zh(e.map((e => { const t = e.getValue(), n = t.prev ? s(t.prev, t) : ""; return zh([n ? zh([n, Th(t.prev) ? hh : ""]) : "", i(e)]); }), "children"))]); const o = r.children.map((() => Symbol(""))); return zh(e.map(((e, t) => { const n = e.getValue(); if (Ph(n)) {
                if (n.prev && Ph(n.prev)) {
                    const t = s(n.prev, n);
                    if (t)
                        return Th(n.prev) ? zh([hh, hh, i(e)]) : zh([t, i(e)]);
                }
                return i(e);
            } const r = [], a = [], u = [], c = [], l = n.prev ? s(n.prev, n) : "", p = n.next ? s(n, n.next) : ""; return l && (Th(n.prev) ? r.push(hh, hh) : l === hh ? r.push(hh) : Ph(n.prev) ? a.push(l) : a.push(mh("", Eh, { groupId: o[t - 1] }))), p && (Th(n) ? Ph(n.next) && c.push(hh, hh) : p === hh ? Ph(n.next) && c.push(hh) : u.push(p)), zh([].concat(r, dh(zh([zh(a), dh(zh([i(e), zh(u)]), { id: o[t] })])), c)); }), "children")); function i(e) { const r = e.getValue(); return Oh(r) ? zh([].concat(im(r, t), Lh(t.originalText.slice(t.locStart(r) + (r.prev && em(r.prev) ? um(r).length : 0), t.locEnd(r) - (r.next && nm(r.next) ? pm(r, t).length : 0)), bh), am(r, t))) : jh(r, t) ? zh([].concat(im(r, t), dh(Yh(e, t, n)), Lh(t.originalText.slice(r.startSourceSpan.end.offset + (r.firstChild && tm(r.firstChild) ? -cm(r).length : 0), r.endSourceSpan.start.offset + (r.lastChild && om(r.lastChild) ? lm(r, t).length : rm(r) ? -pm(r.lastChild, t).length : 0)), bh), Xh(r, t), am(r, t))) : n(e); } function s(e, t) { return Ph(e) && Ph(t) ? e.isTrailingSpaceSensitive ? e.hasTrailingSpaces ? Rh(t) ? hh : vh : "" : Rh(t) ? hh : Eh : em(e) && (Oh(t) || t.firstChild || t.isSelfClosing || "element" === t.type && 0 !== t.attrs.length) || "element" === e.type && e.isSelfClosing && nm(t) ? "" : !t.isLeadingSpaceSensitive || Rh(t) || nm(t) && e.lastChild && om(e.lastChild) && e.lastChild.lastChild && om(e.lastChild.lastChild) ? hh : t.hasLeadingSpaces ? vh : Eh; } } function Yh(e, t, n) { const r = e.getValue(), o = "element" === r.type && "script" === r.fullName && 1 === r.attrs.length && "src" === r.attrs[0].fullName && 0 === r.children.length; return zh([Jh(r, t), r.attrs && 0 !== r.attrs.length ? zh([gh(zh([o ? " " : vh, yh(vh, (r => { const o = "boolean" == typeof r ? () => r : Array.isArray(r) ? e => r.includes(e.rawName) : () => !1; return e.map((e => { const r = e.getValue(); return o(r) ? zh(Lh(t.originalText.slice(t.locStart(r), t.locEnd(r)), bh)) : n(e); }), "attrs"); })(r.prev && "comment" === r.prev.type && Fh(r.prev.value)))])), r.firstChild && tm(r.firstChild) || r.isSelfClosing && rm(r.parent) ? r.isSelfClosing ? " " : "" : r.isSelfClosing ? o ? " " : vh : o ? "" : Eh]) : r.isSelfClosing ? " " : "", r.isSelfClosing ? "" : Gh(r)]); } function Jh(e, t) { return e.prev && em(e.prev) ? "" : zh([im(e, t), um(e)]); } function Gh(e) { return e.firstChild && tm(e.firstChild) ? "" : cm(e); } function Xh(e, t) { return zh([e.isSelfClosing ? "" : Qh(e, t), Zh(e, t)]); } function Qh(e, t) { return e.lastChild && om(e.lastChild) ? "" : zh([sm(e, t), lm(e, t)]); } function Zh(e, t) { return (e.next ? nm(e.next) : rm(e.parent)) ? "" : zh([pm(e, t), am(e, t)]); } function em(e) { return e.next && !Ph(e.next) && Ph(e) && e.isTrailingSpaceSensitive && !e.hasTrailingSpaces; } function tm(e) { return !e.prev && e.isLeadingSpaceSensitive && !e.hasLeadingSpaces; } function nm(e) { return e.prev && !Ph(e.prev) && e.isLeadingSpaceSensitive && !e.hasLeadingSpaces; } function rm(e) { return e.lastChild && e.lastChild.isTrailingSpaceSensitive && !e.lastChild.hasTrailingSpaces && !Ph(kh(e.lastChild)); } function om(e) { return !e.next && !e.hasTrailingSpaces && e.isTrailingSpaceSensitive && Ph(kh(e)); } function im(e, t) { return tm(e) ? cm(e.parent) : nm(e) ? pm(e.prev, t) : ""; } function sm(e, t) { return rm(e) ? pm(e.lastChild, t) : ""; } function am(e, t) { return om(e) ? lm(e.parent, t) : em(e) ? um(e.next) : ""; } function um(e) { switch (e.type) {
                case "ieConditionalComment":
                case "ieConditionalStartComment": return "\x3c!--[if ".concat(e.condition);
                case "ieConditionalEndComment": return "\x3c!--<!";
                case "interpolation": return "{{";
                case "docType": return "<!DOCTYPE";
                case "element": if (e.condition)
                    return "\x3c!--[if ".concat(e.condition, "]>\x3c!--\x3e<").concat(e.rawName);
                default: return "<".concat(e.rawName);
            } } function cm(e) { switch (e.isSelfClosing, e.type) {
                case "ieConditionalComment": return "]>";
                case "element": if (e.condition)
                    return ">\x3c!--<![endif]--\x3e";
                default: return ">";
            } } function lm(e, t) { if (e.isSelfClosing, Ih(e, t))
                return ""; switch (e.type) {
                case "ieConditionalComment": return "<!";
                case "element": if (e.hasHtmComponentClosingTag)
                    return "<//";
                default: return "</".concat(e.rawName);
            } } function pm(e, t) { if (Ih(e, t))
                return ""; switch (e.type) {
                case "ieConditionalComment":
                case "ieConditionalEndComment": return "[endif]--\x3e";
                case "ieConditionalStartComment": return "]>\x3c!--\x3e";
                case "interpolation": return "}}";
                case "element": if (e.isSelfClosing)
                    return "/>";
                default: return ">";
            } } function fm(e, t = e.value) { return e.parent.isWhitespaceSensitive ? e.parent.isIndentationSensitive ? Lh(t, bh) : Lh(Ah(t.replace(/^\s*?\n|\n\s*?$/g, "")), hh) : yh(vh, t.split(/[\t\n\f\r ]+/)).parts; } var dm = { preprocess: function (e, t) { for (const n of Gd)
                    e = n(e, t); return e; }, print: function (e, t, n) { const r = e.getValue(); switch (r.type) {
                    case "root": return t.__onHtmlRoot && t.__onHtmlRoot(r), ah.concat([dh(Hh(e, t, n)), hh]);
                    case "element":
                    case "ieConditionalComment": {
                        const i = 1 === r.children.length && "interpolation" === r.firstChild.type && r.firstChild.isLeadingSpaceSensitive && !r.firstChild.hasLeadingSpaces && r.lastChild.isTrailingSpaceSensitive && !r.lastChild.hasTrailingSpaces, s = Symbol("element-attr-group-id");
                        return zh([dh(zh([dh(Yh(e, t, n), { id: s }), 0 === r.children.length ? r.hasDanglingSpaces && r.isDanglingSpaceSensitive ? vh : "" : zh([xh(r) ? lh : "", (o = zh([i ? mh(Eh, "", { groupId: s }) : r.firstChild.hasLeadingSpaces && r.firstChild.isLeadingSpaceSensitive ? vh : "text" === r.firstChild.type && r.isWhitespaceSensitive && r.isIndentationSensitive ? ph(Eh) : Eh, Hh(e, t, n)]), i ? mh(gh(o), o, { groupId: s }) : Nh(r) && "root" === r.parent.type && "vue" === t.parser && !t.vueIndentScriptAndStyle ? o : gh(o)), (r.next ? nm(r.next) : rm(r.parent)) ? r.lastChild.hasTrailingSpaces && r.lastChild.isTrailingSpaceSensitive ? " " : "" : i ? mh(Eh, "", { groupId: s }) : r.lastChild.hasTrailingSpaces && r.lastChild.isTrailingSpaceSensitive ? vh : ("comment" === r.lastChild.type || "text" === r.lastChild.type && r.isWhitespaceSensitive && r.isIndentationSensitive) && new RegExp("\\n\\s{".concat(t.tabWidth * wh(e, (e => e.parent && "root" !== e.parent.type)), "}$")).test(r.lastChild.value) ? "" : Eh])])), Xh(r, t)]);
                    }
                    case "ieConditionalStartComment":
                    case "ieConditionalEndComment": return zh([Jh(r), Zh(r)]);
                    case "interpolation": return zh([Jh(r, t), zh(e.map(n, "children")), Zh(r, t)]);
                    case "text":
                        if ("interpolation" === r.parent.type) {
                            const e = /\n[^\S\n]*?$/, t = e.test(r.value), n = t ? r.value.replace(e, "") : r.value;
                            return zh([zh(Lh(n, bh)), t ? hh : ""]);
                        }
                        return fh(Mh([].concat(im(r, t), fm(r), am(r, t))));
                    case "docType": return zh([dh(zh([Jh(r, t), " ", r.value.replace(/^html\b/i, "html").replace(/\s+/g, " ")])), Zh(r, t)]);
                    case "comment": return zh([im(r, t), zh(Lh(t.originalText.slice(t.locStart(r), t.locEnd(r)), bh)), am(r, t)]);
                    case "attribute": {
                        if (null === r.value)
                            return r.rawName;
                        const e = Bh(r.value), t = Ch(e, "'") < Ch(e, '"') ? "'" : '"';
                        return zh([r.rawName, zh(["=", t, zh(Lh('"' === t ? e.replace(/"/g, "&quot;") : e.replace(/'/g, "&apos;"), bh)), t])]);
                    }
                    case "yaml":
                    case "toml": return zh(Lh(r.raw, bh));
                    default: throw new Error("Unexpected node type ".concat(r.type));
                } var o; }, insertPragma: qh, massageAstNode: function (e, t) { return delete t.sourceSpan, delete t.startSourceSpan, delete t.endSourceSpan, delete t.nameSpan, delete t.valueSpan, "text" === e.type || "comment" === e.type || "yaml" === e.type || "toml" === e.type ? null : ("attribute" === e.type && delete t.value, void ("docType" === e.type && delete t.value)); }, embed: function (e, t, n, r) { const o = e.getValue(); switch (o.type) {
                    case "text":
                        if (Nh(o.parent)) {
                            const e = _h(o.parent);
                            if (e) {
                                const t = "markdown" === e ? Ah(o.value.replace(/^[^\S\n]*?\n/, "")) : o.value;
                                return ah.concat([zh([lh, im(o, r), uh(n(t, { parser: e })), am(o, r)])]);
                            }
                        }
                        else if ("interpolation" === o.parent.type)
                            return zh([gh(zh([vh, n(o.value, Object.assign({ __isInHtmlInterpolation: !0 }, "angular" === r.parser ? { parser: "__ng_interpolation", trailingComma: "none" } : "vue" === r.parser ? { parser: "__vue_expression" } : { parser: "__js_expression" }))])), o.parent.next && nm(o.parent.next) ? " " : vh]);
                        break;
                    case "attribute": {
                        if (!o.value)
                            break;
                        if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(r.originalText.slice(o.valueSpan.start.offset, o.valueSpan.end.offset)))
                            return zh([o.rawName, "=", o.value]);
                        if ("lwc" === r.parser && /^\{[\s\S]*\}$/.test(r.originalText.slice(o.valueSpan.start.offset, o.valueSpan.end.offset)))
                            return zh([o.rawName, "=", o.value]);
                        const e = function (e, t, n) { const r = t => new RegExp(t.join("|")).test(e.fullName), o = () => Bh(e.value); let i = !1; const s = (e, t) => { const n = "NGRoot" === e.type ? "NGMicrosyntax" === e.node.type && 1 === e.node.body.length && "NGMicrosyntaxExpression" === e.node.body[0].type ? e.node.body[0].expression : e.node : "JsExpressionRoot" === e.type ? e.node : e; !n || "ObjectExpression" !== n.type && "ArrayExpression" !== n.type && ("__vue_expression" !== t.parser || "TemplateLiteral" !== n.type && "StringLiteral" !== n.type) || (i = !0); }, a = (e, t = !0) => dh(zh([gh(zh([Eh, e])), t ? Eh : ""])), u = e => i ? (e => dh(e))(e) : a(e), c = (e, n) => t(e, Object.assign({ __onHtmlBindingRoot: s }, n)); if ("srcset" === e.fullName && ("img" === e.parent.fullName || "source" === e.parent.fullName))
                            return a(Wh(o())); if ("class" === e.fullName && !n.parentParser) {
                            const e = o();
                            if (!e.includes("{{"))
                                return Kh(e);
                        } if ("style" === e.fullName && !n.parentParser) {
                            const e = o();
                            if (!e.includes("{{"))
                                return a(c(e, { parser: "css", __isHTMLStyleAttribute: !0 }));
                        } if ("vue" === n.parser) {
                            if ("v-for" === e.fullName)
                                return $h(o(), c);
                            if ("slot-scope" === e.fullName)
                                return Uh(o(), c);
                            const t = ["^:", "^v-bind:"], n = ["^v-"];
                            if (r(["^@", "^v-on:"])) {
                                const e = o();
                                return u(Vh(e) ? c(e, { parser: "__js_expression" }) : uh(c(e, { parser: "__vue_event_binding" })));
                            }
                            if (r(t))
                                return u(c(o(), { parser: "__vue_expression" }));
                            if (r(n))
                                return u(c(o(), { parser: "__js_expression" }));
                        } if ("angular" === n.parser) {
                            const t = (e, t) => c(e, Object.assign({}, t, { trailingComma: "none" })), n = ["^\\*"], i = ["^\\[.+\\]$", "^bind(on)?-", "^ng-(if|show|hide|class|style)$"], s = ["^i18n(-.+)?$"];
                            if (r(["^\\(.+\\)$", "^on-"]))
                                return u(t(o(), { parser: "__ng_action" }));
                            if (r(i))
                                return u(t(o(), { parser: "__ng_binding" }));
                            if (r(s)) {
                                const t = o().trim();
                                return a(fh(fm(e, t)), !t.includes("@@"));
                            }
                            if (r(n))
                                return u(t(o(), { parser: "__ng_directive" }));
                            const l = /\{\{([\s\S]+?)\}\}/g, p = o();
                            if (l.test(p)) {
                                const e = [];
                                return p.split(l).forEach(((n, r) => { if (r % 2 == 0)
                                    e.push(zh(Lh(n, bh)));
                                else
                                    try {
                                        e.push(dh(zh(["{{", gh(zh([vh, t(n, { parser: "__ng_interpolation", __isInHtmlInterpolation: !0 })])), vh, "}}"])));
                                    }
                                    catch (t) {
                                        e.push("{{", zh(Lh(n, bh)), "}}");
                                    } })), dh(zh(e));
                            }
                        } return null; }(o, ((e, t) => n(e, Object.assign({ __isInHtmlAttribute: !0 }, t))), r);
                        if (e)
                            return zh([o.rawName, '="', dh(ch(e, (e => "string" == typeof e ? e.replace(/"/g, "&quot;") : e))), '"']);
                        break;
                    }
                    case "yaml": return Dh(zh(["---", hh, 0 === o.value.trim().length ? "" : n(o.value, { parser: "yaml" }), "---"]));
                } } }; const hm = "HTML"; var mm = { htmlWhitespaceSensitivity: { since: "1.15.0", category: hm, type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{ value: "css", description: "Respect the default value of CSS display property." }, { value: "strict", description: "Whitespaces are considered sensitive." }, { value: "ignore", description: "Whitespaces are considered insensitive." }] }, vueIndentScriptAndStyle: { since: "1.19.0", category: hm, type: "boolean", default: !1, description: "Indent script and style tags in Vue files." } }, gm = "HTML", ym = "markup", vm = "text.html.basic", bm = "html", Dm = "htmlmixed", Em = "text/html", Cm = "#e34c26", wm = ["xhtml"], Am = [".html", ".htm", ".html.hl", ".inc", ".st", ".xht", ".xhtml"], Sm = { name: gm, type: ym, tmScope: vm, aceMode: bm, codemirrorMode: Dm, codemirrorMimeType: Em, color: Cm, aliases: wm, extensions: Am, languageId: 146 }, xm = Object.freeze({ __proto__: null, name: gm, type: ym, tmScope: vm, aceMode: bm, codemirrorMode: Dm, codemirrorMimeType: Em, color: Cm, aliases: wm, extensions: Am, languageId: 146, default: Sm }), Tm = "markup", km = "#2c3e50", Fm = [".vue"], Om = "text.html.vue", _m = "html", Nm = { name: "Vue", type: Tm, color: km, extensions: Fm, tmScope: Om, aceMode: _m, languageId: 391 }, Pm = Object.freeze({ __proto__: null, name: "Vue", type: Tm, color: km, extensions: Fm, tmScope: Om, aceMode: _m, languageId: 391, default: Nm }), Mm = at(xm), Rm = at(Pm), Im = { languages: [Hc(Mm, (() => ({ name: "Angular", since: "1.15.0", parsers: ["angular"], vscodeLanguageIds: ["html"], extensions: [".component.html"], filenames: [] }))), Hc(Mm, (e => ({ since: "1.15.0", parsers: ["html"], vscodeLanguageIds: ["html"], extensions: e.extensions.concat([".mjml"]) }))), Hc(Mm, (() => ({ name: "Lightning Web Components", since: "1.17.0", parsers: ["lwc"], vscodeLanguageIds: ["html"], extensions: [], filenames: [] }))), Hc(Rm, (() => ({ since: "1.10.0", parsers: ["vue"], vscodeLanguageIds: ["vue"] })))], printers: { html: dm }, options: mm }; const { addLeadingComment: jm, addTrailingComment: Bm, addDanglingComment: Lm, getNextNonSpaceNonCommentCharacterIndex: qm } = ra; function $m(e, t) { const n = e.body.filter((e => "EmptyStatement" !== e.type)); 0 === n.length ? Lm(e, t) : jm(n[0], t); } function Um(e, t) { "BlockStatement" === e.type ? $m(e, t) : jm(e, t); } function Vm(e, t, n, r, o, i) { return !(!n || "IfStatement" !== n.type || !r || (")" === ls.getNextNonSpaceNonCommentCharacter(e, o, i.locEnd) ? (Bm(t, o), 0) : t === n.consequent && r === n.alternate ? ("BlockStatement" === t.type ? Bm(t, o) : Lm(n, o), 0) : "BlockStatement" === r.type ? ($m(r, o), 0) : "IfStatement" === r.type ? (Um(r.consequent, o), 0) : n.consequent !== r || (jm(r, o), 0))); } function Wm(e, t, n, r, o, i) { return !(!n || "WhileStatement" !== n.type || !r || (")" === ls.getNextNonSpaceNonCommentCharacter(e, o, i.locEnd) ? (Bm(t, o), 0) : "BlockStatement" !== r.type || ($m(r, o), 0))); } function Km(e, t, n, r) { return !(!e || "TryStatement" !== e.type && "CatchClause" !== e.type || !n || ("CatchClause" === e.type && t ? (Bm(t, r), 0) : "BlockStatement" === n.type ? ($m(n, r), 0) : "TryStatement" === n.type ? (Um(n.finalizer, r), 0) : "CatchClause" !== n.type || (Um(n.body, r), 0))); } function zm(e, t, n, r) { return !(!(e && ("ClassDeclaration" === e.type || "ClassExpression" === e.type) && e.decorators && e.decorators.length > 0) || n && "Decorator" === n.type || (e.decorators && 0 !== e.decorators.length ? Bm(e.decorators[e.decorators.length - 1], r) : jm(e, r), 0)); } function Hm(e, t, n, r, o) { return (t && n && ("Property" === t.type || "TSDeclareMethod" === t.type || "TSAbstractMethodDefinition" === t.type) && "Identifier" === n.type && t.key === n && ":" !== ls.getNextNonSpaceNonCommentCharacter(e, n, o.locEnd) || !(!n || !t || "Decorator" !== n.type || "ClassMethod" !== t.type && "ClassProperty" !== t.type && "TSAbstractClassProperty" !== t.type && "TSAbstractMethodDefinition" !== t.type && "TSDeclareMethod" !== t.type && "MethodDefinition" !== t.type)) && (Bm(n, r), !0); } function Ym(e, t, n, r, o, i) { if (t && "FunctionTypeParam" === t.type && n && "FunctionTypeAnnotation" === n.type && r && "FunctionTypeParam" !== r.type)
                return Bm(t, o), !0; if (t && ("Identifier" === t.type || "AssignmentPattern" === t.type) && n && Zm(n) && ")" === ls.getNextNonSpaceNonCommentCharacter(e, o, i.locEnd))
                return Bm(t, o), !0; if (n && "FunctionDeclaration" === n.type && r && "BlockStatement" === r.type) {
                const t = (() => { if (0 !== (n.params || n.parameters).length)
                    return ls.getNextNonSpaceNonCommentCharacterIndexWithStartIndex(e, i.locEnd(ls.getLast(n.params || n.parameters))); const t = ls.getNextNonSpaceNonCommentCharacterIndexWithStartIndex(e, i.locEnd(n.id)); return ls.getNextNonSpaceNonCommentCharacterIndexWithStartIndex(e, t + 1); })();
                if (i.locStart(o) > t)
                    return $m(r, o), !0;
            } return !1; } function Jm(e, t) { return !(!e || "ImportSpecifier" !== e.type || (jm(e, t), 0)); } function Gm(e, t) { return !(!e || "LabeledStatement" !== e.type || (jm(e, t), 0)); } function Xm(e, t, n, r) { return t && t.body && 0 === t.body.length ? (r ? Lm(t, n) : jm(t, n), !0) : !(!e || "Program" !== e.type || 0 !== e.body.length || !e.directives || 0 !== e.directives.length || (r ? Lm(e, n) : jm(e, n), 0)); } function Qm(e) { return "Block" === e.type || "CommentBlock" === e.type; } function Zm(e) { return "ArrowFunctionExpression" === e.type || "FunctionExpression" === e.type || "FunctionDeclaration" === e.type || "ObjectMethod" === e.type || "ClassMethod" === e.type || "TSDeclareFunction" === e.type || "TSCallSignatureDeclaration" === e.type || "TSConstructSignatureDeclaration" === e.type || "TSConstructSignatureDeclaration" === e.type || "TSMethodSignature" === e.type || "TSConstructorType" === e.type || "TSFunctionType" === e.type || "TSDeclareMethod" === e.type; } function eg(e) { return Qm(e) && "*" === e.value[0] && /@type\b/.test(e.value); } var tg = { handleOwnLineComment: function (e, t, n, r, o) { const { precedingNode: i, enclosingNode: s, followingNode: a } = e; return Ym(t, i, s, a, e, n) || function (e, t, n) { return !(!e || "MemberExpression" !== e.type && "OptionalMemberExpression" !== e.type || !t || "Identifier" !== t.type || (jm(e, n), 0)); }(s, a, e) || Vm(t, i, s, a, e, n) || Wm(t, i, s, a, e, n) || Km(s, i, a, e) || zm(s, 0, a, e) || Jm(s, e) || function (e, t, n) { return !(!e || "ForInStatement" !== e.type && "ForOfStatement" !== e.type || (jm(e, n), 0)); }(s, 0, e) || function (e, t, n, r) { return !t || "UnionTypeAnnotation" !== t.type && "TSUnionType" !== t.type ? (n && ("UnionTypeAnnotation" === n.type || "TSUnionType" === n.type) && ls.isNodeIgnoreComment(r) && (n.types[0].prettierIgnore = !0, r.unignore = !0), !1) : (ls.isNodeIgnoreComment(r) && (n.prettierIgnore = !0, r.unignore = !0), !!e && (Bm(e, r), !0)); }(i, s, a, e) || Xm(s, r, e, o) || function (e, t, n, r, o) { return !!(n && "ImportSpecifier" === n.type && t && "ImportDeclaration" === t.type && ls.hasNewline(e, o.locEnd(r))) && (Bm(n, r), !0); }(t, s, i, e, n) || function (e, t) { return !(!e || "AssignmentPattern" !== e.type || (jm(e, t), 0)); }(s, e) || Hm(t, s, i, e, n) || Gm(s, e); }, handleEndOfLineComment: function (e, t, n, r, o) { const { precedingNode: i, enclosingNode: s, followingNode: a } = e; return function (e, t) { return !(!e || !eg(t) || (jm(e, t), 0)); }(a, e) || Ym(t, i, s, a, e, n) || function (e, t, n, r, o, i) { const s = t && !ls.hasNewlineInRange(o, i.locEnd(t), i.locStart(r)); return !(t && s || !e || "ConditionalExpression" !== e.type || !n || (jm(n, r), 0)); }(s, i, a, e, t, n) || Jm(s, e) || Vm(t, i, s, a, e, n) || Wm(t, i, s, a, e, n) || Km(s, i, a, e) || zm(s, 0, a, e) || Gm(s, e) || function (e, t, n) { return !!(t && ("CallExpression" === t.type || "OptionalCallExpression" === t.type) && e && t.callee === e && t.arguments.length > 0) && (jm(t.arguments[0], n), !0); }(i, s, e) || function (e, t) { return !(!e || "Property" !== e.type && "ObjectProperty" !== e.type || (jm(e, t), 0)); }(s, e) || Xm(s, r, e, o) || function (e, t, n) { return !(!e || "TypeAlias" !== e.type || (jm(e, n), 0)); }(s, 0, e) || function (e, t, n) { return !(!e || "VariableDeclarator" !== e.type && "AssignmentExpression" !== e.type || !t || "ObjectExpression" !== t.type && "ArrayExpression" !== t.type && "TemplateLiteral" !== t.type && "TaggedTemplateExpression" !== t.type && !Qm(n) || (jm(t, n), 0)); }(s, a, e); }, handleRemainingComment: function (e, t, n, r, o) { const { precedingNode: i, enclosingNode: s, followingNode: a } = e; return !!(Vm(t, i, s, a, e, n) || Wm(t, i, s, a, e, n) || function (e, t, n) { return !(!e || "ObjectProperty" !== e.type && "Property" !== e.type || !e.shorthand || e.key !== t || "AssignmentPattern" !== e.value.type || (Bm(e.value.left, n), 0)); }(s, i, e) || function (e, t, n, r) { return !(")" !== ls.getNextNonSpaceNonCommentCharacter(e, n, r.locEnd) || (t && (Zm(t) && 0 === (t.params || t.parameters).length || ("CallExpression" === t.type || "OptionalCallExpression" === t.type || "NewExpression" === t.type) && 0 === t.arguments.length) ? (Lm(t, n), 0) : !t || "MethodDefinition" !== t.type || 0 !== t.value.params.length || (Lm(t.value, n), 0))); }(t, s, e, n) || Hm(t, s, i, e, n) || Xm(s, r, e, o) || function (e, t, n, r) { if (!t || "ArrowFunctionExpression" !== t.type)
                    return !1; const o = qm(e, n, r.locEnd); return "=>" === e.slice(o, o + 2) && (Lm(t, n), !0); }(t, s, e, n) || function (e, t, n, r, o) { return !("(" !== ls.getNextNonSpaceNonCommentCharacter(e, r, o.locEnd) || !n || !t || "FunctionDeclaration" !== t.type && "FunctionExpression" !== t.type && "ClassMethod" !== t.type && "MethodDefinition" !== t.type && "ObjectMethod" !== t.type || (Bm(n, r), 0)); }(t, s, i, e, n) || function (e, t, n, r, o) { return !(!t || "TSMappedType" !== t.type || (r && "TSTypeParameter" === r.type && r.name ? (jm(r.name, o), 0) : !n || "TSTypeParameter" !== n.type || !n.constraint || (Bm(n.constraint, o), 0))); }(0, s, i, a, e) || function (e, t) { return !(!e || "ContinueStatement" !== e.type && "BreakStatement" !== e.type || e.label || (Bm(e, t), 0)); }(s, e) || function (e, t, n, r, o) { return !(n || !t || "TSMethodSignature" !== t.type && "TSDeclareFunction" !== t.type && "TSAbstractMethodDefinition" !== t.type || ";" !== ls.getNextNonSpaceNonCommentCharacter(e, r, o.locEnd) || (Bm(t, r), 0)); }(t, s, a, e, n)); }, hasLeadingComment: function (e, t = (() => !0)) { return e.leadingComments ? e.leadingComments.some(t) : !!e.comments && e.comments.some((e => e.leading && t(e))); }, isBlockComment: Qm, isTypeCastComment: eg, getGapRegex: function (e) { if (e && "BinaryExpression" !== e.type && "LogicalExpression" !== e.type)
                    return /^[\s(&|]*$/; }, getCommentChildNodes: function (e, t) { if (("typescript" === t.parser || "flow" === t.parser) && "MethodDefinition" === e.type && e.value && "FunctionExpression" === e.value.type && 0 === e.value.params.length && !e.value.returnType && (!e.value.typeParameters || 0 === e.value.typeParameters.length) && e.value.body)
                    return [...e.decorators || [], e.key, e.value.body]; } }; const { isBlockComment: ng, hasLeadingComment: rg } = tg, { builders: { indent: og, join: ig, line: sg, hardline: ag, softline: ug, literalline: cg, concat: lg, group: pg, dedentToRoot: fg }, utils: { mapDoc: dg, stripTrailingHardline: hg } } = Ps; function mg(e) { return e.replace(/([\\`]|\$\{)/g, "\\$1"); } function gg(e, t) { return dg(e, (e => { if (!e.parts)
                return e; const n = []; return e.parts.forEach((e => { "string" == typeof e ? n.push(t ? e.replace(/(\\*)`/g, "$1$1\\`") : mg(e)) : n.push(e); })), Object.assign({}, e, { parts: n }); })); } function yg(e) { const t = []; let n = !1; return e.map((e => e.trim())).forEach(((e, r, o) => { "" !== e && ("" === o[r - 1] && n ? t.push(lg([ag, e])) : t.push(e), n = !0); })), 0 === t.length ? null : ig(ag, t); } function vg(e) { const t = e.getValue(), n = e.getParentNode(), r = e.getParentNode(1); return r && t.quasis && "JSXExpressionContainer" === n.type && "JSXElement" === r.type && "style" === r.openingElement.name.name && r.openingElement.attributes.some((e => "jsx" === e.name.name)) || n && "TaggedTemplateExpression" === n.type && "Identifier" === n.tag.type && "css" === n.tag.name || n && "TaggedTemplateExpression" === n.type && "MemberExpression" === n.tag.type && "css" === n.tag.object.name && ("global" === n.tag.property.name || "resolve" === n.tag.property.name); } function bg(e) { return e.match((e => "TemplateLiteral" === e.type), ((e, t) => "ArrayExpression" === e.type && "elements" === t), ((e, t) => ("Property" === e.type || "ObjectProperty" === e.type) && "Identifier" === e.key.type && "styles" === e.key.name && "value" === t), ...Dg); } const Dg = [(e, t) => "ObjectExpression" === e.type && "properties" === t, (e, t) => "CallExpression" === e.type && "Identifier" === e.callee.type && "Component" === e.callee.name && "arguments" === t, (e, t) => "Decorator" === e.type && "expression" === t]; function Eg(e) { const t = e.getParentNode(); if (!t || "TaggedTemplateExpression" !== t.type)
                return !1; const { tag: n } = t; switch (n.type) {
                case "MemberExpression": return wg(n.object) || Ag(n);
                case "CallExpression": return wg(n.callee) || "MemberExpression" === n.callee.type && ("MemberExpression" === n.callee.object.type && (wg(n.callee.object.object) || Ag(n.callee.object)) || "CallExpression" === n.callee.object.type && wg(n.callee.object.callee));
                case "Identifier": return "css" === n.name;
                default: return !1;
            } } function Cg(e) { const t = e.getParentNode(), n = e.getParentNode(1); return n && "JSXExpressionContainer" === t.type && "JSXAttribute" === n.type && "JSXIdentifier" === n.name.type && "css" === n.name.name; } function wg(e) { return "Identifier" === e.type && "styled" === e.name; } function Ag(e) { return /^[A-Z]/.test(e.object.name) && "extend" === e.property.name; } function Sg(e, t) { return rg(e, (e => ng(e) && e.value === " ".concat(t, " "))); } let xg = 0; const { getLast: Tg, hasNewline: kg, hasNewlineInRange: Fg, hasIgnoreComment: Og, hasNodeIgnoreComment: _g, skipWhitespace: Ng } = ls, Pg = Mo.keyword.isIdentifierNameES5, Mg = "(?:(?=.)\\s)", Rg = new RegExp("^".concat(Mg, "*:")), Ig = new RegExp("^".concat(Mg, "*::")); function jg(e, t) { if (!e || "object" != typeof e)
                return !1; if (Array.isArray(e))
                return e.some((e => jg(e, t))); const n = t(e); return "boolean" == typeof n ? n : Object.keys(e).some((n => jg(e[n], t))); } function Bg(e) { return "AssignmentExpression" === e.type || "BinaryExpression" === e.type || "LogicalExpression" === e.type || "NGPipeExpression" === e.type || "ConditionalExpression" === e.type || "CallExpression" === e.type || "OptionalCallExpression" === e.type || "MemberExpression" === e.type || "OptionalMemberExpression" === e.type || "SequenceExpression" === e.type || "TaggedTemplateExpression" === e.type || "BindExpression" === e.type || "UpdateExpression" === e.type && !e.prefix || "TSAsExpression" === e.type || "TSNonNullExpression" === e.type; } const Lg = new Set(["ExportDefaultDeclaration", "ExportDefaultSpecifier", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration"]); function qg(e) { return e && Lg.has(e.type); } function $g(e) { return "BooleanLiteral" === e.type || "DirectiveLiteral" === e.type || "Literal" === e.type || "NullLiteral" === e.type || "NumericLiteral" === e.type || "RegExpLiteral" === e.type || "StringLiteral" === e.type || "TemplateLiteral" === e.type || "TSTypeLiteral" === e.type || "JSXText" === e.type; } function Ug(e) { return "NumericLiteral" === e.type || "Literal" === e.type && "number" == typeof e.value; } function Vg(e) { return "StringLiteral" === e.type || "Literal" === e.type && "string" == typeof e.value; } function Wg(e) { return "FunctionExpression" === e.type || "ArrowFunctionExpression" === e.type; } function Kg(e) { return !("CallExpression" !== e.type && "OptionalCallExpression" !== e.type || "Identifier" !== e.callee.type || "async" !== e.callee.name && "inject" !== e.callee.name && "fakeAsync" !== e.callee.name); } function zg(e) { return "JSXElement" === e.type || "JSXFragment" === e.type; } function Hg(e) { return "get" === e.kind || "set" === e.kind; } function Yg(e, t, n) { return n.locStart(e) === n.locStart(t); } function Jg(e, t) { return Hg(e) || Yg(e, e.value, t); } const Gg = new Set(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]), Xg = /^(skip|[fx]?(it|describe|test))$/; function Qg(e) { return "CallExpression" === e.type || "OptionalCallExpression" === e.type; } const Zg = new RegExp("([ \n\r\t]+)"), ey = new RegExp("[^ \n\r\t]"); function ty(e) { return $g(e) && (ey.test(oy(e)) || !/\n/.test(oy(e))); } function ny(e, t, n) { return zg(t) ? _g(t) : t.comments && t.comments.some((t => t.leading && kg(e, n.locEnd(t)))); } function ry(e) { return e.quasis.some((e => e.value.raw.includes("\n"))); } function oy(e) { return e.extra ? e.extra.raw : e.raw; } var iy = { classChildNeedsASIProtection: function (e) { if (e) {
                    if (e.static || e.accessibility)
                        return !1;
                    if (!e.computed) {
                        const t = e.key && e.key.name;
                        if ("in" === t || "instanceof" === t)
                            return !0;
                    }
                    switch (e.type) {
                        case "ClassProperty":
                        case "TSAbstractClassProperty": return e.computed;
                        case "MethodDefinition":
                        case "TSAbstractMethodDefinition":
                        case "ClassMethod":
                        case "ClassPrivateMethod": {
                            const t = e.value ? e.value.async : e.async, n = e.value ? e.value.generator : e.generator;
                            return !(t || "get" === e.kind || "set" === e.kind || !e.computed && !n);
                        }
                        case "TSIndexSignature": return !0;
                        default: return !1;
                    }
                } }, classPropMayCauseASIProblems: function (e) { const t = e.getNode(); if ("ClassProperty" !== t.type)
                    return !1; const n = t.key && t.key.name; return !("static" !== n && "get" !== n && "set" !== n || t.value || t.typeAnnotation) || void 0; }, conditionalExpressionChainContainsJSX: function (e) { return Boolean(function (e) { const t = []; return function e(n) { "ConditionalExpression" === n.type ? (e(n.test), e(n.consequent), e(n.alternate)) : t.push(n); }(e), t; }(e).find(zg)); }, getFlowVariance: function (e) { if (!e.variance)
                    return null; const t = e.variance.kind || e.variance; switch (t) {
                    case "plus": return "+";
                    case "minus": return "-";
                    default: return t;
                } }, getLeftSidePathName: function (e, t) { if (t.expressions)
                    return ["expressions", 0]; if (t.left)
                    return ["left"]; if (t.test)
                    return ["test"]; if (t.object)
                    return ["object"]; if (t.callee)
                    return ["callee"]; if (t.tag)
                    return ["tag"]; if (t.argument)
                    return ["argument"]; if (t.expression)
                    return ["expression"]; throw new Error("Unexpected node has no left side", t); }, getParentExportDeclaration: function (e) { const t = e.getParentNode(); return "declaration" === e.getName() && qg(t) ? t : null; }, getTypeScriptMappedTypeModifier: function (e, t) { return "+" === e ? "+" + t : "-" === e ? "-" + t : t; }, hasDanglingComments: function (e) { return e.comments && e.comments.some((e => !e.leading && !e.trailing)); }, hasFlowAnnotationComment: function (e) { return e && e[0].value.match(Ig); }, hasFlowShorthandAnnotationComment: function (e) { return e.extra && e.extra.parenthesized && e.trailingComments && e.trailingComments[0].value.match(Rg); }, hasLeadingComment: function (e) { return e.comments && e.comments.some((e => e.leading)); }, hasLeadingOwnLineComment: ny, hasNakedLeftSide: Bg, hasNewlineBetweenOrAfterDecorators: function (e, t) { return Fg(t.originalText, t.locStart(e.decorators[0]), t.locEnd(Tg(e.decorators))) || kg(t.originalText, t.locEnd(Tg(e.decorators))); }, hasNgSideEffect: function (e) { return jg(e.getValue(), (e => { switch (e.type) {
                    case void 0: return !1;
                    case "CallExpression":
                    case "OptionalCallExpression":
                    case "AssignmentExpression": return !0;
                } })); }, hasNode: jg, hasPrettierIgnore: function (e) { return Og(e) || function (e) { const t = e.getValue(), n = e.getParentNode(); if (!(n && t && zg(t) && zg(n)))
                    return !1; let r = null; for (let e = n.children.indexOf(t); e > 0; e--) {
                    const t = n.children[e - 1];
                    if ("JSXText" !== t.type || ty(t)) {
                        r = t;
                        break;
                    }
                } return r && "JSXExpressionContainer" === r.type && "JSXEmptyExpression" === r.expression.type && r.expression.comments && r.expression.comments.find((e => "prettier-ignore" === e.value.trim())); }(e); }, hasTrailingComment: function (e) { return e.comments && e.comments.some((e => e.trailing)); }, identity: function (e) { return e; }, isBinaryish: function (e) { return Gg.has(e.type); }, isCallOrOptionalCallExpression: Qg, isEmptyJSXElement: function (e) { if (0 === e.children.length)
                    return !0; if (e.children.length > 1)
                    return !1; const t = e.children[0]; return $g(t) && !ty(t); }, isExportDeclaration: qg, isFlowAnnotationComment: function (e, t, n) { const r = n.locStart(t), o = Ng(e, n.locEnd(t)); return "/*" === e.slice(r, r + 2) && "*/" === e.slice(o, o + 2); }, isFunctionCompositionArgs: function (e) { if (e.length <= 1)
                    return !1; let t = 0; for (const n of e)
                    if (Wg(n)) {
                        if (t += 1, t > 1)
                            return !0;
                    }
                    else if (Qg(n))
                        for (const e of n.arguments)
                            if (Wg(e))
                                return !0; return !1; }, isFunctionNotation: Jg, isFunctionOrArrowExpression: Wg, isGetterOrSetter: Hg, isJestEachTemplateLiteral: function (e, t) { const n = /^[xf]?(describe|it|test)$/; return "TaggedTemplateExpression" === t.type && t.quasi === e && "MemberExpression" === t.tag.type && "Identifier" === t.tag.property.type && "each" === t.tag.property.name && ("Identifier" === t.tag.object.type && n.test(t.tag.object.name) || "MemberExpression" === t.tag.object.type && "Identifier" === t.tag.object.property.type && ("only" === t.tag.object.property.name || "skip" === t.tag.object.property.name) && "Identifier" === t.tag.object.object.type && n.test(t.tag.object.object.name)); }, isJSXNode: zg, isJSXWhitespaceExpression: function (e) { return "JSXExpressionContainer" === e.type && $g(e.expression) && " " === e.expression.value && !e.expression.comments; }, isLastStatement: function (e) { const t = e.getParentNode(); if (!t)
                    return !0; const n = e.getValue(), r = (t.body || t.consequent).filter((e => "EmptyStatement" !== e.type)); return r && r[r.length - 1] === n; }, isLiteral: $g, isLongCurriedCallExpression: function (e) { const t = e.getValue(), n = e.getParentNode(); return Qg(t) && Qg(n) && n.callee === t && t.arguments.length > n.arguments.length && n.arguments.length > 0; }, isSimpleCallArgument: function e(t, n) { if (n >= 2)
                    return !1; const r = t => e(t, n + 1), o = "Literal" === t.type && t.regex && t.regex.pattern || "RegExpLiteral" === t.type && t.pattern; return !(o && o.length > 5) && ("Literal" === t.type || "BooleanLiteral" === t.type || "NullLiteral" === t.type || "NumericLiteral" === t.type || "StringLiteral" === t.type || "Identifier" === t.type || "ThisExpression" === t.type || "Super" === t.type || "BigIntLiteral" === t.type || "PrivateName" === t.type || "ArgumentPlaceholder" === t.type || "RegExpLiteral" === t.type || "Import" === t.type || ("TemplateLiteral" === t.type ? t.expressions.every(r) : "ObjectExpression" === t.type ? t.properties.every((e => !e.computed && (e.shorthand || e.value && r(e.value)))) : "ArrayExpression" === t.type ? t.elements.every((e => null == e || r(e))) : "CallExpression" === t.type || "OptionalCallExpression" === t.type || "NewExpression" === t.type ? e(t.callee, n) && t.arguments.every(r) : "MemberExpression" === t.type || "OptionalMemberExpression" === t.type ? e(t.object, n) && e(t.property, n) : "UnaryExpression" !== t.type || "!" !== t.operator && "-" !== t.operator ? "TSNonNullExpression" === t.type && e(t.expression, n) : e(t.argument, n))); }, isMeaningfulJSXText: ty, isMemberExpressionChain: function e(t) { return ("MemberExpression" === t.type || "OptionalMemberExpression" === t.type) && ("Identifier" === t.object.type || e(t.object)); }, isMemberish: function (e) { return "MemberExpression" === e.type || "OptionalMemberExpression" === e.type || "BindExpression" === e.type && e.object; }, isNgForOf: function (e, t, n) { return "NGMicrosyntaxKeyedExpression" === e.type && "of" === e.key.name && 1 === t && "NGMicrosyntaxLet" === n.body[0].type && null === n.body[0].value; }, isNumericLiteral: Ug, isObjectType: function (e) { return "ObjectTypeAnnotation" === e.type || "TSTypeLiteral" === e.type; }, isObjectTypePropertyAFunction: function (e, t) { return !("ObjectTypeProperty" !== e.type && "ObjectTypeInternalSlot" !== e.type || "FunctionTypeAnnotation" !== e.value.type || e.static || Jg(e, t)); }, isSimpleFlowType: function (e) { return e && ["AnyTypeAnnotation", "NullLiteralTypeAnnotation", "GenericTypeAnnotation", "ThisTypeAnnotation", "NumberTypeAnnotation", "VoidTypeAnnotation", "EmptyTypeAnnotation", "MixedTypeAnnotation", "BooleanTypeAnnotation", "BooleanLiteralTypeAnnotation", "StringTypeAnnotation"].includes(e.type) && !("GenericTypeAnnotation" === e.type && e.typeParameters); }, isSimpleTemplateLiteral: function (e) { return 0 !== e.expressions.length && e.expressions.every((e => { if (e.comments)
                    return !1; if ("Identifier" === e.type || "ThisExpression" === e.type)
                    return !0; if ("MemberExpression" === e.type || "OptionalMemberExpression" === e.type) {
                    let t = e;
                    for (; "MemberExpression" === t.type || "OptionalMemberExpression" === t.type;) {
                        if ("Identifier" !== t.property.type && "Literal" !== t.property.type && "StringLiteral" !== t.property.type && "NumericLiteral" !== t.property.type)
                            return !1;
                        if (t = t.object, t.comments)
                            return !1;
                    }
                    return "Identifier" === t.type || "ThisExpression" === t.type;
                } return !1; })); }, isStringLiteral: Vg, isStringPropSafeToCoerceToIdentifier: function (e, t) { return Vg(e.key) && Pg(e.key.value) && "json" !== t.parser && !(("typescript" === t.parser || "babel-ts" === t.parser) && "ClassProperty" === e.type); }, isTemplateOnItsOwnLine: function (e, t, n) { return ("TemplateLiteral" === e.type && ry(e) || "TaggedTemplateExpression" === e.type && ry(e.quasi)) && !kg(t, n.locStart(e), { backwards: !0 }); }, isTestCall: function e(t, n) { if ("CallExpression" !== t.type)
                    return !1; if (1 === t.arguments.length) {
                    if (Kg(t) && n && e(n))
                        return Wg(t.arguments[0]);
                    if (function (e) { return "Identifier" === e.callee.type && /^(before|after)(Each|All)$/.test(e.callee.name) && 1 === e.arguments.length; }(t))
                        return Kg(t.arguments[0]);
                }
                else if ((2 === t.arguments.length || 3 === t.arguments.length) && ("Identifier" === t.callee.type && Xg.test(t.callee.name) || ("MemberExpression" === (r = t).callee.type || "OptionalMemberExpression" === r.callee.type) && "Identifier" === r.callee.object.type && "Identifier" === r.callee.property.type && Xg.test(r.callee.object.name) && ("only" === r.callee.property.name || "skip" === r.callee.property.name)) && (function (e) { return "TemplateLiteral" === e.type; }(t.arguments[0]) || Vg(t.arguments[0])))
                    return !(t.arguments[2] && !Ug(t.arguments[2])) && ((2 === t.arguments.length ? Wg(t.arguments[1]) : function (e) { return "FunctionExpression" === e.type || "ArrowFunctionExpression" === e.type && "BlockStatement" === e.body.type; }(t.arguments[1]) && t.arguments[1].params.length <= 1) || Kg(t.arguments[1])); var r; return !1; }, isTheOnlyJSXElementInMarkdown: function (e, t) { if ("markdown" !== e.parentParser && "mdx" !== e.parentParser)
                    return !1; const n = t.getNode(); if (!n.expression || !zg(n.expression))
                    return !1; const r = t.getParentNode(); return "Program" === r.type && 1 === r.body.length; }, isTSXFile: function (e) { return e.filepath && /\.tsx$/i.test(e.filepath); }, isTypeAnnotationAFunction: function (e, t) { return !("TypeAnnotation" !== e.type && "TSTypeAnnotation" !== e.type || "FunctionTypeAnnotation" !== e.typeAnnotation.type || e.static || Yg(e, e.typeAnnotation, t)); }, matchJsxWhitespaceRegex: Zg, needsHardlineAfterDanglingComment: function (e) { if (!e.comments)
                    return !1; const t = Tg(e.comments.filter((e => !e.leading && !e.trailing))); return t && !tg.isBlockComment(t); }, rawText: oy, returnArgumentHasLeadingComment: function (e, t) { if (ny(e.originalText, t, e))
                    return !0; if (Bg(t)) {
                    let r, o = t;
                    for (; r = (n = o).expressions ? n.expressions[0] : n.left || n.test || n.callee || n.object || n.tag || n.argument || n.expression;)
                        if (o = r, ny(e.originalText, o, e))
                            return !0;
                } var n; return !1; } }; const { getLeftSidePathName: sy, hasFlowShorthandAnnotationComment: ay, hasNakedLeftSide: uy, hasNode: cy } = iy; function ly(e, t) { const n = e.getParentNode(); if (!n)
                return !1; const r = e.getName(), o = e.getNode(); if (e.getValue() !== o)
                return !1; if (t.__isInHtmlInterpolation && !t.bracketSpacing && function (e) { return "ObjectExpression" === e.type; }(o) && py(e))
                return !0; if (function (e) { return "BlockStatement" === e.type || "BreakStatement" === e.type || "ClassBody" === e.type || "ClassDeclaration" === e.type || "ClassMethod" === e.type || "ClassProperty" === e.type || "ClassPrivateProperty" === e.type || "ContinueStatement" === e.type || "DebuggerStatement" === e.type || "DeclareClass" === e.type || "DeclareExportAllDeclaration" === e.type || "DeclareExportDeclaration" === e.type || "DeclareFunction" === e.type || "DeclareInterface" === e.type || "DeclareModule" === e.type || "DeclareModuleExports" === e.type || "DeclareVariable" === e.type || "DoWhileStatement" === e.type || "EnumDeclaration" === e.type || "ExportAllDeclaration" === e.type || "ExportDefaultDeclaration" === e.type || "ExportNamedDeclaration" === e.type || "ExpressionStatement" === e.type || "ForInStatement" === e.type || "ForOfStatement" === e.type || "ForStatement" === e.type || "FunctionDeclaration" === e.type || "IfStatement" === e.type || "ImportDeclaration" === e.type || "InterfaceDeclaration" === e.type || "LabeledStatement" === e.type || "MethodDefinition" === e.type || "ReturnStatement" === e.type || "SwitchStatement" === e.type || "ThrowStatement" === e.type || "TryStatement" === e.type || "TSDeclareFunction" === e.type || "TSEnumDeclaration" === e.type || "TSImportEqualsDeclaration" === e.type || "TSInterfaceDeclaration" === e.type || "TSModuleDeclaration" === e.type || "TSNamespaceExportDeclaration" === e.type || "TypeAlias" === e.type || "VariableDeclaration" === e.type || "WhileStatement" === e.type || "WithStatement" === e.type; }(o))
                return !1; if ("flow" !== t.parser && ay(e.getValue()))
                return !0; if ("Identifier" === o.type)
                return !!(o.extra && o.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(o.name)); if ("ParenthesizedExpression" === n.type)
                return !1; if (!("ClassDeclaration" !== n.type && "ClassExpression" !== n.type || n.superClass !== o || "ArrowFunctionExpression" !== o.type && "AssignmentExpression" !== o.type && "AwaitExpression" !== o.type && "BinaryExpression" !== o.type && "ConditionalExpression" !== o.type && "LogicalExpression" !== o.type && "NewExpression" !== o.type && "ObjectExpression" !== o.type && "ParenthesizedExpression" !== o.type && "SequenceExpression" !== o.type && "TaggedTemplateExpression" !== o.type && "UnaryExpression" !== o.type && "UpdateExpression" !== o.type && "YieldExpression" !== o.type))
                return !0; if ("ExportDefaultDeclaration" === n.type)
                return fy(e, t) || "SequenceExpression" === o.type; if ("Decorator" === n.type && n.expression === o) {
                let e = !1, t = !1, n = o;
                for (; n;)
                    switch (n.type) {
                        case "MemberExpression":
                            t = !0, n = n.object;
                            break;
                        case "CallExpression":
                            if (t || e)
                                return !0;
                            e = !0, n = n.callee;
                            break;
                        case "Identifier": return !1;
                        default: return !0;
                    }
                return !0;
            } if ("ArrowFunctionExpression" === n.type && n.body === o && "SequenceExpression" !== o.type && ls.startsWithNoLookaheadToken(o, !1) || "ExpressionStatement" === n.type && ls.startsWithNoLookaheadToken(o, !0))
                return !0; switch (o.type) {
                case "SpreadElement":
                case "SpreadProperty": return "MemberExpression" === n.type && "object" === r && n.object === o;
                case "UpdateExpression": if ("UnaryExpression" === n.type)
                    return o.prefix && ("++" === o.operator && "+" === n.operator || "--" === o.operator && "-" === n.operator);
                case "UnaryExpression": switch (n.type) {
                    case "UnaryExpression": return o.operator === n.operator && ("+" === o.operator || "-" === o.operator);
                    case "BindExpression":
                    case "TaggedTemplateExpression":
                    case "TSNonNullExpression": return !0;
                    case "MemberExpression":
                    case "OptionalMemberExpression": return "object" === r;
                    case "NewExpression":
                    case "CallExpression":
                    case "OptionalCallExpression": return "callee" === r;
                    case "BinaryExpression": return "**" === n.operator && "left" === r;
                    default: return !1;
                }
                case "BinaryExpression": {
                    if ("UpdateExpression" === n.type)
                        return !0;
                    const t = t => { let n = 0; for (; t;) {
                        const r = e.getParentNode(n++);
                        if (!r)
                            return !1;
                        if ("ForStatement" === r.type && r.init === t)
                            return !0;
                        t = r;
                    } return !1; };
                    if ("in" === o.operator && t(o))
                        return !0;
                }
                case "TSTypeAssertion":
                case "TSAsExpression":
                case "LogicalExpression": switch (n.type) {
                    case "ConditionalExpression": return "TSAsExpression" === o.type;
                    case "CallExpression":
                    case "NewExpression":
                    case "OptionalCallExpression": return "callee" === r;
                    case "ClassExpression":
                    case "ClassDeclaration": return "superClass" === r && n.superClass === o;
                    case "TSTypeAssertion":
                    case "TaggedTemplateExpression":
                    case "UnaryExpression":
                    case "JSXSpreadAttribute":
                    case "SpreadElement":
                    case "SpreadProperty":
                    case "BindExpression":
                    case "AwaitExpression":
                    case "TSAsExpression":
                    case "TSNonNullExpression":
                    case "UpdateExpression": return !0;
                    case "MemberExpression":
                    case "OptionalMemberExpression": return "object" === r;
                    case "AssignmentExpression": return n.left === o && ("TSTypeAssertion" === o.type || "TSAsExpression" === o.type);
                    case "LogicalExpression": if ("LogicalExpression" === o.type)
                        return n.operator !== o.operator;
                    case "BinaryExpression": {
                        if (!o.operator && "TSTypeAssertion" !== o.type)
                            return !0;
                        const e = n.operator, t = ls.getPrecedence(e), i = o.operator, s = ls.getPrecedence(i);
                        return t > s || (t === s && "right" === r ? (Ci.strictEqual(n.right, o), !0) : t === s && !ls.shouldFlatten(e, i) || (t < s && "%" === i ? "+" === e || "-" === e : !!ls.isBitwiseOperator(e)));
                    }
                    default: return !1;
                }
                case "SequenceExpression": switch (n.type) {
                    case "ReturnStatement":
                    case "ForStatement": return !1;
                    case "ExpressionStatement": return "expression" !== r;
                    case "ArrowFunctionExpression": return "body" !== r;
                    default: return !0;
                }
                case "YieldExpression": if ("UnaryExpression" === n.type || "AwaitExpression" === n.type || "TSAsExpression" === n.type || "TSNonNullExpression" === n.type)
                    return !0;
                case "AwaitExpression": switch (n.type) {
                    case "TaggedTemplateExpression":
                    case "UnaryExpression":
                    case "BinaryExpression":
                    case "LogicalExpression":
                    case "SpreadElement":
                    case "SpreadProperty":
                    case "TSAsExpression":
                    case "TSNonNullExpression":
                    case "BindExpression": return !0;
                    case "MemberExpression":
                    case "OptionalMemberExpression": return "object" === r;
                    case "NewExpression":
                    case "CallExpression":
                    case "OptionalCallExpression": return "callee" === r;
                    case "ConditionalExpression": return n.test === o;
                    default: return !1;
                }
                case "TSJSDocFunctionType":
                case "TSConditionalType": if ("TSConditionalType" === n.type && o === n.extendsType)
                    return !0;
                case "TSFunctionType":
                case "TSConstructorType": if ("TSConditionalType" === n.type && o === n.checkType)
                    return !0;
                case "TSUnionType":
                case "TSIntersectionType": if ("TSUnionType" === n.type || "TSIntersectionType" === n.type)
                    return !0;
                case "TSTypeOperator":
                case "TSInferType": return "TSArrayType" === n.type || "TSOptionalType" === n.type || "TSRestType" === n.type || "TSIndexedAccessType" === n.type && o === n.objectType || "TSTypeOperator" === n.type || "TSTypeAnnotation" === n.type && /^TSJSDoc/.test(e.getParentNode(1).type);
                case "ArrayTypeAnnotation": return "NullableTypeAnnotation" === n.type;
                case "IntersectionTypeAnnotation":
                case "UnionTypeAnnotation": return "ArrayTypeAnnotation" === n.type || "NullableTypeAnnotation" === n.type || "IntersectionTypeAnnotation" === n.type || "UnionTypeAnnotation" === n.type;
                case "NullableTypeAnnotation": return "ArrayTypeAnnotation" === n.type;
                case "FunctionTypeAnnotation": {
                    const t = "NullableTypeAnnotation" === n.type ? e.getParentNode(1) : n;
                    return "UnionTypeAnnotation" === t.type || "IntersectionTypeAnnotation" === t.type || "ArrayTypeAnnotation" === t.type || "NullableTypeAnnotation" === t.type;
                }
                case "StringLiteral":
                case "NumericLiteral":
                case "Literal":
                    if ("string" == typeof o.value && "ExpressionStatement" === n.type && ("typescript" !== t.parser && !n.directive || "typescript" === t.parser && "(" === t.originalText.charAt(t.locStart(o) - 1))) {
                        const t = e.getParentNode(1);
                        return "Program" === t.type || "BlockStatement" === t.type;
                    }
                    return "MemberExpression" === n.type && "number" == typeof o.value && "object" === r && n.object === o;
                case "AssignmentExpression": {
                    const t = e.getParentNode(1);
                    return !(("ArrowFunctionExpression" !== n.type || n.body !== o) && ("ClassProperty" === n.type && n.key === o && n.computed || "TSPropertySignature" === n.type && n.name === o || "ForStatement" === n.type && (n.init === o || n.update === o) || ("ExpressionStatement" === n.type ? "ObjectPattern" !== o.left.type : "TSPropertySignature" === n.type && n.key === o || "AssignmentExpression" === n.type || "SequenceExpression" === n.type && t && "ForStatement" === t.type && (t.init === n || t.update === n) || "Property" === n.type && n.value === o || "NGChainedExpression" === n.type)));
                }
                case "ConditionalExpression": switch (n.type) {
                    case "TaggedTemplateExpression":
                    case "UnaryExpression":
                    case "SpreadElement":
                    case "SpreadProperty":
                    case "BinaryExpression":
                    case "LogicalExpression":
                    case "NGPipeExpression":
                    case "ExportDefaultDeclaration":
                    case "AwaitExpression":
                    case "JSXSpreadAttribute":
                    case "TSTypeAssertion":
                    case "TypeCastExpression":
                    case "TSAsExpression":
                    case "TSNonNullExpression": return !0;
                    case "NewExpression":
                    case "CallExpression":
                    case "OptionalCallExpression": return "callee" === r;
                    case "ConditionalExpression": return "test" === r && n.test === o;
                    case "MemberExpression":
                    case "OptionalMemberExpression": return "object" === r;
                    default: return !1;
                }
                case "FunctionExpression": switch (n.type) {
                    case "NewExpression":
                    case "CallExpression":
                    case "OptionalCallExpression": return "callee" === r;
                    case "TaggedTemplateExpression": return !0;
                    default: return !1;
                }
                case "ArrowFunctionExpression": switch (n.type) {
                    case "NewExpression":
                    case "CallExpression":
                    case "OptionalCallExpression": return "callee" === r;
                    case "MemberExpression":
                    case "OptionalMemberExpression": return "object" === r;
                    case "TSAsExpression":
                    case "BindExpression":
                    case "TaggedTemplateExpression":
                    case "UnaryExpression":
                    case "LogicalExpression":
                    case "BinaryExpression":
                    case "AwaitExpression":
                    case "TSTypeAssertion": return !0;
                    case "ConditionalExpression": return "test" === r;
                    default: return !1;
                }
                case "ClassExpression": return "NewExpression" === n.type && "callee" === r && n.callee === o;
                case "OptionalMemberExpression":
                case "OptionalCallExpression": if ("MemberExpression" === n.type && "object" === r || ("CallExpression" === n.type || "NewExpression" === n.type) && "callee" === r)
                    return !0;
                case "CallExpression":
                case "MemberExpression":
                case "TaggedTemplateExpression":
                case "TSNonNullExpression":
                    if (("BindExpression" === n.type || "NewExpression" === n.type) && "callee" === r) {
                        let e = o;
                        for (; e;)
                            switch (e.type) {
                                case "CallExpression":
                                case "OptionalCallExpression": return !0;
                                case "MemberExpression":
                                case "OptionalMemberExpression":
                                case "BindExpression":
                                    e = e.object;
                                    break;
                                case "TaggedTemplateExpression":
                                    e = e.tag;
                                    break;
                                case "TSNonNullExpression":
                                    e = e.expression;
                                    break;
                                default: return !1;
                            }
                    }
                    return !1;
                case "BindExpression": return ("BindExpression" === n.type || "NewExpression" === n.type) && "callee" === r || ("MemberExpression" === n.type || "OptionalMemberExpression" === n.type) && "object" === r;
                case "NGPipeExpression": return !("NGRoot" === n.type || "NGMicrosyntaxExpression" === n.type || "ObjectProperty" === n.type || "ArrayExpression" === n.type || ("CallExpression" === n.type || "OptionalCallExpression" === n.type) && n.arguments[r] === o || "NGPipeExpression" === n.type && "right" === r || "MemberExpression" === n.type && "property" === r || "AssignmentExpression" === n.type);
                case "JSXFragment":
                case "JSXElement": return "callee" === r || "ArrayExpression" !== n.type && "ArrowFunctionExpression" !== n.type && "AssignmentExpression" !== n.type && "AssignmentPattern" !== n.type && "BinaryExpression" !== n.type && "CallExpression" !== n.type && "NewExpression" !== n.type && "ConditionalExpression" !== n.type && "ExpressionStatement" !== n.type && "JsExpressionRoot" !== n.type && "JSXAttribute" !== n.type && "JSXElement" !== n.type && "JSXExpressionContainer" !== n.type && "JSXFragment" !== n.type && "LogicalExpression" !== n.type && "ObjectProperty" !== n.type && "OptionalCallExpression" !== n.type && "Property" !== n.type && "ReturnStatement" !== n.type && "ThrowStatement" !== n.type && "TypeCastExpression" !== n.type && "VariableDeclarator" !== n.type && "YieldExpression" !== n.type;
                case "TypeAnnotation": return "returnType" === r && "ArrowFunctionExpression" === n.type && function (e) { return cy(e, (e => "ObjectTypeAnnotation" === e.type && cy(e, (e => "FunctionTypeAnnotation" === e.type || void 0)) || void 0)); }(o);
            } return !1; } function py(e) { const t = e.getValue(), n = e.getParentNode(), r = e.getName(); switch (n.type) {
                case "NGPipeExpression":
                    if ("number" == typeof r && n.arguments[r] === t && n.arguments.length - 1 === r)
                        return e.callParent(py);
                    break;
                case "ObjectProperty":
                    if ("value" === r) {
                        const t = e.getParentNode(1);
                        return t.properties[t.properties.length - 1] === n;
                    }
                    break;
                case "BinaryExpression":
                case "LogicalExpression":
                    if ("right" === r)
                        return e.callParent(py);
                    break;
                case "ConditionalExpression":
                    if ("alternate" === r)
                        return e.callParent(py);
                    break;
                case "UnaryExpression": if (n.prefix)
                    return e.callParent(py);
            } return !1; } function fy(e, t) { const n = e.getValue(), r = e.getParentNode(); return "FunctionExpression" === n.type || "ClassExpression" === n.type ? "ExportDefaultDeclaration" === r.type || !ly(e, t) : !(!uy(n) || "ExportDefaultDeclaration" !== r.type && ly(e, t)) && e.call((e => fy(e, t)), ...sy(e, n)); } var dy = ly; const { builders: { concat: hy, join: my, line: gy } } = Ps; var yy = { isVueEventBindingExpression: function e(t) { switch (t.type) {
                    case "MemberExpression":
                        switch (t.property.type) {
                            case "Identifier":
                            case "NumericLiteral":
                            case "StringLiteral": return e(t.object);
                        }
                        return !1;
                    case "Identifier": return !0;
                    default: return !1;
                } }, printHtmlBinding: function (e, t, n) { const r = e.getValue(); if (t.__onHtmlBindingRoot && null === e.getName() && t.__onHtmlBindingRoot(r, t), "File" === r.type)
                    return t.__isVueForBindingLeft ? e.call((e => { const { params: t } = e.getValue(); return hy([t.length > 1 ? "(" : "", my(hy([",", gy]), e.map(n, "params")), t.length > 1 ? ")" : ""]); }), "program", "body", 0) : t.__isVueSlotScope ? e.call((e => my(hy([",", gy]), e.map(n, "params"))), "program", "body", 0) : void 0; } }, vy = function (e, t) { switch (t.parser) {
                case "json":
                case "json5":
                case "json-stringify":
                case "__js_expression":
                case "__vue_expression": return Object.assign({}, e, { type: t.parser.startsWith("__") ? "JsExpressionRoot" : "JsonRoot", node: e, comments: [], rootMarker: t.rootMarker });
                default: return e;
            } }; const { shouldFlatten: by, getNextNonSpaceNonCommentCharacter: Dy, hasNewline: Ey, hasNewlineInRange: Cy, getLast: wy, getStringWidth: Ay, printString: Sy, printNumber: xy, hasIgnoreComment: Ty, hasNodeIgnoreComment: ky, getPenultimate: Fy, startsWithNoLookaheadToken: Oy, getIndentSize: _y, getPreferredQuote: Ny } = ls, { isNextLineEmpty: Py, isNextLineEmptyAfterIndex: My, getNextNonSpaceNonCommentCharacterIndex: Ry } = ra, { insertPragma: Iy } = cu, { printHtmlBinding: jy, isVueEventBindingExpression: By } = yy, { classChildNeedsASIProtection: Ly, classPropMayCauseASIProblems: qy, conditionalExpressionChainContainsJSX: $y, getFlowVariance: Uy, getLeftSidePathName: Vy, getParentExportDeclaration: Wy, getTypeScriptMappedTypeModifier: Ky, hasDanglingComments: zy, hasFlowAnnotationComment: Hy, hasFlowShorthandAnnotationComment: Yy, hasLeadingComment: Jy, hasLeadingOwnLineComment: Gy, hasNakedLeftSide: Xy, hasNewlineBetweenOrAfterDecorators: Qy, hasNgSideEffect: Zy, hasPrettierIgnore: ev, hasTrailingComment: tv, identity: nv, isBinaryish: rv, isCallOrOptionalCallExpression: ov, isEmptyJSXElement: iv, isExportDeclaration: sv, isFlowAnnotationComment: av, isFunctionCompositionArgs: uv, isFunctionNotation: cv, isFunctionOrArrowExpression: lv, isGetterOrSetter: pv, isJestEachTemplateLiteral: fv, isJSXNode: dv, isJSXWhitespaceExpression: hv, isLastStatement: mv, isLiteral: gv, isLongCurriedCallExpression: yv, isMeaningfulJSXText: vv, isMemberExpressionChain: bv, isMemberish: Dv, isNgForOf: Ev, isNumericLiteral: Cv, isObjectType: wv, isObjectTypePropertyAFunction: Av, isSimpleCallArgument: Sv, isSimpleFlowType: xv, isSimpleTemplateLiteral: Tv, isStringLiteral: kv, isStringPropSafeToCoerceToIdentifier: Fv, isTemplateOnItsOwnLine: Ov, isTestCall: _v, isTheOnlyJSXElementInMarkdown: Nv, isTSXFile: Pv, isTypeAnnotationAFunction: Mv, matchJsxWhitespaceRegex: Rv, needsHardlineAfterDanglingComment: Iv, rawText: jv, returnArgumentHasLeadingComment: Bv } = iy, Lv = new WeakMap, { builders: { concat: qv, join: $v, line: Uv, hardline: Vv, softline: Wv, literalline: Kv, group: zv, indent: Hv, align: Yv, conditionalGroup: Jv, fill: Gv, ifBreak: Xv, breakParent: Qv, lineSuffixBoundary: Zv, addAlignmentToDoc: eb, dedent: tb }, utils: { willBreak: nb, isLineNext: rb, isEmpty: ob, removeLines: ib }, printer: { printDocToString: sb } } = Ps; let ab = 0; function ub(e, t) { switch (t = t || "es5", e.trailingComma) {
                case "all": if ("all" === t)
                    return !0;
                case "es5": if ("es5" === t)
                    return !0;
                default: return !1;
            } } function cb(e, t, n) { const r = e.getValue(); return zv(qv([$v(Uv, e.map(n, "decorators")), Qy(r, t) ? Vv : Uv])); } function lb(e, t, n, r) { const o = e.getValue(), i = o[r.consequentNodePropertyName], s = o[r.alternateNodePropertyName], a = []; let u = !1; const c = e.getParentNode(), l = c.type === r.conditionalNodeType && r.testNodePropertyNames.some((e => c[e] === o)); let p, f, d = c.type === r.conditionalNodeType && !l, h = 0; do {
                f = p || o, p = e.getParentNode(h), h++;
            } while (p && p.type === r.conditionalNodeType && r.testNodePropertyNames.every((e => p[e] !== f))); const m = p || c, g = f; if (r.shouldCheckJsx && (dv(o[r.testNodePropertyNames[0]]) || dv(i) || dv(s) || $y(g))) {
                u = !0, d = !0;
                const t = e => qv([Xv("(", ""), Hv(qv([Wv, e])), Wv, Xv(")", "")]), o = e => "NullLiteral" === e.type || "Literal" === e.type && null === e.value || "Identifier" === e.type && "undefined" === e.name;
                a.push(" ? ", o(i) ? e.call(n, r.consequentNodePropertyName) : t(e.call(n, r.consequentNodePropertyName)), " : ", s.type === r.conditionalNodeType || o(s) ? e.call(n, r.alternateNodePropertyName) : t(e.call(n, r.alternateNodePropertyName)));
            }
            else {
                const u = qv([Uv, "? ", i.type === r.conditionalNodeType ? Xv("", "(") : "", Yv(2, e.call(n, r.consequentNodePropertyName)), i.type === r.conditionalNodeType ? Xv("", ")") : "", Uv, ": ", s.type === r.conditionalNodeType ? e.call(n, r.alternateNodePropertyName) : Yv(2, e.call(n, r.alternateNodePropertyName))]);
                a.push(c.type !== r.conditionalNodeType || c[r.alternateNodePropertyName] === o || l ? u : t.useTabs ? tb(Hv(u)) : Yv(Math.max(0, t.tabWidth - 2), u));
            } const y = !u && ("MemberExpression" === c.type || "OptionalMemberExpression" === c.type || "NGPipeExpression" === c.type && c.left === o) && !c.computed, v = (b = qv([].concat((D = qv(r.beforeParts()), c.type === r.conditionalNodeType && c[r.alternateNodePropertyName] === o ? Yv(2, D) : D), d ? qv(a) : Hv(qv(a)), r.afterParts(y))), c === m ? zv(b) : b); var b, D; return l ? zv(qv([Hv(qv([Wv, v])), Wv])) : v; } function pb(e, t, n) { const r = [], o = e.getNode(), i = "ClassBody" === o.type; return e.map(((e, s) => { const a = e.getValue(); if (!a)
                return; if ("EmptyStatement" === a.type)
                return; const u = n(e), c = t.originalText, l = []; if (t.semi || i || Nv(t, e) || !function (e, t) { return "ExpressionStatement" === e.getNode().type && e.call((e => qb(e, t)), "expression"); }(e, t) ? l.push(u) : a.comments && a.comments.some((e => e.leading)) ? l.push(n(e, { needsSemi: !0 })) : l.push(";", u), !t.semi && i)
                if (qy(e))
                    l.push(";");
                else if ("ClassProperty" === a.type) {
                    const e = o.body[s + 1];
                    Ly(e) && l.push(";");
                } Py(c, a, t.locEnd) && !mv(e) && l.push(Vv), r.push(qv(l)); })), $v(Vv, r); } function fb(e, t, n) { const r = e.getNode(); if (r.computed)
                return qv(["[", e.call(n, "key"), "]"]); const o = e.getParentNode(), { key: i } = r; if ("ClassPrivateProperty" === r.type && "Identifier" === i.type)
                return qv(["#", e.call(n, "key")]); if ("consistent" === t.quoteProps && !Lv.has(o)) {
                const e = (o.properties || o.body || o.members).some((e => !e.computed && e.key && kv(e.key) && !Fv(e, t)));
                Lv.set(o, e);
            } if ("Identifier" === i.type && ("json" === t.parser || "consistent" === t.quoteProps && Lv.get(o))) {
                const n = Sy(JSON.stringify(i.name), t);
                return e.call((e => Sa.printComments(e, (() => n), t)), "key");
            } return Fv(r, t) && ("as-needed" === t.quoteProps || "consistent" === t.quoteProps && !Lv.get(o)) ? e.call((e => Sa.printComments(e, (() => i.value), t)), "key") : e.call(n, "key"); } function db(e, t, n) { const r = e.getNode(), { kind: o } = r, i = r.value || r, s = []; return o && "init" !== o && "method" !== o && "constructor" !== o ? (Ci.ok("get" === o || "set" === o), s.push(o, " ")) : (i.async && s.push("async "), i.generator && s.push("*")), s.push(fb(e, t, n), r.optional || r.key.optional ? "?" : "", r === i ? hb(e, t, n) : e.call((e => hb(e, t, n)), "value")), qv(s); } function hb(e, t, n) { const r = [vb(e, 0, n), zv(qv([bb(e, n, t), Cb(e, n, t)]))]; return e.getNode().body ? r.push(" ", e.call(n, "body")) : r.push(t.semi ? ";" : ""), qv(r); } function mb(e) { return "ObjectExpression" === e.type && (e.properties.length > 0 || e.comments) || "ArrayExpression" === e.type && (e.elements.length > 0 || e.comments) || "TSTypeAssertion" === e.type && mb(e.expression) || "TSAsExpression" === e.type && mb(e.expression) || "FunctionExpression" === e.type || "ArrowFunctionExpression" === e.type && (!e.returnType || !e.returnType.typeAnnotation || "TSTypeReference" !== e.returnType.typeAnnotation.type) && ("BlockStatement" === e.body.type || "ArrowFunctionExpression" === e.body.type || "ObjectExpression" === e.body.type || "ArrayExpression" === e.body.type || "CallExpression" === e.body.type || "OptionalCallExpression" === e.body.type || "ConditionalExpression" === e.body.type || dv(e.body)); } function gb(e, t, n) { const r = e.getValue(), o = r.arguments; if (0 === o.length)
                return qv(["(", Sa.printDanglingComments(e, t, !0), ")"]); if (2 === o.length && "ArrowFunctionExpression" === o[0].type && 0 === o[0].params.length && "BlockStatement" === o[0].body.type && "ArrayExpression" === o[1].type && !o.find((e => e.comments)))
                return qv(["(", e.call(n, "arguments", 0), ", ", e.call(n, "arguments", 1), ")"]); let i = !1, s = !1, a = !1; const u = o.length - 1, c = e.map(((e, r) => { const o = e.getNode(), c = [n(e)]; return r === u || (Py(t.originalText, o, t.locEnd) ? (0 === r && (a = !0), i = !0, c.push(",", Vv, Vv)) : c.push(",", Uv)), s = function (e, t) { if (!e || "ArrowFunctionExpression" !== e.type || !e.body || "BlockStatement" !== e.body.type || !e.params || e.params.length < 1)
                return !1; let r = !1; return t.each((e => { const t = qv([n(e)]); r = r || nb(t); }), "params"), r; }(o, e), qv(c); }), "arguments"), l = r.callee && "Import" === r.callee.type || !ub(t, "all") ? "" : ","; function p() { return zv(qv(["(", Hv(qv([Uv, qv(c)])), l, Uv, ")"]), { shouldBreak: !0 }); } if ("Decorator" !== e.getParentNode().type && uv(o))
                return p(); const f = function (e) { if (2 !== e.length)
                return !1; const [t, n] = e; return !(t.comments && t.comments.length || "FunctionExpression" !== t.type && ("ArrowFunctionExpression" !== t.type || "BlockStatement" !== t.body.type) || "FunctionExpression" === n.type || "ArrowFunctionExpression" === n.type || "ConditionalExpression" === n.type || mb(n)); }(o), d = function (e) { const t = wy(e), n = Fy(e); return !Jy(t) && !tv(t) && mb(t) && (!n || n.type !== t.type); }(o); if (f || d) {
                const t = (f ? c.slice(1).some(nb) : c.slice(0, -1).some(nb)) || i || s;
                let u, l = 0;
                e.each((e => { f && 0 === l && (u = [qv([e.call((e => n(e, { expandFirstArg: !0 }))), c.length > 1 ? "," : "", a ? Vv : Uv, a ? Vv : ""])].concat(c.slice(1))), d && l === o.length - 1 && (u = c.slice(0, -1).concat(e.call((e => n(e, { expandLastArg: !0 }))))), l++; }), "arguments");
                const h = c.some(nb), m = qv(["(", qv(u), ")"]);
                return qv([h ? Qv : "", Jv([h || r.typeArguments || r.typeParameters ? Xv(p(), m) : m, qv(f ? ["(", zv(u[0], { shouldBreak: !0 }), qv(u.slice(1)), ")"] : ["(", qv(c.slice(0, -1)), zv(wy(u), { shouldBreak: !0 }), ")"]), p()], { shouldBreak: t })]);
            } const h = qv(["(", Hv(qv([Wv, qv(c)])), Xv(l), Wv, ")"]); return yv(e) ? h : zv(h, { shouldBreak: c.some(nb) || i }); } function yb(e, t, n) { const r = e.getValue(); if (!r.typeAnnotation)
                return ""; const o = e.getParentNode(), i = r.definite || o && "VariableDeclarator" === o.type && o.definite, s = "DeclareFunction" === o.type && o.id === r; return av(t.originalText, r.typeAnnotation, t) ? qv([" /*: ", e.call(n, "typeAnnotation"), " */"]) : qv([s ? "" : i ? "!: " : ": ", e.call(n, "typeAnnotation")]); } function vb(e, t, n) { const r = e.getValue(); return r.typeArguments ? e.call(n, "typeArguments") : r.typeParameters ? e.call(n, "typeParameters") : ""; } function bb(e, t, n, r, o) { const i = e.getValue(), s = e.getParentNode(), a = i.parameters ? "parameters" : "params", u = _v(s), c = Ub(i), l = r && !(i[a] && i[a].some((e => e.comments))), p = o ? vb(e, 0, t) : ""; let f = []; if (i[a]) {
                const r = i[a].length - 1;
                f = e.map(((e, o) => { const s = [], a = e.getValue(); return s.push(t(e)), o === r ? i.rest && s.push(",", Uv) : u || c || l ? s.push(", ") : Py(n.originalText, a, n.locEnd) ? s.push(",", Vv, Vv) : s.push(",", Uv), qv(s); }), a);
            } if (i.rest && f.push(qv(["...", e.call(t, "rest")])), 0 === f.length)
                return qv([p, "(", Sa.printDanglingComments(e, n, !0, (e => ")" === Dy(n.originalText, e, n.locEnd))), ")"]); const d = wy(i[a]); if (l)
                return zv(qv([ib(p), "(", qv(f.map(ib)), ")"])); const h = i[a].every((e => !e.decorators)); if (c && h)
                return qv([p, "(", qv(f), ")"]); if (u)
                return qv([p, "(", qv(f), ")"]); if ((Av(s, n) || Mv(s, n) || "TypeAlias" === s.type || "UnionTypeAnnotation" === s.type || "TSUnionType" === s.type || "IntersectionTypeAnnotation" === s.type || "FunctionTypeAnnotation" === s.type && s.returnType === i) && 1 === i[a].length && null === i[a][0].name && i[a][0].typeAnnotation && null === i.typeParameters && xv(i[a][0].typeAnnotation) && !i.rest)
                return "always" === n.arrowParens ? qv(["(", qv(f), ")"]) : qv(f); const m = !(d && "RestElement" === d.type || i.rest); return qv([p, "(", Hv(qv([Wv, qv(f)])), Xv(m && ub(n, "all") ? "," : ""), Wv, ")"]); } function Db(e, t) { return "always" !== t.arrowParens && "avoid" === t.arrowParens && !(1 !== (n = e.getValue()).params.length || n.rest || n.typeParameters || zy(n) || "Identifier" !== n.params[0].type || n.params[0].typeAnnotation || n.params[0].comments || n.params[0].optional || n.predicate || n.returnType); var n; } function Eb(e, t, n) { const r = e.getValue(), o = []; return r.async && o.push("async "), r.generator ? o.push("function* ") : o.push("function "), r.id && o.push(e.call(t, "id")), o.push(vb(e, 0, t), zv(qv([bb(e, t, n), Cb(e, t, n)])), r.body ? " " : "", e.call(t, "body")), qv(o); } function Cb(e, t, n) { const r = e.getValue(), o = e.call(t, "returnType"); if (r.returnType && av(n.originalText, r.returnType, n))
                return qv([" /*: ", o, " */"]); const i = [o]; return r.returnType && r.returnType.typeAnnotation && i.unshift(": "), r.predicate && i.push(r.returnType ? " " : ": ", e.call(t, "predicate")), qv(i); } function wb(e, t, n) { const r = e.getValue(), o = t.semi ? ";" : "", i = ["export "], s = r.default || "ExportDefaultDeclaration" === r.type; if (s && i.push("default "), i.push(Sa.printDanglingComments(e, t, !0)), Iv(r) && i.push(Vv), r.declaration)
                i.push(e.call(n, "declaration")), s && "ClassDeclaration" !== r.declaration.type && "FunctionDeclaration" !== r.declaration.type && "TSInterfaceDeclaration" !== r.declaration.type && "DeclareClass" !== r.declaration.type && "DeclareFunction" !== r.declaration.type && "TSDeclareFunction" !== r.declaration.type && i.push(o);
            else {
                if (r.specifiers && r.specifiers.length > 0) {
                    const o = [], s = [], a = [];
                    e.each((t => { const r = e.getValue().type; "ExportSpecifier" === r ? o.push(n(t)) : "ExportDefaultSpecifier" === r ? s.push(n(t)) : "ExportNamespaceSpecifier" === r && a.push(qv(["* as ", n(t)])); }), "specifiers");
                    const u = 0 !== a.length && 0 !== o.length, c = 0 !== s.length && (0 !== a.length || 0 !== o.length), l = o.length > 1 || s.length > 0 || r.specifiers && r.specifiers.some((e => e.comments));
                    let p = "";
                    0 !== o.length && (p = l ? zv(qv(["{", Hv(qv([t.bracketSpacing ? Uv : Wv, $v(qv([",", Uv]), o)])), Xv(ub(t) ? "," : ""), t.bracketSpacing ? Uv : Wv, "}"])) : qv(["{", t.bracketSpacing ? " " : "", qv(o), t.bracketSpacing ? " " : "", "}"])), i.push("type" === r.exportKind ? "type " : "", qv(s), qv([c ? ", " : ""]), qv(a), qv([u ? ", " : ""]), p);
                }
                else
                    i.push("{}");
                r.source && i.push(" from ", e.call(n, "source")), i.push(o);
            } return qv(i); } function Ab(e, t) { const n = Wy(e); return n ? Ci.strictEqual(n.type, "DeclareExportDeclaration") : t.unshift("declare "), qv(t); } function Sb(e, t, n) { const r = e.getValue(); return r.modifiers && r.modifiers.length ? qv([$v(" ", e.map(n, "modifiers")), " "]) : ""; } function xb(e, t, n, r) { const o = e.getValue(); if (!o[r])
                return ""; if (!Array.isArray(o[r]))
                return e.call(n, r); const i = e.getNode(2), s = e.getNode(3), a = e.getNode(4); return null != i && _v(i) || 0 === o[r].length || 1 === o[r].length && ($b(o[r][0]) || "GenericTypeAnnotation" === o[r][0].type && $b(o[r][0].id) || "TSTypeReference" === o[r][0].type && $b(o[r][0].typeName) || "NullableTypeAnnotation" === o[r][0].type || a && "VariableDeclarator" === a.type && "TSTypeAnnotation" === i.type && "ArrowFunctionExpression" !== s.type && "TSUnionType" !== o[r][0].type && "UnionTypeAnnotation" !== o[r][0].type && "TSIntersectionType" !== o[r][0].type && "IntersectionTypeAnnotation" !== o[r][0].type && "TSConditionalType" !== o[r][0].type && "TSMappedType" !== o[r][0].type && "TSTypeOperator" !== o[r][0].type && "TSIndexedAccessType" !== o[r][0].type && "TSArrayType" !== o[r][0].type) ? qv(["<", $v(", ", e.map(n, r)), function (n) { if (!zy(n))
                    return ""; const r = n.comments.every(tg.isBlockComment), o = Sa.printDanglingComments(e, t, r); return r ? o : qv([o, Vv]); }(o), ">"]) : zv(qv(["<", Hv(qv([Wv, $v(qv([",", Uv]), e.map(n, r))])), Xv("typescript" !== t.parser && "babel-ts" !== t.parser && ub(t, "all") ? "," : ""), Wv, ">"])); } function Tb(e, t, n) { const r = e.getValue(), o = []; r.abstract && o.push("abstract "), o.push("class"), r.id && o.push(" ", e.call(n, "id")), o.push(e.call(n, "typeParameters")); const i = []; if (r.superClass) {
                const s = qv(["extends ", e.call(n, "superClass"), e.call(n, "superTypeParameters")]);
                r.implements && 0 !== r.implements.length || r.superClass.comments && 0 !== r.superClass.comments.length ? i.push(zv(qv([Uv, e.call((e => Sa.printComments(e, (() => s), t)), "superClass")]))) : o.push(qv([" ", e.call((e => Sa.printComments(e, (() => s), t)), "superClass")]));
            }
            else
                r.extends && r.extends.length > 0 && o.push(" extends ", $v(", ", e.map(n, "extends"))); return r.mixins && r.mixins.length > 0 && i.push(Uv, "mixins ", zv(Hv($v(qv([",", Uv]), e.map(n, "mixins"))))), r.implements && r.implements.length > 0 && i.push(Uv, "implements", zv(Hv(qv([Uv, $v(qv([",", Uv]), e.map(n, "implements"))])))), i.length > 0 && o.push(zv(Hv(qv(i)))), r.body && r.body.comments && Gy(t.originalText, r.body, t) ? o.push(Vv) : o.push(" "), o.push(e.call(n, "body")), o; } function kb(e) { const t = e.getValue(); return !t.optional || "Identifier" === t.type && t === e.getParentNode().key ? "" : "OptionalCallExpression" === t.type || "OptionalMemberExpression" === t.type && t.computed ? "?." : "?"; } function Fb(e, t, n) { const r = e.call(n, "property"), o = e.getValue(), i = kb(e); return o.computed ? !o.property || Cv(o.property) ? qv([i, "[", r, "]"]) : zv(qv([i, "[", Hv(qv([Wv, r])), Wv, "]"])) : qv([i, ".", r]); } function Ob(e, t, n) { return qv(["::", e.call(n, "callee")]); } function _b(e, t, n, r) { return e ? "" : "JSXElement" === n.type && !n.closingElement || r && "JSXElement" === r.type && !r.closingElement ? 1 === t.length ? Wv : Vv : Wv; } function Nb(e, t, n, r) { return e ? Vv : 1 === t.length ? "JSXElement" === n.type && !n.closingElement || r && "JSXElement" === r.type && !r.closingElement ? Vv : Wv : Vv; } function Pb(e) { return "LogicalExpression" === e.type && ("ObjectExpression" === e.right.type && 0 !== e.right.properties.length || "ArrayExpression" === e.right.type && 0 !== e.right.elements.length || !!dv(e.right)); } function Mb(e, t, n, r, o) { let i = []; const s = e.getValue(); if (rv(s)) {
                by(s.operator, s.left.operator) ? i = i.concat(e.call((e => Mb(e, t, n, !0, o)), "left")) : i.push(e.call(t, "left"));
                const a = Pb(s), u = ("|>" === s.operator || "NGPipeExpression" === s.type || "|" === s.operator && "__vue_expression" === n.parser) && !Gy(n.originalText, s.right, n), c = "NGPipeExpression" === s.type ? "|" : s.operator, l = "NGPipeExpression" === s.type && 0 !== s.arguments.length ? zv(Hv(qv([Wv, ": ", $v(qv([Wv, ":", Xv(" ")]), e.map(t, "arguments").map((e => Yv(2, zv(e)))))]))) : "", p = qv(a ? [c, " ", e.call(t, "right"), l] : [u ? Wv : "", c, u ? " " : Uv, e.call(t, "right"), l]), f = e.getParentNode(), d = !(o && "LogicalExpression" === s.type) && f.type !== s.type && s.left.type !== s.type && s.right.type !== s.type;
                i.push(" ", d ? zv(p) : p), r && s.comments && (i = Sa.printComments(e, (() => qv(i)), n));
            }
            else
                i.push(e.call(t)); return i; } function Rb(e, t, n, r) { return Gy(r.originalText, t, r) ? Hv(qv([Uv, n])) : rv(t) && !Pb(t) || "ConditionalExpression" === t.type && rv(t.test) && !Pb(t.test) || "StringLiteralTypeAnnotation" === t.type || "ClassExpression" === t.type && t.decorators && t.decorators.length || ("Identifier" === e.type || kv(e) || "MemberExpression" === e.type) && (kv(t) || bv(t)) && "json" !== r.parser && "json5" !== r.parser || "SequenceExpression" === t.type ? zv(Hv(qv([Uv, n]))) : qv([" ", n]); } function Ib(e, t, n, r, o, i) { if (!r)
                return t; const s = Rb(e, r, o, i); return zv(qv([t, n, s])); } function jb(e, t, n) { return "EmptyStatement" === e.type ? ";" : "BlockStatement" === e.type || n ? qv([" ", t]) : Hv(qv([Uv, t])); } function Bb(e, t, n) { const r = jv(e), o = n || "DirectiveLiteral" === e.type; return Sy(r, t, o); } function Lb(e) { const t = e.flags.split("").sort().join(""); return "/".concat(e.pattern, "/").concat(t); } function qb(e, t) { const n = e.getValue(); return !!(dy(e, t) || "ParenthesizedExpression" === n.type || "TypeCastExpression" === n.type || "ArrowFunctionExpression" === n.type && !Db(e, t) || "ArrayExpression" === n.type || "ArrayPattern" === n.type || "UnaryExpression" === n.type && n.prefix && ("+" === n.operator || "-" === n.operator) || "TemplateLiteral" === n.type || "TemplateElement" === n.type || dv(n) || "BindExpression" === n.type && !n.object || "RegExpLiteral" === n.type || "Literal" === n.type && n.pattern || "Literal" === n.type && n.regex) || !!Xy(n) && e.call((e => qb(e, t)), ...Vy(e, n)); } function $b(e) { if (xv(e) || wv(e))
                return !0; if ("UnionTypeAnnotation" === e.type || "TSUnionType" === e.type) {
                const t = e.types.filter((e => "VoidTypeAnnotation" === e.type || "TSVoidKeyword" === e.type || "NullLiteralTypeAnnotation" === e.type || "TSNullKeyword" === e.type)).length, n = e.types.some((e => "ObjectTypeAnnotation" === e.type || "TSTypeLiteral" === e.type || "GenericTypeAnnotation" === e.type || "TSTypeReference" === e.type));
                if (e.types.length - 1 === t && n)
                    return !0;
            } return !1; } function Ub(e) { if (!e || e.rest)
                return !1; const t = e.params || e.parameters; if (!t || 1 !== t.length)
                return !1; const n = t[0]; return !n.comments && ("ObjectPattern" === n.type || "ArrayPattern" === n.type || "Identifier" === n.type && n.typeAnnotation && ("TypeAnnotation" === n.typeAnnotation.type || "TSTypeAnnotation" === n.typeAnnotation.type) && wv(n.typeAnnotation.typeAnnotation) || "FunctionTypeParam" === n.type && wv(n.typeAnnotation) || "AssignmentPattern" === n.type && ("ObjectPattern" === n.left.type || "ArrayPattern" === n.left.type) && ("Identifier" === n.right.type || "ObjectExpression" === n.right.type && 0 === n.right.properties.length || "ArrayExpression" === n.right.type && 0 === n.right.elements.length)); } function Vb(e, t, n, r) { const o = []; let i = []; return e.each((e => { o.push(qv(i)), o.push(zv(r(e))), i = [",", Uv], e.getValue() && Py(t.originalText, e.getValue(), t.locEnd) && i.push(Wv); }), n), qv(o); } function Wb(e, t, n) { const r = e.getValue(), o = t.semi ? ";" : "", i = []; r.argument && (Bv(t, r.argument) ? i.push(qv([" (", Hv(qv([Vv, e.call(n, "argument")])), Vv, ")"])) : rv(r.argument) || "SequenceExpression" === r.argument.type ? i.push(zv(qv([Xv(" (", " "), Hv(qv([Wv, e.call(n, "argument")])), Wv, Xv(")")]))) : i.push(" ", e.call(n, "argument"))); const s = Array.isArray(r.comments) && r.comments[r.comments.length - 1], a = s && ("CommentLine" === s.type || "Line" === s.type); return a && i.push(o), zy(r) && i.push(" ", Sa.printDanglingComments(e, t, !0)), a || i.push(o), qv(i); } var Kb = { preprocess: vy, print: function (e, t, n, r) { const o = e.getValue(); let i = !1; const s = function (e, t, n, r) { const o = e.getValue(), i = t.semi ? ";" : ""; if (!o)
                    return ""; if ("string" == typeof o)
                    return o; const s = jy(e, t, n); if (s)
                    return s; let a = []; switch (o.type) {
                    case "JsExpressionRoot": return e.call(n, "node");
                    case "JsonRoot": return qv([e.call(n, "node"), Vv]);
                    case "File": return o.program && o.program.interpreter && a.push(e.call((e => e.call(n, "interpreter")), "program")), a.push(e.call(n, "program")), qv(a);
                    case "Program": return o.directives && e.each((e => { a.push(n(e), i, Vv), Py(t.originalText, e.getValue(), t.locEnd) && a.push(Vv); }), "directives"), a.push(e.call((e => pb(e, t, n)), "body")), a.push(Sa.printDanglingComments(e, t, !0)), o.body.every((({ type: e }) => "EmptyStatement" === e)) && !o.comments || a.push(Vv), qv(a);
                    case "EmptyStatement":
                    case "NGEmptyExpression": return "";
                    case "ExpressionStatement":
                        if (o.directive)
                            return qv([Bb(o.expression, t, !0), i]);
                        if ("__vue_event_binding" === t.parser) {
                            const t = e.getParentNode();
                            if ("Program" === t.type && 1 === t.body.length && t.body[0] === o)
                                return qv([e.call(n, "expression"), By(o.expression) ? ";" : ""]);
                        }
                        return qv([e.call(n, "expression"), Nv(t, e) ? "" : i]);
                    case "ParenthesizedExpression": return o.expression.comments ? zv(qv(["(", Hv(qv([Wv, e.call(n, "expression")])), Wv, ")"])) : qv(["(", e.call(n, "expression"), ")"]);
                    case "AssignmentExpression": return Ib(o.left, e.call(n, "left"), qv([" ", o.operator]), o.right, e.call(n, "right"), t);
                    case "BinaryExpression":
                    case "LogicalExpression":
                    case "NGPipeExpression": {
                        const r = e.getParentNode(), i = e.getParentNode(1), s = o !== r.body && ("IfStatement" === r.type || "WhileStatement" === r.type || "SwitchStatement" === r.type || "DoWhileStatement" === r.type), a = Mb(e, n, t, !1, s);
                        if (s)
                            return qv(a);
                        if (("CallExpression" === r.type || "OptionalCallExpression" === r.type) && r.callee === o || "UnaryExpression" === r.type || ("MemberExpression" === r.type || "OptionalMemberExpression" === r.type) && !r.computed)
                            return zv(qv([Hv(qv([Wv, qv(a)])), Wv]));
                        const u = "ReturnStatement" === r.type || "ThrowStatement" === r.type || "JSXExpressionContainer" === r.type && "JSXAttribute" === i.type || "|" !== o.operator && "JsExpressionRoot" === r.type || "NGPipeExpression" !== o.type && ("NGRoot" === r.type && "__ng_binding" === t.parser || "NGMicrosyntaxExpression" === r.type && "NGMicrosyntax" === i.type && 1 === i.body.length) || o === r.body && "ArrowFunctionExpression" === r.type || o !== r.body && "ForStatement" === r.type || "ConditionalExpression" === r.type && "ReturnStatement" !== i.type && "ThrowStatement" !== i.type && "CallExpression" !== i.type && "OptionalCallExpression" !== i.type || "TemplateLiteral" === r.type, c = "AssignmentExpression" === r.type || "VariableDeclarator" === r.type || "ClassProperty" === r.type || "TSAbstractClassProperty" === r.type || "ClassPrivateProperty" === r.type || "ObjectProperty" === r.type || "Property" === r.type, l = rv(o.left) && by(o.operator, o.left.operator);
                        if (u || Pb(o) && !l || !Pb(o) && c)
                            return zv(qv(a));
                        if (0 === a.length)
                            return "";
                        const p = dv(o.right), f = qv(p ? a.slice(1, -1) : a.slice(1)), d = Symbol("logicalChain-" + ++ab), h = zv(qv([a.length > 0 ? a[0] : "", Hv(f)]), { id: d });
                        if (!p)
                            return h;
                        const m = wy(a);
                        return zv(qv([h, Xv(Hv(m), m, { groupId: d })]));
                    }
                    case "AssignmentPattern": return qv([e.call(n, "left"), " = ", e.call(n, "right")]);
                    case "TSTypeAssertion": {
                        const t = !("ArrayExpression" === o.expression.type || "ObjectExpression" === o.expression.type), r = zv(qv(["<", Hv(qv([Wv, e.call(n, "typeAnnotation")])), Wv, ">"])), i = qv([Xv("("), Hv(qv([Wv, e.call(n, "expression")])), Wv, Xv(")")]);
                        return t ? Jv([qv([r, e.call(n, "expression")]), qv([r, zv(i, { shouldBreak: !0 })]), qv([r, e.call(n, "expression")])]) : zv(qv([r, e.call(n, "expression")]));
                    }
                    case "OptionalMemberExpression":
                    case "MemberExpression": {
                        const t = e.getParentNode();
                        let r, i = 0;
                        do {
                            r = e.getParentNode(i), i++;
                        } while (r && ("MemberExpression" === r.type || "OptionalMemberExpression" === r.type || "TSNonNullExpression" === r.type));
                        const s = r && ("NewExpression" === r.type || "BindExpression" === r.type || "VariableDeclarator" === r.type && "Identifier" !== r.id.type || "AssignmentExpression" === r.type && "Identifier" !== r.left.type) || o.computed || "Identifier" === o.object.type && "Identifier" === o.property.type && "MemberExpression" !== t.type && "OptionalMemberExpression" !== t.type;
                        return qv([e.call(n, "object"), s ? Fb(e, 0, n) : zv(Hv(qv([Wv, Fb(e, 0, n)])))]);
                    }
                    case "MetaProperty": return qv([e.call(n, "meta"), ".", e.call(n, "property")]);
                    case "BindExpression": return o.object && a.push(e.call(n, "object")), a.push(zv(Hv(qv([Wv, Ob(e, 0, n)])))), qv(a);
                    case "Identifier": return qv([o.name, kb(e), yb(e, t, n)]);
                    case "V8IntrinsicIdentifier": return qv(["%", o.name]);
                    case "SpreadElement":
                    case "SpreadElementPattern":
                    case "SpreadProperty":
                    case "SpreadPropertyPattern":
                    case "RestElement":
                    case "ObjectTypeSpreadProperty": return qv(["...", e.call(n, "argument"), yb(e, t, n)]);
                    case "FunctionDeclaration":
                    case "FunctionExpression": return a.push(Eb(e, n, t)), o.body || a.push(i), qv(a);
                    case "ArrowFunctionExpression": {
                        o.async && a.push("async "), Db(e, t) ? a.push(e.call(n, "params", 0)) : a.push(zv(qv([bb(e, n, t, r && (r.expandLastArg || r.expandFirstArg), !0), Cb(e, n, t)])));
                        const i = Sa.printDanglingComments(e, t, !0, (e => { const n = Ry(t.originalText, e, t.locEnd); return "=>" === t.originalText.slice(n, n + 2); }));
                        i && a.push(" ", i), a.push(" =>");
                        const s = e.call((e => n(e, r)), "body");
                        if (!Gy(t.originalText, o.body, t) && ("ArrayExpression" === o.body.type || "ObjectExpression" === o.body.type || "BlockStatement" === o.body.type || dv(o.body) || Ov(o.body, t.originalText, t) || "ArrowFunctionExpression" === o.body.type || "DoExpression" === o.body.type))
                            return zv(qv([qv(a), " ", s]));
                        if ("SequenceExpression" === o.body.type)
                            return zv(qv([qv(a), zv(qv([" (", Hv(qv([Wv, s])), Wv, ")"]))]));
                        const u = (r && r.expandLastArg || "JSXExpressionContainer" === e.getParentNode().type) && !(o.comments && o.comments.length), c = r && r.expandLastArg && ub(t, "all"), l = "ConditionalExpression" === o.body.type && !Oy(o.body, !1);
                        return zv(qv([qv(a), zv(qv([Hv(qv([Uv, l ? Xv("", "(") : "", s, l ? Xv("", ")") : ""])), u ? qv([Xv(c ? "," : ""), Wv]) : ""]))]));
                    }
                    case "YieldExpression": return a.push("yield"), o.delegate && a.push("*"), o.argument && a.push(" ", e.call(n, "argument")), qv(a);
                    case "AwaitExpression": {
                        a.push("await ", e.call(n, "argument"));
                        const t = e.getParentNode();
                        return ("CallExpression" === t.type || "OptionalCallExpression" === t.type) && t.callee === o || ("MemberExpression" === t.type || "OptionalMemberExpression" === t.type) && t.object === o ? zv(qv([Hv(qv([Wv, qv(a)])), Wv])) : qv(a);
                    }
                    case "ImportSpecifier": return o.importKind && a.push(e.call(n, "importKind"), " "), a.push(e.call(n, "imported")), o.local && o.local.name !== o.imported.name && a.push(" as ", e.call(n, "local")), qv(a);
                    case "ExportSpecifier": return a.push(e.call(n, "local")), o.exported && o.exported.name !== o.local.name && a.push(" as ", e.call(n, "exported")), qv(a);
                    case "ImportNamespaceSpecifier": return a.push("* as "), a.push(e.call(n, "local")), qv(a);
                    case "ImportDefaultSpecifier": return e.call(n, "local");
                    case "TSExportAssignment": return qv(["export = ", e.call(n, "expression"), i]);
                    case "ExportDefaultDeclaration":
                    case "ExportNamedDeclaration": return wb(e, t, n);
                    case "ExportAllDeclaration": return a.push("export "), "type" === o.exportKind && a.push("type "), a.push("* "), o.exported && a.push("as ", e.call(n, "exported"), " "), a.push("from ", e.call(n, "source"), i), qv(a);
                    case "ExportNamespaceSpecifier":
                    case "ExportDefaultSpecifier": return e.call(n, "exported");
                    case "ImportDeclaration": {
                        a.push("import "), o.importKind && "value" !== o.importKind && a.push(o.importKind + " ");
                        const r = [], s = [];
                        return o.specifiers && o.specifiers.length > 0 ? (e.each((e => { const t = e.getValue(); "ImportDefaultSpecifier" === t.type || "ImportNamespaceSpecifier" === t.type ? r.push(n(e)) : s.push(n(e)); }), "specifiers"), r.length > 0 && a.push($v(", ", r)), r.length > 0 && s.length > 0 && a.push(", "), 1 === s.length && 0 === r.length && o.specifiers && !o.specifiers.some((e => e.comments)) ? a.push(qv(["{", t.bracketSpacing ? " " : "", qv(s), t.bracketSpacing ? " " : "", "}"])) : s.length >= 1 && a.push(zv(qv(["{", Hv(qv([t.bracketSpacing ? Uv : Wv, $v(qv([",", Uv]), s)])), Xv(ub(t) ? "," : ""), t.bracketSpacing ? Uv : Wv, "}"]))), a.push(" from ")) : (o.importKind && "type" === o.importKind || /{\s*}/.test(t.originalText.slice(t.locStart(o), t.locStart(o.source)))) && a.push("{} from "), a.push(e.call(n, "source"), i), qv(a);
                    }
                    case "Import": return "import";
                    case "TSModuleBlock":
                    case "BlockStatement": {
                        const r = e.call((e => pb(e, t, n)), "body"), s = o.body.find((e => "EmptyStatement" !== e.type)), u = o.directives && o.directives.length > 0, c = e.getParentNode(), l = e.getParentNode(1);
                        return s || u || zy(o) || "ArrowFunctionExpression" !== c.type && "FunctionExpression" !== c.type && "FunctionDeclaration" !== c.type && "ObjectMethod" !== c.type && "ClassMethod" !== c.type && "ClassPrivateMethod" !== c.type && "ForStatement" !== c.type && "WhileStatement" !== c.type && "DoWhileStatement" !== c.type && "DoExpression" !== c.type && ("CatchClause" !== c.type || l.finalizer) && "TSModuleDeclaration" !== c.type ? (a.push("{"), u && e.each((e => { a.push(Hv(qv([Vv, n(e), i]))), Py(t.originalText, e.getValue(), t.locEnd) && a.push(Vv); }), "directives"), s && a.push(Hv(qv([Vv, r]))), a.push(Sa.printDanglingComments(e, t)), a.push(Vv, "}"), qv(a)) : "{}";
                    }
                    case "ReturnStatement": return qv(["return", Wb(e, t, n)]);
                    case "NewExpression":
                    case "OptionalCallExpression":
                    case "CallExpression": {
                        const r = "NewExpression" === o.type, i = kb(e);
                        if (!r && "Identifier" === o.callee.type && ("require" === o.callee.name || "define" === o.callee.name) || 1 === o.arguments.length && Ov(o.arguments[0], t.originalText, t) || !r && _v(o, e.getParentNode()))
                            return qv([r ? "new " : "", e.call(n, "callee"), i, vb(e, 0, n), qv(["(", $v(", ", e.map(n, "arguments")), ")"])]);
                        const s = "Identifier" === o.callee.type && Hy(o.callee.trailingComments);
                        if (s && (o.callee.trailingComments[0].printed = !0), !r && Dv(o.callee) && !e.call((e => dy(e, t)), "callee"))
                            return function (e, t, n) { const r = []; function o(e) { const { originalText: n } = t, r = Ry(n, e, t.locEnd); return ")" === n.charAt(r) ? My(n, r + 1, t.locEnd) : Py(n, e, t.locEnd); } function i(e) { const s = e.getValue(); "CallExpression" !== s.type && "OptionalCallExpression" !== s.type || !Dv(s.callee) && "CallExpression" !== s.callee.type && "OptionalCallExpression" !== s.callee.type ? Dv(s) ? (r.unshift({ node: s, needsParens: dy(e, t), printed: Sa.printComments(e, (() => "OptionalMemberExpression" === s.type || "MemberExpression" === s.type ? Fb(e, 0, n) : Ob(e, 0, n)), t) }), e.call((e => i(e)), "object")) : "TSNonNullExpression" === s.type ? (r.unshift({ node: s, printed: Sa.printComments(e, (() => "!"), t) }), e.call((e => i(e)), "expression")) : r.unshift({ node: s, printed: e.call(n) }) : (r.unshift({ node: s, printed: qv([Sa.printComments(e, (() => qv([kb(e), vb(e, 0, n), gb(e, t, n)])), t), o(s) ? Vv : ""]) }), e.call((e => i(e)), "callee")); } const s = e.getValue(); r.unshift({ node: s, printed: qv([kb(e), vb(e, 0, n), gb(e, t, n)]) }), e.call((e => i(e)), "callee"); const a = []; let u = [r[0]], c = 1; for (; c < r.length && ("TSNonNullExpression" === r[c].node.type || "OptionalCallExpression" === r[c].node.type || "CallExpression" === r[c].node.type || ("MemberExpression" === r[c].node.type || "OptionalMemberExpression" === r[c].node.type) && r[c].node.computed && Cv(r[c].node.property)); ++c)
                                u.push(r[c]); if ("CallExpression" !== r[0].node.type && "OptionalCallExpression" !== r[0].node.type)
                                for (; c + 1 < r.length && Dv(r[c].node) && Dv(r[c + 1].node); ++c)
                                    u.push(r[c]); a.push(u), u = []; let l = !1; for (; c < r.length; ++c) {
                                if (l && Dv(r[c].node)) {
                                    if (r[c].node.computed && Cv(r[c].node.property)) {
                                        u.push(r[c]);
                                        continue;
                                    }
                                    a.push(u), u = [], l = !1;
                                }
                                "CallExpression" !== r[c].node.type && "OptionalCallExpression" !== r[c].node.type || (l = !0), u.push(r[c]), r[c].node.comments && r[c].node.comments.some((e => e.trailing)) && (a.push(u), u = [], l = !1);
                            } function p(e) { return /^[A-Z]|^[_$]+$/.test(e); } u.length > 0 && a.push(u); const f = a.length >= 2 && !a[1][0].node.comments && function (n) { const r = e.getParentNode(), o = r && "ExpressionStatement" === r.type, i = n[1].length && n[1][0].node.computed; if (1 === n[0].length) {
                                const e = n[0][0].node;
                                return "ThisExpression" === e.type || "Identifier" === e.type && (p(e.name) || o && e.name.length <= t.tabWidth || i);
                            } const s = wy(n[0]).node; return ("MemberExpression" === s.type || "OptionalMemberExpression" === s.type) && "Identifier" === s.property.type && (p(s.property.name) || i); }(a); function d(e) { const t = e.map((e => e.printed)); return e.length > 0 && e[e.length - 1].needsParens ? qv(["(", ...t, ")"]) : qv(t); } const h = a.map(d), m = qv(h), g = f ? 3 : 2, y = a.reduce(((e, t) => e.concat(t)), []), v = y.slice(1, -1).some((e => Jy(e.node))) || y.slice(0, -1).some((e => tv(e.node))) || a[g] && Jy(a[g][0].node); if (a.length <= g && !v)
                                return yv(e) ? m : zv(m); const b = wy(f ? a.slice(1, 2)[0] : a[0]).node, D = "CallExpression" !== b.type && "OptionalCallExpression" !== b.type && o(b), E = qv([d(a[0]), f ? qv(a.slice(1, 2).map(d)) : "", D ? Vv : "", (w = a.slice(f ? 2 : 1), 0 === w.length ? "" : Hv(zv(qv([Vv, $v(Vv, w.map(d))]))))]), C = r.map((({ node: e }) => e)).filter(ov); var w, A, S; return v || C.length > 2 && C.some((e => !e.arguments.every((e => Sv(e, 0))))) || h.slice(0, -1).some(nb) || (A = wy(h), S = wy(wy(a)).node, ov(S) && nb(A) && C.slice(0, -1).some((e => e.arguments.some(lv)))) ? zv(E) : qv([nb(m) || D ? Qv : "", Jv([m, E])]); }(e, t, n);
                        const a = qv([r ? "new " : "", e.call(n, "callee"), i, s ? "/*:: ".concat(o.callee.trailingComments[0].value.slice(2).trim(), " */") : "", vb(e, 0, n), gb(e, t, n)]);
                        return ov(o.callee) ? zv(a) : a;
                    }
                    case "TSInterfaceDeclaration": return o.declare && a.push("declare "), a.push(o.abstract ? "abstract " : "", Sb(e, 0, n), "interface ", e.call(n, "id"), o.typeParameters ? e.call(n, "typeParameters") : "", " "), o.extends && o.extends.length && a.push(zv(Hv(qv([Wv, "extends ", (1 === o.extends.length ? nv : Hv)($v(qv([",", Uv]), e.map(n, "extends"))), " "])))), a.push(e.call(n, "body")), qv(a);
                    case "ObjectTypeInternalSlot": return qv([o.static ? "static " : "", "[[", e.call(n, "id"), "]]", kb(e), o.method ? "" : ": ", e.call(n, "value")]);
                    case "ObjectExpression":
                    case "ObjectPattern":
                    case "ObjectTypeAnnotation":
                    case "TSInterfaceBody":
                    case "TSTypeLiteral": {
                        let r;
                        r = "TSTypeLiteral" === o.type ? "members" : "TSInterfaceBody" === o.type ? "body" : "properties";
                        const s = "ObjectTypeAnnotation" === o.type, a = [];
                        s && a.push("indexers", "callProperties", "internalSlots"), a.push(r);
                        const u = a.map((e => o[e][0])).sort(((e, n) => t.locStart(e) - t.locStart(n)))[0], c = e.getParentNode(0), l = s && c && ("InterfaceDeclaration" === c.type || "DeclareInterface" === c.type || "DeclareClass" === c.type) && "body" === e.getName(), p = "TSInterfaceBody" === o.type || l || "ObjectPattern" === o.type && "FunctionDeclaration" !== c.type && "FunctionExpression" !== c.type && "ArrowFunctionExpression" !== c.type && "ObjectMethod" !== c.type && "ClassMethod" !== c.type && "ClassPrivateMethod" !== c.type && "AssignmentPattern" !== c.type && "CatchClause" !== c.type && o.properties.some((e => e.value && ("ObjectPattern" === e.value.type || "ArrayPattern" === e.value.type))) || "ObjectPattern" !== o.type && u && Cy(t.originalText, t.locStart(o), t.locStart(u)), f = l ? ";" : "TSInterfaceBody" === o.type || "TSTypeLiteral" === o.type ? Xv(i, ";") : ",", d = o.exact ? "{|" : "{", h = o.exact ? "|}" : "}", m = [];
                        a.forEach((r => { e.each((e => { const r = e.getValue(); m.push({ node: r, printed: n(e), loc: t.locStart(r) }); }), r); }));
                        let g = [];
                        const y = m.sort(((e, t) => e.loc - t.loc)).map((e => { const n = qv(g.concat(zv(e.printed))); return g = [f, Uv], "TSPropertySignature" !== e.node.type && "TSMethodSignature" !== e.node.type && "TSConstructSignatureDeclaration" !== e.node.type || !ky(e.node) || g.shift(), Py(t.originalText, e.node, t.locEnd) && g.push(Vv), n; }));
                        if (o.inexact) {
                            let n;
                            if (zy(o)) {
                                const r = !o.comments.every(tg.isBlockComment), i = Sa.printDanglingComments(e, t, !0);
                                n = qv([i, r || Ey(t.originalText, t.locEnd(o.comments[o.comments.length - 1])) ? Vv : Uv, "..."]);
                            }
                            else
                                n = "...";
                            y.push(qv(g.concat(n)));
                        }
                        const v = wy(o[r]), b = !(o.inexact || v && ("RestElement" === v.type || ky(v)));
                        let D;
                        if (0 === y.length) {
                            if (!zy(o))
                                return qv([d, h, yb(e, t, n)]);
                            D = zv(qv([d, Sa.printDanglingComments(e, t), Wv, h, kb(e), yb(e, t, n)]));
                        }
                        else
                            D = qv([d, Hv(qv([t.bracketSpacing ? Uv : Wv, qv(y)])), Xv(b && ("," !== f || ub(t)) ? f : ""), qv([t.bracketSpacing ? Uv : Wv, h]), kb(e), yb(e, t, n)]);
                        return e.match((e => "ObjectPattern" === e.type && !e.decorators), ((e, t, n) => Ub(e) && ("params" === t || "parameters" === t) && 0 === n)) || e.match($b, ((e, t) => "typeAnnotation" === t), ((e, t) => "typeAnnotation" === t), ((e, t, n) => Ub(e) && ("params" === t || "parameters" === t) && 0 === n)) ? D : zv(D, { shouldBreak: p });
                    }
                    case "ObjectProperty":
                    case "Property": return o.method || "get" === o.kind || "set" === o.kind ? db(e, t, n) : (o.shorthand ? a.push(e.call(n, "value")) : a.push(Ib(o.key, fb(e, t, n), ":", o.value, e.call(n, "value"), t)), qv(a));
                    case "ClassMethod":
                    case "ClassPrivateMethod":
                    case "MethodDefinition":
                    case "TSAbstractMethodDefinition":
                    case "TSDeclareMethod": return o.decorators && 0 !== o.decorators.length && a.push(cb(e, t, n)), o.accessibility && a.push(o.accessibility + " "), o.static && a.push("static "), ("TSAbstractMethodDefinition" === o.type || o.abstract) && a.push("abstract "), a.push(db(e, t, n)), qv(a);
                    case "ObjectMethod": return db(e, t, n);
                    case "Decorator": return qv(["@", e.call(n, "expression"), e.call(n, "callee")]);
                    case "ArrayExpression":
                    case "ArrayPattern":
                        if (0 === o.elements.length)
                            zy(o) ? a.push(zv(qv(["[", Sa.printDanglingComments(e, t), Wv, "]"]))) : a.push("[]");
                        else {
                            const r = wy(o.elements), i = !(r && "RestElement" === r.type), s = i && null === r, u = o.elements.length > 1 && o.elements.every(((e, t, n) => { const r = e && e.type; if ("ArrayExpression" !== r && "ObjectExpression" !== r)
                                return !1; const o = n[t + 1]; if (o && r !== o.type)
                                return !1; const i = "ArrayExpression" === r ? "elements" : "properties"; return e[i] && e[i].length > 1; }));
                            a.push(zv(qv(["[", Hv(qv([Wv, Vb(e, t, "elements", n)])), s ? "," : "", Xv(i && !s && ub(t) ? "," : ""), Sa.printDanglingComments(e, t, !0), Wv, "]"]), { shouldBreak: u }));
                        }
                        return a.push(kb(e), yb(e, t, n)), qv(a);
                    case "SequenceExpression": {
                        const t = e.getParentNode(0);
                        if ("ExpressionStatement" === t.type || "ForStatement" === t.type) {
                            const t = [];
                            return e.each((e => { 0 === e.getName() ? t.push(n(e)) : t.push(",", Hv(qv([Uv, n(e)]))); }), "expressions"), zv(qv(t));
                        }
                        return zv(qv([$v(qv([",", Uv]), e.map(n, "expressions"))]));
                    }
                    case "ThisExpression":
                    case "ThisTypeAnnotation":
                    case "TSThisType": return "this";
                    case "Super": return "super";
                    case "NullLiteral":
                    case "TSNullKeyword":
                    case "NullLiteralTypeAnnotation": return "null";
                    case "RegExpLiteral": return Lb(o);
                    case "NumericLiteral": return xy(o.extra.raw);
                    case "BigIntLiteral": return (o.bigint || (o.extra ? o.extra.raw : o.raw)).toLowerCase();
                    case "BooleanLiteral":
                    case "StringLiteral":
                    case "Literal": {
                        if (o.regex)
                            return Lb(o.regex);
                        if ("number" == typeof o.value)
                            return xy(o.raw);
                        if ("string" != typeof o.value)
                            return "" + o.value;
                        const n = e.getParentNode(1), r = "typescript" === t.parser && "string" == typeof o.value && n && ("Program" === n.type || "BlockStatement" === n.type);
                        return Bb(o, t, r);
                    }
                    case "Directive": return e.call(n, "value");
                    case "DirectiveLiteral":
                    case "StringLiteralTypeAnnotation": return Bb(o, t);
                    case "UnaryExpression": return a.push(o.operator), /[a-z]$/.test(o.operator) && a.push(" "), o.argument.comments && o.argument.comments.length > 0 ? a.push(zv(qv(["(", Hv(qv([Wv, e.call(n, "argument")])), Wv, ")"]))) : a.push(e.call(n, "argument")), qv(a);
                    case "UpdateExpression": return a.push(e.call(n, "argument"), o.operator), o.prefix && a.reverse(), qv(a);
                    case "ConditionalExpression": return lb(e, t, n, { beforeParts: () => [e.call(n, "test")], afterParts: e => [e ? Wv : ""], shouldCheckJsx: !0, conditionalNodeType: "ConditionalExpression", consequentNodePropertyName: "consequent", alternateNodePropertyName: "alternate", testNodePropertyNames: ["test"] });
                    case "VariableDeclaration": {
                        const t = e.map((e => n(e)), "declarations"), r = e.getParentNode(), s = "ForStatement" === r.type || "ForInStatement" === r.type || "ForOfStatement" === r.type, u = o.declarations.some((e => e.init));
                        let c;
                        return 1 !== t.length || o.declarations[0].comments ? t.length > 0 && (c = Hv(t[0])) : c = t[0], a = [o.declare ? "declare " : "", o.kind, c ? qv([" ", c]) : "", Hv(qv(t.slice(1).map((e => qv([",", u && !s ? Vv : Uv, e])))))], s && r.body !== o || a.push(i), zv(qv(a));
                    }
                    case "TSTypeAliasDeclaration": {
                        o.declare && a.push("declare ");
                        const r = Rb(o.id, o.typeAnnotation, o.typeAnnotation && e.call(n, "typeAnnotation"), t);
                        return a.push("type ", e.call(n, "id"), e.call(n, "typeParameters"), " =", r, i), zv(qv(a));
                    }
                    case "VariableDeclarator": return Ib(o.id, e.call(n, "id"), " =", o.init, o.init && e.call(n, "init"), t);
                    case "WithStatement": return zv(qv(["with (", e.call(n, "object"), ")", jb(o.body, e.call(n, "body"))]));
                    case "IfStatement": {
                        const r = jb(o.consequent, e.call(n, "consequent")), i = zv(qv(["if (", zv(qv([Hv(qv([Wv, e.call(n, "test")])), Wv])), ")", r]));
                        if (a.push(i), o.alternate) {
                            const r = tv(o.consequent) && o.consequent.comments.some((e => e.trailing && !tg.isBlockComment(e))) || Iv(o), i = "BlockStatement" === o.consequent.type && !r;
                            a.push(i ? " " : Vv), zy(o) && a.push(Sa.printDanglingComments(e, t, !0), r ? Vv : " "), a.push("else", zv(jb(o.alternate, e.call(n, "alternate"), "IfStatement" === o.alternate.type)));
                        }
                        return qv(a);
                    }
                    case "ForStatement": {
                        const r = jb(o.body, e.call(n, "body")), i = Sa.printDanglingComments(e, t, !0), s = i ? qv([i, Wv]) : "";
                        return o.init || o.test || o.update ? qv([s, zv(qv(["for (", zv(qv([Hv(qv([Wv, e.call(n, "init"), ";", Uv, e.call(n, "test"), ";", Uv, e.call(n, "update")])), Wv])), ")", r]))]) : qv([s, zv(qv(["for (;;)", r]))]);
                    }
                    case "WhileStatement": return zv(qv(["while (", zv(qv([Hv(qv([Wv, e.call(n, "test")])), Wv])), ")", jb(o.body, e.call(n, "body"))]));
                    case "ForInStatement": return zv(qv([o.each ? "for each (" : "for (", e.call(n, "left"), " in ", e.call(n, "right"), ")", jb(o.body, e.call(n, "body"))]));
                    case "ForOfStatement": return zv(qv(["for", o.await ? " await" : "", " (", e.call(n, "left"), " of ", e.call(n, "right"), ")", jb(o.body, e.call(n, "body"))]));
                    case "DoWhileStatement": {
                        const t = jb(o.body, e.call(n, "body")), r = zv(qv(["do", t]));
                        return a = [r], "BlockStatement" === o.body.type ? a.push(" ") : a.push(Vv), a.push("while ("), a.push(zv(qv([Hv(qv([Wv, e.call(n, "test")])), Wv])), ")", i), qv(a);
                    }
                    case "DoExpression": return qv(["do ", e.call(n, "body")]);
                    case "BreakStatement": return a.push("break"), o.label && a.push(" ", e.call(n, "label")), a.push(i), qv(a);
                    case "ContinueStatement": return a.push("continue"), o.label && a.push(" ", e.call(n, "label")), a.push(i), qv(a);
                    case "LabeledStatement": return "EmptyStatement" === o.body.type ? qv([e.call(n, "label"), ":;"]) : qv([e.call(n, "label"), ": ", e.call(n, "body")]);
                    case "TryStatement": return qv(["try ", e.call(n, "block"), o.handler ? qv([" ", e.call(n, "handler")]) : "", o.finalizer ? qv([" finally ", e.call(n, "finalizer")]) : ""]);
                    case "CatchClause":
                        if (o.param) {
                            const r = o.param.comments && o.param.comments.some((e => !tg.isBlockComment(e) || e.leading && Ey(t.originalText, t.locEnd(e)) || e.trailing && Ey(t.originalText, t.locStart(e), { backwards: !0 }))), i = e.call(n, "param");
                            return qv(["catch ", qv(r ? ["(", Hv(qv([Wv, i])), Wv, ") "] : ["(", i, ") "]), e.call(n, "body")]);
                        }
                        return qv(["catch ", e.call(n, "body")]);
                    case "ThrowStatement": return qv(["throw", Wb(e, t, n)]);
                    case "SwitchStatement": return qv([zv(qv(["switch (", Hv(qv([Wv, e.call(n, "discriminant")])), Wv, ")"])), " {", o.cases.length > 0 ? Hv(qv([Vv, $v(Vv, e.map((e => { const r = e.getValue(); return qv([e.call(n), o.cases.indexOf(r) !== o.cases.length - 1 && Py(t.originalText, r, t.locEnd) ? Vv : ""]); }), "cases"))])) : "", Vv, "}"]);
                    case "SwitchCase": {
                        o.test ? a.push("case ", e.call(n, "test"), ":") : a.push("default:");
                        const r = o.consequent.filter((e => "EmptyStatement" !== e.type));
                        if (r.length > 0) {
                            const o = e.call((e => pb(e, t, n)), "consequent");
                            a.push(1 === r.length && "BlockStatement" === r[0].type ? qv([" ", o]) : Hv(qv([Vv, o])));
                        }
                        return qv(a);
                    }
                    case "DebuggerStatement": return qv(["debugger", i]);
                    case "JSXAttribute":
                        if (a.push(e.call(n, "name")), o.value) {
                            let r;
                            if (kv(o.value)) {
                                let e = jv(o.value).replace(/&apos;/g, "'").replace(/&quot;/g, '"');
                                const n = Ny(e, t.jsxSingleQuote ? "'" : '"'), i = "'" === n ? "&apos;" : "&quot;";
                                e = e.slice(1, -1).replace(new RegExp(n, "g"), i), r = qv([n, e, n]);
                            }
                            else
                                r = e.call(n, "value");
                            a.push("=", r);
                        }
                        return qv(a);
                    case "JSXIdentifier": return "" + o.name;
                    case "JSXNamespacedName": return $v(":", [e.call(n, "namespace"), e.call(n, "name")]);
                    case "JSXMemberExpression": return $v(".", [e.call(n, "object"), e.call(n, "property")]);
                    case "TSQualifiedName": return $v(".", [e.call(n, "left"), e.call(n, "right")]);
                    case "JSXSpreadAttribute":
                    case "JSXSpreadChild": return qv(["{", e.call((e => { const r = qv(["...", n(e)]), o = e.getValue(); return o.comments && o.comments.length ? qv([Hv(qv([Wv, Sa.printComments(e, (() => r), t)])), Wv]) : r; }), "JSXSpreadAttribute" === o.type ? "argument" : "expression"), "}"]);
                    case "JSXExpressionContainer": {
                        const t = e.getParentNode(0), r = o.expression.comments && o.expression.comments.length > 0, i = "JSXEmptyExpression" === o.expression.type || !r && ("ArrayExpression" === o.expression.type || "ObjectExpression" === o.expression.type || "ArrowFunctionExpression" === o.expression.type || "CallExpression" === o.expression.type || "OptionalCallExpression" === o.expression.type || "FunctionExpression" === o.expression.type || "TemplateLiteral" === o.expression.type || "TaggedTemplateExpression" === o.expression.type || "DoExpression" === o.expression.type || dv(t) && ("ConditionalExpression" === o.expression.type || rv(o.expression)));
                        return zv(qv(i ? ["{", e.call(n, "expression"), Zv, "}"] : ["{", Hv(qv([Wv, e.call(n, "expression")])), Wv, Zv, "}"]));
                    }
                    case "JSXFragment":
                    case "JSXElement": {
                        const r = Sa.printComments(e, (() => function (e, t, n) { const r = e.getValue(); if ("JSXElement" === r.type && iv(r))
                            return qv([e.call(n, "openingElement"), e.call(n, "closingElement")]); const o = "JSXElement" === r.type ? e.call(n, "openingElement") : e.call(n, "openingFragment"), i = "JSXElement" === r.type ? e.call(n, "closingElement") : e.call(n, "closingFragment"); if (1 === r.children.length && "JSXExpressionContainer" === r.children[0].type && ("TemplateLiteral" === r.children[0].expression.type || "TaggedTemplateExpression" === r.children[0].expression.type))
                            return qv([o, qv(e.map(n, "children")), i]); r.children = r.children.map((e => hv(e) ? { type: "JSXText", value: " ", raw: " " } : e)); const s = r.children.filter(dv).length > 0, a = r.children.filter((e => "JSXExpressionContainer" === e.type)).length > 1, u = "JSXElement" === r.type && r.openingElement.attributes.length > 1; let c = nb(o) || s || u || a; const l = "mdx" === e.getParentNode().rootMarker, p = t.singleQuote ? "{' '}" : '{" "}', f = l ? qv([" "]) : Xv(qv([p, Wv]), " "), d = r.openingElement && r.openingElement.name && "fbt" === r.openingElement.name.name, h = function (e, t, n, r, o) { const i = e.getValue(), s = []; return e.map(((e, t) => { const a = e.getValue(); if (gv(a)) {
                            const e = jv(a);
                            if (vv(a)) {
                                const n = e.split(Rv);
                                if ("" === n[0]) {
                                    if (s.push(""), n.shift(), /\n/.test(n[0])) {
                                        const e = i.children[t + 1];
                                        s.push(Nb(o, n[1], a, e));
                                    }
                                    else
                                        s.push(r);
                                    n.shift();
                                }
                                let u;
                                if ("" === wy(n) && (n.pop(), u = n.pop()), 0 === n.length)
                                    return;
                                if (n.forEach(((e, t) => { t % 2 == 1 ? s.push(Uv) : s.push(e); })), void 0 !== u)
                                    if (/\n/.test(u)) {
                                        const e = i.children[t + 1];
                                        s.push(Nb(o, wy(s), a, e));
                                    }
                                    else
                                        s.push(r);
                                else {
                                    const e = i.children[t + 1];
                                    s.push(_b(o, wy(s), a, e));
                                }
                            }
                            else
                                /\n/.test(e) ? e.match(/\n/g).length > 1 && (s.push(""), s.push(Vv)) : (s.push(""), s.push(r));
                        }
                        else {
                            const r = n(e);
                            s.push(r);
                            const u = i.children[t + 1];
                            if (u && vv(u)) {
                                const e = jv(u).trim().split(Rv)[0];
                                s.push(_b(o, e, a, u));
                            }
                            else
                                s.push(Vv);
                        } }), "children"), s; }(e, 0, n, f, d), m = r.children.some((e => vv(e))); for (let e = h.length - 2; e >= 0; e--) {
                            const t = "" === h[e] && "" === h[e + 1], n = h[e] === Vv && "" === h[e + 1] && h[e + 2] === Vv, r = (h[e] === Wv || h[e] === Vv) && "" === h[e + 1] && h[e + 2] === f, o = h[e] === f && "" === h[e + 1] && (h[e + 2] === Wv || h[e + 2] === Vv), i = h[e] === f && "" === h[e + 1] && h[e + 2] === f, s = h[e] === Wv && "" === h[e + 1] && h[e + 2] === Vv || h[e] === Vv && "" === h[e + 1] && h[e + 2] === Wv;
                            n && m || t || r || i || s ? h.splice(e, 2) : o && h.splice(e + 1, 2);
                        } for (; h.length && (rb(wy(h)) || ob(wy(h)));)
                            h.pop(); for (; h.length && (rb(h[0]) || ob(h[0])) && (rb(h[1]) || ob(h[1]));)
                            h.shift(), h.shift(); const g = []; h.forEach(((e, t) => { if (e === f) {
                            if (1 === t && "" === h[t - 1])
                                return 2 === h.length ? void g.push(p) : void g.push(qv([p, Vv]));
                            if (t === h.length - 1)
                                return void g.push(p);
                            if ("" === h[t - 1] && h[t - 2] === Vv)
                                return void g.push(p);
                        } g.push(e), nb(e) && (c = !0); })); const y = m ? Gv(g) : zv(qv(g), { shouldBreak: !0 }); if (l)
                            return y; const v = zv(qv([o, Hv(qv([Vv, y])), Vv, i])); return c ? v : Jv([zv(qv([o, qv(h), i])), v]); }(e, t, n)), t);
                        return function (e, t, n) { const r = e.getParentNode(); if (!r)
                            return t; if ({ ArrayExpression: !0, JSXAttribute: !0, JSXElement: !0, JSXExpressionContainer: !0, JSXFragment: !0, ExpressionStatement: !0, CallExpression: !0, OptionalCallExpression: !0, ConditionalExpression: !0, JsExpressionRoot: !0 }[r.type])
                            return t; const o = e.match(void 0, (e => "ArrowFunctionExpression" === e.type), ov, (e => "JSXExpressionContainer" === e.type)), i = dy(e, n); return zv(qv([i ? "" : Xv("("), Hv(qv([Wv, t])), Wv, i ? "" : Xv(")")]), { shouldBreak: o }); }(e, r, t);
                    }
                    case "JSXOpeningElement": {
                        const r = e.getValue(), o = r.name && r.name.comments && r.name.comments.length > 0 || r.typeParameters && r.typeParameters.comments && r.typeParameters.comments.length > 0;
                        if (r.selfClosing && !r.attributes.length && !o)
                            return qv(["<", e.call(n, "name"), e.call(n, "typeParameters"), " />"]);
                        if (r.attributes && 1 === r.attributes.length && r.attributes[0].value && kv(r.attributes[0].value) && !r.attributes[0].value.value.includes("\n") && !o && (!r.attributes[0].comments || !r.attributes[0].comments.length))
                            return zv(qv(["<", e.call(n, "name"), e.call(n, "typeParameters"), " ", qv(e.map(n, "attributes")), r.selfClosing ? " />" : ">"]));
                        const i = r.attributes.length && tv(wy(r.attributes)), s = !r.attributes.length && !o || t.jsxBracketSameLine && (!o || r.attributes.length) && !i, a = r.attributes && r.attributes.some((e => e.value && kv(e.value) && e.value.value.includes("\n")));
                        return zv(qv(["<", e.call(n, "name"), e.call(n, "typeParameters"), qv([Hv(qv(e.map((e => qv([Uv, n(e)])), "attributes"))), r.selfClosing ? Uv : s ? ">" : Wv]), r.selfClosing ? "/>" : s ? "" : ">"]), { shouldBreak: a });
                    }
                    case "JSXClosingElement": return qv(["</", e.call(n, "name"), ">"]);
                    case "JSXOpeningFragment":
                    case "JSXClosingFragment": {
                        const n = o.comments && o.comments.length, r = n && !o.comments.every(tg.isBlockComment), i = "JSXOpeningFragment" === o.type;
                        return qv([i ? "<" : "</", Hv(qv([r ? Vv : n && !i ? " " : "", Sa.printDanglingComments(e, t, !0)])), r ? Vv : "", ">"]);
                    }
                    case "JSXText": throw new Error("JSXTest should be handled by JSXElement");
                    case "JSXEmptyExpression": {
                        const n = o.comments && !o.comments.every(tg.isBlockComment);
                        return qv([Sa.printDanglingComments(e, t, !n), n ? Vv : ""]);
                    }
                    case "ClassBody": return o.comments || 0 !== o.body.length ? qv(["{", o.body.length > 0 ? Hv(qv([Vv, e.call((e => pb(e, t, n)), "body")])) : Sa.printDanglingComments(e, t), Vv, "}"]) : "{}";
                    case "ClassProperty":
                    case "TSAbstractClassProperty":
                    case "ClassPrivateProperty": {
                        o.decorators && 0 !== o.decorators.length && a.push(cb(e, t, n)), o.accessibility && a.push(o.accessibility + " "), o.declare && a.push("declare "), o.static && a.push("static "), ("TSAbstractClassProperty" === o.type || o.abstract) && a.push("abstract "), o.readonly && a.push("readonly ");
                        const r = Uy(o);
                        return r && a.push(r), a.push(fb(e, t, n), kb(e), yb(e, t, n)), o.value && a.push(" =", Rb(o.key, o.value, e.call(n, "value"), t)), a.push(i), zv(qv(a));
                    }
                    case "ClassDeclaration":
                    case "ClassExpression": return o.declare && a.push("declare "), a.push(qv(Tb(e, t, n))), qv(a);
                    case "TSInterfaceHeritage":
                    case "TSExpressionWithTypeArguments": return a.push(e.call(n, "expression")), o.typeParameters && a.push(e.call(n, "typeParameters")), qv(a);
                    case "TemplateElement": return $v(Kv, o.value.raw.split(/\r?\n/g));
                    case "TemplateLiteral": {
                        let r = e.map(n, "expressions");
                        const i = e.getParentNode();
                        if (fv(o, i)) {
                            const e = function (e, t, n) { const r = e.quasis[0].value.raw.trim().split(/\s*\|\s*/); if (r.length > 1 || r.some((e => 0 !== e.length))) {
                                const o = [], i = t.map((e => "${" + sb(e, Object.assign({}, n, { printWidth: 1 / 0, endOfLine: "lf" })).formatted + "}")), s = [{ hasLineBreak: !1, cells: [] }];
                                for (let t = 1; t < e.quasis.length; t++) {
                                    const n = s[s.length - 1], r = i[t - 1];
                                    n.cells.push(r), r.includes("\n") && (n.hasLineBreak = !0), e.quasis[t].value.raw.includes("\n") && s.push({ hasLineBreak: !1, cells: [] });
                                }
                                const a = Math.max(r.length, ...s.map((e => e.cells.length))), u = Array.from({ length: a }).fill(0), c = [{ cells: r }, ...s.filter((e => 0 !== e.cells.length))];
                                for (const { cells: e } of c.filter((e => !e.hasLineBreak)))
                                    e.forEach(((e, t) => { u[t] = Math.max(u[t], Ay(e)); }));
                                return o.push(Zv, "`", Hv(qv([Vv, $v(Vv, c.map((e => $v(" | ", e.cells.map(((t, n) => e.hasLineBreak ? t : t + " ".repeat(u[n] - Ay(t))))))))])), Vv, "`"), qv(o);
                            } }(o, r, t);
                            if (e)
                                return e;
                        }
                        const s = Tv(o);
                        return s && (r = r.map((e => sb(e, Object.assign({}, t, { printWidth: 1 / 0 })).formatted))), a.push(Zv, "`"), e.each((e => { const i = e.getName(); if (a.push(n(e)), i < r.length) {
                            const { tabWidth: n } = t, u = e.getValue(), c = _y(u.value.raw, n);
                            let l = r[i];
                            s || (o.expressions[i].comments && o.expressions[i].comments.length || "MemberExpression" === o.expressions[i].type || "OptionalMemberExpression" === o.expressions[i].type || "ConditionalExpression" === o.expressions[i].type || "SequenceExpression" === o.expressions[i].type || "TSAsExpression" === o.expressions[i].type || rv(o.expressions[i])) && (l = qv([Hv(qv([Wv, l])), Wv]));
                            const p = 0 === c && u.value.raw.endsWith("\n") ? Yv(-1 / 0, l) : eb(l, c, n);
                            a.push(zv(qv(["${", p, Zv, "}"])));
                        } }), "quasis"), a.push("`"), qv(a);
                    }
                    case "TaggedTemplateExpression": return qv([e.call(n, "tag"), e.call(n, "typeParameters"), e.call(n, "quasi")]);
                    case "Node":
                    case "Printable":
                    case "SourceLocation":
                    case "Position":
                    case "Statement":
                    case "Function":
                    case "Pattern":
                    case "Expression":
                    case "Declaration":
                    case "Specifier":
                    case "NamedSpecifier":
                    case "Comment":
                    case "MemberTypeAnnotation":
                    case "Type": throw new Error("unprintable type: " + JSON.stringify(o.type));
                    case "TypeAnnotation":
                    case "TSTypeAnnotation": return o.typeAnnotation ? e.call(n, "typeAnnotation") : "";
                    case "TSTupleType":
                    case "TupleTypeAnnotation": {
                        const r = "TSTupleType" === o.type ? "elementTypes" : "types", i = o[r].length > 0 && "TSRestType" === wy(o[r]).type;
                        return zv(qv(["[", Hv(qv([Wv, Vb(e, t, r, n)])), Xv(ub(t, "all") && !i ? "," : ""), Sa.printDanglingComments(e, t, !0), Wv, "]"]));
                    }
                    case "ExistsTypeAnnotation":
                    case "TSJSDocAllType": return "*";
                    case "EmptyTypeAnnotation": return "empty";
                    case "AnyTypeAnnotation":
                    case "TSAnyKeyword": return "any";
                    case "MixedTypeAnnotation": return "mixed";
                    case "ArrayTypeAnnotation":
                    case "TSArrayType": return qv([e.call(n, "elementType"), "[]"]);
                    case "BooleanTypeAnnotation":
                    case "TSBooleanKeyword": return "boolean";
                    case "BooleanLiteralTypeAnnotation": return "" + o.value;
                    case "DeclareClass": return Ab(e, Tb(e, t, n));
                    case "TSDeclareFunction": return qv([o.declare ? "declare " : "", Eb(e, n, t), i]);
                    case "DeclareFunction": return Ab(e, ["function ", e.call(n, "id"), o.predicate ? " " : "", e.call(n, "predicate"), i]);
                    case "DeclareModule": return Ab(e, ["module ", e.call(n, "id"), " ", e.call(n, "body")]);
                    case "DeclareModuleExports": return Ab(e, ["module.exports", ": ", e.call(n, "typeAnnotation"), i]);
                    case "DeclareVariable": return Ab(e, ["var ", e.call(n, "id"), i]);
                    case "DeclareExportAllDeclaration": return qv(["declare export * from ", e.call(n, "source")]);
                    case "DeclareExportDeclaration": return qv(["declare ", wb(e, t, n)]);
                    case "DeclareOpaqueType":
                    case "OpaqueType": return a.push("opaque type ", e.call(n, "id"), e.call(n, "typeParameters")), o.supertype && a.push(": ", e.call(n, "supertype")), o.impltype && a.push(" = ", e.call(n, "impltype")), a.push(i), "DeclareOpaqueType" === o.type ? Ab(e, a) : qv(a);
                    case "EnumDeclaration": return qv(["enum ", e.call(n, "id"), " ", e.call(n, "body")]);
                    case "EnumBooleanBody":
                    case "EnumNumberBody":
                    case "EnumStringBody":
                    case "EnumSymbolBody":
                        if ("EnumSymbolBody" === o.type || o.explicitType) {
                            let e = null;
                            switch (o.type) {
                                case "EnumBooleanBody":
                                    e = "boolean";
                                    break;
                                case "EnumNumberBody":
                                    e = "number";
                                    break;
                                case "EnumStringBody":
                                    e = "string";
                                    break;
                                case "EnumSymbolBody": e = "symbol";
                            }
                            a.push("of ", e, " ");
                        }
                        return 0 === o.members.length ? a.push(zv(qv(["{", Sa.printDanglingComments(e, t), Wv, "}"]))) : a.push(zv(qv(["{", Hv(qv([Vv, Vb(e, t, "members", n), ub(t) ? "," : ""])), Sa.printDanglingComments(e, t, !0), Vv, "}"]))), qv(a);
                    case "EnumBooleanMember":
                    case "EnumNumberMember":
                    case "EnumStringMember": return qv([e.call(n, "id"), " = ", "object" == typeof o.init ? e.call(n, "init") : String(o.init)]);
                    case "EnumDefaultedMember": return e.call(n, "id");
                    case "FunctionTypeAnnotation":
                    case "TSFunctionType": {
                        const r = e.getParentNode(0), i = e.getParentNode(1), s = e.getParentNode(2);
                        let u = "TSFunctionType" === o.type || !(("ObjectTypeProperty" === r.type || "ObjectTypeInternalSlot" === r.type) && !Uy(r) && !r.optional && t.locStart(r) === t.locStart(o) || "ObjectTypeCallProperty" === r.type || s && "DeclareFunction" === s.type), c = u && ("TypeAnnotation" === r.type || "TSTypeAnnotation" === r.type);
                        const l = c && u && ("TypeAnnotation" === r.type || "TSTypeAnnotation" === r.type) && "ArrowFunctionExpression" === i.type;
                        return Av(r, t) && (u = !0, c = !0), l && a.push("("), a.push(bb(e, n, t, !1, !0)), (o.returnType || o.predicate || o.typeAnnotation) && a.push(u ? " => " : ": ", e.call(n, "returnType"), e.call(n, "predicate"), e.call(n, "typeAnnotation")), l && a.push(")"), zv(qv(a));
                    }
                    case "TSRestType": return qv(["...", e.call(n, "typeAnnotation")]);
                    case "TSOptionalType": return qv([e.call(n, "typeAnnotation"), "?"]);
                    case "FunctionTypeParam": return qv([e.call(n, "name"), kb(e), o.name ? ": " : "", e.call(n, "typeAnnotation")]);
                    case "GenericTypeAnnotation":
                    case "ClassImplements":
                    case "InterfaceExtends": return qv([e.call(n, "id"), e.call(n, "typeParameters")]);
                    case "DeclareInterface":
                    case "InterfaceDeclaration":
                    case "InterfaceTypeAnnotation": return ("DeclareInterface" === o.type || o.declare) && a.push("declare "), a.push("interface"), "DeclareInterface" !== o.type && "InterfaceDeclaration" !== o.type || a.push(" ", e.call(n, "id"), e.call(n, "typeParameters")), o.extends.length > 0 && a.push(zv(Hv(qv([Uv, "extends ", (1 === o.extends.length ? nv : Hv)($v(qv([",", Uv]), e.map(n, "extends")))])))), a.push(" ", e.call(n, "body")), zv(qv(a));
                    case "TSClassImplements": return qv([e.call(n, "expression"), e.call(n, "typeParameters")]);
                    case "TSIntersectionType":
                    case "IntersectionTypeAnnotation": {
                        const t = e.map(n, "types"), r = [];
                        let i = !1;
                        for (let e = 0; e < t.length; ++e)
                            0 === e ? r.push(t[e]) : wv(o.types[e - 1]) && wv(o.types[e]) ? r.push(qv([" & ", i ? Hv(t[e]) : t[e]])) : wv(o.types[e - 1]) || wv(o.types[e]) ? (e > 1 && (i = !0), r.push(" & ", e > 1 ? Hv(t[e]) : t[e])) : r.push(Hv(qv([" &", Uv, t[e]])));
                        return zv(qv(r));
                    }
                    case "TSUnionType":
                    case "UnionTypeAnnotation": {
                        const r = e.getParentNode(), i = !("TypeParameterInstantiation" === r.type || "TSTypeParameterInstantiation" === r.type || "GenericTypeAnnotation" === r.type || "TSTypeReference" === r.type || "TSTypeAssertion" === r.type || "TupleTypeAnnotation" === r.type || "TSTupleType" === r.type || "FunctionTypeParam" === r.type && !r.name || ("TypeAlias" === r.type || "VariableDeclarator" === r.type || "TSTypeAliasDeclaration" === r.type) && Gy(t.originalText, o, t)), s = $b(o), a = e.map((e => { let r = e.call(n); return s || (r = Yv(2, r)), Sa.printComments(e, (() => r), t); }), "types");
                        if (s)
                            return $v(" | ", a);
                        const u = i && !Gy(t.originalText, o, t), c = qv([Xv(qv([u ? Uv : "", "| "])), $v(qv([Uv, "| "]), a)]);
                        return dy(e, t) ? zv(qv([Hv(c), Wv])) : "TupleTypeAnnotation" === r.type && r.types.length > 1 || "TSTupleType" === r.type && r.elementTypes.length > 1 ? zv(qv([Hv(qv([Xv(qv(["(", Wv])), c])), Wv, Xv(")")])) : zv(i ? Hv(c) : c);
                    }
                    case "NullableTypeAnnotation":
                    case "TSJSDocNullableType": return qv(["?", e.call(n, "typeAnnotation")]);
                    case "NumberTypeAnnotation":
                    case "TSNumberKeyword": return "number";
                    case "SymbolTypeAnnotation":
                    case "TSSymbolKeyword": return "symbol";
                    case "ObjectTypeCallProperty": return o.static && a.push("static "), a.push(e.call(n, "value")), qv(a);
                    case "ObjectTypeIndexer": {
                        const t = Uy(o);
                        return qv([t || "", "[", e.call(n, "id"), o.id ? ": " : "", e.call(n, "key"), "]: ", e.call(n, "value")]);
                    }
                    case "ObjectTypeProperty": {
                        const r = Uy(o);
                        let i = "";
                        return o.proto ? i = "proto " : o.static && (i = "static "), qv([i, pv(o) ? o.kind + " " : "", r || "", fb(e, t, n), kb(e), cv(o, t) ? "" : ": ", e.call(n, "value")]);
                    }
                    case "QualifiedTypeIdentifier": return qv([e.call(n, "qualification"), ".", e.call(n, "id")]);
                    case "NumberLiteralTypeAnnotation": return Ci.strictEqual(typeof o.value, "number"), null != o.extra ? xy(o.extra.raw) : xy(o.raw);
                    case "StringTypeAnnotation":
                    case "TSStringKeyword": return "string";
                    case "DeclareTypeAlias":
                    case "TypeAlias": {
                        ("DeclareTypeAlias" === o.type || o.declare) && a.push("declare ");
                        const r = Rb(o.id, o.right, e.call(n, "right"), t);
                        return a.push("type ", e.call(n, "id"), e.call(n, "typeParameters"), " =", r, i), zv(qv(a));
                    }
                    case "TypeCastExpression": return qv(["(", e.call(n, "expression"), yb(e, t, n), ")"]);
                    case "TypeParameterDeclaration":
                    case "TypeParameterInstantiation": {
                        const r = e.getValue(), o = r.range ? t.originalText.slice(0, r.range[0]).lastIndexOf("/*") : -1;
                        return o >= 0 && t.originalText.slice(o).match(/^\/\*\s*::/) ? qv(["/*:: ", xb(e, t, n, "params"), " */"]) : xb(e, t, n, "params");
                    }
                    case "TSTypeParameterDeclaration":
                    case "TSTypeParameterInstantiation": return xb(e, t, n, "params");
                    case "TSTypeParameter":
                    case "TypeParameter": {
                        const r = e.getParentNode();
                        if ("TSMappedType" === r.type)
                            return a.push("[", e.call(n, "name")), o.constraint && a.push(" in ", e.call(n, "constraint")), a.push("]"), qv(a);
                        const i = Uy(o);
                        i && a.push(i), a.push(e.call(n, "name")), o.bound && (a.push(": "), a.push(e.call(n, "bound"))), o.constraint && a.push(" extends ", e.call(n, "constraint")), o.default && a.push(" = ", e.call(n, "default"));
                        const s = e.getNode(2);
                        return r.params && 1 === r.params.length && Pv(t) && !o.constraint && "ArrowFunctionExpression" === s.type && a.push(","), qv(a);
                    }
                    case "TypeofTypeAnnotation": return qv(["typeof ", e.call(n, "argument")]);
                    case "VoidTypeAnnotation":
                    case "TSVoidKeyword": return "void";
                    case "InferredPredicate": return "%checks";
                    case "DeclaredPredicate": return qv(["%checks(", e.call(n, "value"), ")"]);
                    case "TSAbstractKeyword": return "abstract";
                    case "TSAsyncKeyword": return "async";
                    case "TSBigIntKeyword": return "bigint";
                    case "TSConstKeyword": return "const";
                    case "TSDeclareKeyword": return "declare";
                    case "TSExportKeyword": return "export";
                    case "TSNeverKeyword": return "never";
                    case "TSObjectKeyword": return "object";
                    case "TSProtectedKeyword": return "protected";
                    case "TSPrivateKeyword": return "private";
                    case "TSPublicKeyword": return "public";
                    case "TSReadonlyKeyword": return "readonly";
                    case "TSStaticKeyword": return "static";
                    case "TSUndefinedKeyword": return "undefined";
                    case "TSUnknownKeyword": return "unknown";
                    case "TSAsExpression": return qv([e.call(n, "expression"), " as ", e.call(n, "typeAnnotation")]);
                    case "TSPropertySignature": return o.export && a.push("export "), o.accessibility && a.push(o.accessibility + " "), o.static && a.push("static "), o.readonly && a.push("readonly "), a.push(fb(e, t, n), kb(e)), o.typeAnnotation && (a.push(": "), a.push(e.call(n, "typeAnnotation"))), o.initializer && a.push(" = ", e.call(n, "initializer")), qv(a);
                    case "TSParameterProperty": return o.accessibility && a.push(o.accessibility + " "), o.export && a.push("export "), o.static && a.push("static "), o.readonly && a.push("readonly "), a.push(e.call(n, "parameter")), qv(a);
                    case "TSTypeReference": return qv([e.call(n, "typeName"), xb(e, t, n, "typeParameters")]);
                    case "TSTypeQuery": return qv(["typeof ", e.call(n, "exprName")]);
                    case "TSIndexSignature": {
                        const r = e.getParentNode(), s = o.parameters.length > 1 ? Xv(ub(t) ? "," : "") : "", a = zv(qv([Hv(qv([Wv, $v(qv([", ", Wv]), e.map(n, "parameters"))])), s, Wv]));
                        return qv([o.export ? "export " : "", o.accessibility ? qv([o.accessibility, " "]) : "", o.static ? "static " : "", o.readonly ? "readonly " : "", "[", o.parameters ? a : "", o.typeAnnotation ? "]: " : "]", o.typeAnnotation ? e.call(n, "typeAnnotation") : "", "ClassBody" === r.type ? i : ""]);
                    }
                    case "TSTypePredicate": return qv([o.asserts ? "asserts " : "", e.call(n, "parameterName"), o.typeAnnotation ? qv([" is ", e.call(n, "typeAnnotation")]) : ""]);
                    case "TSNonNullExpression": return qv([e.call(n, "expression"), "!"]);
                    case "TSImportType": return qv([o.isTypeOf ? "typeof " : "", "import(", e.call(n, o.parameter ? "parameter" : "argument"), ")", o.qualifier ? qv([".", e.call(n, "qualifier")]) : "", xb(e, t, n, "typeParameters")]);
                    case "TSLiteralType": return e.call(n, "literal");
                    case "TSIndexedAccessType": return qv([e.call(n, "objectType"), "[", e.call(n, "indexType"), "]"]);
                    case "TSConstructSignatureDeclaration":
                    case "TSCallSignatureDeclaration":
                    case "TSConstructorType":
                        if ("TSCallSignatureDeclaration" !== o.type && a.push("new "), a.push(zv(bb(e, n, t, !1, !0))), o.returnType || o.typeAnnotation) {
                            const t = "TSConstructorType" === o.type;
                            a.push(t ? " => " : ": ", e.call(n, "returnType"), e.call(n, "typeAnnotation"));
                        }
                        return qv(a);
                    case "TSTypeOperator": return qv([o.operator, " ", e.call(n, "typeAnnotation")]);
                    case "TSMappedType": {
                        const r = Cy(t.originalText, t.locStart(o), t.locEnd(o));
                        return zv(qv(["{", Hv(qv([t.bracketSpacing ? Uv : Wv, o.readonly ? qv([Ky(o.readonly, "readonly"), " "]) : "", Sb(e, 0, n), e.call(n, "typeParameter"), o.optional ? Ky(o.optional, "?") : "", o.typeAnnotation ? ": " : "", e.call(n, "typeAnnotation"), Xv(i, "")])), Sa.printDanglingComments(e, t, !0), t.bracketSpacing ? Uv : Wv, "}"]), { shouldBreak: r });
                    }
                    case "TSMethodSignature": return a.push(o.accessibility ? qv([o.accessibility, " "]) : "", o.export ? "export " : "", o.static ? "static " : "", o.readonly ? "readonly " : "", o.computed ? "[" : "", e.call(n, "key"), o.computed ? "]" : "", kb(e), bb(e, n, t, !1, !0)), (o.returnType || o.typeAnnotation) && a.push(": ", e.call(n, "returnType"), e.call(n, "typeAnnotation")), zv(qv(a));
                    case "TSNamespaceExportDeclaration": return a.push("export as namespace ", e.call(n, "id")), t.semi && a.push(";"), zv(qv(a));
                    case "TSEnumDeclaration": return o.declare && a.push("declare "), o.modifiers && a.push(Sb(e, 0, n)), o.const && a.push("const "), a.push("enum ", e.call(n, "id"), " "), 0 === o.members.length ? a.push(zv(qv(["{", Sa.printDanglingComments(e, t), Wv, "}"]))) : a.push(zv(qv(["{", Hv(qv([Vv, Vb(e, t, "members", n), ub(t, "es5") ? "," : ""])), Sa.printDanglingComments(e, t, !0), Vv, "}"]))), qv(a);
                    case "TSEnumMember": return a.push(e.call(n, "id")), o.initializer && a.push(" = ", e.call(n, "initializer")), qv(a);
                    case "TSImportEqualsDeclaration": return o.isExport && a.push("export "), a.push("import ", e.call(n, "id"), " = ", e.call(n, "moduleReference")), t.semi && a.push(";"), zv(qv(a));
                    case "TSExternalModuleReference": return qv(["require(", e.call(n, "expression"), ")"]);
                    case "TSModuleDeclaration": {
                        const r = e.getParentNode(), s = gv(o.id), u = "TSModuleDeclaration" === r.type, c = o.body && "TSModuleDeclaration" === o.body.type;
                        if (u)
                            a.push(".");
                        else {
                            o.declare && a.push("declare "), a.push(Sb(e, 0, n));
                            const r = t.originalText.slice(t.locStart(o), t.locStart(o.id));
                            "Identifier" === o.id.type && "global" === o.id.name && !/namespace|module/.test(r) || a.push(s || /(^|\s)module(\s|$)/.test(r) ? "module " : "namespace ");
                        }
                        return a.push(e.call(n, "id")), c ? a.push(e.call(n, "body")) : o.body ? a.push(" ", zv(e.call(n, "body"))) : a.push(i), qv(a);
                    }
                    case "PrivateName": return qv(["#", e.call(n, "id")]);
                    case "TSPrivateIdentifier": return o.escapedText;
                    case "TSConditionalType": return lb(e, t, n, { beforeParts: () => [e.call(n, "checkType"), " ", "extends", " ", e.call(n, "extendsType")], afterParts: () => [], shouldCheckJsx: !1, conditionalNodeType: "TSConditionalType", consequentNodePropertyName: "trueType", alternateNodePropertyName: "falseType", testNodePropertyNames: ["checkType", "extendsType"] });
                    case "TSInferType": return qv(["infer", " ", e.call(n, "typeParameter")]);
                    case "InterpreterDirective": return a.push("#!", o.value, Vv), Py(t.originalText, o, t.locEnd) && a.push(Vv), qv(a);
                    case "NGRoot": return qv([].concat(e.call(n, "node"), o.node.comments && 0 !== o.node.comments.length ? qv([" //", o.node.comments[0].value.trimEnd()]) : []));
                    case "NGChainedExpression": return zv($v(qv([";", Uv]), e.map((e => Zy(e) ? n(e) : qv(["(", n(e), ")"])), "expressions")));
                    case "NGQuotedExpression": return qv([o.prefix, ": ", o.value.trim()]);
                    case "NGMicrosyntax": return qv(e.map(((e, t) => qv([0 === t ? "" : Ev(e.getValue(), t, o) ? " " : qv([";", Uv]), n(e)])), "body"));
                    case "NGMicrosyntaxKey": return /^[a-z_$][a-z0-9_$]*(-[a-z_$][a-z0-9_$])*$/i.test(o.name) ? o.name : JSON.stringify(o.name);
                    case "NGMicrosyntaxExpression": return qv([e.call(n, "expression"), null === o.alias ? "" : qv([" as ", e.call(n, "alias")])]);
                    case "NGMicrosyntaxKeyedExpression": {
                        const t = e.getName(), r = e.getParentNode(), i = Ev(o, t, r) || (1 === t && ("then" === o.key.name || "else" === o.key.name) || 2 === t && "else" === o.key.name && "NGMicrosyntaxKeyedExpression" === r.body[t - 1].type && "then" === r.body[t - 1].key.name) && "NGMicrosyntaxExpression" === r.body[0].type;
                        return qv([e.call(n, "key"), i ? " " : ": ", e.call(n, "expression")]);
                    }
                    case "NGMicrosyntaxLet": return qv(["let ", e.call(n, "key"), null === o.value ? "" : qv([" = ", e.call(n, "value")])]);
                    case "NGMicrosyntaxAs": return qv([e.call(n, "key"), " as ", e.call(n, "alias")]);
                    case "ArgumentPlaceholder":
                    case "TSJSDocUnknownType": return "?";
                    case "TSJSDocNonNullableType": return qv(["!", e.call(n, "typeAnnotation")]);
                    case "TSJSDocFunctionType": return qv(["function(", "): ", e.call(n, "typeAnnotation")]);
                    default: throw new Error("unknown type: " + JSON.stringify(o.type));
                } }(e, t, n, r); if (!o || ob(s))
                    return s; const a = Wy(e), u = []; if ("ClassMethod" === o.type || "ClassPrivateMethod" === o.type || "ClassProperty" === o.type || "TSAbstractClassProperty" === o.type || "ClassPrivateProperty" === o.type || "MethodDefinition" === o.type || "TSAbstractMethodDefinition" === o.type || "TSDeclareMethod" === o.type)
                    ;
                else if (o.decorators && o.decorators.length > 0 && !(a && t.locStart(a, { ignoreDecorators: !0 }) > t.locStart(o.decorators[0]))) {
                    const r = "ClassExpression" === o.type || "ClassDeclaration" === o.type || Qy(o, t) ? Vv : Uv;
                    e.each((e => { let t = e.getValue(); t = t.expression ? t.expression : t.callee, u.push(n(e), r); }), "decorators"), a && u.unshift(Vv);
                }
                else
                    sv(o) && o.declaration && o.declaration.decorators && o.declaration.decorators.length > 0 && t.locStart(o, { ignoreDecorators: !0 }) > t.locStart(o.declaration.decorators[0]) ? e.each((e => { const t = "Decorator" === e.getValue().type ? "" : "@"; u.push(t, n(e), Vv); }), "declaration", "decorators") : i = dy(e, t); const c = []; if (i && c.unshift("("), c.push(s), i) {
                    const t = e.getValue();
                    Yy(t) && (c.push(" /*"), c.push(t.trailingComments[0].value.trimStart()), c.push("*/"), t.trailingComments[0].printed = !0), c.push(")");
                } return u.length > 0 ? zv(qv(u.concat(c))) : qv(c); }, embed: function (e, t, n, r) { const o = e.getValue(), i = e.getParentNode(), s = e.getParentNode(1); switch (o.type) {
                    case "TemplateLiteral": {
                        if ([vg, Eg, Cg, bg].some((t => t(e)))) {
                            const r = o.quasis.map((e => e.value.raw));
                            let i = 0;
                            const s = r.reduce(((e, t, n) => 0 === n ? t : e + "@prettier-placeholder-" + i++ + "-id" + t), "");
                            return function (e, t, n) { const r = t.getValue(); if (1 === r.quasis.length && !r.quasis[0].value.raw.trim())
                                return "``"; const o = function (e, t) { if (!t || !t.length)
                                return e; const n = t.slice(); let r = 0; const o = dg(e, (e => { if (!e || !e.parts || !e.parts.length)
                                return e; let { parts: t } = e; const o = t.indexOf("@"), i = o + 1; if (o > -1 && "string" == typeof t[i] && t[i].startsWith("prettier-placeholder")) {
                                const e = t[o], n = t[i], r = t.slice(i + 1);
                                t = t.slice(0, o).concat([e + n]).concat(r);
                            } const s = t.findIndex((e => "string" == typeof e && e.startsWith("@prettier-placeholder"))); if (s > -1) {
                                const e = t[s], o = t.slice(s + 1), i = e.match(/@prettier-placeholder-(.+)-id([\s\S]*)/), a = i[1], u = i[2], c = n[a];
                                r++, t = t.slice(0, s).concat(["${", c, "}" + u]).concat(o);
                            } return Object.assign({}, e, { parts: t }); })); return n.length === r ? o : null; }(e, r.expressions ? t.map(n, "expressions") : []); if (!o)
                                throw new Error("Couldn't insert all the expressions"); return lg(["`", og(lg([ag, hg(o)])), ug, "`"]); }(n(s, { parser: "scss" }), e, t);
                        }
                        if (function (e) { const t = e.getValue(), n = e.getParentNode(); return Sg(t, "GraphQL") || n && ("TaggedTemplateExpression" === n.type && ("MemberExpression" === n.tag.type && "graphql" === n.tag.object.name && "experimental" === n.tag.property.name || "Identifier" === n.tag.type && ("gql" === n.tag.name || "graphql" === n.tag.name)) || "CallExpression" === n.type && "Identifier" === n.callee.type && "graphql" === n.callee.name); }(e)) {
                            const r = o.expressions ? e.map(t, "expressions") : [], i = o.quasis.length;
                            if (1 === i && "" === o.quasis[0].value.raw.trim())
                                return "``";
                            const s = [];
                            for (let e = 0; e < i; e++) {
                                const t = 0 === e, a = e === i - 1, u = o.quasis[e].value.cooked;
                                if ("string" != typeof u)
                                    return null;
                                const c = u.split("\n"), l = c.length, p = r[e], f = l > 2 && "" === c[0].trim() && "" === c[1].trim(), d = l > 2 && "" === c[l - 1].trim() && "" === c[l - 2].trim(), h = c.every((e => /^\s*(?:#[^\r\n]*)?$/.test(e)));
                                if (!a && /#[^\r\n]*$/.test(c[l - 1]))
                                    return null;
                                let m = null;
                                m = h ? yg(c) : hg(n(u, { parser: "graphql" })), m ? (m = gg(m, !1), !t && f && s.push(""), s.push(m), !a && d && s.push("")) : t || a || !f || s.push(""), p && s.push(lg(["${", p, "}"]));
                            }
                            return lg(["`", og(lg([ag, ig(ag, s)])), ag, "`"]);
                        }
                        const i = function (e) { return Sg(e.getValue(), "HTML") || e.match((e => "TemplateLiteral" === e.type), ((e, t) => "TaggedTemplateExpression" === e.type && "Identifier" === e.tag.type && "html" === e.tag.name && "quasi" === t)); }(e) ? "html" : function (e) { return e.match((e => "TemplateLiteral" === e.type), ((e, t) => ("Property" === e.type || "ObjectProperty" === e.type) && "Identifier" === e.key.type && "template" === e.key.name && "value" === t), ...Dg); }(e) ? "angular" : void 0;
                        if (i)
                            return function (e, t, n, r, o) { const i = e.getValue(), s = xg; xg = xg + 1 >>> 0; const a = e => "PRETTIER_HTML_PLACEHOLDER_".concat(e, "_").concat(s, "_IN_JS"), u = i.quasis.map(((e, t, n) => t === n.length - 1 ? e.value.cooked : e.value.cooked + a(t))).join(""), c = e.map(t, "expressions"); if (0 === c.length && 0 === u.trim().length)
                                return "``"; const l = new RegExp(a("(\\d+)"), "g"); let p = 0; const f = dg(hg(n(u, { parser: r, __onHtmlRoot(e) { p = e.children.length; } })), (e => { if ("string" != typeof e)
                                return e; const t = [], n = e.split(l); for (let e = 0; e < n.length; e++) {
                                let r = n[e];
                                if (e % 2 == 0) {
                                    r && (r = mg(r), o.embeddedInHtml && (r = r.replace(/<\/(script)\b/gi, "<\\/$1")), t.push(r));
                                    continue;
                                }
                                const i = +r;
                                t.push(lg(["${", pg(c[i]), "}"]));
                            } return lg(t); })), d = /^\s/.test(u) ? " " : "", h = /\s$/.test(u) ? " " : "", m = "ignore" === o.htmlWhitespaceSensitivity ? ag : d && h ? sg : null; return pg(lg(m ? ["`", og(lg([m, pg(f)])), m, "`"] : ["`", d, p > 1 ? og(pg(f)) : pg(f), h, "`"])); }(e, t, n, i, r);
                        break;
                    }
                    case "TemplateElement": if (s && "TaggedTemplateExpression" === s.type && 1 === i.quasis.length && "Identifier" === s.tag.type && ("md" === s.tag.name || "markdown" === s.tag.name)) {
                        const e = i.quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g, ((e, t) => "\\".repeat(t.length / 2) + "`")), t = function (e) { const t = e.match(/^([^\S\n]*)\S/m); return null === t ? "" : t[1]; }(e);
                        return lg(["" !== t ? og(lg([ug, a(e.replace(new RegExp("^".concat(t), "gm"), ""))])) : lg([cg, fg(a(e))]), ug]);
                    }
                } function a(e) { const t = n(e, { parser: "markdown", __inJsTemplate: !0 }); return hg(gg(t, !0)); } }, insertPragma: Iy, massageAstNode: function (e, t, n) { if (["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "flags", "errors"].forEach((e => { delete t[e]; })), e.loc && null === e.loc.source && delete t.loc.source, "BigIntLiteral" === e.type && (t.value = t.value.toLowerCase()), "EmptyStatement" === e.type)
                    return null; if ("JSXText" === e.type)
                    return null; if ("JSXExpressionContainer" === e.type && "Literal" === e.expression.type && " " === e.expression.value)
                    return null; if ("TSParameterProperty" === e.type && null === e.accessibility && !e.readonly)
                    return { type: "Identifier", name: e.parameter.name, typeAnnotation: t.parameter.typeAnnotation, decorators: t.decorators }; "TSNamespaceExportDeclaration" === e.type && e.specifiers && 0 === e.specifiers.length && delete t.specifiers, "JSXOpeningElement" === e.type && delete t.selfClosing, "JSXElement" === e.type && delete t.closingElement, "Property" !== e.type && "ObjectProperty" !== e.type && "MethodDefinition" !== e.type && "ClassProperty" !== e.type && "TSPropertySignature" !== e.type && "ObjectTypeProperty" !== e.type || "object" != typeof e.key || !e.key || "Literal" !== e.key.type && "StringLiteral" !== e.key.type && "Identifier" !== e.key.type || delete t.key, "OptionalMemberExpression" === e.type && !1 === e.optional && (t.type = "MemberExpression", delete t.optional), "JSXElement" === e.type && "style" === e.openingElement.name.name && e.openingElement.attributes.some((e => "jsx" === e.name.name)) && t.children.filter((e => "JSXExpressionContainer" === e.type && "TemplateLiteral" === e.expression.type)).map((e => e.expression)).reduce(((e, t) => e.concat(t.quasis)), []).forEach((e => delete e.value)), "JSXAttribute" === e.type && "css" === e.name.name && "JSXExpressionContainer" === e.value.type && "TemplateLiteral" === e.value.expression.type && t.value.expression.quasis.forEach((e => delete e.value)); const r = e.expression || e.callee; if ("Decorator" === e.type && "CallExpression" === r.type && "Component" === r.callee.name && 1 === r.arguments.length) {
                    const n = e.expression.arguments[0].properties;
                    t.expression.arguments[0].properties.forEach(((e, t) => { let r = null; switch (n[t].key.name) {
                        case "styles":
                            "ArrayExpression" === e.value.type && (r = e.value.elements[0]);
                            break;
                        case "template": "TemplateLiteral" === e.value.type && (r = e.value);
                    } r && r.quasis.forEach((e => delete e.value)); }));
                } "TaggedTemplateExpression" !== e.type || "MemberExpression" !== e.tag.type && ("Identifier" !== e.tag.type || "gql" !== e.tag.name && "graphql" !== e.tag.name && "css" !== e.tag.name && "md" !== e.tag.name && "markdown" !== e.tag.name && "html" !== e.tag.name) && "CallExpression" !== e.tag.type || t.quasi.quasis.forEach((e => delete e.value)), "TemplateLiteral" === e.type && (e.leadingComments && e.leadingComments.some((e => "CommentBlock" === e.type && ["GraphQL", "HTML"].some((t => e.value === " ".concat(t, " "))))) || "CallExpression" === n.type && "graphql" === n.callee.name) && t.quasis.forEach((e => delete e.value)); }, hasPrettierIgnore: ev, willPrintOwnComments: function (e) { const t = e.getValue(), n = e.getParentNode(); return (t && (dv(t) || Yy(t) || n && ("CallExpression" === n.type || "OptionalCallExpression" === n.type) && (Hy(t.leadingComments) || Hy(t.trailingComments))) || n && ("JSXSpreadAttribute" === n.type || "JSXSpreadChild" === n.type || "UnionTypeAnnotation" === n.type || "TSUnionType" === n.type || ("ClassDeclaration" === n.type || "ClassExpression" === n.type) && n.superClass === t)) && (!Ty(e) || "UnionTypeAnnotation" === n.type || "TSUnionType" === n.type); }, canAttachComment: function (e) { return e.type && "CommentBlock" !== e.type && "CommentLine" !== e.type && "Line" !== e.type && "Block" !== e.type && "EmptyStatement" !== e.type && "TemplateElement" !== e.type && "Import" !== e.type; }, printComment: function (e, t) { const n = e.getValue(); switch (n.type) {
                    case "CommentBlock":
                    case "Block": {
                        if (function (e) { const t = "*".concat(e.value, "*").split("\n"); return t.length > 1 && t.every((e => "*" === e.trim()[0])); }(n)) {
                            const e = function (e) { const t = e.value.split("\n"); return qv(["/*", $v(Vv, t.map(((e, n) => 0 === n ? e.trimEnd() : " " + (n < t.length - 1 ? e.trim() : e.trimStart())))), "*/"]); }(n);
                            return n.trailing && !Ey(t.originalText, t.locStart(n), { backwards: !0 }) ? qv([Vv, e]) : e;
                        }
                        const e = t.locEnd(n), r = "*-/" === t.originalText.slice(e - 3, e);
                        return "/*" + n.value + (r ? "*-/" : "*/");
                    }
                    case "CommentLine":
                    case "Line": return t.originalText.slice(t.locStart(n)).startsWith("#!") ? "#!" + n.value.trimEnd() : "//" + n.value.trimEnd();
                    default: throw new Error("Not a comment: " + JSON.stringify(n));
                } }, isBlockComment: tg.isBlockComment, handleComments: { ownLine: tg.handleOwnLineComment, endOfLine: tg.handleEndOfLineComment, remaining: tg.handleRemainingComment }, getGapRegex: tg.getGapRegex, getCommentChildNodes: tg.getCommentChildNodes }; const { concat: zb, hardline: Hb, indent: Yb, join: Jb } = Ps.builders; var Gb = { preprocess: vy, print: function (e, t, n) { const r = e.getValue(); switch (r.type) {
                    case "JsonRoot": return zb([e.call(n, "node"), Hb]);
                    case "ArrayExpression": return 0 === r.elements.length ? "[]" : zb(["[", Yb(zb([Hb, Jb(zb([",", Hb]), e.map(n, "elements"))])), Hb, "]"]);
                    case "ObjectExpression": return 0 === r.properties.length ? "{}" : zb(["{", Yb(zb([Hb, Jb(zb([",", Hb]), e.map(n, "properties"))])), Hb, "}"]);
                    case "ObjectProperty": return zb([e.call(n, "key"), ": ", e.call(n, "value")]);
                    case "UnaryExpression": return zb(["+" === r.operator ? "" : r.operator, e.call(n, "argument")]);
                    case "NullLiteral": return "null";
                    case "BooleanLiteral": return r.value ? "true" : "false";
                    case "StringLiteral":
                    case "NumericLiteral": return JSON.stringify(r.value);
                    case "Identifier": return JSON.stringify(r.name);
                    default: throw new Error("unknown type: " + JSON.stringify(r.type));
                } }, massageAstNode: function (e, t) { return delete t.start, delete t.end, delete t.extra, delete t.loc, delete t.comments, delete t.errors, "Identifier" === e.type ? { type: "StringLiteral", value: e.name } : "UnaryExpression" === e.type && "+" === e.operator ? t.argument : void 0; } }; const Xb = "JavaScript"; var Qb = { arrowParens: { since: "1.9.0", category: Xb, type: "choice", default: [{ since: "1.9.0", value: "avoid" }, { since: "2.0.0", value: "always" }], description: "Include parentheses around a sole arrow function parameter.", choices: [{ value: "always", description: "Always include parens. Example: `(x) => x`" }, { value: "avoid", description: "Omit parens when possible. Example: `x => x`" }] }, bracketSpacing: Kc.bracketSpacing, jsxBracketSameLine: { since: "0.17.0", category: Xb, type: "boolean", default: !1, description: "Put > on the last line instead of at a new line." }, semi: { since: "1.0.0", category: Xb, type: "boolean", default: !0, description: "Print semicolons.", oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them." }, singleQuote: Kc.singleQuote, jsxSingleQuote: { since: "1.15.0", category: Xb, type: "boolean", default: !1, description: "Use single quotes in JSX." }, quoteProps: { since: "1.17.0", category: Xb, type: "choice", default: "as-needed", description: "Change when properties in objects are quoted.", choices: [{ value: "as-needed", description: "Only add quotes around object properties where required." }, { value: "consistent", description: "If at least one property in an object requires quotes, quote all properties." }, { value: "preserve", description: "Respect the input use of quotes in object properties." }] }, trailingComma: { since: "0.0.0", category: Xb, type: "choice", default: [{ since: "0.0.0", value: !1 }, { since: "0.19.0", value: "none" }, { since: "2.0.0", value: "es5" }], description: "Print trailing commas wherever possible when multi-line.", choices: [{ value: "es5", description: "Trailing commas where valid in ES5 (objects, arrays, etc.)" }, { value: "none", description: "No trailing commas." }, { value: "all", description: "Trailing commas wherever possible (including function arguments)." }] } }, Zb = "JavaScript", eD = "programming", tD = "source.js", nD = "javascript", rD = "javascript", oD = "text/javascript", iD = "#f1e05a", sD = ["js", "node"], aD = [".js", "._js", ".bones", ".cjs", ".es", ".es6", ".frag", ".gs", ".jake", ".jsb", ".jscad", ".jsfl", ".jsm", ".jss", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib"], uD = ["Jakefile"], cD = ["chakra", "d8", "gjs", "js", "node", "qjs", "rhino", "v8", "v8-shell"], lD = { name: Zb, type: eD, tmScope: tD, aceMode: nD, codemirrorMode: rD, codemirrorMimeType: oD, color: iD, aliases: sD, extensions: aD, filenames: uD, interpreters: cD, languageId: 183 }, pD = Object.freeze({ __proto__: null, name: Zb, type: eD, tmScope: tD, aceMode: nD, codemirrorMode: rD, codemirrorMimeType: oD, color: iD, aliases: sD, extensions: aD, filenames: uD, interpreters: cD, languageId: 183, default: lD }), fD = "programming", dD = "JavaScript", hD = [".jsx"], mD = "source.js.jsx", gD = "javascript", yD = "text/jsx", vD = { name: "JSX", type: fD, group: dD, extensions: hD, tmScope: mD, aceMode: gD, codemirrorMode: "jsx", codemirrorMimeType: yD, languageId: 178 }, bD = Object.freeze({ __proto__: null, name: "JSX", type: fD, group: dD, extensions: hD, tmScope: mD, aceMode: gD, codemirrorMode: "jsx", codemirrorMimeType: yD, languageId: 178, default: vD }), DD = "TypeScript", ED = "programming", CD = "#2b7489", wD = ["ts"], AD = ["deno", "ts-node"], SD = [".ts"], xD = "source.ts", TD = "typescript", kD = "javascript", FD = "application/typescript", OD = { name: DD, type: ED, color: CD, aliases: wD, interpreters: AD, extensions: SD, tmScope: xD, aceMode: TD, codemirrorMode: kD, codemirrorMimeType: FD, languageId: 378 }, _D = Object.freeze({ __proto__: null, name: DD, type: ED, color: CD, aliases: wD, interpreters: AD, extensions: SD, tmScope: xD, aceMode: TD, codemirrorMode: kD, codemirrorMimeType: FD, languageId: 378, default: OD }), ND = "programming", PD = "TypeScript", MD = [".tsx"], RD = "source.tsx", ID = "javascript", jD = "text/jsx", BD = 94901924, LD = { name: "TSX", type: ND, group: PD, extensions: MD, tmScope: RD, aceMode: ID, codemirrorMode: "jsx", codemirrorMimeType: jD, languageId: BD }, qD = Object.freeze({ __proto__: null, name: "TSX", type: ND, group: PD, extensions: MD, tmScope: RD, aceMode: ID, codemirrorMode: "jsx", codemirrorMimeType: jD, languageId: BD, default: LD }), $D = "JSON", UD = "data", VD = "source.json", WD = "json", KD = "javascript", zD = "application/json", HD = [".json", ".avsc", ".geojson", ".gltf", ".har", ".ice", ".JSON-tmLanguage", ".jsonl", ".mcmeta", ".tfstate", ".tfstate.backup", ".topojson", ".webapp", ".webmanifest", ".yy", ".yyp"], YD = [".arcconfig", ".htmlhintrc", ".tern-config", ".tern-project", ".watchmanconfig", "composer.lock", "mcmod.info"], JD = { name: $D, type: UD, tmScope: VD, aceMode: WD, codemirrorMode: KD, codemirrorMimeType: zD, searchable: !1, extensions: HD, filenames: YD, languageId: 174 }, GD = Object.freeze({ __proto__: null, name: $D, type: UD, tmScope: VD, aceMode: WD, codemirrorMode: KD, codemirrorMimeType: zD, searchable: !1, extensions: HD, filenames: YD, languageId: 174, default: JD }), XD = "JSON with Comments", QD = "data", ZD = "JSON", eE = "source.js", tE = "javascript", nE = "javascript", rE = "text/javascript", oE = ["jsonc"], iE = [".jsonc", ".sublime-build", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"], sE = [".babelrc", ".eslintrc.json", ".jscsrc", ".jshintrc", ".jslintrc", "jsconfig.json", "language-configuration.json", "tsconfig.json"], aE = { name: XD, type: QD, group: ZD, tmScope: eE, aceMode: tE, codemirrorMode: nE, codemirrorMimeType: rE, aliases: oE, extensions: iE, filenames: sE, languageId: 423 }, uE = Object.freeze({ __proto__: null, name: XD, type: QD, group: ZD, tmScope: eE, aceMode: tE, codemirrorMode: nE, codemirrorMimeType: rE, aliases: oE, extensions: iE, filenames: sE, languageId: 423, default: aE }), cE = "JSON5", lE = "data", pE = [".json5"], fE = "source.js", dE = "javascript", hE = "javascript", mE = "application/json", gE = { name: cE, type: lE, extensions: pE, tmScope: fE, aceMode: dE, codemirrorMode: hE, codemirrorMimeType: mE, languageId: 175 }, yE = Object.freeze({ __proto__: null, name: cE, type: lE, extensions: pE, tmScope: fE, aceMode: dE, codemirrorMode: hE, codemirrorMimeType: mE, languageId: 175, default: gE }), vE = at(pD), bE = at(bD), DE = at(_D), EE = at(qD), CE = at(GD), wE = at(uE), AE = at(yE), SE = { languages: [Hc(vE, (e => ({ since: "0.0.0", parsers: ["babel", "flow"], vscodeLanguageIds: ["javascript", "mongo"], interpreters: e.interpreters.concat(["nodejs"]) }))), Hc(vE, (() => ({ name: "Flow", since: "0.0.0", parsers: ["babel", "flow"], vscodeLanguageIds: ["javascript"], aliases: [], filenames: [], extensions: [".js.flow"] }))), Hc(bE, (() => ({ since: "0.0.0", parsers: ["babel", "flow"], vscodeLanguageIds: ["javascriptreact"] }))), Hc(DE, (() => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescript"] }))), Hc(EE, (() => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescriptreact"] }))), Hc(CE, (() => ({ name: "JSON.stringify", since: "1.13.0", parsers: ["json-stringify"], vscodeLanguageIds: ["json"], extensions: [], filenames: ["package.json", "package-lock.json", "composer.json"] }))), Hc(CE, (e => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["json"], filenames: e.filenames.concat([".prettierrc"]) }))), Hc(wE, (e => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["jsonc"], filenames: e.filenames.concat([".eslintrc"]) }))), Hc(AE, (() => ({ since: "1.13.0", parsers: ["json5"], vscodeLanguageIds: ["json5"] })))], options: Qb, printers: { estree: Kb, "estree-json": Gb } }; const { cjkPattern: xE, kPattern: TE, punctuationPattern: kE } = { cjkPattern: "[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u3000-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d]", kPattern: "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]", punctuationPattern: "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]" }, { getLast: FE } = ls, OE = ["liquidNode", "inlineCode", "emphasis", "strong", "delete", "link", "linkReference", "image", "imageReference", "footnote", "footnoteReference", "sentence", "whitespace", "word", "break", "inlineMath"], _E = OE.concat(["tableCell", "paragraph", "heading"]), NE = new RegExp(TE), PE = new RegExp(kE); function ME(e, t) { const [, n, r, o] = t.slice(e.position.start.offset, e.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/); return { numberText: n, marker: r, leadingSpaces: o }; } var RE = { mapAst: function (e, t) { return function e(n, r, o) { o = o || []; const i = Object.assign({}, t(n, r, o)); return i.children && (i.children = i.children.map(((t, n) => e(t, n, [i].concat(o))))), i; }(e, null, null); }, splitText: function (e, t) { const n = "non-cjk", r = "cj-letter", o = "cjk-punctuation", i = []; return ("preserve" === t.proseWrap ? e : e.replace(new RegExp("(".concat(xE, ")\n(").concat(xE, ")"), "g"), "$1$2")).split(/([ \t\n]+)/).forEach(((e, t, a) => { t % 2 != 1 ? (0 !== t && t !== a.length - 1 || "" !== e) && e.split(new RegExp("(".concat(xE, ")"))).forEach(((e, t, i) => { (0 !== t && t !== i.length - 1 || "" !== e) && (t % 2 != 0 ? s(PE.test(e) ? { type: "word", value: e, kind: o, hasLeadingPunctuation: !0, hasTrailingPunctuation: !0 } : { type: "word", value: e, kind: NE.test(e) ? "k-letter" : r, hasLeadingPunctuation: !1, hasTrailingPunctuation: !1 }) : "" !== e && s({ type: "word", value: e, kind: n, hasLeadingPunctuation: PE.test(e[0]), hasTrailingPunctuation: PE.test(FE(e)) })); })) : i.push({ type: "whitespace", value: /\n/.test(e) ? "\n" : " " }); })), i; function s(e) { const t = FE(i); var s, a; t && "word" === t.type && (t.kind === n && e.kind === r && !t.hasTrailingPunctuation || t.kind === r && e.kind === n && !e.hasLeadingPunctuation ? i.push({ type: "whitespace", value: " " }) : (s = n, a = o, t.kind === s && e.kind === a || t.kind === a && e.kind === s || [t.value, e.value].some((e => /\u3000/.test(e))) || i.push({ type: "whitespace", value: "" }))), i.push(e); } }, punctuationPattern: kE, getFencedCodeBlockValue: function (e, t) { const n = t.slice(e.position.start.offset, e.position.end.offset), r = n.match(/^\s*/)[0].length, o = new RegExp("^\\s{0,".concat(r, "}")), i = n.split("\n"), s = n[r], a = n.slice(r).match(new RegExp("^[".concat(s, "]+")))[0], u = new RegExp("^\\s{0,3}".concat(a)).test(i[i.length - 1].slice(c(i.length - 1))); return i.slice(1, u ? -1 : void 0).map(((e, t) => e.slice(c(t + 1)).replace(o, ""))).join("\n"); function c(t) { return e.position.indent[t - 1] - 1; } }, getOrderedListItemInfo: ME, hasGitDiffFriendlyOrderedList: function (e, t) { if (!e.ordered)
                    return !1; if (e.children.length < 2)
                    return !1; const n = Number(ME(e.children[0], t.originalText).numberText), r = Number(ME(e.children[1], t.originalText).numberText); if (0 === n && e.children.length > 2) {
                    const n = Number(ME(e.children[2], t.originalText).numberText);
                    return 1 === r && 1 === n;
                } return 1 === r; }, INLINE_NODE_TYPES: OE, INLINE_NODE_WRAPPER_TYPES: _E }; const { builders: { hardline: IE, literalline: jE, concat: BE, markAsRoot: LE }, utils: { mapDoc: qE } } = Ps, { getFencedCodeBlockValue: $E } = RE; const UE = ["format", "prettier"]; function VE(e) { const t = "@(".concat(UE.join("|"), ")"), n = new RegExp(["\x3c!--\\s*".concat(t, "\\s*--\x3e"), "\x3c!--.*\r?\n[\\s\\S]*(^|\n)[^\\S\n]*".concat(t, "[^\\S\n]*($|\n)[\\s\\S]*\n.*--\x3e")].join("|"), "m"), r = e.match(n); return r && 0 === r.index; } var WE = { startWithPragma: VE, hasPragma: e => VE(pu(e).content.trimStart()), insertPragma: e => { const t = pu(e), n = "\x3c!-- @".concat(UE[0], " --\x3e"); return t.frontMatter ? "".concat(t.frontMatter.raw, "\n\n").concat(n, "\n\n").concat(t.content) : "".concat(n, "\n\n").concat(t.content); } }; const { getOrderedListItemInfo: KE, mapAst: zE, splitText: HE } = RE, YE = /^([\u0000-\uffff]|[\ud800-\udbff][\udc00-\udfff])$/; function JE(e, t, n) { return zE(e, (e => { if (!e.children)
                return e; const r = e.children.reduce(((e, r) => { const o = e[e.length - 1]; return o && t(o, r) ? e.splice(-1, 1, n(o, r)) : e.push(r), e; }), []); return Object.assign({}, e, { children: r }); })); } const { builders: { breakParent: GE, concat: XE, join: QE, line: ZE, literalline: eC, markAsRoot: tC, hardline: nC, softline: rC, ifBreak: oC, fill: iC, align: sC, indent: aC, group: uC }, utils: { mapDoc: cC }, printer: { printDocToString: lC } } = Ps, { getFencedCodeBlockValue: pC, hasGitDiffFriendlyOrderedList: fC, splitText: dC, punctuationPattern: hC, INLINE_NODE_TYPES: mC, INLINE_NODE_WRAPPER_TYPES: gC } = RE, { replaceEndOfLineWith: yC } = ls, vC = ["importExport"], bC = ["heading", "tableCell", "link"], DC = ["listItem", "definition", "footnoteDefinition"]; function EC(e, t, n, r) { const o = e.getValue(), i = null === o.checked ? "" : o.checked ? "[x] " : "[ ] "; return XE([i, TC(e, t, n, { processor: (e, o) => { if (0 === o && "list" !== e.getValue().type)
                        return sC(" ".repeat(i.length), e.call(n)); const s = " ".repeat((3, (a = t.tabWidth - r.length) < 0 ? 0 : a > 3 ? 3 : a)); var a; return XE([s, sC(s, e.call(n))]); } })]); } function CC(e, t) { return function (e, t, n) { n = n || (() => !0); let r = -1; for (const o of t.children)
                if (o.type === e.type && n(o) ? r++ : r = -1, o === e)
                    return r; }(e, t, (t => t.ordered === e.ordered)); } function wC(e, t) { const n = [].concat(t); let r, o = -1; for (; r = e.getParentNode(++o);)
                if (n.includes(r.type))
                    return o; return -1; } function AC(e, t) { const n = wC(e, t); return -1 === n ? null : e.getParentNode(n); } function SC(e, t, n) { if ("preserve" === n.proseWrap && "\n" === t)
                return nC; const r = "always" === n.proseWrap && !AC(e, bC); return "" !== t ? r ? ZE : " " : r ? rC : ""; } function xC(e, t, n) { const r = []; let o = null; const { children: i } = e.getValue(); return i.forEach(((e, t) => { switch (FC(e)) {
                case "start":
                    null === o && (o = { index: t, offset: e.position.end.offset });
                    break;
                case "end": null !== o && (r.push({ start: o, end: { index: t, offset: e.position.start.offset } }), o = null);
            } })), TC(e, t, n, { processor: (e, o) => { if (0 !== r.length) {
                    const e = r[0];
                    if (o === e.start.index)
                        return XE([i[e.start.index].value, t.originalText.slice(e.start.offset, e.end.offset), i[e.end.index].value]);
                    if (e.start.index < o && o < e.end.index)
                        return !1;
                    if (o === e.end.index)
                        return r.shift(), !1;
                } return e.call(n); } }); } function TC(e, t, n, r) { const o = (r = r || {}).postprocessor || XE, i = r.processor || (e => e.call(n)), s = e.getValue(), a = []; let u; return e.map(((e, n) => { const r = e.getValue(), o = i(e, n); if (!1 !== o) {
                const e = { parts: a, prevNode: u, parentNode: s, options: t };
                (function (e, t) { const n = 0 === t.parts.length, r = mC.includes(e.type), o = "html" === e.type && gC.includes(t.parentNode.type); return n || r || o; })(r, e) || (a.push(nC), u && vC.includes(u.type) || (function (e, t) { const n = (t.prevNode && t.prevNode.type) === e.type && DC.includes(e.type), r = "listItem" === t.parentNode.type && !t.parentNode.loose, o = t.prevNode && "listItem" === t.prevNode.type && t.prevNode.loose, i = "next" === FC(t.prevNode), s = "html" === e.type && t.prevNode && "html" === t.prevNode.type && t.prevNode.position.end.line + 1 === e.position.start.line, a = "html" === e.type && "listItem" === t.parentNode.type && t.prevNode && "paragraph" === t.prevNode.type && t.prevNode.position.end.line + 1 === e.position.start.line; return o || !(n || r || i || s || a); }(r, e) || OC(r, e)) && a.push(nC), OC(r, e) && a.push(nC)), a.push(o), u = r;
            } }), "children"), o(a); } function kC(e) { let t = e; for (; t.children && 0 !== t.children.length;)
                t = t.children[t.children.length - 1]; return t; } function FC(e) { if ("html" !== e.type)
                return !1; const t = e.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/); return null !== t && (t[1] ? t[1] : "next"); } function OC(e, t) { const n = t.prevNode && "list" === t.prevNode.type, r = "code" === e.type && e.isIndented; return n && r; } function _C(e, t) { const n = [" "].concat(t || []); return new RegExp(n.map((e => "\\".concat(e))).join("|")).test(e) ? "<".concat(e, ">") : e; } function NC(e, t, n) { if (null == n && (n = !0), !e)
                return ""; if (n)
                return " " + NC(e, t, !1); if (e.includes('"') && e.includes("'") && !e.includes(")"))
                return "(".concat(e, ")"); const r = e.split("'").length - 1, o = e.split('"').length - 1, i = r > o ? '"' : o > r || t.singleQuote ? "'" : '"'; return e = e.replace(new RegExp("(".concat(i, ")"), "g"), "\\$1"), "".concat(i).concat(e).concat(i); } function PC(e) { return e.reduce(((e, t) => { const n = ls.getLast(e); return "string" == typeof n && "string" == typeof t ? e.splice(-1, 1, n + t) : e.push(t), e; }), []); } var MC = { preprocess: function (e, t) { return e = function (e, t) { return zE(e, (e => "text" !== e.type ? e : Object.assign({}, e, { value: "*" !== e.value && "_" !== e.value && "$" !== e.value && YE.test(e.value) && e.position.end.offset - e.position.start.offset !== e.value.length ? t.originalText.slice(e.position.start.offset, e.position.end.offset) : e.value }))); }(e, t), e = function (e, t) { return zE(e, ((e, n, r) => { if ("code" === e.type) {
                    const n = /^\n?( {4,}|\t)/.test(t.originalText.slice(e.position.start.offset, e.position.end.offset));
                    if (e.isIndented = n, n)
                        for (let e = 0; e < r.length; e++) {
                            const t = r[e];
                            if (t.hasIndentedCodeblock)
                                break;
                            "list" === t.type && (t.hasIndentedCodeblock = !0);
                        }
                } return e; })); }(e = function (e) { return zE(e, (e => "inlineCode" !== e.type ? e : Object.assign({}, e, { value: e.value.replace(/\s+/g, " ") }))); }(e = function (e) { return JE(e, ((e, t) => "text" === e.type && "text" === t.type), ((e, t) => ({ type: "text", value: e.value + t.value, position: { start: e.position.start, end: t.position.end } }))); }(e)), t), e = function (e, t) { return zE(e, ((e, r, o) => { if ("list" === e.type && 0 !== e.children.length) {
                    for (let t = 0; t < o.length; t++) {
                        const n = o[t];
                        if ("list" === n.type && !n.isAligned)
                            return e.isAligned = !1, e;
                    }
                    e.isAligned = function (e) { if (!e.ordered)
                        return !0; const [r, o] = e.children; if (KE(r, t.originalText).leadingSpaces.length > 1)
                        return !0; const i = n(r); return -1 !== i && (1 === e.children.length ? i % t.tabWidth == 0 : i === n(o) && (i % t.tabWidth == 0 || KE(o, t.originalText).leadingSpaces.length > 1)); }(e);
                } return e; })); function n(e) { return 0 === e.children.length ? -1 : e.children[0].position.start.column - 1; } }(e, t), e = function (e, t) { return zE(e, ((e, n, [r]) => { if ("text" !== e.type)
                    return e; let { value: o } = e; return "paragraph" === r.type && (0 === n && (o = o.trimStart()), n === r.children.length - 1 && (o = o.trimEnd())), { type: "sentence", position: e.position, children: HE(o, t) }; })); }(e, t), function (e) { return JE(e, ((e, t) => "importExport" === e.type && "importExport" === t.type), ((e, t) => ({ type: "importExport", value: e.value + "\n\n" + t.value, position: { start: e.position.start, end: t.position.end } }))); }(e = function (e) { return zE(e, (e => "import" !== e.type && "export" !== e.type ? e : Object.assign({}, e, { type: "importExport" }))); }(e)); }, print: function (e, t, n) { const r = e.getValue(); if (function (e) { const t = AC(e, ["linkReference", "imageReference"]); return t && ("linkReference" !== t.type || "full" !== t.referenceType); }(e))
                    return XE(dC(t.originalText.slice(r.position.start.offset, r.position.end.offset), t).map((n => "word" === n.type ? n.value : "" === n.value ? "" : SC(e, n.value, t)))); switch (r.type) {
                    case "root": return 0 === r.children.length ? "" : XE([(o = xC(e, t, n), cC(o, (e => { if (!e.parts)
                            return e; if ("concat" === e.type && 1 === e.parts.length)
                            return e.parts[0]; const t = e.parts.reduce(((e, t) => ("concat" === t.type ? e.push(...t.parts) : "" !== t && e.push(t), e)), []); return Object.assign({}, e, { parts: PC(t) }); }))), vC.includes(kC(r).type) ? "" : nC]);
                    case "paragraph": return TC(e, t, n, { postprocessor: iC });
                    case "sentence": return TC(e, t, n);
                    case "word": return r.value.replace(/[*$]/g, "\\$&").replace(new RegExp(["(^|".concat(hC, ")(_+)"), "(_+)(".concat(hC, "|$)")].join("|"), "g"), ((e, t, n, r, o) => (n ? "".concat(t).concat(n) : "".concat(r).concat(o)).replace(/_/g, "\\_")));
                    case "whitespace": {
                        const n = e.getParentNode(), o = n.children.indexOf(r), i = n.children[o + 1], s = i && /^>|^([-+*]|#{1,6}|[0-9]+[.)])$/.test(i.value) ? "never" : t.proseWrap;
                        return SC(e, r.value, { proseWrap: s });
                    }
                    case "emphasis": {
                        const o = e.getParentNode(), i = o.children.indexOf(r), s = o.children[i - 1], a = o.children[i + 1], u = s && "sentence" === s.type && s.children.length > 0 && "word" === ls.getLast(s.children).type && !ls.getLast(s.children).hasTrailingPunctuation || a && "sentence" === a.type && a.children.length > 0 && "word" === a.children[0].type && !a.children[0].hasLeadingPunctuation || AC(e, "emphasis") ? "*" : "_";
                        return XE([u, TC(e, t, n), u]);
                    }
                    case "strong": return XE(["**", TC(e, t, n), "**"]);
                    case "delete": return XE(["~~", TC(e, t, n), "~~"]);
                    case "inlineCode": {
                        const e = ls.getMinNotPresentContinuousCount(r.value, "`"), t = "`".repeat(e || 1), n = e ? " " : "";
                        return XE([t, n, r.value, n, t]);
                    }
                    case "link": switch (t.originalText[r.position.start.offset]) {
                        case "<": {
                            const e = "mailto:", n = r.url.startsWith(e) && t.originalText.slice(r.position.start.offset + 1, r.position.start.offset + 1 + e.length) !== e ? r.url.slice(e.length) : r.url;
                            return XE(["<", n, ">"]);
                        }
                        case "[": return XE(["[", TC(e, t, n), "](", _C(r.url, ")"), NC(r.title, t), ")"]);
                        default: return t.originalText.slice(r.position.start.offset, r.position.end.offset);
                    }
                    case "image": return XE(["![", r.alt || "", "](", _C(r.url, ")"), NC(r.title, t), ")"]);
                    case "blockquote": return XE(["> ", sC("> ", TC(e, t, n))]);
                    case "heading": return XE(["#".repeat(r.depth) + " ", TC(e, t, n)]);
                    case "code": {
                        if (r.isIndented) {
                            const e = " ".repeat(4);
                            return sC(e, XE([e, XE(yC(r.value, nC))]));
                        }
                        const e = t.__inJsTemplate ? "~" : "`", n = e.repeat(Math.max(3, ls.getMaxContinuousCount(r.value, e) + 1));
                        return XE([n, r.lang || "", nC, XE(yC(pC(r, t.originalText), nC)), nC, n]);
                    }
                    case "yaml":
                    case "toml": return t.originalText.slice(r.position.start.offset, r.position.end.offset);
                    case "html": {
                        const t = e.getParentNode(), n = "root" === t.type && ls.getLast(t.children) === r ? r.value.trimEnd() : r.value, o = /^<!--[\s\S]*-->$/.test(n);
                        return XE(yC(n, o ? nC : tC(eC)));
                    }
                    case "list": {
                        const o = CC(r, e.getParentNode()), i = fC(r, t);
                        return TC(e, t, n, { processor: (e, s) => { const a = function () { const e = r.ordered ? (0 === s ? r.start : i ? 1 : r.start + s) + (o % 2 == 0 ? ". " : ") ") : o % 2 == 0 ? "- " : "* "; return r.isAligned || r.hasIndentedCodeblock ? function (e, t) { const n = function () { const n = e.length % t.tabWidth; return 0 === n ? 0 : t.tabWidth - n; }(); return e + " ".repeat(n >= 4 ? 0 : n); }(e, t) : e; }(), u = e.getValue(); return 2 === u.children.length && "html" === u.children[1].type && u.children[0].position.start.column !== u.children[1].position.start.column ? XE([a, EC(e, t, n, a)]) : XE([a, sC(" ".repeat(a.length), EC(e, t, n, a))]); } });
                    }
                    case "thematicBreak": {
                        const t = wC(e, "list");
                        return -1 === t ? "---" : CC(e.getParentNode(t), e.getParentNode(t + 1)) % 2 == 0 ? "***" : "---";
                    }
                    case "linkReference": return XE(["[", TC(e, t, n), "]", "full" === r.referenceType ? XE(["[", r.identifier, "]"]) : "collapsed" === r.referenceType ? "[]" : ""]);
                    case "imageReference": return "full" === r.referenceType ? XE(["![", r.alt || "", "][", r.identifier, "]"]) : XE(["![", r.alt, "]", "collapsed" === r.referenceType ? "[]" : ""]);
                    case "definition": {
                        const e = "always" === t.proseWrap ? ZE : " ";
                        return uC(XE([XE(["[", r.identifier, "]:"]), aC(XE([e, _C(r.url), null === r.title ? "" : XE([e, NC(r.title, t, !1)])]))]));
                    }
                    case "footnote": return XE(["[^", TC(e, t, n), "]"]);
                    case "footnoteReference": return XE(["[^", r.identifier, "]"]);
                    case "footnoteDefinition": {
                        const o = e.getParentNode().children[e.getName() + 1], i = 1 === r.children.length && "paragraph" === r.children[0].type && ("never" === t.proseWrap || "preserve" === t.proseWrap && r.children[0].position.start.line === r.children[0].position.end.line);
                        return XE(["[^", r.identifier, "]: ", i ? TC(e, t, n) : uC(XE([sC(" ".repeat(t.tabWidth), TC(e, t, n, { processor: (e, t) => 0 === t ? uC(XE([rC, e.call(n)])) : e.call(n) })), o && "footnoteDefinition" === o.type ? rC : ""]))]);
                    }
                    case "table": return function (e, t, n) { const r = nC.parts[0], o = e.getValue(), i = []; e.map((e => { const r = []; e.map((e => { r.push(lC(e.call(n), t).formatted); }), "children"), i.push(r); }), "children"); const s = i.reduce(((e, t) => e.map(((e, n) => Math.max(e, ls.getStringWidth(t[n]))))), i[0].map((() => 3))), a = QE(r, [l(i[0]), c(), QE(r, i.slice(1).map((e => l(e))))]); if ("never" !== t.proseWrap)
                        return XE([GE, a]); const u = QE(r, [l(i[0], !0), c(!0), QE(r, i.slice(1).map((e => l(e, !0))))]); return XE([GE, uC(oC(u, a))]); function c(e) { return XE(["| ", QE(" | ", s.map(((t, n) => { const r = e ? 3 : t; switch (o.align[n]) {
                            case "left": return ":" + "-".repeat(r - 1);
                            case "right": return "-".repeat(r - 1) + ":";
                            case "center": return ":" + "-".repeat(r - 2) + ":";
                            default: return "-".repeat(r);
                        } }))), " |"]); } function l(e, t) { return XE(["| ", QE(" | ", t ? e : e.map(((e, t) => { switch (o.align[t]) {
                            case "right": return function (e, t) { const n = t - ls.getStringWidth(e); return XE([" ".repeat(n), e]); }(e, s[t]);
                            case "center": return function (e, t) { const n = t - ls.getStringWidth(e), r = Math.floor(n / 2), o = n - r; return XE([" ".repeat(r), e, " ".repeat(o)]); }(e, s[t]);
                            default: return function (e, t) { const n = t - ls.getStringWidth(e); return XE([e, " ".repeat(n)]); }(e, s[t]);
                        } }))), " |"]); } }(e, t, n);
                    case "tableCell": return TC(e, t, n);
                    case "break": return /\s/.test(t.originalText[r.position.start.offset]) ? XE(["  ", tC(eC)]) : XE(["\\", nC]);
                    case "liquidNode": return XE(yC(r.value, nC));
                    case "importExport":
                    case "jsx": return r.value;
                    case "math": return XE(["$$", nC, r.value ? XE([XE(yC(r.value, nC)), nC]) : "", "$$"]);
                    case "inlineMath": return t.originalText.slice(t.locStart(r), t.locEnd(r));
                    default: throw new Error("Unknown markdown type ".concat(JSON.stringify(r.type)));
                } var o; }, embed: function (e, t, n, r) { const o = e.getValue(); if ("code" === o.type && null !== o.lang) {
                    const e = o.lang.match(/^[A-Za-z0-9_-]+/), t = function (e) { const t = bn.getSupportInfo({ plugins: r.plugins }).languages.find((t => t.name.toLowerCase() === e || t.aliases && t.aliases.includes(e) || t.extensions && t.extensions.find((t => t === ".".concat(e))))); return t ? t.parsers[0] : null; }(e ? e[0] : "");
                    if (t) {
                        const e = r.__inJsTemplate ? "~" : "`", s = e.repeat(Math.max(3, ls.getMaxContinuousCount(o.value, e) + 1)), a = n($E(o, r.originalText), { parser: t });
                        return LE(BE([s, o.lang, IE, i(a), s]));
                    }
                } if ("yaml" === o.type)
                    return LE(BE(["---", IE, o.value && o.value.trim() ? i(n(o.value, { parser: "yaml" })) : "", "---"])); switch (o.type) {
                    case "importExport": return n(o.value, { parser: "babel" });
                    case "jsx": return n("<$>".concat(o.value, "</$>"), { parser: "__js_expression", rootMarker: "mdx" });
                } return null; function i(e) { return qE(e, (e => "string" == typeof e && e.includes("\n") ? BE(e.split(/(\n)/g).map(((e, t) => t % 2 == 0 ? e : jE))) : e)); } }, massageAstNode: function (e, t, n) { return delete t.position, delete t.raw, "code" !== e.type && "yaml" !== e.type && "import" !== e.type && "export" !== e.type && "jsx" !== e.type || delete t.value, "list" === e.type && delete t.isAligned, "text" === e.type ? null : ("inlineCode" === e.type && (t.value = e.value.replace(/[ \t\n]+/g, " ")), n && "root" === n.type && n.children.length > 0 && (n.children[0] === e || ("yaml" === n.children[0].type || "toml" === n.children[0].type) && n.children[1] === e) && "html" === e.type && WE.startWithPragma(e.value) ? null : void 0); }, hasPrettierIgnore: function (e) { const t = +e.getName(); return 0 !== t && "next" === FC(e.getParentNode().children[t - 1]); }, insertPragma: WE.insertPragma }, RC = { proseWrap: Kc.proseWrap, singleQuote: Kc.singleQuote }, IC = "Markdown", jC = "prose", BC = ["pandoc"], LC = "markdown", qC = "text/x-gfm", $C = [".md", ".markdown", ".mdown", ".mdwn", ".mdx", ".mkd", ".mkdn", ".mkdown", ".ronn", ".workbook"], UC = ["contents.lr"], VC = "source.gfm", WC = { name: IC, type: jC, aliases: BC, aceMode: LC, codemirrorMode: "gfm", codemirrorMimeType: qC, wrap: !0, extensions: $C, filenames: UC, tmScope: VC, languageId: 222 }, KC = at(Object.freeze({ __proto__: null, name: IC, type: jC, aliases: BC, aceMode: LC, codemirrorMode: "gfm", codemirrorMimeType: qC, wrap: !0, extensions: $C, filenames: UC, tmScope: VC, languageId: 222, default: WC })), zC = { languages: [Hc(KC, (e => ({ since: "1.8.0", parsers: ["markdown"], vscodeLanguageIds: ["markdown"], filenames: e.filenames.concat(["README"]), extensions: e.extensions.filter((e => ".mdx" !== e)) }))), Hc(KC, (() => ({ name: "MDX", since: "1.15.0", parsers: ["mdx"], vscodeLanguageIds: ["mdx"], filenames: [], extensions: [".mdx"] })))], options: RC, printers: { mdast: MC } }; const { getLast: HC } = ls; function YC(e, t) { return e && "string" == typeof e.type && (!t || t.includes(e.type)); } function JC(e) { return "prettier-ignore" === e.value.trim(); } function GC(e) { return e && e.leadingComments && 0 !== e.leadingComments.length; } function XC(e) { return e && e.middleComments && 0 !== e.middleComments.length; } function QC(e) { return e && e.indicatorComment; } function ZC(e) { return e && e.trailingComment; } function ew(e) { return e && e.endComments && 0 !== e.endComments.length; } function tw(e) { const t = []; let n; for (const r of e.split(/( +)/g))
                " " !== r ? " " === n ? t.push(r) : t.push((t.pop() || "") + r) : void 0 === n && t.unshift(""), n = r; return " " === n && t.push((t.pop() || "") + " "), "" === t[0] && (t.shift(), t.unshift(" " + (t.shift() || ""))), t; } var nw = { getLast: HC, getAncestorCount: function (e, t) { let n = 0; const r = e.stack.length - 1; for (let o = 0; o < r; o++) {
                    const r = e.stack[o];
                    YC(r) && t(r) && n++;
                } return n; }, isNode: YC, isEmptyNode: function (e) { return !(e.children && 0 !== e.children.length || function (e) { return GC(e) || XC(e) || QC(e) || ZC(e) || ew(e); }(e)); }, mapNode: function e(t, n, r) { return n("children" in t ? Object.assign({}, t, { children: t.children.map((r => e(r, n, t))) }) : t, r); }, defineShortcut: function (e, t, n) { Object.defineProperty(e, t, { get: n, enumerable: !1 }); }, isNextLineEmpty: function (e, t) { let n = 0; const r = t.length; for (let o = e.position.end.offset - 1; o < r; o++) {
                    const e = t[o];
                    if ("\n" === e && n++, 1 === n && /\S/.test(e))
                        return !1;
                    if (2 === n)
                        return !0;
                } return !1; }, isLastDescendantNode: function (e) { switch (e.getValue().type) {
                    case "tag":
                    case "anchor":
                    case "comment": return !1;
                } const t = e.stack.length; for (let n = 1; n < t; n++) {
                    const t = e.stack[n], r = e.stack[n - 1];
                    if (Array.isArray(r) && "number" == typeof t && t !== r.length - 1)
                        return !1;
                } return !0; }, getBlockValueLineContents: function (e, { parentIndent: t, isLastDescendant: n, options: r }) { const o = e.position.start.line === e.position.end.line ? "" : r.originalText.slice(e.position.start.offset, e.position.end.offset).match(/^[^\n]*?\n([\s\S]*)$/)[1], i = null === e.indent ? (s = o.match(/^( *)\S/m)) ? s[1].length : 1 / 0 : e.indent - 1 + t; var s; const a = o.split("\n").map((e => e.slice(i))); return "preserve" === r.proseWrap || "blockLiteral" === e.type ? u(a.map((e => 0 === e.length ? [] : [e]))) : u(a.map((e => 0 === e.length ? [] : tw(e))).reduce(((e, t, n) => 0 === n || 0 === a[n - 1].length || 0 === t.length || /^\s/.test(t[0]) || /^\s|\s$/.test(HC(e)) ? e.concat([t]) : e.concat([e.pop().concat(t)])), []).map((e => e.reduce(((e, t) => 0 !== e.length && /\s$/.test(HC(e)) ? e.concat(e.pop() + " " + t) : e.concat(t)), []))).map((e => "never" === r.proseWrap ? [e.join(" ")] : e))); function u(t) { if ("keep" === e.chomping)
                    return 0 === HC(t).length ? t.slice(0, -1) : t; let r = 0; for (let e = t.length - 1; e >= 0 && 0 === t[e].length; e--)
                    r++; return 0 === r ? t : r >= 2 && !n ? t.slice(0, -(r - 1)) : t.slice(0, -r); } }, getFlowScalarLineContents: function (e, t, n) { const r = t.split("\n").map(((e, t, n) => 0 === t && t === n.length - 1 ? e : 0 !== t && t !== n.length - 1 ? e.trim() : 0 === t ? e.trimEnd() : e.trimStart())); return "preserve" === n.proseWrap ? r.map((e => 0 === e.length ? [] : [e])) : r.map((e => 0 === e.length ? [] : tw(e))).reduce(((t, n, o) => 0 === o || 0 === r[o - 1].length || 0 === n.length || "quoteDouble" === e && HC(HC(t)).endsWith("\\") ? t.concat([n]) : t.concat([t.pop().concat(n)])), []).map((e => "never" === n.proseWrap ? [e.join(" ")] : e)); }, getLastDescendantNode: function e(t) { return "children" in t && 0 !== t.children.length ? e(HC(t.children)) : t; }, hasPrettierIgnore: function (e) { const t = e.getValue(); if ("documentBody" === t.type) {
                    const t = e.getParentNode();
                    return ew(t.head) && JC(HC(t.head.endComments));
                } return GC(t) && JC(HC(t.leadingComments)); }, hasLeadingComments: GC, hasMiddleComments: XC, hasIndicatorComment: QC, hasTrailingComment: ZC, hasEndComments: ew }; const { insertPragma: rw, isPragma: ow } = { isPragma: function (e) { return /^\s*@(prettier|format)\s*$/.test(e); }, hasPragma: function (e) { return /^\s*#[^\n\S]*@(prettier|format)\s*?(\n|$)/.test(e); }, insertPragma: function (e) { return "# @format\n\n".concat(e); } }, { getAncestorCount: iw, getBlockValueLineContents: sw, getFlowScalarLineContents: aw, getLast: uw, getLastDescendantNode: cw, hasLeadingComments: lw, hasMiddleComments: pw, hasIndicatorComment: fw, hasTrailingComment: dw, hasEndComments: hw, hasPrettierIgnore: mw, isLastDescendantNode: gw, isNextLineEmpty: yw, isNode: vw, isEmptyNode: bw, defineShortcut: Dw, mapNode: Ew } = nw, Cw = Ps.builders, { conditionalGroup: ww, breakParent: Aw, concat: Sw, dedent: xw, dedentToRoot: Tw, fill: kw, group: Fw, hardline: Ow, ifBreak: _w, join: Nw, line: Pw, lineSuffix: Mw, literalline: Rw, markAsRoot: Iw, softline: jw } = Cw, { replaceEndOfLineWith: Bw } = ls; function Lw(e) { switch (e.type) {
                case "document":
                    Dw(e, "head", (() => e.children[0])), Dw(e, "body", (() => e.children[1]));
                    break;
                case "documentBody":
                case "sequenceItem":
                case "flowSequenceItem":
                case "mappingKey":
                case "mappingValue":
                    Dw(e, "content", (() => e.children[0]));
                    break;
                case "mappingItem":
                case "flowMappingItem": Dw(e, "key", (() => e.children[0])), Dw(e, "value", (() => e.children[1]));
            } return e; } function qw(e, t, n, r, o) { switch (e.type) {
                case "root": return Sw([Nw(Ow, n.map(((t, r) => { const i = e.children[r], s = e.children[r + 1]; return Sw([o(t), Vw(i, s) ? Sw([Ow, "...", dw(i) ? Sw([" ", n.call(o, "trailingComment")]) : ""]) : !s || dw(s.head) ? "" : Sw([Ow, "---"])]); }), "children")), 0 === e.children.length || (a = cw(e), vw(a, ["blockLiteral", "blockFolded"]) && "keep" === a.chomping) ? "" : Ow]);
                case "document": {
                    const i = t.children[n.getName() + 1];
                    return Nw(Ow, ["head" === Ww(e, i, t, r) ? Nw(Ow, [0 === e.head.children.length && 0 === e.head.endComments.length ? "" : n.call(o, "head"), Sw(["---", dw(e.head) ? Sw([" ", n.call(o, "head", "trailingComment")]) : ""])].filter(Boolean)) : "", (s = e, 0 !== s.body.children.length || hw(s.body) ? n.call(o, "body") : "")].filter(Boolean));
                }
                case "documentHead": return Nw(Ow, [].concat(n.map(o, "children"), n.map(o, "endComments")));
                case "documentBody": {
                    const t = Nw(Ow, n.map(o, "children")).parts, r = Nw(Ow, n.map(o, "endComments")).parts, i = 0 === t.length || 0 === r.length ? "" : (e => vw(e, ["blockFolded", "blockLiteral"]) ? "keep" === e.chomping ? "" : Sw([Ow, Ow]) : Ow)(cw(e));
                    return Sw([].concat(t, i, r));
                }
                case "directive": return Sw(["%", Nw(" ", [e.name].concat(e.parameters))]);
                case "comment": return Sw(["#", e.value]);
                case "alias": return Sw(["*", e.value]);
                case "tag": return r.originalText.slice(e.position.start.offset, e.position.end.offset);
                case "anchor": return Sw(["&", e.value]);
                case "plain": return Yw(e.type, r.originalText.slice(e.position.start.offset, e.position.end.offset), r);
                case "quoteDouble":
                case "quoteSingle": {
                    const t = "'", n = '"', o = r.originalText.slice(e.position.start.offset + 1, e.position.end.offset - 1);
                    if ("quoteSingle" === e.type && o.includes("\\") || "quoteDouble" === e.type && /\\[^"]/.test(o)) {
                        const i = "quoteDouble" === e.type ? n : t;
                        return Sw([i, Yw(e.type, o, r), i]);
                    }
                    if (o.includes(n))
                        return Sw([t, Yw(e.type, "quoteDouble" === e.type ? o.replace(/\\"/g, n).replace(/'/g, t.repeat(2)) : o, r), t]);
                    if (o.includes(t))
                        return Sw([n, Yw(e.type, "quoteSingle" === e.type ? o.replace(/''/g, t) : o, r), n]);
                    const i = r.singleQuote ? t : n;
                    return Sw([i, Yw(e.type, o, r), i]);
                }
                case "blockFolded":
                case "blockLiteral": {
                    const t = iw(n, (e => vw(e, ["sequence", "mapping"]))), i = gw(n);
                    return Sw(["blockFolded" === e.type ? ">" : "|", null === e.indent ? "" : e.indent.toString(), "clip" === e.chomping ? "" : "keep" === e.chomping ? "+" : "-", fw(e) ? Sw([" ", n.call(o, "indicatorComment")]) : "", (null === e.indent ? xw : Tw)($w(null === e.indent ? r.tabWidth : e.indent - 1 + t, Sw(sw(e, { parentIndent: t, isLastDescendant: i, options: r }).reduce(((t, n, r, o) => t.concat(0 === r ? Ow : "", kw(Nw(Pw, n).parts), r !== o.length - 1 ? 0 === n.length ? Ow : Iw(Rw) : "keep" === e.chomping && i ? 0 === n.length ? Tw(Ow) : Tw(Rw) : "")), []))))]);
                }
                case "sequence":
                case "mapping": return Nw(Ow, n.map(o, "children"));
                case "sequenceItem": return Sw(["- ", $w(2, e.content ? n.call(o, "content") : "")]);
                case "mappingKey":
                case "mappingValue": return e.content ? n.call(o, "content") : "";
                case "mappingItem":
                case "flowMappingItem": {
                    const i = bw(e.key), s = bw(e.value);
                    if (i && s)
                        return Sw([": "]);
                    const a = n.call(o, "key"), c = n.call(o, "value");
                    if (s)
                        return "flowMappingItem" === e.type && "flowMapping" === t.type ? a : "mappingItem" !== e.type || !Kw(e.key.content, r) || dw(e.key.content) || t.tag && "tag:yaml.org,2002:set" === t.tag.value ? Sw(["? ", $w(2, a)]) : Sw([a, zw(e) ? " " : "", ":"]);
                    if (i)
                        return Sw([": ", $w(2, c)]);
                    const l = Symbol("mappingKey");
                    return lw(e.value) || !Uw(e.key.content) ? Sw(["? ", $w(2, a), Ow, Nw("", n.map(o, "value", "leadingComments").map((e => Sw([e, Ow])))), ": ", $w(2, c)]) : !function (e) { if (!e)
                        return !0; switch (e.type) {
                        case "plain":
                        case "quoteDouble":
                        case "quoteSingle": return e.position.start.line === e.position.end.line;
                        case "alias": return !0;
                        default: return !1;
                    } }(e.key.content) || lw(e.key.content) || pw(e.key.content) || dw(e.key.content) || hw(e.key) || lw(e.value.content) || pw(e.value.content) || hw(e.value) || !Kw(e.value.content, r) ? ww([Sw([Fw(Sw([_w("? "), Fw($w(2, a), { id: l })])), _w(Sw([Ow, ": ", $w(2, c)]), u(Sw([zw(e) ? " " : "", ":", lw(e.value.content) || hw(e.value) && e.value.content && !vw(e.value.content, ["mapping", "sequence"]) || "mapping" === t.type && dw(e.key.content) && Uw(e.value.content) || vw(e.value.content, ["mapping", "sequence"]) && null === e.value.content.tag && null === e.value.content.anchor ? Ow : e.value.content ? Pw : "", c])), { groupId: l })])]) : Sw([a, zw(e) ? " " : "", ": ", c]);
                }
                case "flowMapping":
                case "flowSequence": {
                    const t = "flowMapping" === e.type ? "{" : "[", s = "flowMapping" === e.type ? "}" : "]", a = "flowMapping" === e.type && 0 !== e.children.length && r.bracketSpacing ? Pw : jw, c = 0 !== e.children.length && "flowMappingItem" === (i = uw(e.children)).type && bw(i.key) && bw(i.value);
                    return Sw([t, u(Sw([a, Sw(n.map(((t, n) => Sw([o(t), n === e.children.length - 1 ? "" : Sw([",", Pw, e.children[n].position.start.line !== e.children[n + 1].position.start.line ? Hw(t, r.originalText) : ""])])), "children")), _w(",", "")])), c ? "" : a, s]);
                }
                case "flowSequenceItem": return n.call(o, "content");
                default: throw new Error("Unexpected node type ".concat(e.type));
            } var i, s, a; function u(e) { return Cw.align(" ".repeat(r.tabWidth), e); } } function $w(e, t) { return "number" == typeof e && e > 0 ? Cw.align(" ".repeat(e), t) : Cw.align(e, t); } function Uw(e) { if (!e)
                return !0; switch (e.type) {
                case "plain":
                case "quoteDouble":
                case "quoteSingle":
                case "alias":
                case "flowMapping":
                case "flowSequence": return !0;
                default: return !1;
            } } function Vw(e, t) { return dw(e) || t && (0 !== t.head.children.length || hw(t.head)); } function Ww(e, t, n, r) { return n.children[0] === e && /---(\s|$)/.test(r.originalText.slice(r.locStart(e), r.locStart(e) + 4)) || 0 !== e.head.children.length || hw(e.head) || dw(e.head) ? "head" : !Vw(e, t) && !!t && "root"; } function Kw(e, t) { if (!e)
                return !0; switch (e.type) {
                case "plain":
                case "quoteSingle":
                case "quoteDouble": break;
                case "alias": return !0;
                default: return !1;
            } if ("preserve" === t.proseWrap)
                return e.position.start.line === e.position.end.line; if (/\\$/m.test(t.originalText.slice(e.position.start.offset, e.position.end.offset)))
                return !1; switch (t.proseWrap) {
                case "never": return !e.value.includes("\n");
                case "always": return !/[\n ]/.test(e.value);
                default: return !1;
            } } function zw(e) { return e.key.content && "alias" === e.key.content.type; } function Hw(e, t) { const n = e.getValue(), r = e.stack[0]; return r.isNextEmptyLinePrintedChecklist = r.isNextEmptyLinePrintedChecklist || [], !r.isNextEmptyLinePrintedChecklist[n.position.end.line] && yw(n, t) ? (r.isNextEmptyLinePrintedChecklist[n.position.end.line] = !0, jw) : ""; } function Yw(e, t, n) { const r = aw(e, t, n); return Nw(Ow, r.map((e => kw(Nw(Pw, e).parts)))); } var Jw = { preprocess: function (e) { return Ew(e, Lw); }, print: function (e, t, n) { const r = e.getValue(), o = e.getParentNode(), i = r.tag ? e.call(n, "tag") : "", s = r.anchor ? e.call(n, "anchor") : "", a = vw(r, ["mapping", "sequence", "comment", "directive", "mappingItem", "sequenceItem"]) && !gw(e) ? Hw(e, t.originalText) : ""; return Sw(["mappingValue" !== r.type && lw(r) ? Sw([Nw(Ow, e.map(n, "leadingComments")), Ow]) : "", i, i && s ? " " : "", s, i || s ? vw(r, ["sequence", "mapping"]) && !pw(r) ? Ow : " " : "", pw(r) ? Sw([1 === r.middleComments.length ? "" : Ow, Nw(Ow, e.map(n, "middleComments")), Ow]) : "", mw(e) ? Sw(Bw(t.originalText.slice(r.position.start.offset, r.position.end.offset), Rw)) : Fw(qw(r, o, e, t, n)), dw(r) && !vw(r, ["document", "documentHead"]) ? Mw(Sw(["mappingValue" !== r.type || r.content ? " " : "", "mappingKey" === o.type && "mapping" === e.getParentNode(2).type && Uw(r) ? "" : Aw, e.call(n, "trailingComment")])) : "", a, hw(r) && !vw(r, ["documentHead", "documentBody"]) ? $w("sequenceItem" === r.type ? 2 : 0, Sw([Ow, Nw(Ow, e.map(n, "endComments"))])) : ""]); }, massageAstNode: function (e, t) { if (vw(t))
                    switch (delete t.position, t.type) {
                        case "comment":
                            if (ow(t.value))
                                return null;
                            break;
                        case "quoteDouble":
                        case "quoteSingle": t.type = "quote";
                    } }, insertPragma: rw }, Gw = { bracketSpacing: Kc.bracketSpacing, singleQuote: Kc.singleQuote, proseWrap: Kc.proseWrap }, Xw = "YAML", Qw = "data", Zw = "source.yaml", eA = ["yml"], tA = [".yml", ".mir", ".reek", ".rviz", ".sublime-syntax", ".syntax", ".yaml", ".yaml-tmlanguage", ".yaml.sed", ".yml.mysql"], nA = [".clang-format", ".clang-tidy", ".gemrc", "glide.lock", "yarn.lock"], rA = "yaml", oA = "yaml", iA = "text/x-yaml", sA = { name: Xw, type: Qw, tmScope: Zw, aliases: eA, extensions: tA, filenames: nA, aceMode: rA, codemirrorMode: oA, codemirrorMimeType: iA, languageId: 407 }, aA = { languages: [Hc(at(Object.freeze({ __proto__: null, name: Xw, type: Qw, tmScope: Zw, aliases: eA, extensions: tA, filenames: nA, aceMode: rA, codemirrorMode: oA, codemirrorMimeType: iA, languageId: 407, default: sA })), (e => ({ since: "1.14.0", parsers: ["yaml"], vscodeLanguageIds: ["yaml"], filenames: e.filenames.filter((e => "yarn.lock" !== e)) })))], printers: { yaml: Jw }, options: Gw }; const { version: uA } = dn, { getSupportInfo: cA } = bn, lA = [Fl, Zl, Vp, Im, SE, zC, aA]; function pA(e, t = 1) { return (...n) => { const r = n[t] || {}, o = r.plugins || []; return n[t] = Object.assign({}, r, { plugins: [...lA, ...Array.isArray(o) ? o : Object.values(o)] }), e(...n); }; } const fA = pA(eu.formatWithCursor); return { formatWithCursor: fA, format: (e, t) => fA(e, t).formatted, check(e, t) { const { formatted: n } = fA(e, t); return n === e; }, doc: Ps, getSupportInfo: pA(cA, 0), version: uA, util: ra, __debug: { parse: pA(eu.parse), formatAST: pA(eu.formatAST), formatDoc: pA(eu.formatDoc), printToDoc: pA(eu.printToDoc), printDocToString: pA(eu.printDocToString) } }; }, "object" == typeof e && void 0 !== t ? t.exports = o() : void 0 === (i = "function" == typeof (r = o) ? r.call(e, n, e, t) : r) || (t.exports = i); } }), w = v({ "../../node_modules/prettier/parser-yaml.js"(e, t) { var s; s = function (e) { var t = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : void 0 !== n.g ? n.g : "undefined" != typeof self ? self : {}; function r(e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e; } function o(e, t) { return e(t = { exports: {} }, t.exports), t.exports; } var i = function (e, t) { return (i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t; } || function (e, t) { for (var n in t)
                t.hasOwnProperty(n) && (e[n] = t[n]); })(e, t); }, s = function () { return (s = Object.assign || function (e) { for (var t, n = 1, r = arguments.length; n < r; n++)
                for (var o in t = arguments[n])
                    Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]); return e; }).apply(this, arguments); }; function u(e) { var t = "function" == typeof Symbol && e[Symbol.iterator], n = 0; return t ? t.call(e) : { next: function () { return e && n >= e.length && (e = void 0), { value: e && e[n++], done: !e }; } }; } function c(e, t) { var n = "function" == typeof Symbol && e[Symbol.iterator]; if (!n)
                return e; var r, o, i = n.call(e), s = []; try {
                for (; (void 0 === t || t-- > 0) && !(r = i.next()).done;)
                    s.push(r.value);
            }
            catch (e) {
                o = { error: e };
            }
            finally {
                try {
                    r && !r.done && (n = i.return) && n.call(i);
                }
                finally {
                    if (o)
                        throw o.error;
                }
            } return s; } function l(e) { return this instanceof l ? (this.v = e, this) : new l(e); } var p = Object.freeze({ __proto__: null, __extends: function (e, t) { function n() { this.constructor = e; } i(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n); }, get __assign() { return s; }, __rest: function (e, t) { var n = {}; for (var r in e)
                    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]); if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
                    var o = 0;
                    for (r = Object.getOwnPropertySymbols(e); o < r.length; o++)
                        t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
                } return n; }, __decorate: function (e, t, n, r) { var o, i = arguments.length, s = i < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
                    s = Reflect.decorate(e, t, n, r);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        (o = e[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(t, n, s) : o(t, n)) || s); return i > 3 && s && Object.defineProperty(t, n, s), s; }, __param: function (e, t) { return function (n, r) { t(n, r, e); }; }, __metadata: function (e, t) { if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
                    return Reflect.metadata(e, t); }, __awaiter: function (e, t, n, r) { return new (n || (n = Promise))((function (o, i) { function s(e) { try {
                    u(r.next(e));
                }
                catch (e) {
                    i(e);
                } } function a(e) { try {
                    u(r.throw(e));
                }
                catch (e) {
                    i(e);
                } } function u(e) { e.done ? o(e.value) : new n((function (t) { t(e.value); })).then(s, a); } u((r = r.apply(e, t || [])).next()); })); }, __generator: function (e, t) { var n, r, o, i, s = { label: 0, sent: function () { if (1 & o[0])
                        throw o[1]; return o[1]; }, trys: [], ops: [] }; return i = { next: a(0), throw: a(1), return: a(2) }, "function" == typeof Symbol && (i[Symbol.iterator] = function () { return this; }), i; function a(i) { return function (a) { return function (i) { if (n)
                    throw new TypeError("Generator is already executing."); for (; s;)
                    try {
                        if (n = 1, r && (o = 2 & i[0] ? r.return : i[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, i[1])).done)
                            return o;
                        switch (r = 0, o && (i = [2 & i[0], o.value]), i[0]) {
                            case 0:
                            case 1:
                                o = i;
                                break;
                            case 4: return s.label++, { value: i[1], done: !1 };
                            case 5:
                                s.label++, r = i[1], i = [0];
                                continue;
                            case 7:
                                i = s.ops.pop(), s.trys.pop();
                                continue;
                            default:
                                if (!(o = (o = s.trys).length > 0 && o[o.length - 1]) && (6 === i[0] || 2 === i[0])) {
                                    s = 0;
                                    continue;
                                }
                                if (3 === i[0] && (!o || i[1] > o[0] && i[1] < o[3])) {
                                    s.label = i[1];
                                    break;
                                }
                                if (6 === i[0] && s.label < o[1]) {
                                    s.label = o[1], o = i;
                                    break;
                                }
                                if (o && s.label < o[2]) {
                                    s.label = o[2], s.ops.push(i);
                                    break;
                                }
                                o[2] && s.ops.pop(), s.trys.pop();
                                continue;
                        }
                        i = t.call(e, s);
                    }
                    catch (e) {
                        i = [6, e], r = 0;
                    }
                    finally {
                        n = o = 0;
                    } if (5 & i[0])
                    throw i[1]; return { value: i[0] ? i[1] : void 0, done: !0 }; }([i, a]); }; } }, __exportStar: function (e, t) { for (var n in e)
                    t.hasOwnProperty(n) || (t[n] = e[n]); }, __values: u, __read: c, __spread: function () { for (var e = [], t = 0; t < arguments.length; t++)
                    e = e.concat(c(arguments[t])); return e; }, __spreadArrays: function () { for (var e = 0, t = 0, n = arguments.length; t < n; t++)
                    e += arguments[t].length; var r = Array(e), o = 0; for (t = 0; t < n; t++)
                    for (var i = arguments[t], s = 0, a = i.length; s < a; s++, o++)
                        r[o] = i[s]; return r; }, __await: l, __asyncGenerator: function (e, t, n) { if (!Symbol.asyncIterator)
                    throw new TypeError("Symbol.asyncIterator is not defined."); var r, o = n.apply(e, t || []), i = []; return r = {}, s("next"), s("throw"), s("return"), r[Symbol.asyncIterator] = function () { return this; }, r; function s(e) { o[e] && (r[e] = function (t) { return new Promise((function (n, r) { i.push([e, t, n, r]) > 1 || a(e, t); })); }); } function a(e, t) { try {
                    (n = o[e](t)).value instanceof l ? Promise.resolve(n.value.v).then(u, c) : p(i[0][2], n);
                }
                catch (e) {
                    p(i[0][3], e);
                } var n; } function u(e) { a("next", e); } function c(e) { a("throw", e); } function p(e, t) { e(t), i.shift(), i.length && a(i[0][0], i[0][1]); } }, __asyncDelegator: function (e) { var t, n; return t = {}, r("next"), r("throw", (function (e) { throw e; })), r("return"), t[Symbol.iterator] = function () { return this; }, t; function r(r, o) { t[r] = e[r] ? function (t) { return (n = !n) ? { value: l(e[r](t)), done: "return" === r } : o ? o(t) : t; } : o; } }, __asyncValues: function (e) { if (!Symbol.asyncIterator)
                    throw new TypeError("Symbol.asyncIterator is not defined."); var t, n = e[Symbol.asyncIterator]; return n ? n.call(e) : (e = u(e), t = {}, r("next"), r("throw"), r("return"), t[Symbol.asyncIterator] = function () { return this; }, t); function r(n) { t[n] = e[n] && function (t) { return new Promise((function (r, o) { var i, s, a, u; i = r, s = o, a = (t = e[n](t)).done, u = t.value, Promise.resolve(u).then((function (e) { i({ value: e, done: a }); }), s); })); }; } }, __makeTemplateObject: function (e, t) { return Object.defineProperty ? Object.defineProperty(e, "raw", { value: t }) : e.raw = t, e; }, __importStar: function (e) { if (e && e.__esModule)
                    return e; var t = {}; if (null != e)
                    for (var n in e)
                        Object.hasOwnProperty.call(e, n) && (t[n] = e[n]); return t.default = e, t; }, __importDefault: function (e) { return e && e.__esModule ? e : { default: e }; } }), f = o((function (e, t) { var n = function () { function e(e) { this.string = e; for (var t = [0], n = 0; n < e.length;)
                switch (e[n]) {
                    case "\n":
                        n += "\n".length, t.push(n);
                        break;
                    case "\r":
                        "\n" === e[n += "\r".length] && (n += "\n".length), t.push(n);
                        break;
                    default: n++;
                } this.offsets = t; } return e.prototype.locationForIndex = function (e) { if (e < 0 || e > this.string.length)
                return null; for (var t = 0, n = this.offsets; n[t + 1] <= e;)
                t++; return { line: t, column: e - n[t] }; }, e.prototype.indexForLocation = function (e) { var t = e.line, n = e.column; return t < 0 || t >= this.offsets.length || n < 0 || n > this.lengthOfLine(t) ? null : this.offsets[t] + n; }, e.prototype.lengthOfLine = function (e) { var t = this.offsets[e]; return (e === this.offsets.length - 1 ? this.string.length : this.offsets[e + 1]) - t; }, e; }(); t.__esModule = !0, t.default = n; })); r(f); var d = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.Type = t.Char = void 0, t.Char = { ANCHOR: "&", COMMENT: "#", TAG: "!", DIRECTIVES_END: "-", DOCUMENT_END: "." }, t.Type = { ALIAS: "ALIAS", BLANK_LINE: "BLANK_LINE", BLOCK_FOLDED: "BLOCK_FOLDED", BLOCK_LITERAL: "BLOCK_LITERAL", COMMENT: "COMMENT", DIRECTIVE: "DIRECTIVE", DOCUMENT: "DOCUMENT", FLOW_MAP: "FLOW_MAP", FLOW_SEQ: "FLOW_SEQ", MAP: "MAP", MAP_KEY: "MAP_KEY", MAP_VALUE: "MAP_VALUE", PLAIN: "PLAIN", QUOTE_DOUBLE: "QUOTE_DOUBLE", QUOTE_SINGLE: "QUOTE_SINGLE", SEQ: "SEQ", SEQ_ITEM: "SEQ_ITEM" }; })); r(d), d.Type, d.Char; var h = o((function (e, t) { function n(e) { const t = [0]; let n = e.indexOf("\n"); for (; -1 !== n;)
                n += 1, t.push(n), n = e.indexOf("\n", n); return t; } function r(e) { let t, r; return "string" == typeof e ? (t = n(e), r = e) : (Array.isArray(e) && (e = e[0]), e && e.context && (e.lineStarts || (e.lineStarts = n(e.context.src)), t = e.lineStarts, r = e.context.src)), { lineStarts: t, src: r }; } function o(e, t) { const { lineStarts: n, src: o } = r(t); if (!n || !(e >= 1) || e > n.length)
                return null; const i = n[e - 1]; let s = n[e]; for (; s && s > i && "\n" === o[s - 1];)
                --s; return o.slice(i, s); } Object.defineProperty(t, "__esModule", { value: !0 }), t.getLinePos = function (e, t) { if ("number" != typeof e || e < 0)
                return null; const { lineStarts: n, src: o } = r(t); if (!n || !o || e > o.length)
                return null; for (let t = 0; t < n.length; ++t) {
                const r = n[t];
                if (e < r)
                    return { line: t, col: e - n[t - 1] + 1 };
                if (e === r)
                    return { line: t + 1, col: 1 };
            } const i = n.length; return { line: i, col: e - n[i - 1] + 1 }; }, t.getLine = o, t.getPrettyContext = function ({ start: e, end: t }, n, r = 80) { let i = o(e.line, n); if (!i)
                return null; let { col: s } = e; if (i.length > r)
                if (s <= r - 10)
                    i = i.substr(0, r - 1) + "…";
                else {
                    const e = Math.round(r / 2);
                    i.length > s + e && (i = i.substr(0, s + e - 1) + "…"), s -= i.length - r, i = "…" + i.substr(1 - r);
                } let a = 1, u = ""; t && (t.line === e.line && s + (t.col - e.col) <= r + 1 ? a = t.col - e.col : (a = Math.min(i.length + 1, r) - s, u = "…")); const c = s > 1 ? " ".repeat(s - 1) : "", l = "^".repeat(a); return "".concat(i, "\n").concat(c).concat(l).concat(u); }; })); r(h), h.getLinePos, h.getLine, h.getPrettyContext; var m = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0; class n {
                static copy(e) { return new n(e.start, e.end); }
                constructor(e, t) { this.start = e, this.end = t || e; }
                isEmpty() { return "number" != typeof this.start || !this.end || this.end <= this.start; }
                setOrigRange(e, t) { const { start: n, end: r } = this; if (0 === e.length || r <= e[0])
                    return this.origStart = n, this.origEnd = r, t; let o = t; for (; o < e.length && !(e[o] > n);)
                    ++o; this.origStart = n + o; const i = o; for (; o < e.length && !(e[o] >= r);)
                    ++o; return this.origEnd = r + o, i; }
            } t.default = n; })); r(m); var g = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0; var n, r = (n = m) && n.__esModule ? n : { default: n }; class o {
                static addStringTerminator(e, t, n) { if ("\n" === n[n.length - 1])
                    return n; const r = o.endOfWhiteSpace(e, t); return r >= e.length || "\n" === e[r] ? n + "\n" : n; }
                static atDocumentBoundary(e, t, n) { const r = e[t]; if (!r)
                    return !0; const o = e[t - 1]; if (o && "\n" !== o)
                    return !1; if (n) {
                    if (r !== n)
                        return !1;
                }
                else if (r !== d.Char.DIRECTIVES_END && r !== d.Char.DOCUMENT_END)
                    return !1; const i = e[t + 1], s = e[t + 2]; if (i !== r || s !== r)
                    return !1; const a = e[t + 3]; return !a || "\n" === a || "\t" === a || " " === a; }
                static endOfIdentifier(e, t) { let n = e[t]; const r = "<" === n, o = r ? ["\n", "\t", " ", ">"] : ["\n", "\t", " ", "[", "]", "{", "}", ","]; for (; n && -1 === o.indexOf(n);)
                    n = e[t += 1]; return r && ">" === n && (t += 1), t; }
                static endOfIndent(e, t) { let n = e[t]; for (; " " === n;)
                    n = e[t += 1]; return t; }
                static endOfLine(e, t) { let n = e[t]; for (; n && "\n" !== n;)
                    n = e[t += 1]; return t; }
                static endOfWhiteSpace(e, t) { let n = e[t]; for (; "\t" === n || " " === n;)
                    n = e[t += 1]; return t; }
                static startOfLine(e, t) { let n = e[t - 1]; if ("\n" === n)
                    return t; for (; n && "\n" !== n;)
                    n = e[t -= 1]; return t + 1; }
                static endOfBlockIndent(e, t, n) { const r = o.endOfIndent(e, n); if (r > n + t)
                    return r; {
                    const t = o.endOfWhiteSpace(e, r), n = e[t];
                    if (!n || "\n" === n)
                        return t;
                } return null; }
                static atBlank(e, t, n) { const r = e[t]; return "\n" === r || "\t" === r || " " === r || n && !r; }
                static nextNodeIsIndented(e, t, n) { return !(!e || t < 0) && (t > 0 || n && "-" === e); }
                static normalizeOffset(e, t) { const n = e[t]; return n ? "\n" !== n && "\n" === e[t - 1] ? t - 1 : o.endOfWhiteSpace(e, t) : t; }
                static foldNewline(e, t, n) { let r = 0, i = !1, s = "", a = e[t + 1]; for (; " " === a || "\t" === a || "\n" === a;) {
                    switch (a) {
                        case "\n":
                            r = 0, t += 1, s += "\n";
                            break;
                        case "\t":
                            r <= n && (i = !0), t = o.endOfWhiteSpace(e, t + 2) - 1;
                            break;
                        case " ": r += 1, t += 1;
                    }
                    a = e[t + 1];
                } return s || (s = " "), a && r <= n && (i = !0), { fold: s, offset: t, error: i }; }
                constructor(e, t, n) { Object.defineProperty(this, "context", { value: n || null, writable: !0 }), this.error = null, this.range = null, this.valueRange = null, this.props = t || [], this.type = e, this.value = null; }
                getPropValue(e, t, n) { if (!this.context)
                    return null; const { src: r } = this.context, o = this.props[e]; return o && r[o.start] === t ? r.slice(o.start + (n ? 1 : 0), o.end) : null; }
                get anchor() { for (let e = 0; e < this.props.length; ++e) {
                    const t = this.getPropValue(e, d.Char.ANCHOR, !0);
                    if (null != t)
                        return t;
                } return null; }
                get comment() { const e = []; for (let t = 0; t < this.props.length; ++t) {
                    const n = this.getPropValue(t, d.Char.COMMENT, !0);
                    null != n && e.push(n);
                } return e.length > 0 ? e.join("\n") : null; }
                commentHasRequiredWhitespace(e) { const { src: t } = this.context; if (this.header && e === this.header.end)
                    return !1; if (!this.valueRange)
                    return !1; const { end: n } = this.valueRange; return e !== n || o.atBlank(t, n - 1); }
                get hasComment() { if (this.context) {
                    const { src: e } = this.context;
                    for (let t = 0; t < this.props.length; ++t)
                        if (e[this.props[t].start] === d.Char.COMMENT)
                            return !0;
                } return !1; }
                get hasProps() { if (this.context) {
                    const { src: e } = this.context;
                    for (let t = 0; t < this.props.length; ++t)
                        if (e[this.props[t].start] !== d.Char.COMMENT)
                            return !0;
                } return !1; }
                get includesTrailingLines() { return !1; }
                get jsonLike() { return -1 !== [d.Type.FLOW_MAP, d.Type.FLOW_SEQ, d.Type.QUOTE_DOUBLE, d.Type.QUOTE_SINGLE].indexOf(this.type); }
                get rangeAsLinePos() { if (!this.range || !this.context)
                    return; const e = (0, h.getLinePos)(this.range.start, this.context.root); return e ? { start: e, end: (0, h.getLinePos)(this.range.end, this.context.root) } : void 0; }
                get rawValue() { if (!this.valueRange || !this.context)
                    return null; const { start: e, end: t } = this.valueRange; return this.context.src.slice(e, t); }
                get tag() { for (let e = 0; e < this.props.length; ++e) {
                    const t = this.getPropValue(e, d.Char.TAG, !1);
                    if (null != t) {
                        if ("<" === t[1])
                            return { verbatim: t.slice(2, -1) };
                        {
                            const [e, n, r] = t.match(/^(.*!)([^!]*)$/);
                            return { handle: n, suffix: r };
                        }
                    }
                } return null; }
                get valueRangeContainsNewline() { if (!this.valueRange || !this.context)
                    return !1; const { start: e, end: t } = this.valueRange, { src: n } = this.context; for (let r = e; r < t; ++r)
                    if ("\n" === n[r])
                        return !0; return !1; }
                parseComment(e) { const { src: t } = this.context; if (t[e] === d.Char.COMMENT) {
                    const n = o.endOfLine(t, e + 1), i = new r.default(e, n);
                    return this.props.push(i), n;
                } return e; }
                setOrigRanges(e, t) { return this.range && (t = this.range.setOrigRange(e, t)), this.valueRange && this.valueRange.setOrigRange(e, t), this.props.forEach((n => n.setOrigRange(e, t))), t; }
                toString() { const { context: { src: e }, range: t, value: n } = this; if (null != n)
                    return n; const r = e.slice(t.start, t.end); return o.addStringTerminator(e, t.end, r); }
            } t.default = o; })); r(g); var y = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.YAMLWarning = t.YAMLSyntaxError = t.YAMLSemanticError = t.YAMLReferenceError = t.YAMLError = void 0; var n = o(g), r = o(m); function o(e) { return e && e.__esModule ? e : { default: e }; } class i extends Error {
                constructor(e, t, r) { if (!(r && t instanceof n.default))
                    throw new Error("Invalid arguments for new ".concat(e)); super(), this.name = e, this.message = r, this.source = t; }
                makePretty() { if (!this.source)
                    return; this.nodeType = this.source.type; const e = this.source.context && this.source.context.root; if ("number" == typeof this.offset) {
                    this.range = new r.default(this.offset, this.offset + 1);
                    const t = e && (0, h.getLinePos)(this.offset, e);
                    if (t) {
                        const e = { line: t.line, col: t.col + 1 };
                        this.linePos = { start: t, end: e };
                    }
                    delete this.offset;
                }
                else
                    this.range = this.source.range, this.linePos = this.source.rangeAsLinePos; if (this.linePos) {
                    const { line: t, col: n } = this.linePos.start;
                    this.message += " at line ".concat(t, ", column ").concat(n);
                    const r = e && (0, h.getPrettyContext)(this.linePos, e);
                    r && (this.message += ":\n\n".concat(r, "\n"));
                } delete this.source; }
            } t.YAMLError = i, t.YAMLReferenceError = class extends i {
                constructor(e, t) { super("YAMLReferenceError", e, t); }
            }, t.YAMLSemanticError = class extends i {
                constructor(e, t) { super("YAMLSemanticError", e, t); }
            }, t.YAMLSyntaxError = class extends i {
                constructor(e, t) { super("YAMLSyntaxError", e, t); }
            }, t.YAMLWarning = class extends i {
                constructor(e, t) { super("YAMLWarning", e, t); }
            }; })); r(y), y.YAMLWarning, y.YAMLSyntaxError, y.YAMLSemanticError, y.YAMLReferenceError, y.YAMLError; var v = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0; var n = o(g), r = o(m); function o(e) { return e && e.__esModule ? e : { default: e }; } class i extends n.default {
                constructor() { super(d.Type.BLANK_LINE); }
                get includesTrailingLines() { return !0; }
                parse(e, t) { this.context = e; const { src: o } = e; let i = t + 1; for (; n.default.atBlank(o, i);) {
                    const e = n.default.endOfWhiteSpace(o, i);
                    if ("\n" !== e)
                        break;
                    i = e + 1;
                } return this.range = new r.default(t, i), i; }
            } t.default = i; })); r(v); var b = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0; var n = i(v), r = i(g), o = i(m); function i(e) { return e && e.__esModule ? e : { default: e }; } class s extends r.default {
                constructor(e, t) { super(e, t), this.node = null; }
                get includesTrailingLines() { return !!this.node && this.node.includesTrailingLines; }
                parse(e, t) { this.context = e; const { parseNode: i, src: s } = e; let { atLineStart: a, lineStart: u } = e; a || this.type !== d.Type.SEQ_ITEM || (this.error = new y.YAMLSemanticError(this, "Sequence items must not have preceding content on the same line")); const c = a ? t - u : e.indent; let l = r.default.endOfWhiteSpace(s, t + 1), p = s[l]; const f = "#" === p, h = []; let m = null; for (; "\n" === p || "#" === p;) {
                    if ("#" === p) {
                        const e = r.default.endOfLine(s, l + 1);
                        h.push(new o.default(l, e)), l = e;
                    }
                    else
                        a = !0, u = l + 1, "\n" === s[r.default.endOfWhiteSpace(s, u)] && 0 === h.length && (m = new n.default, u = m.parse({ src: s }, u)), l = r.default.endOfIndent(s, u);
                    p = s[l];
                } if (r.default.nextNodeIsIndented(p, l - (u + c), this.type !== d.Type.SEQ_ITEM) ? this.node = i({ atLineStart: a, inCollection: !1, indent: c, lineStart: u, parent: this }, l) : p && u > t + 1 && (l = u - 1), this.node) {
                    if (m) {
                        const t = e.parent.items || e.parent.contents;
                        t && t.push(m);
                    }
                    h.length && Array.prototype.push.apply(this.props, h), l = this.node.range.end;
                }
                else if (f) {
                    const e = h[0];
                    this.props.push(e), l = e.end;
                }
                else
                    l = r.default.endOfLine(s, t + 1); const g = this.node ? this.node.valueRange.end : l; return this.valueRange = new o.default(t, g), l; }
                setOrigRanges(e, t) { return t = super.setOrigRanges(e, t), this.node ? this.node.setOrigRanges(e, t) : t; }
                toString() { const { context: { src: e }, node: t, range: n, value: o } = this; if (null != o)
                    return o; const i = t ? e.slice(n.start, t.range.start) + String(t) : e.slice(n.start, n.end); return r.default.addStringTerminator(e, n.end, i); }
            } t.default = s; })); r(b); var D = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0; var n = o(g), r = o(m); function o(e) { return e && e.__esModule ? e : { default: e }; } class i extends n.default {
                constructor() { super(d.Type.COMMENT); }
                parse(e, t) { this.context = e; const n = this.parseComment(t); return this.range = new r.default(t, n), n; }
            } t.default = i; })); r(D); var E = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.grabCollectionEndComments = u, t.default = void 0; var n = a(v), r = a(b), o = a(D), i = a(g), s = a(m); function a(e) { return e && e.__esModule ? e : { default: e }; } function u(e) { let t = e; for (; t instanceof r.default;)
                t = t.node; if (!(t instanceof c))
                return null; const n = t.items.length; let o = -1; for (let e = n - 1; e >= 0; --e) {
                const n = t.items[e];
                if (n.type === d.Type.COMMENT) {
                    const { indent: t, lineStart: r } = n.context;
                    if (t > 0 && n.range.start >= r + t)
                        break;
                    o = e;
                }
                else {
                    if (n.type !== d.Type.BLANK_LINE)
                        break;
                    o = e;
                }
            } if (-1 === o)
                return null; const i = t.items.splice(o, n - o), s = i[0].range.start; for (; t.range.end = s, t.valueRange && t.valueRange.end > s && (t.valueRange.end = s), t !== e;)
                t = t.context.parent; return i; } class c extends i.default {
                static nextContentHasIndent(e, t, n) { const r = i.default.endOfLine(e, t) + 1, o = e[t = i.default.endOfWhiteSpace(e, r)]; return !!o && (t >= r + n || ("#" === o || "\n" === o) && c.nextContentHasIndent(e, t, n)); }
                constructor(e) { super(e.type === d.Type.SEQ_ITEM ? d.Type.SEQ : d.Type.MAP); for (let t = e.props.length - 1; t >= 0; --t)
                    if (e.props[t].start < e.context.lineStart) {
                        this.props = e.props.slice(0, t + 1), e.props = e.props.slice(t + 1);
                        const n = e.props[0] || e.valueRange;
                        e.range.start = n.start;
                        break;
                    } this.items = [e]; const t = u(e); t && Array.prototype.push.apply(this.items, t); }
                get includesTrailingLines() { return this.items.length > 0; }
                parse(e, t) { this.context = e; const { parseNode: r, src: a } = e; let l = i.default.startOfLine(a, t); const p = this.items[0]; p.context.parent = this, this.valueRange = s.default.copy(p.valueRange); const f = p.range.start - p.context.lineStart; let h = t; h = i.default.normalizeOffset(a, h); let m = a[h], g = i.default.endOfWhiteSpace(a, l) === h, y = !1; for (; m;) {
                    for (; "\n" === m || "#" === m;) {
                        if (g && "\n" === m && !y) {
                            const e = new n.default;
                            if (h = e.parse({ src: a }, h), this.valueRange.end = h, h >= a.length) {
                                m = null;
                                break;
                            }
                            this.items.push(e), h -= 1;
                        }
                        else if ("#" === m) {
                            if (h < l + f && !c.nextContentHasIndent(a, h, f))
                                return h;
                            const e = new o.default;
                            if (h = e.parse({ indent: f, lineStart: l, src: a }, h), this.items.push(e), this.valueRange.end = h, h >= a.length) {
                                m = null;
                                break;
                            }
                        }
                        if (l = h + 1, h = i.default.endOfIndent(a, l), i.default.atBlank(a, h)) {
                            const e = i.default.endOfWhiteSpace(a, h), t = a[e];
                            t && "\n" !== t && "#" !== t || (h = e);
                        }
                        m = a[h], g = !0;
                    }
                    if (!m)
                        break;
                    if (h !== l + f && (g || ":" !== m)) {
                        l > t && (h = l);
                        break;
                    }
                    if (p.type === d.Type.SEQ_ITEM != ("-" === m)) {
                        let e = !0;
                        if ("-" === m) {
                            const t = a[h + 1];
                            e = !t || "\n" === t || "\t" === t || " " === t;
                        }
                        if (e) {
                            l > t && (h = l);
                            break;
                        }
                    }
                    const e = r({ atLineStart: g, inCollection: !0, indent: f, lineStart: l, parent: this }, h);
                    if (!e)
                        return h;
                    if (this.items.push(e), this.valueRange.end = e.valueRange.end, h = i.default.normalizeOffset(a, e.range.end), m = a[h], g = !1, y = e.includesTrailingLines, m) {
                        let e = h - 1, t = a[e];
                        for (; " " === t || "\t" === t;)
                            t = a[--e];
                        "\n" === t && (l = e + 1, g = !0);
                    }
                    const s = u(e);
                    s && Array.prototype.push.apply(this.items, s);
                } return h; }
                setOrigRanges(e, t) { return t = super.setOrigRanges(e, t), this.items.forEach((n => { t = n.setOrigRanges(e, t); })), t; }
                toString() { const { context: { src: e }, items: t, range: n, value: r } = this; if (null != r)
                    return r; let o = e.slice(n.start, t[0].range.start) + String(t[0]); for (let e = 1; e < t.length; ++e) {
                    const n = t[e], { atLineStart: r, indent: i } = n.context;
                    if (r)
                        for (let e = 0; e < i; ++e)
                            o += " ";
                    o += String(n);
                } return i.default.addStringTerminator(e, n.end, o); }
            } t.default = c; })); r(E), E.grabCollectionEndComments; var C = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0; var n = o(g), r = o(m); function o(e) { return e && e.__esModule ? e : { default: e }; } class i extends n.default {
                constructor() { super(d.Type.DIRECTIVE), this.name = null; }
                get parameters() { const e = this.rawValue; return e ? e.trim().split(/[ \t]+/) : []; }
                parseName(e) { const { src: t } = this.context; let n = e, r = t[n]; for (; r && "\n" !== r && "\t" !== r && " " !== r;)
                    r = t[n += 1]; return this.name = t.slice(e, n), n; }
                parseParameters(e) { const { src: t } = this.context; let n = e, o = t[n]; for (; o && "\n" !== o && "#" !== o;)
                    o = t[n += 1]; return this.valueRange = new r.default(e, n), n; }
                parse(e, t) { this.context = e; let n = this.parseName(t + 1); return n = this.parseParameters(n), n = this.parseComment(n), this.range = new r.default(t, n), n; }
            } t.default = i; })); r(C); var w = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0; var n = a(v), r = a(D), o = a(C), i = a(g), s = a(m); function a(e) { return e && e.__esModule ? e : { default: e }; } class u extends i.default {
                static startCommentOrEndBlankLine(e, t) { const n = i.default.endOfWhiteSpace(e, t), r = e[n]; return "#" === r || "\n" === r ? n : t; }
                constructor() { super(d.Type.DOCUMENT), this.directives = null, this.contents = null, this.directivesEndMarker = null, this.documentEndMarker = null; }
                parseDirectives(e) { const { src: t } = this.context; this.directives = []; let a = !0, c = !1, l = e; for (; !i.default.atDocumentBoundary(t, l, d.Char.DIRECTIVES_END);)
                    switch (l = u.startCommentOrEndBlankLine(t, l), t[l]) {
                        case "\n":
                            if (a) {
                                const e = new n.default;
                                l = e.parse({ src: t }, l), l < t.length && this.directives.push(e);
                            }
                            else
                                l += 1, a = !0;
                            break;
                        case "#":
                            {
                                const e = new r.default;
                                l = e.parse({ src: t }, l), this.directives.push(e), a = !1;
                            }
                            break;
                        case "%":
                            {
                                const e = new o.default;
                                l = e.parse({ parent: this, src: t }, l), this.directives.push(e), c = !0, a = !1;
                            }
                            break;
                        default: return c ? this.error = new y.YAMLSemanticError(this, "Missing directives-end indicator line") : this.directives.length > 0 && (this.contents = this.directives, this.directives = []), l;
                    } return t[l] ? (this.directivesEndMarker = new s.default(l, l + 3), l + 3) : (c ? this.error = new y.YAMLSemanticError(this, "Missing directives-end indicator line") : this.directives.length > 0 && (this.contents = this.directives, this.directives = []), l); }
                parseContents(e) { const { parseNode: t, src: o } = this.context; this.contents || (this.contents = []); let a = e; for (; "-" === o[a - 1];)
                    a -= 1; let c = i.default.endOfWhiteSpace(o, e), l = a === e; for (this.valueRange = new s.default(c); !i.default.atDocumentBoundary(o, c, d.Char.DOCUMENT_END);) {
                    switch (o[c]) {
                        case "\n":
                            if (l) {
                                const e = new n.default;
                                c = e.parse({ src: o }, c), c < o.length && this.contents.push(e);
                            }
                            else
                                c += 1, l = !0;
                            a = c;
                            break;
                        case "#":
                            {
                                const e = new r.default;
                                c = e.parse({ src: o }, c), this.contents.push(e), l = !1;
                            }
                            break;
                        default: {
                            const e = i.default.endOfIndent(o, c), n = t({ atLineStart: l, indent: -1, inFlow: !1, inCollection: !1, lineStart: a, parent: this }, e);
                            if (!n)
                                return this.valueRange.end = e;
                            this.contents.push(n), c = n.range.end, l = !1;
                            const r = (0, E.grabCollectionEndComments)(n);
                            r && Array.prototype.push.apply(this.contents, r);
                        }
                    }
                    c = u.startCommentOrEndBlankLine(o, c);
                } if (this.valueRange.end = c, o[c] && (this.documentEndMarker = new s.default(c, c + 3), c += 3, o[c])) {
                    if (c = i.default.endOfWhiteSpace(o, c), "#" === o[c]) {
                        const e = new r.default;
                        c = e.parse({ src: o }, c), this.contents.push(e);
                    }
                    switch (o[c]) {
                        case "\n":
                            c += 1;
                            break;
                        case void 0: break;
                        default: this.error = new y.YAMLSyntaxError(this, "Document end marker line cannot have a non-comment suffix");
                    }
                } return c; }
                parse(e, t) { e.root = this, this.context = e; const { src: n } = e; let r = 65279 === n.charCodeAt(t) ? t + 1 : t; return r = this.parseDirectives(r), r = this.parseContents(r), r; }
                setOrigRanges(e, t) { return t = super.setOrigRanges(e, t), this.directives.forEach((n => { t = n.setOrigRanges(e, t); })), this.directivesEndMarker && (t = this.directivesEndMarker.setOrigRange(e, t)), this.contents.forEach((n => { t = n.setOrigRanges(e, t); })), this.documentEndMarker && (t = this.documentEndMarker.setOrigRange(e, t)), t; }
                toString() { const { contents: e, directives: t, value: n } = this; if (null != n)
                    return n; let r = t.join(""); return e.length > 0 && ((t.length > 0 || e[0].type === d.Type.COMMENT) && (r += "---\n"), r += e.join("")), "\n" !== r[r.length - 1] && (r += "\n"), r; }
            } t.default = u; })); r(w); var A = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0; var n = o(g), r = o(m); function o(e) { return e && e.__esModule ? e : { default: e }; } class i extends n.default {
                parse(e, t) { this.context = e; const { src: o } = e; let i = n.default.endOfIdentifier(o, t + 1); return this.valueRange = new r.default(t + 1, i), i = n.default.endOfWhiteSpace(o, i), i = this.parseComment(i), i; }
            } t.default = i; })); r(A); var S = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = t.Chomp = void 0; var n = o(g), r = o(m); function o(e) { return e && e.__esModule ? e : { default: e }; } const i = { CLIP: "CLIP", KEEP: "KEEP", STRIP: "STRIP" }; t.Chomp = i; class s extends n.default {
                constructor(e, t) { super(e, t), this.blockIndent = null, this.chomping = i.CLIP, this.header = null; }
                get includesTrailingLines() { return this.chomping === i.KEEP; }
                get strValue() { if (!this.valueRange || !this.context)
                    return null; let { start: e, end: t } = this.valueRange; const { indent: r, src: o } = this.context; if (this.valueRange.isEmpty())
                    return ""; let s = null, a = o[t - 1]; for (; "\n" === a || "\t" === a || " " === a;) {
                    if (t -= 1, t <= e) {
                        if (this.chomping === i.KEEP)
                            break;
                        return "";
                    }
                    "\n" === a && (s = t), a = o[t - 1];
                } let u = t + 1; s && (this.chomping === i.KEEP ? (u = s, t = this.valueRange.end) : t = s); const c = r + this.blockIndent, l = this.type === d.Type.BLOCK_FOLDED; let p = !0, f = "", h = "", m = !1; for (let r = e; r < t; ++r) {
                    for (let e = 0; e < c && " " === o[r]; ++e)
                        r += 1;
                    const e = o[r];
                    if ("\n" === e)
                        "\n" === h ? f += "\n" : h = "\n";
                    else {
                        const i = n.default.endOfLine(o, r), s = o.slice(r, i);
                        r = i, l && (" " === e || "\t" === e) && r < u ? (" " === h ? h = "\n" : m || p || "\n" !== h || (h = "\n\n"), f += h + s, h = i < t && o[i] || "", m = !0) : (f += h + s, h = l && r < u ? " " : "\n", m = !1), p && "" !== s && (p = !1);
                    }
                } return this.chomping === i.STRIP ? f : f + "\n"; }
                parseBlockHeader(e) { const { src: t } = this.context; let n = e + 1, o = ""; for (;;) {
                    const s = t[n];
                    switch (s) {
                        case "-":
                            this.chomping = i.STRIP;
                            break;
                        case "+":
                            this.chomping = i.KEEP;
                            break;
                        case "0":
                        case "1":
                        case "2":
                        case "3":
                        case "4":
                        case "5":
                        case "6":
                        case "7":
                        case "8":
                        case "9":
                            o += s;
                            break;
                        default: return this.blockIndent = Number(o) || null, this.header = new r.default(e, n), n;
                    }
                    n += 1;
                } }
                parseBlockValue(e) { const { indent: t, src: o } = this.context; let s = e, a = e, u = this.blockIndent ? t + this.blockIndent - 1 : t, c = 1; for (let e = o[s]; "\n" === e && (s += 1, !n.default.atDocumentBoundary(o, s)); e = o[s]) {
                    const e = n.default.endOfBlockIndent(o, u, s);
                    if (null === e)
                        break;
                    if (!this.blockIndent) {
                        const n = e - (s + t);
                        if ("\n" !== o[e]) {
                            if (n < c) {
                                s -= 1;
                                break;
                            }
                            this.blockIndent = n, u = t + this.blockIndent - 1;
                        }
                        else
                            n > c && (c = n);
                    }
                    s = "\n" === o[e] ? e : a = n.default.endOfLine(o, e);
                } return this.chomping !== i.KEEP && (s = o[a] ? a + 1 : a), this.valueRange = new r.default(e + 1, s), s; }
                parse(e, t) { this.context = e; const { src: r } = e; let o = this.parseBlockHeader(t); return o = n.default.endOfWhiteSpace(r, o), o = this.parseComment(o), o = this.parseBlockValue(o), o; }
                setOrigRanges(e, t) { return t = super.setOrigRanges(e, t), this.header ? this.header.setOrigRange(e, t) : t; }
            } t.default = s; })); r(S), S.Chomp; var x = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0; var n = s(v), r = s(D), o = s(g), i = s(m); function s(e) { return e && e.__esModule ? e : { default: e }; } class a extends o.default {
                constructor(e, t) { super(e, t), this.items = null; }
                prevNodeIsJsonLike(e = this.items.length) { const t = this.items[e - 1]; return !!t && (t.jsonLike || t.type === d.Type.COMMENT && this.nodeIsJsonLike(e - 1)); }
                parse(e, t) { this.context = e; const { parseNode: s, src: a } = e; let { indent: u, lineStart: c } = e, l = a[t]; this.items = [{ char: l, offset: t }]; let p = o.default.endOfWhiteSpace(a, t + 1); for (l = a[p]; l && "]" !== l && "}" !== l;) {
                    switch (l) {
                        case "\n":
                            if (c = p + 1, "\n" === a[o.default.endOfWhiteSpace(a, c)]) {
                                const e = new n.default;
                                c = e.parse({ src: a }, c), this.items.push(e);
                            }
                            if (p = o.default.endOfIndent(a, c), p <= c + u && (l = a[p], p < c + u || "]" !== l && "}" !== l)) {
                                const e = "Insufficient indentation in flow collection";
                                this.error = new y.YAMLSemanticError(this, e);
                            }
                            break;
                        case ",":
                            this.items.push({ char: l, offset: p }), p += 1;
                            break;
                        case "#":
                            {
                                const e = new r.default;
                                p = e.parse({ src: a }, p), this.items.push(e);
                            }
                            break;
                        case "?":
                        case ":": {
                            const e = a[p + 1];
                            if ("\n" === e || "\t" === e || " " === e || "," === e || ":" === l && this.prevNodeIsJsonLike()) {
                                this.items.push({ char: l, offset: p }), p += 1;
                                break;
                            }
                        }
                        default: {
                            const e = s({ atLineStart: !1, inCollection: !1, inFlow: !0, indent: -1, lineStart: c, parent: this }, p);
                            if (!e)
                                return this.valueRange = new i.default(t, p), p;
                            this.items.push(e), p = o.default.normalizeOffset(a, e.range.end);
                        }
                    }
                    p = o.default.endOfWhiteSpace(a, p), l = a[p];
                } return this.valueRange = new i.default(t, p + 1), l && (this.items.push({ char: l, offset: p }), p = o.default.endOfWhiteSpace(a, p + 1), p = this.parseComment(p)), p; }
                setOrigRanges(e, t) { return t = super.setOrigRanges(e, t), this.items.forEach((n => { if (n instanceof o.default)
                    t = n.setOrigRanges(e, t);
                else if (0 === e.length)
                    n.origOffset = n.offset;
                else {
                    let r = t;
                    for (; r < e.length && !(e[r] > n.offset);)
                        ++r;
                    n.origOffset = n.offset + r, t = r;
                } })), t; }
                toString() { const { context: { src: e }, items: t, range: n, value: r } = this; if (null != r)
                    return r; const i = t.filter((e => e instanceof o.default)); let s = "", a = n.start; return i.forEach((t => { const n = e.slice(a, t.range.start); a = t.range.end, s += n + String(t), "\n" === s[s.length - 1] && "\n" !== e[a - 1] && "\n" === e[a] && (a += 1); })), s += e.slice(a, n.end), o.default.addStringTerminator(e, n.end, s); }
            } t.default = a; })); r(x); var T = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0; var n = o(g), r = o(m); function o(e) { return e && e.__esModule ? e : { default: e }; } class i extends n.default {
                static endOfLine(e, t, n) { let r = e[t], o = t; for (; r && "\n" !== r && (!n || "[" !== r && "]" !== r && "{" !== r && "}" !== r && "," !== r);) {
                    const t = e[o + 1];
                    if (":" === r && (!t || "\n" === t || "\t" === t || " " === t || n && "," === t))
                        break;
                    if ((" " === r || "\t" === r) && "#" === t)
                        break;
                    o += 1, r = t;
                } return o; }
                get strValue() { if (!this.valueRange || !this.context)
                    return null; let { start: e, end: t } = this.valueRange; const { src: r } = this.context; let o = r[t - 1]; for (; e < t && ("\n" === o || "\t" === o || " " === o);)
                    o = r[--t - 1]; for (o = r[e]; e < t && ("\n" === o || "\t" === o || " " === o);)
                    o = r[++e]; let i = ""; for (let o = e; o < t; ++o) {
                    const e = r[o];
                    if ("\n" === e) {
                        const { fold: e, offset: t } = n.default.foldNewline(r, o, -1);
                        i += e, o = t;
                    }
                    else if (" " === e || "\t" === e) {
                        const n = o;
                        let s = r[o + 1];
                        for (; o < t && (" " === s || "\t" === s);)
                            o += 1, s = r[o + 1];
                        "\n" !== s && (i += o > n ? r.slice(n, o + 1) : e);
                    }
                    else
                        i += e;
                } return i; }
                parseBlockValue(e) { const { indent: t, inFlow: r, src: o } = this.context; let s = e, a = e; for (let e = o[s]; "\n" === e && !n.default.atDocumentBoundary(o, s + 1); e = o[s]) {
                    const e = n.default.endOfBlockIndent(o, t, s + 1);
                    if (null === e || "#" === o[e])
                        break;
                    "\n" === o[e] ? s = e : (a = i.endOfLine(o, e, r), s = a);
                } return this.valueRange.isEmpty() && (this.valueRange.start = e), this.valueRange.end = a, a; }
                parse(e, t) { this.context = e; const { inFlow: o, src: s } = e; let a = t; const u = s[a]; return u && "#" !== u && "\n" !== u && (a = i.endOfLine(s, t, o)), this.valueRange = new r.default(t, a), a = n.default.endOfWhiteSpace(s, a), a = this.parseComment(a), this.hasComment && !this.valueRange.isEmpty() || (a = this.parseBlockValue(a)), a; }
            } t.default = i; })); r(T); var k = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0; var n = o(g), r = o(m); function o(e) { return e && e.__esModule ? e : { default: e }; } class i extends n.default {
                static endOfQuote(e, t) { let n = e[t]; for (; n && '"' !== n;)
                    n = e[t += "\\" === n ? 2 : 1]; return t + 1; }
                get strValue() { if (!this.valueRange || !this.context)
                    return null; const e = [], { start: t, end: r } = this.valueRange, { indent: o, src: i } = this.context; '"' !== i[r - 1] && e.push(new y.YAMLSyntaxError(this, 'Missing closing "quote')); let s = ""; for (let a = t + 1; a < r - 1; ++a) {
                    const t = i[a];
                    if ("\n" === t) {
                        n.default.atDocumentBoundary(i, a + 1) && e.push(new y.YAMLSemanticError(this, "Document boundary indicators are not allowed within string values"));
                        const { fold: t, offset: r, error: u } = n.default.foldNewline(i, a, o);
                        s += t, a = r, u && e.push(new y.YAMLSemanticError(this, "Multi-line double-quoted string needs to be sufficiently indented"));
                    }
                    else if ("\\" === t)
                        switch (a += 1, i[a]) {
                            case "0":
                                s += "\0";
                                break;
                            case "a":
                                s += "";
                                break;
                            case "b":
                                s += "\b";
                                break;
                            case "e":
                                s += "";
                                break;
                            case "f":
                                s += "\f";
                                break;
                            case "n":
                                s += "\n";
                                break;
                            case "r":
                                s += "\r";
                                break;
                            case "t":
                            case "\t":
                                s += "\t";
                                break;
                            case "v":
                                s += "\v";
                                break;
                            case "N":
                                s += "";
                                break;
                            case "_":
                                s += " ";
                                break;
                            case "L":
                                s += "\u2028";
                                break;
                            case "P":
                                s += "\u2029";
                                break;
                            case " ":
                                s += " ";
                                break;
                            case '"':
                                s += '"';
                                break;
                            case "/":
                                s += "/";
                                break;
                            case "\\":
                                s += "\\";
                                break;
                            case "x":
                                s += this.parseCharCode(a + 1, 2, e), a += 2;
                                break;
                            case "u":
                                s += this.parseCharCode(a + 1, 4, e), a += 4;
                                break;
                            case "U":
                                s += this.parseCharCode(a + 1, 8, e), a += 8;
                                break;
                            case "\n":
                                for (; " " === i[a + 1] || "\t" === i[a + 1];)
                                    a += 1;
                                break;
                            default: e.push(new y.YAMLSyntaxError(this, "Invalid escape sequence ".concat(i.substr(a - 1, 2)))), s += "\\" + i[a];
                        }
                    else if (" " === t || "\t" === t) {
                        const e = a;
                        let n = i[a + 1];
                        for (; " " === n || "\t" === n;)
                            a += 1, n = i[a + 1];
                        "\n" !== n && (s += a > e ? i.slice(e, a + 1) : t);
                    }
                    else
                        s += t;
                } return e.length > 0 ? { errors: e, str: s } : s; }
                parseCharCode(e, t, n) { const { src: r } = this.context, o = r.substr(e, t), i = o.length === t && /^[0-9a-fA-F]+$/.test(o) ? parseInt(o, 16) : NaN; return isNaN(i) ? (n.push(new y.YAMLSyntaxError(this, "Invalid escape sequence ".concat(r.substr(e - 2, t + 2)))), r.substr(e - 2, t + 2)) : String.fromCodePoint(i); }
                parse(e, t) { this.context = e; const { src: o } = e; let s = i.endOfQuote(o, t + 1); return this.valueRange = new r.default(t, s), s = n.default.endOfWhiteSpace(o, s), s = this.parseComment(s), s; }
            } t.default = i; })); r(k); var F = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0; var n = o(g), r = o(m); function o(e) { return e && e.__esModule ? e : { default: e }; } class i extends n.default {
                static endOfQuote(e, t) { let n = e[t]; for (; n;)
                    if ("'" === n) {
                        if ("'" !== e[t + 1])
                            break;
                        n = e[t += 2];
                    }
                    else
                        n = e[t += 1]; return t + 1; }
                get strValue() { if (!this.valueRange || !this.context)
                    return null; const e = [], { start: t, end: r } = this.valueRange, { indent: o, src: i } = this.context; "'" !== i[r - 1] && e.push(new y.YAMLSyntaxError(this, "Missing closing 'quote")); let s = ""; for (let a = t + 1; a < r - 1; ++a) {
                    const t = i[a];
                    if ("\n" === t) {
                        n.default.atDocumentBoundary(i, a + 1) && e.push(new y.YAMLSemanticError(this, "Document boundary indicators are not allowed within string values"));
                        const { fold: t, offset: r, error: u } = n.default.foldNewline(i, a, o);
                        s += t, a = r, u && e.push(new y.YAMLSemanticError(this, "Multi-line single-quoted string needs to be sufficiently indented"));
                    }
                    else if ("'" === t)
                        s += t, a += 1, "'" !== i[a] && e.push(new y.YAMLSyntaxError(this, "Unescaped single quote? This should not happen."));
                    else if (" " === t || "\t" === t) {
                        const e = a;
                        let n = i[a + 1];
                        for (; " " === n || "\t" === n;)
                            a += 1, n = i[a + 1];
                        "\n" !== n && (s += a > e ? i.slice(e, a + 1) : t);
                    }
                    else
                        s += t;
                } return e.length > 0 ? { errors: e, str: s } : s; }
                parse(e, t) { this.context = e; const { src: o } = e; let s = i.endOfQuote(o, t + 1); return this.valueRange = new r.default(t, s), s = n.default.endOfWhiteSpace(o, s), s = this.parseComment(s), s; }
            } t.default = i; })); r(F); var O = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0; var n = f(A), r = f(S), o = f(E), i = f(b), s = f(x), a = f(g), u = f(T), c = f(k), l = f(F), p = f(m); function f(e) { return e && e.__esModule ? e : { default: e }; } class h {
                static parseType(e, t, n) { switch (e[t]) {
                    case "*": return d.Type.ALIAS;
                    case ">": return d.Type.BLOCK_FOLDED;
                    case "|": return d.Type.BLOCK_LITERAL;
                    case "{": return d.Type.FLOW_MAP;
                    case "[": return d.Type.FLOW_SEQ;
                    case "?": return !n && a.default.atBlank(e, t + 1, !0) ? d.Type.MAP_KEY : d.Type.PLAIN;
                    case ":": return !n && a.default.atBlank(e, t + 1, !0) ? d.Type.MAP_VALUE : d.Type.PLAIN;
                    case "-": return !n && a.default.atBlank(e, t + 1, !0) ? d.Type.SEQ_ITEM : d.Type.PLAIN;
                    case '"': return d.Type.QUOTE_DOUBLE;
                    case "'": return d.Type.QUOTE_SINGLE;
                    default: return d.Type.PLAIN;
                } }
                constructor(e = {}, { atLineStart: t, inCollection: f, inFlow: m, indent: g, lineStart: v, parent: b } = {}) { var D, E; E = (e, t) => { if (a.default.atDocumentBoundary(this.src, t))
                    return null; const f = new h(this, e), { props: m, type: g, valueStart: v } = f.parseProps(t), b = function (e, t) { switch (e) {
                    case d.Type.ALIAS: return new n.default(e, t);
                    case d.Type.BLOCK_FOLDED:
                    case d.Type.BLOCK_LITERAL: return new r.default(e, t);
                    case d.Type.FLOW_MAP:
                    case d.Type.FLOW_SEQ: return new s.default(e, t);
                    case d.Type.MAP_KEY:
                    case d.Type.MAP_VALUE:
                    case d.Type.SEQ_ITEM: return new i.default(e, t);
                    case d.Type.COMMENT:
                    case d.Type.PLAIN: return new u.default(e, t);
                    case d.Type.QUOTE_DOUBLE: return new c.default(e, t);
                    case d.Type.QUOTE_SINGLE: return new l.default(e, t);
                    default: return null;
                } }(g, m); let D = b.parse(f, v); if (b.range = new p.default(t, D), D <= t && (b.error = new Error("Node#parse consumed no characters"), b.error.parseEnd = D, b.error.source = b, b.range.end = t + 1), f.nodeStartsCollection(b)) {
                    b.error || f.atLineStart || f.parent.type !== d.Type.DOCUMENT || (b.error = new y.YAMLSyntaxError(b, "Block collection must not have preceding content here (e.g. directives-end indicator)"));
                    const e = new o.default(b);
                    return D = e.parse(new h(f), D), e.range = new p.default(t, D), e;
                } return b; }, (D = "parseNode") in this ? Object.defineProperty(this, D, { value: E, enumerable: !0, configurable: !0, writable: !0 }) : this[D] = E, this.atLineStart = null != t ? t : e.atLineStart || !1, this.inCollection = null != f ? f : e.inCollection || !1, this.inFlow = null != m ? m : e.inFlow || !1, this.indent = null != g ? g : e.indent, this.lineStart = null != v ? v : e.lineStart, this.parent = null != b ? b : e.parent || {}, this.root = e.root, this.src = e.src; }
                nodeStartsCollection(e) { const { inCollection: t, inFlow: n, src: r } = this; if (t || n)
                    return !1; if (e instanceof i.default)
                    return !0; let o = e.range.end; return "\n" !== r[o] && "\n" !== r[o - 1] && (o = a.default.endOfWhiteSpace(r, o), ":" === r[o]); }
                parseProps(e) { const { inFlow: t, parent: n, src: r } = this, o = []; let i = !1, s = r[e = a.default.endOfWhiteSpace(r, e)]; for (; s === d.Char.ANCHOR || s === d.Char.COMMENT || s === d.Char.TAG || "\n" === s;) {
                    if ("\n" === s) {
                        const t = e + 1, o = a.default.endOfIndent(r, t), s = o - (t + this.indent), u = n.type === d.Type.SEQ_ITEM && n.context.atLineStart;
                        if (!a.default.nextNodeIsIndented(r[o], s, !u))
                            break;
                        this.atLineStart = !0, this.lineStart = t, i = !1, e = o;
                    }
                    else if (s === d.Char.COMMENT) {
                        const t = a.default.endOfLine(r, e + 1);
                        o.push(new p.default(e, t)), e = t;
                    }
                    else {
                        let t = a.default.endOfIdentifier(r, e + 1);
                        s === d.Char.TAG && "," === r[t] && /^[a-zA-Z0-9-]+\.[a-zA-Z0-9-]+,\d\d\d\d(-\d\d){0,2}\/\S/.test(r.slice(e + 1, t + 13)) && (t = a.default.endOfIdentifier(r, t + 5)), o.push(new p.default(e, t)), i = !0, e = a.default.endOfWhiteSpace(r, t);
                    }
                    s = r[e];
                } return i && ":" === s && a.default.atBlank(r, e + 1, !0) && (e -= 1), { props: o, type: h.parseType(r, e, t), valueStart: e }; }
            } t.default = h; })); r(O); var _ = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function (e) { const t = []; -1 !== e.indexOf("\r") && (e = e.replace(/\r\n?/g, ((e, n) => (e.length > 1 && t.push(n), "\n")))); const o = []; let i = 0; do {
                const t = new n.default, s = new r.default({ src: e });
                i = t.parse(s, i), o.push(t);
            } while (i < e.length); return o.setOrigRanges = () => { if (0 === t.length)
                return !1; for (let e = 1; e < t.length; ++e)
                t[e] -= e; let e = 0; for (let n = 0; n < o.length; ++n)
                e = o[n].setOrigRanges(t, e); return t.splice(0, t.length), !0; }, o.toString = () => o.join("...\n"), o; }; var n = o(w), r = o(O); function o(e) { return e && e.__esModule ? e : { default: e }; } })); r(_); var N = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.addCommentBefore = function (e, t, n) { if (!n)
                return e; const r = n.replace(/[\s\S]^/gm, "$&".concat(t, "#")); return "#".concat(r, "\n").concat(t).concat(e); }, t.default = function (e, t, n) { return n ? -1 === n.indexOf("\n") ? "".concat(e, " #").concat(n) : "".concat(e, "\n") + n.replace(/^/gm, "".concat(t || "", "#")) : e; }; })); r(N), N.addCommentBefore; var P = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function e(t, n, r) { if (Array.isArray(t))
                return t.map(((t, n) => e(t, String(n), r))); if (t && "function" == typeof t.toJSON) {
                const e = r && r.anchors && r.anchors.find((e => e.node === t));
                e && (r.onCreate = t => { e.res = t, delete r.onCreate; });
                const o = t.toJSON(n, r);
                return e && r.onCreate && r.onCreate(o), o;
            } return t; }; })); r(P); var M = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0, t.default = class {
            }; })); r(M); var R = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0; var n = o(P), r = o(M); function o(e) { return e && e.__esModule ? e : { default: e }; } class i extends r.default {
                constructor(e) { super(), this.value = e; }
                toJSON(e, t) { return t && t.keep ? this.value : (0, n.default)(this.value, e, t); }
                toString() { return String(this.value); }
            } t.default = i; })); r(R); var I = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0; var n = a(N), r = a(P), o = a(j), i = a(M), s = a(R); function a(e) { return e && e.__esModule ? e : { default: e }; } class u extends i.default {
                constructor(e, t = null) { super(), this.key = e, this.value = t, this.type = "PAIR"; }
                get commentBefore() { return this.key && this.key.commentBefore; }
                set commentBefore(e) { null == this.key && (this.key = new s.default(null)), this.key.commentBefore = e; }
                addToJSMap(e, t) { const n = (0, r.default)(this.key, "", e); if (t instanceof Map) {
                    const o = (0, r.default)(this.value, n, e);
                    t.set(n, o);
                }
                else if (t instanceof Set)
                    t.add(n);
                else {
                    const u = (o = this.key, a = e, null === (s = n) ? "" : "object" != typeof s ? String(s) : o instanceof i.default && a && a.doc ? o.toString({ anchors: {}, doc: a.doc, indent: "", inFlow: !0, inStringifyKey: !0 }) : JSON.stringify(s));
                    t[u] = (0, r.default)(this.value, u, e);
                } var o, s, a; return t; }
                toJSON(e, t) { const n = t && t.mapAsMap ? new Map : {}; return this.addToJSMap(t, n); }
                toString(e, t, r) { if (!e || !e.doc)
                    return JSON.stringify(this); const { simpleKeys: a } = e.doc.options; let { key: u, value: c } = this, l = u instanceof i.default && u.comment; if (a) {
                    if (l)
                        throw new Error("With simple keys, key nodes cannot have comments");
                    if (u instanceof o.default)
                        throw new Error("With simple keys, collection cannot be used as a key value");
                } const p = !a && (!u || l || u instanceof o.default || u.type === d.Type.BLOCK_FOLDED || u.type === d.Type.BLOCK_LITERAL), { doc: f, indent: h } = e; e = Object.assign({}, e, { implicitKey: !p, indent: h + "  " }); let m = !1, g = f.schema.stringify(u, e, (() => l = null), (() => m = !0)); if (g = (0, n.default)(g, e.indent, l), e.allNullValues && !a)
                    return this.comment ? (g = (0, n.default)(g, e.indent, this.comment), t && t()) : m && !l && r && r(), e.inFlow ? g : "? ".concat(g); g = p ? "? ".concat(g, "\n").concat(h, ":") : "".concat(g, ":"), this.comment && (g = (0, n.default)(g, e.indent, this.comment), t && t()); let y = "", v = null; if (c instanceof i.default) {
                    if (c.spaceBefore && (y = "\n"), c.commentBefore) {
                        const t = c.commentBefore.replace(/^/gm, "".concat(e.indent, "#"));
                        y += "\n".concat(t);
                    }
                    v = c.comment;
                }
                else
                    c && "object" == typeof c && (c = f.schema.createNode(c, !0)); e.implicitKey = !1, !p && !this.comment && c instanceof s.default && (e.indentAtStart = g.length + 1), m = !1; const b = f.schema.stringify(c, e, (() => v = null), (() => m = !0)); let D = " "; return y || this.comment ? D = "".concat(y, "\n").concat(e.indent) : !p && c instanceof o.default && (("[" === b[0] || "{" === b[0]) && !b.includes("\n") || (D = "\n".concat(e.indent))), m && !v && r && r(), (0, n.default)(g + D + b, e.indent, v); }
            } t.default = u; })); r(I); var j = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = t.isEmptyPath = void 0; var n = s(N), r = s(M), o = s(I), i = s(R); function s(e) { return e && e.__esModule ? e : { default: e }; } function a(e, t, n) { return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e; } function u(e, t, n) { let r = n; for (let e = t.length - 1; e >= 0; --e) {
                const n = t[e], o = Number.isInteger(n) && n >= 0 ? [] : {};
                o[n] = r, r = o;
            } return e.createNode(r, !1); } const c = e => null == e || "object" == typeof e && e[Symbol.iterator]().next().done; t.isEmptyPath = c; class l extends r.default {
                constructor(e) { super(), a(this, "items", []), this.schema = e; }
                addIn(e, t) { if (c(e))
                    this.add(t);
                else {
                    const [n, ...r] = e, o = this.get(n, !0);
                    if (o instanceof l)
                        o.addIn(r, t);
                    else {
                        if (void 0 !== o || !this.schema)
                            throw new Error("Expected YAML collection at ".concat(n, ". Remaining path: ").concat(r));
                        this.set(n, u(this.schema, r, t));
                    }
                } }
                deleteIn([e, ...t]) { if (0 === t.length)
                    return this.delete(e); const n = this.get(e, !0); if (n instanceof l)
                    return n.deleteIn(t); throw new Error("Expected YAML collection at ".concat(e, ". Remaining path: ").concat(t)); }
                getIn([e, ...t], n) { const r = this.get(e, !0); return 0 === t.length ? !n && r instanceof i.default ? r.value : r : r instanceof l ? r.getIn(t, n) : void 0; }
                hasAllNullValues() { return this.items.every((e => { if (!(e instanceof o.default))
                    return !1; const t = e.value; return null == t || t instanceof i.default && null == t.value && !t.commentBefore && !t.comment && !t.tag; })); }
                hasIn([e, ...t]) { if (0 === t.length)
                    return this.has(e); const n = this.get(e, !0); return n instanceof l && n.hasIn(t); }
                setIn([e, ...t], n) { if (0 === t.length)
                    this.set(e, n);
                else {
                    const r = this.get(e, !0);
                    if (r instanceof l)
                        r.setIn(t, n);
                    else {
                        if (void 0 !== r || !this.schema)
                            throw new Error("Expected YAML collection at ".concat(e, ". Remaining path: ").concat(t));
                        this.set(e, u(this.schema, t, n));
                    }
                } }
                toJSON() { return null; }
                toString(e, { blockItem: t, flowChars: r, isMap: o, itemIndent: i }, s, a) { const { doc: u, indent: c } = e, p = this.type && "FLOW" === this.type.substr(0, 4) || e.inFlow; p && (i += "  "); const f = o && this.hasAllNullValues(); e = Object.assign({}, e, { allNullValues: f, indent: i, inFlow: p, type: null }); let d = !1, h = !1; const m = this.items.reduce(((t, r, o) => { let s; r && (!d && r.spaceBefore && t.push({ type: "comment", str: "" }), r.commentBefore && r.commentBefore.match(/^.*$/gm).forEach((e => { t.push({ type: "comment", str: "#".concat(e) }); })), r.comment && (s = r.comment), p && (!d && r.spaceBefore || r.commentBefore || r.comment || r.key && (r.key.commentBefore || r.key.comment) || r.value && (r.value.commentBefore || r.value.comment)) && (h = !0)), d = !1; let a = u.schema.stringify(r, e, (() => s = null), (() => d = !0)); return p && !h && a.includes("\n") && (h = !0), p && o < this.items.length - 1 && (a += ","), a = (0, n.default)(a, i, s), d && (s || p) && (d = !1), t.push({ type: "item", str: a }), t; }), []); let g; if (0 === m.length)
                    g = r.start + r.end;
                else if (p) {
                    const { start: e, end: t } = r, n = m.map((e => e.str));
                    if (h || n.reduce(((e, t) => e + t.length + 2), 2) > l.maxFlowStringSingleLineLength) {
                        g = e;
                        for (const e of n)
                            g += e ? "\n  ".concat(c).concat(e) : "\n";
                        g += "\n".concat(c).concat(t);
                    }
                    else
                        g = "".concat(e, " ").concat(n.join(" "), " ").concat(t);
                }
                else {
                    const e = m.map(t);
                    g = e.shift();
                    for (const t of e)
                        g += t ? "\n".concat(c).concat(t) : "\n";
                } return this.comment ? (g += "\n" + this.comment.replace(/^/gm, "".concat(c, "#")), s && s()) : d && a && a(), g; }
            } t.default = l, a(l, "maxFlowStringSingleLineLength", 60); })); r(j), j.isEmptyPath; var B = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0; var n = s(P), r = s(j), o = s(M), i = s(I); function s(e) { return e && e.__esModule ? e : { default: e }; } const a = (e, t) => { if (e instanceof u) {
                const n = t.find((t => t.node === e.source));
                return n.count * n.aliasCount;
            } if (e instanceof r.default) {
                let n = 0;
                for (const r of e.items) {
                    const e = a(r, t);
                    e > n && (n = e);
                }
                return n;
            } if (e instanceof i.default) {
                const n = a(e.key, t), r = a(e.value, t);
                return Math.max(n, r);
            } return 1; }; class u extends o.default {
                static stringify({ range: e, source: t }, { anchors: n, doc: r, implicitKey: o, inStringifyKey: i }) { let s = Object.keys(n).find((e => n[e] === t)); if (!s && i && (s = r.anchors.getName(t) || r.anchors.newName()), s)
                    return "*".concat(s).concat(o ? " " : ""); const a = r.anchors.getName(t) ? "Alias node must be after source node" : "Source node not found for alias node"; throw new Error("".concat(a, " [").concat(e, "]")); }
                constructor(e) { super(), this.source = e, this.type = d.Type.ALIAS; }
                set tag(e) { throw new Error("Alias nodes cannot have tags"); }
                toJSON(e, t) { if (!t)
                    return (0, n.default)(this.source, e, t); const { anchors: r, maxAliasCount: o } = t, i = r.find((e => e.node === this.source)); if (!i || void 0 === i.res) {
                    const e = "This should not happen: Alias anchor was not resolved?";
                    throw this.cstNode ? new y.YAMLReferenceError(this.cstNode, e) : new ReferenceError(e);
                } if (o >= 0 && (i.count += 1, 0 === i.aliasCount && (i.aliasCount = a(this.source, r)), i.count * i.aliasCount > o)) {
                    const e = "Excessive alias count indicates a resource exhaustion attack";
                    throw this.cstNode ? new y.YAMLReferenceError(this.cstNode, e) : new ReferenceError(e);
                } return i.res; }
                toString(e) { return u.stringify(this, e); }
            } var c, l; t.default = u, (l = "default") in (c = u) ? Object.defineProperty(c, l, { value: !0, enumerable: !0, configurable: !0, writable: !0 }) : c[l] = !0; })); r(B); var L = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.findPair = s, t.default = void 0; var n = i(j), r = i(I), o = i(R); function i(e) { return e && e.__esModule ? e : { default: e }; } function s(e, t) { const n = t instanceof o.default ? t.value : t; for (const o of e)
                if (o instanceof r.default) {
                    if (o.key === t || o.key === n)
                        return o;
                    if (o.key && o.key.value === n)
                        return o;
                } } class a extends n.default {
                add(e, t) { e ? e instanceof r.default || (e = new r.default(e.key || e, e.value)) : e = new r.default(e); const n = s(this.items, e.key), o = this.schema && this.schema.sortMapEntries; if (n) {
                    if (!t)
                        throw new Error("Key ".concat(e.key, " already set"));
                    n.value = e.value;
                }
                else if (o) {
                    const t = this.items.findIndex((t => o(e, t) < 0));
                    -1 === t ? this.items.push(e) : this.items.splice(t, 0, e);
                }
                else
                    this.items.push(e); }
                delete(e) { const t = s(this.items, e); return !!t && this.items.splice(this.items.indexOf(t), 1).length > 0; }
                get(e, t) { const n = s(this.items, e), r = n && n.value; return !t && r instanceof o.default ? r.value : r; }
                has(e) { return !!s(this.items, e); }
                set(e, t) { this.add(new r.default(e, t), !0); }
                toJSON(e, t, n) { const r = n ? new n : t && t.mapAsMap ? new Map : {}; t && t.onCreate && t.onCreate(r); for (const e of this.items)
                    e.addToJSMap(t, r); return r; }
                toString(e, t, n) { if (!e)
                    return JSON.stringify(this); for (const e of this.items)
                    if (!(e instanceof r.default))
                        throw new Error("Map items must all be pairs; found ".concat(JSON.stringify(e), " instead")); return super.toString(e, { blockItem: e => e.str, flowChars: { start: "{", end: "}" }, isMap: !0, itemIndent: e.indent || "" }, t, n); }
            } t.default = a; })); r(L), L.findPair; var q = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0; var n = i(P), r = i(j), o = i(R); function i(e) { return e && e.__esModule ? e : { default: e }; } function s(e) { let t = e instanceof o.default ? e.value : e; return t && "string" == typeof t && (t = Number(t)), Number.isInteger(t) && t >= 0 ? t : null; } class a extends r.default {
                add(e) { this.items.push(e); }
                delete(e) { const t = s(e); return "number" == typeof t && this.items.splice(t, 1).length > 0; }
                get(e, t) { const n = s(e); if ("number" != typeof n)
                    return; const r = this.items[n]; return !t && r instanceof o.default ? r.value : r; }
                has(e) { const t = s(e); return "number" == typeof t && t < this.items.length; }
                set(e, t) { const n = s(e); if ("number" != typeof n)
                    throw new Error("Expected a valid index, not ".concat(e, ".")); this.items[n] = t; }
                toJSON(e, t) { const r = []; t && t.onCreate && t.onCreate(r); let o = 0; for (const e of this.items)
                    r.push((0, n.default)(e, String(o++), t)); return r; }
                toString(e, t, n) { return e ? super.toString(e, { blockItem: e => "comment" === e.type ? e.str : "- ".concat(e.str), flowChars: { start: "[", end: "]" }, isMap: !1, itemIndent: (e.indent || "") + "  " }, t, n) : JSON.stringify(this); }
            } t.default = a; })); r(q); var $ = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = t.MERGE_KEY = void 0; var n = s(L), r = s(I), o = s(R), i = s(q); function s(e) { return e && e.__esModule ? e : { default: e }; } t.MERGE_KEY = "<<"; class a extends r.default {
                constructor(e) { if (e instanceof r.default) {
                    let t = e.value;
                    t instanceof i.default || (t = new i.default, t.items.push(e.value), t.range = e.value.range), super(e.key, t), this.range = e.range;
                }
                else
                    super(new o.default("<<"), new i.default); this.type = "MERGE_PAIR"; }
                addToJSMap(e, t) { for (const { source: r } of this.value.items) {
                    if (!(r instanceof n.default))
                        throw new Error("Merge sources must be maps");
                    const o = r.toJSON(null, e, Map);
                    for (const [e, n] of o)
                        t instanceof Map ? t.has(e) || t.set(e, n) : t instanceof Set ? t.add(e) : Object.prototype.hasOwnProperty.call(t, e) || (t[e] = n);
                } return t; }
                toString(e, t) { const n = this.value; if (n.items.length > 1)
                    return super.toString(e, t); this.value = n.items[0]; const r = super.toString(e, t); return this.value = n, r; }
            } t.default = a; })); r($), $.MERGE_KEY; var U = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0; var n = a(B), r = a(L), o = a($), i = a(R), s = a(q); function a(e) { return e && e.__esModule ? e : { default: e }; } class u {
                static validAnchorNode(e) { return e instanceof i.default || e instanceof s.default || e instanceof r.default; }
                constructor(e) { var t; t = {}, "map" in this ? Object.defineProperty(this, "map", { value: t, enumerable: !0, configurable: !0, writable: !0 }) : this.map = t, this.prefix = e; }
                createAlias(e, t) { return this.setAnchor(e, t), new n.default(e); }
                createMergePair(...e) { const t = new o.default; return t.value.items = e.map((e => { if (e instanceof n.default) {
                    if (e.source instanceof r.default)
                        return e;
                }
                else if (e instanceof r.default)
                    return this.createAlias(e); throw new Error("Merge sources must be Map nodes or their Aliases"); })), t; }
                getName(e) { const { map: t } = this; return Object.keys(t).find((n => t[n] === e)); }
                getNode(e) { return this.map[e]; }
                newName(e) { e || (e = this.prefix); const t = Object.keys(this.map); for (let n = 1;; ++n) {
                    const r = "".concat(e).concat(n);
                    if (!t.includes(r))
                        return r;
                } }
                resolveNodes() { const { map: e, _cstAliases: t } = this; Object.keys(e).forEach((t => { e[t] = e[t].resolved; })), t.forEach((e => { e.source = e.source.resolved; })), delete this._cstAliases; }
                setAnchor(e, t) { if (null != e && !u.validAnchorNode(e))
                    throw new Error("Anchors may only be set for Scalar, Seq and Map nodes"); if (t && /[\x00-\x19\s,[\]{}]/.test(t))
                    throw new Error("Anchor names must not contain whitespace or control characters"); const { map: n } = this, r = e && Object.keys(n).find((t => n[t] === e)); if (r) {
                    if (!t)
                        return r;
                    r !== t && (delete n[r], n[t] = e);
                }
                else {
                    if (!t) {
                        if (!e)
                            return null;
                        t = this.newName();
                    }
                    n[t] = e;
                } return t; }
            } t.default = u; })); r(U); var V = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0; var n = i(j), r = i(I), o = i(R); function i(e) { return e && e.__esModule ? e : { default: e }; } const s = (e, t) => { if (e && "object" == typeof e) {
                const { tag: i } = e;
                e instanceof n.default ? (i && (t[i] = !0), e.items.forEach((e => s(e, t)))) : e instanceof r.default ? (s(e.key, t), s(e.value, t)) : e instanceof o.default && i && (t[i] = !0);
            } return t; }; t.default = e => Object.keys(s(e, {})); })); r(V); var W = o((function (e, n) { function r(e, n) { if (t && t._YAML_SILENCE_WARNINGS)
                return; const { emitWarning: r } = t && t.process; r ? r(e, n) : a.warn(n ? "".concat(n, ": ").concat(e) : e); } Object.defineProperty(n, "__esModule", { value: !0 }), n.warn = r, n.warnFileDeprecation = function (e) { if (t && t._YAML_SILENCE_DEPRECATION_WARNINGS)
                return; const n = e.replace(/.*yaml[/\\]/i, "").replace(/\.js$/, "").replace(/\\/g, "/"); r("The endpoint 'yaml/".concat(n, "' will be removed in a future release."), "DeprecationWarning"); }, n.warnOptionDeprecation = function (e, n) { if (t && t._YAML_SILENCE_DEPRECATION_WARNINGS)
                return; if (o[e])
                return; o[e] = !0; let i = "The option '".concat(e, "' will be removed in a future release"); i += n ? ", use '".concat(n, "' instead.") : ".", r(i, "DeprecationWarning"); }; const o = {}; })); r(W), W.warn, W.warnFileDeprecation, W.warnOptionDeprecation; var K = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function (e, t, r, { indentAtStart: o, lineWidth: i = 80, minContentWidth: s = 20, onFold: a, onOverflow: u }) { if (!i || i < 0)
                return e; const c = Math.max(1 + s, 1 + i - t.length); if (e.length <= c)
                return e; const l = [], p = {}; let f, d, h, m = i - ("number" == typeof o ? o : t.length), g = !1, y = -1; for ("block" === r && (y = n(e, y), -1 !== y && (m = y + c)); f = e[y += 1];) {
                if ("quoted" === r && "\\" === f)
                    switch (e[y + 1]) {
                        case "x":
                            y += 3;
                            break;
                        case "u":
                            y += 5;
                            break;
                        case "U":
                            y += 9;
                            break;
                        default: y += 1;
                    }
                if ("\n" === f)
                    "block" === r && (y = n(e, y)), m = y + c, d = void 0;
                else {
                    if (" " === f && h && " " !== h && "\n" !== h && "\t" !== h) {
                        const t = e[y + 1];
                        t && " " !== t && "\n" !== t && "\t" !== t && (d = y);
                    }
                    if (y >= m)
                        if (d)
                            l.push(d), m = d + c, d = void 0;
                        else if ("quoted" === r) {
                            for (; " " === h || "\t" === h;)
                                h = f, f = e[y += 1], g = !0;
                            l.push(y - 2), p[y - 2] = !0, m = y - 2 + c, d = void 0;
                        }
                        else
                            g = !0;
                }
                h = f;
            } if (g && u && u(), 0 === l.length)
                return e; a && a(); let v = e.slice(0, l[0]); for (let n = 0; n < l.length; ++n) {
                const o = l[n], i = l[n + 1] || e.length;
                "quoted" === r && p[o] && (v += "".concat(e[o], "\\")), v += "\n".concat(t).concat(e.slice(o + 1, i));
            } return v; }, t.FOLD_QUOTED = t.FOLD_BLOCK = t.FOLD_FLOW = void 0, t.FOLD_FLOW = "flow", t.FOLD_BLOCK = "block", t.FOLD_QUOTED = "quoted"; const n = (e, t) => { let n = e[t + 1]; for (; " " === n || "\t" === n;) {
                do {
                    n = e[t += 1];
                } while (n && "\n" !== n);
                n = e[t + 1];
            } return t; }; })); r(K), K.FOLD_QUOTED, K.FOLD_BLOCK, K.FOLD_FLOW; var z = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.strOptions = t.nullOptions = t.boolOptions = t.binaryOptions = void 0; const n = { defaultType: d.Type.BLOCK_LITERAL, lineWidth: 76 }; t.binaryOptions = n, t.boolOptions = { trueStr: "true", falseStr: "false" }, t.nullOptions = { nullStr: "null" }; const r = { defaultType: d.Type.PLAIN, doubleQuoted: { jsonEncoding: !1, minMultiLineLength: 40 }, fold: { lineWidth: 80, minContentWidth: 20 } }; t.strOptions = r; })); r(z), z.strOptions, z.nullOptions, z.boolOptions, z.binaryOptions; var H = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.stringifyNumber = function ({ format: e, minFractionDigits: t, tag: n, value: r }) { if (!isFinite(r))
                return isNaN(r) ? ".nan" : r < 0 ? "-.inf" : ".inf"; let o = JSON.stringify(r); if (!e && t && (!n || "tag:yaml.org,2002:float" === n) && /^\d/.test(o)) {
                let e = o.indexOf(".");
                e < 0 && (e = o.length, o += ".");
                let n = t - (o.length - e - 1);
                for (; n-- > 0;)
                    o += "0";
            } return o; }, t.stringifyString = function (e, t, r, u) { const { defaultType: c } = z.strOptions, { implicitKey: l, inFlow: p } = t; let { type: f, value: h } = e; "string" != typeof h && (h = String(h), e = Object.assign({}, e, { value: h })); const m = c => { switch (c) {
                case d.Type.BLOCK_FOLDED:
                case d.Type.BLOCK_LITERAL: return a(e, t, r, u);
                case d.Type.QUOTE_DOUBLE: return i(h, t);
                case d.Type.QUOTE_SINGLE: return s(h, t);
                case d.Type.PLAIN: return function (e, t, r, u) { const { comment: c, type: l, value: p } = e, { actualString: f, implicitKey: h, indent: m, inFlow: g, tags: y } = t; if (h && /[\n[\]{},]/.test(p) || g && /[[\]{},]/.test(p))
                    return i(p, t); if (!p || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(p))
                    return h || g || -1 === p.indexOf("\n") ? -1 !== p.indexOf('"') && -1 === p.indexOf("'") ? s(p, t) : i(p, t) : a(e, t, r, u); if (!h && !g && l !== d.Type.PLAIN && -1 !== p.indexOf("\n"))
                    return a(e, t, r, u); const v = p.replace(/\n+/g, "$&\n".concat(m)); if (f && "string" != typeof y.resolveScalar(v).value)
                    return i(p, t); const b = h ? v : (0, n.default)(v, m, n.FOLD_FLOW, o(t)); return !c || g || -1 === b.indexOf("\n") && -1 === c.indexOf("\n") ? b : (r && r(), (0, N.addCommentBefore)(b, m, c)); }(e, t, r, u);
                default: return null;
            } }; f !== d.Type.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f]/.test(h) ? f = d.Type.QUOTE_DOUBLE : !l && !p || f !== d.Type.BLOCK_FOLDED && f !== d.Type.BLOCK_LITERAL || (f = d.Type.QUOTE_DOUBLE); let g = m(f); if (null === g && (g = m(c), null === g))
                throw new Error("Unsupported default string type ".concat(c)); return g; }; var n = function (e) { if (e && e.__esModule)
                return e; if (null === e || "object" != typeof e && "function" != typeof e)
                return { default: e }; var t = r(); if (t && t.has(e))
                return t.get(e); var n = {}, o = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var i in e)
                if (Object.prototype.hasOwnProperty.call(e, i)) {
                    var s = o ? Object.getOwnPropertyDescriptor(e, i) : null;
                    s && (s.get || s.set) ? Object.defineProperty(n, i, s) : n[i] = e[i];
                } return n.default = e, t && t.set(e, n), n; }(K); function r() { if ("function" != typeof WeakMap)
                return null; var e = new WeakMap; return r = function () { return e; }, e; } const o = ({ indentAtStart: e }) => e ? Object.assign({ indentAtStart: e }, z.strOptions.fold) : z.strOptions.fold; function i(e, t) { const { implicitKey: r, indent: i } = t, { jsonEncoding: s, minMultiLineLength: a } = z.strOptions.doubleQuoted, u = JSON.stringify(e); if (s)
                return u; let c = "", l = 0; for (let e = 0, t = u[e]; t; t = u[++e])
                if (" " === t && "\\" === u[e + 1] && "n" === u[e + 2] && (c += u.slice(l, e) + "\\ ", e += 1, l = e, t = "\\"), "\\" === t)
                    switch (u[e + 1]) {
                        case "u":
                            {
                                c += u.slice(l, e);
                                const t = u.substr(e + 2, 4);
                                switch (t) {
                                    case "0000":
                                        c += "\\0";
                                        break;
                                    case "0007":
                                        c += "\\a";
                                        break;
                                    case "000b":
                                        c += "\\v";
                                        break;
                                    case "001b":
                                        c += "\\e";
                                        break;
                                    case "0085":
                                        c += "\\N";
                                        break;
                                    case "00a0":
                                        c += "\\_";
                                        break;
                                    case "2028":
                                        c += "\\L";
                                        break;
                                    case "2029":
                                        c += "\\P";
                                        break;
                                    default: "00" === t.substr(0, 2) ? c += "\\x" + t.substr(2) : c += u.substr(e, 6);
                                }
                                e += 5, l = e + 1;
                            }
                            break;
                        case "n":
                            if (r || '"' === u[e + 2] || u.length < a)
                                e += 1;
                            else {
                                for (c += u.slice(l, e) + "\n\n"; "\\" === u[e + 2] && "n" === u[e + 3] && '"' !== u[e + 4];)
                                    c += "\n", e += 2;
                                c += i, " " === u[e + 2] && (c += "\\"), e += 1, l = e + 1;
                            }
                            break;
                        default: e += 1;
                    } return c = l ? c + u.slice(l) : u, r ? c : (0, n.default)(c, i, n.FOLD_QUOTED, o(t)); } function s(e, t) { const { indent: r, implicitKey: s } = t; if (s) {
                if (/\n/.test(e))
                    return i(e, t);
            }
            else if (/[ \t]\n|\n[ \t]/.test(e))
                return i(e, t); const a = "'" + e.replace(/'/g, "''").replace(/\n+/g, "$&\n".concat(r)) + "'"; return s ? a : (0, n.default)(a, r, n.FOLD_FLOW, o(t)); } function a({ comment: e, type: t, value: r }, o, s, a) { if (/\n[\t ]+$/.test(r) || /^\s*$/.test(r))
                return i(r, o); const u = o.indent || (o.forceBlockIndent ? " " : ""), c = u ? "2" : "1", l = t !== d.Type.BLOCK_FOLDED && (t === d.Type.BLOCK_LITERAL || !function (e, t) { const n = e.length; if (n <= t)
                return !1; for (let r = 0, o = 0; r < n; ++r)
                if ("\n" === e[r]) {
                    if (r - o > t)
                        return !0;
                    if (o = r + 1, n - o <= t)
                        return !1;
                } return !0; }(r, z.strOptions.fold.lineWidth - u.length)); let p = l ? "|" : ">"; if (!r)
                return p + "\n"; let f = "", h = ""; if (r = r.replace(/[\n\t ]*$/, (e => { const t = e.indexOf("\n"); return -1 === t ? p += "-" : r !== e && t === e.length - 1 || (p += "+", a && a()), h = e.replace(/\n$/, ""), ""; })).replace(/^[\n ]*/, (e => { -1 !== e.indexOf(" ") && (p += c); const t = e.match(/ +$/); return t ? (f = e.slice(0, -t[0].length), t[0]) : (f = e, ""); })), h && (h = h.replace(/\n+(?!\n|$)/g, "$&".concat(u))), f && (f = f.replace(/\n+/g, "$&".concat(u))), e && (p += " #" + e.replace(/ ?[\r\n]+/g, " "), s && s()), !r)
                return "".concat(p).concat(c, "\n").concat(u).concat(h); if (l)
                return r = r.replace(/\n+/g, "$&".concat(u)), "".concat(p, "\n").concat(u).concat(f).concat(r).concat(h); r = r.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, "$&".concat(u)); const m = (0, n.default)("".concat(f).concat(r).concat(h), u, n.FOLD_BLOCK, z.strOptions.fold); return "".concat(p, "\n").concat(u).concat(m); } })); r(H), H.stringifyNumber, H.stringifyString; var Y = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.checkFlowCollectionEnd = function (e, t) { let n, r, o; switch (t.type) {
                case d.Type.FLOW_MAP:
                    n = "}", r = "flow map";
                    break;
                case d.Type.FLOW_SEQ:
                    n = "]", r = "flow sequence";
                    break;
                default: return void e.push(new y.YAMLSemanticError(t, "Not a flow collection!?"));
            } for (let e = t.items.length - 1; e >= 0; --e) {
                const n = t.items[e];
                if (!n || n.type !== d.Type.COMMENT) {
                    o = n;
                    break;
                }
            } if (o && o.char !== n) {
                const i = "Expected ".concat(r, " to end with ").concat(n);
                let s;
                "number" == typeof o.offset ? (s = new y.YAMLSemanticError(t, i), s.offset = o.offset + 1) : (s = new y.YAMLSemanticError(o, i), o.range && o.range.end && (s.offset = o.range.end - o.range.start)), e.push(s);
            } }, t.checkKeyLength = function (e, t, n, r, o) { if (!r || "number" != typeof o)
                return; const i = t.items[n]; let s = i && i.range && i.range.start; if (!s)
                for (let e = n - 1; e >= 0; --e) {
                    const r = t.items[e];
                    if (r && r.range) {
                        s = r.range.end + 2 * (n - e);
                        break;
                    }
                } if (s > o + 1024) {
                const n = String(r).substr(0, 8) + "..." + String(r).substr(-8);
                e.push(new y.YAMLSemanticError(t, 'The "'.concat(n, '" key is too long')));
            } }, t.resolveComments = function (e, t) { for (const { afterKey: n, before: r, comment: o } of t) {
                let t = e.items[r];
                t ? (n && t.value && (t = t.value), void 0 === o ? !n && t.commentBefore || (t.spaceBefore = !0) : t.commentBefore ? t.commentBefore += "\n" + o : t.commentBefore = o) : void 0 !== o && (e.comment ? e.comment += "\n" + o : e.comment = o);
            } }; })); r(Y), Y.checkFlowCollectionEnd, Y.checkKeyLength, Y.resolveComments; var J = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function (e, t) { if (t.type !== d.Type.MAP && t.type !== d.Type.FLOW_MAP) {
                const n = "A ".concat(t.type, " node cannot be resolved as a mapping");
                return e.errors.push(new y.YAMLSyntaxError(t, n)), null;
            } const { comments: u, items: c } = t.type === d.Type.FLOW_MAP ? function (e, t) { const n = [], r = []; let o, s = null, a = !1, u = "{"; for (let c = 0; c < t.items.length; ++c) {
                (0, Y.checkKeyLength)(e.errors, t, c, o, s);
                const l = t.items[c];
                if ("string" == typeof l.char) {
                    const { char: n, offset: p } = l;
                    if ("?" === n && void 0 === o && !a) {
                        a = !0, u = ":";
                        continue;
                    }
                    if (":" === n) {
                        if (void 0 === o && (o = null), ":" === u) {
                            u = ",";
                            continue;
                        }
                    }
                    else if (a && (void 0 === o && "," !== n && (o = null), a = !1), void 0 !== o && (r.push(new i.default(o)), o = void 0, s = null, "," === n)) {
                        u = ":";
                        continue;
                    }
                    if ("}" === n) {
                        if (c === t.items.length - 1)
                            continue;
                    }
                    else if (n === u) {
                        u = ":";
                        continue;
                    }
                    const f = "Flow map contains an unexpected ".concat(n), d = new y.YAMLSyntaxError(t, f);
                    d.offset = p, e.errors.push(d);
                }
                else
                    l.type === d.Type.BLANK_LINE ? n.push({ afterKey: !!o, before: r.length }) : l.type === d.Type.COMMENT ? n.push({ afterKey: !!o, before: r.length, comment: l.comment }) : void 0 === o ? ("," === u && e.errors.push(new y.YAMLSemanticError(l, "Separator , missing in flow map")), o = e.resolveNode(l), s = a ? null : l.range.start) : ("," !== u && e.errors.push(new y.YAMLSemanticError(l, "Indicator : missing in flow map entry")), r.push(new i.default(o, e.resolveNode(l))), o = void 0, a = !1);
            } return (0, Y.checkFlowCollectionEnd)(e.errors, t), void 0 !== o && r.push(new i.default(o)), { comments: n, items: r }; }(e, t) : function (e, t) { const r = [], o = []; let s, a = null; for (let u = 0; u < t.items.length; ++u) {
                const c = t.items[u];
                switch (c.type) {
                    case d.Type.BLANK_LINE:
                        r.push({ afterKey: !!s, before: o.length });
                        break;
                    case d.Type.COMMENT:
                        r.push({ afterKey: !!s, before: o.length, comment: c.comment });
                        break;
                    case d.Type.MAP_KEY:
                        void 0 !== s && o.push(new i.default(s)), c.error && e.errors.push(c.error), s = e.resolveNode(c.node), a = null;
                        break;
                    case d.Type.MAP_VALUE:
                        {
                            if (void 0 === s && (s = null), c.error && e.errors.push(c.error), !c.context.atLineStart && c.node && c.node.type === d.Type.MAP && !c.node.context.atLineStart) {
                                const t = "Nested mappings are not allowed in compact mappings";
                                e.errors.push(new y.YAMLSemanticError(c.node, t));
                            }
                            let r = c.node;
                            if (!r && c.props.length > 0) {
                                r = new n.default(d.Type.PLAIN, []), r.context = { parent: c, src: c.context.src };
                                const e = c.range.start + 1;
                                if (r.range = { start: e, end: e }, r.valueRange = { start: e, end: e }, "number" == typeof c.range.origStart) {
                                    const e = c.range.origStart + 1;
                                    r.range.origStart = r.range.origEnd = e, r.valueRange.origStart = r.valueRange.origEnd = e;
                                }
                            }
                            const p = new i.default(s, e.resolveNode(r));
                            l(c, p), o.push(p), (0, Y.checkKeyLength)(e.errors, t, u, s, a), s = void 0, a = null;
                        }
                        break;
                    default:
                        void 0 !== s && o.push(new i.default(s)), s = e.resolveNode(c), a = c.range.start, c.error && e.errors.push(c.error);
                        e: for (let n = u + 1;; ++n) {
                            const r = t.items[n];
                            switch (r && r.type) {
                                case d.Type.BLANK_LINE:
                                case d.Type.COMMENT: continue e;
                                case d.Type.MAP_VALUE: break e;
                                default:
                                    e.errors.push(new y.YAMLSemanticError(c, "Implicit map keys need to be followed by map values"));
                                    break e;
                            }
                        }
                        if (c.valueRangeContainsNewline) {
                            const t = "Implicit map keys need to be on a single line";
                            e.errors.push(new y.YAMLSemanticError(c, t));
                        }
                }
            } return void 0 !== s && o.push(new i.default(s)), { comments: r, items: o }; }(e, t), p = new r.default; p.items = c, (0, Y.resolveComments)(p, u); let f = !1; for (let n = 0; n < c.length; ++n) {
                const { key: r } = c[n];
                if (r instanceof a.default && (f = !0), e.schema.merge && r && r.value === o.MERGE_KEY) {
                    c[n] = new o.default(c[n]);
                    const r = c[n].value.items;
                    let i = null;
                    r.some((e => { if (e instanceof s.default) {
                        const { type: t } = e.source;
                        return t !== d.Type.MAP && t !== d.Type.FLOW_MAP && (i = "Merge nodes aliases can only point to maps");
                    } return i = "Merge nodes can only have Alias nodes as values"; })), i && e.errors.push(new y.YAMLSemanticError(t, i));
                }
                else
                    for (let o = n + 1; o < c.length; ++o) {
                        const { key: n } = c[o];
                        if (r === n || r && n && Object.prototype.hasOwnProperty.call(r, "value") && r.value === n.value) {
                            const n = 'Map keys must be unique; "'.concat(r, '" is repeated');
                            e.errors.push(new y.YAMLSemanticError(t, n));
                            break;
                        }
                    }
            } if (f && !e.options.mapAsMap) {
                const n = "Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";
                e.warnings.push(new y.YAMLWarning(t, n));
            } return t.resolved = p, p; }; var n = c(T), r = c(L), o = function (e) { if (e && e.__esModule)
                return e; if (null === e || "object" != typeof e && "function" != typeof e)
                return { default: e }; var t = u(); if (t && t.has(e))
                return t.get(e); var n = {}, r = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var i = r ? Object.getOwnPropertyDescriptor(e, o) : null;
                    i && (i.get || i.set) ? Object.defineProperty(n, o, i) : n[o] = e[o];
                } return n.default = e, t && t.set(e, n), n; }($), i = c(I), s = c(B), a = c(j); function u() { if ("function" != typeof WeakMap)
                return null; var e = new WeakMap; return u = function () { return e; }, e; } function c(e) { return e && e.__esModule ? e : { default: e }; } function l(e, t) { if (!(({ context: { lineStart: e, node: t, src: n }, props: r }) => { if (0 === r.length)
                return !1; const { start: o } = r[0]; if (t && o > t.valueRange.start)
                return !1; if (n[o] !== d.Char.COMMENT)
                return !1; for (let t = e; t < o; ++t)
                if ("\n" === n[t])
                    return !1; return !0; })(e))
                return; const n = e.getPropValue(0, d.Char.COMMENT, !0); let r = !1; const o = t.value.commentBefore; if (o && o.startsWith(n))
                t.value.commentBefore = o.substr(n.length + 1), r = !0;
            else {
                const o = t.value.comment;
                !e.node && o && o.startsWith(n) && (t.value.comment = o.substr(n.length + 1), r = !0);
            } r && (t.comment = n); } })); r(J); var G = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0; var n = o(L), r = o(J); function o(e) { return e && e.__esModule ? e : { default: e }; } var i = { createNode: function (e, t, r) { const o = new n.default(e); if (t instanceof Map)
                    for (const [n, i] of t)
                        o.items.push(e.createPair(n, i, r));
                else if (t && "object" == typeof t)
                    for (const n of Object.keys(t))
                        o.items.push(e.createPair(n, t[n], r)); return "function" == typeof e.sortMapEntries && o.items.sort(e.sortMapEntries), o; }, default: !0, nodeClass: n.default, tag: "tag:yaml.org,2002:map", resolve: r.default }; t.default = i; })); r(G); var X = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function (e, t) { if (t.type !== d.Type.SEQ && t.type !== d.Type.FLOW_SEQ) {
                const n = "A ".concat(t.type, " node cannot be resolved as a sequence");
                return e.errors.push(new y.YAMLSyntaxError(t, n)), null;
            } const { comments: i, items: s } = t.type === d.Type.FLOW_SEQ ? function (e, t) { const r = [], o = []; let i, s = !1, a = null, u = "["; for (let c = 0; c < t.items.length; ++c) {
                const l = t.items[c];
                if ("string" == typeof l.char) {
                    const { char: r, offset: p } = l;
                    if (":" === r || !s && void 0 === i || (s && void 0 === i && (i = u ? o.pop() : null), o.push(new n.default(i)), s = !1, i = void 0, a = null), r === u)
                        u = null;
                    else if (u || "?" !== r) {
                        if ("[" !== u && ":" === r && void 0 === i) {
                            if ("," === u) {
                                if (i = o.pop(), i instanceof n.default) {
                                    const n = "Chaining flow sequence pairs is invalid", r = new y.YAMLSemanticError(t, n);
                                    r.offset = p, e.errors.push(r);
                                }
                                s || (0, Y.checkKeyLength)(e.errors, t, c, i, a);
                            }
                            else
                                i = null;
                            a = null, s = !1, u = null;
                        }
                        else if ("[" === u || "]" !== r || c < t.items.length - 1) {
                            const n = "Flow sequence contains an unexpected ".concat(r), o = new y.YAMLSyntaxError(t, n);
                            o.offset = p, e.errors.push(o);
                        }
                    }
                    else
                        s = !0;
                }
                else if (l.type === d.Type.BLANK_LINE)
                    r.push({ before: o.length });
                else if (l.type === d.Type.COMMENT)
                    r.push({ comment: l.comment, before: o.length });
                else {
                    if (u) {
                        const t = "Expected a ".concat(u, " in flow sequence");
                        e.errors.push(new y.YAMLSemanticError(l, t));
                    }
                    const t = e.resolveNode(l);
                    void 0 === i ? o.push(t) : (o.push(new n.default(i, t)), i = void 0), a = l.range.start, u = ",";
                }
            } return (0, Y.checkFlowCollectionEnd)(e.errors, t), void 0 !== i && o.push(new n.default(i)), { comments: r, items: o }; }(e, t) : function (e, t) { const n = [], r = []; for (let o = 0; o < t.items.length; ++o) {
                const i = t.items[o];
                switch (i.type) {
                    case d.Type.BLANK_LINE:
                        n.push({ before: r.length });
                        break;
                    case d.Type.COMMENT:
                        n.push({ comment: i.comment, before: r.length });
                        break;
                    case d.Type.SEQ_ITEM:
                        if (i.error && e.errors.push(i.error), r.push(e.resolveNode(i.node)), i.hasProps) {
                            const t = "Sequence items cannot have tags or anchors before the - indicator";
                            e.errors.push(new y.YAMLSemanticError(i, t));
                        }
                        break;
                    default: i.error && e.errors.push(i.error), e.errors.push(new y.YAMLSyntaxError(i, "Unexpected ".concat(i.type, " node in sequence")));
                }
            } return { comments: n, items: r }; }(e, t), a = new r.default; if (a.items = s, (0, Y.resolveComments)(a, i), !e.options.mapAsMap && s.some((e => e instanceof n.default && e.key instanceof o.default))) {
                const n = "Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";
                e.warnings.push(new y.YAMLWarning(t, n));
            } return t.resolved = a, a; }; var n = i(I), r = i(q), o = i(j); function i(e) { return e && e.__esModule ? e : { default: e }; } })); r(X); var Q = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0; var n = o(X), r = o(q); function o(e) { return e && e.__esModule ? e : { default: e }; } var i = { createNode: function (e, t, n) { const o = new r.default(e); if (t && t[Symbol.iterator])
                    for (const r of t) {
                        const t = e.createNode(r, n.wrapScalars, null, n);
                        o.items.push(t);
                    } return o; }, default: !0, nodeClass: r.default, tag: "tag:yaml.org,2002:seq", resolve: n.default }; t.default = i; })); r(Q); var Z = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = t.resolveString = void 0; const n = (e, t) => { const n = t.strValue; return n ? "string" == typeof n ? n : (n.errors.forEach((n => { n.source || (n.source = t), e.errors.push(n); })), n.str) : ""; }; t.resolveString = n; var r = { identify: e => "string" == typeof e, default: !0, tag: "tag:yaml.org,2002:str", resolve: n, stringify: (e, t, n, r) => (t = Object.assign({ actualString: !0 }, t), (0, H.stringifyString)(e, t, n, r)), options: z.strOptions }; t.default = r; })); r(Z), Z.resolveString; var ee = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0; var n = i(G), r = i(Q), o = i(Z); function i(e) { return e && e.__esModule ? e : { default: e }; } var s = [n.default, r.default, o.default]; t.default = s; })); r(ee); var te = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = t.floatObj = t.expObj = t.nanObj = t.hexObj = t.intObj = t.octObj = t.boolObj = t.nullObj = void 0; var n = o(R), r = o(ee); function o(e) { return e && e.__esModule ? e : { default: e }; } const i = { identify: e => null == e, createNode: (e, t, r) => r.wrapScalars ? new n.default(null) : null, default: !0, tag: "tag:yaml.org,2002:null", test: /^(?:~|[Nn]ull|NULL)?$/, resolve: () => null, options: z.nullOptions, stringify: () => z.nullOptions.nullStr }; t.nullObj = i; const s = { identify: e => "boolean" == typeof e, default: !0, tag: "tag:yaml.org,2002:bool", test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/, resolve: e => "t" === e[0] || "T" === e[0], options: z.boolOptions, stringify: ({ value: e }) => e ? z.boolOptions.trueStr : z.boolOptions.falseStr }; t.boolObj = s; const a = { identify: e => "number" == typeof e, default: !0, tag: "tag:yaml.org,2002:int", format: "OCT", test: /^0o([0-7]+)$/, resolve: (e, t) => parseInt(t, 8), stringify: ({ value: e }) => "0o" + e.toString(8) }; t.octObj = a; const u = { identify: e => "number" == typeof e, default: !0, tag: "tag:yaml.org,2002:int", test: /^[-+]?[0-9]+$/, resolve: e => parseInt(e, 10), stringify: H.stringifyNumber }; t.intObj = u; const c = { identify: e => "number" == typeof e, default: !0, tag: "tag:yaml.org,2002:int", format: "HEX", test: /^0x([0-9a-fA-F]+)$/, resolve: (e, t) => parseInt(t, 16), stringify: ({ value: e }) => "0x" + e.toString(16) }; t.hexObj = c; const l = { identify: e => "number" == typeof e, default: !0, tag: "tag:yaml.org,2002:float", test: /^(?:[-+]?\.inf|(\.nan))$/i, resolve: (e, t) => t ? NaN : "-" === e[0] ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, stringify: H.stringifyNumber }; t.nanObj = l; const p = { identify: e => "number" == typeof e, default: !0, tag: "tag:yaml.org,2002:float", format: "EXP", test: /^[-+]?(?:0|[1-9][0-9]*)(\.[0-9]*)?[eE][-+]?[0-9]+$/, resolve: e => parseFloat(e), stringify: ({ value: e }) => Number(e).toExponential() }; t.expObj = p; const f = { identify: e => "number" == typeof e, default: !0, tag: "tag:yaml.org,2002:float", test: /^[-+]?(?:0|[1-9][0-9]*)\.([0-9]*)$/, resolve(e, t) { const r = new n.default(parseFloat(e)); return t && "0" === t[t.length - 1] && (r.minFractionDigits = t.length), r; }, stringify: H.stringifyNumber }; t.floatObj = f; var d = r.default.concat([i, s, a, u, c, l, p, f]); t.default = d; })); r(te), te.floatObj, te.expObj, te.nanObj, te.hexObj, te.intObj, te.octObj, te.boolObj, te.nullObj; var ne = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0; var n = i(G), r = i(Q), o = i(R); function i(e) { return e && e.__esModule ? e : { default: e }; } const s = [n.default, r.default, { identify: e => "string" == typeof e, default: !0, tag: "tag:yaml.org,2002:str", resolve: Z.resolveString, stringify: e => JSON.stringify(e) }, { identify: e => null == e, createNode: (e, t, n) => n.wrapScalars ? new o.default(null) : null, default: !0, tag: "tag:yaml.org,2002:null", test: /^null$/, resolve: () => null, stringify: e => JSON.stringify(e) }, { identify: e => "boolean" == typeof e, default: !0, tag: "tag:yaml.org,2002:bool", test: /^true|false$/, resolve: e => "true" === e, stringify: e => JSON.stringify(e) }, { identify: e => "number" == typeof e, default: !0, tag: "tag:yaml.org,2002:int", test: /^-?(?:0|[1-9][0-9]*)$/, resolve: e => parseInt(e, 10), stringify: e => JSON.stringify(e) }, { identify: e => "number" == typeof e, default: !0, tag: "tag:yaml.org,2002:float", test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/, resolve: e => parseFloat(e), stringify: e => JSON.stringify(e) }]; s.scalarFallback = e => { throw new SyntaxError("Unresolved plain scalar ".concat(JSON.stringify(e))); }; var a = s; t.default = a; })); r(ne); var re = void 0 !== n.g ? n.g : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, oe = [], ie = [], se = "undefined" != typeof Uint8Array ? Uint8Array : Array, ae = !1; function ue() { ae = !0; for (var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", t = 0, n = e.length; t < n; ++t)
                oe[t] = e[t], ie[e.charCodeAt(t)] = t; ie["-".charCodeAt(0)] = 62, ie["_".charCodeAt(0)] = 63; } function ce(e, t, n) { for (var r, o, i = [], s = t; s < n; s += 3)
                r = (e[s] << 16) + (e[s + 1] << 8) + e[s + 2], i.push(oe[(o = r) >> 18 & 63] + oe[o >> 12 & 63] + oe[o >> 6 & 63] + oe[63 & o]); return i.join(""); } function le(e) { var t; ae || ue(); for (var n = e.length, r = n % 3, o = "", i = [], s = 0, a = n - r; s < a; s += 16383)
                i.push(ce(e, s, s + 16383 > a ? a : s + 16383)); return 1 === r ? (t = e[n - 1], o += oe[t >> 2], o += oe[t << 4 & 63], o += "==") : 2 === r && (t = (e[n - 2] << 8) + e[n - 1], o += oe[t >> 10], o += oe[t >> 4 & 63], o += oe[t << 2 & 63], o += "="), i.push(o), i.join(""); } function pe(e, t, n, r, o) { var i, s, a = 8 * o - r - 1, u = (1 << a) - 1, c = u >> 1, l = -7, p = n ? o - 1 : 0, f = n ? -1 : 1, d = e[t + p]; for (p += f, i = d & (1 << -l) - 1, d >>= -l, l += a; l > 0; i = 256 * i + e[t + p], p += f, l -= 8)
                ; for (s = i & (1 << -l) - 1, i >>= -l, l += r; l > 0; s = 256 * s + e[t + p], p += f, l -= 8)
                ; if (0 === i)
                i = 1 - c;
            else {
                if (i === u)
                    return s ? NaN : 1 / 0 * (d ? -1 : 1);
                s += Math.pow(2, r), i -= c;
            } return (d ? -1 : 1) * s * Math.pow(2, i - r); } function fe(e, t, n, r, o, i) { var s, a, u, c = 8 * i - o - 1, l = (1 << c) - 1, p = l >> 1, f = 23 === o ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = r ? 0 : i - 1, h = r ? 1 : -1, m = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0; for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (a = isNaN(t) ? 1 : 0, s = l) : (s = Math.floor(Math.log(t) / Math.LN2), t * (u = Math.pow(2, -s)) < 1 && (s--, u *= 2), (t += s + p >= 1 ? f / u : f * Math.pow(2, 1 - p)) * u >= 2 && (s++, u /= 2), s + p >= l ? (a = 0, s = l) : s + p >= 1 ? (a = (t * u - 1) * Math.pow(2, o), s += p) : (a = t * Math.pow(2, p - 1) * Math.pow(2, o), s = 0)); o >= 8; e[n + d] = 255 & a, d += h, a /= 256, o -= 8)
                ; for (s = s << o | a, c += o; c > 0; e[n + d] = 255 & s, d += h, s /= 256, c -= 8)
                ; e[n + d - h] |= 128 * m; } var de = {}.toString, he = Array.isArray || function (e) { return "[object Array]" == de.call(e); }; function me() { return ye.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823; } function ge(e, t) { if (me() < t)
                throw new RangeError("Invalid typed array length"); return ye.TYPED_ARRAY_SUPPORT ? (e = new Uint8Array(t)).__proto__ = ye.prototype : (null === e && (e = new ye(t)), e.length = t), e; } function ye(e, t, n) { if (!(ye.TYPED_ARRAY_SUPPORT || this instanceof ye))
                return new ye(e, t, n); if ("number" == typeof e) {
                if ("string" == typeof t)
                    throw new Error("If encoding is specified then the first argument must be a string");
                return De(this, e);
            } return ve(this, e, t, n); } function ve(e, t, n, r) { if ("number" == typeof t)
                throw new TypeError('"value" argument must not be a number'); return "undefined" != typeof ArrayBuffer && t instanceof ArrayBuffer ? function (e, t, n, r) { if (t.byteLength, n < 0 || t.byteLength < n)
                throw new RangeError("'offset' is out of bounds"); if (t.byteLength < n + (r || 0))
                throw new RangeError("'length' is out of bounds"); return t = void 0 === n && void 0 === r ? new Uint8Array(t) : void 0 === r ? new Uint8Array(t, n) : new Uint8Array(t, n, r), ye.TYPED_ARRAY_SUPPORT ? (e = t).__proto__ = ye.prototype : e = Ee(e, t), e; }(e, t, n, r) : "string" == typeof t ? function (e, t, n) { if ("string" == typeof n && "" !== n || (n = "utf8"), !ye.isEncoding(n))
                throw new TypeError('"encoding" must be a valid string encoding'); var r = 0 | Ae(t, n), o = (e = ge(e, r)).write(t, n); return o !== r && (e = e.slice(0, o)), e; }(e, t, n) : function (e, t) { if (we(t)) {
                var n = 0 | Ce(t.length);
                return 0 === (e = ge(e, n)).length || t.copy(e, 0, 0, n), e;
            } if (t) {
                if ("undefined" != typeof ArrayBuffer && t.buffer instanceof ArrayBuffer || "length" in t)
                    return "number" != typeof t.length || (r = t.length) != r ? ge(e, 0) : Ee(e, t);
                if ("Buffer" === t.type && he(t.data))
                    return Ee(e, t.data);
            } var r; throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object."); }(e, t); } function be(e) { if ("number" != typeof e)
                throw new TypeError('"size" argument must be a number'); if (e < 0)
                throw new RangeError('"size" argument must not be negative'); } function De(e, t) { if (be(t), e = ge(e, t < 0 ? 0 : 0 | Ce(t)), !ye.TYPED_ARRAY_SUPPORT)
                for (var n = 0; n < t; ++n)
                    e[n] = 0; return e; } function Ee(e, t) { var n = t.length < 0 ? 0 : 0 | Ce(t.length); e = ge(e, n); for (var r = 0; r < n; r += 1)
                e[r] = 255 & t[r]; return e; } function Ce(e) { if (e >= me())
                throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + me().toString(16) + " bytes"); return 0 | e; } function we(e) { return !(null == e || !e._isBuffer); } function Ae(e, t) { if (we(e))
                return e.length; if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(e) || e instanceof ArrayBuffer))
                return e.byteLength; "string" != typeof e && (e = "" + e); var n = e.length; if (0 === n)
                return 0; for (var r = !1;;)
                switch (t) {
                    case "ascii":
                    case "latin1":
                    case "binary": return n;
                    case "utf8":
                    case "utf-8":
                    case void 0: return Ge(e).length;
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le": return 2 * n;
                    case "hex": return n >>> 1;
                    case "base64": return Xe(e).length;
                    default:
                        if (r)
                            return Ge(e).length;
                        t = ("" + t).toLowerCase(), r = !0;
                } } function Se(e, t, n) { var r = !1; if ((void 0 === t || t < 0) && (t = 0), t > this.length)
                return ""; if ((void 0 === n || n > this.length) && (n = this.length), n <= 0)
                return ""; if ((n >>>= 0) <= (t >>>= 0))
                return ""; for (e || (e = "utf8");;)
                switch (e) {
                    case "hex": return Le(this, t, n);
                    case "utf8":
                    case "utf-8": return Ie(this, t, n);
                    case "ascii": return je(this, t, n);
                    case "latin1":
                    case "binary": return Be(this, t, n);
                    case "base64": return Re(this, t, n);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le": return qe(this, t, n);
                    default:
                        if (r)
                            throw new TypeError("Unknown encoding: " + e);
                        e = (e + "").toLowerCase(), r = !0;
                } } function xe(e, t, n) { var r = e[t]; e[t] = e[n], e[n] = r; } function Te(e, t, n, r, o) { if (0 === e.length)
                return -1; if ("string" == typeof n ? (r = n, n = 0) : n > 2147483647 ? n = 2147483647 : n < -2147483648 && (n = -2147483648), n = +n, isNaN(n) && (n = o ? 0 : e.length - 1), n < 0 && (n = e.length + n), n >= e.length) {
                if (o)
                    return -1;
                n = e.length - 1;
            }
            else if (n < 0) {
                if (!o)
                    return -1;
                n = 0;
            } if ("string" == typeof t && (t = ye.from(t, r)), we(t))
                return 0 === t.length ? -1 : ke(e, t, n, r, o); if ("number" == typeof t)
                return t &= 255, ye.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? o ? Uint8Array.prototype.indexOf.call(e, t, n) : Uint8Array.prototype.lastIndexOf.call(e, t, n) : ke(e, [t], n, r, o); throw new TypeError("val must be string, number or Buffer"); } function ke(e, t, n, r, o) { var i, s = 1, a = e.length, u = t.length; if (void 0 !== r && ("ucs2" === (r = String(r).toLowerCase()) || "ucs-2" === r || "utf16le" === r || "utf-16le" === r)) {
                if (e.length < 2 || t.length < 2)
                    return -1;
                s = 2, a /= 2, u /= 2, n /= 2;
            } function c(e, t) { return 1 === s ? e[t] : e.readUInt16BE(t * s); } if (o) {
                var l = -1;
                for (i = n; i < a; i++)
                    if (c(e, i) === c(t, -1 === l ? 0 : i - l)) {
                        if (-1 === l && (l = i), i - l + 1 === u)
                            return l * s;
                    }
                    else
                        -1 !== l && (i -= i - l), l = -1;
            }
            else
                for (n + u > a && (n = a - u), i = n; i >= 0; i--) {
                    for (var p = !0, f = 0; f < u; f++)
                        if (c(e, i + f) !== c(t, f)) {
                            p = !1;
                            break;
                        }
                    if (p)
                        return i;
                } return -1; } function Fe(e, t, n, r) { n = Number(n) || 0; var o = e.length - n; r ? (r = Number(r)) > o && (r = o) : r = o; var i = t.length; if (i % 2 != 0)
                throw new TypeError("Invalid hex string"); r > i / 2 && (r = i / 2); for (var s = 0; s < r; ++s) {
                var a = parseInt(t.substr(2 * s, 2), 16);
                if (isNaN(a))
                    return s;
                e[n + s] = a;
            } return s; } function Oe(e, t, n, r) { return Qe(Ge(t, e.length - n), e, n, r); } function _e(e, t, n, r) { return Qe(function (e) { for (var t = [], n = 0; n < e.length; ++n)
                t.push(255 & e.charCodeAt(n)); return t; }(t), e, n, r); } function Ne(e, t, n, r) { return _e(e, t, n, r); } function Pe(e, t, n, r) { return Qe(Xe(t), e, n, r); } function Me(e, t, n, r) { return Qe(function (e, t) { for (var n, r, o, i = [], s = 0; s < e.length && !((t -= 2) < 0); ++s)
                r = (n = e.charCodeAt(s)) >> 8, o = n % 256, i.push(o), i.push(r); return i; }(t, e.length - n), e, n, r); } function Re(e, t, n) { return 0 === t && n === e.length ? le(e) : le(e.slice(t, n)); } function Ie(e, t, n) { n = Math.min(e.length, n); for (var r = [], o = t; o < n;) {
                var i, s, a, u, c = e[o], l = null, p = c > 239 ? 4 : c > 223 ? 3 : c > 191 ? 2 : 1;
                if (o + p <= n)
                    switch (p) {
                        case 1:
                            c < 128 && (l = c);
                            break;
                        case 2:
                            128 == (192 & (i = e[o + 1])) && (u = (31 & c) << 6 | 63 & i) > 127 && (l = u);
                            break;
                        case 3:
                            i = e[o + 1], s = e[o + 2], 128 == (192 & i) && 128 == (192 & s) && (u = (15 & c) << 12 | (63 & i) << 6 | 63 & s) > 2047 && (u < 55296 || u > 57343) && (l = u);
                            break;
                        case 4: i = e[o + 1], s = e[o + 2], a = e[o + 3], 128 == (192 & i) && 128 == (192 & s) && 128 == (192 & a) && (u = (15 & c) << 18 | (63 & i) << 12 | (63 & s) << 6 | 63 & a) > 65535 && u < 1114112 && (l = u);
                    }
                null === l ? (l = 65533, p = 1) : l > 65535 && (l -= 65536, r.push(l >>> 10 & 1023 | 55296), l = 56320 | 1023 & l), r.push(l), o += p;
            } return function (e) { var t = e.length; if (t <= 4096)
                return String.fromCharCode.apply(String, e); for (var n = "", r = 0; r < t;)
                n += String.fromCharCode.apply(String, e.slice(r, r += 4096)); return n; }(r); } function je(e, t, n) { var r = ""; n = Math.min(e.length, n); for (var o = t; o < n; ++o)
                r += String.fromCharCode(127 & e[o]); return r; } function Be(e, t, n) { var r = ""; n = Math.min(e.length, n); for (var o = t; o < n; ++o)
                r += String.fromCharCode(e[o]); return r; } function Le(e, t, n) { var r = e.length; (!t || t < 0) && (t = 0), (!n || n < 0 || n > r) && (n = r); for (var o = "", i = t; i < n; ++i)
                o += Je(e[i]); return o; } function qe(e, t, n) { for (var r = e.slice(t, n), o = "", i = 0; i < r.length; i += 2)
                o += String.fromCharCode(r[i] + 256 * r[i + 1]); return o; } function $e(e, t, n) { if (e % 1 != 0 || e < 0)
                throw new RangeError("offset is not uint"); if (e + t > n)
                throw new RangeError("Trying to access beyond buffer length"); } function Ue(e, t, n, r, o, i) { if (!we(e))
                throw new TypeError('"buffer" argument must be a Buffer instance'); if (t > o || t < i)
                throw new RangeError('"value" argument is out of bounds'); if (n + r > e.length)
                throw new RangeError("Index out of range"); } function Ve(e, t, n, r) { t < 0 && (t = 65535 + t + 1); for (var o = 0, i = Math.min(e.length - n, 2); o < i; ++o)
                e[n + o] = (t & 255 << 8 * (r ? o : 1 - o)) >>> 8 * (r ? o : 1 - o); } function We(e, t, n, r) { t < 0 && (t = 4294967295 + t + 1); for (var o = 0, i = Math.min(e.length - n, 4); o < i; ++o)
                e[n + o] = t >>> 8 * (r ? o : 3 - o) & 255; } function Ke(e, t, n, r, o, i) { if (n + r > e.length)
                throw new RangeError("Index out of range"); if (n < 0)
                throw new RangeError("Index out of range"); } function ze(e, t, n, r, o) { return o || Ke(e, 0, n, 4), fe(e, t, n, r, 23, 4), n + 4; } function He(e, t, n, r, o) { return o || Ke(e, 0, n, 8), fe(e, t, n, r, 52, 8), n + 8; } ye.TYPED_ARRAY_SUPPORT = void 0 === re.TYPED_ARRAY_SUPPORT || re.TYPED_ARRAY_SUPPORT, ye.poolSize = 8192, ye._augment = function (e) { return e.__proto__ = ye.prototype, e; }, ye.from = function (e, t, n) { return ve(null, e, t, n); }, ye.TYPED_ARRAY_SUPPORT && (ye.prototype.__proto__ = Uint8Array.prototype, ye.__proto__ = Uint8Array), ye.alloc = function (e, t, n) { return r = null, i = t, s = n, be(o = e), o <= 0 ? ge(r, o) : void 0 !== i ? "string" == typeof s ? ge(r, o).fill(i, s) : ge(r, o).fill(i) : ge(r, o); var r, o, i, s; }, ye.allocUnsafe = function (e) { return De(null, e); }, ye.allocUnsafeSlow = function (e) { return De(null, e); }, ye.isBuffer = function (e) { return null != e && (!!e._isBuffer || Ze(e) || "function" == typeof (t = e).readFloatLE && "function" == typeof t.slice && Ze(t.slice(0, 0))); var t; }, ye.compare = function (e, t) { if (!we(e) || !we(t))
                throw new TypeError("Arguments must be Buffers"); if (e === t)
                return 0; for (var n = e.length, r = t.length, o = 0, i = Math.min(n, r); o < i; ++o)
                if (e[o] !== t[o]) {
                    n = e[o], r = t[o];
                    break;
                } return n < r ? -1 : r < n ? 1 : 0; }, ye.isEncoding = function (e) { switch (String(e).toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le": return !0;
                default: return !1;
            } }, ye.concat = function (e, t) { if (!he(e))
                throw new TypeError('"list" argument must be an Array of Buffers'); if (0 === e.length)
                return ye.alloc(0); var n; if (void 0 === t)
                for (t = 0, n = 0; n < e.length; ++n)
                    t += e[n].length; var r = ye.allocUnsafe(t), o = 0; for (n = 0; n < e.length; ++n) {
                var i = e[n];
                if (!we(i))
                    throw new TypeError('"list" argument must be an Array of Buffers');
                i.copy(r, o), o += i.length;
            } return r; }, ye.byteLength = Ae, ye.prototype._isBuffer = !0, ye.prototype.swap16 = function () { var e = this.length; if (e % 2 != 0)
                throw new RangeError("Buffer size must be a multiple of 16-bits"); for (var t = 0; t < e; t += 2)
                xe(this, t, t + 1); return this; }, ye.prototype.swap32 = function () { var e = this.length; if (e % 4 != 0)
                throw new RangeError("Buffer size must be a multiple of 32-bits"); for (var t = 0; t < e; t += 4)
                xe(this, t, t + 3), xe(this, t + 1, t + 2); return this; }, ye.prototype.swap64 = function () { var e = this.length; if (e % 8 != 0)
                throw new RangeError("Buffer size must be a multiple of 64-bits"); for (var t = 0; t < e; t += 8)
                xe(this, t, t + 7), xe(this, t + 1, t + 6), xe(this, t + 2, t + 5), xe(this, t + 3, t + 4); return this; }, ye.prototype.toString = function () { var e = 0 | this.length; return 0 === e ? "" : 0 === arguments.length ? Ie(this, 0, e) : Se.apply(this, arguments); }, ye.prototype.equals = function (e) { if (!we(e))
                throw new TypeError("Argument must be a Buffer"); return this === e || 0 === ye.compare(this, e); }, ye.prototype.inspect = function () { var e = ""; return this.length > 0 && (e = this.toString("hex", 0, 50).match(/.{2}/g).join(" "), this.length > 50 && (e += " ... ")), "<Buffer " + e + ">"; }, ye.prototype.compare = function (e, t, n, r, o) { if (!we(e))
                throw new TypeError("Argument must be a Buffer"); if (void 0 === t && (t = 0), void 0 === n && (n = e ? e.length : 0), void 0 === r && (r = 0), void 0 === o && (o = this.length), t < 0 || n > e.length || r < 0 || o > this.length)
                throw new RangeError("out of range index"); if (r >= o && t >= n)
                return 0; if (r >= o)
                return -1; if (t >= n)
                return 1; if (this === e)
                return 0; for (var i = (o >>>= 0) - (r >>>= 0), s = (n >>>= 0) - (t >>>= 0), a = Math.min(i, s), u = this.slice(r, o), c = e.slice(t, n), l = 0; l < a; ++l)
                if (u[l] !== c[l]) {
                    i = u[l], s = c[l];
                    break;
                } return i < s ? -1 : s < i ? 1 : 0; }, ye.prototype.includes = function (e, t, n) { return -1 !== this.indexOf(e, t, n); }, ye.prototype.indexOf = function (e, t, n) { return Te(this, e, t, n, !0); }, ye.prototype.lastIndexOf = function (e, t, n) { return Te(this, e, t, n, !1); }, ye.prototype.write = function (e, t, n, r) { if (void 0 === t)
                r = "utf8", n = this.length, t = 0;
            else if (void 0 === n && "string" == typeof t)
                r = t, n = this.length, t = 0;
            else {
                if (!isFinite(t))
                    throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                t |= 0, isFinite(n) ? (n |= 0, void 0 === r && (r = "utf8")) : (r = n, n = void 0);
            } var o = this.length - t; if ((void 0 === n || n > o) && (n = o), e.length > 0 && (n < 0 || t < 0) || t > this.length)
                throw new RangeError("Attempt to write outside buffer bounds"); r || (r = "utf8"); for (var i = !1;;)
                switch (r) {
                    case "hex": return Fe(this, e, t, n);
                    case "utf8":
                    case "utf-8": return Oe(this, e, t, n);
                    case "ascii": return _e(this, e, t, n);
                    case "latin1":
                    case "binary": return Ne(this, e, t, n);
                    case "base64": return Pe(this, e, t, n);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le": return Me(this, e, t, n);
                    default:
                        if (i)
                            throw new TypeError("Unknown encoding: " + r);
                        r = ("" + r).toLowerCase(), i = !0;
                } }, ye.prototype.toJSON = function () { return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) }; }, ye.prototype.slice = function (e, t) { var n, r = this.length; if ((e = ~~e) < 0 ? (e += r) < 0 && (e = 0) : e > r && (e = r), (t = void 0 === t ? r : ~~t) < 0 ? (t += r) < 0 && (t = 0) : t > r && (t = r), t < e && (t = e), ye.TYPED_ARRAY_SUPPORT)
                (n = this.subarray(e, t)).__proto__ = ye.prototype;
            else {
                var o = t - e;
                n = new ye(o, void 0);
                for (var i = 0; i < o; ++i)
                    n[i] = this[i + e];
            } return n; }, ye.prototype.readUIntLE = function (e, t, n) { e |= 0, t |= 0, n || $e(e, t, this.length); for (var r = this[e], o = 1, i = 0; ++i < t && (o *= 256);)
                r += this[e + i] * o; return r; }, ye.prototype.readUIntBE = function (e, t, n) { e |= 0, t |= 0, n || $e(e, t, this.length); for (var r = this[e + --t], o = 1; t > 0 && (o *= 256);)
                r += this[e + --t] * o; return r; }, ye.prototype.readUInt8 = function (e, t) { return t || $e(e, 1, this.length), this[e]; }, ye.prototype.readUInt16LE = function (e, t) { return t || $e(e, 2, this.length), this[e] | this[e + 1] << 8; }, ye.prototype.readUInt16BE = function (e, t) { return t || $e(e, 2, this.length), this[e] << 8 | this[e + 1]; }, ye.prototype.readUInt32LE = function (e, t) { return t || $e(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + 16777216 * this[e + 3]; }, ye.prototype.readUInt32BE = function (e, t) { return t || $e(e, 4, this.length), 16777216 * this[e] + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]); }, ye.prototype.readIntLE = function (e, t, n) { e |= 0, t |= 0, n || $e(e, t, this.length); for (var r = this[e], o = 1, i = 0; ++i < t && (o *= 256);)
                r += this[e + i] * o; return r >= (o *= 128) && (r -= Math.pow(2, 8 * t)), r; }, ye.prototype.readIntBE = function (e, t, n) { e |= 0, t |= 0, n || $e(e, t, this.length); for (var r = t, o = 1, i = this[e + --r]; r > 0 && (o *= 256);)
                i += this[e + --r] * o; return i >= (o *= 128) && (i -= Math.pow(2, 8 * t)), i; }, ye.prototype.readInt8 = function (e, t) { return t || $e(e, 1, this.length), 128 & this[e] ? -1 * (255 - this[e] + 1) : this[e]; }, ye.prototype.readInt16LE = function (e, t) { t || $e(e, 2, this.length); var n = this[e] | this[e + 1] << 8; return 32768 & n ? 4294901760 | n : n; }, ye.prototype.readInt16BE = function (e, t) { t || $e(e, 2, this.length); var n = this[e + 1] | this[e] << 8; return 32768 & n ? 4294901760 | n : n; }, ye.prototype.readInt32LE = function (e, t) { return t || $e(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24; }, ye.prototype.readInt32BE = function (e, t) { return t || $e(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]; }, ye.prototype.readFloatLE = function (e, t) { return t || $e(e, 4, this.length), pe(this, e, !0, 23, 4); }, ye.prototype.readFloatBE = function (e, t) { return t || $e(e, 4, this.length), pe(this, e, !1, 23, 4); }, ye.prototype.readDoubleLE = function (e, t) { return t || $e(e, 8, this.length), pe(this, e, !0, 52, 8); }, ye.prototype.readDoubleBE = function (e, t) { return t || $e(e, 8, this.length), pe(this, e, !1, 52, 8); }, ye.prototype.writeUIntLE = function (e, t, n, r) { e = +e, t |= 0, n |= 0, r || Ue(this, e, t, n, Math.pow(2, 8 * n) - 1, 0); var o = 1, i = 0; for (this[t] = 255 & e; ++i < n && (o *= 256);)
                this[t + i] = e / o & 255; return t + n; }, ye.prototype.writeUIntBE = function (e, t, n, r) { e = +e, t |= 0, n |= 0, r || Ue(this, e, t, n, Math.pow(2, 8 * n) - 1, 0); var o = n - 1, i = 1; for (this[t + o] = 255 & e; --o >= 0 && (i *= 256);)
                this[t + o] = e / i & 255; return t + n; }, ye.prototype.writeUInt8 = function (e, t, n) { return e = +e, t |= 0, n || Ue(this, e, t, 1, 255, 0), ye.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), this[t] = 255 & e, t + 1; }, ye.prototype.writeUInt16LE = function (e, t, n) { return e = +e, t |= 0, n || Ue(this, e, t, 2, 65535, 0), ye.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8) : Ve(this, e, t, !0), t + 2; }, ye.prototype.writeUInt16BE = function (e, t, n) { return e = +e, t |= 0, n || Ue(this, e, t, 2, 65535, 0), ye.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8, this[t + 1] = 255 & e) : Ve(this, e, t, !1), t + 2; }, ye.prototype.writeUInt32LE = function (e, t, n) { return e = +e, t |= 0, n || Ue(this, e, t, 4, 4294967295, 0), ye.TYPED_ARRAY_SUPPORT ? (this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = 255 & e) : We(this, e, t, !0), t + 4; }, ye.prototype.writeUInt32BE = function (e, t, n) { return e = +e, t |= 0, n || Ue(this, e, t, 4, 4294967295, 0), ye.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e) : We(this, e, t, !1), t + 4; }, ye.prototype.writeIntLE = function (e, t, n, r) { if (e = +e, t |= 0, !r) {
                var o = Math.pow(2, 8 * n - 1);
                Ue(this, e, t, n, o - 1, -o);
            } var i = 0, s = 1, a = 0; for (this[t] = 255 & e; ++i < n && (s *= 256);)
                e < 0 && 0 === a && 0 !== this[t + i - 1] && (a = 1), this[t + i] = (e / s >> 0) - a & 255; return t + n; }, ye.prototype.writeIntBE = function (e, t, n, r) { if (e = +e, t |= 0, !r) {
                var o = Math.pow(2, 8 * n - 1);
                Ue(this, e, t, n, o - 1, -o);
            } var i = n - 1, s = 1, a = 0; for (this[t + i] = 255 & e; --i >= 0 && (s *= 256);)
                e < 0 && 0 === a && 0 !== this[t + i + 1] && (a = 1), this[t + i] = (e / s >> 0) - a & 255; return t + n; }, ye.prototype.writeInt8 = function (e, t, n) { return e = +e, t |= 0, n || Ue(this, e, t, 1, 127, -128), ye.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), e < 0 && (e = 255 + e + 1), this[t] = 255 & e, t + 1; }, ye.prototype.writeInt16LE = function (e, t, n) { return e = +e, t |= 0, n || Ue(this, e, t, 2, 32767, -32768), ye.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8) : Ve(this, e, t, !0), t + 2; }, ye.prototype.writeInt16BE = function (e, t, n) { return e = +e, t |= 0, n || Ue(this, e, t, 2, 32767, -32768), ye.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8, this[t + 1] = 255 & e) : Ve(this, e, t, !1), t + 2; }, ye.prototype.writeInt32LE = function (e, t, n) { return e = +e, t |= 0, n || Ue(this, e, t, 4, 2147483647, -2147483648), ye.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24) : We(this, e, t, !0), t + 4; }, ye.prototype.writeInt32BE = function (e, t, n) { return e = +e, t |= 0, n || Ue(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), ye.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e) : We(this, e, t, !1), t + 4; }, ye.prototype.writeFloatLE = function (e, t, n) { return ze(this, e, t, !0, n); }, ye.prototype.writeFloatBE = function (e, t, n) { return ze(this, e, t, !1, n); }, ye.prototype.writeDoubleLE = function (e, t, n) { return He(this, e, t, !0, n); }, ye.prototype.writeDoubleBE = function (e, t, n) { return He(this, e, t, !1, n); }, ye.prototype.copy = function (e, t, n, r) { if (n || (n = 0), r || 0 === r || (r = this.length), t >= e.length && (t = e.length), t || (t = 0), r > 0 && r < n && (r = n), r === n)
                return 0; if (0 === e.length || 0 === this.length)
                return 0; if (t < 0)
                throw new RangeError("targetStart out of bounds"); if (n < 0 || n >= this.length)
                throw new RangeError("sourceStart out of bounds"); if (r < 0)
                throw new RangeError("sourceEnd out of bounds"); r > this.length && (r = this.length), e.length - t < r - n && (r = e.length - t + n); var o, i = r - n; if (this === e && n < t && t < r)
                for (o = i - 1; o >= 0; --o)
                    e[o + t] = this[o + n];
            else if (i < 1e3 || !ye.TYPED_ARRAY_SUPPORT)
                for (o = 0; o < i; ++o)
                    e[o + t] = this[o + n];
            else
                Uint8Array.prototype.set.call(e, this.subarray(n, n + i), t); return i; }, ye.prototype.fill = function (e, t, n, r) { if ("string" == typeof e) {
                if ("string" == typeof t ? (r = t, t = 0, n = this.length) : "string" == typeof n && (r = n, n = this.length), 1 === e.length) {
                    var o = e.charCodeAt(0);
                    o < 256 && (e = o);
                }
                if (void 0 !== r && "string" != typeof r)
                    throw new TypeError("encoding must be a string");
                if ("string" == typeof r && !ye.isEncoding(r))
                    throw new TypeError("Unknown encoding: " + r);
            }
            else
                "number" == typeof e && (e &= 255); if (t < 0 || this.length < t || this.length < n)
                throw new RangeError("Out of range index"); if (n <= t)
                return this; var i; if (t >>>= 0, n = void 0 === n ? this.length : n >>> 0, e || (e = 0), "number" == typeof e)
                for (i = t; i < n; ++i)
                    this[i] = e;
            else {
                var s = we(e) ? e : Ge(new ye(e, r).toString()), a = s.length;
                for (i = 0; i < n - t; ++i)
                    this[i + t] = s[i % a];
            } return this; }; var Ye = /[^+\/0-9A-Za-z-_]/g; function Je(e) { return e < 16 ? "0" + e.toString(16) : e.toString(16); } function Ge(e, t) { var n; t = t || 1 / 0; for (var r = e.length, o = null, i = [], s = 0; s < r; ++s) {
                if ((n = e.charCodeAt(s)) > 55295 && n < 57344) {
                    if (!o) {
                        if (n > 56319) {
                            (t -= 3) > -1 && i.push(239, 191, 189);
                            continue;
                        }
                        if (s + 1 === r) {
                            (t -= 3) > -1 && i.push(239, 191, 189);
                            continue;
                        }
                        o = n;
                        continue;
                    }
                    if (n < 56320) {
                        (t -= 3) > -1 && i.push(239, 191, 189), o = n;
                        continue;
                    }
                    n = 65536 + (o - 55296 << 10 | n - 56320);
                }
                else
                    o && (t -= 3) > -1 && i.push(239, 191, 189);
                if (o = null, n < 128) {
                    if ((t -= 1) < 0)
                        break;
                    i.push(n);
                }
                else if (n < 2048) {
                    if ((t -= 2) < 0)
                        break;
                    i.push(n >> 6 | 192, 63 & n | 128);
                }
                else if (n < 65536) {
                    if ((t -= 3) < 0)
                        break;
                    i.push(n >> 12 | 224, n >> 6 & 63 | 128, 63 & n | 128);
                }
                else {
                    if (!(n < 1114112))
                        throw new Error("Invalid code point");
                    if ((t -= 4) < 0)
                        break;
                    i.push(n >> 18 | 240, n >> 12 & 63 | 128, n >> 6 & 63 | 128, 63 & n | 128);
                }
            } return i; } function Xe(e) { return function (e) { var t, n, r, o, i, s; ae || ue(); var a = e.length; if (a % 4 > 0)
                throw new Error("Invalid string. Length must be a multiple of 4"); i = "=" === e[a - 2] ? 2 : "=" === e[a - 1] ? 1 : 0, s = new se(3 * a / 4 - i), r = i > 0 ? a - 4 : a; var u = 0; for (t = 0, n = 0; t < r; t += 4, n += 3)
                o = ie[e.charCodeAt(t)] << 18 | ie[e.charCodeAt(t + 1)] << 12 | ie[e.charCodeAt(t + 2)] << 6 | ie[e.charCodeAt(t + 3)], s[u++] = o >> 16 & 255, s[u++] = o >> 8 & 255, s[u++] = 255 & o; return 2 === i ? (o = ie[e.charCodeAt(t)] << 2 | ie[e.charCodeAt(t + 1)] >> 4, s[u++] = 255 & o) : 1 === i && (o = ie[e.charCodeAt(t)] << 10 | ie[e.charCodeAt(t + 1)] << 4 | ie[e.charCodeAt(t + 2)] >> 2, s[u++] = o >> 8 & 255, s[u++] = 255 & o), s; }(function (e) { if ((e = (t = e, t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "")).replace(Ye, "")).length < 2)
                return ""; for (var t; e.length % 4 != 0;)
                e += "="; return e; }(e)); } function Qe(e, t, n, r) { for (var o = 0; o < r && !(o + n >= t.length || o >= e.length); ++o)
                t[o + n] = e[o]; return o; } function Ze(e) { return !!e.constructor && "function" == typeof e.constructor.isBuffer && e.constructor.isBuffer(e); } var et = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0; var n = { identify: e => e instanceof Uint8Array, default: !1, tag: "tag:yaml.org,2002:binary", resolve: (e, t) => { {
                    const n = (0, Z.resolveString)(e, t);
                    return ye.from(n, "base64");
                } }, options: z.binaryOptions, stringify: ({ comment: e, type: t, value: n }, r, o, i) => { let s; if (s = n instanceof ye ? n.toString("base64") : ye.from(n.buffer).toString("base64"), t || (t = z.binaryOptions.defaultType), t === d.Type.QUOTE_DOUBLE)
                    n = s;
                else {
                    const { lineWidth: e } = z.binaryOptions, r = Math.ceil(s.length / e), o = new Array(r);
                    for (let t = 0, n = 0; t < r; ++t, n += e)
                        o[t] = s.substr(n, e);
                    n = o.join(t === d.Type.BLOCK_LITERAL ? "\n" : " ");
                } return (0, H.stringifyString)({ comment: e, type: t, value: n }, r, o, i); } }; t.default = n; })); r(et); var tt = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.parsePairs = a, t.createPairs = u, t.default = void 0; var n = s(L), r = s(I), o = s(X), i = s(q); function s(e) { return e && e.__esModule ? e : { default: e }; } function a(e, t) { const i = (0, o.default)(e, t); for (let e = 0; e < i.items.length; ++e) {
                let o = i.items[e];
                if (!(o instanceof r.default)) {
                    if (o instanceof n.default) {
                        if (o.items.length > 1) {
                            const e = "Each pair must have its own sequence indicator";
                            throw new y.YAMLSemanticError(t, e);
                        }
                        const e = o.items[0] || new r.default;
                        o.commentBefore && (e.commentBefore = e.commentBefore ? "".concat(o.commentBefore, "\n").concat(e.commentBefore) : o.commentBefore), o.comment && (e.comment = e.comment ? "".concat(o.comment, "\n").concat(e.comment) : o.comment), o = e;
                    }
                    i.items[e] = o instanceof r.default ? o : new r.default(o);
                }
            } return i; } function u(e, t, n) { const r = new i.default(e); r.tag = "tag:yaml.org,2002:pairs"; for (const o of t) {
                let t, i;
                if (Array.isArray(o)) {
                    if (2 !== o.length)
                        throw new TypeError("Expected [key, value] tuple: ".concat(o));
                    t = o[0], i = o[1];
                }
                else if (o && o instanceof Object) {
                    const e = Object.keys(o);
                    if (1 !== e.length)
                        throw new TypeError("Expected { key: value } tuple: ".concat(o));
                    t = e[0], i = o[t];
                }
                else
                    t = o;
                const s = e.createPair(t, i, n);
                r.items.push(s);
            } return r; } var c = { default: !1, tag: "tag:yaml.org,2002:pairs", resolve: a, createNode: u }; t.default = c; })); r(tt), tt.parsePairs, tt.createPairs; var nt = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = t.YAMLOMap = void 0; var n = a(P), r = a(L), o = a(I), i = a(R), s = a(q); function a(e) { return e && e.__esModule ? e : { default: e }; } function u(e, t, n) { return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e; } class c extends s.default {
                constructor() { super(), u(this, "add", r.default.prototype.add.bind(this)), u(this, "delete", r.default.prototype.delete.bind(this)), u(this, "get", r.default.prototype.get.bind(this)), u(this, "has", r.default.prototype.has.bind(this)), u(this, "set", r.default.prototype.set.bind(this)), this.tag = c.tag; }
                toJSON(e, t) { const r = new Map; t && t.onCreate && t.onCreate(r); for (const e of this.items) {
                    let i, s;
                    if (e instanceof o.default ? (i = (0, n.default)(e.key, "", t), s = (0, n.default)(e.value, i, t)) : i = (0, n.default)(e, "", t), r.has(i))
                        throw new Error("Ordered maps must not include duplicate keys");
                    r.set(i, s);
                } return r; }
            } t.YAMLOMap = c, u(c, "tag", "tag:yaml.org,2002:omap"); var l = { identify: e => e instanceof Map, nodeClass: c, default: !1, tag: "tag:yaml.org,2002:omap", resolve: function (e, t) { const n = (0, tt.parsePairs)(e, t), r = []; for (const { key: e } of n.items)
                    if (e instanceof i.default) {
                        if (r.includes(e.value)) {
                            const e = "Ordered maps must not include duplicate keys";
                            throw new y.YAMLSemanticError(t, e);
                        }
                        r.push(e.value);
                    } return Object.assign(new c, n); }, createNode: function (e, t, n) { const r = (0, tt.createPairs)(e, t, n), o = new c; return o.items = r.items, o; } }; t.default = l; })); r(nt), nt.YAMLOMap; var rt = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = t.YAMLSet = void 0; var n, r, o = function (e) { if (e && e.__esModule)
                return e; if (null === e || "object" != typeof e && "function" != typeof e)
                return { default: e }; var t = c(); if (t && t.has(e))
                return t.get(e); var n = {}, r = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var i = r ? Object.getOwnPropertyDescriptor(e, o) : null;
                    i && (i.get || i.set) ? Object.defineProperty(n, o, i) : n[o] = e[o];
                } return n.default = e, t && t.set(e, n), n; }(L), i = u(I), s = u(J), a = u(R); function u(e) { return e && e.__esModule ? e : { default: e }; } function c() { if ("function" != typeof WeakMap)
                return null; var e = new WeakMap; return c = function () { return e; }, e; } class l extends o.default {
                constructor() { super(), this.tag = l.tag; }
                add(e) { const t = e instanceof i.default ? e : new i.default(e); (0, o.findPair)(this.items, t.key) || this.items.push(t); }
                get(e, t) { const n = (0, o.findPair)(this.items, e); return !t && n instanceof i.default ? n.key instanceof a.default ? n.key.value : n.key : n; }
                set(e, t) { if ("boolean" != typeof t)
                    throw new Error("Expected boolean value for set(key, value) in a YAML set, not ".concat(typeof t)); const n = (0, o.findPair)(this.items, e); n && !t ? this.items.splice(this.items.indexOf(n), 1) : !n && t && this.items.push(new i.default(e)); }
                toJSON(e, t) { return super.toJSON(e, t, Set); }
                toString(e, t, n) { if (!e)
                    return JSON.stringify(this); if (this.hasAllNullValues())
                    return super.toString(e, t, n); throw new Error("Set items must all have null values"); }
            } t.YAMLSet = l, r = "tag:yaml.org,2002:set", "tag" in (n = l) ? Object.defineProperty(n, "tag", { value: r, enumerable: !0, configurable: !0, writable: !0 }) : n.tag = r; var p = { identify: e => e instanceof Set, nodeClass: l, default: !1, tag: "tag:yaml.org,2002:set", resolve: function (e, t) { const n = (0, s.default)(e, t); if (!n.hasAllNullValues())
                    throw new y.YAMLSemanticError(t, "Set items must all have null values"); return Object.assign(new l, n); }, createNode: function (e, t, n) { const r = new l; for (const o of t)
                    r.items.push(e.createPair(o, null, n)); return r; } }; t.default = p; })); r(rt), rt.YAMLSet; var ot = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.timestamp = t.floatTime = t.intTime = void 0; const n = (e, t) => { const n = t.split(":").reduce(((e, t) => 60 * e + Number(t)), 0); return "-" === e ? -n : n; }, r = ({ value: e }) => { if (isNaN(e) || !isFinite(e))
                return (0, H.stringifyNumber)(e); let t = ""; e < 0 && (t = "-", e = Math.abs(e)); const n = [e % 60]; return e < 60 ? n.unshift(0) : (e = Math.round((e - n[0]) / 60), n.unshift(e % 60), e >= 60 && (e = Math.round((e - n[0]) / 60), n.unshift(e))), t + n.map((e => e < 10 ? "0" + String(e) : String(e))).join(":").replace(/000000\d*$/, ""); }, o = { identify: e => "number" == typeof e, default: !0, tag: "tag:yaml.org,2002:int", format: "TIME", test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/, resolve: (e, t, r) => n(t, r.replace(/_/g, "")), stringify: r }; t.intTime = o; const i = { identify: e => "number" == typeof e, default: !0, tag: "tag:yaml.org,2002:float", format: "TIME", test: /^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*)$/, resolve: (e, t, r) => n(t, r.replace(/_/g, "")), stringify: r }; t.floatTime = i; const s = { identify: e => e instanceof Date, default: !0, tag: "tag:yaml.org,2002:timestamp", test: RegExp("^(?:([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?)$"), resolve: (e, t, r, o, i, s, a, u, c) => { u && (u = (u + "00").substr(1, 3)); let l = Date.UTC(t, r - 1, o, i || 0, s || 0, a || 0, u || 0); if (c && "Z" !== c) {
                    let e = n(c[0], c.slice(1));
                    Math.abs(e) < 30 && (e *= 60), l -= 6e4 * e;
                } return new Date(l); }, stringify: ({ value: e }) => e.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "") }; t.timestamp = s; })); r(ot), ot.timestamp, ot.floatTime, ot.intTime; var it = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0; var n = u(R), r = u(ee), o = u(et), i = u(nt), s = u(tt), a = u(rt); function u(e) { return e && e.__esModule ? e : { default: e }; } const c = ({ value: e }) => e ? z.boolOptions.trueStr : z.boolOptions.falseStr; var l = r.default.concat([{ identify: e => null == e, createNode: (e, t, r) => r.wrapScalars ? new n.default(null) : null, default: !0, tag: "tag:yaml.org,2002:null", test: /^(?:~|[Nn]ull|NULL)?$/, resolve: () => null, options: z.nullOptions, stringify: () => z.nullOptions.nullStr }, { identify: e => "boolean" == typeof e, default: !0, tag: "tag:yaml.org,2002:bool", test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/, resolve: () => !0, options: z.boolOptions, stringify: c }, { identify: e => "boolean" == typeof e, default: !0, tag: "tag:yaml.org,2002:bool", test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i, resolve: () => !1, options: z.boolOptions, stringify: c }, { identify: e => "number" == typeof e, default: !0, tag: "tag:yaml.org,2002:int", format: "BIN", test: /^0b([0-1_]+)$/, resolve: (e, t) => parseInt(t.replace(/_/g, ""), 2), stringify: ({ value: e }) => "0b" + e.toString(2) }, { identify: e => "number" == typeof e, default: !0, tag: "tag:yaml.org,2002:int", format: "OCT", test: /^[-+]?0([0-7_]+)$/, resolve: (e, t) => parseInt(t.replace(/_/g, ""), 8), stringify: ({ value: e }) => (e < 0 ? "-0" : "0") + e.toString(8) }, { identify: e => "number" == typeof e, default: !0, tag: "tag:yaml.org,2002:int", test: /^[-+]?[0-9][0-9_]*$/, resolve: e => parseInt(e.replace(/_/g, ""), 10), stringify: H.stringifyNumber }, { identify: e => "number" == typeof e, default: !0, tag: "tag:yaml.org,2002:int", format: "HEX", test: /^0x([0-9a-fA-F_]+)$/, resolve: (e, t) => parseInt(t.replace(/_/g, ""), 16), stringify: ({ value: e }) => (e < 0 ? "-0x" : "0x") + e.toString(16) }, { identify: e => "number" == typeof e, default: !0, tag: "tag:yaml.org,2002:float", test: /^(?:[-+]?\.inf|(\.nan))$/i, resolve: (e, t) => t ? NaN : "-" === e[0] ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, stringify: H.stringifyNumber }, { identify: e => "number" == typeof e, default: !0, tag: "tag:yaml.org,2002:float", format: "EXP", test: /^[-+]?([0-9][0-9_]*)?(\.[0-9_]*)?[eE][-+]?[0-9]+$/, resolve: e => parseFloat(e.replace(/_/g, "")), stringify: ({ value: e }) => Number(e).toExponential() }, { identify: e => "number" == typeof e, default: !0, tag: "tag:yaml.org,2002:float", test: /^[-+]?(?:[0-9][0-9_]*)?\.([0-9_]*)$/, resolve(e, t) { const r = new n.default(parseFloat(e.replace(/_/g, ""))); if (t) {
                        const e = t.replace(/_/g, "");
                        "0" === e[e.length - 1] && (r.minFractionDigits = e.length);
                    } return r; }, stringify: H.stringifyNumber }], o.default, i.default, s.default, a.default, ot.intTime, ot.floatTime, ot.timestamp); t.default = l; })); r(it); var st = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.tags = t.schemas = void 0; var n = function (e) { if (e && e.__esModule)
                return e; if (null === e || "object" != typeof e && "function" != typeof e)
                return { default: e }; var t = d(); if (t && t.has(e))
                return t.get(e); var n = {}, r = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var i = r ? Object.getOwnPropertyDescriptor(e, o) : null;
                    i && (i.get || i.set) ? Object.defineProperty(n, o, i) : n[o] = e[o];
                } return n.default = e, t && t.set(e, n), n; }(te), r = f(ee), o = f(ne), i = f(it), s = f(G), a = f(Q), u = f(et), c = f(nt), l = f(tt), p = f(rt); function f(e) { return e && e.__esModule ? e : { default: e }; } function d() { if ("function" != typeof WeakMap)
                return null; var e = new WeakMap; return d = function () { return e; }, e; } const h = { core: n.default, failsafe: r.default, json: o.default, yaml11: i.default }; t.schemas = h; const m = { binary: u.default, bool: n.boolObj, float: n.floatObj, floatExp: n.expObj, floatNaN: n.nanObj, floatTime: ot.floatTime, int: n.intObj, intHex: n.hexObj, intOct: n.octObj, intTime: ot.intTime, map: s.default, null: n.nullObj, omap: c.default, pairs: l.default, seq: a.default, set: p.default, timestamp: ot.timestamp }; t.tags = m; })); r(st), st.tags, st.schemas; var at = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0; var n = a(B), r = a(j), o = a(M), i = a(I), s = a(R); function a(e) { return e && e.__esModule ? e : { default: e }; } function u(e, t, n) { return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e; } class c {
                constructor({ customTags: e, merge: t, schema: n, sortMapEntries: r, tags: o }) { if (this.merge = !!t, this.name = n, this.sortMapEntries = !0 === r ? (e, t) => e.key < t.key ? -1 : e.key > t.key ? 1 : 0 : r || null, this.tags = st.schemas[n.replace(/\W/g, "")], !this.tags) {
                    const e = Object.keys(st.schemas).map((e => JSON.stringify(e))).join(", ");
                    throw new Error('Unknown schema "'.concat(n, '"; use one of ').concat(e));
                } if (!e && o && (e = o, (0, W.warnOptionDeprecation)("tags", "customTags")), Array.isArray(e))
                    for (const t of e)
                        this.tags = this.tags.concat(t);
                else
                    "function" == typeof e && (this.tags = e(this.tags.slice())); for (let e = 0; e < this.tags.length; ++e) {
                    const t = this.tags[e];
                    if ("string" == typeof t) {
                        const n = st.tags[t];
                        if (!n) {
                            const e = Object.keys(st.tags).map((e => JSON.stringify(e))).join(", ");
                            throw new Error('Unknown custom tag "'.concat(t, '"; use one of ').concat(e));
                        }
                        this.tags[e] = n;
                    }
                } }
                createNode(e, t, r, i) { if (e instanceof o.default)
                    return e; let a; if (r) {
                    r.startsWith("!!") && (r = c.defaultPrefix + r.slice(2));
                    const e = this.tags.filter((e => e.tag === r));
                    if (a = e.find((e => !e.format)) || e[0], !a)
                        throw new Error("Tag ".concat(r, " not found"));
                }
                else if (a = this.tags.find((t => (t.identify && t.identify(e) || t.class && e instanceof t.class) && !t.format)), !a) {
                    if ("function" == typeof e.toJSON && (e = e.toJSON()), "object" != typeof e)
                        return t ? new s.default(e) : e;
                    a = e instanceof Map ? st.tags.map : e[Symbol.iterator] ? st.tags.seq : st.tags.map;
                } i ? i.wrapScalars = t : i = { wrapScalars: t }, i.onTagObj && (i.onTagObj(a), delete i.onTagObj); const u = {}; if (e && "object" == typeof e && i.prevObjects) {
                    const t = i.prevObjects.get(e);
                    if (t) {
                        const e = new n.default(t);
                        return i.aliasNodes.push(e), e;
                    }
                    u.value = e, i.prevObjects.set(e, u);
                } return u.node = a.createNode ? a.createNode(this, e, i) : t ? new s.default(e) : e, r && u.node instanceof o.default && (u.node.tag = r), u.node; }
                createPair(e, t, n) { const r = this.createNode(e, n.wrapScalars, null, n), o = this.createNode(t, n.wrapScalars, null, n); return new i.default(r, o); }
                resolveScalar(e, t) { t || (t = this.tags); for (let n = 0; n < t.length; ++n) {
                    const { format: r, test: o, resolve: i } = t[n];
                    if (o) {
                        const t = e.match(o);
                        if (t) {
                            let e = i.apply(null, t);
                            return e instanceof s.default || (e = new s.default(e)), r && (e.format = r), e;
                        }
                    }
                } return this.tags.scalarFallback && (e = this.tags.scalarFallback(e)), new s.default(e); }
                resolveNode(e, t, n) { const o = this.tags.filter((({ tag: e }) => e === n)), i = o.find((({ test: e }) => !e)); t.error && e.errors.push(t.error); try {
                    if (i) {
                        let n = i.resolve(e, t);
                        n instanceof r.default || (n = new s.default(n)), t.resolved = n;
                    }
                    else {
                        const n = (0, Z.resolveString)(e, t);
                        "string" == typeof n && o.length > 0 && (t.resolved = this.resolveScalar(n, o));
                    }
                }
                catch (n) {
                    n.source || (n.source = t), e.errors.push(n), t.resolved = null;
                } return t.resolved ? (n && t.tag && (t.resolved.tag = n), t.resolved) : null; }
                resolveNodeWithFallback(e, t, n) { const r = this.resolveNode(e, t, n); if (Object.prototype.hasOwnProperty.call(t, "resolved"))
                    return r; const o = (({ type: e }) => e === d.Type.FLOW_MAP || e === d.Type.MAP)(t) ? c.defaultTags.MAP : (({ type: e }) => e === d.Type.FLOW_SEQ || e === d.Type.SEQ)(t) ? c.defaultTags.SEQ : c.defaultTags.STR; if (o) {
                    e.warnings.push(new y.YAMLWarning(t, "The tag ".concat(n, " is unavailable, falling back to ").concat(o)));
                    const r = this.resolveNode(e, t, o);
                    return r.tag = n, r;
                } return e.errors.push(new y.YAMLReferenceError(t, "The tag ".concat(n, " is unavailable"))), null; }
                getTagObject(e) { if (e instanceof n.default)
                    return n.default; if (e.tag) {
                    const t = this.tags.filter((t => t.tag === e.tag));
                    if (t.length > 0)
                        return t.find((t => t.format === e.format)) || t[0];
                } let t, r; if (e instanceof s.default) {
                    r = e.value;
                    const n = this.tags.filter((e => e.identify && e.identify(r) || e.class && r instanceof e.class));
                    t = n.find((t => t.format === e.format)) || n.find((e => !e.format));
                }
                else
                    r = e, t = this.tags.find((e => e.nodeClass && r instanceof e.nodeClass)); if (!t) {
                    const e = r && r.constructor ? r.constructor.name : typeof r;
                    throw new Error("Tag not resolved for ".concat(e, " value"));
                } return t; }
                stringifyProps(e, t, { anchors: n, doc: r }) { const o = [], i = r.anchors.getName(e); return i && (n[i] = e, o.push("&".concat(i))), e.tag ? o.push(r.stringifyTag(e.tag)) : t.default || o.push(r.stringifyTag(t.tag)), o.join(" "); }
                stringify(e, t, n, s) { let a; if (!(e instanceof o.default)) {
                    const n = { aliasNodes: [], onTagObj: e => a = e, prevObjects: new Map };
                    e = this.createNode(e, !0, null, n);
                    const { anchors: r } = t.doc;
                    for (const e of n.aliasNodes) {
                        e.source = e.source.node;
                        let t = r.getName(e.source);
                        t || (t = r.newName(), r.map[t] = e.source);
                    }
                } if (t.tags = this, e instanceof i.default)
                    return e.toString(t, n, s); a || (a = this.getTagObject(e)); const u = this.stringifyProps(e, a, t); u.length > 0 && (t.indentAtStart = (t.indentAtStart || 0) + u.length + 1); const c = "function" == typeof a.stringify ? a.stringify(e, t, n, s) : e instanceof r.default ? e.toString(t, n, s) : (0, H.stringifyString)(e, t, n, s); return u ? e instanceof r.default && "{" !== c[0] && "[" !== c[0] ? "".concat(u, "\n").concat(t.indent).concat(c) : "".concat(u, " ").concat(c) : c; }
            } t.default = c, u(c, "defaultPrefix", "tag:yaml.org,2002:"), u(c, "defaultTags", { MAP: "tag:yaml.org,2002:map", SEQ: "tag:yaml.org,2002:seq", STR: "tag:yaml.org,2002:str" }); })); r(at); var ut = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0; var n, r, o, i = g(N), s = g(U), a = g(V), u = g(at), c = g(B), l = function (e) { if (e && e.__esModule)
                return e; if (null === e || "object" != typeof e && "function" != typeof e)
                return { default: e }; var t = m(); if (t && t.has(e))
                return t.get(e); var n = {}, r = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var o in e)
                if (Object.prototype.hasOwnProperty.call(e, o)) {
                    var i = r ? Object.getOwnPropertyDescriptor(e, o) : null;
                    i && (i.get || i.set) ? Object.defineProperty(n, o, i) : n[o] = e[o];
                } return n.default = e, t && t.set(e, n), n; }(j), p = g(M), f = g(R), h = g(P); function m() { if ("function" != typeof WeakMap)
                return null; var e = new WeakMap; return m = function () { return e; }, e; } function g(e) { return e && e.__esModule ? e : { default: e }; } class v {
                constructor(e) { this.anchors = new s.default(e.anchorPrefix), this.commentBefore = null, this.comment = null, this.contents = null, this.directivesEndMarker = null, this.errors = [], this.options = e, this.schema = null, this.tagPrefixes = [], this.version = null, this.warnings = []; }
                assertCollectionContents() { if (this.contents instanceof l.default)
                    return !0; throw new Error("Expected a YAML collection as document contents"); }
                add(e) { return this.assertCollectionContents(), this.contents.add(e); }
                addIn(e, t) { this.assertCollectionContents(), this.contents.addIn(e, t); }
                delete(e) { return this.assertCollectionContents(), this.contents.delete(e); }
                deleteIn(e) { return (0, l.isEmptyPath)(e) ? null != this.contents && (this.contents = null, !0) : (this.assertCollectionContents(), this.contents.deleteIn(e)); }
                getDefaults() { return v.defaults[this.version] || v.defaults[this.options.version] || {}; }
                get(e, t) { return this.contents instanceof l.default ? this.contents.get(e, t) : void 0; }
                getIn(e, t) { return (0, l.isEmptyPath)(e) ? !t && this.contents instanceof f.default ? this.contents.value : this.contents : this.contents instanceof l.default ? this.contents.getIn(e, t) : void 0; }
                has(e) { return this.contents instanceof l.default && this.contents.has(e); }
                hasIn(e) { return (0, l.isEmptyPath)(e) ? void 0 !== this.contents : this.contents instanceof l.default && this.contents.hasIn(e); }
                set(e, t) { this.assertCollectionContents(), this.contents.set(e, t); }
                setIn(e, t) { (0, l.isEmptyPath)(e) ? this.contents = t : (this.assertCollectionContents(), this.contents.setIn(e, t)); }
                setSchema(e, t) { if (!e && !t && this.schema)
                    return; "number" == typeof e && (e = e.toFixed(1)), "1.0" === e || "1.1" === e || "1.2" === e ? (this.version ? this.version = e : this.options.version = e, delete this.options.schema) : e && "string" == typeof e && (this.options.schema = e), Array.isArray(t) && (this.options.customTags = t); const n = Object.assign({}, this.getDefaults(), this.options); this.schema = new u.default(n); }
                parse(e, t) { this.options.keepCstNodes && (this.cstNode = e), this.options.keepNodeTypes && (this.type = "DOCUMENT"); const { directives: n = [], contents: r = [], directivesEndMarker: o, error: i, valueRange: s } = e; if (i && (i.source || (i.source = this), this.errors.push(i)), this.parseDirectives(n, t), o && (this.directivesEndMarker = !0), this.range = s ? [s.start, s.end] : null, this.setSchema(), this.anchors._cstAliases = [], this.parseContents(r), this.anchors.resolveNodes(), this.options.prettyErrors) {
                    for (const e of this.errors)
                        e instanceof y.YAMLError && e.makePretty();
                    for (const e of this.warnings)
                        e instanceof y.YAMLError && e.makePretty();
                } return this; }
                parseDirectives(e, t) { const n = []; let r = !1; if (e.forEach((e => { const { comment: t, name: o } = e; switch (o) {
                    case "TAG":
                        this.resolveTagDirective(e), r = !0;
                        break;
                    case "YAML":
                    case "YAML:1.0":
                        this.resolveYamlDirective(e), r = !0;
                        break;
                    default: if (o) {
                        const t = "YAML only supports %TAG and %YAML directives, and not %".concat(o);
                        this.warnings.push(new y.YAMLWarning(e, t));
                    }
                } t && n.push(t); })), t && !r && "1.1" === (this.version || t.version || this.options.version)) {
                    const e = ({ handle: e, prefix: t }) => ({ handle: e, prefix: t });
                    this.tagPrefixes = t.tagPrefixes.map(e), this.version = t.version;
                } this.commentBefore = n.join("\n") || null; }
                parseContents(e) { const t = { before: [], after: [] }, n = []; let r = !1; switch (e.forEach((e => { if (e.valueRange) {
                    if (1 === n.length) {
                        const t = "Document is not valid YAML (bad indentation?)";
                        this.errors.push(new y.YAMLSyntaxError(e, t));
                    }
                    const t = this.resolveNode(e);
                    r && (t.spaceBefore = !0, r = !1), n.push(t);
                }
                else
                    null !== e.comment ? (0 === n.length ? t.before : t.after).push(e.comment) : e.type === d.Type.BLANK_LINE && (r = !0, 0 === n.length && t.before.length > 0 && !this.commentBefore && (this.commentBefore = t.before.join("\n"), t.before = [])); })), n.length) {
                    case 0:
                        this.contents = null, t.after = t.before;
                        break;
                    case 1:
                        if (this.contents = n[0], this.contents) {
                            const e = t.before.join("\n") || null;
                            if (e) {
                                const t = this.contents instanceof l.default && this.contents.items[0] ? this.contents.items[0] : this.contents;
                                t.commentBefore = t.commentBefore ? "".concat(e, "\n").concat(t.commentBefore) : e;
                            }
                        }
                        else
                            t.after = t.before.concat(t.after);
                        break;
                    default: this.contents = n, this.contents[0] ? this.contents[0].commentBefore = t.before.join("\n") || null : t.after = t.before.concat(t.after);
                } this.comment = t.after.join("\n") || null; }
                resolveTagDirective(e) { const [t, n] = e.parameters; if (t && n)
                    if (this.tagPrefixes.every((e => e.handle !== t)))
                        this.tagPrefixes.push({ handle: t, prefix: n });
                    else {
                        const t = "The %TAG directive must only be given at most once per handle in the same document.";
                        this.errors.push(new y.YAMLSemanticError(e, t));
                    }
                else {
                    const t = "Insufficient parameters given for %TAG directive";
                    this.errors.push(new y.YAMLSemanticError(e, t));
                } }
                resolveYamlDirective(e) { let [t] = e.parameters; if ("YAML:1.0" === e.name && (t = "1.0"), this.version) {
                    const t = "The %YAML directive must only be given at most once per document.";
                    this.errors.push(new y.YAMLSemanticError(e, t));
                } if (t) {
                    if (!v.defaults[t]) {
                        const n = this.version || this.options.version, r = "Document will be parsed as YAML ".concat(n, " rather than YAML ").concat(t);
                        this.warnings.push(new y.YAMLWarning(e, r));
                    }
                    this.version = t;
                }
                else {
                    const t = "Insufficient parameters given for %YAML directive";
                    this.errors.push(new y.YAMLSemanticError(e, t));
                } }
                resolveTagName(e) { const { tag: t, type: n } = e; let r = !1; if (t) {
                    const { handle: n, suffix: o, verbatim: i } = t;
                    if (i) {
                        if ("!" !== i && "!!" !== i)
                            return i;
                        const t = "Verbatim tags aren't resolved, so ".concat(i, " is invalid.");
                        this.errors.push(new y.YAMLSemanticError(e, t));
                    }
                    else if ("!" !== n || o) {
                        let t = this.tagPrefixes.find((e => e.handle === n));
                        if (!t) {
                            const e = this.getDefaults().tagPrefixes;
                            e && (t = e.find((e => e.handle === n)));
                        }
                        if (t) {
                            if (o) {
                                if ("!" === n && "1.0" === (this.version || this.options.version)) {
                                    if ("^" === o[0])
                                        return o;
                                    if (/[:/]/.test(o)) {
                                        const e = o.match(/^([a-z0-9-]+)\/(.*)/i);
                                        return e ? "tag:".concat(e[1], ".yaml.org,2002:").concat(e[2]) : "tag:".concat(o);
                                    }
                                }
                                return t.prefix + decodeURIComponent(o);
                            }
                            this.errors.push(new y.YAMLSemanticError(e, "The ".concat(n, " tag has no suffix.")));
                        }
                        else {
                            const t = "The ".concat(n, " tag handle is non-default and was not declared.");
                            this.errors.push(new y.YAMLSemanticError(e, t));
                        }
                    }
                    else
                        r = !0;
                } switch (n) {
                    case d.Type.BLOCK_FOLDED:
                    case d.Type.BLOCK_LITERAL:
                    case d.Type.QUOTE_DOUBLE:
                    case d.Type.QUOTE_SINGLE: return u.default.defaultTags.STR;
                    case d.Type.FLOW_MAP:
                    case d.Type.MAP: return u.default.defaultTags.MAP;
                    case d.Type.FLOW_SEQ:
                    case d.Type.SEQ: return u.default.defaultTags.SEQ;
                    case d.Type.PLAIN: return r ? u.default.defaultTags.STR : null;
                    default: return null;
                } }
                resolveNode(e) { if (!e)
                    return null; const { anchors: t, errors: n, schema: r } = this; let o = !1, i = !1; const s = { before: [], after: [] }, a = (u = e.context.parent) && [d.Type.MAP_KEY, d.Type.MAP_VALUE, d.Type.SEQ_ITEM].includes(u.type) ? e.context.parent.props.concat(e.props) : e.props; var u; for (const { start: t, end: r } of a)
                    switch (e.context.src[t]) {
                        case d.Char.COMMENT:
                            {
                                if (!e.commentHasRequiredWhitespace(t)) {
                                    const t = "Comments must be separated from other tokens by white space characters";
                                    n.push(new y.YAMLSemanticError(e, t));
                                }
                                const o = e.context.src.slice(t + 1, r), { header: i, valueRange: a } = e;
                                a && (t > a.start || i && t > i.start) ? s.after.push(o) : s.before.push(o);
                            }
                            break;
                        case d.Char.ANCHOR:
                            if (o) {
                                const t = "A node can have at most one anchor";
                                n.push(new y.YAMLSemanticError(e, t));
                            }
                            o = !0;
                            break;
                        case d.Char.TAG:
                            if (i) {
                                const t = "A node can have at most one tag";
                                n.push(new y.YAMLSemanticError(e, t));
                            }
                            i = !0;
                    } if (o) {
                    const n = e.anchor, r = t.getNode(n);
                    r && (t.map[t.newName(n)] = r), t.map[n] = e;
                } let l; if (e.type === d.Type.ALIAS) {
                    if (o || i) {
                        const t = "An alias node must not specify any properties";
                        n.push(new y.YAMLSemanticError(e, t));
                    }
                    const r = e.rawValue, s = t.getNode(r);
                    if (!s) {
                        const t = "Aliased anchor not found: ".concat(r);
                        return n.push(new y.YAMLReferenceError(e, t)), null;
                    }
                    l = new c.default(s), t._cstAliases.push(l);
                }
                else {
                    const t = this.resolveTagName(e);
                    if (t)
                        l = r.resolveNodeWithFallback(this, e, t);
                    else {
                        if (e.type !== d.Type.PLAIN) {
                            const t = "Failed to resolve ".concat(e.type, " node here");
                            return n.push(new y.YAMLSyntaxError(e, t)), null;
                        }
                        try {
                            l = r.resolveScalar(e.strValue || "");
                        }
                        catch (t) {
                            return t.source || (t.source = e), n.push(t), null;
                        }
                    }
                } if (l) {
                    l.range = [e.range.start, e.range.end], this.options.keepCstNodes && (l.cstNode = e), this.options.keepNodeTypes && (l.type = e.type);
                    const t = s.before.join("\n");
                    t && (l.commentBefore = l.commentBefore ? "".concat(l.commentBefore, "\n").concat(t) : t);
                    const n = s.after.join("\n");
                    n && (l.comment = l.comment ? "".concat(l.comment, "\n").concat(n) : n);
                } return e.resolved = l; }
                listNonDefaultTags() { return (0, a.default)(this.contents).filter((e => 0 !== e.indexOf(u.default.defaultPrefix))); }
                setTagPrefix(e, t) { if ("!" !== e[0] || "!" !== e[e.length - 1])
                    throw new Error("Handle must start and end with !"); if (t) {
                    const n = this.tagPrefixes.find((t => t.handle === e));
                    n ? n.prefix = t : this.tagPrefixes.push({ handle: e, prefix: t });
                }
                else
                    this.tagPrefixes = this.tagPrefixes.filter((t => t.handle !== e)); }
                stringifyTag(e) { if ("1.0" === (this.version || this.options.version)) {
                    const t = e.match(/^tag:private\.yaml\.org,2002:([^:/]+)$/);
                    if (t)
                        return "!" + t[1];
                    const n = e.match(/^tag:([a-zA-Z0-9-]+)\.yaml\.org,2002:(.*)/);
                    return n ? "!".concat(n[1], "/").concat(n[2]) : "!".concat(e.replace(/^tag:/, ""));
                } {
                    let t = this.tagPrefixes.find((t => 0 === e.indexOf(t.prefix)));
                    if (!t) {
                        const n = this.getDefaults().tagPrefixes;
                        t = n && n.find((t => 0 === e.indexOf(t.prefix)));
                    }
                    if (!t)
                        return "!" === e[0] ? e : "!<".concat(e, ">");
                    const n = e.substr(t.prefix.length).replace(/[!,[\]{}]/g, (e => ({ "!": "%21", ",": "%2C", "[": "%5B", "]": "%5D", "{": "%7B", "}": "%7D" }[e])));
                    return t.handle + n;
                } }
                toJSON(e) { const { keepBlobsInJSON: t, mapAsMap: n, maxAliasCount: r } = this.options, o = t && ("string" != typeof e || !(this.contents instanceof f.default)), i = { doc: this, keep: o, mapAsMap: o && !!n, maxAliasCount: r }, s = Object.keys(this.anchors.map); return s.length > 0 && (i.anchors = s.map((e => ({ alias: [], aliasCount: 0, count: 1, node: this.anchors.map[e] })))), (0, h.default)(this.contents, e, i); }
                toString() { if (this.errors.length > 0)
                    throw new Error("Document with errors cannot be stringified"); this.setSchema(); const e = []; let t = !1; if (this.version) {
                    let n = "%YAML 1.2";
                    "yaml-1.1" === this.schema.name && ("1.0" === this.version ? n = "%YAML:1.0" : "1.1" === this.version && (n = "%YAML 1.1")), e.push(n), t = !0;
                } const n = this.listNonDefaultTags(); this.tagPrefixes.forEach((({ handle: r, prefix: o }) => { n.some((e => 0 === e.indexOf(o))) && (e.push("%TAG ".concat(r, " ").concat(o)), t = !0); })), (t || this.directivesEndMarker) && e.push("---"), this.commentBefore && (!t && this.directivesEndMarker || e.unshift(""), e.unshift(this.commentBefore.replace(/^/gm, "#"))); const r = { anchors: {}, doc: this, indent: "" }; let o = !1, s = null; if (this.contents) {
                    this.contents instanceof p.default && (this.contents.spaceBefore && (t || this.directivesEndMarker) && e.push(""), this.contents.commentBefore && e.push(this.contents.commentBefore.replace(/^/gm, "#")), r.forceBlockIndent = !!this.comment, s = this.contents.comment);
                    const n = s ? null : () => o = !0, a = this.schema.stringify(this.contents, r, (() => s = null), n);
                    e.push((0, i.default)(a, "", s));
                }
                else
                    void 0 !== this.contents && e.push(this.schema.stringify(this.contents, r)); return this.comment && (o && !s || "" === e[e.length - 1] || e.push(""), e.push(this.comment.replace(/^/gm, "#"))), e.join("\n") + "\n"; }
            } t.default = v, n = v, r = "defaults", o = { "1.0": { schema: "yaml-1.1", merge: !0, tagPrefixes: [{ handle: "!", prefix: u.default.defaultPrefix }, { handle: "!!", prefix: "tag:private.yaml.org,2002:" }] }, 1.1: { schema: "yaml-1.1", merge: !0, tagPrefixes: [{ handle: "!", prefix: "!" }, { handle: "!!", prefix: u.default.defaultPrefix }] }, 1.2: { schema: "core", merge: !1, tagPrefixes: [{ handle: "!", prefix: "!" }, { handle: "!!", prefix: u.default.defaultPrefix }] } }, r in n ? Object.defineProperty(n, r, { value: o, enumerable: !0, configurable: !0, writable: !0 }) : n[r] = o; })); r(ut); var ct = o((function (e, t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.default = void 0; var n = i(_), r = i(ut), o = i(at); function i(e) { return e && e.__esModule ? e : { default: e }; } const s = { anchorPrefix: "a", customTags: null, keepCstNodes: !1, keepNodeTypes: !0, keepBlobsInJSON: !0, mapAsMap: !1, maxAliasCount: 100, prettyErrors: !1, simpleKeys: !1, version: "1.2" }; class a extends r.default {
                constructor(e) { super(Object.assign({}, s, e)); }
            } function u(e, t) { const r = (0, n.default)(e), o = new a(t).parse(r[0]); if (r.length > 1) {
                const e = "Source contains multiple documents; please use YAML.parseAllDocuments()";
                o.errors.unshift(new y.YAMLSemanticError(r[1], e));
            } return o; } var c = { createNode: function (e, t = !0, n) { void 0 === n && "string" == typeof t && (n = t, t = !0); const i = Object.assign({}, r.default.defaults[s.version], s); return new o.default(i).createNode(e, t, n); }, defaultOptions: s, Document: a, parse: function (e, t) { const n = u(e, t); if (n.warnings.forEach((e => (0, W.warn)(e))), n.errors.length > 0)
                    throw n.errors[0]; return n.toJSON(); }, parseAllDocuments: function (e, t) { const r = []; let o; for (const i of (0, n.default)(e)) {
                    const e = new a(t);
                    e.parse(i, o), r.push(e), o = e;
                } return r; }, parseCST: n.default, parseDocument: u, stringify: function (e, t) { const n = new a(t); return n.contents = e, String(n); } }; t.default = c; })); r(ct); var lt = ct.default, pt = o((function (e, t) { t.__esModule = !0, t.defineParents = function e(t, n) { void 0 === n && (n = null), "children" in t && t.children.forEach((function (n) { return e(n, t); })), "anchor" in t && t.anchor && e(t.anchor, t), "tag" in t && t.tag && e(t.tag, t), "leadingComments" in t && t.leadingComments.forEach((function (n) { return e(n, t); })), "middleComments" in t && t.middleComments.forEach((function (n) { return e(n, t); })), "indicatorComment" in t && t.indicatorComment && e(t.indicatorComment, t), "trailingComment" in t && t.trailingComment && e(t.trailingComment, t), "endComments" in t && t.endComments.forEach((function (n) { return e(n, t); })), Object.defineProperty(t, "_parent", { value: n, enumerable: !1 }); }; })); r(pt), pt.defineParents; var ft = o((function (e, t) { t.__esModule = !0, t.getPointText = function (e) { return e.line + ":" + e.column; }; })); r(ft), ft.getPointText; var dt = o((function (e, t) { function n(e, t) { if (t.position.end.offset < e.position.end.offset)
                return !1; switch (e.type) {
                case "sequenceItem": return t.position.start.column > e.position.start.column;
                case "mappingKey":
                case "mappingValue": return t.position.start.column > e._parent.position.start.column && (0 === e.children.length || 1 === e.children.length && "blockFolded" !== e.children[0].type && "blockLiteral" !== e.children[0].type && ("mappingValue" === e.type || e.position.start.offset !== e.children[0].position.start.offset));
                default: return !1;
            } } t.__esModule = !0, t.attachComments = function (e) { pt.defineParents(e); var t = function (e) { for (var t = Array.from(new Array(e.position.end.line), (function () { return {}; })), n = 0, r = e.comments; n < r.length; n++) {
                var o = r[n];
                t[o.position.start.line - 1].comment = o;
            } return function e(t, n) { if (n.position.start.offset !== n.position.end.offset) {
                if ("leadingComments" in n) {
                    var r = n.position.start, o = t[r.line - 1].leadingAttachableNode;
                    (!o || r.column < o.position.start.column) && (t[r.line - 1].leadingAttachableNode = n);
                }
                if ("trailingComment" in n && n.position.end.column > 1 && "document" !== n.type && "documentHead" !== n.type) {
                    var i = n.position.end, s = t[i.line - 1].trailingAttachableNode;
                    (!s || i.column >= s.position.end.column) && (t[i.line - 1].trailingAttachableNode = n);
                }
                if ("root" !== n.type && "document" !== n.type && "documentHead" !== n.type && "documentBody" !== n.type)
                    for (var a = n.position, u = 0, c = (r = a.start, [(i = a.end).line].concat(r.line === i.line ? [] : r.line)); u < c.length; u++) {
                        var l = c[u], p = t[l - 1].trailingNode;
                        (!p || i.column >= p.position.end.column) && (t[l - 1].trailingNode = n);
                    }
                "children" in n && n.children.forEach((function (n) { e(t, n); }));
            } }(t, e), t; }(e), r = e.children.slice(); e.comments.sort((function (e, t) { return e.position.start.offset - t.position.end.offset; })).filter((function (e) { return !e._parent; })).forEach((function (e) { for (; r.length > 1 && e.position.start.line > r[0].position.end.line;)
                r.shift(); !function (e, t, r) { var o = e.position.start.line, i = t[o - 1].trailingAttachableNode; if (i) {
                if (i.trailingComment)
                    throw new Error("Unexpected multiple trailing comment at " + ft.getPointText(e.position.start));
                return pt.defineParents(e, i), void (i.trailingComment = e);
            } for (var s = o; s >= r.position.start.line; s--) {
                var a = t[s - 1].trailingNode, u = void 0;
                if (a)
                    u = a;
                else {
                    if (s === o || !t[s - 1].comment)
                        continue;
                    u = t[s - 1].comment._parent;
                }
                for (;;) {
                    if (n(u, e))
                        return pt.defineParents(e, u), void u.endComments.push(e);
                    if (!u._parent)
                        break;
                    u = u._parent;
                }
                break;
            } for (s = o + 1; s <= r.position.end.line; s++) {
                var c = t[s - 1].leadingAttachableNode;
                if (c)
                    return pt.defineParents(e, c), void c.leadingComments.push(e);
            } var l = r.children[1]; pt.defineParents(e, l), l.endComments.push(e); }(e, t, r[0]); })); }; })); r(dt), dt.attachComments; var ht = o((function (e, t) { t.__esModule = !0, t.createNode = function (e, t) { return { type: e, position: t }; }; })); r(ht), ht.createNode; var mt, gt = (mt = p) && mt.default || mt, yt = o((function (e, t) { t.__esModule = !0, t.createRoot = function (e, t, n) { return gt.__assign(gt.__assign({}, ht.createNode("root", e)), { children: t, comments: n }); }; })); r(yt), yt.createRoot; var vt = o((function (e, t) { t.__esModule = !0, t.removeCstBlankLine = function e(t) { switch (t.type) {
                case "DOCUMENT":
                    for (var n = t.contents.length - 1; n >= 0; n--)
                        "BLANK_LINE" === t.contents[n].type ? t.contents.splice(n, 1) : e(t.contents[n]);
                    for (n = t.directives.length - 1; n >= 0; n--)
                        "BLANK_LINE" === t.directives[n].type && t.directives.splice(n, 1);
                    break;
                case "FLOW_MAP":
                case "FLOW_SEQ":
                case "MAP":
                case "SEQ":
                    for (n = t.items.length - 1; n >= 0; n--) {
                        var r = t.items[n];
                        "char" in r || ("BLANK_LINE" === r.type ? t.items.splice(n, 1) : e(r));
                    }
                    break;
                case "MAP_KEY":
                case "MAP_VALUE":
                case "SEQ_ITEM":
                    t.node && e(t.node);
                    break;
                case "ALIAS":
                case "BLANK_LINE":
                case "BLOCK_FOLDED":
                case "BLOCK_LITERAL":
                case "COMMENT":
                case "DIRECTIVE":
                case "PLAIN":
                case "QUOTE_DOUBLE":
                case "QUOTE_SINGLE": break;
                default: throw new Error("Unexpected node type " + JSON.stringify(t.type));
            } }; })); r(vt), vt.removeCstBlankLine; var bt = o((function (e, t) { t.__esModule = !0, t.createLeadingCommentAttachable = function () { return { leadingComments: [] }; }; })); r(bt), bt.createLeadingCommentAttachable; var Dt = o((function (e, t) { t.__esModule = !0, t.createTrailingCommentAttachable = function (e) { return void 0 === e && (e = null), { trailingComment: e }; }; })); r(Dt), Dt.createTrailingCommentAttachable; var Et = o((function (e, t) { t.__esModule = !0, t.createCommentAttachable = function () { return gt.__assign(gt.__assign({}, bt.createLeadingCommentAttachable()), Dt.createTrailingCommentAttachable()); }; })); r(Et), Et.createCommentAttachable; var Ct = o((function (e, t) { t.__esModule = !0, t.createAlias = function (e, t, n) { return gt.__assign(gt.__assign(gt.__assign(gt.__assign({}, ht.createNode("alias", e)), Et.createCommentAttachable()), t), { value: n }); }; })); r(Ct), Ct.createAlias; var wt = o((function (e, t) { t.__esModule = !0, t.transformAlias = function (e, t) { var n = e.cstNode; return Ct.createAlias(t.transformRange({ origStart: n.valueRange.origStart - 1, origEnd: n.valueRange.origEnd }), t.transformContent(e), n.rawValue); }; })); r(wt), wt.transformAlias; var At = o((function (e, t) { t.__esModule = !0, t.createBlockFolded = function (e) { return gt.__assign(gt.__assign({}, e), { type: "blockFolded" }); }; })); r(At), At.createBlockFolded; var St = o((function (e, t) { t.__esModule = !0, t.createBlockValue = function (e, t, n, r, o, i) { return gt.__assign(gt.__assign(gt.__assign(gt.__assign({}, ht.createNode("blockValue", e)), bt.createLeadingCommentAttachable()), t), { chomping: n, indent: r, value: o, indicatorComment: i }); }; })); r(St), St.createBlockValue; var xt = o((function (e, t) { var n; t.__esModule = !0, (n = t.PropLeadingCharacter || (t.PropLeadingCharacter = {})).Tag = "!", n.Anchor = "&", n.Comment = "#"; })); r(xt), xt.PropLeadingCharacter; var Tt = o((function (e, t) { t.__esModule = !0, t.createAnchor = function (e, t) { return gt.__assign(gt.__assign({}, ht.createNode("anchor", e)), { value: t }); }; })); r(Tt), Tt.createAnchor; var kt = o((function (e, t) { t.__esModule = !0, t.createComment = function (e, t) { return gt.__assign(gt.__assign({}, ht.createNode("comment", e)), { value: t }); }; })); r(kt), kt.createComment; var Ft = o((function (e, t) { t.__esModule = !0, t.createContent = function (e, t, n) { return { anchor: t, tag: e, middleComments: n }; }; })); r(Ft), Ft.createContent; var Ot = o((function (e, t) { t.__esModule = !0, t.createTag = function (e, t) { return gt.__assign(gt.__assign({}, ht.createNode("tag", e)), { value: t }); }; })); r(Ot), Ot.createTag; var _t = o((function (e, t) { t.__esModule = !0, t.transformContent = function (e, t, n) { void 0 === n && (n = function () { return !1; }); for (var r = e.cstNode, o = [], i = null, s = null, a = null, u = 0, c = r.props; u < c.length; u++) {
                var l = c[u], p = t.text[l.origStart];
                switch (p) {
                    case xt.PropLeadingCharacter.Tag:
                        i = i || l, s = Ot.createTag(t.transformRange(l), e.tag);
                        break;
                    case xt.PropLeadingCharacter.Anchor:
                        i = i || l, a = Tt.createAnchor(t.transformRange(l), r.anchor);
                        break;
                    case xt.PropLeadingCharacter.Comment:
                        var f = kt.createComment(t.transformRange(l), t.text.slice(l.origStart + 1, l.origEnd));
                        t.comments.push(f), !n(f) && i && i.origEnd <= l.origStart && l.origEnd <= r.valueRange.origStart && o.push(f);
                        break;
                    default: throw new Error("Unexpected leading character " + JSON.stringify(p));
                }
            } return Ft.createContent(s, a, o); }; })); r(_t), _t.transformContent; var Nt = o((function (e, t) { var n, r; t.__esModule = !0, (r = n || (n = {})).CLIP = "clip", r.STRIP = "strip", r.KEEP = "keep", t.transformAstBlockValue = function (e, t) { var r = e.cstNode, o = "CLIP" === r.chomping ? 0 : 1, i = r.header.origEnd - r.header.origStart - 1 - o != 0, s = t.transformRange({ origStart: r.header.origStart, origEnd: r.valueRange.origEnd }), a = null, u = _t.transformContent(e, t, (function (e) { if (!(s.start.offset < e.position.start.offset && e.position.end.offset < s.end.offset))
                return !1; if (a)
                throw new Error("Unexpected multiple indicator comments at " + ft.getPointText(e.position.start)); return a = e, !0; })); return St.createBlockValue(s, u, n[r.chomping], i ? r.blockIndent : null, r.strValue, a); }; })); r(Nt), Nt.transformAstBlockValue; var Pt = o((function (e, t) { t.__esModule = !0, t.transformBlockFolded = function (e, t) { return At.createBlockFolded(Nt.transformAstBlockValue(e, t)); }; })); r(Pt), Pt.transformBlockFolded; var Mt = o((function (e, t) { t.__esModule = !0, t.createBlockLiteral = function (e) { return gt.__assign(gt.__assign({}, e), { type: "blockLiteral" }); }; })); r(Mt), Mt.createBlockLiteral; var Rt = o((function (e, t) { t.__esModule = !0, t.transformBlockLiteral = function (e, t) { return Mt.createBlockLiteral(Nt.transformAstBlockValue(e, t)); }; })); r(Rt), Rt.transformBlockLiteral; var It = o((function (e, t) { t.__esModule = !0, t.transformComment = function (e, t) { return kt.createComment(t.transformRange(e.range), e.comment); }; })); r(It), It.transformComment; var jt = o((function (e, t) { t.__esModule = !0, t.createDirective = function (e, t, n) { return gt.__assign(gt.__assign(gt.__assign({}, ht.createNode("directive", e)), Et.createCommentAttachable()), { name: t, parameters: n }); }; })); r(jt), jt.createDirective; var Bt = o((function (e, t) { t.__esModule = !0, t.extractPropComments = function (e, t) { for (var n = 0, r = e.props; n < r.length; n++) {
                var o = r[n], i = t.text[o.origStart];
                if (i !== xt.PropLeadingCharacter.Comment)
                    throw new Error("Unexpected leading character " + JSON.stringify(i));
                t.comments.push(kt.createComment(t.transformRange(o), t.text.slice(o.origStart + 1, o.origEnd)));
            } }; })); r(Bt), Bt.extractPropComments; var Lt = o((function (e, t) { t.__esModule = !0, t.transformDirective = function (e, t) { return Bt.extractPropComments(e, t), jt.createDirective(t.transformRange(e.range), e.name, e.parameters); }; })); r(Lt), Lt.transformDirective; var qt = o((function (e, t) { t.__esModule = !0, t.createDocument = function (e, t, n, r) { return gt.__assign(gt.__assign(gt.__assign({}, ht.createNode("document", e)), Dt.createTrailingCommentAttachable(r)), { children: [t, n] }); }; })); r(qt), qt.createDocument; var $t = o((function (e, t) { t.__esModule = !0, t.createPosition = function (e, t) { return { start: e, end: t }; }, t.createEmptyPosition = function (e) { return { start: e, end: e }; }; })); r($t), $t.createPosition, $t.createEmptyPosition; var Ut = o((function (e, t) { t.__esModule = !0, t.createEndCommentAttachable = function (e) { return void 0 === e && (e = []), { endComments: e }; }; })); r(Ut), Ut.createEndCommentAttachable; var Vt = o((function (e, t) { t.__esModule = !0, t.createDocumentBody = function (e, t, n) { return gt.__assign(gt.__assign(gt.__assign({}, ht.createNode("documentBody", e)), Ut.createEndCommentAttachable(n)), { children: t ? [t] : [] }); }; })); r(Vt), Vt.createDocumentBody; var Wt = o((function (e, t) { t.__esModule = !0, t.getLast = function (e) { return e[e.length - 1]; }; })); r(Wt), Wt.getLast; var Kt = o((function (e, t) { t.__esModule = !0, t.getMatchIndex = function (e, t) { var n = e.match(t); return n ? n.index : -1; }; })); r(Kt), Kt.getMatchIndex; var zt = o((function (e, t) { t.__esModule = !0, t.transformDocumentBody = function (e, t, n) { var r, o = e.cstNode, i = function (e, t, n) { for (var r = [], o = [], i = [], s = !1, a = e.contents.length - 1; a >= 0; a--) {
                var u = e.contents[a];
                if ("COMMENT" === u.type) {
                    var c = t.transformNode(u);
                    n && n.line === c.position.start.line ? i.unshift(c) : s ? r.unshift(c) : c.position.start.offset >= e.valueRange.origEnd ? o.unshift(c) : r.unshift(c);
                }
                else
                    s = !0;
            } if (o.length > 1)
                throw new Error("Unexpected multiple document trailing comments at " + ft.getPointText(o[1].position.start)); if (i.length > 1)
                throw new Error("Unexpected multiple documentHead trailing comments at " + ft.getPointText(i[1].position.start)); return { comments: r, endComments: [], documentTrailingComment: Wt.getLast(o) || null, documentHeadTrailingComment: Wt.getLast(i) || null }; }(o, t, n), s = i.comments, a = i.endComments, u = i.documentTrailingComment, c = i.documentHeadTrailingComment, l = t.transformNode(e.contents), p = function (e, t, n) { var r = Kt.getMatchIndex(n.text.slice(e.valueRange.origEnd), /^\.\.\./), o = -1 === r ? e.valueRange.origEnd : Math.max(0, e.valueRange.origEnd - 1); "\r" === n.text[o - 1] && o--; var i = n.transformRange({ origStart: null !== t ? t.position.start.offset : o, origEnd: o }); return { position: i, documentEndPoint: -1 === r ? i.end : n.transformOffset(e.valueRange.origEnd + 3) }; }(o, l, t), f = p.position, d = p.documentEndPoint; return (r = t.comments).push.apply(r, gt.__spreadArrays(s, a)), { documentBody: Vt.createDocumentBody(f, l, a), documentEndPoint: d, documentTrailingComment: u, documentHeadTrailingComment: c }; }; })); r(zt), zt.transformDocumentBody; var Ht = o((function (e, t) { t.__esModule = !0, t.createDocumentHead = function (e, t, n, r) { return gt.__assign(gt.__assign(gt.__assign(gt.__assign({}, ht.createNode("documentHead", e)), Ut.createEndCommentAttachable(n)), Dt.createTrailingCommentAttachable(r)), { children: t }); }; })); r(Ht), Ht.createDocumentHead; var Yt = o((function (e, t) { t.__esModule = !0, t.transformDocumentHead = function (e, t) { var n, r, o, i, s, a, u = e.cstNode, c = function (e, t) { for (var n = [], r = [], o = [], i = !1, s = e.directives.length - 1; s >= 0; s--) {
                var a = t.transformNode(e.directives[s]);
                "comment" === a.type ? i ? r.unshift(a) : o.unshift(a) : (i = !0, n.unshift(a));
            } return { directives: n, comments: r, endComments: o }; }(u, t), l = c.directives, p = c.comments, f = c.endComments, d = (r = u, o = l, i = t, a = -1 === (s = Kt.getMatchIndex(i.text.slice(0, r.valueRange.origStart), /---\s*$/)) ? { origStart: r.valueRange.origStart, origEnd: r.valueRange.origStart } : { origStart: s, origEnd: s + 3 }, 0 !== o.length && (a.origStart = o[0].position.start.offset), { position: i.transformRange(a), endMarkerPoint: -1 === s ? null : i.transformOffset(s) }), h = d.position, m = d.endMarkerPoint; return (n = t.comments).push.apply(n, gt.__spreadArrays(p, f)), { createDocumentHeadWithTrailingComment: function (e) { return e && t.comments.push(e), Ht.createDocumentHead(h, l, f, e); }, documentHeadEndMarkerPoint: m }; }; })); r(Yt), Yt.transformDocumentHead; var Jt = o((function (e, t) { t.__esModule = !0, t.transformDocument = function (e, t) { var n = Yt.transformDocumentHead(e, t), r = n.createDocumentHeadWithTrailingComment, o = n.documentHeadEndMarkerPoint, i = zt.transformDocumentBody(e, t, o), s = i.documentBody, a = i.documentEndPoint, u = i.documentTrailingComment, c = r(i.documentHeadTrailingComment); return u && t.comments.push(u), qt.createDocument($t.createPosition(c.position.start, a), c, s, u); }; })); r(Jt), Jt.transformDocument; var Gt = o((function (e, t) { t.__esModule = !0, t.createFlowCollection = function (e, t, n) { return gt.__assign(gt.__assign(gt.__assign(gt.__assign({}, ht.createNode("flowCollection", e)), Et.createCommentAttachable()), t), { children: n }); }; })); r(Gt), Gt.createFlowCollection; var Xt = o((function (e, t) { t.__esModule = !0, t.createFlowMapping = function (e, t, n) { return gt.__assign(gt.__assign({}, Gt.createFlowCollection(e, t, n)), { type: "flowMapping" }); }; })); r(Xt), Xt.createFlowMapping; var Qt = o((function (e, t) { t.__esModule = !0, t.createFlowMappingItem = function (e, t, n) { return gt.__assign(gt.__assign(gt.__assign({}, ht.createNode("flowMappingItem", e)), bt.createLeadingCommentAttachable()), { children: [t, n] }); }; })); r(Qt), Qt.createFlowMappingItem; var Zt = o((function (e, t) { t.__esModule = !0, t.extractComments = function (e, t) { for (var n = [], r = 0, o = e; r < o.length; r++) {
                var i = o[r];
                i && "type" in i && "COMMENT" === i.type ? t.comments.push(t.transformNode(i)) : n.push(i);
            } return n; }; })); r(Zt), Zt.extractComments; var en = o((function (e, t) { t.__esModule = !0, t.getFlowMapItemAdditionalRanges = function (e) { var t = ["?", ":"].map((function (t) { var n = e.find((function (e) { return "char" in e && e.char === t; })); return n ? { origStart: n.origOffset, origEnd: n.origOffset + 1 } : null; })); return { additionalKeyRange: t[0], additionalValueRange: t[1] }; }; })); r(en), en.getFlowMapItemAdditionalRanges; var tn = o((function (e, t) { t.__esModule = !0, t.createSlicer = function (e, t) { var n = t; return function (t) { return e.slice(n, n = t); }; }; })); r(tn), tn.createSlicer; var nn = o((function (e, t) { t.__esModule = !0, t.groupCstFlowCollectionItems = function (e) { for (var t = [], n = tn.createSlicer(e, 1), r = !1, o = 1; o < e.length - 1; o++) {
                var i = e[o];
                "char" in i && "," === i.char ? (t.push(n(o)), n(o + 1), r = !1) : r = !0;
            } return r && t.push(n(e.length - 1)), t; }; })); r(nn), nn.groupCstFlowCollectionItems; var rn = o((function (e, t) { t.__esModule = !0, t.createMappingKey = function (e, t) { return gt.__assign(gt.__assign(gt.__assign(gt.__assign({}, ht.createNode("mappingKey", e)), Dt.createTrailingCommentAttachable()), Ut.createEndCommentAttachable()), { children: t ? [t] : [] }); }; })); r(rn), rn.createMappingKey; var on = o((function (e, t) { t.__esModule = !0, t.createMappingValue = function (e, t) { return gt.__assign(gt.__assign(gt.__assign(gt.__assign({}, ht.createNode("mappingValue", e)), Et.createCommentAttachable()), Ut.createEndCommentAttachable()), { children: t ? [t] : [] }); }; })); r(on), on.createMappingValue; var sn = o((function (e, t) { t.__esModule = !0, t.transformAstPair = function (e, t, n, r, o) { var i = t.transformNode(e.key), s = t.transformNode("MERGE_PAIR" === e.type ? e.value.type ? e.value : e.value.items[0] : e.value), a = i || r ? rn.createMappingKey(t.transformRange({ origStart: r ? r.origStart : i.position.start.offset, origEnd: i ? i.position.end.offset : r.origStart + 1 }), i) : null, u = s || o ? on.createMappingValue(t.transformRange({ origStart: o ? o.origStart : s.position.start.offset, origEnd: s ? s.position.end.offset : o.origStart + 1 }), s) : null; return n($t.createPosition(a ? a.position.start : u.position.start, u ? u.position.end : a.position.end), a || rn.createMappingKey($t.createEmptyPosition(u.position.start), null), u || on.createMappingValue($t.createEmptyPosition(a.position.end), null)); }; })); r(sn), sn.transformAstPair; var an = o((function (e, t) { t.__esModule = !0, t.transformFlowMap = function (e, t) { var n = Zt.extractComments(e.cstNode.items, t), r = nn.groupCstFlowCollectionItems(n), o = e.items.map((function (e, n) { var o = r[n], i = en.getFlowMapItemAdditionalRanges(o), s = i.additionalKeyRange, a = i.additionalValueRange; return sn.transformAstPair(e, t, Qt.createFlowMappingItem, s, a); })), i = n[0], s = Wt.getLast(n); return Xt.createFlowMapping(t.transformRange({ origStart: i.origOffset, origEnd: s.origOffset + 1 }), t.transformContent(e), o); }; })); r(an), an.transformFlowMap; var un = o((function (e, t) { t.__esModule = !0, t.createFlowSequence = function (e, t, n) { return gt.__assign(gt.__assign({}, Gt.createFlowCollection(e, t, n)), { type: "flowSequence" }); }; })); r(un), un.createFlowSequence; var cn = o((function (e, t) { t.__esModule = !0, t.createFlowSequenceItem = function (e, t) { return gt.__assign(gt.__assign({}, ht.createNode("flowSequenceItem", e)), { children: [t] }); }; })); r(cn), cn.createFlowSequenceItem; var ln = o((function (e, t) { t.__esModule = !0, t.transformFlowSeq = function (e, t) { var n = Zt.extractComments(e.cstNode.items, t), r = nn.groupCstFlowCollectionItems(n), o = e.items.map((function (e, n) { if ("PAIR" !== e.type) {
                var o = t.transformNode(e);
                return cn.createFlowSequenceItem($t.createPosition(o.position.start, o.position.end), o);
            } var i = r[n], s = en.getFlowMapItemAdditionalRanges(i), a = s.additionalKeyRange, u = s.additionalValueRange; return sn.transformAstPair(e, t, Qt.createFlowMappingItem, a, u); })), i = n[0], s = Wt.getLast(n); return un.createFlowSequence(t.transformRange({ origStart: i.origOffset, origEnd: s.origOffset + 1 }), t.transformContent(e), o); }; })); r(ln), ln.transformFlowSeq; var pn = o((function (e, t) { t.__esModule = !0, t.createMapping = function (e, t, n) { return gt.__assign(gt.__assign(gt.__assign(gt.__assign({}, ht.createNode("mapping", e)), bt.createLeadingCommentAttachable()), t), { children: n }); }; })); r(pn), pn.createMapping; var fn = o((function (e, t) { t.__esModule = !0, t.createMappingItem = function (e, t, n) { return gt.__assign(gt.__assign(gt.__assign({}, ht.createNode("mappingItem", e)), bt.createLeadingCommentAttachable()), { children: [t, n] }); }; })); r(fn), fn.createMappingItem; var dn = o((function (e, t) { t.__esModule = !0, t.transformMap = function (e, t) { var n = e.cstNode; n.items.filter((function (e) { return "MAP_KEY" === e.type || "MAP_VALUE" === e.type; })).forEach((function (e) { return Bt.extractPropComments(e, t); })); var r = function (e) { for (var t = [], n = tn.createSlicer(e, 0), r = !1, o = 0; o < e.length; o++)
                "MAP_VALUE" !== e[o].type ? (r && t.push(n(o)), r = !0) : (t.push(n(o + 1)), r = !1); return r && t.push(n(1 / 0)), t; }(Zt.extractComments(n.items, t)), o = e.items.map((function (e, n) { var o = r[n], i = "MAP_VALUE" === o[0].type ? [null, o[0].range] : [o[0].range, 1 === o.length ? null : o[1].range], s = i[0], a = i[1]; return sn.transformAstPair(e, t, fn.createMappingItem, s, a); })); return pn.createMapping($t.createPosition(o[0].position.start, Wt.getLast(o).position.end), t.transformContent(e), o); }; })); r(dn), dn.transformMap; var hn = o((function (e, t) { t.__esModule = !0, t.createPlain = function (e, t, n) { return gt.__assign(gt.__assign(gt.__assign(gt.__assign({}, ht.createNode("plain", e)), Et.createCommentAttachable()), t), { value: n }); }; })); r(hn), hn.createPlain; var mn = o((function (e, t) { t.__esModule = !0, t.findLastCharIndex = function (e, t, n) { for (var r = t; r >= 0; r--)
                if (n.test(e[r]))
                    return r; return -1; }; })); r(mn), mn.findLastCharIndex; var gn = o((function (e, t) { t.__esModule = !0, t.transformPlain = function (e, t) { var n = e.cstNode; return hn.createPlain(t.transformRange({ origStart: n.valueRange.origStart, origEnd: mn.findLastCharIndex(t.text, n.valueRange.origEnd - 1, /\S/) + 1 }), t.transformContent(e), n.strValue); }; })); r(gn), gn.transformPlain; var yn = o((function (e, t) { t.__esModule = !0, t.createQuoteDouble = function (e) { return gt.__assign(gt.__assign({}, e), { type: "quoteDouble" }); }; })); r(yn), yn.createQuoteDouble; var vn = o((function (e, t) { t.__esModule = !0, t.createQuoteValue = function (e, t, n) { return gt.__assign(gt.__assign(gt.__assign(gt.__assign({}, ht.createNode("quoteValue", e)), t), Et.createCommentAttachable()), { value: n }); }; })); r(vn), vn.createQuoteValue; var bn = o((function (e, t) { t.__esModule = !0, t.transformAstQuoteValue = function (e, t) { var n = e.cstNode; return vn.createQuoteValue(t.transformRange(n.valueRange), t.transformContent(e), n.strValue); }; })); r(bn), bn.transformAstQuoteValue; var Dn = o((function (e, t) { t.__esModule = !0, t.transformQuoteDouble = function (e, t) { return yn.createQuoteDouble(bn.transformAstQuoteValue(e, t)); }; })); r(Dn), Dn.transformQuoteDouble; var En = o((function (e, t) { t.__esModule = !0, t.createQuoteSingle = function (e) { return gt.__assign(gt.__assign({}, e), { type: "quoteSingle" }); }; })); r(En), En.createQuoteSingle; var Cn = o((function (e, t) { t.__esModule = !0, t.transformQuoteSingle = function (e, t) { return En.createQuoteSingle(bn.transformAstQuoteValue(e, t)); }; })); r(Cn), Cn.transformQuoteSingle; var wn = o((function (e, t) { t.__esModule = !0, t.createSequence = function (e, t, n) { return gt.__assign(gt.__assign(gt.__assign(gt.__assign(gt.__assign({}, ht.createNode("sequence", e)), bt.createLeadingCommentAttachable()), Ut.createEndCommentAttachable()), t), { children: n }); }; })); r(wn), wn.createSequence; var An = o((function (e, t) { t.__esModule = !0, t.createSequenceItem = function (e, t) { return gt.__assign(gt.__assign(gt.__assign(gt.__assign({}, ht.createNode("sequenceItem", e)), Et.createCommentAttachable()), Ut.createEndCommentAttachable()), { children: t ? [t] : [] }); }; })); r(An), An.createSequenceItem; var Sn = o((function (e, t) { t.__esModule = !0, t.transformSeq = function (e, t) { var n = Zt.extractComments(e.cstNode.items, t).map((function (n, r) { Bt.extractPropComments(n, t); var o = t.transformNode(e.items[r]); return An.createSequenceItem($t.createPosition(t.transformOffset(n.valueRange.origStart), null === o ? t.transformOffset(n.valueRange.origStart + 1) : o.position.end), o); })); return wn.createSequence($t.createPosition(n[0].position.start, Wt.getLast(n).position.end), t.transformContent(e), n); }; })); r(Sn), Sn.transformSeq; var xn = o((function (e, t) { t.__esModule = !0, t.transformNode = function (e, t) { if (null === e)
                return null; switch (e.type) {
                case "ALIAS": return wt.transformAlias(e, t);
                case "BLOCK_FOLDED": return Pt.transformBlockFolded(e, t);
                case "BLOCK_LITERAL": return Rt.transformBlockLiteral(e, t);
                case "COMMENT": return It.transformComment(e, t);
                case "DIRECTIVE": return Lt.transformDirective(e, t);
                case "DOCUMENT": return Jt.transformDocument(e, t);
                case "FLOW_MAP": return an.transformFlowMap(e, t);
                case "FLOW_SEQ": return ln.transformFlowSeq(e, t);
                case "MAP": return dn.transformMap(e, t);
                case "PLAIN": return gn.transformPlain(e, t);
                case "QUOTE_DOUBLE": return Dn.transformQuoteDouble(e, t);
                case "QUOTE_SINGLE": return Cn.transformQuoteSingle(e, t);
                case "SEQ": return Sn.transformSeq(e, t);
                default: throw new Error("Unexpected node type " + e.type);
            } }; })); r(xn), xn.transformNode; var Tn = o((function (e, t) { t.__esModule = !0, t.createError = function (e, t, n) { var r = new SyntaxError(e); return r.name = "YAMLSyntaxError", r.source = t, r.position = n, r; }; })); r(Tn), Tn.createError; var kn = o((function (e, t) { t.__esModule = !0, t.transformError = function (e, t) { var n = e.source.range || e.source.valueRange; return Tn.createError(e.message, t.text, t.transformRange(n)); }; })); r(kn), kn.transformError; var Fn = o((function (e, t) { t.__esModule = !0, t.createPoint = function (e, t, n) { return { offset: e, line: t, column: n }; }; })); r(Fn), Fn.createPoint; var On = o((function (e, t) { t.__esModule = !0, t.transformOffset = function (e, t) { e < 0 ? e = 0 : e > t.text.length && (e = t.text.length); var n = t.locator.locationForIndex(e); return Fn.createPoint(e, n.line + 1, n.column + 1); }; })); r(On), On.transformOffset; var _n = o((function (e, t) { t.__esModule = !0, t.transformRange = function (e, t) { return $t.createPosition(t.transformOffset(e.origStart), t.transformOffset(e.origEnd)); }; })); r(_n), _n.transformRange; var Nn = o((function (e, t) { t.__esModule = !0, t.addOrigRange = function (e) { if (!e.setOrigRanges()) {
                var t = function (e) { return "number" == typeof e.start ? (e.origStart = e.start, e.origEnd = e.end, !0) : "number" == typeof e.offset ? (e.origOffset = e.offset, !0) : void 0; };
                e.forEach((function (e) { return function e(t, n) { if (t && "object" == typeof t && !0 !== n(t))
                    for (var r = 0, o = Object.keys(t); r < o.length; r++) {
                        var i = o[r];
                        if ("context" !== i && "error" !== i) {
                            var s = t[i];
                            Array.isArray(s) ? s.forEach((function (t) { return e(t, n); })) : e(s, n);
                        }
                    } }(e, t); }));
            } }; })); r(Nn), Nn.addOrigRange; var Pn = o((function (e, t) { t.__esModule = !0, t.removeFakeNodes = function e(t) { if ("children" in t) {
                if (1 === t.children.length) {
                    var n = t.children[0];
                    if ("plain" === n.type && null === n.tag && null === n.anchor && "" === n.value)
                        return t.children.splice(0, 1), t;
                }
                t.children.forEach(e);
            } return t; }; })); r(Pn), Pn.removeFakeNodes; var Mn = o((function (e, t) { t.__esModule = !0, t.createUpdater = function (e, t, n, r) { var o = t(e); return function (t) { r(o, t) && n(e, o = t); }; }; })); r(Mn), Mn.createUpdater; var Rn = o((function (e, t) { function n(e) { return e.start; } function r(e, t) { e.start = t; } function o(e) { return e.end; } function i(e, t) { e.end = t; } function s(e, t) { return t.offset < e.offset; } function a(e, t) { return t.offset > e.offset; } t.__esModule = !0, t.updatePositions = function e(t) { if (null !== t && "children" in t) {
                var u = t.children;
                if (u.forEach(e), "document" === t.type) {
                    var c = t.children, l = c[0], p = c[1];
                    l.position.start.offset === l.position.end.offset ? l.position.start = l.position.end = p.position.start : p.position.start.offset === p.position.end.offset && (p.position.start = p.position.end = l.position.end);
                }
                var f = Mn.createUpdater(t.position, n, r, s), d = Mn.createUpdater(t.position, o, i, a);
                "endComments" in t && 0 !== t.endComments.length && (f(t.endComments[0].position.start), d(Wt.getLast(t.endComments).position.end));
                var h = u.filter((function (e) { return null !== e; }));
                if (0 !== h.length) {
                    var m = h[0], g = Wt.getLast(h);
                    f(m.position.start), d(g.position.end), "leadingComments" in m && 0 !== m.leadingComments.length && f(m.leadingComments[0].position.start), "tag" in m && m.tag && f(m.tag.position.start), "anchor" in m && m.anchor && f(m.anchor.position.start), "trailingComment" in g && g.trailingComment && d(g.trailingComment.position.end);
                }
            } }; })); r(Rn), Rn.updatePositions; var In = o((function (e, t) { t.__esModule = !0, t.parse = function (e) { var t = lt.parseCST(e); Nn.addOrigRange(t); var n = t.map((function (e) { return new lt.Document({ merge: !0, keepCstNodes: !0 }).parse(e); })), r = [], o = { text: e, locator: new f.default(e), comments: r, transformOffset: function (e) { return On.transformOffset(e, o); }, transformRange: function (e) { return _n.transformRange(e, o); }, transformNode: function (e) { return xn.transformNode(e, o); }, transformContent: function (e) { return _t.transformContent(e, o); } }, i = n.find((function (e) { return 0 !== e.errors.length; })); if (i)
                throw kn.transformError(i.errors[0], o); n.forEach((function (e) { return vt.removeCstBlankLine(e.cstNode); })); var s = yt.createRoot(o.transformRange({ origStart: 0, origEnd: o.text.length }), n.map(o.transformNode), r); return dt.attachComments(s), Rn.updatePositions(s), Pn.removeFakeNodes(s), s; }; })); r(In), In.parse; var jn = o((function (e, t) { t.__esModule = !0, gt.__exportStar(In, t); })); r(jn); const { hasPragma: Bn } = { isPragma: function (e) { return /^\s*@(prettier|format)\s*$/.test(e); }, hasPragma: function (e) { return /^\s*#[^\n\S]*@(prettier|format)\s*?(\n|$)/.test(e); }, insertPragma: function (e) { return "# @format\n\n".concat(e); } }; var Ln = { parsers: { yaml: { astFormat: "yaml", parse: function (e) { try {
                            const t = jn.parse(e);
                            return delete t.comments, t;
                        }
                        catch (e) {
                            throw e && e.position ? function (e, t) { const n = new SyntaxError(e + " (" + t.start.line + ":" + t.start.column + ")"); return n.loc = t, n; }(e.message, e.position) : e;
                        } }, hasPragma: Bn, locStart: e => e.position.start.offset, locEnd: e => e.position.end.offset } } }, qn = Ln.parsers; e.default = Ln, e.parsers = qn, Object.defineProperty(e, "__esModule", { value: !0 }); }, "object" == typeof e && void 0 !== t ? s(e) : (o = [e], void 0 === (i = "function" == typeof (r = s) ? r.apply(e, o) : r) || (t.exports = i)); } }), A = v({ "../../node_modules/vscode-languageserver/node_modules/vscode-jsonrpc/lib/common/ral.js"(e) { var t; function n() { if (void 0 === t)
                throw new Error("No runtime abstraction layer installed"); return t; } Object.defineProperty(e, "__esModule", { value: !0 }), (n || (n = {})).install = function (e) { if (void 0 === e)
                throw new Error("No runtime abstraction layer provided"); t = e; }, e.default = n; } }), S = v({ "../../node_modules/vscode-languageserver/node_modules/vscode-jsonrpc/lib/common/disposable.js"(e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.Disposable = void 0, (e.Disposable || (e.Disposable = {})).create = function (e) { return { dispose: e }; }; } }), x = v({ "../../node_modules/vscode-languageserver/node_modules/vscode-jsonrpc/lib/common/events.js"(e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.Emitter = e.Event = void 0; var t = A(); !function (e) { const t = { dispose() { } }; e.None = function () { return t; }; }(e.Event || (e.Event = {})); var n = class {
                constructor(e) { this._options = e; }
                get event() { return this._event || (this._event = (e, r, o) => { this._callbacks || (this._callbacks = new class {
                    add(e, t = null, n) { this._callbacks || (this._callbacks = [], this._contexts = []), this._callbacks.push(e), this._contexts.push(t), Array.isArray(n) && n.push({ dispose: () => this.remove(e, t) }); }
                    remove(e, t = null) { if (!this._callbacks)
                        return; let n = !1; for (let r = 0, o = this._callbacks.length; r < o; r++)
                        if (this._callbacks[r] === e) {
                            if (this._contexts[r] === t)
                                return this._callbacks.splice(r, 1), void this._contexts.splice(r, 1);
                            n = !0;
                        } if (n)
                        throw new Error("When adding a listener with a context, you should remove it with the same context"); }
                    invoke(...e) { if (!this._callbacks)
                        return []; const n = [], r = this._callbacks.slice(0), o = this._contexts.slice(0); for (let i = 0, s = r.length; i < s; i++)
                        try {
                            n.push(r[i].apply(o[i], e));
                        }
                        catch (e) {
                            t.default().console.error(e);
                        } return n; }
                    isEmpty() { return !this._callbacks || 0 === this._callbacks.length; }
                    dispose() { this._callbacks = void 0, this._contexts = void 0; }
                }), this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty() && this._options.onFirstListenerAdd(this), this._callbacks.add(e, r); const i = { dispose: () => { this._callbacks && (this._callbacks.remove(e, r), i.dispose = n._noop, this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty() && this._options.onLastListenerRemove(this)); } }; return Array.isArray(o) && o.push(i), i; }), this._event; }
                fire(e) { this._callbacks && this._callbacks.invoke.call(this._callbacks, e); }
                dispose() { this._callbacks && (this._callbacks.dispose(), this._callbacks = void 0); }
            }; e.Emitter = n, n._noop = function () { }; } }), T = v({ "../../node_modules/vscode-languageserver/node_modules/vscode-jsonrpc/lib/common/messageBuffer.js"(e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.AbstractMessageBuffer = void 0, e.AbstractMessageBuffer = class {
                constructor(e = "utf-8") { this._encoding = e, this._chunks = [], this._totalLength = 0; }
                get encoding() { return this._encoding; }
                append(e) { const t = "string" == typeof e ? this.fromString(e, this._encoding) : e; this._chunks.push(t), this._totalLength += t.byteLength; }
                tryReadHeaders() { if (0 === this._chunks.length)
                    return; let e = 0, t = 0, n = 0, r = 0; e: for (; t < this._chunks.length;) {
                    const o = this._chunks[t];
                    for (n = 0; n < o.length;) {
                        switch (o[n]) {
                            case 13:
                                switch (e) {
                                    case 0:
                                        e = 1;
                                        break;
                                    case 2:
                                        e = 3;
                                        break;
                                    default: e = 0;
                                }
                                break;
                            case 10:
                                switch (e) {
                                    case 1:
                                        e = 2;
                                        break;
                                    case 3:
                                        e = 4, n++;
                                        break e;
                                    default: e = 0;
                                }
                                break;
                            default: e = 0;
                        }
                        n++;
                    }
                    r += o.byteLength, t++;
                } if (4 !== e)
                    return; const o = this._read(r + n), i = new Map, s = this.toString(o, "ascii").split("\r\n"); if (s.length < 2)
                    return i; for (let e = 0; e < s.length - 2; e++) {
                    const t = s[e], n = t.indexOf(":");
                    if (-1 === n)
                        throw new Error("Message header must separate key and value using :");
                    const r = t.substr(0, n), o = t.substr(n + 1).trim();
                    i.set(r, o);
                } return i; }
                tryReadBody(e) { if (!(this._totalLength < e))
                    return this._read(e); }
                get numberOfBytes() { return this._totalLength; }
                _read(e) { if (0 === e)
                    return this.emptyBuffer(); if (e > this._totalLength)
                    throw new Error("Cannot read so many bytes!"); if (this._chunks[0].byteLength === e) {
                    const t = this._chunks[0];
                    return this._chunks.shift(), this._totalLength -= e, this.asNative(t);
                } if (this._chunks[0].byteLength > e) {
                    const t = this._chunks[0], n = this.asNative(t, e);
                    return this._chunks[0] = t.slice(e), this._totalLength -= e, n;
                } const t = this.allocNative(e); let n = 0; for (; e > 0;) {
                    const r = this._chunks[0];
                    if (r.byteLength > e) {
                        const o = r.slice(0, e);
                        t.set(o, n), n += e, this._chunks[0] = r.slice(e), this._totalLength -= e, e -= e;
                    }
                    else
                        t.set(r, n), n += r.byteLength, this._chunks.shift(), this._totalLength -= r.byteLength, e -= r.byteLength;
                } return t; }
            }; } }), k = v({ "../../node_modules/vscode-languageserver/node_modules/vscode-jsonrpc/lib/browser/ril.js"(e) { Object.defineProperty(e, "__esModule", { value: !0 }); var t = A(), n = S(), r = x(), o = T(), i = class extends o.AbstractMessageBuffer {
                constructor(e = "utf-8") { super(e), this.asciiDecoder = new TextDecoder("ascii"); }
                emptyBuffer() { return i.emptyBuffer; }
                fromString(e, t) { return (new TextEncoder).encode(e); }
                toString(e, t) { return "ascii" === t ? this.asciiDecoder.decode(e) : new TextDecoder(t).decode(e); }
                asNative(e, t) { return void 0 === t ? e : e.slice(0, t); }
                allocNative(e) { return new Uint8Array(e); }
            }; i.emptyBuffer = new Uint8Array(0); var s = new TextEncoder, u = Object.freeze({ messageBuffer: Object.freeze({ create: e => new i(e) }), applicationJson: Object.freeze({ encoder: Object.freeze({ name: "application/json", encode: (e, t) => { if ("utf-8" !== t.charset)
                            throw new Error(`In a Browser environments only utf-8 text encding is supported. But got encoding: ${t.charset}`); return Promise.resolve(s.encode(JSON.stringify(e, void 0, 0))); } }), decoder: Object.freeze({ name: "application/json", decode: (e, t) => { if (!(e instanceof Uint8Array))
                            throw new Error("In a Browser environments only Uint8Arrays are supported."); return Promise.resolve(JSON.parse(new TextDecoder(t.charset).decode(e))); } }) }), stream: Object.freeze({ asReadableStream: e => new class {
                        constructor(e) { this.socket = e, this._onData = new r.Emitter, this._messageListener = e => { e.data.arrayBuffer().then((e => { this._onData.fire(new Uint8Array(e)); })); }, this.socket.addEventListener("message", this._messageListener); }
                        onClose(e) { return this.socket.addEventListener("close", e), n.Disposable.create((() => this.socket.removeEventListener("close", e))); }
                        onError(e) { return this.socket.addEventListener("error", e), n.Disposable.create((() => this.socket.removeEventListener("error", e))); }
                        onEnd(e) { return this.socket.addEventListener("end", e), n.Disposable.create((() => this.socket.removeEventListener("end", e))); }
                        onData(e) { return this._onData.event(e); }
                    }(e), asWritableStream: e => new class {
                        constructor(e) { this.socket = e; }
                        onClose(e) { return this.socket.addEventListener("close", e), n.Disposable.create((() => this.socket.removeEventListener("close", e))); }
                        onError(e) { return this.socket.addEventListener("error", e), n.Disposable.create((() => this.socket.removeEventListener("error", e))); }
                        onEnd(e) { return this.socket.addEventListener("end", e), n.Disposable.create((() => this.socket.removeEventListener("end", e))); }
                        write(e, t) { if ("string" == typeof e) {
                            if (void 0 !== t && "utf-8" !== t)
                                throw new Error(`In a Browser environments only utf-8 text encding is supported. But got encoding: ${t}`);
                            this.socket.send(e);
                        }
                        else
                            this.socket.send(e); return Promise.resolve(); }
                        end() { this.socket.close(); }
                    }(e) }), console: a, timer: Object.freeze({ setTimeout: (e, t, ...n) => setTimeout(e, t, ...n), clearTimeout(e) { clearTimeout(e); }, setImmediate: (e, ...t) => setTimeout(e, 0, ...t), clearImmediate(e) { clearTimeout(e); } }) }); function c() { return u; } (c || (c = {})).install = function () { t.default.install(u); }, e.default = c; } }), F = v({ "../../node_modules/vscode-languageserver/node_modules/vscode-jsonrpc/lib/common/is.js"(e) { function t(e) { return "string" == typeof e || e instanceof String; } function n(e) { return Array.isArray(e); } Object.defineProperty(e, "__esModule", { value: !0 }), e.stringArray = e.array = e.func = e.error = e.number = e.string = e.boolean = void 0, e.boolean = function (e) { return !0 === e || !1 === e; }, e.string = t, e.number = function (e) { return "number" == typeof e || e instanceof Number; }, e.error = function (e) { return e instanceof Error; }, e.func = function (e) { return "function" == typeof e; }, e.array = n, e.stringArray = function (e) { return n(e) && e.every((e => t(e))); }; } }), O = v({ "../../node_modules/vscode-languageserver/node_modules/vscode-jsonrpc/lib/common/messages.js"(e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.isResponseMessage = e.isNotificationMessage = e.isRequestMessage = e.NotificationType9 = e.NotificationType8 = e.NotificationType7 = e.NotificationType6 = e.NotificationType5 = e.NotificationType4 = e.NotificationType3 = e.NotificationType2 = e.NotificationType1 = e.NotificationType0 = e.NotificationType = e.RequestType9 = e.RequestType8 = e.RequestType7 = e.RequestType6 = e.RequestType5 = e.RequestType4 = e.RequestType3 = e.RequestType2 = e.RequestType1 = e.RequestType = e.RequestType0 = e.AbstractMessageSignature = e.ParameterStructures = e.ResponseError = e.ErrorCodes = void 0; var t, n, r = F(); (n = t = e.ErrorCodes || (e.ErrorCodes = {})).ParseError = -32700, n.InvalidRequest = -32600, n.MethodNotFound = -32601, n.InvalidParams = -32602, n.InternalError = -32603, n.jsonrpcReservedErrorRangeStart = -32099, n.serverErrorStart = n.jsonrpcReservedErrorRangeStart, n.MessageWriteError = -32099, n.MessageReadError = -32098, n.ServerNotInitialized = -32002, n.UnknownErrorCode = -32001, n.jsonrpcReservedErrorRangeEnd = -32e3, n.serverErrorEnd = n.jsonrpcReservedErrorRangeEnd; var o = class extends Error {
                constructor(e, n, i) { super(n), this.code = r.number(e) ? e : t.UnknownErrorCode, this.data = i, Object.setPrototypeOf(this, o.prototype); }
                toJson() { return { code: this.code, message: this.message, data: this.data }; }
            }; e.ResponseError = o; var i = class {
                constructor(e) { this.kind = e; }
                static is(e) { return e === i.auto || e === i.byName || e === i.byPosition; }
                toString() { return this.kind; }
            }; e.ParameterStructures = i, i.auto = new i("auto"), i.byPosition = new i("byPosition"), i.byName = new i("byName"); var s = class {
                constructor(e, t) { this.method = e, this.numberOfParams = t; }
                get parameterStructures() { return i.auto; }
            }; e.AbstractMessageSignature = s, e.RequestType0 = class extends s {
                constructor(e) { super(e, 0); }
            }, e.RequestType = class extends s {
                constructor(e, t = i.auto) { super(e, 1), this._parameterStructures = t; }
                get parameterStructures() { return this._parameterStructures; }
            }, e.RequestType1 = class extends s {
                constructor(e, t = i.auto) { super(e, 1), this._parameterStructures = t; }
                get parameterStructures() { return this._parameterStructures; }
            }, e.RequestType2 = class extends s {
                constructor(e) { super(e, 2); }
            }, e.RequestType3 = class extends s {
                constructor(e) { super(e, 3); }
            }, e.RequestType4 = class extends s {
                constructor(e) { super(e, 4); }
            }, e.RequestType5 = class extends s {
                constructor(e) { super(e, 5); }
            }, e.RequestType6 = class extends s {
                constructor(e) { super(e, 6); }
            }, e.RequestType7 = class extends s {
                constructor(e) { super(e, 7); }
            }, e.RequestType8 = class extends s {
                constructor(e) { super(e, 8); }
            }, e.RequestType9 = class extends s {
                constructor(e) { super(e, 9); }
            }, e.NotificationType = class extends s {
                constructor(e, t = i.auto) { super(e, 1), this._parameterStructures = t; }
                get parameterStructures() { return this._parameterStructures; }
            }, e.NotificationType0 = class extends s {
                constructor(e) { super(e, 0); }
            }, e.NotificationType1 = class extends s {
                constructor(e, t = i.auto) { super(e, 1), this._parameterStructures = t; }
                get parameterStructures() { return this._parameterStructures; }
            }, e.NotificationType2 = class extends s {
                constructor(e) { super(e, 2); }
            }, e.NotificationType3 = class extends s {
                constructor(e) { super(e, 3); }
            }, e.NotificationType4 = class extends s {
                constructor(e) { super(e, 4); }
            }, e.NotificationType5 = class extends s {
                constructor(e) { super(e, 5); }
            }, e.NotificationType6 = class extends s {
                constructor(e) { super(e, 6); }
            }, e.NotificationType7 = class extends s {
                constructor(e) { super(e, 7); }
            }, e.NotificationType8 = class extends s {
                constructor(e) { super(e, 8); }
            }, e.NotificationType9 = class extends s {
                constructor(e) { super(e, 9); }
            }, e.isRequestMessage = function (e) { const t = e; return t && r.string(t.method) && (r.string(t.id) || r.number(t.id)); }, e.isNotificationMessage = function (e) { const t = e; return t && r.string(t.method) && void 0 === e.id; }, e.isResponseMessage = function (e) { const t = e; return t && (void 0 !== t.result || !!t.error) && (r.string(t.id) || r.number(t.id) || null === t.id); }; } }), _ = v({ "../../node_modules/vscode-languageserver/node_modules/vscode-jsonrpc/lib/common/cancellation.js"(e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.CancellationTokenSource = e.CancellationToken = void 0; var t, n, r = A(), o = F(), i = x(); (n = t = e.CancellationToken || (e.CancellationToken = {})).None = Object.freeze({ isCancellationRequested: !1, onCancellationRequested: i.Event.None }), n.Cancelled = Object.freeze({ isCancellationRequested: !0, onCancellationRequested: i.Event.None }), n.is = function (e) { const t = e; return t && (t === n.None || t === n.Cancelled || o.boolean(t.isCancellationRequested) && !!t.onCancellationRequested); }; var s = Object.freeze((function (e, t) { const n = r.default().timer.setTimeout(e.bind(t), 0); return { dispose() { r.default().timer.clearTimeout(n); } }; })), a = class {
                constructor() { this._isCancelled = !1; }
                cancel() { this._isCancelled || (this._isCancelled = !0, this._emitter && (this._emitter.fire(void 0), this.dispose())); }
                get isCancellationRequested() { return this._isCancelled; }
                get onCancellationRequested() { return this._isCancelled ? s : (this._emitter || (this._emitter = new i.Emitter), this._emitter.event); }
                dispose() { this._emitter && (this._emitter.dispose(), this._emitter = void 0); }
            }; e.CancellationTokenSource = class {
                get token() { return this._token || (this._token = new a), this._token; }
                cancel() { this._token ? this._token.cancel() : this._token = t.Cancelled; }
                dispose() { this._token ? this._token instanceof a && this._token.dispose() : this._token = t.None; }
            }; } }), N = v({ "../../node_modules/vscode-languageserver/node_modules/vscode-jsonrpc/lib/common/messageReader.js"(e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.ReadableStreamMessageReader = e.AbstractMessageReader = e.MessageReader = void 0; var t = A(), n = F(), r = x(); (e.MessageReader || (e.MessageReader = {})).is = function (e) { let t = e; return t && n.func(t.listen) && n.func(t.dispose) && n.func(t.onError) && n.func(t.onClose) && n.func(t.onPartialMessage); }; var o, i = class {
                constructor() { this.errorEmitter = new r.Emitter, this.closeEmitter = new r.Emitter, this.partialMessageEmitter = new r.Emitter; }
                dispose() { this.errorEmitter.dispose(), this.closeEmitter.dispose(); }
                get onError() { return this.errorEmitter.event; }
                fireError(e) { this.errorEmitter.fire(this.asError(e)); }
                get onClose() { return this.closeEmitter.event; }
                fireClose() { this.closeEmitter.fire(void 0); }
                get onPartialMessage() { return this.partialMessageEmitter.event; }
                firePartialMessage(e) { this.partialMessageEmitter.fire(e); }
                asError(e) { return e instanceof Error ? e : new Error(`Reader received error. Reason: ${n.string(e.message) ? e.message : "unknown"}`); }
            }; e.AbstractMessageReader = i, (o || (o = {})).fromOptions = function (e) { var n; let r, o; const i = new Map; let s; const a = new Map; if (void 0 === e || "string" == typeof e)
                r = null != e ? e : "utf-8";
            else {
                if (r = null !== (n = e.charset) && void 0 !== n ? n : "utf-8", void 0 !== e.contentDecoder && (o = e.contentDecoder, i.set(o.name, o)), void 0 !== e.contentDecoders)
                    for (const t of e.contentDecoders)
                        i.set(t.name, t);
                if (void 0 !== e.contentTypeDecoder && (s = e.contentTypeDecoder, a.set(s.name, s)), void 0 !== e.contentTypeDecoders)
                    for (const t of e.contentTypeDecoders)
                        a.set(t.name, t);
            } return void 0 === s && (s = t.default().applicationJson.decoder, a.set(s.name, s)), { charset: r, contentDecoder: o, contentDecoders: i, contentTypeDecoder: s, contentTypeDecoders: a }; }, e.ReadableStreamMessageReader = class extends i {
                constructor(e, n) { super(), this.readable = e, this.options = o.fromOptions(n), this.buffer = t.default().messageBuffer.create(this.options.charset), this._partialMessageTimeout = 1e4, this.nextMessageLength = -1, this.messageToken = 0; }
                set partialMessageTimeout(e) { this._partialMessageTimeout = e; }
                get partialMessageTimeout() { return this._partialMessageTimeout; }
                listen(e) { this.nextMessageLength = -1, this.messageToken = 0, this.partialMessageTimer = void 0, this.callback = e; const t = this.readable.onData((e => { this.onData(e); })); return this.readable.onError((e => this.fireError(e))), this.readable.onClose((() => this.fireClose())), t; }
                onData(e) { for (this.buffer.append(e);;) {
                    if (-1 === this.nextMessageLength) {
                        const e = this.buffer.tryReadHeaders();
                        if (!e)
                            return;
                        const t = e.get("Content-Length");
                        if (!t)
                            throw new Error("Header must provide a Content-Length property.");
                        const n = parseInt(t);
                        if (isNaN(n))
                            throw new Error("Content-Length value must be a number.");
                        this.nextMessageLength = n;
                    }
                    const e = this.buffer.tryReadBody(this.nextMessageLength);
                    if (void 0 === e)
                        return void this.setPartialMessageTimer();
                    let t;
                    this.clearPartialMessageTimer(), this.nextMessageLength = -1, t = void 0 !== this.options.contentDecoder ? this.options.contentDecoder.decode(e) : Promise.resolve(e), t.then((e => { this.options.contentTypeDecoder.decode(e, this.options).then((e => { this.callback(e); }), (e => { this.fireError(e); })); }), (e => { this.fireError(e); }));
                } }
                clearPartialMessageTimer() { this.partialMessageTimer && (t.default().timer.clearTimeout(this.partialMessageTimer), this.partialMessageTimer = void 0); }
                setPartialMessageTimer() { this.clearPartialMessageTimer(), this._partialMessageTimeout <= 0 || (this.partialMessageTimer = t.default().timer.setTimeout(((e, t) => { this.partialMessageTimer = void 0, e === this.messageToken && (this.firePartialMessage({ messageToken: e, waitingTime: t }), this.setPartialMessageTimer()); }), this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout)); }
            }; } }), P = v({ "../../node_modules/vscode-languageserver/node_modules/vscode-jsonrpc/lib/common/semaphore.js"(e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.Semaphore = void 0; var t = A(); e.Semaphore = class {
                constructor(e = 1) { if (e <= 0)
                    throw new Error("Capacity must be greater than 0"); this._capacity = e, this._active = 0, this._waiting = []; }
                lock(e) { return new Promise(((t, n) => { this._waiting.push({ thunk: e, resolve: t, reject: n }), this.runNext(); })); }
                get active() { return this._active; }
                runNext() { 0 !== this._waiting.length && this._active !== this._capacity && t.default().timer.setImmediate((() => this.doRunNext())); }
                doRunNext() { if (0 === this._waiting.length || this._active === this._capacity)
                    return; const e = this._waiting.shift(); if (this._active++, this._active > this._capacity)
                    throw new Error("To many thunks active"); try {
                    const t = e.thunk();
                    t instanceof Promise ? t.then((t => { this._active--, e.resolve(t), this.runNext(); }), (t => { this._active--, e.reject(t), this.runNext(); })) : (this._active--, e.resolve(t), this.runNext());
                }
                catch (t) {
                    this._active--, e.reject(t), this.runNext();
                } }
            }; } }), M = v({ "../../node_modules/vscode-languageserver/node_modules/vscode-jsonrpc/lib/common/messageWriter.js"(e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.WriteableStreamMessageWriter = e.AbstractMessageWriter = e.MessageWriter = void 0; var t = A(), n = F(), r = P(), o = x(); (e.MessageWriter || (e.MessageWriter = {})).is = function (e) { let t = e; return t && n.func(t.dispose) && n.func(t.onClose) && n.func(t.onError) && n.func(t.write); }; var i, s = class {
                constructor() { this.errorEmitter = new o.Emitter, this.closeEmitter = new o.Emitter; }
                dispose() { this.errorEmitter.dispose(), this.closeEmitter.dispose(); }
                get onError() { return this.errorEmitter.event; }
                fireError(e, t, n) { this.errorEmitter.fire([this.asError(e), t, n]); }
                get onClose() { return this.closeEmitter.event; }
                fireClose() { this.closeEmitter.fire(void 0); }
                asError(e) { return e instanceof Error ? e : new Error(`Writer received error. Reason: ${n.string(e.message) ? e.message : "unknown"}`); }
            }; e.AbstractMessageWriter = s, (i || (i = {})).fromOptions = function (e) { var n, r; return void 0 === e || "string" == typeof e ? { charset: null != e ? e : "utf-8", contentTypeEncoder: t.default().applicationJson.encoder } : { charset: null !== (n = e.charset) && void 0 !== n ? n : "utf-8", contentEncoder: e.contentEncoder, contentTypeEncoder: null !== (r = e.contentTypeEncoder) && void 0 !== r ? r : t.default().applicationJson.encoder }; }, e.WriteableStreamMessageWriter = class extends s {
                constructor(e, t) { super(), this.writable = e, this.options = i.fromOptions(t), this.errorCount = 0, this.writeSemaphore = new r.Semaphore(1), this.writable.onError((e => this.fireError(e))), this.writable.onClose((() => this.fireClose())); }
                async write(e) { return this.writeSemaphore.lock((async () => this.options.contentTypeEncoder.encode(e, this.options).then((e => void 0 !== this.options.contentEncoder ? this.options.contentEncoder.encode(e) : e)).then((t => { const n = []; return n.push("Content-Length: ", t.byteLength.toString(), "\r\n"), n.push("\r\n"), this.doWrite(e, n, t); }), (e => { throw this.fireError(e), e; })))); }
                async doWrite(e, t, n) { try {
                    return await this.writable.write(t.join(""), "ascii"), this.writable.write(n);
                }
                catch (t) {
                    return this.handleError(t, e), Promise.reject(t);
                } }
                handleError(e, t) { this.errorCount++, this.fireError(e, t, this.errorCount); }
                end() { this.writable.end(); }
            }; } }), R = v({ "../../node_modules/vscode-languageserver/node_modules/vscode-jsonrpc/lib/common/linkedMap.js"(e) { var t, n; Object.defineProperty(e, "__esModule", { value: !0 }), e.LRUCache = e.LinkedMap = e.Touch = void 0, (n = t = e.Touch || (e.Touch = {})).None = 0, n.First = 1, n.AsOld = n.First, n.Last = 2, n.AsNew = n.Last; var r = class {
                constructor() { this[Symbol.toStringTag] = "LinkedMap", this._map = new Map, this._head = void 0, this._tail = void 0, this._size = 0, this._state = 0; }
                clear() { this._map.clear(), this._head = void 0, this._tail = void 0, this._size = 0, this._state++; }
                isEmpty() { return !this._head && !this._tail; }
                get size() { return this._size; }
                get first() { var e; return null === (e = this._head) || void 0 === e ? void 0 : e.value; }
                get last() { var e; return null === (e = this._tail) || void 0 === e ? void 0 : e.value; }
                has(e) { return this._map.has(e); }
                get(e, n = t.None) { const r = this._map.get(e); if (r)
                    return n !== t.None && this.touch(r, n), r.value; }
                set(e, n, r = t.None) { let o = this._map.get(e); if (o)
                    o.value = n, r !== t.None && this.touch(o, r);
                else {
                    switch (o = { key: e, value: n, next: void 0, previous: void 0 }, r) {
                        case t.None:
                            this.addItemLast(o);
                            break;
                        case t.First:
                            this.addItemFirst(o);
                            break;
                        case t.Last:
                        default: this.addItemLast(o);
                    }
                    this._map.set(e, o), this._size++;
                } return this; }
                delete(e) { return !!this.remove(e); }
                remove(e) { const t = this._map.get(e); if (t)
                    return this._map.delete(e), this.removeItem(t), this._size--, t.value; }
                shift() { if (!this._head && !this._tail)
                    return; if (!this._head || !this._tail)
                    throw new Error("Invalid list"); const e = this._head; return this._map.delete(e.key), this.removeItem(e), this._size--, e.value; }
                forEach(e, t) { const n = this._state; let r = this._head; for (; r;) {
                    if (t ? e.bind(t)(r.value, r.key, this) : e(r.value, r.key, this), this._state !== n)
                        throw new Error("LinkedMap got modified during iteration.");
                    r = r.next;
                } }
                keys() { const e = this, t = this._state; let n = this._head; const r = { [Symbol.iterator]: () => r, next() { if (e._state !== t)
                        throw new Error("LinkedMap got modified during iteration."); if (n) {
                        const e = { value: n.key, done: !1 };
                        return n = n.next, e;
                    } return { value: void 0, done: !0 }; } }; return r; }
                values() { const e = this, t = this._state; let n = this._head; const r = { [Symbol.iterator]: () => r, next() { if (e._state !== t)
                        throw new Error("LinkedMap got modified during iteration."); if (n) {
                        const e = { value: n.value, done: !1 };
                        return n = n.next, e;
                    } return { value: void 0, done: !0 }; } }; return r; }
                entries() { const e = this, t = this._state; let n = this._head; const r = { [Symbol.iterator]: () => r, next() { if (e._state !== t)
                        throw new Error("LinkedMap got modified during iteration."); if (n) {
                        const e = { value: [n.key, n.value], done: !1 };
                        return n = n.next, e;
                    } return { value: void 0, done: !0 }; } }; return r; }
                [Symbol.iterator]() { return this.entries(); }
                trimOld(e) { if (e >= this.size)
                    return; if (0 === e)
                    return void this.clear(); let t = this._head, n = this.size; for (; t && n > e;)
                    this._map.delete(t.key), t = t.next, n--; this._head = t, this._size = n, t && (t.previous = void 0), this._state++; }
                addItemFirst(e) { if (this._head || this._tail) {
                    if (!this._head)
                        throw new Error("Invalid list");
                    e.next = this._head, this._head.previous = e;
                }
                else
                    this._tail = e; this._head = e, this._state++; }
                addItemLast(e) { if (this._head || this._tail) {
                    if (!this._tail)
                        throw new Error("Invalid list");
                    e.previous = this._tail, this._tail.next = e;
                }
                else
                    this._head = e; this._tail = e, this._state++; }
                removeItem(e) { if (e === this._head && e === this._tail)
                    this._head = void 0, this._tail = void 0;
                else if (e === this._head) {
                    if (!e.next)
                        throw new Error("Invalid list");
                    e.next.previous = void 0, this._head = e.next;
                }
                else if (e === this._tail) {
                    if (!e.previous)
                        throw new Error("Invalid list");
                    e.previous.next = void 0, this._tail = e.previous;
                }
                else {
                    const t = e.next, n = e.previous;
                    if (!t || !n)
                        throw new Error("Invalid list");
                    t.previous = n, n.next = t;
                } e.next = void 0, e.previous = void 0, this._state++; }
                touch(e, n) { if (!this._head || !this._tail)
                    throw new Error("Invalid list"); if (n === t.First || n === t.Last)
                    if (n === t.First) {
                        if (e === this._head)
                            return;
                        const t = e.next, n = e.previous;
                        e === this._tail ? (n.next = void 0, this._tail = n) : (t.previous = n, n.next = t), e.previous = void 0, e.next = this._head, this._head.previous = e, this._head = e, this._state++;
                    }
                    else if (n === t.Last) {
                        if (e === this._tail)
                            return;
                        const t = e.next, n = e.previous;
                        e === this._head ? (t.previous = void 0, this._head = t) : (t.previous = n, n.next = t), e.next = void 0, e.previous = this._tail, this._tail.next = e, this._tail = e, this._state++;
                    } }
                toJSON() { const e = []; return this.forEach(((t, n) => { e.push([n, t]); })), e; }
                fromJSON(e) { this.clear(); for (const [t, n] of e)
                    this.set(t, n); }
            }; e.LinkedMap = r, e.LRUCache = class extends r {
                constructor(e, t = 1) { super(), this._limit = e, this._ratio = Math.min(Math.max(0, t), 1); }
                get limit() { return this._limit; }
                set limit(e) { this._limit = e, this.checkTrim(); }
                get ratio() { return this._ratio; }
                set ratio(e) { this._ratio = Math.min(Math.max(0, e), 1), this.checkTrim(); }
                get(e, n = t.AsNew) { return super.get(e, n); }
                peek(e) { return super.get(e, t.None); }
                set(e, n) { return super.set(e, n, t.Last), this.checkTrim(), this; }
                checkTrim() { this.size > this._limit && this.trimOld(Math.round(this._limit * this._ratio)); }
            }; } }), I = v({ "../../node_modules/vscode-languageserver/node_modules/vscode-jsonrpc/lib/common/connection.js"(e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.createMessageConnection = e.ConnectionOptions = e.CancellationStrategy = e.CancellationSenderStrategy = e.CancellationReceiverStrategy = e.ConnectionStrategy = e.ConnectionError = e.ConnectionErrors = e.LogTraceNotification = e.SetTraceNotification = e.TraceFormat = e.Trace = e.NullLogger = e.ProgressType = void 0; var t, n, r, o, i, s, a, u, c, l, p, f = A(), d = F(), h = O(), m = R(), g = x(), y = _(); (t || (t = {})).type = new h.NotificationType("$/cancelRequest"), (n || (n = {})).type = new h.NotificationType("$/progress"), e.ProgressType = class {
                constructor() { }
            }, (r || (r = {})).is = function (e) { return d.func(e); }, e.NullLogger = Object.freeze({ error: () => { }, warn: () => { }, info: () => { }, log: () => { } }), (i = o = e.Trace || (e.Trace = {}))[i.Off = 0] = "Off", i[i.Messages = 1] = "Messages", i[i.Verbose = 2] = "Verbose", function (e) { e.fromString = function (t) { if (!d.string(t))
                return e.Off; switch (t = t.toLowerCase()) {
                case "off":
                default: return e.Off;
                case "messages": return e.Messages;
                case "verbose": return e.Verbose;
            } }, e.toString = function (t) { switch (t) {
                case e.Off: return "off";
                case e.Messages: return "messages";
                case e.Verbose: return "verbose";
                default: return "off";
            } }; }(o = e.Trace || (e.Trace = {})), (a = e.TraceFormat || (e.TraceFormat = {})).Text = "text", a.JSON = "json", function (e) { e.fromString = function (t) { return "json" === (t = t.toLowerCase()) ? e.JSON : e.Text; }; }(s = e.TraceFormat || (e.TraceFormat = {})), (u = e.SetTraceNotification || (e.SetTraceNotification = {})).type = new h.NotificationType("$/setTrace"), (c = e.LogTraceNotification || (e.LogTraceNotification = {})).type = new h.NotificationType("$/logTrace"), (p = l = e.ConnectionErrors || (e.ConnectionErrors = {}))[p.Closed = 1] = "Closed", p[p.Disposed = 2] = "Disposed", p[p.AlreadyListening = 3] = "AlreadyListening"; var v, b, D, E, C, w, S, T, k, N = class extends Error {
                constructor(e, t) { super(t), this.code = e, Object.setPrototypeOf(this, N.prototype); }
            }; e.ConnectionError = N, (v = e.ConnectionStrategy || (e.ConnectionStrategy = {})).is = function (e) { const t = e; return t && d.func(t.cancelUndispatched); }, (D = b = e.CancellationReceiverStrategy || (e.CancellationReceiverStrategy = {})).Message = Object.freeze({ createCancellationTokenSource: e => new y.CancellationTokenSource }), D.is = function (e) { const t = e; return t && d.func(t.createCancellationTokenSource); }, (C = E = e.CancellationSenderStrategy || (e.CancellationSenderStrategy = {})).Message = Object.freeze({ sendCancellation(e, n) { e.sendNotification(t.type, { id: n }); }, cleanup(e) { } }), C.is = function (e) { const t = e; return t && d.func(t.sendCancellation) && d.func(t.cleanup); }, (S = w = e.CancellationStrategy || (e.CancellationStrategy = {})).Message = Object.freeze({ receiver: b.Message, sender: E.Message }), S.is = function (e) { const t = e; return t && b.is(t.receiver) && E.is(t.sender); }, (e.ConnectionOptions || (e.ConnectionOptions = {})).is = function (e) { const t = e; return t && (w.is(t.cancellationStrategy) || v.is(t.connectionStrategy)); }, (k = T || (T = {}))[k.New = 1] = "New", k[k.Listening = 2] = "Listening", k[k.Closed = 3] = "Closed", k[k.Disposed = 4] = "Disposed", e.createMessageConnection = function (i, a, p, v) { const b = void 0 !== p ? p : e.NullLogger; let D = 0, E = 0, C = 0; const A = "2.0"; let S; const x = Object.create(null); let k; const F = Object.create(null), O = new Map; let _, P, M = new m.LinkedMap, R = Object.create(null), I = Object.create(null), j = o.Off, B = s.Text, L = T.New; const q = new g.Emitter, $ = new g.Emitter, U = new g.Emitter, V = new g.Emitter, W = new g.Emitter, K = v && v.cancellationStrategy ? v.cancellationStrategy : w.Message; function z(e) { if (null === e)
                throw new Error("Can't send requests with id null since the response can't be correlated."); return "req-" + e.toString(); } function H(e) { } function Y() { return L === T.Listening; } function J() { return L === T.Closed; } function G() { return L === T.Disposed; } function X() { L !== T.New && L !== T.Listening || (L = T.Closed, $.fire(void 0)); } function Q() { _ || 0 === M.size || (_ = f.default().timer.setImmediate((() => { _ = void 0, function () { if (0 === M.size)
                return; const e = M.shift(); try {
                h.isRequestMessage(e) ? function (e) { if (G())
                    return; function t(t, n, r) { const o = { jsonrpc: A, id: e.id }; t instanceof h.ResponseError ? o.error = t.toJson() : o.result = void 0 === t ? null : t, ee(o, n, r), a.write(o); } function n(t, n, r) { const o = { jsonrpc: A, id: e.id, error: t.toJson() }; ee(o, n, r), a.write(o); } !function (e) { if (j !== o.Off && P)
                    if (B === s.Text) {
                        let t;
                        j === o.Verbose && e.params && (t = `Params: ${JSON.stringify(e.params, null, 4)}\n\n`), P.log(`Received request '${e.method} - (${e.id})'.`, t);
                    }
                    else
                        te("receive-request", e); }(e); const r = x[e.method]; let i, u; r && (i = r.type, u = r.handler); const c = Date.now(); if (u || S) {
                    const r = String(e.id), o = K.receiver.createCancellationTokenSource(r);
                    I[r] = o;
                    try {
                        let s;
                        if (u)
                            if (void 0 === e.params) {
                                if (void 0 !== i && 0 !== i.numberOfParams)
                                    return void n(new h.ResponseError(h.ErrorCodes.InvalidParams, `Request ${e.method} defines ${i.numberOfParams} params but recevied none.`), e.method, c);
                                s = u(o.token);
                            }
                            else if (Array.isArray(e.params)) {
                                if (void 0 !== i && i.parameterStructures === h.ParameterStructures.byName)
                                    return void n(new h.ResponseError(h.ErrorCodes.InvalidParams, `Request ${e.method} defines parameters by name but received parameters by position`), e.method, c);
                                s = u(...e.params, o.token);
                            }
                            else {
                                if (void 0 !== i && i.parameterStructures === h.ParameterStructures.byPosition)
                                    return void n(new h.ResponseError(h.ErrorCodes.InvalidParams, `Request ${e.method} defines parameters by position but received parameters by name`), e.method, c);
                                s = u(e.params, o.token);
                            }
                        else
                            S && (s = S(e.method, e.params, o.token));
                        const l = s;
                        s ? l.then ? l.then((n => { delete I[r], t(n, e.method, c); }), (t => { delete I[r], t instanceof h.ResponseError ? n(t, e.method, c) : t && d.string(t.message) ? n(new h.ResponseError(h.ErrorCodes.InternalError, `Request ${e.method} failed with message: ${t.message}`), e.method, c) : n(new h.ResponseError(h.ErrorCodes.InternalError, `Request ${e.method} failed unexpectedly without providing any details.`), e.method, c); })) : (delete I[r], t(s, e.method, c)) : (delete I[r], function (t, n, r) { void 0 === t && (t = null); const o = { jsonrpc: A, id: e.id, result: t }; ee(o, n, r), a.write(o); }(s, e.method, c));
                    }
                    catch (o) {
                        delete I[r], o instanceof h.ResponseError ? t(o, e.method, c) : o && d.string(o.message) ? n(new h.ResponseError(h.ErrorCodes.InternalError, `Request ${e.method} failed with message: ${o.message}`), e.method, c) : n(new h.ResponseError(h.ErrorCodes.InternalError, `Request ${e.method} failed unexpectedly without providing any details.`), e.method, c);
                    }
                }
                else
                    n(new h.ResponseError(h.ErrorCodes.MethodNotFound, `Unhandled method ${e.method}`), e.method, c); }(e) : h.isNotificationMessage(e) ? function (e) { if (G())
                    return; let n, r; if (e.method === t.type.method)
                    r = e => { const t = e.id, n = I[String(t)]; n && n.cancel(); };
                else {
                    const t = F[e.method];
                    t && (r = t.handler, n = t.type);
                } if (r || k)
                    try {
                        !function (e) { if (j !== o.Off && P && e.method !== c.type.method)
                            if (B === s.Text) {
                                let t;
                                j === o.Verbose && (t = e.params ? `Params: ${JSON.stringify(e.params, null, 4)}\n\n` : "No parameters provided.\n\n"), P.log(`Received notification '${e.method}'.`, t);
                            }
                            else
                                te("receive-notification", e); }(e), r ? void 0 === e.params ? (void 0 !== n && 0 !== n.numberOfParams && n.parameterStructures !== h.ParameterStructures.byName && b.error(`Notification ${e.method} defines ${n.numberOfParams} params but recevied none.`), r()) : Array.isArray(e.params) ? (void 0 !== n && (n.parameterStructures === h.ParameterStructures.byName && b.error(`Notification ${e.method} defines parameters by name but received parameters by position`), n.numberOfParams !== e.params.length && b.error(`Notification ${e.method} defines ${n.numberOfParams} params but received ${e.params.length} argumennts`)), r(...e.params)) : (void 0 !== n && n.parameterStructures === h.ParameterStructures.byPosition && b.error(`Notification ${e.method} defines parameters by position but received parameters by name`), r(e.params)) : k && k(e.method, e.params);
                    }
                    catch (t) {
                        t.message ? b.error(`Notification handler '${e.method}' failed with message: ${t.message}`) : b.error(`Notification handler '${e.method}' failed unexpectedly.`);
                    }
                else
                    U.fire(e); }(e) : h.isResponseMessage(e) ? function (e) { if (!G())
                    if (null === e.id)
                        e.error ? b.error(`Received response message without id: Error is: \n${JSON.stringify(e.error, void 0, 4)}`) : b.error("Received response message without id. No further error information provided.");
                    else {
                        const t = String(e.id), n = R[t];
                        if (function (e, t) { if (j !== o.Off && P)
                            if (B === s.Text) {
                                let n;
                                if (j === o.Verbose && (e.error && e.error.data ? n = `Error data: ${JSON.stringify(e.error.data, null, 4)}\n\n` : e.result ? n = `Result: ${JSON.stringify(e.result, null, 4)}\n\n` : void 0 === e.error && (n = "No result returned.\n\n")), t) {
                                    const r = e.error ? ` Request failed: ${e.error.message} (${e.error.code}).` : "";
                                    P.log(`Received response '${t.method} - (${e.id})' in ${Date.now() - t.timerStart}ms.${r}`, n);
                                }
                                else
                                    P.log(`Received response ${e.id} without active response promise.`, n);
                            }
                            else
                                te("receive-response", e); }(e, n), n) {
                            delete R[t];
                            try {
                                if (e.error) {
                                    const t = e.error;
                                    n.reject(new h.ResponseError(t.code, t.message, t.data));
                                }
                                else {
                                    if (void 0 === e.result)
                                        throw new Error("Should never happen.");
                                    n.resolve(e.result);
                                }
                            }
                            catch (e) {
                                e.message ? b.error(`Response handler '${n.method}' failed with message: ${e.message}`) : b.error(`Response handler '${n.method}' failed unexpectedly.`);
                            }
                        }
                    } }(e) : function (e) { if (!e)
                    return void b.error("Received empty message."); b.error(`Received message which is neither a response nor a notification message:\n${JSON.stringify(e, null, 4)}`); const t = e; if (d.string(t.id) || d.number(t.id)) {
                    const e = String(t.id), n = R[e];
                    n && n.reject(new Error("The received response has neither a result nor an error property."));
                } }(e);
            }
            finally {
                Q();
            } }(); }))); } i.onClose(X), i.onError((function (e) { q.fire([e, void 0, void 0]); })), a.onClose(X), a.onError((function (e) { q.fire(e); })); const Z = e => { try {
                if (h.isNotificationMessage(e) && e.method === t.type.method) {
                    const t = z(e.params.id), n = M.get(t);
                    if (h.isRequestMessage(n)) {
                        const r = null == v ? void 0 : v.connectionStrategy, o = r && r.cancelUndispatched ? r.cancelUndispatched(n, H) : void 0;
                        if (o && (void 0 !== o.error || void 0 !== o.result))
                            return M.delete(t), o.id = n.id, ee(o, e.method, Date.now()), void a.write(o);
                    }
                }
                !function (e, t) { var n; h.isRequestMessage(t) ? e.set(z(t.id), t) : h.isResponseMessage(t) ? e.set(null === (n = t.id) ? "res-unknown-" + (++C).toString() : "res-" + n.toString(), t) : e.set("not-" + (++E).toString(), t); }(M, e);
            }
            finally {
                Q();
            } }; function ee(e, t, n) { if (j !== o.Off && P)
                if (B === s.Text) {
                    let r;
                    j === o.Verbose && (e.error && e.error.data ? r = `Error data: ${JSON.stringify(e.error.data, null, 4)}\n\n` : e.result ? r = `Result: ${JSON.stringify(e.result, null, 4)}\n\n` : void 0 === e.error && (r = "No result returned.\n\n")), P.log(`Sending response '${t} - (${e.id})'. Processing request took ${Date.now() - n}ms`, r);
                }
                else
                    te("send-response", e); } function te(e, t) { if (!P || j === o.Off)
                return; const n = { isLSPMessage: !0, type: e, message: t, timestamp: Date.now() }; P.log(n); } function ne() { if (J())
                throw new N(l.Closed, "Connection is closed."); if (G())
                throw new N(l.Disposed, "Connection is disposed."); } function re(e) { return void 0 === e ? null : e; } function oe(e) { return null === e ? void 0 : e; } function ie(e) { return null != e && !Array.isArray(e) && "object" == typeof e; } function se(e, t) { switch (e) {
                case h.ParameterStructures.auto: return ie(t) ? oe(t) : [re(t)];
                case h.ParameterStructures.byName:
                    if (!ie(t))
                        throw new Error("Recevied parameters by name but param is not an object literal.");
                    return oe(t);
                case h.ParameterStructures.byPosition: return [re(t)];
                default: throw new Error(`Unknown parameter structure ${e.toString()}`);
            } } function ae(e, t) { let n; const r = e.numberOfParams; switch (r) {
                case 0:
                    n = void 0;
                    break;
                case 1:
                    n = se(e.parameterStructures, t[0]);
                    break;
                default:
                    n = [];
                    for (let e = 0; e < t.length && e < r; e++)
                        n.push(re(t[e]));
                    if (t.length < r)
                        for (let e = t.length; e < r; e++)
                            n.push(null);
            } return n; } const ue = { sendNotification: (e, ...t) => { let n, r; if (ne(), d.string(e)) {
                    n = e;
                    const o = t[0];
                    let i = 0, s = h.ParameterStructures.auto;
                    h.ParameterStructures.is(o) && (i = 1, s = o);
                    let a = t.length;
                    const u = a - i;
                    switch (u) {
                        case 0:
                            r = void 0;
                            break;
                        case 1:
                            r = se(s, t[i]);
                            break;
                        default:
                            if (s === h.ParameterStructures.byName)
                                throw new Error(`Recevied ${u} parameters for 'by Name' notification parameter structure.`);
                            r = t.slice(i, a).map((e => re(e)));
                    }
                }
                else {
                    const o = t;
                    n = e.method, r = ae(e, o);
                } const i = { jsonrpc: A, method: n, params: r }; !function (e) { if (j !== o.Off && P)
                    if (B === s.Text) {
                        let t;
                        j === o.Verbose && (t = e.params ? `Params: ${JSON.stringify(e.params, null, 4)}\n\n` : "No parameters provided.\n\n"), P.log(`Sending notification '${e.method}'.`, t);
                    }
                    else
                        te("send-notification", e); }(i), a.write(i); }, onNotification: (e, t) => { let n; return ne(), d.func(e) ? k = e : t && (d.string(e) ? (n = e, F[e] = { type: void 0, handler: t }) : (n = e.method, F[e.method] = { type: e, handler: t })), { dispose: () => { void 0 !== n ? delete F[n] : k = void 0; } }; }, onProgress: (e, t, n) => { if (O.has(t))
                    throw new Error(`Progress handler for token ${t} already registered`); return O.set(t, n), { dispose: () => { O.delete(t); } }; }, sendProgress: (e, t, r) => { ue.sendNotification(n.type, { token: t, value: r }); }, onUnhandledProgress: V.event, sendRequest: (e, ...t) => { let n, r, i; if (ne(), function () { if (!Y())
                    throw new Error("Call listen() first."); }(), d.string(e)) {
                    n = e;
                    const o = t[0], s = t[t.length - 1];
                    let a = 0, u = h.ParameterStructures.auto;
                    h.ParameterStructures.is(o) && (a = 1, u = o);
                    let c = t.length;
                    y.CancellationToken.is(s) && (c -= 1, i = s);
                    const l = c - a;
                    switch (l) {
                        case 0:
                            r = void 0;
                            break;
                        case 1:
                            r = se(u, t[a]);
                            break;
                        default:
                            if (u === h.ParameterStructures.byName)
                                throw new Error(`Recevied ${l} parameters for 'by Name' request parameter structure.`);
                            r = t.slice(a, c).map((e => re(e)));
                    }
                }
                else {
                    const o = t;
                    n = e.method, r = ae(e, o);
                    const s = e.numberOfParams;
                    i = y.CancellationToken.is(o[s]) ? o[s] : void 0;
                } const u = D++; let c; return i && (c = i.onCancellationRequested((() => { K.sender.sendCancellation(ue, u); }))), new Promise(((e, t) => { const i = { jsonrpc: A, id: u, method: n, params: r }; let l = { method: n, timerStart: Date.now(), resolve: t => { e(t), K.sender.cleanup(u), null == c || c.dispose(); }, reject: e => { t(e), K.sender.cleanup(u), null == c || c.dispose(); } }; !function (e) { if (j !== o.Off && P)
                    if (B === s.Text) {
                        let t;
                        j === o.Verbose && e.params && (t = `Params: ${JSON.stringify(e.params, null, 4)}\n\n`), P.log(`Sending request '${e.method} - (${e.id})'.`, t);
                    }
                    else
                        te("send-request", e); }(i); try {
                    a.write(i);
                }
                catch (e) {
                    l.reject(new h.ResponseError(h.ErrorCodes.MessageWriteError, e.message ? e.message : "Unknown reason")), l = null;
                } l && (R[String(u)] = l); })); }, onRequest: (e, t) => { ne(); let n = null; return r.is(e) ? (n = void 0, S = e) : d.string(e) ? (n = null, void 0 !== t && (n = e, x[e] = { handler: t, type: void 0 })) : void 0 !== t && (n = e.method, x[e.method] = { type: e, handler: t }), { dispose: () => { null !== n && (void 0 !== n ? delete x[n] : S = void 0); } }; }, trace: (e, t, n) => { let r = !1, i = s.Text; void 0 !== n && (d.boolean(n) ? r = n : (r = n.sendNotification || !1, i = n.traceFormat || s.Text)), j = e, B = i, P = j === o.Off ? void 0 : t, !r || J() || G() || ue.sendNotification(u.type, { value: o.toString(e) }); }, onError: q.event, onClose: $.event, onUnhandledNotification: U.event, onDispose: W.event, end: () => { a.end(); }, dispose: () => { if (G())
                    return; L = T.Disposed, W.fire(void 0); const e = new Error("Connection got disposed."); Object.keys(R).forEach((t => { R[t].reject(e); })), R = Object.create(null), I = Object.create(null), M = new m.LinkedMap, d.func(a.dispose) && a.dispose(), d.func(i.dispose) && i.dispose(); }, listen: () => { ne(), function () { if (Y())
                    throw new N(l.AlreadyListening, "Connection is already listening"); }(), L = T.Listening, i.listen(Z); }, inspect: () => { f.default().console.log("inspect"); } }; return ue.onNotification(c.type, (e => { j !== o.Off && P && P.log(e.message, j === o.Verbose ? e.verbose : void 0); })), ue.onNotification(n.type, (e => { const t = O.get(e.token); t ? t(e.value) : V.fire(e); })), ue; }; } }), j = v({ "../../node_modules/vscode-languageserver/node_modules/vscode-jsonrpc/lib/common/api.js"(e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.CancellationSenderStrategy = e.CancellationReceiverStrategy = e.ConnectionError = e.ConnectionErrors = e.LogTraceNotification = e.SetTraceNotification = e.TraceFormat = e.Trace = e.ProgressType = e.createMessageConnection = e.NullLogger = e.ConnectionOptions = e.ConnectionStrategy = e.WriteableStreamMessageWriter = e.AbstractMessageWriter = e.MessageWriter = e.ReadableStreamMessageReader = e.AbstractMessageReader = e.MessageReader = e.CancellationToken = e.CancellationTokenSource = e.Emitter = e.Event = e.Disposable = e.ParameterStructures = e.NotificationType9 = e.NotificationType8 = e.NotificationType7 = e.NotificationType6 = e.NotificationType5 = e.NotificationType4 = e.NotificationType3 = e.NotificationType2 = e.NotificationType1 = e.NotificationType0 = e.NotificationType = e.ErrorCodes = e.ResponseError = e.RequestType9 = e.RequestType8 = e.RequestType7 = e.RequestType6 = e.RequestType5 = e.RequestType4 = e.RequestType3 = e.RequestType2 = e.RequestType1 = e.RequestType0 = e.RequestType = e.RAL = void 0, e.CancellationStrategy = void 0; var t = O(); Object.defineProperty(e, "RequestType", { enumerable: !0, get: function () { return t.RequestType; } }), Object.defineProperty(e, "RequestType0", { enumerable: !0, get: function () { return t.RequestType0; } }), Object.defineProperty(e, "RequestType1", { enumerable: !0, get: function () { return t.RequestType1; } }), Object.defineProperty(e, "RequestType2", { enumerable: !0, get: function () { return t.RequestType2; } }), Object.defineProperty(e, "RequestType3", { enumerable: !0, get: function () { return t.RequestType3; } }), Object.defineProperty(e, "RequestType4", { enumerable: !0, get: function () { return t.RequestType4; } }), Object.defineProperty(e, "RequestType5", { enumerable: !0, get: function () { return t.RequestType5; } }), Object.defineProperty(e, "RequestType6", { enumerable: !0, get: function () { return t.RequestType6; } }), Object.defineProperty(e, "RequestType7", { enumerable: !0, get: function () { return t.RequestType7; } }), Object.defineProperty(e, "RequestType8", { enumerable: !0, get: function () { return t.RequestType8; } }), Object.defineProperty(e, "RequestType9", { enumerable: !0, get: function () { return t.RequestType9; } }), Object.defineProperty(e, "ResponseError", { enumerable: !0, get: function () { return t.ResponseError; } }), Object.defineProperty(e, "ErrorCodes", { enumerable: !0, get: function () { return t.ErrorCodes; } }), Object.defineProperty(e, "NotificationType", { enumerable: !0, get: function () { return t.NotificationType; } }), Object.defineProperty(e, "NotificationType0", { enumerable: !0, get: function () { return t.NotificationType0; } }), Object.defineProperty(e, "NotificationType1", { enumerable: !0, get: function () { return t.NotificationType1; } }), Object.defineProperty(e, "NotificationType2", { enumerable: !0, get: function () { return t.NotificationType2; } }), Object.defineProperty(e, "NotificationType3", { enumerable: !0, get: function () { return t.NotificationType3; } }), Object.defineProperty(e, "NotificationType4", { enumerable: !0, get: function () { return t.NotificationType4; } }), Object.defineProperty(e, "NotificationType5", { enumerable: !0, get: function () { return t.NotificationType5; } }), Object.defineProperty(e, "NotificationType6", { enumerable: !0, get: function () { return t.NotificationType6; } }), Object.defineProperty(e, "NotificationType7", { enumerable: !0, get: function () { return t.NotificationType7; } }), Object.defineProperty(e, "NotificationType8", { enumerable: !0, get: function () { return t.NotificationType8; } }), Object.defineProperty(e, "NotificationType9", { enumerable: !0, get: function () { return t.NotificationType9; } }), Object.defineProperty(e, "ParameterStructures", { enumerable: !0, get: function () { return t.ParameterStructures; } }); var n = S(); Object.defineProperty(e, "Disposable", { enumerable: !0, get: function () { return n.Disposable; } }); var r = x(); Object.defineProperty(e, "Event", { enumerable: !0, get: function () { return r.Event; } }), Object.defineProperty(e, "Emitter", { enumerable: !0, get: function () { return r.Emitter; } }); var o = _(); Object.defineProperty(e, "CancellationTokenSource", { enumerable: !0, get: function () { return o.CancellationTokenSource; } }), Object.defineProperty(e, "CancellationToken", { enumerable: !0, get: function () { return o.CancellationToken; } }); var i = N(); Object.defineProperty(e, "MessageReader", { enumerable: !0, get: function () { return i.MessageReader; } }), Object.defineProperty(e, "AbstractMessageReader", { enumerable: !0, get: function () { return i.AbstractMessageReader; } }), Object.defineProperty(e, "ReadableStreamMessageReader", { enumerable: !0, get: function () { return i.ReadableStreamMessageReader; } }); var s = M(); Object.defineProperty(e, "MessageWriter", { enumerable: !0, get: function () { return s.MessageWriter; } }), Object.defineProperty(e, "AbstractMessageWriter", { enumerable: !0, get: function () { return s.AbstractMessageWriter; } }), Object.defineProperty(e, "WriteableStreamMessageWriter", { enumerable: !0, get: function () { return s.WriteableStreamMessageWriter; } }); var a = I(); Object.defineProperty(e, "ConnectionStrategy", { enumerable: !0, get: function () { return a.ConnectionStrategy; } }), Object.defineProperty(e, "ConnectionOptions", { enumerable: !0, get: function () { return a.ConnectionOptions; } }), Object.defineProperty(e, "NullLogger", { enumerable: !0, get: function () { return a.NullLogger; } }), Object.defineProperty(e, "createMessageConnection", { enumerable: !0, get: function () { return a.createMessageConnection; } }), Object.defineProperty(e, "ProgressType", { enumerable: !0, get: function () { return a.ProgressType; } }), Object.defineProperty(e, "Trace", { enumerable: !0, get: function () { return a.Trace; } }), Object.defineProperty(e, "TraceFormat", { enumerable: !0, get: function () { return a.TraceFormat; } }), Object.defineProperty(e, "SetTraceNotification", { enumerable: !0, get: function () { return a.SetTraceNotification; } }), Object.defineProperty(e, "LogTraceNotification", { enumerable: !0, get: function () { return a.LogTraceNotification; } }), Object.defineProperty(e, "ConnectionErrors", { enumerable: !0, get: function () { return a.ConnectionErrors; } }), Object.defineProperty(e, "ConnectionError", { enumerable: !0, get: function () { return a.ConnectionError; } }), Object.defineProperty(e, "CancellationReceiverStrategy", { enumerable: !0, get: function () { return a.CancellationReceiverStrategy; } }), Object.defineProperty(e, "CancellationSenderStrategy", { enumerable: !0, get: function () { return a.CancellationSenderStrategy; } }), Object.defineProperty(e, "CancellationStrategy", { enumerable: !0, get: function () { return a.CancellationStrategy; } }); var u = A(); e.RAL = u.default; } }), B = v({ "../../node_modules/vscode-languageserver/node_modules/vscode-jsonrpc/lib/browser/main.js"(e) { var t = e && e.__createBinding || (Object.create ? function (e, t, n, r) { void 0 === r && (r = n), Object.defineProperty(e, r, { enumerable: !0, get: function () { return t[n]; } }); } : function (e, t, n, r) { void 0 === r && (r = n), e[r] = t[n]; }), n = e && e.__exportStar || function (e, n) { for (var r in e)
                "default" === r || Object.prototype.hasOwnProperty.call(n, r) || t(n, e, r); }; Object.defineProperty(e, "__esModule", { value: !0 }), e.createMessageConnection = e.BrowserMessageWriter = e.BrowserMessageReader = void 0, k().default.install(); var r = j(); n(j(), e); var o = class extends r.AbstractMessageReader {
                constructor(e) { super(), this._onData = new r.Emitter, this._messageListener = e => { this._onData.fire(e.data); }, e.addEventListener("error", (e => this.fireError(e))), e.onmessage = this._messageListener; }
                listen(e) { return this._onData.event(e); }
            }; e.BrowserMessageReader = o; var i = class extends r.AbstractMessageWriter {
                constructor(e) { super(), this.context = e, this.errorCount = 0, e.addEventListener("error", (e => this.fireError(e))); }
                write(e) { try {
                    return this.context.postMessage(e), Promise.resolve();
                }
                catch (t) {
                    return this.handleError(t, e), Promise.reject(t);
                } }
                handleError(e, t) { this.errorCount++, this.fireError(e, t, this.errorCount); }
                end() { }
            }; e.BrowserMessageWriter = i, e.createMessageConnection = function (e, t, n, o) { return void 0 === n && (n = r.NullLogger), r.ConnectionStrategy.is(o) && (o = { connectionStrategy: o }), r.createMessageConnection(e, t, n, o); }; } }), L = v({ "../../node_modules/vscode-languageserver/node_modules/vscode-jsonrpc/browser.js"(e, t) { t.exports = B(); } }), q = v({ "../../node_modules/vscode-languageserver/node_modules/vscode-languageserver-types/lib/umd/main.js"(e, t) { !function (s) { if ("object" == typeof t && "object" == typeof t.exports) {
                var a = s(0, e);
                void 0 !== a && (t.exports = a);
            }
            else
                o = [n, e], void 0 === (i = "function" == typeof (r = s) ? r.apply(e, o) : r) || (t.exports = i); }((function (e, t) { var n, r, o, i, s, a, u, c, l, p, f, d, h, m, g, y, v, b, D, E, C, w, A, S, x, T, k, F, O, _, N, P, M, R, I, j, B, L, q, $; Object.defineProperty(t, "__esModule", { value: !0 }), t.TextDocument = t.EOL = t.SelectionRange = t.DocumentLink = t.FormattingOptions = t.CodeLens = t.CodeAction = t.CodeActionContext = t.CodeActionKind = t.DocumentSymbol = t.SymbolInformation = t.SymbolTag = t.SymbolKind = t.DocumentHighlight = t.DocumentHighlightKind = t.SignatureInformation = t.ParameterInformation = t.Hover = t.MarkedString = t.CompletionList = t.CompletionItem = t.InsertTextMode = t.InsertReplaceEdit = t.CompletionItemTag = t.InsertTextFormat = t.CompletionItemKind = t.MarkupContent = t.MarkupKind = t.TextDocumentItem = t.OptionalVersionedTextDocumentIdentifier = t.VersionedTextDocumentIdentifier = t.TextDocumentIdentifier = t.WorkspaceChange = t.WorkspaceEdit = t.DeleteFile = t.RenameFile = t.CreateFile = t.TextDocumentEdit = t.AnnotatedTextEdit = t.ChangeAnnotationIdentifier = t.ChangeAnnotation = t.TextEdit = t.Command = t.Diagnostic = t.CodeDescription = t.DiagnosticTag = t.DiagnosticSeverity = t.DiagnosticRelatedInformation = t.FoldingRange = t.FoldingRangeKind = t.ColorPresentation = t.ColorInformation = t.Color = t.LocationLink = t.Location = t.Range = t.Position = t.uinteger = t.integer = void 0, (n = t.integer || (t.integer = {})).MIN_VALUE = -2147483648, n.MAX_VALUE = 2147483647, (o = r = t.uinteger || (t.uinteger = {})).MIN_VALUE = 0, o.MAX_VALUE = 2147483647, (s = i = t.Position || (t.Position = {})).create = function (e, t) { return e === Number.MAX_VALUE && (e = r.MAX_VALUE), t === Number.MAX_VALUE && (t = r.MAX_VALUE), { line: e, character: t }; }, s.is = function (e) { var t = e; return me.objectLiteral(t) && me.uinteger(t.line) && me.uinteger(t.character); }, (u = a = t.Range || (t.Range = {})).create = function (e, t, n, r) { if (me.uinteger(e) && me.uinteger(t) && me.uinteger(n) && me.uinteger(r))
                return { start: i.create(e, t), end: i.create(n, r) }; if (i.is(e) && i.is(t))
                return { start: e, end: t }; throw new Error("Range#create called with invalid arguments[" + e + ", " + t + ", " + n + ", " + r + "]"); }, u.is = function (e) { var t = e; return me.objectLiteral(t) && i.is(t.start) && i.is(t.end); }, (l = c = t.Location || (t.Location = {})).create = function (e, t) { return { uri: e, range: t }; }, l.is = function (e) { var t = e; return me.defined(t) && a.is(t.range) && (me.string(t.uri) || me.undefined(t.uri)); }, (p = t.LocationLink || (t.LocationLink = {})).create = function (e, t, n, r) { return { targetUri: e, targetRange: t, targetSelectionRange: n, originSelectionRange: r }; }, p.is = function (e) { var t = e; return me.defined(t) && a.is(t.targetRange) && me.string(t.targetUri) && (a.is(t.targetSelectionRange) || me.undefined(t.targetSelectionRange)) && (a.is(t.originSelectionRange) || me.undefined(t.originSelectionRange)); }, (d = f = t.Color || (t.Color = {})).create = function (e, t, n, r) { return { red: e, green: t, blue: n, alpha: r }; }, d.is = function (e) { var t = e; return me.numberRange(t.red, 0, 1) && me.numberRange(t.green, 0, 1) && me.numberRange(t.blue, 0, 1) && me.numberRange(t.alpha, 0, 1); }, (h = t.ColorInformation || (t.ColorInformation = {})).create = function (e, t) { return { range: e, color: t }; }, h.is = function (e) { var t = e; return a.is(t.range) && f.is(t.color); }, (m = t.ColorPresentation || (t.ColorPresentation = {})).create = function (e, t, n) { return { label: e, textEdit: t, additionalTextEdits: n }; }, m.is = function (e) { var t = e; return me.string(t.label) && (me.undefined(t.textEdit) || x.is(t)) && (me.undefined(t.additionalTextEdits) || me.typedArray(t.additionalTextEdits, x.is)); }, (g = t.FoldingRangeKind || (t.FoldingRangeKind = {})).Comment = "comment", g.Imports = "imports", g.Region = "region", (y = t.FoldingRange || (t.FoldingRange = {})).create = function (e, t, n, r, o) { var i = { startLine: e, endLine: t }; return me.defined(n) && (i.startCharacter = n), me.defined(r) && (i.endCharacter = r), me.defined(o) && (i.kind = o), i; }, y.is = function (e) { var t = e; return me.uinteger(t.startLine) && me.uinteger(t.startLine) && (me.undefined(t.startCharacter) || me.uinteger(t.startCharacter)) && (me.undefined(t.endCharacter) || me.uinteger(t.endCharacter)) && (me.undefined(t.kind) || me.string(t.kind)); }, (b = v = t.DiagnosticRelatedInformation || (t.DiagnosticRelatedInformation = {})).create = function (e, t) { return { location: e, message: t }; }, b.is = function (e) { var t = e; return me.defined(t) && c.is(t.location) && me.string(t.message); }, (D = t.DiagnosticSeverity || (t.DiagnosticSeverity = {})).Error = 1, D.Warning = 2, D.Information = 3, D.Hint = 4, (E = t.DiagnosticTag || (t.DiagnosticTag = {})).Unnecessary = 1, E.Deprecated = 2, (t.CodeDescription || (t.CodeDescription = {})).is = function (e) { var t = e; return null != t && me.string(t.href); }, (w = C = t.Diagnostic || (t.Diagnostic = {})).create = function (e, t, n, r, o, i) { var s = { range: e, message: t }; return me.defined(n) && (s.severity = n), me.defined(r) && (s.code = r), me.defined(o) && (s.source = o), me.defined(i) && (s.relatedInformation = i), s; }, w.is = function (e) { var t, n = e; return me.defined(n) && a.is(n.range) && me.string(n.message) && (me.number(n.severity) || me.undefined(n.severity)) && (me.integer(n.code) || me.string(n.code) || me.undefined(n.code)) && (me.undefined(n.codeDescription) || me.string(null === (t = n.codeDescription) || void 0 === t ? void 0 : t.href)) && (me.string(n.source) || me.undefined(n.source)) && (me.undefined(n.relatedInformation) || me.typedArray(n.relatedInformation, v.is)); }, (S = A = t.Command || (t.Command = {})).create = function (e, t) { for (var n = [], r = 2; r < arguments.length; r++)
                n[r - 2] = arguments[r]; var o = { title: e, command: t }; return me.defined(n) && n.length > 0 && (o.arguments = n), o; }, S.is = function (e) { var t = e; return me.defined(t) && me.string(t.title) && me.string(t.command); }, (T = x = t.TextEdit || (t.TextEdit = {})).replace = function (e, t) { return { range: e, newText: t }; }, T.insert = function (e, t) { return { range: { start: e, end: e }, newText: t }; }, T.del = function (e) { return { range: e, newText: "" }; }, T.is = function (e) { var t = e; return me.objectLiteral(t) && me.string(t.newText) && a.is(t.range); }, (F = k = t.ChangeAnnotation || (t.ChangeAnnotation = {})).create = function (e, t, n) { var r = { label: e }; return void 0 !== t && (r.needsConfirmation = t), void 0 !== n && (r.description = n), r; }, F.is = function (e) { var t = e; return void 0 !== t && me.objectLiteral(t) && me.string(t.label) && (me.boolean(t.needsConfirmation) || void 0 === t.needsConfirmation) && (me.string(t.description) || void 0 === t.description); }, (O = t.ChangeAnnotationIdentifier || (t.ChangeAnnotationIdentifier = {})).is = function (e) { return "string" == typeof e; }, (N = _ = t.AnnotatedTextEdit || (t.AnnotatedTextEdit = {})).replace = function (e, t, n) { return { range: e, newText: t, annotationId: n }; }, N.insert = function (e, t, n) { return { range: { start: e, end: e }, newText: t, annotationId: n }; }, N.del = function (e, t) { return { range: e, newText: "", annotationId: t }; }, N.is = function (e) { var t = e; return x.is(t) && (k.is(t.annotationId) || O.is(t.annotationId)); }, (M = P = t.TextDocumentEdit || (t.TextDocumentEdit = {})).create = function (e, t) { return { textDocument: e, edits: t }; }, M.is = function (e) { var t = e; return me.defined(t) && W.is(t.textDocument) && Array.isArray(t.edits); }, (I = R = t.CreateFile || (t.CreateFile = {})).create = function (e, t, n) { var r = { kind: "create", uri: e }; return void 0 === t || void 0 === t.overwrite && void 0 === t.ignoreIfExists || (r.options = t), void 0 !== n && (r.annotationId = n), r; }, I.is = function (e) { var t = e; return t && "create" === t.kind && me.string(t.uri) && (void 0 === t.options || (void 0 === t.options.overwrite || me.boolean(t.options.overwrite)) && (void 0 === t.options.ignoreIfExists || me.boolean(t.options.ignoreIfExists))) && (void 0 === t.annotationId || O.is(t.annotationId)); }, (B = j = t.RenameFile || (t.RenameFile = {})).create = function (e, t, n, r) { var o = { kind: "rename", oldUri: e, newUri: t }; return void 0 === n || void 0 === n.overwrite && void 0 === n.ignoreIfExists || (o.options = n), void 0 !== r && (o.annotationId = r), o; }, B.is = function (e) { var t = e; return t && "rename" === t.kind && me.string(t.oldUri) && me.string(t.newUri) && (void 0 === t.options || (void 0 === t.options.overwrite || me.boolean(t.options.overwrite)) && (void 0 === t.options.ignoreIfExists || me.boolean(t.options.ignoreIfExists))) && (void 0 === t.annotationId || O.is(t.annotationId)); }, (q = L = t.DeleteFile || (t.DeleteFile = {})).create = function (e, t, n) { var r = { kind: "delete", uri: e }; return void 0 === t || void 0 === t.recursive && void 0 === t.ignoreIfNotExists || (r.options = t), void 0 !== n && (r.annotationId = n), r; }, q.is = function (e) { var t = e; return t && "delete" === t.kind && me.string(t.uri) && (void 0 === t.options || (void 0 === t.options.recursive || me.boolean(t.options.recursive)) && (void 0 === t.options.ignoreIfNotExists || me.boolean(t.options.ignoreIfNotExists))) && (void 0 === t.annotationId || O.is(t.annotationId)); }, ($ = t.WorkspaceEdit || (t.WorkspaceEdit = {})).is = function (e) { var t = e; return t && (void 0 !== t.changes || void 0 !== t.documentChanges) && (void 0 === t.documentChanges || t.documentChanges.every((function (e) { return me.string(e.kind) ? R.is(e) || j.is(e) || L.is(e) : P.is(e); }))); }; var U, V, W, K, z, H, Y, J, G, X, Q, Z, ee, te, ne, re, oe, ie, se, ae, ue, ce, le, pe, fe = function () { function e(e, t) { this.edits = e, this.changeAnnotations = t; } return e.prototype.insert = function (e, t, n) { var r, o; if (void 0 === n ? r = x.insert(e, t) : O.is(n) ? (o = n, r = _.insert(e, t, n)) : (this.assertChangeAnnotations(this.changeAnnotations), o = this.changeAnnotations.manage(n), r = _.insert(e, t, o)), this.edits.push(r), void 0 !== o)
                return o; }, e.prototype.replace = function (e, t, n) { var r, o; if (void 0 === n ? r = x.replace(e, t) : O.is(n) ? (o = n, r = _.replace(e, t, n)) : (this.assertChangeAnnotations(this.changeAnnotations), o = this.changeAnnotations.manage(n), r = _.replace(e, t, o)), this.edits.push(r), void 0 !== o)
                return o; }, e.prototype.delete = function (e, t) { var n, r; if (void 0 === t ? n = x.del(e) : O.is(t) ? (r = t, n = _.del(e, t)) : (this.assertChangeAnnotations(this.changeAnnotations), r = this.changeAnnotations.manage(t), n = _.del(e, r)), this.edits.push(n), void 0 !== r)
                return r; }, e.prototype.add = function (e) { this.edits.push(e); }, e.prototype.all = function () { return this.edits; }, e.prototype.clear = function () { this.edits.splice(0, this.edits.length); }, e.prototype.assertChangeAnnotations = function (e) { if (void 0 === e)
                throw new Error("Text edit change is not configured to manage change annotations."); }, e; }(), de = function () { function e(e) { this._annotations = void 0 === e ? Object.create(null) : e, this._counter = 0, this._size = 0; } return e.prototype.all = function () { return this._annotations; }, Object.defineProperty(e.prototype, "size", { get: function () { return this._size; }, enumerable: !1, configurable: !0 }), e.prototype.manage = function (e, t) { var n; if (O.is(e) ? n = e : (n = this.nextId(), t = e), void 0 !== this._annotations[n])
                throw new Error("Id " + n + " is already in use."); if (void 0 === t)
                throw new Error("No annotation provided for id " + n); return this._annotations[n] = t, this._size++, n; }, e.prototype.nextId = function () { return this._counter++, this._counter.toString(); }, e; }(), he = function () { function e(e) { var t = this; this._textEditChanges = Object.create(null), void 0 !== e ? (this._workspaceEdit = e, e.documentChanges ? (this._changeAnnotations = new de(e.changeAnnotations), e.changeAnnotations = this._changeAnnotations.all(), e.documentChanges.forEach((function (e) { if (P.is(e)) {
                var n = new fe(e.edits, t._changeAnnotations);
                t._textEditChanges[e.textDocument.uri] = n;
            } }))) : e.changes && Object.keys(e.changes).forEach((function (n) { var r = new fe(e.changes[n]); t._textEditChanges[n] = r; }))) : this._workspaceEdit = {}; } return Object.defineProperty(e.prototype, "edit", { get: function () { return this.initDocumentChanges(), void 0 !== this._changeAnnotations && (0 === this._changeAnnotations.size ? this._workspaceEdit.changeAnnotations = void 0 : this._workspaceEdit.changeAnnotations = this._changeAnnotations.all()), this._workspaceEdit; }, enumerable: !1, configurable: !0 }), e.prototype.getTextEditChange = function (e) { if (W.is(e)) {
                if (this.initDocumentChanges(), void 0 === this._workspaceEdit.documentChanges)
                    throw new Error("Workspace edit is not configured for document changes.");
                var t = { uri: e.uri, version: e.version };
                if (!(r = this._textEditChanges[t.uri])) {
                    var n = { textDocument: t, edits: o = [] };
                    this._workspaceEdit.documentChanges.push(n), r = new fe(o, this._changeAnnotations), this._textEditChanges[t.uri] = r;
                }
                return r;
            } if (this.initChanges(), void 0 === this._workspaceEdit.changes)
                throw new Error("Workspace edit is not configured for normal text edit changes."); var r; if (!(r = this._textEditChanges[e])) {
                var o = [];
                this._workspaceEdit.changes[e] = o, r = new fe(o), this._textEditChanges[e] = r;
            } return r; }, e.prototype.initDocumentChanges = function () { void 0 === this._workspaceEdit.documentChanges && void 0 === this._workspaceEdit.changes && (this._changeAnnotations = new de, this._workspaceEdit.documentChanges = [], this._workspaceEdit.changeAnnotations = this._changeAnnotations.all()); }, e.prototype.initChanges = function () { void 0 === this._workspaceEdit.documentChanges && void 0 === this._workspaceEdit.changes && (this._workspaceEdit.changes = Object.create(null)); }, e.prototype.createFile = function (e, t, n) { if (this.initDocumentChanges(), void 0 === this._workspaceEdit.documentChanges)
                throw new Error("Workspace edit is not configured for document changes."); var r, o, i; if (k.is(t) || O.is(t) ? r = t : n = t, void 0 === r ? o = R.create(e, n) : (i = O.is(r) ? r : this._changeAnnotations.manage(r), o = R.create(e, n, i)), this._workspaceEdit.documentChanges.push(o), void 0 !== i)
                return i; }, e.prototype.renameFile = function (e, t, n, r) { if (this.initDocumentChanges(), void 0 === this._workspaceEdit.documentChanges)
                throw new Error("Workspace edit is not configured for document changes."); var o, i, s; if (k.is(n) || O.is(n) ? o = n : r = n, void 0 === o ? i = j.create(e, t, r) : (s = O.is(o) ? o : this._changeAnnotations.manage(o), i = j.create(e, t, r, s)), this._workspaceEdit.documentChanges.push(i), void 0 !== s)
                return s; }, e.prototype.deleteFile = function (e, t, n) { if (this.initDocumentChanges(), void 0 === this._workspaceEdit.documentChanges)
                throw new Error("Workspace edit is not configured for document changes."); var r, o, i; if (k.is(t) || O.is(t) ? r = t : n = t, void 0 === r ? o = L.create(e, n) : (i = O.is(r) ? r : this._changeAnnotations.manage(r), o = L.create(e, n, i)), this._workspaceEdit.documentChanges.push(o), void 0 !== i)
                return i; }, e; }(); t.WorkspaceChange = he, (U = t.TextDocumentIdentifier || (t.TextDocumentIdentifier = {})).create = function (e) { return { uri: e }; }, U.is = function (e) { var t = e; return me.defined(t) && me.string(t.uri); }, (V = t.VersionedTextDocumentIdentifier || (t.VersionedTextDocumentIdentifier = {})).create = function (e, t) { return { uri: e, version: t }; }, V.is = function (e) { var t = e; return me.defined(t) && me.string(t.uri) && me.integer(t.version); }, (K = W = t.OptionalVersionedTextDocumentIdentifier || (t.OptionalVersionedTextDocumentIdentifier = {})).create = function (e, t) { return { uri: e, version: t }; }, K.is = function (e) { var t = e; return me.defined(t) && me.string(t.uri) && (null === t.version || me.integer(t.version)); }, (z = t.TextDocumentItem || (t.TextDocumentItem = {})).create = function (e, t, n, r) { return { uri: e, languageId: t, version: n, text: r }; }, z.is = function (e) { var t = e; return me.defined(t) && me.string(t.uri) && me.string(t.languageId) && me.integer(t.version) && me.string(t.text); }, (Y = H = t.MarkupKind || (t.MarkupKind = {})).PlainText = "plaintext", Y.Markdown = "markdown", function (e) { e.is = function (t) { var n = t; return n === e.PlainText || n === e.Markdown; }; }(H = t.MarkupKind || (t.MarkupKind = {})), (J = t.MarkupContent || (t.MarkupContent = {})).is = function (e) { var t = e; return me.objectLiteral(e) && H.is(t.kind) && me.string(t.value); }, (G = t.CompletionItemKind || (t.CompletionItemKind = {})).Text = 1, G.Method = 2, G.Function = 3, G.Constructor = 4, G.Field = 5, G.Variable = 6, G.Class = 7, G.Interface = 8, G.Module = 9, G.Property = 10, G.Unit = 11, G.Value = 12, G.Enum = 13, G.Keyword = 14, G.Snippet = 15, G.Color = 16, G.File = 17, G.Reference = 18, G.Folder = 19, G.EnumMember = 20, G.Constant = 21, G.Struct = 22, G.Event = 23, G.Operator = 24, G.TypeParameter = 25, (X = t.InsertTextFormat || (t.InsertTextFormat = {})).PlainText = 1, X.Snippet = 2, (t.CompletionItemTag || (t.CompletionItemTag = {})).Deprecated = 1, (Q = t.InsertReplaceEdit || (t.InsertReplaceEdit = {})).create = function (e, t, n) { return { newText: e, insert: t, replace: n }; }, Q.is = function (e) { var t = e; return t && me.string(t.newText) && a.is(t.insert) && a.is(t.replace); }, (Z = t.InsertTextMode || (t.InsertTextMode = {})).asIs = 1, Z.adjustIndentation = 2, (t.CompletionItem || (t.CompletionItem = {})).create = function (e) { return { label: e }; }, (t.CompletionList || (t.CompletionList = {})).create = function (e, t) { return { items: e || [], isIncomplete: !!t }; }, (te = ee = t.MarkedString || (t.MarkedString = {})).fromPlainText = function (e) { return e.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&"); }, te.is = function (e) { var t = e; return me.string(t) || me.objectLiteral(t) && me.string(t.language) && me.string(t.value); }, (t.Hover || (t.Hover = {})).is = function (e) { var t = e; return !!t && me.objectLiteral(t) && (J.is(t.contents) || ee.is(t.contents) || me.typedArray(t.contents, ee.is)) && (void 0 === e.range || a.is(e.range)); }, (t.ParameterInformation || (t.ParameterInformation = {})).create = function (e, t) { return t ? { label: e, documentation: t } : { label: e }; }, (t.SignatureInformation || (t.SignatureInformation = {})).create = function (e, t) { for (var n = [], r = 2; r < arguments.length; r++)
                n[r - 2] = arguments[r]; var o = { label: e }; return me.defined(t) && (o.documentation = t), me.defined(n) ? o.parameters = n : o.parameters = [], o; }, (ne = t.DocumentHighlightKind || (t.DocumentHighlightKind = {})).Text = 1, ne.Read = 2, ne.Write = 3, (t.DocumentHighlight || (t.DocumentHighlight = {})).create = function (e, t) { var n = { range: e }; return me.number(t) && (n.kind = t), n; }, (re = t.SymbolKind || (t.SymbolKind = {})).File = 1, re.Module = 2, re.Namespace = 3, re.Package = 4, re.Class = 5, re.Method = 6, re.Property = 7, re.Field = 8, re.Constructor = 9, re.Enum = 10, re.Interface = 11, re.Function = 12, re.Variable = 13, re.Constant = 14, re.String = 15, re.Number = 16, re.Boolean = 17, re.Array = 18, re.Object = 19, re.Key = 20, re.Null = 21, re.EnumMember = 22, re.Struct = 23, re.Event = 24, re.Operator = 25, re.TypeParameter = 26, (t.SymbolTag || (t.SymbolTag = {})).Deprecated = 1, (t.SymbolInformation || (t.SymbolInformation = {})).create = function (e, t, n, r, o) { var i = { name: e, kind: t, location: { uri: r, range: n } }; return o && (i.containerName = o), i; }, (oe = t.DocumentSymbol || (t.DocumentSymbol = {})).create = function (e, t, n, r, o, i) { var s = { name: e, detail: t, kind: n, range: r, selectionRange: o }; return void 0 !== i && (s.children = i), s; }, oe.is = function (e) { var t = e; return t && me.string(t.name) && me.number(t.kind) && a.is(t.range) && a.is(t.selectionRange) && (void 0 === t.detail || me.string(t.detail)) && (void 0 === t.deprecated || me.boolean(t.deprecated)) && (void 0 === t.children || Array.isArray(t.children)) && (void 0 === t.tags || Array.isArray(t.tags)); }, (ie = t.CodeActionKind || (t.CodeActionKind = {})).Empty = "", ie.QuickFix = "quickfix", ie.Refactor = "refactor", ie.RefactorExtract = "refactor.extract", ie.RefactorInline = "refactor.inline", ie.RefactorRewrite = "refactor.rewrite", ie.Source = "source", ie.SourceOrganizeImports = "source.organizeImports", ie.SourceFixAll = "source.fixAll", (se = t.CodeActionContext || (t.CodeActionContext = {})).create = function (e, t) { var n = { diagnostics: e }; return null != t && (n.only = t), n; }, se.is = function (e) { var t = e; return me.defined(t) && me.typedArray(t.diagnostics, C.is) && (void 0 === t.only || me.typedArray(t.only, me.string)); }, (ae = t.CodeAction || (t.CodeAction = {})).create = function (e, t, n) { var r = { title: e }, o = !0; return "string" == typeof t ? (o = !1, r.kind = t) : A.is(t) ? r.command = t : r.edit = t, o && void 0 !== n && (r.kind = n), r; }, ae.is = function (e) { var t = e; return t && me.string(t.title) && (void 0 === t.diagnostics || me.typedArray(t.diagnostics, C.is)) && (void 0 === t.kind || me.string(t.kind)) && (void 0 !== t.edit || void 0 !== t.command) && (void 0 === t.command || A.is(t.command)) && (void 0 === t.isPreferred || me.boolean(t.isPreferred)) && (void 0 === t.edit || $.is(t.edit)); }, (ue = t.CodeLens || (t.CodeLens = {})).create = function (e, t) { var n = { range: e }; return me.defined(t) && (n.data = t), n; }, ue.is = function (e) { var t = e; return me.defined(t) && a.is(t.range) && (me.undefined(t.command) || A.is(t.command)); }, (ce = t.FormattingOptions || (t.FormattingOptions = {})).create = function (e, t) { return { tabSize: e, insertSpaces: t }; }, ce.is = function (e) { var t = e; return me.defined(t) && me.uinteger(t.tabSize) && me.boolean(t.insertSpaces); }, (le = t.DocumentLink || (t.DocumentLink = {})).create = function (e, t, n) { return { range: e, target: t, data: n }; }, le.is = function (e) { var t = e; return me.defined(t) && a.is(t.range) && (me.undefined(t.target) || me.string(t.target)); }, (pe = t.SelectionRange || (t.SelectionRange = {})).create = function (e, t) { return { range: e, parent: t }; }, pe.is = function (e) { var t = e; return void 0 !== t && a.is(t.range) && (void 0 === t.parent || pe.is(t.parent)); }, t.EOL = ["\n", "\r\n", "\r"], function (e) { function t(e, n) { if (e.length <= 1)
                return e; var r = e.length / 2 | 0, o = e.slice(0, r), i = e.slice(r); t(o, n), t(i, n); for (var s = 0, a = 0, u = 0; s < o.length && a < i.length;) {
                var c = n(o[s], i[a]);
                e[u++] = c <= 0 ? o[s++] : i[a++];
            } for (; s < o.length;)
                e[u++] = o[s++]; for (; a < i.length;)
                e[u++] = i[a++]; return e; } e.create = function (e, t, n, r) { return new ve(e, t, n, r); }, e.is = function (e) { var t = e; return !!(me.defined(t) && me.string(t.uri) && (me.undefined(t.languageId) || me.string(t.languageId)) && me.uinteger(t.lineCount) && me.func(t.getText) && me.func(t.positionAt) && me.func(t.offsetAt)); }, e.applyEdits = function (e, n) { for (var r = e.getText(), o = t(n, (function (e, t) { var n = e.range.start.line - t.range.start.line; return 0 === n ? e.range.start.character - t.range.start.character : n; })), i = r.length, s = o.length - 1; s >= 0; s--) {
                var a = o[s], u = e.offsetAt(a.range.start), c = e.offsetAt(a.range.end);
                if (!(c <= i))
                    throw new Error("Overlapping edit");
                r = r.substring(0, u) + a.newText + r.substring(c, r.length), i = u;
            } return r; }; }(t.TextDocument || (t.TextDocument = {})); var me, ge, ye, ve = function () { function e(e, t, n, r) { this._uri = e, this._languageId = t, this._version = n, this._content = r, this._lineOffsets = void 0; } return Object.defineProperty(e.prototype, "uri", { get: function () { return this._uri; }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "languageId", { get: function () { return this._languageId; }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "version", { get: function () { return this._version; }, enumerable: !1, configurable: !0 }), e.prototype.getText = function (e) { if (e) {
                var t = this.offsetAt(e.start), n = this.offsetAt(e.end);
                return this._content.substring(t, n);
            } return this._content; }, e.prototype.update = function (e, t) { this._content = e.text, this._version = t, this._lineOffsets = void 0; }, e.prototype.getLineOffsets = function () { if (void 0 === this._lineOffsets) {
                for (var e = [], t = this._content, n = !0, r = 0; r < t.length; r++) {
                    n && (e.push(r), n = !1);
                    var o = t.charAt(r);
                    n = "\r" === o || "\n" === o, "\r" === o && r + 1 < t.length && "\n" === t.charAt(r + 1) && r++;
                }
                n && t.length > 0 && e.push(t.length), this._lineOffsets = e;
            } return this._lineOffsets; }, e.prototype.positionAt = function (e) { e = Math.max(Math.min(e, this._content.length), 0); var t = this.getLineOffsets(), n = 0, r = t.length; if (0 === r)
                return i.create(0, e); for (; n < r;) {
                var o = Math.floor((n + r) / 2);
                t[o] > e ? r = o : n = o + 1;
            } var s = n - 1; return i.create(s, e - t[s]); }, e.prototype.offsetAt = function (e) { var t = this.getLineOffsets(); if (e.line >= t.length)
                return this._content.length; if (e.line < 0)
                return 0; var n = t[e.line], r = e.line + 1 < t.length ? t[e.line + 1] : this._content.length; return Math.max(Math.min(n + e.character, r), n); }, Object.defineProperty(e.prototype, "lineCount", { get: function () { return this.getLineOffsets().length; }, enumerable: !1, configurable: !0 }), e; }(); ge = me || (me = {}), ye = Object.prototype.toString, ge.defined = function (e) { return void 0 !== e; }, ge.undefined = function (e) { return void 0 === e; }, ge.boolean = function (e) { return !0 === e || !1 === e; }, ge.string = function (e) { return "[object String]" === ye.call(e); }, ge.number = function (e) { return "[object Number]" === ye.call(e); }, ge.numberRange = function (e, t, n) { return "[object Number]" === ye.call(e) && t <= e && e <= n; }, ge.integer = function (e) { return "[object Number]" === ye.call(e) && -2147483648 <= e && e <= 2147483647; }, ge.uinteger = function (e) { return "[object Number]" === ye.call(e) && 0 <= e && e <= 2147483647; }, ge.func = function (e) { return "[object Function]" === ye.call(e); }, ge.objectLiteral = function (e) { return null !== e && "object" == typeof e; }, ge.typedArray = function (e, t) { return Array.isArray(e) && e.every(t); }; })); } }), $ = v({ "../../node_modules/vscode-languageserver/node_modules/vscode-languageserver-protocol/lib/common/messages.js"(e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.ProtocolNotificationType = e.ProtocolNotificationType0 = e.ProtocolRequestType = e.ProtocolRequestType0 = e.RegistrationType = void 0; var t = B(); e.RegistrationType = class {
                constructor(e) { this.method = e; }
            }; var n = class extends t.RequestType0 {
                constructor(e) { super(e); }
            }; e.ProtocolRequestType0 = n; var r = class extends t.RequestType {
                constructor(e) { super(e, t.ParameterStructures.byName); }
            }; e.ProtocolRequestType = r; var o = class extends t.NotificationType0 {
                constructor(e) { super(e); }
            }; e.ProtocolNotificationType0 = o; var i = class extends t.NotificationType {
                constructor(e) { super(e, t.ParameterStructures.byName); }
            }; e.ProtocolNotificationType = i; } }), U = v({ "../../node_modules/vscode-languageserver/node_modules/vscode-languageserver-protocol/lib/common/utils/is.js"(e) { function t(e) { return "string" == typeof e || e instanceof String; } function n(e) { return Array.isArray(e); } Object.defineProperty(e, "__esModule", { value: !0 }), e.objectLiteral = e.typedArray = e.stringArray = e.array = e.func = e.error = e.number = e.string = e.boolean = void 0, e.boolean = function (e) { return !0 === e || !1 === e; }, e.string = t, e.number = function (e) { return "number" == typeof e || e instanceof Number; }, e.error = function (e) { return e instanceof Error; }, e.func = function (e) { return "function" == typeof e; }, e.array = n, e.stringArray = function (e) { return n(e) && e.every((e => t(e))); }, e.typedArray = function (e, t) { return Array.isArray(e) && e.every(t); }, e.objectLiteral = function (e) { return null !== e && "object" == typeof e; }; } }), V = v({ "../../node_modules/vscode-languageserver/node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js"(e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.ImplementationRequest = void 0; var t, n = $(); (t = e.ImplementationRequest || (e.ImplementationRequest = {})).method = "textDocument/implementation", t.type = new n.ProtocolRequestType(t.method); } }), W = v({ "../../node_modules/vscode-languageserver/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js"(e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.TypeDefinitionRequest = void 0; var t, n = $(); (t = e.TypeDefinitionRequest || (e.TypeDefinitionRequest = {})).method = "textDocument/typeDefinition", t.type = new n.ProtocolRequestType(t.method); } }), K = v({ "../../node_modules/vscode-languageserver/node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolders.js"(e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.DidChangeWorkspaceFoldersNotification = e.WorkspaceFoldersRequest = void 0; var t = $(); (e.WorkspaceFoldersRequest || (e.WorkspaceFoldersRequest = {})).type = new t.ProtocolRequestType0("workspace/workspaceFolders"), (e.DidChangeWorkspaceFoldersNotification || (e.DidChangeWorkspaceFoldersNotification = {})).type = new t.ProtocolNotificationType("workspace/didChangeWorkspaceFolders"); } }), z = v({ "../../node_modules/vscode-languageserver/node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js"(e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.ConfigurationRequest = void 0; var t = $(); (e.ConfigurationRequest || (e.ConfigurationRequest = {})).type = new t.ProtocolRequestType("workspace/configuration"); } }), H = v({ "../../node_modules/vscode-languageserver/node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js"(e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.ColorPresentationRequest = e.DocumentColorRequest = void 0; var t, n = $(); (t = e.DocumentColorRequest || (e.DocumentColorRequest = {})).method = "textDocument/documentColor", t.type = new n.ProtocolRequestType(t.method), (e.ColorPresentationRequest || (e.ColorPresentationRequest = {})).type = new n.ProtocolRequestType("textDocument/colorPresentation"); } }), Y = v({ "../../node_modules/vscode-languageserver/node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js"(e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.FoldingRangeRequest = e.FoldingRangeKind = void 0; var t, n, r = $(); (t = e.FoldingRangeKind || (e.FoldingRangeKind = {})).Comment = "comment", t.Imports = "imports", t.Region = "region", (n = e.FoldingRangeRequest || (e.FoldingRangeRequest = {})).method = "textDocument/foldingRange", n.type = new r.ProtocolRequestType(n.method); } }), J = v({ "../../node_modules/vscode-languageserver/node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js"(e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.DeclarationRequest = void 0; var t, n = $(); (t = e.DeclarationRequest || (e.DeclarationRequest = {})).method = "textDocument/declaration", t.type = new n.ProtocolRequestType(t.method); } }), G = v({ "../../node_modules/vscode-languageserver/node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js"(e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.SelectionRangeRequest = void 0; var t, n = $(); (t = e.SelectionRangeRequest || (e.SelectionRangeRequest = {})).method = "textDocument/selectionRange", t.type = new n.ProtocolRequestType(t.method); } }), X = v({ "../../node_modules/vscode-languageserver/node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js"(e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.WorkDoneProgressCancelNotification = e.WorkDoneProgressCreateRequest = e.WorkDoneProgress = void 0; var t, n = B(), r = $(); (t = e.WorkDoneProgress || (e.WorkDoneProgress = {})).type = new n.ProgressType, t.is = function (e) { return e === t.type; }, (e.WorkDoneProgressCreateRequest || (e.WorkDoneProgressCreateRequest = {})).type = new r.ProtocolRequestType("window/workDoneProgress/create"), (e.WorkDoneProgressCancelNotification || (e.WorkDoneProgressCancelNotification = {})).type = new r.ProtocolNotificationType("window/workDoneProgress/cancel"); } }), Q = v({ "../../node_modules/vscode-languageserver/node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js"(e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.CallHierarchyOutgoingCallsRequest = e.CallHierarchyIncomingCallsRequest = e.CallHierarchyPrepareRequest = void 0; var t, n, r, o = $(); (t = e.CallHierarchyPrepareRequest || (e.CallHierarchyPrepareRequest = {})).method = "textDocument/prepareCallHierarchy", t.type = new o.ProtocolRequestType(t.method), (n = e.CallHierarchyIncomingCallsRequest || (e.CallHierarchyIncomingCallsRequest = {})).method = "callHierarchy/incomingCalls", n.type = new o.ProtocolRequestType(n.method), (r = e.CallHierarchyOutgoingCallsRequest || (e.CallHierarchyOutgoingCallsRequest = {})).method = "callHierarchy/outgoingCalls", r.type = new o.ProtocolRequestType(r.method); } }), Z = v({ "../../node_modules/vscode-languageserver/node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js"(e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.SemanticTokensRefreshRequest = e.SemanticTokensRangeRequest = e.SemanticTokensDeltaRequest = e.SemanticTokensRequest = e.SemanticTokensRegistrationType = e.TokenFormat = e.SemanticTokens = e.SemanticTokenModifiers = e.SemanticTokenTypes = void 0; var t, n, r, o, i, s, a, u = $(); (t = e.SemanticTokenTypes || (e.SemanticTokenTypes = {})).namespace = "namespace", t.type = "type", t.class = "class", t.enum = "enum", t.interface = "interface", t.struct = "struct", t.typeParameter = "typeParameter", t.parameter = "parameter", t.variable = "variable", t.property = "property", t.enumMember = "enumMember", t.event = "event", t.function = "function", t.method = "method", t.macro = "macro", t.keyword = "keyword", t.modifier = "modifier", t.comment = "comment", t.string = "string", t.number = "number", t.regexp = "regexp", t.operator = "operator", (n = e.SemanticTokenModifiers || (e.SemanticTokenModifiers = {})).declaration = "declaration", n.definition = "definition", n.readonly = "readonly", n.static = "static", n.deprecated = "deprecated", n.abstract = "abstract", n.async = "async", n.modification = "modification", n.documentation = "documentation", n.defaultLibrary = "defaultLibrary", (e.SemanticTokens || (e.SemanticTokens = {})).is = function (e) { const t = e; return void 0 !== t && (void 0 === t.resultId || "string" == typeof t.resultId) && Array.isArray(t.data) && (0 === t.data.length || "number" == typeof t.data[0]); }, (e.TokenFormat || (e.TokenFormat = {})).Relative = "relative", (r = e.SemanticTokensRegistrationType || (e.SemanticTokensRegistrationType = {})).method = "textDocument/semanticTokens", r.type = new u.RegistrationType(r.method), (o = e.SemanticTokensRequest || (e.SemanticTokensRequest = {})).method = "textDocument/semanticTokens/full", o.type = new u.ProtocolRequestType(o.method), (i = e.SemanticTokensDeltaRequest || (e.SemanticTokensDeltaRequest = {})).method = "textDocument/semanticTokens/full/delta", i.type = new u.ProtocolRequestType(i.method), (s = e.SemanticTokensRangeRequest || (e.SemanticTokensRangeRequest = {})).method = "textDocument/semanticTokens/range", s.type = new u.ProtocolRequestType(s.method), (a = e.SemanticTokensRefreshRequest || (e.SemanticTokensRefreshRequest = {})).method = "workspace/semanticTokens/refresh", a.type = new u.ProtocolRequestType0(a.method); } }), ee = v({ "../../node_modules/vscode-languageserver/node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js"(e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.ShowDocumentRequest = void 0; var t, n = $(); (t = e.ShowDocumentRequest || (e.ShowDocumentRequest = {})).method = "window/showDocument", t.type = new n.ProtocolRequestType(t.method); } }), te = v({ "../../node_modules/vscode-languageserver/node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js"(e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.LinkedEditingRangeRequest = void 0; var t, n = $(); (t = e.LinkedEditingRangeRequest || (e.LinkedEditingRangeRequest = {})).method = "textDocument/linkedEditingRange", t.type = new n.ProtocolRequestType(t.method); } }), ne = v({ "../../node_modules/vscode-languageserver/node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js"(e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.WillDeleteFilesRequest = e.DidDeleteFilesNotification = e.DidRenameFilesNotification = e.WillRenameFilesRequest = e.DidCreateFilesNotification = e.WillCreateFilesRequest = e.FileOperationPatternKind = void 0; var t, n, r, o, i, s, a, u = $(); (t = e.FileOperationPatternKind || (e.FileOperationPatternKind = {})).file = "file", t.folder = "folder", (n = e.WillCreateFilesRequest || (e.WillCreateFilesRequest = {})).method = "workspace/willCreateFiles", n.type = new u.ProtocolRequestType(n.method), (r = e.DidCreateFilesNotification || (e.DidCreateFilesNotification = {})).method = "workspace/didCreateFiles", r.type = new u.ProtocolNotificationType(r.method), (o = e.WillRenameFilesRequest || (e.WillRenameFilesRequest = {})).method = "workspace/willRenameFiles", o.type = new u.ProtocolRequestType(o.method), (i = e.DidRenameFilesNotification || (e.DidRenameFilesNotification = {})).method = "workspace/didRenameFiles", i.type = new u.ProtocolNotificationType(i.method), (s = e.DidDeleteFilesNotification || (e.DidDeleteFilesNotification = {})).method = "workspace/didDeleteFiles", s.type = new u.ProtocolNotificationType(s.method), (a = e.WillDeleteFilesRequest || (e.WillDeleteFilesRequest = {})).method = "workspace/willDeleteFiles", a.type = new u.ProtocolRequestType(a.method); } }), re = v({ "../../node_modules/vscode-languageserver/node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js"(e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.MonikerRequest = e.MonikerKind = e.UniquenessLevel = void 0; var t, n, r, o = $(); (t = e.UniquenessLevel || (e.UniquenessLevel = {})).document = "document", t.project = "project", t.group = "group", t.scheme = "scheme", t.global = "global", (n = e.MonikerKind || (e.MonikerKind = {})).import = "import", n.export = "export", n.local = "local", (r = e.MonikerRequest || (e.MonikerRequest = {})).method = "textDocument/moniker", r.type = new o.ProtocolRequestType(r.method); } }), oe = v({ "../../node_modules/vscode-languageserver/node_modules/vscode-languageserver-protocol/lib/common/protocol.js"(e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.DocumentLinkRequest = e.CodeLensRefreshRequest = e.CodeLensResolveRequest = e.CodeLensRequest = e.WorkspaceSymbolRequest = e.CodeActionResolveRequest = e.CodeActionRequest = e.DocumentSymbolRequest = e.DocumentHighlightRequest = e.ReferencesRequest = e.DefinitionRequest = e.SignatureHelpRequest = e.SignatureHelpTriggerKind = e.HoverRequest = e.CompletionResolveRequest = e.CompletionRequest = e.CompletionTriggerKind = e.PublishDiagnosticsNotification = e.WatchKind = e.FileChangeType = e.DidChangeWatchedFilesNotification = e.WillSaveTextDocumentWaitUntilRequest = e.WillSaveTextDocumentNotification = e.TextDocumentSaveReason = e.DidSaveTextDocumentNotification = e.DidCloseTextDocumentNotification = e.DidChangeTextDocumentNotification = e.TextDocumentContentChangeEvent = e.DidOpenTextDocumentNotification = e.TextDocumentSyncKind = e.TelemetryEventNotification = e.LogMessageNotification = e.ShowMessageRequest = e.ShowMessageNotification = e.MessageType = e.DidChangeConfigurationNotification = e.ExitNotification = e.ShutdownRequest = e.InitializedNotification = e.InitializeError = e.InitializeRequest = e.WorkDoneProgressOptions = e.TextDocumentRegistrationOptions = e.StaticRegistrationOptions = e.FailureHandlingKind = e.ResourceOperationKind = e.UnregistrationRequest = e.RegistrationRequest = e.DocumentSelector = e.DocumentFilter = void 0, e.MonikerRequest = e.MonikerKind = e.UniquenessLevel = e.WillDeleteFilesRequest = e.DidDeleteFilesNotification = e.WillRenameFilesRequest = e.DidRenameFilesNotification = e.WillCreateFilesRequest = e.DidCreateFilesNotification = e.FileOperationPatternKind = e.LinkedEditingRangeRequest = e.ShowDocumentRequest = e.SemanticTokensRegistrationType = e.SemanticTokensRefreshRequest = e.SemanticTokensRangeRequest = e.SemanticTokensDeltaRequest = e.SemanticTokensRequest = e.TokenFormat = e.SemanticTokens = e.SemanticTokenModifiers = e.SemanticTokenTypes = e.CallHierarchyPrepareRequest = e.CallHierarchyOutgoingCallsRequest = e.CallHierarchyIncomingCallsRequest = e.WorkDoneProgressCancelNotification = e.WorkDoneProgressCreateRequest = e.WorkDoneProgress = e.SelectionRangeRequest = e.DeclarationRequest = e.FoldingRangeRequest = e.ColorPresentationRequest = e.DocumentColorRequest = e.ConfigurationRequest = e.DidChangeWorkspaceFoldersNotification = e.WorkspaceFoldersRequest = e.TypeDefinitionRequest = e.ImplementationRequest = e.ApplyWorkspaceEditRequest = e.ExecuteCommandRequest = e.PrepareRenameRequest = e.RenameRequest = e.PrepareSupportDefaultBehavior = e.DocumentOnTypeFormattingRequest = e.DocumentRangeFormattingRequest = e.DocumentFormattingRequest = e.DocumentLinkResolveRequest = void 0; var t = U(), n = $(), r = V(); Object.defineProperty(e, "ImplementationRequest", { enumerable: !0, get: function () { return r.ImplementationRequest; } }); var o = W(); Object.defineProperty(e, "TypeDefinitionRequest", { enumerable: !0, get: function () { return o.TypeDefinitionRequest; } }); var i = K(); Object.defineProperty(e, "WorkspaceFoldersRequest", { enumerable: !0, get: function () { return i.WorkspaceFoldersRequest; } }), Object.defineProperty(e, "DidChangeWorkspaceFoldersNotification", { enumerable: !0, get: function () { return i.DidChangeWorkspaceFoldersNotification; } }); var s = z(); Object.defineProperty(e, "ConfigurationRequest", { enumerable: !0, get: function () { return s.ConfigurationRequest; } }); var a = H(); Object.defineProperty(e, "DocumentColorRequest", { enumerable: !0, get: function () { return a.DocumentColorRequest; } }), Object.defineProperty(e, "ColorPresentationRequest", { enumerable: !0, get: function () { return a.ColorPresentationRequest; } }); var u = Y(); Object.defineProperty(e, "FoldingRangeRequest", { enumerable: !0, get: function () { return u.FoldingRangeRequest; } }); var c = J(); Object.defineProperty(e, "DeclarationRequest", { enumerable: !0, get: function () { return c.DeclarationRequest; } }); var l = G(); Object.defineProperty(e, "SelectionRangeRequest", { enumerable: !0, get: function () { return l.SelectionRangeRequest; } }); var p = X(); Object.defineProperty(e, "WorkDoneProgress", { enumerable: !0, get: function () { return p.WorkDoneProgress; } }), Object.defineProperty(e, "WorkDoneProgressCreateRequest", { enumerable: !0, get: function () { return p.WorkDoneProgressCreateRequest; } }), Object.defineProperty(e, "WorkDoneProgressCancelNotification", { enumerable: !0, get: function () { return p.WorkDoneProgressCancelNotification; } }); var f = Q(); Object.defineProperty(e, "CallHierarchyIncomingCallsRequest", { enumerable: !0, get: function () { return f.CallHierarchyIncomingCallsRequest; } }), Object.defineProperty(e, "CallHierarchyOutgoingCallsRequest", { enumerable: !0, get: function () { return f.CallHierarchyOutgoingCallsRequest; } }), Object.defineProperty(e, "CallHierarchyPrepareRequest", { enumerable: !0, get: function () { return f.CallHierarchyPrepareRequest; } }); var d = Z(); Object.defineProperty(e, "SemanticTokenTypes", { enumerable: !0, get: function () { return d.SemanticTokenTypes; } }), Object.defineProperty(e, "SemanticTokenModifiers", { enumerable: !0, get: function () { return d.SemanticTokenModifiers; } }), Object.defineProperty(e, "SemanticTokens", { enumerable: !0, get: function () { return d.SemanticTokens; } }), Object.defineProperty(e, "TokenFormat", { enumerable: !0, get: function () { return d.TokenFormat; } }), Object.defineProperty(e, "SemanticTokensRequest", { enumerable: !0, get: function () { return d.SemanticTokensRequest; } }), Object.defineProperty(e, "SemanticTokensDeltaRequest", { enumerable: !0, get: function () { return d.SemanticTokensDeltaRequest; } }), Object.defineProperty(e, "SemanticTokensRangeRequest", { enumerable: !0, get: function () { return d.SemanticTokensRangeRequest; } }), Object.defineProperty(e, "SemanticTokensRefreshRequest", { enumerable: !0, get: function () { return d.SemanticTokensRefreshRequest; } }), Object.defineProperty(e, "SemanticTokensRegistrationType", { enumerable: !0, get: function () { return d.SemanticTokensRegistrationType; } }); var h = ee(); Object.defineProperty(e, "ShowDocumentRequest", { enumerable: !0, get: function () { return h.ShowDocumentRequest; } }); var m = te(); Object.defineProperty(e, "LinkedEditingRangeRequest", { enumerable: !0, get: function () { return m.LinkedEditingRangeRequest; } }); var g = ne(); Object.defineProperty(e, "FileOperationPatternKind", { enumerable: !0, get: function () { return g.FileOperationPatternKind; } }), Object.defineProperty(e, "DidCreateFilesNotification", { enumerable: !0, get: function () { return g.DidCreateFilesNotification; } }), Object.defineProperty(e, "WillCreateFilesRequest", { enumerable: !0, get: function () { return g.WillCreateFilesRequest; } }), Object.defineProperty(e, "DidRenameFilesNotification", { enumerable: !0, get: function () { return g.DidRenameFilesNotification; } }), Object.defineProperty(e, "WillRenameFilesRequest", { enumerable: !0, get: function () { return g.WillRenameFilesRequest; } }), Object.defineProperty(e, "DidDeleteFilesNotification", { enumerable: !0, get: function () { return g.DidDeleteFilesNotification; } }), Object.defineProperty(e, "WillDeleteFilesRequest", { enumerable: !0, get: function () { return g.WillDeleteFilesRequest; } }); var y, v, b, D, E, C, w, A, S, x, T, k, F, O, _, N, P, M, R, I, j, B, L, q, oe, ie, se, ae, ue, ce, le, pe, fe, de, he, me, ge, ye, ve, be, De = re(); Object.defineProperty(e, "UniquenessLevel", { enumerable: !0, get: function () { return De.UniquenessLevel; } }), Object.defineProperty(e, "MonikerKind", { enumerable: !0, get: function () { return De.MonikerKind; } }), Object.defineProperty(e, "MonikerRequest", { enumerable: !0, get: function () { return De.MonikerRequest; } }), (y = e.DocumentFilter || (e.DocumentFilter = {})).is = function (e) { const n = e; return t.string(n.language) || t.string(n.scheme) || t.string(n.pattern); }, (v = e.DocumentSelector || (e.DocumentSelector = {})).is = function (e) { if (!Array.isArray(e))
                return !1; for (let n of e)
                if (!t.string(n) && !y.is(n))
                    return !1; return !0; }, (e.RegistrationRequest || (e.RegistrationRequest = {})).type = new n.ProtocolRequestType("client/registerCapability"), (e.UnregistrationRequest || (e.UnregistrationRequest = {})).type = new n.ProtocolRequestType("client/unregisterCapability"), (b = e.ResourceOperationKind || (e.ResourceOperationKind = {})).Create = "create", b.Rename = "rename", b.Delete = "delete", (D = e.FailureHandlingKind || (e.FailureHandlingKind = {})).Abort = "abort", D.Transactional = "transactional", D.TextOnlyTransactional = "textOnlyTransactional", D.Undo = "undo", (e.StaticRegistrationOptions || (e.StaticRegistrationOptions = {})).hasId = function (e) { const n = e; return n && t.string(n.id) && n.id.length > 0; }, (e.TextDocumentRegistrationOptions || (e.TextDocumentRegistrationOptions = {})).is = function (e) { const t = e; return t && (null === t.documentSelector || v.is(t.documentSelector)); }, (E = e.WorkDoneProgressOptions || (e.WorkDoneProgressOptions = {})).is = function (e) { const n = e; return t.objectLiteral(n) && (void 0 === n.workDoneProgress || t.boolean(n.workDoneProgress)); }, E.hasWorkDoneProgress = function (e) { const n = e; return n && t.boolean(n.workDoneProgress); }, (e.InitializeRequest || (e.InitializeRequest = {})).type = new n.ProtocolRequestType("initialize"), (e.InitializeError || (e.InitializeError = {})).unknownProtocolVersion = 1, (e.InitializedNotification || (e.InitializedNotification = {})).type = new n.ProtocolNotificationType("initialized"), (e.ShutdownRequest || (e.ShutdownRequest = {})).type = new n.ProtocolRequestType0("shutdown"), (e.ExitNotification || (e.ExitNotification = {})).type = new n.ProtocolNotificationType0("exit"), (e.DidChangeConfigurationNotification || (e.DidChangeConfigurationNotification = {})).type = new n.ProtocolNotificationType("workspace/didChangeConfiguration"), (C = e.MessageType || (e.MessageType = {})).Error = 1, C.Warning = 2, C.Info = 3, C.Log = 4, (e.ShowMessageNotification || (e.ShowMessageNotification = {})).type = new n.ProtocolNotificationType("window/showMessage"), (e.ShowMessageRequest || (e.ShowMessageRequest = {})).type = new n.ProtocolRequestType("window/showMessageRequest"), (e.LogMessageNotification || (e.LogMessageNotification = {})).type = new n.ProtocolNotificationType("window/logMessage"), (e.TelemetryEventNotification || (e.TelemetryEventNotification = {})).type = new n.ProtocolNotificationType("telemetry/event"), (w = e.TextDocumentSyncKind || (e.TextDocumentSyncKind = {})).None = 0, w.Full = 1, w.Incremental = 2, (A = e.DidOpenTextDocumentNotification || (e.DidOpenTextDocumentNotification = {})).method = "textDocument/didOpen", A.type = new n.ProtocolNotificationType(A.method), (S = e.TextDocumentContentChangeEvent || (e.TextDocumentContentChangeEvent = {})).isIncremental = function (e) { let t = e; return null != t && "string" == typeof t.text && void 0 !== t.range && (void 0 === t.rangeLength || "number" == typeof t.rangeLength); }, S.isFull = function (e) { let t = e; return null != t && "string" == typeof t.text && void 0 === t.range && void 0 === t.rangeLength; }, (x = e.DidChangeTextDocumentNotification || (e.DidChangeTextDocumentNotification = {})).method = "textDocument/didChange", x.type = new n.ProtocolNotificationType(x.method), (T = e.DidCloseTextDocumentNotification || (e.DidCloseTextDocumentNotification = {})).method = "textDocument/didClose", T.type = new n.ProtocolNotificationType(T.method), (k = e.DidSaveTextDocumentNotification || (e.DidSaveTextDocumentNotification = {})).method = "textDocument/didSave", k.type = new n.ProtocolNotificationType(k.method), (F = e.TextDocumentSaveReason || (e.TextDocumentSaveReason = {})).Manual = 1, F.AfterDelay = 2, F.FocusOut = 3, (O = e.WillSaveTextDocumentNotification || (e.WillSaveTextDocumentNotification = {})).method = "textDocument/willSave", O.type = new n.ProtocolNotificationType(O.method), (_ = e.WillSaveTextDocumentWaitUntilRequest || (e.WillSaveTextDocumentWaitUntilRequest = {})).method = "textDocument/willSaveWaitUntil", _.type = new n.ProtocolRequestType(_.method), (e.DidChangeWatchedFilesNotification || (e.DidChangeWatchedFilesNotification = {})).type = new n.ProtocolNotificationType("workspace/didChangeWatchedFiles"), (N = e.FileChangeType || (e.FileChangeType = {})).Created = 1, N.Changed = 2, N.Deleted = 3, (P = e.WatchKind || (e.WatchKind = {})).Create = 1, P.Change = 2, P.Delete = 4, (e.PublishDiagnosticsNotification || (e.PublishDiagnosticsNotification = {})).type = new n.ProtocolNotificationType("textDocument/publishDiagnostics"), (M = e.CompletionTriggerKind || (e.CompletionTriggerKind = {})).Invoked = 1, M.TriggerCharacter = 2, M.TriggerForIncompleteCompletions = 3, (R = e.CompletionRequest || (e.CompletionRequest = {})).method = "textDocument/completion", R.type = new n.ProtocolRequestType(R.method), (I = e.CompletionResolveRequest || (e.CompletionResolveRequest = {})).method = "completionItem/resolve", I.type = new n.ProtocolRequestType(I.method), (j = e.HoverRequest || (e.HoverRequest = {})).method = "textDocument/hover", j.type = new n.ProtocolRequestType(j.method), (B = e.SignatureHelpTriggerKind || (e.SignatureHelpTriggerKind = {})).Invoked = 1, B.TriggerCharacter = 2, B.ContentChange = 3, (L = e.SignatureHelpRequest || (e.SignatureHelpRequest = {})).method = "textDocument/signatureHelp", L.type = new n.ProtocolRequestType(L.method), (q = e.DefinitionRequest || (e.DefinitionRequest = {})).method = "textDocument/definition", q.type = new n.ProtocolRequestType(q.method), (oe = e.ReferencesRequest || (e.ReferencesRequest = {})).method = "textDocument/references", oe.type = new n.ProtocolRequestType(oe.method), (ie = e.DocumentHighlightRequest || (e.DocumentHighlightRequest = {})).method = "textDocument/documentHighlight", ie.type = new n.ProtocolRequestType(ie.method), (se = e.DocumentSymbolRequest || (e.DocumentSymbolRequest = {})).method = "textDocument/documentSymbol", se.type = new n.ProtocolRequestType(se.method), (ae = e.CodeActionRequest || (e.CodeActionRequest = {})).method = "textDocument/codeAction", ae.type = new n.ProtocolRequestType(ae.method), (ue = e.CodeActionResolveRequest || (e.CodeActionResolveRequest = {})).method = "codeAction/resolve", ue.type = new n.ProtocolRequestType(ue.method), (ce = e.WorkspaceSymbolRequest || (e.WorkspaceSymbolRequest = {})).method = "workspace/symbol", ce.type = new n.ProtocolRequestType(ce.method), (le = e.CodeLensRequest || (e.CodeLensRequest = {})).method = "textDocument/codeLens", le.type = new n.ProtocolRequestType(le.method), (pe = e.CodeLensResolveRequest || (e.CodeLensResolveRequest = {})).method = "codeLens/resolve", pe.type = new n.ProtocolRequestType(pe.method), (fe = e.CodeLensRefreshRequest || (e.CodeLensRefreshRequest = {})).method = "workspace/codeLens/refresh", fe.type = new n.ProtocolRequestType0(fe.method), (de = e.DocumentLinkRequest || (e.DocumentLinkRequest = {})).method = "textDocument/documentLink", de.type = new n.ProtocolRequestType(de.method), (he = e.DocumentLinkResolveRequest || (e.DocumentLinkResolveRequest = {})).method = "documentLink/resolve", he.type = new n.ProtocolRequestType(he.method), (me = e.DocumentFormattingRequest || (e.DocumentFormattingRequest = {})).method = "textDocument/formatting", me.type = new n.ProtocolRequestType(me.method), (ge = e.DocumentRangeFormattingRequest || (e.DocumentRangeFormattingRequest = {})).method = "textDocument/rangeFormatting", ge.type = new n.ProtocolRequestType(ge.method), (ye = e.DocumentOnTypeFormattingRequest || (e.DocumentOnTypeFormattingRequest = {})).method = "textDocument/onTypeFormatting", ye.type = new n.ProtocolRequestType(ye.method), (e.PrepareSupportDefaultBehavior || (e.PrepareSupportDefaultBehavior = {})).Identifier = 1, (ve = e.RenameRequest || (e.RenameRequest = {})).method = "textDocument/rename", ve.type = new n.ProtocolRequestType(ve.method), (be = e.PrepareRenameRequest || (e.PrepareRenameRequest = {})).method = "textDocument/prepareRename", be.type = new n.ProtocolRequestType(be.method), (e.ExecuteCommandRequest || (e.ExecuteCommandRequest = {})).type = new n.ProtocolRequestType("workspace/executeCommand"), (e.ApplyWorkspaceEditRequest || (e.ApplyWorkspaceEditRequest = {})).type = new n.ProtocolRequestType("workspace/applyEdit"); } }), ie = v({ "../../node_modules/vscode-languageserver/node_modules/vscode-languageserver-protocol/lib/common/connection.js"(e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.createProtocolConnection = void 0; var t = B(); e.createProtocolConnection = function (e, n, r, o) { return t.ConnectionStrategy.is(o) && (o = { connectionStrategy: o }), t.createMessageConnection(e, n, r, o); }; } }), se = v({ "../../node_modules/vscode-languageserver/node_modules/vscode-languageserver-protocol/lib/common/api.js"(e) { var t = e && e.__createBinding || (Object.create ? function (e, t, n, r) { void 0 === r && (r = n), Object.defineProperty(e, r, { enumerable: !0, get: function () { return t[n]; } }); } : function (e, t, n, r) { void 0 === r && (r = n), e[r] = t[n]; }), n = e && e.__exportStar || function (e, n) { for (var r in e)
                "default" === r || Object.prototype.hasOwnProperty.call(n, r) || t(n, e, r); }; Object.defineProperty(e, "__esModule", { value: !0 }), e.LSPErrorCodes = e.createProtocolConnection = void 0, n(B(), e), n(q(), e), n($(), e), n(oe(), e); var r, o = ie(); Object.defineProperty(e, "createProtocolConnection", { enumerable: !0, get: function () { return o.createProtocolConnection; } }), (r = e.LSPErrorCodes || (e.LSPErrorCodes = {})).lspReservedErrorRangeStart = -32899, r.ContentModified = -32801, r.RequestCancelled = -32800, r.lspReservedErrorRangeEnd = -32800; } }), ae = v({ "../../node_modules/vscode-languageserver/node_modules/vscode-languageserver-protocol/lib/browser/main.js"(e) { var t = e && e.__createBinding || (Object.create ? function (e, t, n, r) { void 0 === r && (r = n), Object.defineProperty(e, r, { enumerable: !0, get: function () { return t[n]; } }); } : function (e, t, n, r) { void 0 === r && (r = n), e[r] = t[n]; }), n = e && e.__exportStar || function (e, n) { for (var r in e)
                "default" === r || Object.prototype.hasOwnProperty.call(n, r) || t(n, e, r); }; Object.defineProperty(e, "__esModule", { value: !0 }), e.createProtocolConnection = void 0; var r = L(); n(L(), e), n(se(), e), e.createProtocolConnection = function (e, t, n, o) { return r.createMessageConnection(e, t, n, o); }; } }), ue = v({ "../../node_modules/vscode-languageserver/lib/common/semanticTokens.js"(e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.SemanticTokensBuilder = e.SemanticTokensFeature = void 0; var t = ae(); e.SemanticTokensFeature = e => class extends e {
                get semanticTokens() { return { on: e => { const n = t.SemanticTokensRequest.type; this.connection.onRequest(n, ((t, r) => e(t, r, this.attachWorkDoneProgress(t), this.attachPartialResultProgress(n, t)))); }, onDelta: e => { const n = t.SemanticTokensDeltaRequest.type; this.connection.onRequest(n, ((t, r) => e(t, r, this.attachWorkDoneProgress(t), this.attachPartialResultProgress(n, t)))); }, onRange: e => { const n = t.SemanticTokensRangeRequest.type; this.connection.onRequest(n, ((t, r) => e(t, r, this.attachWorkDoneProgress(t), this.attachPartialResultProgress(n, t)))); } }; }
            }, e.SemanticTokensBuilder = class {
                constructor() { this._prevData = void 0, this.initialize(); }
                initialize() { this._id = Date.now(), this._prevLine = 0, this._prevChar = 0, this._data = [], this._dataLen = 0; }
                push(e, t, n, r, o) { let i = e, s = t; this._dataLen > 0 && (i -= this._prevLine, 0 === i && (s -= this._prevChar)), this._data[this._dataLen++] = i, this._data[this._dataLen++] = s, this._data[this._dataLen++] = n, this._data[this._dataLen++] = r, this._data[this._dataLen++] = o, this._prevLine = e, this._prevChar = t; }
                get id() { return this._id.toString(); }
                previousResult(e) { this.id === e && (this._prevData = this._data), this.initialize(); }
                build() { return this._prevData = void 0, { resultId: this.id, data: this._data }; }
                canBuildEdits() { return void 0 !== this._prevData; }
                buildEdits() { if (void 0 !== this._prevData) {
                    const e = this._prevData.length, t = this._data.length;
                    let n = 0;
                    for (; n < t && n < e && this._prevData[n] === this._data[n];)
                        n++;
                    if (n < t && n < e) {
                        let r = 0;
                        for (; r < t && r < e && this._prevData[e - 1 - r] === this._data[t - 1 - r];)
                            r++;
                        const o = this._data.slice(n, t - r);
                        return { resultId: this.id, edits: [{ start: n, deleteCount: e - r - n, data: o }] };
                    }
                    return n < t ? { resultId: this.id, edits: [{ start: n, deleteCount: 0, data: this._data.slice(n) }] } : n < e ? { resultId: this.id, edits: [{ start: n, deleteCount: e - n }] } : { resultId: this.id, edits: [] };
                } return this.build(); }
            }; } }), ce = v({ "../../node_modules/vscode-languageserver/lib/common/utils/is.js"(e) { function t(e) { return "string" == typeof e || e instanceof String; } function n(e) { return "function" == typeof e; } function r(e) { return Array.isArray(e); } Object.defineProperty(e, "__esModule", { value: !0 }), e.thenable = e.typedArray = e.stringArray = e.array = e.func = e.error = e.number = e.string = e.boolean = void 0, e.boolean = function (e) { return !0 === e || !1 === e; }, e.string = t, e.number = function (e) { return "number" == typeof e || e instanceof Number; }, e.error = function (e) { return e instanceof Error; }, e.func = n, e.array = r, e.stringArray = function (e) { return r(e) && e.every((e => t(e))); }, e.typedArray = function (e, t) { return Array.isArray(e) && e.every(t); }, e.thenable = function (e) { return e && n(e.then); }; } }), le = v({ "../../node_modules/vscode-languageserver/lib/common/utils/uuid.js"(e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.generateUuid = e.parse = e.isUUID = e.v4 = e.empty = void 0; var t = class {
                constructor(e) { this._value = e; }
                asHex() { return this._value; }
                equals(e) { return this.asHex() === e.asHex(); }
            }, n = class extends t {
                constructor() { super([n._randomHex(), n._randomHex(), n._randomHex(), n._randomHex(), n._randomHex(), n._randomHex(), n._randomHex(), n._randomHex(), "-", n._randomHex(), n._randomHex(), n._randomHex(), n._randomHex(), "-", "4", n._randomHex(), n._randomHex(), n._randomHex(), "-", n._oneOf(n._timeHighBits), n._randomHex(), n._randomHex(), n._randomHex(), "-", n._randomHex(), n._randomHex(), n._randomHex(), n._randomHex(), n._randomHex(), n._randomHex(), n._randomHex(), n._randomHex(), n._randomHex(), n._randomHex(), n._randomHex(), n._randomHex()].join("")); }
                static _oneOf(e) { return e[Math.floor(e.length * Math.random())]; }
                static _randomHex() { return n._oneOf(n._chars); }
            }; function r() { return new n; } n._chars = ["0", "1", "2", "3", "4", "5", "6", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"], n._timeHighBits = ["8", "9", "a", "b"], e.empty = new t("00000000-0000-0000-0000-000000000000"), e.v4 = r; var o = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i; function i(e) { return o.test(e); } e.isUUID = i, e.parse = function (e) { if (!i(e))
                throw new Error("invalid uuid"); return new t(e); }, e.generateUuid = function () { return r().asHex(); }; } }), pe = v({ "../../node_modules/vscode-languageserver/lib/common/progress.js"(e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.attachPartialResult = e.ProgressFeature = e.attachWorkDone = void 0; var t = ae(), n = le(), r = class {
                constructor(e, t) { this._connection = e, this._token = t, r.Instances.set(this._token, this); }
                begin(e, n, r, o) { let i = { kind: "begin", title: e, percentage: n, message: r, cancellable: o }; this._connection.sendProgress(t.WorkDoneProgress.type, this._token, i); }
                report(e, n) { let r = { kind: "report" }; "number" == typeof e ? (r.percentage = e, void 0 !== n && (r.message = n)) : r.message = e, this._connection.sendProgress(t.WorkDoneProgress.type, this._token, r); }
                done() { r.Instances.delete(this._token), this._connection.sendProgress(t.WorkDoneProgress.type, this._token, { kind: "end" }); }
            }; r.Instances = new Map; var o, i = class extends r {
                constructor(e, n) { super(e, n), this._source = new t.CancellationTokenSource; }
                get token() { return this._source.token; }
                done() { this._source.dispose(), super.done(); }
                cancel() { this._source.cancel(); }
            }, s = class {
                constructor() { }
                begin() { }
                report() { }
                done() { }
            }, a = class extends s {
                constructor() { super(), this._source = new t.CancellationTokenSource; }
                get token() { return this._source.token; }
                done() { this._source.dispose(); }
                cancel() { this._source.cancel(); }
            }; e.attachWorkDone = function (e, t) { if (void 0 === t || void 0 === t.workDoneToken)
                return new s; const n = t.workDoneToken; return delete t.workDoneToken, new r(e, n); }, e.ProgressFeature = e => class extends e {
                constructor() { super(), this._progressSupported = !1; }
                initialize(e) { var n; !0 === (null === (n = null == e ? void 0 : e.window) || void 0 === n ? void 0 : n.workDoneProgress) && (this._progressSupported = !0, this.connection.onNotification(t.WorkDoneProgressCancelNotification.type, (e => { let t = r.Instances.get(e.token); (t instanceof i || t instanceof a) && t.cancel(); }))); }
                attachWorkDoneProgress(e) { return void 0 === e ? new s : new r(this.connection, e); }
                createWorkDoneProgress() { if (this._progressSupported) {
                    const e = n.generateUuid();
                    return this.connection.sendRequest(t.WorkDoneProgressCreateRequest.type, { token: e }).then((() => new i(this.connection, e)));
                } return Promise.resolve(new a); }
            }, (o || (o = {})).type = new t.ProgressType, e.attachPartialResult = function (e, t) { if (void 0 === t || void 0 === t.partialResultToken)
                return; const n = t.partialResultToken; return delete t.partialResultToken, new class {
                constructor(e, t) { this._connection = e, this._token = t; }
                report(e) { this._connection.sendProgress(o.type, this._token, e); }
            }(e, n); }; } }), fe = v({ "../../node_modules/vscode-languageserver/lib/common/configuration.js"(e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.ConfigurationFeature = void 0; var t = ae(), n = ce(); e.ConfigurationFeature = e => class extends e {
                getConfiguration(e) { return e ? n.string(e) ? this._getConfiguration({ section: e }) : this._getConfiguration(e) : this._getConfiguration({}); }
                _getConfiguration(e) { let n = { items: Array.isArray(e) ? e : [e] }; return this.connection.sendRequest(t.ConfigurationRequest.type, n).then((t => Array.isArray(e) ? t : t[0])); }
            }; } }), de = v({ "../../node_modules/vscode-languageserver/lib/common/workspaceFolders.js"(e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.WorkspaceFoldersFeature = void 0; var t = ae(); e.WorkspaceFoldersFeature = e => class extends e {
                initialize(e) { let n = e.workspace; n && n.workspaceFolders && (this._onDidChangeWorkspaceFolders = new t.Emitter, this.connection.onNotification(t.DidChangeWorkspaceFoldersNotification.type, (e => { this._onDidChangeWorkspaceFolders.fire(e.event); }))); }
                getWorkspaceFolders() { return this.connection.sendRequest(t.WorkspaceFoldersRequest.type); }
                get onDidChangeWorkspaceFolders() { if (!this._onDidChangeWorkspaceFolders)
                    throw new Error("Client doesn't support sending workspace folder change events."); return this._unregistration || (this._unregistration = this.connection.client.register(t.DidChangeWorkspaceFoldersNotification.type)), this._onDidChangeWorkspaceFolders.event; }
            }; } }), he = v({ "../../node_modules/vscode-languageserver/lib/common/callHierarchy.js"(e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.CallHierarchyFeature = void 0; var t = ae(); e.CallHierarchyFeature = e => class extends e {
                get callHierarchy() { return { onPrepare: e => { this.connection.onRequest(t.CallHierarchyPrepareRequest.type, ((t, n) => e(t, n, this.attachWorkDoneProgress(t), void 0))); }, onIncomingCalls: e => { const n = t.CallHierarchyIncomingCallsRequest.type; this.connection.onRequest(n, ((t, r) => e(t, r, this.attachWorkDoneProgress(t), this.attachPartialResultProgress(n, t)))); }, onOutgoingCalls: e => { const n = t.CallHierarchyOutgoingCallsRequest.type; this.connection.onRequest(n, ((t, r) => e(t, r, this.attachWorkDoneProgress(t), this.attachPartialResultProgress(n, t)))); } }; }
            }; } }), me = v({ "../../node_modules/vscode-languageserver/lib/common/showDocument.js"(e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.ShowDocumentFeature = void 0; var t = ae(); e.ShowDocumentFeature = e => class extends e {
                showDocument(e) { return this.connection.sendRequest(t.ShowDocumentRequest.type, e); }
            }; } }), ge = v({ "../../node_modules/vscode-languageserver/lib/common/fileOperations.js"(e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.FileOperationsFeature = void 0; var t = ae(); e.FileOperationsFeature = e => class extends e {
                onDidCreateFiles(e) { this.connection.onNotification(t.DidCreateFilesNotification.type, (t => { e(t); })); }
                onDidRenameFiles(e) { this.connection.onNotification(t.DidRenameFilesNotification.type, (t => { e(t); })); }
                onDidDeleteFiles(e) { this.connection.onNotification(t.DidDeleteFilesNotification.type, (t => { e(t); })); }
                onWillCreateFiles(e) { return this.connection.onRequest(t.WillCreateFilesRequest.type, ((t, n) => e(t, n))); }
                onWillRenameFiles(e) { return this.connection.onRequest(t.WillRenameFilesRequest.type, ((t, n) => e(t, n))); }
                onWillDeleteFiles(e) { return this.connection.onRequest(t.WillDeleteFilesRequest.type, ((t, n) => e(t, n))); }
            }; } }), ye = v({ "../../node_modules/vscode-languageserver/lib/common/linkedEditingRange.js"(e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.LinkedEditingRangeFeature = void 0; var t = ae(); e.LinkedEditingRangeFeature = e => class extends e {
                onLinkedEditingRange(e) { this.connection.onRequest(t.LinkedEditingRangeRequest.type, ((t, n) => e(t, n, this.attachWorkDoneProgress(t), void 0))); }
            }; } }), ve = v({ "../../node_modules/vscode-languageserver/lib/common/moniker.js"(e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.MonikerFeature = void 0; var t = ae(); e.MonikerFeature = e => class extends e {
                get moniker() { return { on: e => { const n = t.MonikerRequest.type; this.connection.onRequest(n, ((t, r) => e(t, r, this.attachWorkDoneProgress(t), this.attachPartialResultProgress(n, t)))); } }; }
            }; } }), be = v({ "../../node_modules/vscode-languageserver/lib/common/server.js"(e) { Object.defineProperty(e, "__esModule", { value: !0 }), e.createConnection = e.combineFeatures = e.combineLanguagesFeatures = e.combineWorkspaceFeatures = e.combineWindowFeatures = e.combineClientFeatures = e.combineTracerFeatures = e.combineTelemetryFeatures = e.combineConsoleFeatures = e._LanguagesImpl = e.BulkUnregistration = e.BulkRegistration = e.ErrorMessageTracker = e.TextDocuments = void 0; var t = ae(), n = ce(), r = le(), o = pe(), i = fe(), s = de(), a = he(), u = ue(), c = me(), l = ge(), p = ye(), f = ve(); function d(e) { if (null !== e)
                return e; } e.TextDocuments = class {
                constructor(e) { this._documents = Object.create(null), this._configuration = e, this._onDidChangeContent = new t.Emitter, this._onDidOpen = new t.Emitter, this._onDidClose = new t.Emitter, this._onDidSave = new t.Emitter, this._onWillSave = new t.Emitter; }
                get onDidChangeContent() { return this._onDidChangeContent.event; }
                get onDidOpen() { return this._onDidOpen.event; }
                get onWillSave() { return this._onWillSave.event; }
                onWillSaveWaitUntil(e) { this._willSaveWaitUntil = e; }
                get onDidSave() { return this._onDidSave.event; }
                get onDidClose() { return this._onDidClose.event; }
                get(e) { return this._documents[e]; }
                all() { return Object.keys(this._documents).map((e => this._documents[e])); }
                keys() { return Object.keys(this._documents); }
                listen(e) { e.__textDocumentSync = t.TextDocumentSyncKind.Full, e.onDidOpenTextDocument((e => { let t = e.textDocument, n = this._configuration.create(t.uri, t.languageId, t.version, t.text); this._documents[t.uri] = n; let r = Object.freeze({ document: n }); this._onDidOpen.fire(r), this._onDidChangeContent.fire(r); })), e.onDidChangeTextDocument((e => { let t = e.textDocument, n = e.contentChanges; if (0 === n.length)
                    return; let r = this._documents[t.uri]; const { version: o } = t; if (null == o)
                    throw new Error(`Received document change event for ${t.uri} without valid version identifier`); r = this._configuration.update(r, n, o), this._documents[t.uri] = r, this._onDidChangeContent.fire(Object.freeze({ document: r })); })), e.onDidCloseTextDocument((e => { let t = this._documents[e.textDocument.uri]; t && (delete this._documents[e.textDocument.uri], this._onDidClose.fire(Object.freeze({ document: t }))); })), e.onWillSaveTextDocument((e => { let t = this._documents[e.textDocument.uri]; t && this._onWillSave.fire(Object.freeze({ document: t, reason: e.reason })); })), e.onWillSaveTextDocumentWaitUntil(((e, t) => { let n = this._documents[e.textDocument.uri]; return n && this._willSaveWaitUntil ? this._willSaveWaitUntil(Object.freeze({ document: n, reason: e.reason }), t) : []; })), e.onDidSaveTextDocument((e => { let t = this._documents[e.textDocument.uri]; t && this._onDidSave.fire(Object.freeze({ document: t })); })); }
            }, e.ErrorMessageTracker = class {
                constructor() { this._messages = Object.create(null); }
                add(e) { let t = this._messages[e]; t || (t = 0), t++, this._messages[e] = t; }
                sendErrors(e) { Object.keys(this._messages).forEach((t => { e.window.showErrorMessage(t); })); }
            }; var h = class {
                constructor() { }
                rawAttach(e) { this._rawConnection = e; }
                attach(e) { this._connection = e; }
                get connection() { if (!this._connection)
                    throw new Error("Remote is not attached to a connection yet."); return this._connection; }
                fillServerCapabilities(e) { }
                initialize(e) { }
                error(e) { this.send(t.MessageType.Error, e); }
                warn(e) { this.send(t.MessageType.Warning, e); }
                info(e) { this.send(t.MessageType.Info, e); }
                log(e) { this.send(t.MessageType.Log, e); }
                send(e, n) { this._rawConnection && this._rawConnection.sendNotification(t.LogMessageNotification.type, { type: e, message: n }); }
            }, m = c.ShowDocumentFeature(o.ProgressFeature(class {
                constructor() { }
                attach(e) { this._connection = e; }
                get connection() { if (!this._connection)
                    throw new Error("Remote is not attached to a connection yet."); return this._connection; }
                initialize(e) { }
                fillServerCapabilities(e) { }
                showErrorMessage(e, ...n) { let r = { type: t.MessageType.Error, message: e, actions: n }; return this.connection.sendRequest(t.ShowMessageRequest.type, r).then(d); }
                showWarningMessage(e, ...n) { let r = { type: t.MessageType.Warning, message: e, actions: n }; return this.connection.sendRequest(t.ShowMessageRequest.type, r).then(d); }
                showInformationMessage(e, ...n) { let r = { type: t.MessageType.Info, message: e, actions: n }; return this.connection.sendRequest(t.ShowMessageRequest.type, r).then(d); }
            })); (e.BulkRegistration || (e.BulkRegistration = {})).create = function () { return new g; }; var g = class {
                constructor() { this._registrations = [], this._registered = new Set; }
                add(e, t) { const o = n.string(e) ? e : e.method; if (this._registered.has(o))
                    throw new Error(`${o} is already added to this registration`); const i = r.generateUuid(); this._registrations.push({ id: i, method: o, registerOptions: t || {} }), this._registered.add(o); }
                asRegistrationParams() { return { registrations: this._registrations }; }
            }; (e.BulkUnregistration || (e.BulkUnregistration = {})).create = function () { return new y(void 0, []); }; var y = class {
                constructor(e, t) { this._connection = e, this._unregistrations = new Map, t.forEach((e => { this._unregistrations.set(e.method, e); })); }
                get isAttached() { return !!this._connection; }
                attach(e) { this._connection = e; }
                add(e) { this._unregistrations.set(e.method, e); }
                dispose() { let e = []; for (let t of this._unregistrations.values())
                    e.push(t); let n = { unregisterations: e }; this._connection.sendRequest(t.UnregistrationRequest.type, n).then(void 0, (e => { this._connection.console.info("Bulk unregistration failed."); })); }
                disposeSingle(e) { const r = n.string(e) ? e : e.method, o = this._unregistrations.get(r); if (!o)
                    return !1; let i = { unregisterations: [o] }; return this._connection.sendRequest(t.UnregistrationRequest.type, i).then((() => { this._unregistrations.delete(r); }), (e => { this._connection.console.info(`Un-registering request handler for ${o.id} failed.`); })), !0; }
            }, v = class {
                attach(e) { this._connection = e; }
                get connection() { if (!this._connection)
                    throw new Error("Remote is not attached to a connection yet."); return this._connection; }
                initialize(e) { }
                fillServerCapabilities(e) { }
                register(e, t, n) { return e instanceof g ? this.registerMany(e) : e instanceof y ? this.registerSingle1(e, t, n) : this.registerSingle2(e, t); }
                registerSingle1(e, o, i) { const s = n.string(o) ? o : o.method, a = r.generateUuid(); let u = { registrations: [{ id: a, method: s, registerOptions: i || {} }] }; return e.isAttached || e.attach(this.connection), this.connection.sendRequest(t.RegistrationRequest.type, u).then((t => (e.add({ id: a, method: s }), e)), (e => (this.connection.console.info(`Registering request handler for ${s} failed.`), Promise.reject(e)))); }
                registerSingle2(e, o) { const i = n.string(e) ? e : e.method, s = r.generateUuid(); let a = { registrations: [{ id: s, method: i, registerOptions: o || {} }] }; return this.connection.sendRequest(t.RegistrationRequest.type, a).then((e => t.Disposable.create((() => { this.unregisterSingle(s, i); }))), (e => (this.connection.console.info(`Registering request handler for ${i} failed.`), Promise.reject(e)))); }
                unregisterSingle(e, n) { let r = { unregisterations: [{ id: e, method: n }] }; return this.connection.sendRequest(t.UnregistrationRequest.type, r).then(void 0, (t => { this.connection.console.info(`Un-registering request handler for ${e} failed.`); })); }
                registerMany(e) { let n = e.asRegistrationParams(); return this.connection.sendRequest(t.RegistrationRequest.type, n).then((() => new y(this._connection, n.registrations.map((e => ({ id: e.id, method: e.method }))))), (e => (this.connection.console.info("Bulk registration failed."), Promise.reject(e)))); }
            }, b = l.FileOperationsFeature(s.WorkspaceFoldersFeature(i.ConfigurationFeature(class {
                constructor() { }
                attach(e) { this._connection = e; }
                get connection() { if (!this._connection)
                    throw new Error("Remote is not attached to a connection yet."); return this._connection; }
                initialize(e) { }
                fillServerCapabilities(e) { }
                applyEdit(e) { let n = (r = e) && r.edit ? e : { edit: e }; var r; return this.connection.sendRequest(t.ApplyWorkspaceEditRequest.type, n); }
            }))), D = class {
                constructor() { this._trace = t.Trace.Off; }
                attach(e) { this._connection = e; }
                get connection() { if (!this._connection)
                    throw new Error("Remote is not attached to a connection yet."); return this._connection; }
                initialize(e) { }
                fillServerCapabilities(e) { }
                set trace(e) { this._trace = e; }
                log(e, n) { this._trace !== t.Trace.Off && this.connection.sendNotification(t.LogTraceNotification.type, { message: e, verbose: this._trace === t.Trace.Verbose ? n : void 0 }); }
            }, E = class {
                constructor() { }
                attach(e) { this._connection = e; }
                get connection() { if (!this._connection)
                    throw new Error("Remote is not attached to a connection yet."); return this._connection; }
                initialize(e) { }
                fillServerCapabilities(e) { }
                logEvent(e) { this.connection.sendNotification(t.TelemetryEventNotification.type, e); }
            }, C = class {
                constructor() { }
                attach(e) { this._connection = e; }
                get connection() { if (!this._connection)
                    throw new Error("Remote is not attached to a connection yet."); return this._connection; }
                initialize(e) { }
                fillServerCapabilities(e) { }
                attachWorkDoneProgress(e) { return o.attachWorkDone(this.connection, e); }
                attachPartialResultProgress(e, t) { return o.attachPartialResult(this.connection, t); }
            }; e._LanguagesImpl = C; var w = f.MonikerFeature(p.LinkedEditingRangeFeature(u.SemanticTokensFeature(a.CallHierarchyFeature(C)))); function A(e, t) { return function (n) { return t(e(n)); }; } function S(e, t) { return function (n) { return t(e(n)); }; } function x(e, t) { return function (n) { return t(e(n)); }; } function T(e, t) { return function (n) { return t(e(n)); }; } function k(e, t) { return function (n) { return t(e(n)); }; } function F(e, t) { return function (n) { return t(e(n)); }; } e.combineConsoleFeatures = A, e.combineTelemetryFeatures = S, e.combineTracerFeatures = x, e.combineClientFeatures = T, e.combineWindowFeatures = k, e.combineWorkspaceFeatures = F, e.combineLanguagesFeatures = function (e, t) { return function (n) { return t(e(n)); }; }, e.combineFeatures = function (e, t) { function n(e, t, n) { return e && t ? n(e, t) : e || t; } return { __brand: "features", console: n(e.console, t.console, A), tracer: n(e.tracer, t.tracer, x), telemetry: n(e.telemetry, t.telemetry, S), client: n(e.client, t.client, T), window: n(e.window, t.window, k), workspace: n(e.workspace, t.workspace, F) }; }, e.createConnection = function (e, r, i) { const s = i && i.console ? new (i.console(h)) : new h, a = e(s); s.rawAttach(a); const u = i && i.tracer ? new (i.tracer(D)) : new D, c = i && i.telemetry ? new (i.telemetry(E)) : new E, l = i && i.client ? new (i.client(v)) : new v, p = i && i.window ? new (i.window(m)) : new m, f = i && i.workspace ? new (i.workspace(b)) : new b, d = i && i.languages ? new (i.languages(w)) : new w, g = [s, u, c, l, p, f, d]; function y(e) { return e instanceof Promise ? e : n.thenable(e) ? new Promise(((t, n) => { e.then((e => t(e)), (e => n(e))); })) : Promise.resolve(e); } let C, A, S, x = { listen: () => a.listen(), sendRequest: (e, ...t) => a.sendRequest(n.string(e) ? e : e.method, ...t), onRequest: (e, t) => a.onRequest(e, t), sendNotification: (e, t) => { const r = n.string(e) ? e : e.method; 1 === arguments.length ? a.sendNotification(r) : a.sendNotification(r, t); }, onNotification: (e, t) => a.onNotification(e, t), onProgress: a.onProgress, sendProgress: a.sendProgress, onInitialize: e => A = e, onInitialized: e => a.onNotification(t.InitializedNotification.type, e), onShutdown: e => C = e, onExit: e => S = e, get console() { return s; }, get telemetry() { return c; }, get tracer() { return u; }, get client() { return l; }, get window() { return p; }, get workspace() { return f; }, get languages() { return d; }, onDidChangeConfiguration: e => a.onNotification(t.DidChangeConfigurationNotification.type, e), onDidChangeWatchedFiles: e => a.onNotification(t.DidChangeWatchedFilesNotification.type, e), __textDocumentSync: void 0, onDidOpenTextDocument: e => a.onNotification(t.DidOpenTextDocumentNotification.type, e), onDidChangeTextDocument: e => a.onNotification(t.DidChangeTextDocumentNotification.type, e), onDidCloseTextDocument: e => a.onNotification(t.DidCloseTextDocumentNotification.type, e), onWillSaveTextDocument: e => a.onNotification(t.WillSaveTextDocumentNotification.type, e), onWillSaveTextDocumentWaitUntil: e => a.onRequest(t.WillSaveTextDocumentWaitUntilRequest.type, e), onDidSaveTextDocument: e => a.onNotification(t.DidSaveTextDocumentNotification.type, e), sendDiagnostics: e => a.sendNotification(t.PublishDiagnosticsNotification.type, e), onHover: e => a.onRequest(t.HoverRequest.type, ((t, n) => e(t, n, o.attachWorkDone(a, t), void 0))), onCompletion: e => a.onRequest(t.CompletionRequest.type, ((t, n) => e(t, n, o.attachWorkDone(a, t), o.attachPartialResult(a, t)))), onCompletionResolve: e => a.onRequest(t.CompletionResolveRequest.type, e), onSignatureHelp: e => a.onRequest(t.SignatureHelpRequest.type, ((t, n) => e(t, n, o.attachWorkDone(a, t), void 0))), onDeclaration: e => a.onRequest(t.DeclarationRequest.type, ((t, n) => e(t, n, o.attachWorkDone(a, t), o.attachPartialResult(a, t)))), onDefinition: e => a.onRequest(t.DefinitionRequest.type, ((t, n) => e(t, n, o.attachWorkDone(a, t), o.attachPartialResult(a, t)))), onTypeDefinition: e => a.onRequest(t.TypeDefinitionRequest.type, ((t, n) => e(t, n, o.attachWorkDone(a, t), o.attachPartialResult(a, t)))), onImplementation: e => a.onRequest(t.ImplementationRequest.type, ((t, n) => e(t, n, o.attachWorkDone(a, t), o.attachPartialResult(a, t)))), onReferences: e => a.onRequest(t.ReferencesRequest.type, ((t, n) => e(t, n, o.attachWorkDone(a, t), o.attachPartialResult(a, t)))), onDocumentHighlight: e => a.onRequest(t.DocumentHighlightRequest.type, ((t, n) => e(t, n, o.attachWorkDone(a, t), o.attachPartialResult(a, t)))), onDocumentSymbol: e => a.onRequest(t.DocumentSymbolRequest.type, ((t, n) => e(t, n, o.attachWorkDone(a, t), o.attachPartialResult(a, t)))), onWorkspaceSymbol: e => a.onRequest(t.WorkspaceSymbolRequest.type, ((t, n) => e(t, n, o.attachWorkDone(a, t), o.attachPartialResult(a, t)))), onCodeAction: e => a.onRequest(t.CodeActionRequest.type, ((t, n) => e(t, n, o.attachWorkDone(a, t), o.attachPartialResult(a, t)))), onCodeActionResolve: e => a.onRequest(t.CodeActionResolveRequest.type, ((t, n) => e(t, n))), onCodeLens: e => a.onRequest(t.CodeLensRequest.type, ((t, n) => e(t, n, o.attachWorkDone(a, t), o.attachPartialResult(a, t)))), onCodeLensResolve: e => a.onRequest(t.CodeLensResolveRequest.type, ((t, n) => e(t, n))), onDocumentFormatting: e => a.onRequest(t.DocumentFormattingRequest.type, ((t, n) => e(t, n, o.attachWorkDone(a, t), void 0))), onDocumentRangeFormatting: e => a.onRequest(t.DocumentRangeFormattingRequest.type, ((t, n) => e(t, n, o.attachWorkDone(a, t), void 0))), onDocumentOnTypeFormatting: e => a.onRequest(t.DocumentOnTypeFormattingRequest.type, ((t, n) => e(t, n))), onRenameRequest: e => a.onRequest(t.RenameRequest.type, ((t, n) => e(t, n, o.attachWorkDone(a, t), void 0))), onPrepareRename: e => a.onRequest(t.PrepareRenameRequest.type, ((t, n) => e(t, n))), onDocumentLinks: e => a.onRequest(t.DocumentLinkRequest.type, ((t, n) => e(t, n, o.attachWorkDone(a, t), o.attachPartialResult(a, t)))), onDocumentLinkResolve: e => a.onRequest(t.DocumentLinkResolveRequest.type, ((t, n) => e(t, n))), onDocumentColor: e => a.onRequest(t.DocumentColorRequest.type, ((t, n) => e(t, n, o.attachWorkDone(a, t), o.attachPartialResult(a, t)))), onColorPresentation: e => a.onRequest(t.ColorPresentationRequest.type, ((t, n) => e(t, n, o.attachWorkDone(a, t), o.attachPartialResult(a, t)))), onFoldingRanges: e => a.onRequest(t.FoldingRangeRequest.type, ((t, n) => e(t, n, o.attachWorkDone(a, t), o.attachPartialResult(a, t)))), onSelectionRanges: e => a.onRequest(t.SelectionRangeRequest.type, ((t, n) => e(t, n, o.attachWorkDone(a, t), o.attachPartialResult(a, t)))), onExecuteCommand: e => a.onRequest(t.ExecuteCommandRequest.type, ((t, n) => e(t, n, o.attachWorkDone(a, t), void 0))), dispose: () => a.dispose() }; for (let e of g)
                e.attach(x); return a.onRequest(t.InitializeRequest.type, (e => { r.initialize(e), n.string(e.trace) && (u.trace = t.Trace.fromString(e.trace)); for (let t of g)
                t.initialize(e.capabilities); if (A)
                return y(A(e, (new t.CancellationTokenSource).token, o.attachWorkDone(a, e), void 0)).then((e => { if (e instanceof t.ResponseError)
                    return e; let r = e; r || (r = { capabilities: {} }); let o = r.capabilities; o || (o = {}, r.capabilities = o), void 0 === o.textDocumentSync || null === o.textDocumentSync ? o.textDocumentSync = n.number(x.__textDocumentSync) ? x.__textDocumentSync : t.TextDocumentSyncKind.None : n.number(o.textDocumentSync) || n.number(o.textDocumentSync.change) || (o.textDocumentSync.change = n.number(x.__textDocumentSync) ? x.__textDocumentSync : t.TextDocumentSyncKind.None); for (let e of g)
                    e.fillServerCapabilities(o); return r; })); {
                let e = { capabilities: { textDocumentSync: t.TextDocumentSyncKind.None } };
                for (let t of g)
                    t.fillServerCapabilities(e.capabilities);
                return e;
            } })), a.onRequest(t.ShutdownRequest.type, (() => (r.shutdownReceived = !0, C ? C((new t.CancellationTokenSource).token) : void 0))), a.onNotification(t.ExitNotification.type, (() => { try {
                S && S();
            }
            finally {
                r.shutdownReceived ? r.exit(0) : r.exit(1);
            } })), a.onNotification(t.SetTraceNotification.type, (e => { u.trace = t.Trace.fromString(e.value); })), x; }; } }), De = v({ "../../node_modules/vscode-languageserver/lib/common/api.js"(e) { var t = e && e.__createBinding || (Object.create ? function (e, t, n, r) { void 0 === r && (r = n), Object.defineProperty(e, r, { enumerable: !0, get: function () { return t[n]; } }); } : function (e, t, n, r) { void 0 === r && (r = n), e[r] = t[n]; }), n = e && e.__exportStar || function (e, n) { for (var r in e)
                "default" === r || Object.prototype.hasOwnProperty.call(n, r) || t(n, e, r); }; Object.defineProperty(e, "__esModule", { value: !0 }), e.ProposedFeatures = e.SemanticTokensBuilder = void 0; var r = ue(); Object.defineProperty(e, "SemanticTokensBuilder", { enumerable: !0, get: function () { return r.SemanticTokensBuilder; } }), n(ae(), e), n(be(), e), (e.ProposedFeatures || (e.ProposedFeatures = {})).all = { __brand: "features" }; } }), Ee = v({ "../../node_modules/vscode-languageserver/node_modules/vscode-languageserver-protocol/browser.js"(e, t) { t.exports = ae(); } }), Ce = v({ "../../node_modules/vscode-languageserver/lib/browser/main.js"(e) { var t = e && e.__createBinding || (Object.create ? function (e, t, n, r) { void 0 === r && (r = n), Object.defineProperty(e, r, { enumerable: !0, get: function () { return t[n]; } }); } : function (e, t, n, r) { void 0 === r && (r = n), e[r] = t[n]; }), n = e && e.__exportStar || function (e, n) { for (var r in e)
                "default" === r || Object.prototype.hasOwnProperty.call(n, r) || t(n, e, r); }; Object.defineProperty(e, "__esModule", { value: !0 }), e.createConnection = void 0; var r = De(); n(Ee(), e), n(De(), e); var o = !1, i = { initialize: e => { }, get shutdownReceived() { return o; }, set shutdownReceived(e) { o = e; }, exit: e => { } }; e.createConnection = function (e, t, n, o) { let s, a, u, c; return void 0 !== e && "features" === e.__brand && (s = e, e = t, t = n, n = o), r.ConnectionStrategy.is(e) || r.ConnectionOptions.is(e) ? c = e : (a = e, u = t, c = n), r.createConnection((e => r.createProtocolConnection(a, u, e, c)), i, s); }; } });
        function we(e, t = !1) { const n = e.length; let r = 0, o = "", i = 0, s = 16, a = 0, u = 0, c = 0, l = 0, p = 0; function f(t, n) { let o = 0, i = 0; for (; o < t || !n;) {
            let t = e.charCodeAt(r);
            if (t >= 48 && t <= 57)
                i = 16 * i + t - 48;
            else if (t >= 65 && t <= 70)
                i = 16 * i + t - 65 + 10;
            else {
                if (!(t >= 97 && t <= 102))
                    break;
                i = 16 * i + t - 97 + 10;
            }
            r++, o++;
        } return o < t && (i = -1), i; } function d() { if (o = "", p = 0, i = r, u = a, l = c, r >= n)
            return i = n, s = 17; let t = e.charCodeAt(r); if (Ae(t)) {
            do {
                r++, o += String.fromCharCode(t), t = e.charCodeAt(r);
            } while (Ae(t));
            return s = 15;
        } if (Se(t))
            return r++, o += String.fromCharCode(t), 13 === t && 10 === e.charCodeAt(r) && (r++, o += "\n"), a++, c = r, s = 14; switch (t) {
            case 123: return r++, s = 1;
            case 125: return r++, s = 2;
            case 91: return r++, s = 3;
            case 93: return r++, s = 4;
            case 58: return r++, s = 6;
            case 44: return r++, s = 5;
            case 34: return r++, o = function () { let t = "", o = r; for (;;) {
                if (r >= n) {
                    t += e.substring(o, r), p = 2;
                    break;
                }
                const i = e.charCodeAt(r);
                if (34 === i) {
                    t += e.substring(o, r), r++;
                    break;
                }
                if (92 !== i) {
                    if (i >= 0 && i <= 31) {
                        if (Se(i)) {
                            t += e.substring(o, r), p = 2;
                            break;
                        }
                        p = 6;
                    }
                    r++;
                }
                else {
                    if (t += e.substring(o, r), r++, r >= n) {
                        p = 2;
                        break;
                    }
                    switch (e.charCodeAt(r++)) {
                        case 34:
                            t += '"';
                            break;
                        case 92:
                            t += "\\";
                            break;
                        case 47:
                            t += "/";
                            break;
                        case 98:
                            t += "\b";
                            break;
                        case 102:
                            t += "\f";
                            break;
                        case 110:
                            t += "\n";
                            break;
                        case 114:
                            t += "\r";
                            break;
                        case 116:
                            t += "\t";
                            break;
                        case 117:
                            const e = f(4, !0);
                            e >= 0 ? t += String.fromCharCode(e) : p = 4;
                            break;
                        default: p = 5;
                    }
                    o = r;
                }
            } return t; }(), s = 10;
            case 47:
                const u = r - 1;
                if (47 === e.charCodeAt(r + 1)) {
                    for (r += 2; r < n && !Se(e.charCodeAt(r));)
                        r++;
                    return o = e.substring(u, r), s = 12;
                }
                if (42 === e.charCodeAt(r + 1)) {
                    r += 2;
                    const t = n - 1;
                    let i = !1;
                    for (; r < t;) {
                        const t = e.charCodeAt(r);
                        if (42 === t && 47 === e.charCodeAt(r + 1)) {
                            r += 2, i = !0;
                            break;
                        }
                        r++, Se(t) && (13 === t && 10 === e.charCodeAt(r) && r++, a++, c = r);
                    }
                    return i || (r++, p = 1), o = e.substring(u, r), s = 13;
                }
                return o += String.fromCharCode(t), r++, s = 16;
            case 45: if (o += String.fromCharCode(t), r++, r === n || !xe(e.charCodeAt(r)))
                return s = 16;
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57: return o += function () { let t = r; if (48 === e.charCodeAt(r))
                r++;
            else
                for (r++; r < e.length && xe(e.charCodeAt(r));)
                    r++; if (r < e.length && 46 === e.charCodeAt(r)) {
                if (r++, !(r < e.length && xe(e.charCodeAt(r))))
                    return p = 3, e.substring(t, r);
                for (r++; r < e.length && xe(e.charCodeAt(r));)
                    r++;
            } let n = r; if (r < e.length && (69 === e.charCodeAt(r) || 101 === e.charCodeAt(r)))
                if (r++, (r < e.length && 43 === e.charCodeAt(r) || 45 === e.charCodeAt(r)) && r++, r < e.length && xe(e.charCodeAt(r))) {
                    for (r++; r < e.length && xe(e.charCodeAt(r));)
                        r++;
                    n = r;
                }
                else
                    p = 3; return e.substring(t, n); }(), s = 11;
            default:
                for (; r < n && h(t);)
                    r++, t = e.charCodeAt(r);
                if (i !== r) {
                    switch (o = e.substring(i, r), o) {
                        case "true": return s = 8;
                        case "false": return s = 9;
                        case "null": return s = 7;
                    }
                    return s = 16;
                }
                return o += String.fromCharCode(t), r++, s = 16;
        } } function h(e) { if (Ae(e) || Se(e))
            return !1; switch (e) {
            case 125:
            case 93:
            case 123:
            case 91:
            case 34:
            case 58:
            case 44:
            case 47: return !1;
        } return !0; } return { setPosition: function (e) { r = e, o = "", i = 0, s = 16, p = 0; }, getPosition: () => r, scan: t ? function () { let e; do {
                e = d();
            } while (e >= 12 && e <= 15); return e; } : d, getToken: () => s, getTokenValue: () => o, getTokenOffset: () => i, getTokenLength: () => r - i, getTokenStartLine: () => u, getTokenStartCharacter: () => i - l, getTokenError: () => p }; }
        function Ae(e) { return 32 === e || 9 === e; }
        function Se(e) { return 10 === e || 13 === e; }
        function xe(e) { return e >= 48 && e <= 57; }
        (l = c || (c = {}))[l.lineFeed = 10] = "lineFeed", l[l.carriageReturn = 13] = "carriageReturn", l[l.space = 32] = "space", l[l._0 = 48] = "_0", l[l._1 = 49] = "_1", l[l._2 = 50] = "_2", l[l._3 = 51] = "_3", l[l._4 = 52] = "_4", l[l._5 = 53] = "_5", l[l._6 = 54] = "_6", l[l._7 = 55] = "_7", l[l._8 = 56] = "_8", l[l._9 = 57] = "_9", l[l.a = 97] = "a", l[l.b = 98] = "b", l[l.c = 99] = "c", l[l.d = 100] = "d", l[l.e = 101] = "e", l[l.f = 102] = "f", l[l.g = 103] = "g", l[l.h = 104] = "h", l[l.i = 105] = "i", l[l.j = 106] = "j", l[l.k = 107] = "k", l[l.l = 108] = "l", l[l.m = 109] = "m", l[l.n = 110] = "n", l[l.o = 111] = "o", l[l.p = 112] = "p", l[l.q = 113] = "q", l[l.r = 114] = "r", l[l.s = 115] = "s", l[l.t = 116] = "t", l[l.u = 117] = "u", l[l.v = 118] = "v", l[l.w = 119] = "w", l[l.x = 120] = "x", l[l.y = 121] = "y", l[l.z = 122] = "z", l[l.A = 65] = "A", l[l.B = 66] = "B", l[l.C = 67] = "C", l[l.D = 68] = "D", l[l.E = 69] = "E", l[l.F = 70] = "F", l[l.G = 71] = "G", l[l.H = 72] = "H", l[l.I = 73] = "I", l[l.J = 74] = "J", l[l.K = 75] = "K", l[l.L = 76] = "L", l[l.M = 77] = "M", l[l.N = 78] = "N", l[l.O = 79] = "O", l[l.P = 80] = "P", l[l.Q = 81] = "Q", l[l.R = 82] = "R", l[l.S = 83] = "S", l[l.T = 84] = "T", l[l.U = 85] = "U", l[l.V = 86] = "V", l[l.W = 87] = "W", l[l.X = 88] = "X", l[l.Y = 89] = "Y", l[l.Z = 90] = "Z", l[l.asterisk = 42] = "asterisk", l[l.backslash = 92] = "backslash", l[l.closeBrace = 125] = "closeBrace", l[l.closeBracket = 93] = "closeBracket", l[l.colon = 58] = "colon", l[l.comma = 44] = "comma", l[l.dot = 46] = "dot", l[l.doubleQuote = 34] = "doubleQuote", l[l.minus = 45] = "minus", l[l.openBrace = 123] = "openBrace", l[l.openBracket = 91] = "openBracket", l[l.plus = 43] = "plus", l[l.slash = 47] = "slash", l[l.formFeed = 12] = "formFeed", l[l.tab = 9] = "tab", (p || (p = {})).DEFAULT = { allowTrailingComma: !1 };
        var Te, ke, Fe, Oe, _e = we;
        (ke = Te || (Te = {}))[ke.None = 0] = "None", ke[ke.UnexpectedEndOfComment = 1] = "UnexpectedEndOfComment", ke[ke.UnexpectedEndOfString = 2] = "UnexpectedEndOfString", ke[ke.UnexpectedEndOfNumber = 3] = "UnexpectedEndOfNumber", ke[ke.InvalidUnicode = 4] = "InvalidUnicode", ke[ke.InvalidEscapeCharacter = 5] = "InvalidEscapeCharacter", ke[ke.InvalidCharacter = 6] = "InvalidCharacter", (Oe = Fe || (Fe = {}))[Oe.OpenBraceToken = 1] = "OpenBraceToken", Oe[Oe.CloseBraceToken = 2] = "CloseBraceToken", Oe[Oe.OpenBracketToken = 3] = "OpenBracketToken", Oe[Oe.CloseBracketToken = 4] = "CloseBracketToken", Oe[Oe.CommaToken = 5] = "CommaToken", Oe[Oe.ColonToken = 6] = "ColonToken", Oe[Oe.NullKeyword = 7] = "NullKeyword", Oe[Oe.TrueKeyword = 8] = "TrueKeyword", Oe[Oe.FalseKeyword = 9] = "FalseKeyword", Oe[Oe.StringLiteral = 10] = "StringLiteral", Oe[Oe.NumericLiteral = 11] = "NumericLiteral", Oe[Oe.LineCommentTrivia = 12] = "LineCommentTrivia", Oe[Oe.BlockCommentTrivia = 13] = "BlockCommentTrivia", Oe[Oe.LineBreakTrivia = 14] = "LineBreakTrivia", Oe[Oe.Trivia = 15] = "Trivia", Oe[Oe.Unknown = 16] = "Unknown", Oe[Oe.EOF = 17] = "EOF";
        var Ne, Pe, Me, Re = function (e, t = [], n = p.DEFAULT) { let r = null, o = []; const i = []; function s(e) { Array.isArray(o) ? o.push(e) : null !== r && (o[r] = e); } return function (e, t, n = p.DEFAULT) { const r = we(e, !1), o = []; function i(e) { return e ? () => e(r.getTokenOffset(), r.getTokenLength(), r.getTokenStartLine(), r.getTokenStartCharacter()) : () => !0; } function s(e) { return e ? () => e(r.getTokenOffset(), r.getTokenLength(), r.getTokenStartLine(), r.getTokenStartCharacter(), (() => o.slice())) : () => !0; } function a(e) { return e ? t => e(t, r.getTokenOffset(), r.getTokenLength(), r.getTokenStartLine(), r.getTokenStartCharacter()) : () => !0; } function u(e) { return e ? t => e(t, r.getTokenOffset(), r.getTokenLength(), r.getTokenStartLine(), r.getTokenStartCharacter(), (() => o.slice())) : () => !0; } const c = s(t.onObjectBegin), l = u(t.onObjectProperty), f = i(t.onObjectEnd), d = s(t.onArrayBegin), h = i(t.onArrayEnd), m = u(t.onLiteralValue), g = a(t.onSeparator), y = i(t.onComment), v = a(t.onError), b = n && n.disallowComments, D = n && n.allowTrailingComma; function E() { for (;;) {
            const e = r.scan();
            switch (r.getTokenError()) {
                case 4:
                    C(14);
                    break;
                case 5:
                    C(15);
                    break;
                case 3:
                    C(13);
                    break;
                case 1:
                    b || C(11);
                    break;
                case 2:
                    C(12);
                    break;
                case 6: C(16);
            }
            switch (e) {
                case 12:
                case 13:
                    b ? C(10) : y();
                    break;
                case 16:
                    C(1);
                    break;
                case 15:
                case 14: break;
                default: return e;
            }
        } } function C(e, t = [], n = []) { if (v(e), t.length + n.length > 0) {
            let e = r.getToken();
            for (; 17 !== e;) {
                if (-1 !== t.indexOf(e)) {
                    E();
                    break;
                }
                if (-1 !== n.indexOf(e))
                    break;
                e = E();
            }
        } } function w(e) { const t = r.getTokenValue(); return e ? m(t) : (l(t), o.push(t)), E(), !0; } function A() { switch (r.getToken()) {
            case 3: return function () { d(), E(); let e = !0, t = !1; for (; 4 !== r.getToken() && 17 !== r.getToken();) {
                if (5 === r.getToken()) {
                    if (t || C(4, [], []), g(","), E(), 4 === r.getToken() && D)
                        break;
                }
                else
                    t && C(6, [], []);
                e ? (o.push(0), e = !1) : o[o.length - 1]++, A() || C(4, [], [4, 5]), t = !0;
            } return h(), e || o.pop(), 4 !== r.getToken() ? C(8, [4], []) : E(), !0; }();
            case 1: return function () { c(), E(); let e = !1; for (; 2 !== r.getToken() && 17 !== r.getToken();) {
                if (5 === r.getToken()) {
                    if (e || C(4, [], []), g(","), E(), 2 === r.getToken() && D)
                        break;
                }
                else
                    e && C(6, [], []);
                (10 !== r.getToken() ? (C(3, [], [2, 5]), !1) : (w(!1), 6 === r.getToken() ? (g(":"), E(), A() || C(4, [], [2, 5])) : C(5, [], [2, 5]), o.pop(), !0)) || C(4, [], [2, 5]), e = !0;
            } return f(), 2 !== r.getToken() ? C(7, [2], []) : E(), !0; }();
            case 10: return w(!0);
            default: return function () { switch (r.getToken()) {
                case 11:
                    const e = r.getTokenValue();
                    let t = Number(e);
                    isNaN(t) && (C(2), t = 0), m(t);
                    break;
                case 7:
                    m(null);
                    break;
                case 8:
                    m(!0);
                    break;
                case 9:
                    m(!1);
                    break;
                default: return !1;
            } return E(), !0; }();
        } } E(), 17 === r.getToken() ? !!n.allowEmptyContent || C(4, [], []) : A() ? 17 !== r.getToken() && C(9, [], []) : C(4, [], []); }(e, { onObjectBegin: () => { const e = {}; s(e), i.push(o), o = e, r = null; }, onObjectProperty: e => { r = e; }, onObjectEnd: () => { o = i.pop(); }, onArrayBegin: () => { const e = []; s(e), i.push(o), o = e, r = null; }, onArrayEnd: () => { o = i.pop(); }, onLiteralValue: s, onError: (e, n, r) => { t.push({ error: e, offset: n, length: r }); } }, n), o[0]; }, Ie = function e(t, n, r = !1) { if (function (e, t, n = !1) { return t >= e.offset && t < e.offset + e.length || n && t === e.offset + e.length; }(t, n, r)) {
            const o = t.children;
            if (Array.isArray(o))
                for (let t = 0; t < o.length && o[t].offset <= n; t++) {
                    const i = e(o[t], n, r);
                    if (i)
                        return i;
                }
            return t;
        } }, je = function e(t) { if (!t.parent || !t.parent.children)
            return []; const n = e(t.parent); if ("property" === t.parent.type) {
            const e = t.parent.children[0].value;
            n.push(e);
        }
        else if ("array" === t.parent.type) {
            const e = t.parent.children.indexOf(t);
            -1 !== e && n.push(e);
        } return n; }, Be = function e(t) { switch (t.type) {
            case "array": return t.children.map(e);
            case "object":
                const n = Object.create(null);
                for (let r of t.children) {
                    const t = r.children[1];
                    t && (n[r.children[0].value] = e(t));
                }
                return n;
            case "null":
            case "string":
            case "number":
            case "boolean": return t.value;
            default: return;
        } };
        (Pe = Ne || (Ne = {}))[Pe.InvalidSymbol = 1] = "InvalidSymbol", Pe[Pe.InvalidNumberFormat = 2] = "InvalidNumberFormat", Pe[Pe.PropertyNameExpected = 3] = "PropertyNameExpected", Pe[Pe.ValueExpected = 4] = "ValueExpected", Pe[Pe.ColonExpected = 5] = "ColonExpected", Pe[Pe.CommaExpected = 6] = "CommaExpected", Pe[Pe.CloseBraceExpected = 7] = "CloseBraceExpected", Pe[Pe.CloseBracketExpected = 8] = "CloseBracketExpected", Pe[Pe.EndOfFileExpected = 9] = "EndOfFileExpected", Pe[Pe.InvalidCommentToken = 10] = "InvalidCommentToken", Pe[Pe.UnexpectedEndOfComment = 11] = "UnexpectedEndOfComment", Pe[Pe.UnexpectedEndOfString = 12] = "UnexpectedEndOfString", Pe[Pe.UnexpectedEndOfNumber = 13] = "UnexpectedEndOfNumber", Pe[Pe.InvalidUnicode = 14] = "InvalidUnicode", Pe[Pe.InvalidEscapeCharacter = 15] = "InvalidEscapeCharacter", Pe[Pe.InvalidCharacter = 16] = "InvalidCharacter", (() => { var e = { 470: e => { function t(e) { if ("string" != typeof e)
                throw new TypeError("Path must be a string. Received " + JSON.stringify(e)); } function n(e, t) { for (var n, r = "", o = 0, i = -1, s = 0, a = 0; a <= e.length; ++a) {
                if (a < e.length)
                    n = e.charCodeAt(a);
                else {
                    if (47 === n)
                        break;
                    n = 47;
                }
                if (47 === n) {
                    if (i === a - 1 || 1 === s)
                        ;
                    else if (i !== a - 1 && 2 === s) {
                        if (r.length < 2 || 2 !== o || 46 !== r.charCodeAt(r.length - 1) || 46 !== r.charCodeAt(r.length - 2))
                            if (r.length > 2) {
                                var u = r.lastIndexOf("/");
                                if (u !== r.length - 1) {
                                    -1 === u ? (r = "", o = 0) : o = (r = r.slice(0, u)).length - 1 - r.lastIndexOf("/"), i = a, s = 0;
                                    continue;
                                }
                            }
                            else if (2 === r.length || 1 === r.length) {
                                r = "", o = 0, i = a, s = 0;
                                continue;
                            }
                        t && (r.length > 0 ? r += "/.." : r = "..", o = 2);
                    }
                    else
                        r.length > 0 ? r += "/" + e.slice(i + 1, a) : r = e.slice(i + 1, a), o = a - i - 1;
                    i = a, s = 0;
                }
                else
                    46 === n && -1 !== s ? ++s : s = -1;
            } return r; } var r = { resolve: function () { for (var e, r = "", o = !1, i = arguments.length - 1; i >= -1 && !o; i--) {
                    var a;
                    i >= 0 ? a = arguments[i] : (void 0 === e && (e = s.cwd()), a = e), t(a), 0 !== a.length && (r = a + "/" + r, o = 47 === a.charCodeAt(0));
                } return r = n(r, !o), o ? r.length > 0 ? "/" + r : "/" : r.length > 0 ? r : "."; }, normalize: function (e) { if (t(e), 0 === e.length)
                    return "."; var r = 47 === e.charCodeAt(0), o = 47 === e.charCodeAt(e.length - 1); return 0 !== (e = n(e, !r)).length || r || (e = "."), e.length > 0 && o && (e += "/"), r ? "/" + e : e; }, isAbsolute: function (e) { return t(e), e.length > 0 && 47 === e.charCodeAt(0); }, join: function () { if (0 === arguments.length)
                    return "."; for (var e, n = 0; n < arguments.length; ++n) {
                    var o = arguments[n];
                    t(o), o.length > 0 && (void 0 === e ? e = o : e += "/" + o);
                } return void 0 === e ? "." : r.normalize(e); }, relative: function (e, n) { if (t(e), t(n), e === n)
                    return ""; if ((e = r.resolve(e)) === (n = r.resolve(n)))
                    return ""; for (var o = 1; o < e.length && 47 === e.charCodeAt(o); ++o)
                    ; for (var i = e.length, s = i - o, a = 1; a < n.length && 47 === n.charCodeAt(a); ++a)
                    ; for (var u = n.length - a, c = s < u ? s : u, l = -1, p = 0; p <= c; ++p) {
                    if (p === c) {
                        if (u > c) {
                            if (47 === n.charCodeAt(a + p))
                                return n.slice(a + p + 1);
                            if (0 === p)
                                return n.slice(a + p);
                        }
                        else
                            s > c && (47 === e.charCodeAt(o + p) ? l = p : 0 === p && (l = 0));
                        break;
                    }
                    var f = e.charCodeAt(o + p);
                    if (f !== n.charCodeAt(a + p))
                        break;
                    47 === f && (l = p);
                } var d = ""; for (p = o + l + 1; p <= i; ++p)
                    p !== i && 47 !== e.charCodeAt(p) || (0 === d.length ? d += ".." : d += "/.."); return d.length > 0 ? d + n.slice(a + l) : (a += l, 47 === n.charCodeAt(a) && ++a, n.slice(a)); }, _makeLong: function (e) { return e; }, dirname: function (e) { if (t(e), 0 === e.length)
                    return "."; for (var n = e.charCodeAt(0), r = 47 === n, o = -1, i = !0, s = e.length - 1; s >= 1; --s)
                    if (47 === (n = e.charCodeAt(s))) {
                        if (!i) {
                            o = s;
                            break;
                        }
                    }
                    else
                        i = !1; return -1 === o ? r ? "/" : "." : r && 1 === o ? "//" : e.slice(0, o); }, basename: function (e, n) { if (void 0 !== n && "string" != typeof n)
                    throw new TypeError('"ext" argument must be a string'); t(e); var r, o = 0, i = -1, s = !0; if (void 0 !== n && n.length > 0 && n.length <= e.length) {
                    if (n.length === e.length && n === e)
                        return "";
                    var a = n.length - 1, u = -1;
                    for (r = e.length - 1; r >= 0; --r) {
                        var c = e.charCodeAt(r);
                        if (47 === c) {
                            if (!s) {
                                o = r + 1;
                                break;
                            }
                        }
                        else
                            -1 === u && (s = !1, u = r + 1), a >= 0 && (c === n.charCodeAt(a) ? -1 == --a && (i = r) : (a = -1, i = u));
                    }
                    return o === i ? i = u : -1 === i && (i = e.length), e.slice(o, i);
                } for (r = e.length - 1; r >= 0; --r)
                    if (47 === e.charCodeAt(r)) {
                        if (!s) {
                            o = r + 1;
                            break;
                        }
                    }
                    else
                        -1 === i && (s = !1, i = r + 1); return -1 === i ? "" : e.slice(o, i); }, extname: function (e) { t(e); for (var n = -1, r = 0, o = -1, i = !0, s = 0, a = e.length - 1; a >= 0; --a) {
                    var u = e.charCodeAt(a);
                    if (47 !== u)
                        -1 === o && (i = !1, o = a + 1), 46 === u ? -1 === n ? n = a : 1 !== s && (s = 1) : -1 !== n && (s = -1);
                    else if (!i) {
                        r = a + 1;
                        break;
                    }
                } return -1 === n || -1 === o || 0 === s || 1 === s && n === o - 1 && n === r + 1 ? "" : e.slice(n, o); }, format: function (e) { if (null === e || "object" != typeof e)
                    throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof e); return n = (t = e).dir || t.root, r = t.base || (t.name || "") + (t.ext || ""), n ? n === t.root ? n + r : n + "/" + r : r; var t, n, r; }, parse: function (e) { t(e); var n = { root: "", dir: "", base: "", ext: "", name: "" }; if (0 === e.length)
                    return n; var r, o = e.charCodeAt(0), i = 47 === o; i ? (n.root = "/", r = 1) : r = 0; for (var s = -1, a = 0, u = -1, c = !0, l = e.length - 1, p = 0; l >= r; --l)
                    if (47 !== (o = e.charCodeAt(l)))
                        -1 === u && (c = !1, u = l + 1), 46 === o ? -1 === s ? s = l : 1 !== p && (p = 1) : -1 !== s && (p = -1);
                    else if (!c) {
                        a = l + 1;
                        break;
                    } return -1 === s || -1 === u || 0 === p || 1 === p && s === u - 1 && s === a + 1 ? -1 !== u && (n.base = n.name = 0 === a && i ? e.slice(1, u) : e.slice(a, u)) : (0 === a && i ? (n.name = e.slice(1, s), n.base = e.slice(1, u)) : (n.name = e.slice(a, s), n.base = e.slice(a, u)), n.ext = e.slice(s, u)), a > 0 ? n.dir = e.slice(0, a - 1) : i && (n.dir = "/"), n; }, sep: "/", delimiter: ":", win32: null, posix: null }; r.posix = r, e.exports = r; } }, t = {}; function n(r) { var o = t[r]; if (void 0 !== o)
            return o.exports; var i = t[r] = { exports: {} }; return e[r](i, i.exports, n), i.exports; } n.d = (e, t) => { for (var r in t)
            n.o(t, r) && !n.o(e, r) && Object.defineProperty(e, r, { enumerable: !0, get: t[r] }); }, n.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), n.r = e => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }); }; var r = {}; (() => { var e; if (n.r(r), n.d(r, { URI: () => m, Utils: () => x }), "object" == typeof s)
            e = "win32" === s.platform;
        else if ("object" == typeof navigator) {
            var t = navigator.userAgent;
            e = t.indexOf("Windows") >= 0;
        } var o, i, a = (o = function (e, t) { return (o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t; } || function (e, t) { for (var n in t)
            Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]); })(e, t); }, function (e, t) { if ("function" != typeof t && null !== t)
            throw new TypeError("Class extends value " + String(t) + " is not a constructor or null"); function n() { this.constructor = e; } o(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n); }), u = /^\w[\w\d+.-]*$/, c = /^\//, l = /^\/\//; function p(e, t) { if (!e.scheme && t)
            throw new Error('[UriError]: Scheme is missing: {scheme: "", authority: "'.concat(e.authority, '", path: "').concat(e.path, '", query: "').concat(e.query, '", fragment: "').concat(e.fragment, '"}')); if (e.scheme && !u.test(e.scheme))
            throw new Error("[UriError]: Scheme contains illegal characters."); if (e.path)
            if (e.authority) {
                if (!c.test(e.path))
                    throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
            }
            else if (l.test(e.path))
                throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")'); } var f = "", d = "/", h = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/, m = function () { function t(e, t, n, r, o, i) { var s; void 0 === i && (i = !1), "object" == typeof e ? (this.scheme = e.scheme || f, this.authority = e.authority || f, this.path = e.path || f, this.query = e.query || f, this.fragment = e.fragment || f) : (this.scheme = (s = e) || i ? s : "file", this.authority = t || f, this.path = function (e, t) { switch (e) {
            case "https":
            case "http":
            case "file": t ? t[0] !== d && (t = d + t) : t = d;
        } return t; }(this.scheme, n || f), this.query = r || f, this.fragment = o || f, p(this, i)); } return t.isUri = function (e) { return e instanceof t || !!e && "string" == typeof e.authority && "string" == typeof e.fragment && "string" == typeof e.path && "string" == typeof e.query && "string" == typeof e.scheme && "string" == typeof e.fsPath && "function" == typeof e.with && "function" == typeof e.toString; }, Object.defineProperty(t.prototype, "fsPath", { get: function () { return E(this, !1); }, enumerable: !1, configurable: !0 }), t.prototype.with = function (e) { if (!e)
            return this; var t = e.scheme, n = e.authority, r = e.path, o = e.query, i = e.fragment; return void 0 === t ? t = this.scheme : null === t && (t = f), void 0 === n ? n = this.authority : null === n && (n = f), void 0 === r ? r = this.path : null === r && (r = f), void 0 === o ? o = this.query : null === o && (o = f), void 0 === i ? i = this.fragment : null === i && (i = f), t === this.scheme && n === this.authority && r === this.path && o === this.query && i === this.fragment ? this : new y(t, n, r, o, i); }, t.parse = function (e, t) { void 0 === t && (t = !1); var n = h.exec(e); return n ? new y(n[2] || f, S(n[4] || f), S(n[5] || f), S(n[7] || f), S(n[9] || f), t) : new y(f, f, f, f, f); }, t.file = function (t) { var n = f; if (e && (t = t.replace(/\\/g, d)), t[0] === d && t[1] === d) {
            var r = t.indexOf(d, 2);
            -1 === r ? (n = t.substring(2), t = d) : (n = t.substring(2, r), t = t.substring(r) || d);
        } return new y("file", n, t, f, f); }, t.from = function (e) { var t = new y(e.scheme, e.authority, e.path, e.query, e.fragment); return p(t, !0), t; }, t.prototype.toString = function (e) { return void 0 === e && (e = !1), C(this, e); }, t.prototype.toJSON = function () { return this; }, t.revive = function (e) { if (e) {
            if (e instanceof t)
                return e;
            var n = new y(e);
            return n._formatted = e.external, n._fsPath = e._sep === g ? e.fsPath : null, n;
        } return e; }, t; }(), g = e ? 1 : void 0, y = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t._formatted = null, t._fsPath = null, t; } return a(t, e), Object.defineProperty(t.prototype, "fsPath", { get: function () { return this._fsPath || (this._fsPath = E(this, !1)), this._fsPath; }, enumerable: !1, configurable: !0 }), t.prototype.toString = function (e) { return void 0 === e && (e = !1), e ? C(this, !0) : (this._formatted || (this._formatted = C(this, !1)), this._formatted); }, t.prototype.toJSON = function () { var e = { $mid: 1 }; return this._fsPath && (e.fsPath = this._fsPath, e._sep = g), this._formatted && (e.external = this._formatted), this.path && (e.path = this.path), this.scheme && (e.scheme = this.scheme), this.authority && (e.authority = this.authority), this.query && (e.query = this.query), this.fragment && (e.fragment = this.fragment), e; }, t; }(m), v = ((i = {})[58] = "%3A", i[47] = "%2F", i[63] = "%3F", i[35] = "%23", i[91] = "%5B", i[93] = "%5D", i[64] = "%40", i[33] = "%21", i[36] = "%24", i[38] = "%26", i[39] = "%27", i[40] = "%28", i[41] = "%29", i[42] = "%2A", i[43] = "%2B", i[44] = "%2C", i[59] = "%3B", i[61] = "%3D", i[32] = "%20", i); function b(e, t, n) { for (var r = void 0, o = -1, i = 0; i < e.length; i++) {
            var s = e.charCodeAt(i);
            if (s >= 97 && s <= 122 || s >= 65 && s <= 90 || s >= 48 && s <= 57 || 45 === s || 46 === s || 95 === s || 126 === s || t && 47 === s || n && 91 === s || n && 93 === s || n && 58 === s)
                -1 !== o && (r += encodeURIComponent(e.substring(o, i)), o = -1), void 0 !== r && (r += e.charAt(i));
            else {
                void 0 === r && (r = e.substr(0, i));
                var a = v[s];
                void 0 !== a ? (-1 !== o && (r += encodeURIComponent(e.substring(o, i)), o = -1), r += a) : -1 === o && (o = i);
            }
        } return -1 !== o && (r += encodeURIComponent(e.substring(o))), void 0 !== r ? r : e; } function D(e) { for (var t = void 0, n = 0; n < e.length; n++) {
            var r = e.charCodeAt(n);
            35 === r || 63 === r ? (void 0 === t && (t = e.substr(0, n)), t += v[r]) : void 0 !== t && (t += e[n]);
        } return void 0 !== t ? t : e; } function E(t, n) { var r; return r = t.authority && t.path.length > 1 && "file" === t.scheme ? "//".concat(t.authority).concat(t.path) : 47 === t.path.charCodeAt(0) && (t.path.charCodeAt(1) >= 65 && t.path.charCodeAt(1) <= 90 || t.path.charCodeAt(1) >= 97 && t.path.charCodeAt(1) <= 122) && 58 === t.path.charCodeAt(2) ? n ? t.path.substr(1) : t.path[1].toLowerCase() + t.path.substr(2) : t.path, e && (r = r.replace(/\//g, "\\")), r; } function C(e, t) { var n = t ? D : b, r = "", o = e.scheme, i = e.authority, s = e.path, a = e.query, u = e.fragment; if (o && (r += o, r += ":"), (i || "file" === o) && (r += d, r += d), i) {
            var c = i.indexOf("@");
            if (-1 !== c) {
                var l = i.substr(0, c);
                i = i.substr(c + 1), -1 === (c = l.lastIndexOf(":")) ? r += n(l, !1, !1) : (r += n(l.substr(0, c), !1, !1), r += ":", r += n(l.substr(c + 1), !1, !0)), r += "@";
            }
            -1 === (c = (i = i.toLowerCase()).lastIndexOf(":")) ? r += n(i, !1, !0) : (r += n(i.substr(0, c), !1, !0), r += i.substr(c));
        } if (s) {
            if (s.length >= 3 && 47 === s.charCodeAt(0) && 58 === s.charCodeAt(2))
                (p = s.charCodeAt(1)) >= 65 && p <= 90 && (s = "/".concat(String.fromCharCode(p + 32), ":").concat(s.substr(3)));
            else if (s.length >= 2 && 58 === s.charCodeAt(1)) {
                var p;
                (p = s.charCodeAt(0)) >= 65 && p <= 90 && (s = "".concat(String.fromCharCode(p + 32), ":").concat(s.substr(2)));
            }
            r += n(s, !0, !1);
        } return a && (r += "?", r += n(a, !1, !1)), u && (r += "#", r += t ? u : b(u, !1, !1)), r; } function w(e) { try {
            return decodeURIComponent(e);
        }
        catch (t) {
            return e.length > 3 ? e.substr(0, 3) + w(e.substr(3)) : e;
        } } var A = /(%[0-9A-Za-z][0-9A-Za-z])+/g; function S(e) { return e.match(A) ? e.replace(A, (function (e) { return w(e); })) : e; } var x, T, k = n(470), F = function (e, t, n) { if (n || 2 === arguments.length)
            for (var r, o = 0, i = t.length; o < i; o++)
                !r && o in t || (r || (r = Array.prototype.slice.call(t, 0, o)), r[o] = t[o]); return e.concat(r || Array.prototype.slice.call(t)); }, O = k.posix || k, _ = "/"; (T = x || (x = {})).joinPath = function (e) { for (var t = [], n = 1; n < arguments.length; n++)
            t[n - 1] = arguments[n]; return e.with({ path: O.join.apply(O, F([e.path], t, !1)) }); }, T.resolvePath = function (e) { for (var t = [], n = 1; n < arguments.length; n++)
            t[n - 1] = arguments[n]; var r = e.path, o = !1; r[0] !== _ && (r = _ + r, o = !0); var i = O.resolve.apply(O, F([r], t, !1)); return o && i[0] === _ && !e.authority && (i = i.substring(1)), e.with({ path: i }); }, T.dirname = function (e) { if (0 === e.path.length || e.path === _)
            return e; var t = O.dirname(e.path); return 1 === t.length && 46 === t.charCodeAt(0) && (t = ""), e.with({ path: t }); }, T.basename = function (e) { return O.basename(e.path); }, T.extname = function (e) { return O.extname(e.path); }; })(), Me = r; })();
        var Le, qe, $e, Ue, Ve, We, Ke, ze, He, Ye, Je, Ge, Xe, Qe, Ze, et, tt, nt, rt, ot, it, st, at, ut, ct, lt, pt, ft, dt, ht, mt, gt, yt, vt, bt, Dt, Et, Ct, wt, At, St, xt, Tt, kt, Ft, Ot, _t, Nt, Pt, Mt, Rt, { URI: It, Utils: jt } = Me;
        function Bt(e, t) { if (e.length < t.length)
            return !1; for (var n = 0; n < t.length; n++)
            if (e[n] !== t[n])
                return !1; return !0; }
        function Lt(e, t) { var n = e.length - t.length; return n > 0 ? e.lastIndexOf(t) === n : 0 === n && e === t; }
        function qt(e) { return Bt(e, "(?i)") ? new RegExp(e.substring(4), "i") : new RegExp(e); }
        function $t(e, t) { if (e === t)
            return !0; if (null == e || null == t)
            return !1; if (typeof e != typeof t)
            return !1; if ("object" != typeof e)
            return !1; if (Array.isArray(e) !== Array.isArray(t))
            return !1; var n, r; if (Array.isArray(e)) {
            if (e.length !== t.length)
                return !1;
            for (n = 0; n < e.length; n++)
                if (!$t(e[n], t[n]))
                    return !1;
        }
        else {
            var o = [];
            for (r in e)
                o.push(r);
            o.sort();
            var i = [];
            for (r in t)
                i.push(r);
            if (i.sort(), !$t(o, i))
                return !1;
            for (n = 0; n < o.length; n++)
                if (!$t(e[o[n]], t[o[n]]))
                    return !1;
        } return !0; }
        function Ut(e) { return "number" == typeof e; }
        function Vt(e) { return void 0 !== e; }
        function Wt(e) { return "boolean" == typeof e; }
        (Le || (Le = {})).is = function (e) { return "string" == typeof e; }, (qe || (qe = {})).is = function (e) { return "string" == typeof e; }, (Ue = $e || ($e = {})).MIN_VALUE = -2147483648, Ue.MAX_VALUE = 2147483647, Ue.is = function (e) { return "number" == typeof e && Ue.MIN_VALUE <= e && e <= Ue.MAX_VALUE; }, (We = Ve || (Ve = {})).MIN_VALUE = 0, We.MAX_VALUE = 2147483647, We.is = function (e) { return "number" == typeof e && We.MIN_VALUE <= e && e <= We.MAX_VALUE; }, (ze = Ke || (Ke = {})).create = function (e, t) { return e === Number.MAX_VALUE && (e = Ve.MAX_VALUE), t === Number.MAX_VALUE && (t = Ve.MAX_VALUE), { line: e, character: t }; }, ze.is = function (e) { var t = e; return mr.objectLiteral(t) && mr.uinteger(t.line) && mr.uinteger(t.character); }, (Ye = He || (He = {})).create = function (e, t, n, r) { if (mr.uinteger(e) && mr.uinteger(t) && mr.uinteger(n) && mr.uinteger(r))
            return { start: Ke.create(e, t), end: Ke.create(n, r) }; if (Ke.is(e) && Ke.is(t))
            return { start: e, end: t }; throw new Error("Range#create called with invalid arguments[".concat(e, ", ").concat(t, ", ").concat(n, ", ").concat(r, "]")); }, Ye.is = function (e) { var t = e; return mr.objectLiteral(t) && Ke.is(t.start) && Ke.is(t.end); }, (Ge = Je || (Je = {})).create = function (e, t) { return { uri: e, range: t }; }, Ge.is = function (e) { var t = e; return mr.objectLiteral(t) && He.is(t.range) && (mr.string(t.uri) || mr.undefined(t.uri)); }, (Qe = Xe || (Xe = {})).create = function (e, t, n, r) { return { targetUri: e, targetRange: t, targetSelectionRange: n, originSelectionRange: r }; }, Qe.is = function (e) { var t = e; return mr.objectLiteral(t) && He.is(t.targetRange) && mr.string(t.targetUri) && He.is(t.targetSelectionRange) && (He.is(t.originSelectionRange) || mr.undefined(t.originSelectionRange)); }, (et = Ze || (Ze = {})).create = function (e, t, n, r) { return { red: e, green: t, blue: n, alpha: r }; }, et.is = function (e) { var t = e; return mr.objectLiteral(t) && mr.numberRange(t.red, 0, 1) && mr.numberRange(t.green, 0, 1) && mr.numberRange(t.blue, 0, 1) && mr.numberRange(t.alpha, 0, 1); }, (nt = tt || (tt = {})).create = function (e, t) { return { range: e, color: t }; }, nt.is = function (e) { var t = e; return mr.objectLiteral(t) && He.is(t.range) && Ze.is(t.color); }, (ot = rt || (rt = {})).create = function (e, t, n) { return { label: e, textEdit: t, additionalTextEdits: n }; }, ot.is = function (e) { var t = e; return mr.objectLiteral(t) && mr.string(t.label) && (mr.undefined(t.textEdit) || Dt.is(t)) && (mr.undefined(t.additionalTextEdits) || mr.typedArray(t.additionalTextEdits, Dt.is)); }, (st = it || (it = {})).Comment = "comment", st.Imports = "imports", st.Region = "region", (ut = at || (at = {})).create = function (e, t, n, r, o, i) { var s = { startLine: e, endLine: t }; return mr.defined(n) && (s.startCharacter = n), mr.defined(r) && (s.endCharacter = r), mr.defined(o) && (s.kind = o), mr.defined(i) && (s.collapsedText = i), s; }, ut.is = function (e) { var t = e; return mr.objectLiteral(t) && mr.uinteger(t.startLine) && mr.uinteger(t.startLine) && (mr.undefined(t.startCharacter) || mr.uinteger(t.startCharacter)) && (mr.undefined(t.endCharacter) || mr.uinteger(t.endCharacter)) && (mr.undefined(t.kind) || mr.string(t.kind)); }, (lt = ct || (ct = {})).create = function (e, t) { return { location: e, message: t }; }, lt.is = function (e) { var t = e; return mr.defined(t) && Je.is(t.location) && mr.string(t.message); }, (ft = pt || (pt = {})).Error = 1, ft.Warning = 2, ft.Information = 3, ft.Hint = 4, (ht = dt || (dt = {})).Unnecessary = 1, ht.Deprecated = 2, (mt || (mt = {})).is = function (e) { var t = e; return mr.objectLiteral(t) && mr.string(t.href); }, (yt = gt || (gt = {})).create = function (e, t, n, r, o, i) { var s = { range: e, message: t }; return mr.defined(n) && (s.severity = n), mr.defined(r) && (s.code = r), mr.defined(o) && (s.source = o), mr.defined(i) && (s.relatedInformation = i), s; }, yt.is = function (e) { var t, n = e; return mr.defined(n) && He.is(n.range) && mr.string(n.message) && (mr.number(n.severity) || mr.undefined(n.severity)) && (mr.integer(n.code) || mr.string(n.code) || mr.undefined(n.code)) && (mr.undefined(n.codeDescription) || mr.string(null === (t = n.codeDescription) || void 0 === t ? void 0 : t.href)) && (mr.string(n.source) || mr.undefined(n.source)) && (mr.undefined(n.relatedInformation) || mr.typedArray(n.relatedInformation, ct.is)); }, (bt = vt || (vt = {})).create = function (e, t) { for (var n = [], r = 2; r < arguments.length; r++)
            n[r - 2] = arguments[r]; var o = { title: e, command: t }; return mr.defined(n) && n.length > 0 && (o.arguments = n), o; }, bt.is = function (e) { var t = e; return mr.defined(t) && mr.string(t.title) && mr.string(t.command); }, (Et = Dt || (Dt = {})).replace = function (e, t) { return { range: e, newText: t }; }, Et.insert = function (e, t) { return { range: { start: e, end: e }, newText: t }; }, Et.del = function (e) { return { range: e, newText: "" }; }, Et.is = function (e) { var t = e; return mr.objectLiteral(t) && mr.string(t.newText) && He.is(t.range); }, (wt = Ct || (Ct = {})).create = function (e, t, n) { var r = { label: e }; return void 0 !== t && (r.needsConfirmation = t), void 0 !== n && (r.description = n), r; }, wt.is = function (e) { var t = e; return mr.objectLiteral(t) && mr.string(t.label) && (mr.boolean(t.needsConfirmation) || void 0 === t.needsConfirmation) && (mr.string(t.description) || void 0 === t.description); }, (At || (At = {})).is = function (e) { var t = e; return mr.string(t); }, (xt = St || (St = {})).replace = function (e, t, n) { return { range: e, newText: t, annotationId: n }; }, xt.insert = function (e, t, n) { return { range: { start: e, end: e }, newText: t, annotationId: n }; }, xt.del = function (e, t) { return { range: e, newText: "", annotationId: t }; }, xt.is = function (e) { var t = e; return Dt.is(t) && (Ct.is(t.annotationId) || At.is(t.annotationId)); }, (kt = Tt || (Tt = {})).create = function (e, t) { return { textDocument: e, edits: t }; }, kt.is = function (e) { var t = e; return mr.defined(t) && Jt.is(t.textDocument) && Array.isArray(t.edits); }, (Ot = Ft || (Ft = {})).create = function (e, t, n) { var r = { kind: "create", uri: e }; return void 0 === t || void 0 === t.overwrite && void 0 === t.ignoreIfExists || (r.options = t), void 0 !== n && (r.annotationId = n), r; }, Ot.is = function (e) { var t = e; return t && "create" === t.kind && mr.string(t.uri) && (void 0 === t.options || (void 0 === t.options.overwrite || mr.boolean(t.options.overwrite)) && (void 0 === t.options.ignoreIfExists || mr.boolean(t.options.ignoreIfExists))) && (void 0 === t.annotationId || At.is(t.annotationId)); }, (Nt = _t || (_t = {})).create = function (e, t, n, r) { var o = { kind: "rename", oldUri: e, newUri: t }; return void 0 === n || void 0 === n.overwrite && void 0 === n.ignoreIfExists || (o.options = n), void 0 !== r && (o.annotationId = r), o; }, Nt.is = function (e) { var t = e; return t && "rename" === t.kind && mr.string(t.oldUri) && mr.string(t.newUri) && (void 0 === t.options || (void 0 === t.options.overwrite || mr.boolean(t.options.overwrite)) && (void 0 === t.options.ignoreIfExists || mr.boolean(t.options.ignoreIfExists))) && (void 0 === t.annotationId || At.is(t.annotationId)); }, (Mt = Pt || (Pt = {})).create = function (e, t, n) { var r = { kind: "delete", uri: e }; return void 0 === t || void 0 === t.recursive && void 0 === t.ignoreIfNotExists || (r.options = t), void 0 !== n && (r.annotationId = n), r; }, Mt.is = function (e) { var t = e; return t && "delete" === t.kind && mr.string(t.uri) && (void 0 === t.options || (void 0 === t.options.recursive || mr.boolean(t.options.recursive)) && (void 0 === t.options.ignoreIfNotExists || mr.boolean(t.options.ignoreIfNotExists))) && (void 0 === t.annotationId || At.is(t.annotationId)); }, (Rt || (Rt = {})).is = function (e) { var t = e; return t && (void 0 !== t.changes || void 0 !== t.documentChanges) && (void 0 === t.documentChanges || t.documentChanges.every((function (e) { return mr.string(e.kind) ? Ft.is(e) || _t.is(e) || Pt.is(e) : Tt.is(e); }))); };
        var Kt, zt, Ht, Yt, Jt, Gt, Xt, Qt, Zt, en, tn, nn, rn, on, sn, an, un, cn, ln, pn, fn, dn, hn, mn, gn, yn, vn, bn, Dn, En, Cn, wn, An, Sn, xn, Tn, kn, Fn, On, _n, Nn, Pn, Mn, Rn, In, jn, Bn, Ln, qn, $n, Un, Vn, Wn, Kn, zn, Hn, Yn, Jn, Gn, Xn, Qn, Zn, er, tr, nr, rr, or, ir, sr, ar, ur, cr, lr, pr, fr, dr = function () { function e(e, t) { this.edits = e, this.changeAnnotations = t; } return e.prototype.insert = function (e, t, n) { var r, o; if (void 0 === n ? r = Dt.insert(e, t) : At.is(n) ? (o = n, r = St.insert(e, t, n)) : (this.assertChangeAnnotations(this.changeAnnotations), o = this.changeAnnotations.manage(n), r = St.insert(e, t, o)), this.edits.push(r), void 0 !== o)
            return o; }, e.prototype.replace = function (e, t, n) { var r, o; if (void 0 === n ? r = Dt.replace(e, t) : At.is(n) ? (o = n, r = St.replace(e, t, n)) : (this.assertChangeAnnotations(this.changeAnnotations), o = this.changeAnnotations.manage(n), r = St.replace(e, t, o)), this.edits.push(r), void 0 !== o)
            return o; }, e.prototype.delete = function (e, t) { var n, r; if (void 0 === t ? n = Dt.del(e) : At.is(t) ? (r = t, n = St.del(e, t)) : (this.assertChangeAnnotations(this.changeAnnotations), r = this.changeAnnotations.manage(t), n = St.del(e, r)), this.edits.push(n), void 0 !== r)
            return r; }, e.prototype.add = function (e) { this.edits.push(e); }, e.prototype.all = function () { return this.edits; }, e.prototype.clear = function () { this.edits.splice(0, this.edits.length); }, e.prototype.assertChangeAnnotations = function (e) { if (void 0 === e)
            throw new Error("Text edit change is not configured to manage change annotations."); }, e; }(), hr = function () { function e(e) { this._annotations = void 0 === e ? Object.create(null) : e, this._counter = 0, this._size = 0; } return e.prototype.all = function () { return this._annotations; }, Object.defineProperty(e.prototype, "size", { get: function () { return this._size; }, enumerable: !1, configurable: !0 }), e.prototype.manage = function (e, t) { var n; if (At.is(e) ? n = e : (n = this.nextId(), t = e), void 0 !== this._annotations[n])
            throw new Error("Id ".concat(n, " is already in use.")); if (void 0 === t)
            throw new Error("No annotation provided for id ".concat(n)); return this._annotations[n] = t, this._size++, n; }, e.prototype.nextId = function () { return this._counter++, this._counter.toString(); }, e; }();
        !function () { function e(e) { var t = this; this._textEditChanges = Object.create(null), void 0 !== e ? (this._workspaceEdit = e, e.documentChanges ? (this._changeAnnotations = new hr(e.changeAnnotations), e.changeAnnotations = this._changeAnnotations.all(), e.documentChanges.forEach((function (e) { if (Tt.is(e)) {
            var n = new dr(e.edits, t._changeAnnotations);
            t._textEditChanges[e.textDocument.uri] = n;
        } }))) : e.changes && Object.keys(e.changes).forEach((function (n) { var r = new dr(e.changes[n]); t._textEditChanges[n] = r; }))) : this._workspaceEdit = {}; } Object.defineProperty(e.prototype, "edit", { get: function () { return this.initDocumentChanges(), void 0 !== this._changeAnnotations && (0 === this._changeAnnotations.size ? this._workspaceEdit.changeAnnotations = void 0 : this._workspaceEdit.changeAnnotations = this._changeAnnotations.all()), this._workspaceEdit; }, enumerable: !1, configurable: !0 }), e.prototype.getTextEditChange = function (e) { if (Jt.is(e)) {
            if (this.initDocumentChanges(), void 0 === this._workspaceEdit.documentChanges)
                throw new Error("Workspace edit is not configured for document changes.");
            var t = { uri: e.uri, version: e.version };
            if (!(r = this._textEditChanges[t.uri])) {
                var n = { textDocument: t, edits: o = [] };
                this._workspaceEdit.documentChanges.push(n), r = new dr(o, this._changeAnnotations), this._textEditChanges[t.uri] = r;
            }
            return r;
        } if (this.initChanges(), void 0 === this._workspaceEdit.changes)
            throw new Error("Workspace edit is not configured for normal text edit changes."); var r; if (!(r = this._textEditChanges[e])) {
            var o = [];
            this._workspaceEdit.changes[e] = o, r = new dr(o), this._textEditChanges[e] = r;
        } return r; }, e.prototype.initDocumentChanges = function () { void 0 === this._workspaceEdit.documentChanges && void 0 === this._workspaceEdit.changes && (this._changeAnnotations = new hr, this._workspaceEdit.documentChanges = [], this._workspaceEdit.changeAnnotations = this._changeAnnotations.all()); }, e.prototype.initChanges = function () { void 0 === this._workspaceEdit.documentChanges && void 0 === this._workspaceEdit.changes && (this._workspaceEdit.changes = Object.create(null)); }, e.prototype.createFile = function (e, t, n) { if (this.initDocumentChanges(), void 0 === this._workspaceEdit.documentChanges)
            throw new Error("Workspace edit is not configured for document changes."); var r, o, i; if (Ct.is(t) || At.is(t) ? r = t : n = t, void 0 === r ? o = Ft.create(e, n) : (i = At.is(r) ? r : this._changeAnnotations.manage(r), o = Ft.create(e, n, i)), this._workspaceEdit.documentChanges.push(o), void 0 !== i)
            return i; }, e.prototype.renameFile = function (e, t, n, r) { if (this.initDocumentChanges(), void 0 === this._workspaceEdit.documentChanges)
            throw new Error("Workspace edit is not configured for document changes."); var o, i, s; if (Ct.is(n) || At.is(n) ? o = n : r = n, void 0 === o ? i = _t.create(e, t, r) : (s = At.is(o) ? o : this._changeAnnotations.manage(o), i = _t.create(e, t, r, s)), this._workspaceEdit.documentChanges.push(i), void 0 !== s)
            return s; }, e.prototype.deleteFile = function (e, t, n) { if (this.initDocumentChanges(), void 0 === this._workspaceEdit.documentChanges)
            throw new Error("Workspace edit is not configured for document changes."); var r, o, i; if (Ct.is(t) || At.is(t) ? r = t : n = t, void 0 === r ? o = Pt.create(e, n) : (i = At.is(r) ? r : this._changeAnnotations.manage(r), o = Pt.create(e, n, i)), this._workspaceEdit.documentChanges.push(o), void 0 !== i)
            return i; }; }(), (zt = Kt || (Kt = {})).create = function (e) { return { uri: e }; }, zt.is = function (e) { var t = e; return mr.defined(t) && mr.string(t.uri); }, (Yt = Ht || (Ht = {})).create = function (e, t) { return { uri: e, version: t }; }, Yt.is = function (e) { var t = e; return mr.defined(t) && mr.string(t.uri) && mr.integer(t.version); }, (Gt = Jt || (Jt = {})).create = function (e, t) { return { uri: e, version: t }; }, Gt.is = function (e) { var t = e; return mr.defined(t) && mr.string(t.uri) && (null === t.version || mr.integer(t.version)); }, (Qt = Xt || (Xt = {})).create = function (e, t, n, r) { return { uri: e, languageId: t, version: n, text: r }; }, Qt.is = function (e) { var t = e; return mr.defined(t) && mr.string(t.uri) && mr.string(t.languageId) && mr.integer(t.version) && mr.string(t.text); }, (en = Zt || (Zt = {})).PlainText = "plaintext", en.Markdown = "markdown", en.is = function (e) { var t = e; return t === en.PlainText || t === en.Markdown; }, (tn || (tn = {})).is = function (e) { var t = e; return mr.objectLiteral(e) && Zt.is(t.kind) && mr.string(t.value); }, (rn = nn || (nn = {})).Text = 1, rn.Method = 2, rn.Function = 3, rn.Constructor = 4, rn.Field = 5, rn.Variable = 6, rn.Class = 7, rn.Interface = 8, rn.Module = 9, rn.Property = 10, rn.Unit = 11, rn.Value = 12, rn.Enum = 13, rn.Keyword = 14, rn.Snippet = 15, rn.Color = 16, rn.File = 17, rn.Reference = 18, rn.Folder = 19, rn.EnumMember = 20, rn.Constant = 21, rn.Struct = 22, rn.Event = 23, rn.Operator = 24, rn.TypeParameter = 25, (sn = on || (on = {})).PlainText = 1, sn.Snippet = 2, (an || (an = {})).Deprecated = 1, (cn = un || (un = {})).create = function (e, t, n) { return { newText: e, insert: t, replace: n }; }, cn.is = function (e) { var t = e; return t && mr.string(t.newText) && He.is(t.insert) && He.is(t.replace); }, (pn = ln || (ln = {})).asIs = 1, pn.adjustIndentation = 2, (fn || (fn = {})).is = function (e) { var t = e; return t && (mr.string(t.detail) || void 0 === t.detail) && (mr.string(t.description) || void 0 === t.description); }, (dn || (dn = {})).create = function (e) { return { label: e }; }, (hn || (hn = {})).create = function (e, t) { return { items: e || [], isIncomplete: !!t }; }, (gn = mn || (mn = {})).fromPlainText = function (e) { return e.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&"); }, gn.is = function (e) { var t = e; return mr.string(t) || mr.objectLiteral(t) && mr.string(t.language) && mr.string(t.value); }, (yn || (yn = {})).is = function (e) { var t = e; return !!t && mr.objectLiteral(t) && (tn.is(t.contents) || mn.is(t.contents) || mr.typedArray(t.contents, mn.is)) && (void 0 === e.range || He.is(e.range)); }, (vn || (vn = {})).create = function (e, t) { return t ? { label: e, documentation: t } : { label: e }; }, (bn || (bn = {})).create = function (e, t) { for (var n = [], r = 2; r < arguments.length; r++)
            n[r - 2] = arguments[r]; var o = { label: e }; return mr.defined(t) && (o.documentation = t), mr.defined(n) ? o.parameters = n : o.parameters = [], o; }, (En = Dn || (Dn = {})).Text = 1, En.Read = 2, En.Write = 3, (Cn || (Cn = {})).create = function (e, t) { var n = { range: e }; return mr.number(t) && (n.kind = t), n; }, (An = wn || (wn = {})).File = 1, An.Module = 2, An.Namespace = 3, An.Package = 4, An.Class = 5, An.Method = 6, An.Property = 7, An.Field = 8, An.Constructor = 9, An.Enum = 10, An.Interface = 11, An.Function = 12, An.Variable = 13, An.Constant = 14, An.String = 15, An.Number = 16, An.Boolean = 17, An.Array = 18, An.Object = 19, An.Key = 20, An.Null = 21, An.EnumMember = 22, An.Struct = 23, An.Event = 24, An.Operator = 25, An.TypeParameter = 26, (Sn || (Sn = {})).Deprecated = 1, (xn || (xn = {})).create = function (e, t, n, r, o) { var i = { name: e, kind: t, location: { uri: r, range: n } }; return o && (i.containerName = o), i; }, (Tn || (Tn = {})).create = function (e, t, n, r) { return void 0 !== r ? { name: e, kind: t, location: { uri: n, range: r } } : { name: e, kind: t, location: { uri: n } }; }, (Fn = kn || (kn = {})).create = function (e, t, n, r, o, i) { var s = { name: e, detail: t, kind: n, range: r, selectionRange: o }; return void 0 !== i && (s.children = i), s; }, Fn.is = function (e) { var t = e; return t && mr.string(t.name) && mr.number(t.kind) && He.is(t.range) && He.is(t.selectionRange) && (void 0 === t.detail || mr.string(t.detail)) && (void 0 === t.deprecated || mr.boolean(t.deprecated)) && (void 0 === t.children || Array.isArray(t.children)) && (void 0 === t.tags || Array.isArray(t.tags)); }, (_n = On || (On = {})).Empty = "", _n.QuickFix = "quickfix", _n.Refactor = "refactor", _n.RefactorExtract = "refactor.extract", _n.RefactorInline = "refactor.inline", _n.RefactorRewrite = "refactor.rewrite", _n.Source = "source", _n.SourceOrganizeImports = "source.organizeImports", _n.SourceFixAll = "source.fixAll", (Pn = Nn || (Nn = {})).Invoked = 1, Pn.Automatic = 2, (Rn = Mn || (Mn = {})).create = function (e, t, n) { var r = { diagnostics: e }; return null != t && (r.only = t), null != n && (r.triggerKind = n), r; }, Rn.is = function (e) { var t = e; return mr.defined(t) && mr.typedArray(t.diagnostics, gt.is) && (void 0 === t.only || mr.typedArray(t.only, mr.string)) && (void 0 === t.triggerKind || t.triggerKind === Nn.Invoked || t.triggerKind === Nn.Automatic); }, (jn = In || (In = {})).create = function (e, t, n) { var r = { title: e }, o = !0; return "string" == typeof t ? (o = !1, r.kind = t) : vt.is(t) ? r.command = t : r.edit = t, o && void 0 !== n && (r.kind = n), r; }, jn.is = function (e) { var t = e; return t && mr.string(t.title) && (void 0 === t.diagnostics || mr.typedArray(t.diagnostics, gt.is)) && (void 0 === t.kind || mr.string(t.kind)) && (void 0 !== t.edit || void 0 !== t.command) && (void 0 === t.command || vt.is(t.command)) && (void 0 === t.isPreferred || mr.boolean(t.isPreferred)) && (void 0 === t.edit || Rt.is(t.edit)); }, (Ln = Bn || (Bn = {})).create = function (e, t) { var n = { range: e }; return mr.defined(t) && (n.data = t), n; }, Ln.is = function (e) { var t = e; return mr.defined(t) && He.is(t.range) && (mr.undefined(t.command) || vt.is(t.command)); }, ($n = qn || (qn = {})).create = function (e, t) { return { tabSize: e, insertSpaces: t }; }, $n.is = function (e) { var t = e; return mr.defined(t) && mr.uinteger(t.tabSize) && mr.boolean(t.insertSpaces); }, (Vn = Un || (Un = {})).create = function (e, t, n) { return { range: e, target: t, data: n }; }, Vn.is = function (e) { var t = e; return mr.defined(t) && He.is(t.range) && (mr.undefined(t.target) || mr.string(t.target)); }, (Kn = Wn || (Wn = {})).create = function (e, t) { return { range: e, parent: t }; }, Kn.is = function (e) { var t = e; return mr.objectLiteral(t) && He.is(t.range) && (void 0 === t.parent || Kn.is(t.parent)); }, (Hn = zn || (zn = {})).namespace = "namespace", Hn.type = "type", Hn.class = "class", Hn.enum = "enum", Hn.interface = "interface", Hn.struct = "struct", Hn.typeParameter = "typeParameter", Hn.parameter = "parameter", Hn.variable = "variable", Hn.property = "property", Hn.enumMember = "enumMember", Hn.event = "event", Hn.function = "function", Hn.method = "method", Hn.macro = "macro", Hn.keyword = "keyword", Hn.modifier = "modifier", Hn.comment = "comment", Hn.string = "string", Hn.number = "number", Hn.regexp = "regexp", Hn.operator = "operator", Hn.decorator = "decorator", (Jn = Yn || (Yn = {})).declaration = "declaration", Jn.definition = "definition", Jn.readonly = "readonly", Jn.static = "static", Jn.deprecated = "deprecated", Jn.abstract = "abstract", Jn.async = "async", Jn.modification = "modification", Jn.documentation = "documentation", Jn.defaultLibrary = "defaultLibrary", (Gn || (Gn = {})).is = function (e) { var t = e; return mr.objectLiteral(t) && (void 0 === t.resultId || "string" == typeof t.resultId) && Array.isArray(t.data) && (0 === t.data.length || "number" == typeof t.data[0]); }, (Qn = Xn || (Xn = {})).create = function (e, t) { return { range: e, text: t }; }, Qn.is = function (e) { var t = e; return null != t && He.is(t.range) && mr.string(t.text); }, (er = Zn || (Zn = {})).create = function (e, t, n) { return { range: e, variableName: t, caseSensitiveLookup: n }; }, er.is = function (e) { var t = e; return null != t && He.is(t.range) && mr.boolean(t.caseSensitiveLookup) && (mr.string(t.variableName) || void 0 === t.variableName); }, (nr = tr || (tr = {})).create = function (e, t) { return { range: e, expression: t }; }, nr.is = function (e) { var t = e; return null != t && He.is(t.range) && (mr.string(t.expression) || void 0 === t.expression); }, (or = rr || (rr = {})).create = function (e, t) { return { frameId: e, stoppedLocation: t }; }, or.is = function (e) { var t = e; return mr.defined(t) && He.is(e.stoppedLocation); }, (sr = ir || (ir = {})).Type = 1, sr.Parameter = 2, sr.is = function (e) { return 1 === e || 2 === e; }, (ur = ar || (ar = {})).create = function (e) { return { value: e }; }, ur.is = function (e) { var t = e; return mr.objectLiteral(t) && (void 0 === t.tooltip || mr.string(t.tooltip) || tn.is(t.tooltip)) && (void 0 === t.location || Je.is(t.location)) && (void 0 === t.command || vt.is(t.command)); }, (lr = cr || (cr = {})).create = function (e, t, n) { var r = { position: e, label: t }; return void 0 !== n && (r.kind = n), r; }, lr.is = function (e) { var t = e; return mr.objectLiteral(t) && Ke.is(t.position) && (mr.string(t.label) || mr.typedArray(t.label, ar.is)) && (void 0 === t.kind || ir.is(t.kind)) && void 0 === t.textEdits || mr.typedArray(t.textEdits, Dt.is) && (void 0 === t.tooltip || mr.string(t.tooltip) || tn.is(t.tooltip)) && (void 0 === t.paddingLeft || mr.boolean(t.paddingLeft)) && (void 0 === t.paddingRight || mr.boolean(t.paddingRight)); }, (pr || (pr = {})).is = function (e) { var t = e; return mr.objectLiteral(t) && qe.is(t.uri) && mr.string(t.name); }, function (e) { function t(e, n) { if (e.length <= 1)
            return e; var r = e.length / 2 | 0, o = e.slice(0, r), i = e.slice(r); t(o, n), t(i, n); for (var s = 0, a = 0, u = 0; s < o.length && a < i.length;) {
            var c = n(o[s], i[a]);
            e[u++] = c <= 0 ? o[s++] : i[a++];
        } for (; s < o.length;)
            e[u++] = o[s++]; for (; a < i.length;)
            e[u++] = i[a++]; return e; } e.create = function (e, t, n, r) { return new vr(e, t, n, r); }, e.is = function (e) { var t = e; return !!(mr.defined(t) && mr.string(t.uri) && (mr.undefined(t.languageId) || mr.string(t.languageId)) && mr.uinteger(t.lineCount) && mr.func(t.getText) && mr.func(t.positionAt) && mr.func(t.offsetAt)); }, e.applyEdits = function (e, n) { for (var r = e.getText(), o = t(n, (function (e, t) { var n = e.range.start.line - t.range.start.line; return 0 === n ? e.range.start.character - t.range.start.character : n; })), i = r.length, s = o.length - 1; s >= 0; s--) {
            var a = o[s], u = e.offsetAt(a.range.start), c = e.offsetAt(a.range.end);
            if (!(c <= i))
                throw new Error("Overlapping edit");
            r = r.substring(0, u) + a.newText + r.substring(c, r.length), i = u;
        } return r; }; }(fr || (fr = {}));
        var mr, gr, yr, vr = function () { function e(e, t, n, r) { this._uri = e, this._languageId = t, this._version = n, this._content = r, this._lineOffsets = void 0; } return Object.defineProperty(e.prototype, "uri", { get: function () { return this._uri; }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "languageId", { get: function () { return this._languageId; }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "version", { get: function () { return this._version; }, enumerable: !1, configurable: !0 }), e.prototype.getText = function (e) { if (e) {
            var t = this.offsetAt(e.start), n = this.offsetAt(e.end);
            return this._content.substring(t, n);
        } return this._content; }, e.prototype.update = function (e, t) { this._content = e.text, this._version = t, this._lineOffsets = void 0; }, e.prototype.getLineOffsets = function () { if (void 0 === this._lineOffsets) {
            for (var e = [], t = this._content, n = !0, r = 0; r < t.length; r++) {
                n && (e.push(r), n = !1);
                var o = t.charAt(r);
                n = "\r" === o || "\n" === o, "\r" === o && r + 1 < t.length && "\n" === t.charAt(r + 1) && r++;
            }
            n && t.length > 0 && e.push(t.length), this._lineOffsets = e;
        } return this._lineOffsets; }, e.prototype.positionAt = function (e) { e = Math.max(Math.min(e, this._content.length), 0); var t = this.getLineOffsets(), n = 0, r = t.length; if (0 === r)
            return Ke.create(0, e); for (; n < r;) {
            var o = Math.floor((n + r) / 2);
            t[o] > e ? r = o : n = o + 1;
        } var i = n - 1; return Ke.create(i, e - t[i]); }, e.prototype.offsetAt = function (e) { var t = this.getLineOffsets(); if (e.line >= t.length)
            return this._content.length; if (e.line < 0)
            return 0; var n = t[e.line], r = e.line + 1 < t.length ? t[e.line + 1] : this._content.length; return Math.max(Math.min(n + e.character, r), n); }, Object.defineProperty(e.prototype, "lineCount", { get: function () { return this.getLineOffsets().length; }, enumerable: !1, configurable: !0 }), e; }();
        gr = mr || (mr = {}), yr = Object.prototype.toString, gr.defined = function (e) { return void 0 !== e; }, gr.undefined = function (e) { return void 0 === e; }, gr.boolean = function (e) { return !0 === e || !1 === e; }, gr.string = function (e) { return "[object String]" === yr.call(e); }, gr.number = function (e) { return "[object Number]" === yr.call(e); }, gr.numberRange = function (e, t, n) { return "[object Number]" === yr.call(e) && t <= e && e <= n; }, gr.integer = function (e) { return "[object Number]" === yr.call(e) && -2147483648 <= e && e <= 2147483647; }, gr.uinteger = function (e) { return "[object Number]" === yr.call(e) && 0 <= e && e <= 2147483647; }, gr.func = function (e) { return "[object Function]" === yr.call(e); }, gr.objectLiteral = function (e) { return null !== e && "object" == typeof e; }, gr.typedArray = function (e, t) { return Array.isArray(e) && e.every(t); };
        var br, Dr, Er, Cr, wr, Ar = function (e, t, n) { if (n || 2 === arguments.length)
            for (var r, o = 0, i = t.length; o < i; o++)
                !r && o in t || (r || (r = Array.prototype.slice.call(t, 0, o)), r[o] = t[o]); return e.concat(r || Array.prototype.slice.call(t)); }, Sr = function () { function e(e, t, n, r) { this._uri = e, this._languageId = t, this._version = n, this._content = r, this._lineOffsets = void 0; } return Object.defineProperty(e.prototype, "uri", { get: function () { return this._uri; }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "languageId", { get: function () { return this._languageId; }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "version", { get: function () { return this._version; }, enumerable: !1, configurable: !0 }), e.prototype.getText = function (e) { if (e) {
            var t = this.offsetAt(e.start), n = this.offsetAt(e.end);
            return this._content.substring(t, n);
        } return this._content; }, e.prototype.update = function (t, n) { for (var r = 0, o = t; r < o.length; r++) {
            var i = o[r];
            if (e.isIncremental(i)) {
                var s = kr(i.range), a = this.offsetAt(s.start), u = this.offsetAt(s.end);
                this._content = this._content.substring(0, a) + i.text + this._content.substring(u, this._content.length);
                var c = Math.max(s.start.line, 0), l = Math.max(s.end.line, 0), p = this._lineOffsets, f = Tr(i.text, !1, a);
                if (l - c === f.length)
                    for (var d = 0, h = f.length; d < h; d++)
                        p[d + c + 1] = f[d];
                else
                    f.length < 1e4 ? p.splice.apply(p, Ar([c + 1, l - c], f, !1)) : this._lineOffsets = p = p.slice(0, c + 1).concat(f, p.slice(l + 1));
                var m = i.text.length - (u - a);
                if (0 !== m)
                    for (d = c + 1 + f.length, h = p.length; d < h; d++)
                        p[d] = p[d] + m;
            }
            else {
                if (!e.isFull(i))
                    throw new Error("Unknown change event received");
                this._content = i.text, this._lineOffsets = void 0;
            }
        } this._version = n; }, e.prototype.getLineOffsets = function () { return void 0 === this._lineOffsets && (this._lineOffsets = Tr(this._content, !0)), this._lineOffsets; }, e.prototype.positionAt = function (e) { e = Math.max(Math.min(e, this._content.length), 0); var t = this.getLineOffsets(), n = 0, r = t.length; if (0 === r)
            return { line: 0, character: e }; for (; n < r;) {
            var o = Math.floor((n + r) / 2);
            t[o] > e ? r = o : n = o + 1;
        } var i = n - 1; return { line: i, character: e - t[i] }; }, e.prototype.offsetAt = function (e) { var t = this.getLineOffsets(); if (e.line >= t.length)
            return this._content.length; if (e.line < 0)
            return 0; var n = t[e.line], r = e.line + 1 < t.length ? t[e.line + 1] : this._content.length; return Math.max(Math.min(n + e.character, r), n); }, Object.defineProperty(e.prototype, "lineCount", { get: function () { return this.getLineOffsets().length; }, enumerable: !1, configurable: !0 }), e.isIncremental = function (e) { var t = e; return null != t && "string" == typeof t.text && void 0 !== t.range && (void 0 === t.rangeLength || "number" == typeof t.rangeLength); }, e.isFull = function (e) { var t = e; return null != t && "string" == typeof t.text && void 0 === t.range && void 0 === t.rangeLength; }, e; }();
        function xr(e, t) { if (e.length <= 1)
            return e; var n = e.length / 2 | 0, r = e.slice(0, n), o = e.slice(n); xr(r, t), xr(o, t); for (var i = 0, s = 0, a = 0; i < r.length && s < o.length;) {
            var u = t(r[i], o[s]);
            e[a++] = u <= 0 ? r[i++] : o[s++];
        } for (; i < r.length;)
            e[a++] = r[i++]; for (; s < o.length;)
            e[a++] = o[s++]; return e; }
        function Tr(e, t, n) { void 0 === n && (n = 0); for (var r = t ? [n] : [], o = 0; o < e.length; o++) {
            var i = e.charCodeAt(o);
            13 !== i && 10 !== i || (13 === i && o + 1 < e.length && 10 === e.charCodeAt(o + 1) && o++, r.push(n + o + 1));
        } return r; }
        function kr(e) { var t = e.start, n = e.end; return t.line > n.line || t.line === n.line && t.character > n.character ? { start: n, end: t } : e; }
        function Fr(e) { var t = kr(e.range); return t !== e.range ? { newText: e.newText, range: t } : e; }
        function Or(e, t, ...n) { return function (e, t) { return 0 === t.length ? e : e.replace(/{(\d+)}/g, ((e, n) => { const [r] = n; return void 0 === t[r] ? e : t[r]; })); }(t, n); }
        function _r() { return Or; }
        (Dr = br || (br = {})).create = function (e, t, n, r) { return new Sr(e, t, n, r); }, Dr.update = function (e, t, n) { if (e instanceof Sr)
            return e.update(t, n), e; throw new Error("TextDocument.update: document must be created by TextDocument.create"); }, Dr.applyEdits = function (e, t) { for (var n = e.getText(), r = 0, o = [], i = 0, s = xr(t.map(Fr), (function (e, t) { var n = e.range.start.line - t.range.start.line; return 0 === n ? e.range.start.character - t.range.start.character : n; })); i < s.length; i++) {
            var a = s[i], u = e.offsetAt(a.range.start);
            if (u < r)
                throw new Error("Overlapping edit");
            u > r && o.push(n.substring(r, u)), a.newText.length && o.push(a.newText), r = e.offsetAt(a.range.end);
        } return o.push(n.substr(r)), o.join(""); }, (Cr = Er || (Er = {}))[Cr.Undefined = 0] = "Undefined", Cr[Cr.EnumValueMismatch = 1] = "EnumValueMismatch", Cr[Cr.Deprecated = 2] = "Deprecated", Cr[Cr.UnexpectedEndOfComment = 257] = "UnexpectedEndOfComment", Cr[Cr.UnexpectedEndOfString = 258] = "UnexpectedEndOfString", Cr[Cr.UnexpectedEndOfNumber = 259] = "UnexpectedEndOfNumber", Cr[Cr.InvalidUnicode = 260] = "InvalidUnicode", Cr[Cr.InvalidEscapeCharacter = 261] = "InvalidEscapeCharacter", Cr[Cr.InvalidCharacter = 262] = "InvalidCharacter", Cr[Cr.PropertyExpected = 513] = "PropertyExpected", Cr[Cr.CommaExpected = 514] = "CommaExpected", Cr[Cr.ColonExpected = 515] = "ColonExpected", Cr[Cr.ValueExpected = 516] = "ValueExpected", Cr[Cr.CommaOrCloseBacketExpected = 517] = "CommaOrCloseBacketExpected", Cr[Cr.CommaOrCloseBraceExpected = 518] = "CommaOrCloseBraceExpected", Cr[Cr.TrailingComma = 519] = "TrailingComma", Cr[Cr.DuplicateKey = 520] = "DuplicateKey", Cr[Cr.CommentNotPermitted = 521] = "CommentNotPermitted", Cr[Cr.SchemaResolveError = 768] = "SchemaResolveError", (wr || (wr = {})).LATEST = { textDocument: { completion: { completionItem: { documentationFormat: [Zt.Markdown, Zt.PlainText], commitCharactersSupport: !0 } } } };
        var Nr, Pr, Mr, Rr, Ir = (Nr = function (e, t) { return (Nr = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t; } || function (e, t) { for (var n in t)
            Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]); })(e, t); }, function (e, t) { if ("function" != typeof t && null !== t)
            throw new TypeError("Class extends value " + String(t) + " is not a constructor or null"); function n() { this.constructor = e; } Nr(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n); }), jr = _r(), Br = { "color-hex": { errorMessage: jr("colorHexFormatWarning", "Invalid color format. Use #RGB, #RGBA, #RRGGBB or #RRGGBBAA."), pattern: /^#([0-9A-Fa-f]{3,4}|([0-9A-Fa-f]{2}){3,4})$/ }, "date-time": { errorMessage: jr("dateTimeFormatWarning", "String is not a RFC3339 date-time."), pattern: /^(\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)([01][0-9]|2[0-3]):([0-5][0-9]))$/i }, date: { errorMessage: jr("dateFormatWarning", "String is not a RFC3339 date."), pattern: /^(\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/i }, time: { errorMessage: jr("timeFormatWarning", "String is not a RFC3339 time."), pattern: /^([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)([01][0-9]|2[0-3]):([0-5][0-9]))$/i }, email: { errorMessage: jr("emailFormatWarning", "String is not an e-mail address."), pattern: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/ } }, Lr = function () { function e(e, t, n) { void 0 === n && (n = 0), this.offset = t, this.length = n, this.parent = e; } return Object.defineProperty(e.prototype, "children", { get: function () { return []; }, enumerable: !1, configurable: !0 }), e.prototype.toString = function () { return "type: " + this.type + " (" + this.offset + "/" + this.length + ")" + (this.parent ? " parent: {" + this.parent.toString() + "}" : ""); }, e; }();
        function qr(e) { return Wt(e) ? e ? {} : { not: {} } : e; }
        Ir((function (e, t) { var n = Rr.call(this, e, t) || this; return n.type = "null", n.value = null, n; }), Rr = Lr), function (e) { Ir((function (t, n, r) { var o = e.call(this, t, r) || this; return o.type = "boolean", o.value = n, o; }), e); }(Lr), function (e) { function t(t, n) { var r = e.call(this, t, n) || this; return r.type = "array", r.items = [], r; } Ir(t, e), Object.defineProperty(t.prototype, "children", { get: function () { return this.items; }, enumerable: !1, configurable: !0 }); }(Lr), function (e) { Ir((function (t, n) { var r = e.call(this, t, n) || this; return r.type = "number", r.isInteger = !0, r.value = Number.NaN, r; }), e); }(Lr), function (e) { Ir((function (t, n, r) { var o = e.call(this, t, n, r) || this; return o.type = "string", o.value = "", o; }), e); }(Lr), function (e) { function t(t, n, r) { var o = e.call(this, t, n) || this; return o.type = "property", o.colonOffset = -1, o.keyNode = r, o; } Ir(t, e), Object.defineProperty(t.prototype, "children", { get: function () { return this.valueNode ? [this.keyNode, this.valueNode] : [this.keyNode]; }, enumerable: !1, configurable: !0 }); }(Lr), function (e) { function t(t, n) { var r = e.call(this, t, n) || this; return r.type = "object", r.properties = [], r; } Ir(t, e), Object.defineProperty(t.prototype, "children", { get: function () { return this.properties; }, enumerable: !1, configurable: !0 }); }(Lr), (Mr = Pr || (Pr = {}))[Mr.Key = 0] = "Key", Mr[Mr.Enum = 1] = "Enum";
        var $r = function () { function e(e, t) { void 0 === e && (e = -1), this.focusOffset = e, this.exclude = t, this.schemas = []; } return e.prototype.add = function (e) { this.schemas.push(e); }, e.prototype.merge = function (e) { Array.prototype.push.apply(this.schemas, e.schemas); }, e.prototype.include = function (e) { return (-1 === this.focusOffset || zr(e, this.focusOffset)) && e !== this.exclude; }, e.prototype.newSub = function () { return new e(-1, this.exclude); }, e; }(), Ur = function () { function e() { } return Object.defineProperty(e.prototype, "schemas", { get: function () { return []; }, enumerable: !1, configurable: !0 }), e.prototype.add = function (e) { }, e.prototype.merge = function (e) { }, e.prototype.include = function (e) { return !0; }, e.prototype.newSub = function () { return this; }, e.instance = new e, e; }(), Vr = function () { function e() { this.problems = [], this.propertiesMatches = 0, this.propertiesValueMatches = 0, this.primaryValueMatches = 0, this.enumValueMatch = !1, this.enumValues = void 0; } return e.prototype.hasProblems = function () { return !!this.problems.length; }, e.prototype.mergeAll = function (e) { for (var t = 0, n = e; t < n.length; t++) {
            var r = n[t];
            this.merge(r);
        } }, e.prototype.merge = function (e) { this.problems = this.problems.concat(e.problems); }, e.prototype.mergeEnumValues = function (e) { if (!this.enumValueMatch && !e.enumValueMatch && this.enumValues && e.enumValues) {
            this.enumValues = this.enumValues.concat(e.enumValues);
            for (var t = 0, n = this.problems; t < n.length; t++) {
                var r = n[t];
                r.code === Er.EnumValueMismatch && (r.message = jr("enumWarning", "Value is not accepted. Valid values: {0}.", this.enumValues.map((function (e) { return JSON.stringify(e); })).join(", ")));
            }
        } }, e.prototype.mergePropertyMatch = function (e) { this.merge(e), this.propertiesMatches++, (e.enumValueMatch || !e.hasProblems() && e.propertiesMatches) && this.propertiesValueMatches++, e.enumValueMatch && e.enumValues && 1 === e.enumValues.length && this.primaryValueMatches++; }, e.prototype.compare = function (e) { var t = this.hasProblems(); return t !== e.hasProblems() ? t ? -1 : 1 : this.enumValueMatch !== e.enumValueMatch ? e.enumValueMatch ? -1 : 1 : this.primaryValueMatches !== e.primaryValueMatches ? this.primaryValueMatches - e.primaryValueMatches : this.propertiesValueMatches !== e.propertiesValueMatches ? this.propertiesValueMatches - e.propertiesValueMatches : this.propertiesMatches - e.propertiesMatches; }, e; }();
        function Wr(e) { return Be(e); }
        function Kr(e) { return je(e); }
        function zr(e, t, n) { return void 0 === n && (n = !1), t >= e.offset && t < e.offset + e.length || n && t === e.offset + e.length; }
        function Hr(e, t, n, r) { if (e && r.include(e)) {
            var o = e;
            switch (o.type) {
                case "object":
                    !function (e, t, n, r) { for (var o = Object.create(null), i = [], s = 0, a = e.properties; s < a.length; s++)
                        o[L = (g = a[s]).keyNode.value] = g.valueNode, i.push(L); if (Array.isArray(t.required))
                        for (var u = 0, c = t.required; u < c.length; u++)
                            if (!o[w = c[u]]) {
                                var l = e.parent && "property" === e.parent.type && e.parent.keyNode, p = l ? { offset: l.offset, length: l.length } : { offset: e.offset, length: 1 };
                                n.problems.push({ location: p, message: jr("MissingRequiredPropWarning", 'Missing property "{0}".', w) });
                            } var f = function (e) { for (var t = i.indexOf(e); t >= 0;)
                        i.splice(t, 1), t = i.indexOf(e); }; if (t.properties)
                        for (var d = 0, h = Object.keys(t.properties); d < h.length; d++) {
                            f(w = h[d]);
                            var m = t.properties[w];
                            if (F = o[w])
                                if (Wt(m))
                                    if (m)
                                        n.propertiesMatches++, n.propertiesValueMatches++;
                                    else {
                                        var g = F.parent;
                                        n.problems.push({ location: { offset: g.keyNode.offset, length: g.keyNode.length }, message: t.errorMessage || jr("DisallowedExtraPropWarning", "Property {0} is not allowed.", w) });
                                    }
                                else
                                    Hr(F, m, x = new Vr, r), n.mergePropertyMatch(x);
                        } if (t.patternProperties)
                        for (var y = 0, v = Object.keys(t.patternProperties); y < v.length; y++)
                            for (var b = v[y], D = qt(b), E = 0, C = i.slice(0); E < C.length; E++) {
                                var w = C[E];
                                D.test(w) && (f(w), (F = o[w]) && (Wt(m = t.patternProperties[b]) ? m ? (n.propertiesMatches++, n.propertiesValueMatches++) : (g = F.parent, n.problems.push({ location: { offset: g.keyNode.offset, length: g.keyNode.length }, message: t.errorMessage || jr("DisallowedExtraPropWarning", "Property {0} is not allowed.", w) })) : (Hr(F, m, x = new Vr, r), n.mergePropertyMatch(x))));
                            } if ("object" == typeof t.additionalProperties) {
                        for (var A = 0, S = i; A < S.length; A++)
                            if (F = o[w = S[A]]) {
                                var x = new Vr;
                                Hr(F, t.additionalProperties, x, r), n.mergePropertyMatch(x);
                            }
                    }
                    else if (!1 === t.additionalProperties && i.length > 0)
                        for (var T = 0, k = i; T < k.length; T++) {
                            var F;
                            (F = o[w = k[T]]) && (g = F.parent, n.problems.push({ location: { offset: g.keyNode.offset, length: g.keyNode.length }, message: t.errorMessage || jr("DisallowedExtraPropWarning", "Property {0} is not allowed.", w) }));
                        } if (Ut(t.maxProperties) && e.properties.length > t.maxProperties && n.problems.push({ location: { offset: e.offset, length: e.length }, message: jr("MaxPropWarning", "Object has more properties than limit of {0}.", t.maxProperties) }), Ut(t.minProperties) && e.properties.length < t.minProperties && n.problems.push({ location: { offset: e.offset, length: e.length }, message: jr("MinPropWarning", "Object has fewer properties than the required number of {0}", t.minProperties) }), t.dependencies)
                        for (var O = 0, _ = Object.keys(t.dependencies); O < _.length; O++)
                            if (o[L = _[O]]) {
                                var N = t.dependencies[L];
                                if (Array.isArray(N))
                                    for (var P = 0, M = N; P < M.length; P++) {
                                        var R = M[P];
                                        o[R] ? n.propertiesValueMatches++ : n.problems.push({ location: { offset: e.offset, length: e.length }, message: jr("RequiredDependentPropWarning", "Object is missing property {0} required by property {1}.", R, L) });
                                    }
                                else
                                    (m = qr(N)) && (Hr(e, m, x = new Vr, r), n.mergePropertyMatch(x));
                            } var I = qr(t.propertyNames); if (I)
                        for (var j = 0, B = e.properties; j < B.length; j++) {
                            var L;
                            (L = B[j].keyNode) && Hr(L, I, n, Ur.instance);
                        } }(o, t, n, r);
                    break;
                case "array":
                    !function (e, t, n, r) { if (Array.isArray(t.items)) {
                        for (var o = t.items, i = 0; i < o.length; i++) {
                            var s = qr(o[i]), a = new Vr;
                            (f = e.items[i]) ? (Hr(f, s, a, r), n.mergePropertyMatch(a)) : e.items.length >= o.length && n.propertiesValueMatches++;
                        }
                        if (e.items.length > o.length)
                            if ("object" == typeof t.additionalItems)
                                for (var u = o.length; u < e.items.length; u++)
                                    a = new Vr, Hr(e.items[u], t.additionalItems, a, r), n.mergePropertyMatch(a);
                            else
                                !1 === t.additionalItems && n.problems.push({ location: { offset: e.offset, length: e.length }, message: jr("additionalItemsWarning", "Array has too many items according to schema. Expected {0} or fewer.", o.length) });
                    }
                    else {
                        var c = qr(t.items);
                        if (c)
                            for (var l = 0, p = e.items; l < p.length; l++) {
                                var f;
                                Hr(f = p[l], c, a = new Vr, r), n.mergePropertyMatch(a);
                            }
                    } var d = qr(t.contains); if (d && (e.items.some((function (e) { var t = new Vr; return Hr(e, d, t, Ur.instance), !t.hasProblems(); })) || n.problems.push({ location: { offset: e.offset, length: e.length }, message: t.errorMessage || jr("requiredItemMissingWarning", "Array does not contain required item.") })), Ut(t.minItems) && e.items.length < t.minItems && n.problems.push({ location: { offset: e.offset, length: e.length }, message: jr("minItemsWarning", "Array has too few items. Expected {0} or more.", t.minItems) }), Ut(t.maxItems) && e.items.length > t.maxItems && n.problems.push({ location: { offset: e.offset, length: e.length }, message: jr("maxItemsWarning", "Array has too many items. Expected {0} or fewer.", t.maxItems) }), !0 === t.uniqueItems) {
                        var h = Wr(e);
                        h.some((function (e, t) { return t !== h.lastIndexOf(e); })) && n.problems.push({ location: { offset: e.offset, length: e.length }, message: jr("uniqueItemsWarning", "Array has duplicate items.") });
                    } }(o, t, n, r);
                    break;
                case "string":
                    !function (e, t, n, r) { if (Ut(t.minLength) && e.value.length < t.minLength && n.problems.push({ location: { offset: e.offset, length: e.length }, message: jr("minLengthWarning", "String is shorter than the minimum length of {0}.", t.minLength) }), Ut(t.maxLength) && e.value.length > t.maxLength && n.problems.push({ location: { offset: e.offset, length: e.length }, message: jr("maxLengthWarning", "String is longer than the maximum length of {0}.", t.maxLength) }), "string" == typeof t.pattern && (qt(t.pattern).test(e.value) || n.problems.push({ location: { offset: e.offset, length: e.length }, message: t.patternErrorMessage || t.errorMessage || jr("patternWarning", 'String does not match the pattern of "{0}".', t.pattern) })), t.format)
                        switch (t.format) {
                            case "uri":
                            case "uri-reference":
                                var o = void 0;
                                if (e.value) {
                                    var i = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/.exec(e.value);
                                    i ? i[2] || "uri" !== t.format || (o = jr("uriSchemeMissing", "URI with a scheme is expected.")) : o = jr("uriMissing", "URI is expected.");
                                }
                                else
                                    o = jr("uriEmpty", "URI expected.");
                                o && n.problems.push({ location: { offset: e.offset, length: e.length }, message: t.patternErrorMessage || t.errorMessage || jr("uriFormatWarning", "String is not a URI: {0}", o) });
                                break;
                            case "color-hex":
                            case "date-time":
                            case "date":
                            case "time":
                            case "email":
                                var s = Br[t.format];
                                e.value && s.pattern.exec(e.value) || n.problems.push({ location: { offset: e.offset, length: e.length }, message: t.patternErrorMessage || t.errorMessage || s.errorMessage });
                        } }(o, t, n);
                    break;
                case "number":
                    !function (e, t, n, r) { var o = e.value; function i(e) { var t, n = /^(-?\d+)(?:\.(\d+))?(?:e([-+]\d+))?$/.exec(e.toString()); return n && { value: Number(n[1] + (n[2] || "")), multiplier: ((null === (t = n[2]) || void 0 === t ? void 0 : t.length) || 0) - (parseInt(n[3]) || 0) }; } if (Ut(t.multipleOf)) {
                        var s = -1;
                        if (Number.isInteger(t.multipleOf))
                            s = o % t.multipleOf;
                        else {
                            var a = i(t.multipleOf), u = i(o);
                            if (a && u) {
                                var c = Math.pow(10, Math.abs(u.multiplier - a.multiplier));
                                u.multiplier < a.multiplier ? u.value *= c : a.value *= c, s = u.value % a.value;
                            }
                        }
                        0 !== s && n.problems.push({ location: { offset: e.offset, length: e.length }, message: jr("multipleOfWarning", "Value is not divisible by {0}.", t.multipleOf) });
                    } function l(e, t) { return Ut(t) ? t : Wt(t) && t ? e : void 0; } function p(e, t) { if (!Wt(t) || !t)
                        return e; } var f = l(t.minimum, t.exclusiveMinimum); Ut(f) && o <= f && n.problems.push({ location: { offset: e.offset, length: e.length }, message: jr("exclusiveMinimumWarning", "Value is below the exclusive minimum of {0}.", f) }); var d = l(t.maximum, t.exclusiveMaximum); Ut(d) && o >= d && n.problems.push({ location: { offset: e.offset, length: e.length }, message: jr("exclusiveMaximumWarning", "Value is above the exclusive maximum of {0}.", d) }); var h = p(t.minimum, t.exclusiveMinimum); Ut(h) && o < h && n.problems.push({ location: { offset: e.offset, length: e.length }, message: jr("minimumWarning", "Value is below the minimum of {0}.", h) }); var m = p(t.maximum, t.exclusiveMaximum); Ut(m) && o > m && n.problems.push({ location: { offset: e.offset, length: e.length }, message: jr("maximumWarning", "Value is above the maximum of {0}.", m) }); }(o, t, n);
                    break;
                case "property": return Hr(o.valueNode, t, n, r);
            }
            !function () { function e(e) { return o.type === e || "integer" === e && "number" === o.type && o.isInteger; } if (Array.isArray(t.type) ? t.type.some(e) || n.problems.push({ location: { offset: o.offset, length: o.length }, message: t.errorMessage || jr("typeArrayMismatchWarning", "Incorrect type. Expected one of {0}.", t.type.join(", ")) }) : t.type && (e(t.type) || n.problems.push({ location: { offset: o.offset, length: o.length }, message: t.errorMessage || jr("typeMismatchWarning", 'Incorrect type. Expected "{0}".', t.type) })), Array.isArray(t.allOf))
                for (var i = 0, s = t.allOf; i < s.length; i++) {
                    var a = s[i];
                    Hr(o, qr(a), n, r);
                } var u = qr(t.not); if (u) {
                var c = new Vr, l = r.newSub();
                Hr(o, u, c, l), c.hasProblems() || n.problems.push({ location: { offset: o.offset, length: o.length }, message: jr("notSchemaWarning", "Matches a schema that is not allowed.") });
                for (var p = 0, f = l.schemas; p < f.length; p++) {
                    var d = f[p];
                    d.inverted = !d.inverted, r.add(d);
                }
            } var h = function (e, t) { for (var i = [], s = void 0, a = 0, u = e; a < u.length; a++) {
                var c = qr(u[a]), l = new Vr, p = r.newSub();
                if (Hr(o, c, l, p), l.hasProblems() || i.push(c), s)
                    if (t || l.hasProblems() || s.validationResult.hasProblems()) {
                        var f = l.compare(s.validationResult);
                        f > 0 ? s = { schema: c, validationResult: l, matchingSchemas: p } : 0 === f && (s.matchingSchemas.merge(p), s.validationResult.mergeEnumValues(l));
                    }
                    else
                        s.matchingSchemas.merge(p), s.validationResult.propertiesMatches += l.propertiesMatches, s.validationResult.propertiesValueMatches += l.propertiesValueMatches;
                else
                    s = { schema: c, validationResult: l, matchingSchemas: p };
            } return i.length > 1 && t && n.problems.push({ location: { offset: o.offset, length: 1 }, message: jr("oneOfWarning", "Matches multiple schemas when only one must validate.") }), s && (n.merge(s.validationResult), n.propertiesMatches += s.validationResult.propertiesMatches, n.propertiesValueMatches += s.validationResult.propertiesValueMatches, r.merge(s.matchingSchemas)), i.length; }; Array.isArray(t.anyOf) && h(t.anyOf, !1), Array.isArray(t.oneOf) && h(t.oneOf, !0); var m, g, y, v, b, D, E = function (e) { var t = new Vr, i = r.newSub(); Hr(o, qr(e), t, i), n.merge(t), n.propertiesMatches += t.propertiesMatches, n.propertiesValueMatches += t.propertiesValueMatches, r.merge(i); }, C = qr(t.if); if (C && (m = C, g = qr(t.then), y = qr(t.else), v = qr(m), b = new Vr, D = r.newSub(), Hr(o, v, b, D), r.merge(D), b.hasProblems() ? y && E(y) : g && E(g)), Array.isArray(t.enum)) {
                for (var w = Wr(o), A = !1, S = 0, x = t.enum; S < x.length; S++) {
                    if ($t(w, x[S])) {
                        A = !0;
                        break;
                    }
                }
                n.enumValues = t.enum, n.enumValueMatch = A, A || n.problems.push({ location: { offset: o.offset, length: o.length }, code: Er.EnumValueMismatch, message: t.errorMessage || jr("enumWarning", "Value is not accepted. Valid values: {0}.", t.enum.map((function (e) { return JSON.stringify(e); })).join(", ")) });
            } Vt(t.const) && ($t(w = Wr(o), t.const) ? n.enumValueMatch = !0 : (n.problems.push({ location: { offset: o.offset, length: o.length }, code: Er.EnumValueMismatch, message: t.errorMessage || jr("constWarning", "Value must be {0}.", JSON.stringify(t.const)) }), n.enumValueMatch = !1), n.enumValues = [t.const]), t.deprecationMessage && o.parent && n.problems.push({ location: { offset: o.parent.offset, length: o.parent.length }, severity: pt.Warning, message: t.deprecationMessage, code: Er.Deprecated }); }(), r.add({ node: o, schema: t });
        } }
        function Yr(e, t) { if ("string" != typeof e)
            throw new TypeError("Expected a string"); for (var n, r = String(e), o = "", i = !!t && !!t.extended, s = !!t && !!t.globstar, a = !1, u = t && "string" == typeof t.flags ? t.flags : "", c = 0, l = r.length; c < l; c++)
            switch (n = r[c]) {
                case "/":
                case "$":
                case "^":
                case "+":
                case ".":
                case "(":
                case ")":
                case "=":
                case "!":
                case "|":
                    o += "\\" + n;
                    break;
                case "?": if (i) {
                    o += ".";
                    break;
                }
                case "[":
                case "]": if (i) {
                    o += n;
                    break;
                }
                case "{": if (i) {
                    a = !0, o += "(";
                    break;
                }
                case "}": if (i) {
                    a = !1, o += ")";
                    break;
                }
                case ",":
                    if (a) {
                        o += "|";
                        break;
                    }
                    o += "\\" + n;
                    break;
                case "*":
                    for (var p = r[c - 1], f = 1; "*" === r[c + 1];)
                        f++, c++;
                    var d = r[c + 1];
                    s ? !(f > 1) || "/" !== p && void 0 !== p && "{" !== p && "," !== p || "/" !== d && void 0 !== d && "," !== d && "}" !== d ? o += "([^/]*)" : ("/" === d ? c++ : "/" === p && o.endsWith("\\/") && (o = o.substr(0, o.length - 2)), o += "((?:[^/]*(?:/|$))*)") : o += ".*";
                    break;
                default: o += n;
            } return u && ~u.indexOf("g") || (o = "^" + o + "$"), new RegExp(o, u); }
        !function () { function e(e, t, n) { void 0 === t && (t = []), void 0 === n && (n = []), this.root = e, this.syntaxErrors = t, this.comments = n; } e.prototype.getNodeFromOffset = function (e, t) { if (void 0 === t && (t = !1), this.root)
            return Ie(this.root, e, t); }, e.prototype.visit = function (e) { if (this.root) {
            var t = function (n) { var r = e(n), o = n.children; if (Array.isArray(o))
                for (var i = 0; i < o.length && r; i++)
                    r = t(o[i]); return r; };
            t(this.root);
        } }, e.prototype.validate = function (e, t, n) { if (void 0 === n && (n = pt.Warning), this.root && t) {
            var r = new Vr;
            return Hr(this.root, t, r, Ur.instance), r.problems.map((function (t) { var r, o = He.create(e.positionAt(t.location.offset), e.positionAt(t.location.offset + t.location.length)); return gt.create(o, t.message, null !== (r = t.severity) && void 0 !== r ? r : n, t.code); }));
        } }, e.prototype.getMatchingSchemas = function (e, t, n) { void 0 === t && (t = -1); var r = new $r(t, n); return this.root && e && Hr(this.root, e, new Vr, r), r.schemas; }; }();
        var Jr = _r(), Gr = function () { function e(e, t) { this.globWrappers = []; try {
            for (var n = 0, r = e; n < r.length; n++) {
                var o = r[n], i = "!" !== o[0];
                i || (o = o.substring(1)), o.length > 0 && ("/" === o[0] && (o = o.substring(1)), this.globWrappers.push({ regexp: Yr("**/" + o, { extended: !0, globstar: !0 }), include: i }));
            }
            this.uris = t;
        }
        catch (e) {
            this.globWrappers.length = 0, this.uris = [];
        } } return e.prototype.matchesPattern = function (e) { for (var t = !1, n = 0, r = this.globWrappers; n < r.length; n++) {
            var o = r[n], i = o.regexp, s = o.include;
            i.test(e) && (t = s);
        } return t; }, e.prototype.getURIs = function () { return this.uris; }, e; }(), Xr = function () { function e(e, t, n) { this.service = e, this.url = t, this.dependencies = {}, n && (this.unresolvedSchema = this.service.promise.resolve(new Qr(n))); } return e.prototype.getUnresolvedSchema = function () { return this.unresolvedSchema || (this.unresolvedSchema = this.service.loadSchema(this.url)), this.unresolvedSchema; }, e.prototype.getResolvedSchema = function () { var e = this; return this.resolvedSchema || (this.resolvedSchema = this.getUnresolvedSchema().then((function (t) { return e.service.resolveSchemaContent(t, e.url, e.dependencies); }))), this.resolvedSchema; }, e.prototype.clearSchema = function () { this.resolvedSchema = void 0, this.unresolvedSchema = void 0, this.dependencies = {}; }, e; }(), Qr = function (e, t) { void 0 === t && (t = []), this.schema = e, this.errors = t; }, Zr = function () { function e(e, t) { void 0 === t && (t = []), this.schema = e, this.errors = t; } return e.prototype.getSection = function (e) { var t = this.getSectionRecursive(e, this.schema); if (t)
            return qr(t); }, e.prototype.getSectionRecursive = function (e, t) { if (!t || "boolean" == typeof t || 0 === e.length)
            return t; var n = e.shift(); if (t.properties && (t.properties[n], 1))
            return this.getSectionRecursive(e, t.properties[n]); if (t.patternProperties)
            for (var r = 0, o = Object.keys(t.patternProperties); r < o.length; r++) {
                var i = o[r];
                if (qt(i).test(n))
                    return this.getSectionRecursive(e, t.patternProperties[i]);
            }
        else {
            if ("object" == typeof t.additionalProperties)
                return this.getSectionRecursive(e, t.additionalProperties);
            if (n.match("[0-9]+"))
                if (Array.isArray(t.items)) {
                    var s = parseInt(n, 10);
                    if (!isNaN(s) && t.items[s])
                        return this.getSectionRecursive(e, t.items[s]);
                }
                else if (t.items)
                    return this.getSectionRecursive(e, t.items);
        } }, e; }(), eo = function () { function e(e, t, n) { this.contextService = t, this.requestService = e, this.promiseConstructor = n || Promise, this.callOnDispose = [], this.contributionSchemas = {}, this.contributionAssociations = [], this.schemasById = {}, this.filePatternAssociations = [], this.registeredSchemasIds = {}; } return e.prototype.getRegisteredSchemaIds = function (e) { return Object.keys(this.registeredSchemasIds).filter((function (t) { var n = It.parse(t).scheme; return "schemaservice" !== n && (!e || e(n)); })); }, Object.defineProperty(e.prototype, "promise", { get: function () { return this.promiseConstructor; }, enumerable: !1, configurable: !0 }), e.prototype.dispose = function () { for (; this.callOnDispose.length > 0;)
            this.callOnDispose.pop()(); }, e.prototype.onResourceChange = function (e) { var t = this; this.cachedSchemaForResource = void 0; for (var n = !1, r = [e = no(e)], o = Object.keys(this.schemasById).map((function (e) { return t.schemasById[e]; })); r.length;)
            for (var i = r.pop(), s = 0; s < o.length; s++) {
                var a = o[s];
                a && (a.url === i || a.dependencies[i]) && (a.url !== i && r.push(a.url), a.clearSchema(), o[s] = void 0, n = !0);
            } return n; }, e.prototype.setSchemaContributions = function (e) { if (e.schemas) {
            var t = e.schemas;
            for (var n in t) {
                var r = no(n);
                this.contributionSchemas[r] = this.addSchemaHandle(r, t[n]);
            }
        } if (Array.isArray(e.schemaAssociations))
            for (var o = 0, i = e.schemaAssociations; o < i.length; o++) {
                var s = i[o], a = s.uris.map(no), u = this.addFilePatternAssociation(s.pattern, a);
                this.contributionAssociations.push(u);
            } }, e.prototype.addSchemaHandle = function (e, t) { var n = new Xr(this, e, t); return this.schemasById[e] = n, n; }, e.prototype.getOrAddSchemaHandle = function (e, t) { return this.schemasById[e] || this.addSchemaHandle(e, t); }, e.prototype.addFilePatternAssociation = function (e, t) { var n = new Gr(e, t); return this.filePatternAssociations.push(n), n; }, e.prototype.registerExternalSchema = function (e, t, n) { var r = no(e); return this.registeredSchemasIds[r] = !0, this.cachedSchemaForResource = void 0, t && this.addFilePatternAssociation(t, [e]), n ? this.addSchemaHandle(r, n) : this.getOrAddSchemaHandle(r); }, e.prototype.clearExternalSchemas = function () { for (var e in this.schemasById = {}, this.filePatternAssociations = [], this.registeredSchemasIds = {}, this.cachedSchemaForResource = void 0, this.contributionSchemas)
            this.schemasById[e] = this.contributionSchemas[e], this.registeredSchemasIds[e] = !0; for (var t = 0, n = this.contributionAssociations; t < n.length; t++) {
            var r = n[t];
            this.filePatternAssociations.push(r);
        } }, e.prototype.getResolvedSchema = function (e) { var t = no(e), n = this.schemasById[t]; return n ? n.getResolvedSchema() : this.promise.resolve(void 0); }, e.prototype.loadSchema = function (e) { if (!this.requestService) {
            var t = Jr("json.schema.norequestservice", "Unable to load schema from '{0}'. No schema request service available", ro(e));
            return this.promise.resolve(new Qr({}, [t]));
        } return this.requestService(e).then((function (t) { if (!t) {
            var n = Jr("json.schema.nocontent", "Unable to load schema from '{0}': No content.", ro(e));
            return new Qr({}, [n]);
        } var r, o = []; r = Re(t, o); var i = o.length ? [Jr("json.schema.invalidFormat", "Unable to parse content from '{0}': Parse error at offset {1}.", ro(e), o[0].offset)] : []; return new Qr(r, i); }), (function (t) { var n = t.toString(), r = t.toString().split("Error: "); return r.length > 1 && (n = r[1]), Lt(n, ".") && (n = n.substr(0, n.length - 1)), new Qr({}, [Jr("json.schema.nocontent", "Unable to load schema from '{0}': {1}.", ro(e), n)]); })); }, e.prototype.resolveSchemaContent = function (e, t, n) { var r = this, o = e.errors.slice(0), i = e.schema; if (i.$schema) {
            var s = no(i.$schema);
            if ("http://json-schema.org/draft-03/schema" === s)
                return this.promise.resolve(new Zr({}, [Jr("json.schema.draft03.notsupported", "Draft-03 schemas are not supported.")]));
            "https://json-schema.org/draft/2019-09/schema" === s && o.push(Jr("json.schema.draft201909.notsupported", "Draft 2019-09 schemas are not yet fully supported."));
        } var a = this.contextService, u = function (e, t, n, r) { var i = r ? decodeURIComponent(r) : void 0, s = function (e, t) { if (!t)
            return e; var n = e; return "/" === t[0] && (t = t.substr(1)), t.split("/").some((function (e) { return e = e.replace(/~1/g, "/").replace(/~0/g, "~"), !(n = n[e]); })), n; }(t, i); if (s)
            for (var a in s)
                s.hasOwnProperty(a) && !e.hasOwnProperty(a) && (e[a] = s[a]);
        else
            o.push(Jr("json.schema.invalidref", "$ref '{0}' in '{1}' can not be resolved.", i, n)); }, c = function (e, t, n, i, s) { a && !/^[A-Za-z][A-Za-z0-9+\-.+]*:\/\/.*/.test(t) && (t = a.resolveRelativePath(t, i)), t = no(t); var c = r.getOrAddSchemaHandle(t); return c.getUnresolvedSchema().then((function (r) { if (s[t] = !0, r.errors.length) {
            var i = n ? t + "#" + n : t;
            o.push(Jr("json.schema.problemloadingref", "Problems loading reference '{0}': {1}", i, r.errors[0]));
        } return u(e, r.schema, t, n), l(e, r.schema, t, c.dependencies); })); }, l = function (e, t, n, o) { if (!e || "object" != typeof e)
            return Promise.resolve(null); for (var i = [e], s = [], a = [], l = function (e) { for (var r = []; e.$ref;) {
            var s = e.$ref, l = s.split("#", 2);
            if (delete e.$ref, l[0].length > 0)
                return void a.push(c(e, l[0], l[1], n, o));
            -1 === r.indexOf(s) && (u(e, t, n, l[1]), r.push(s));
        } !function () { for (var e = [], t = 0; t < arguments.length; t++)
            e[t] = arguments[t]; for (var n = 0, r = e; n < r.length; n++) {
            var o = r[n];
            "object" == typeof o && i.push(o);
        } }(e.items, e.additionalItems, e.additionalProperties, e.not, e.contains, e.propertyNames, e.if, e.then, e.else), function () { for (var e = [], t = 0; t < arguments.length; t++)
            e[t] = arguments[t]; for (var n = 0, r = e; n < r.length; n++) {
            var o = r[n];
            if ("object" == typeof o)
                for (var s in o) {
                    var a = o[s];
                    "object" == typeof a && i.push(a);
                }
        } }(e.definitions, e.properties, e.patternProperties, e.dependencies), function () { for (var e = [], t = 0; t < arguments.length; t++)
            e[t] = arguments[t]; for (var n = 0, r = e; n < r.length; n++) {
            var o = r[n];
            if (Array.isArray(o))
                for (var s = 0, a = o; s < a.length; s++) {
                    var u = a[s];
                    "object" == typeof u && i.push(u);
                }
        } }(e.anyOf, e.allOf, e.oneOf, e.items); }; i.length;) {
            var p = i.pop();
            s.indexOf(p) >= 0 || (s.push(p), l(p));
        } return r.promise.all(a); }; return l(i, i, t, n).then((function (e) { return new Zr(i, o); })); }, e.prototype.getSchemaForResource = function (e, t) { if (t && t.root && "object" === t.root.type) {
            var n = t.root.properties.filter((function (e) { return "$schema" === e.keyNode.value && e.valueNode && "string" === e.valueNode.type; }));
            if (n.length > 0) {
                var r = n[0].valueNode;
                if (r && "string" === r.type) {
                    var o = Wr(r);
                    if (o && Bt(o, ".") && this.contextService && (o = this.contextService.resolveRelativePath(o, e)), o) {
                        var i = no(o);
                        return this.getOrAddSchemaHandle(i).getResolvedSchema();
                    }
                }
            }
        } if (this.cachedSchemaForResource && this.cachedSchemaForResource.resource === e)
            return this.cachedSchemaForResource.resolvedSchema; for (var s = Object.create(null), a = [], u = function (e) { try {
            return It.parse(e).with({ fragment: null, query: null }).toString();
        }
        catch (t) {
            return e;
        } }(e), c = 0, l = this.filePatternAssociations; c < l.length; c++) {
            var p = l[c];
            if (p.matchesPattern(u))
                for (var f = 0, d = p.getURIs(); f < d.length; f++) {
                    var h = d[f];
                    s[h] || (a.push(h), s[h] = !0);
                }
        } var m = a.length > 0 ? this.createCombinedSchema(e, a).getResolvedSchema() : this.promise.resolve(void 0); return this.cachedSchemaForResource = { resource: e, resolvedSchema: m }, m; }, e.prototype.createCombinedSchema = function (e, t) { if (1 === t.length)
            return this.getOrAddSchemaHandle(t[0]); var n = "schemaservice://combinedSchema/" + encodeURIComponent(e), r = { allOf: t.map((function (e) { return { $ref: e }; })) }; return this.addSchemaHandle(n, r); }, e.prototype.getMatchingSchemas = function (e, t, n) { if (n) {
            var r = n.id || "schemaservice://untitled/matchingSchemas/" + to++;
            return this.resolveSchemaContent(new Qr(n), r, {}).then((function (e) { return t.getMatchingSchemas(e.schema).filter((function (e) { return !e.inverted; })); }));
        } return this.getSchemaForResource(e.uri, t).then((function (e) { return e ? t.getMatchingSchemas(e.schema).filter((function (e) { return !e.inverted; })) : []; })); }, e; }(), to = 0;
        function no(e) { try {
            return It.parse(e).toString();
        }
        catch (t) {
            return e;
        } }
        function ro(e) { try {
            var t = It.parse(e);
            if ("file" === t.scheme)
                return t.fsPath;
        }
        catch (e) { } return e; }
        function oo(e) { try {
            return new RegExp(e, "u");
        }
        catch (t) {
            return new RegExp(e);
        } }
        function io(e, t) { for (let n = ++t; n < e.length; n++) {
            const r = e.charAt(n);
            if (" " !== r && "\t" !== r)
                return t;
            t++;
        } return t; }
        var so = Symbol.for("yaml.alias"), ao = Symbol.for("yaml.document"), uo = Symbol.for("yaml.map"), co = Symbol.for("yaml.pair"), lo = Symbol.for("yaml.scalar"), po = Symbol.for("yaml.seq"), fo = Symbol.for("yaml.node.type"), ho = e => !!e && "object" == typeof e && e[fo] === so, mo = e => !!e && "object" == typeof e && e[fo] === ao, go = e => !!e && "object" == typeof e && e[fo] === uo, yo = e => !!e && "object" == typeof e && e[fo] === co, vo = e => !!e && "object" == typeof e && e[fo] === lo, bo = e => !!e && "object" == typeof e && e[fo] === po;
        function Do(e) { if (e && "object" == typeof e)
            switch (e[fo]) {
                case uo:
                case po: return !0;
            } return !1; }
        function Eo(e) { if (e && "object" == typeof e)
            switch (e[fo]) {
                case so:
                case uo:
                case lo:
                case po: return !0;
            } return !1; }
        var Co = class {
            constructor(e) { Object.defineProperty(this, fo, { value: e }); }
            clone() { const e = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this)); return this.range && (e.range = this.range.slice()), e; }
        }, wo = Symbol("break visit"), Ao = Symbol("skip children"), So = Symbol("remove node");
        function xo(e, t) { const n = Oo(t); mo(e) ? To(null, e.contents, n, Object.freeze([e])) === So && (e.contents = null) : To(null, e, n, Object.freeze([])); }
        function To(e, t, n, r) { const o = _o(e, t, n, r); if (Eo(o) || yo(o))
            return No(e, r, o), To(e, o, n, r); if ("symbol" != typeof o)
            if (Do(t)) {
                r = Object.freeze(r.concat(t));
                for (let e = 0; e < t.items.length; ++e) {
                    const o = To(e, t.items[e], n, r);
                    if ("number" == typeof o)
                        e = o - 1;
                    else {
                        if (o === wo)
                            return wo;
                        o === So && (t.items.splice(e, 1), e -= 1);
                    }
                }
            }
            else if (yo(t)) {
                r = Object.freeze(r.concat(t));
                const e = To("key", t.key, n, r);
                if (e === wo)
                    return wo;
                e === So && (t.key = null);
                const o = To("value", t.value, n, r);
                if (o === wo)
                    return wo;
                o === So && (t.value = null);
            } return o; }
        async function ko(e, t) { const n = Oo(t); mo(e) ? await Fo(null, e.contents, n, Object.freeze([e])) === So && (e.contents = null) : await Fo(null, e, n, Object.freeze([])); }
        async function Fo(e, t, n, r) { const o = await _o(e, t, n, r); if (Eo(o) || yo(o))
            return No(e, r, o), Fo(e, o, n, r); if ("symbol" != typeof o)
            if (Do(t)) {
                r = Object.freeze(r.concat(t));
                for (let e = 0; e < t.items.length; ++e) {
                    const o = await Fo(e, t.items[e], n, r);
                    if ("number" == typeof o)
                        e = o - 1;
                    else {
                        if (o === wo)
                            return wo;
                        o === So && (t.items.splice(e, 1), e -= 1);
                    }
                }
            }
            else if (yo(t)) {
                r = Object.freeze(r.concat(t));
                const e = await Fo("key", t.key, n, r);
                if (e === wo)
                    return wo;
                e === So && (t.key = null);
                const o = await Fo("value", t.value, n, r);
                if (o === wo)
                    return wo;
                o === So && (t.value = null);
            } return o; }
        function Oo(e) { return "object" == typeof e && (e.Collection || e.Node || e.Value) ? Object.assign({ Alias: e.Node, Map: e.Node, Scalar: e.Node, Seq: e.Node }, e.Value && { Map: e.Value, Scalar: e.Value, Seq: e.Value }, e.Collection && { Map: e.Collection, Seq: e.Collection }, e) : e; }
        function _o(e, t, n, r) { var o, i, s, a, u; return "function" == typeof n ? n(e, t, r) : go(t) ? null === (o = n.Map) || void 0 === o ? void 0 : o.call(n, e, t, r) : bo(t) ? null === (i = n.Seq) || void 0 === i ? void 0 : i.call(n, e, t, r) : yo(t) ? null === (s = n.Pair) || void 0 === s ? void 0 : s.call(n, e, t, r) : vo(t) ? null === (a = n.Scalar) || void 0 === a ? void 0 : a.call(n, e, t, r) : ho(t) ? null === (u = n.Alias) || void 0 === u ? void 0 : u.call(n, e, t, r) : void 0; }
        function No(e, t, n) { const r = t[t.length - 1]; if (Do(r))
            r.items[e] = n;
        else if (yo(r))
            "key" === e ? r.key = n : r.value = n;
        else {
            if (!mo(r)) {
                const e = ho(r) ? "alias" : "scalar";
                throw new Error(`Cannot replace node with ${e} parent`);
            }
            r.contents = n;
        } }
        xo.BREAK = wo, xo.SKIP = Ao, xo.REMOVE = So, ko.BREAK = wo, ko.SKIP = Ao, ko.REMOVE = So;
        var Po = { "!": "%21", ",": "%2C", "[": "%5B", "]": "%5D", "{": "%7B", "}": "%7D" }, Mo = class {
            constructor(e, t) { this.docStart = null, this.docEnd = !1, this.yaml = Object.assign({}, Mo.defaultYaml, e), this.tags = Object.assign({}, Mo.defaultTags, t); }
            clone() { const e = new Mo(this.yaml, this.tags); return e.docStart = this.docStart, e; }
            atDocument() { const e = new Mo(this.yaml, this.tags); switch (this.yaml.version) {
                case "1.1":
                    this.atNextDocument = !0;
                    break;
                case "1.2": this.atNextDocument = !1, this.yaml = { explicit: Mo.defaultYaml.explicit, version: "1.2" }, this.tags = Object.assign({}, Mo.defaultTags);
            } return e; }
            add(e, t) { this.atNextDocument && (this.yaml = { explicit: Mo.defaultYaml.explicit, version: "1.1" }, this.tags = Object.assign({}, Mo.defaultTags), this.atNextDocument = !1); const n = e.trim().split(/[ \t]+/), r = n.shift(); switch (r) {
                case "%TAG": {
                    if (2 !== n.length && (t(0, "%TAG directive should contain exactly two parts"), n.length < 2))
                        return !1;
                    const [e, r] = n;
                    return this.tags[e] = r, !0;
                }
                case "%YAML": {
                    if (this.yaml.explicit = !0, 1 !== n.length)
                        return t(0, "%YAML directive should contain exactly one part"), !1;
                    const [e] = n;
                    return "1.1" === e || "1.2" === e ? (this.yaml.version = e, !0) : (t(6, `Unsupported YAML version ${e}`, /^\d+\.\d+$/.test(e)), !1);
                }
                default: return t(0, `Unknown directive ${r}`, !0), !1;
            } }
            tagName(e, t) { if ("!" === e)
                return "!"; if ("!" !== e[0])
                return t(`Not a valid tag: ${e}`), null; if ("<" === e[1]) {
                const n = e.slice(2, -1);
                return "!" === n || "!!" === n ? (t(`Verbatim tags aren't resolved, so ${e} is invalid.`), null) : (">" !== e[e.length - 1] && t("Verbatim tags must end with a >"), n);
            } const [, n, r] = e.match(/^(.*!)([^!]*)$/); r || t(`The ${e} tag has no suffix`); const o = this.tags[n]; return o ? o + decodeURIComponent(r) : "!" === n ? e : (t(`Could not resolve tag: ${e}`), null); }
            tagString(e) { for (const [t, n] of Object.entries(this.tags))
                if (e.startsWith(n))
                    return t + e.substring(n.length).replace(/[!,[\]{}]/g, (e => Po[e])); return "!" === e[0] ? e : `!<${e}>`; }
            toString(e) { const t = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [], n = Object.entries(this.tags); let r; if (e && n.length > 0 && Eo(e.contents)) {
                const t = {};
                xo(e.contents, ((e, n) => { Eo(n) && n.tag && (t[n.tag] = !0); })), r = Object.keys(t);
            }
            else
                r = []; for (const [o, i] of n)
                "!!" === o && "tag:yaml.org,2002:" === i || e && !r.some((e => e.startsWith(i))) || t.push(`%TAG ${o} ${i}`); return t.join("\n"); }
        };
        function Ro(e) { if (/[\x00-\x19\s,[\]{}]/.test(e)) {
            const t = JSON.stringify(e);
            throw new Error(`Anchor must not contain whitespace or control characters: ${t}`);
        } return !0; }
        function Io(e) { const t = new Set; return xo(e, { Value(e, n) { n.anchor && t.add(n.anchor); } }), t; }
        function jo(e, t) { for (let n = 1;; ++n) {
            const r = `${e}${n}`;
            if (!t.has(r))
                return r;
        } }
        Mo.defaultYaml = { explicit: !1, version: "1.2" }, Mo.defaultTags = { "!!": "tag:yaml.org,2002:" };
        var Bo = class extends Co {
            constructor(e) { super(so), this.source = e, Object.defineProperty(this, "tag", { set() { throw new Error("Alias nodes cannot have tags"); } }); }
            resolve(e) { let t; return xo(e, { Node: (e, n) => { if (n === this)
                    return xo.BREAK; n.anchor === this.source && (t = n); } }), t; }
            toJSON(e, t) { if (!t)
                return { source: this.source }; const { anchors: n, doc: r, maxAliasCount: o } = t, i = this.resolve(r); if (!i) {
                const e = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
                throw new ReferenceError(e);
            } const s = n.get(i); if (!s || void 0 === s.res)
                throw new ReferenceError("This should not happen: Alias anchor was not resolved?"); if (o >= 0 && (s.count += 1, 0 === s.aliasCount && (s.aliasCount = Lo(r, i, n)), s.count * s.aliasCount > o))
                throw new ReferenceError("Excessive alias count indicates a resource exhaustion attack"); return s.res; }
            toString(e, t, n) { const r = `*${this.source}`; if (e) {
                if (Ro(this.source), e.options.verifyAliasOrder && !e.anchors.has(this.source)) {
                    const e = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
                    throw new Error(e);
                }
                if (e.implicitKey)
                    return `${r} `;
            } return r; }
        };
        function Lo(e, t, n) { if (ho(t)) {
            const r = t.resolve(e), o = n && r && n.get(r);
            return o ? o.count * o.aliasCount : 0;
        } if (Do(t)) {
            let r = 0;
            for (const o of t.items) {
                const t = Lo(e, o, n);
                t > r && (r = t);
            }
            return r;
        } if (yo(t)) {
            const r = Lo(e, t.key, n), o = Lo(e, t.value, n);
            return Math.max(r, o);
        } return 1; }
        function qo(e, t, n) { if (Array.isArray(e))
            return e.map(((e, t) => qo(e, String(t), n))); if (e && "function" == typeof e.toJSON) {
            if (!n || !vo(r = e) && !Do(r) || !r.anchor)
                return e.toJSON(t, n);
            const o = { aliasCount: 0, count: 1, res: void 0 };
            n.anchors.set(e, o), n.onCreate = e => { o.res = e, delete n.onCreate; };
            const i = e.toJSON(t, n);
            return n.onCreate && n.onCreate(i), i;
        } var r; return "bigint" != typeof e || n && n.keep ? e : Number(e); }
        var $o = e => !e || "function" != typeof e && "object" != typeof e, Uo = class extends Co {
            constructor(e) { super(lo), this.value = e; }
            toJSON(e, t) { return t && t.keep ? this.value : qo(this.value, e, t); }
            toString() { return String(this.value); }
        };
        function Vo(e, t, n) { var r, o; if (mo(e) && (e = e.contents), Eo(e))
            return e; if (yo(e)) {
            const t = null === (o = (r = n.schema[uo]).createNode) || void 0 === o ? void 0 : o.call(r, n.schema, null, n);
            return t.items.push(e), t;
        } (e instanceof String || e instanceof Number || e instanceof Boolean || "function" == typeof BigInt && e instanceof BigInt) && (e = e.valueOf()); const { aliasDuplicateObjects: i, onAnchor: s, onTagObj: a, schema: u, sourceObjects: c } = n; let l; if (i && e && "object" == typeof e) {
            if (l = c.get(e), l)
                return l.anchor || (l.anchor = s(e)), new Bo(l.anchor);
            l = { anchor: null, node: null }, c.set(e, l);
        } t && t.startsWith("!!") && (t = "tag:yaml.org,2002:" + t.slice(2)); let p = function (e, t, n) { if (t) {
            const e = n.filter((e => e.tag === t)), r = e.find((e => !e.format)) || e[0];
            if (!r)
                throw new Error(`Tag ${t} not found`);
            return r;
        } return n.find((t => t.identify && t.identify(e) && !t.format)); }(e, t, u.tags); if (!p) {
            if (e && "function" == typeof e.toJSON && (e = e.toJSON()), !e || "object" != typeof e) {
                const t = new Uo(e);
                return l && (l.node = t), t;
            }
            p = e instanceof Map ? u[uo] : Symbol.iterator in Object(e) ? u[po] : u[uo];
        } a && (a(p), delete n.onTagObj); const f = (null == p ? void 0 : p.createNode) ? p.createNode(n.schema, e, n) : new Uo(e); return t && (f.tag = t), l && (l.node = f), f; }
        function Wo(e, t, n) { let r = n; for (let e = t.length - 1; e >= 0; --e) {
            const n = t[e];
            if ("number" == typeof n && Number.isInteger(n) && n >= 0) {
                const e = [];
                e[n] = r, r = e;
            }
            else
                r = new Map([[n, r]]);
        } return Vo(r, void 0, { aliasDuplicateObjects: !1, keepUndefined: !1, onAnchor: () => { throw new Error("This should not happen, please report a bug."); }, schema: e, sourceObjects: new Map }); }
        Uo.BLOCK_FOLDED = "BLOCK_FOLDED", Uo.BLOCK_LITERAL = "BLOCK_LITERAL", Uo.PLAIN = "PLAIN", Uo.QUOTE_DOUBLE = "QUOTE_DOUBLE", Uo.QUOTE_SINGLE = "QUOTE_SINGLE";
        var Ko = e => null == e || "object" == typeof e && !!e[Symbol.iterator]().next().done, zo = class extends Co {
            constructor(e, t) { super(e), Object.defineProperty(this, "schema", { value: t, configurable: !0, enumerable: !1, writable: !0 }); }
            clone(e) { const t = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this)); return e && (t.schema = e), t.items = t.items.map((t => Eo(t) || yo(t) ? t.clone(e) : t)), this.range && (t.range = this.range.slice()), t; }
            addIn(e, t) { if (Ko(e))
                this.add(t);
            else {
                const [n, ...r] = e, o = this.get(n, !0);
                if (Do(o))
                    o.addIn(r, t);
                else {
                    if (void 0 !== o || !this.schema)
                        throw new Error(`Expected YAML collection at ${n}. Remaining path: ${r}`);
                    this.set(n, Wo(this.schema, r, t));
                }
            } }
            deleteIn(e) { const [t, ...n] = e; if (0 === n.length)
                return this.delete(t); const r = this.get(t, !0); if (Do(r))
                return r.deleteIn(n); throw new Error(`Expected YAML collection at ${t}. Remaining path: ${n}`); }
            getIn(e, t) { const [n, ...r] = e, o = this.get(n, !0); return 0 === r.length ? !t && vo(o) ? o.value : o : Do(o) ? o.getIn(r, t) : void 0; }
            hasAllNullValues(e) { return this.items.every((t => { if (!yo(t))
                return !1; const n = t.value; return null == n || e && vo(n) && null == n.value && !n.commentBefore && !n.comment && !n.tag; })); }
            hasIn(e) { const [t, ...n] = e; if (0 === n.length)
                return this.has(t); const r = this.get(t, !0); return !!Do(r) && r.hasIn(n); }
            setIn(e, t) { const [n, ...r] = e; if (0 === r.length)
                this.set(n, t);
            else {
                const e = this.get(n, !0);
                if (Do(e))
                    e.setIn(r, t);
                else {
                    if (void 0 !== e || !this.schema)
                        throw new Error(`Expected YAML collection at ${n}. Remaining path: ${r}`);
                    this.set(n, Wo(this.schema, r, t));
                }
            } }
        };
        zo.maxFlowStringSingleLineLength = 60;
        var Ho = e => e.replace(/^(?!$)(?: $)?/gm, "#");
        function Yo(e, t) { return /^\n+$/.test(e) ? e.substring(1) : t ? e.replace(/^(?! *$)/gm, t) : e; }
        var Jo = (e, t, n) => n.includes("\n") ? "\n" + Yo(n, t) : (e.endsWith(" ") ? "" : " ") + n, Go = "flow", Xo = "block", Qo = "quoted";
        function Zo(e, t, n = "flow", { indentAtStart: r, lineWidth: o = 80, minContentWidth: i = 20, onFold: s, onOverflow: a } = {}) { if (!o || o < 0)
            return e; const u = Math.max(1 + i, 1 + o - t.length); if (e.length <= u)
            return e; const c = [], l = {}; let p, f, d = o - t.length; "number" == typeof r && (r > o - Math.max(2, i) ? c.push(0) : d = o - r); let h, m = !1, g = -1, y = -1, v = -1; for (n === Xo && (g = ei(e, g), -1 !== g && (d = g + u)); h = e[g += 1];) {
            if (n === Qo && "\\" === h) {
                switch (y = g, e[g + 1]) {
                    case "x":
                        g += 3;
                        break;
                    case "u":
                        g += 5;
                        break;
                    case "U":
                        g += 9;
                        break;
                    default: g += 1;
                }
                v = g;
            }
            if ("\n" === h)
                n === Xo && (g = ei(e, g)), d = g + u, p = void 0;
            else {
                if (" " === h && f && " " !== f && "\n" !== f && "\t" !== f) {
                    const t = e[g + 1];
                    t && " " !== t && "\n" !== t && "\t" !== t && (p = g);
                }
                if (g >= d)
                    if (p)
                        c.push(p), d = p + u, p = void 0;
                    else if (n === Qo) {
                        for (; " " === f || "\t" === f;)
                            f = h, h = e[g += 1], m = !0;
                        const t = g > v + 1 ? g - 2 : y - 1;
                        if (l[t])
                            return e;
                        c.push(t), l[t] = !0, d = t + u, p = void 0;
                    }
                    else
                        m = !0;
            }
            f = h;
        } if (m && a && a(), 0 === c.length)
            return e; s && s(); let b = e.slice(0, c[0]); for (let r = 0; r < c.length; ++r) {
            const o = c[r], i = c[r + 1] || e.length;
            0 === o ? b = `\n${t}${e.slice(0, i)}` : (n === Qo && l[o] && (b += `${e[o]}\\`), b += `\n${t}${e.slice(o + 1, i)}`);
        } return b; }
        function ei(e, t) { let n = e[t + 1]; for (; " " === n || "\t" === n;) {
            do {
                n = e[t += 1];
            } while (n && "\n" !== n);
            n = e[t + 1];
        } return t; }
        var ti = e => ({ indentAtStart: e.indentAtStart, lineWidth: e.options.lineWidth, minContentWidth: e.options.minContentWidth }), ni = e => /^(%|---|\.\.\.)/m.test(e);
        function ri(e, t) { const n = JSON.stringify(e); if (t.options.doubleQuotedAsJSON)
            return n; const { implicitKey: r } = t, o = t.options.doubleQuotedMinMultiLineLength, i = t.indent || (ni(e) ? "  " : ""); let s = "", a = 0; for (let e = 0, t = n[e]; t; t = n[++e])
            if (" " === t && "\\" === n[e + 1] && "n" === n[e + 2] && (s += n.slice(a, e) + "\\ ", e += 1, a = e, t = "\\"), "\\" === t)
                switch (n[e + 1]) {
                    case "u":
                        {
                            s += n.slice(a, e);
                            const t = n.substr(e + 2, 4);
                            switch (t) {
                                case "0000":
                                    s += "\\0";
                                    break;
                                case "0007":
                                    s += "\\a";
                                    break;
                                case "000b":
                                    s += "\\v";
                                    break;
                                case "001b":
                                    s += "\\e";
                                    break;
                                case "0085":
                                    s += "\\N";
                                    break;
                                case "00a0":
                                    s += "\\_";
                                    break;
                                case "2028":
                                    s += "\\L";
                                    break;
                                case "2029":
                                    s += "\\P";
                                    break;
                                default: "00" === t.substr(0, 2) ? s += "\\x" + t.substr(2) : s += n.substr(e, 6);
                            }
                            e += 5, a = e + 1;
                        }
                        break;
                    case "n":
                        if (r || '"' === n[e + 2] || n.length < o)
                            e += 1;
                        else {
                            for (s += n.slice(a, e) + "\n\n"; "\\" === n[e + 2] && "n" === n[e + 3] && '"' !== n[e + 4];)
                                s += "\n", e += 2;
                            s += i, " " === n[e + 2] && (s += "\\"), e += 1, a = e + 1;
                        }
                        break;
                    default: e += 1;
                } return s = a ? s + n.slice(a) : n, r ? s : Zo(s, i, Qo, ti(t)); }
        function oi(e, t) { if (!1 === t.options.singleQuote || t.implicitKey && e.includes("\n") || /[ \t]\n|\n[ \t]/.test(e))
            return ri(e, t); const n = t.indent || (ni(e) ? "  " : ""), r = "'" + e.replace(/'/g, "''").replace(/\n+/g, `$&\n${n}`) + "'"; return t.implicitKey ? r : Zo(r, n, Go, ti(t)); }
        function ii(e, t) { const { singleQuote: n } = t.options; let r; if (!1 === n)
            r = ri;
        else {
            const t = e.includes('"'), o = e.includes("'");
            r = t && !o ? oi : o && !t ? ri : n ? oi : ri;
        } return r(e, t); }
        function si({ comment: e, type: t, value: n }, r, o, i) { const { blockQuote: s, commentString: a, lineWidth: u } = r.options; if (!s || /\n[\t ]+$/.test(n) || /^\s*$/.test(n))
            return ii(n, r); const c = r.indent || (r.forceBlockIndent || ni(n) ? "  " : ""), l = "literal" === s || "folded" !== s && t !== Uo.BLOCK_FOLDED && (t === Uo.BLOCK_LITERAL || !function (e, t, n) { if (!t || t < 0)
            return !1; const r = t - n, o = e.length; if (o <= r)
            return !1; for (let t = 0, n = 0; t < o; ++t)
            if ("\n" === e[t]) {
                if (t - n > r)
                    return !0;
                if (n = t + 1, o - n <= r)
                    return !1;
            } return !0; }(n, u, c.length)); if (!n)
            return l ? "|\n" : ">\n"; let p, f; for (f = n.length; f > 0; --f) {
            const e = n[f - 1];
            if ("\n" !== e && "\t" !== e && " " !== e)
                break;
        } let d = n.substring(f); const h = d.indexOf("\n"); -1 === h ? p = "-" : n === d || h !== d.length - 1 ? (p = "+", i && i()) : p = "", d && (n = n.slice(0, -d.length), "\n" === d[d.length - 1] && (d = d.slice(0, -1)), d = d.replace(/\n+(?!\n|$)/g, `$&${c}`)); let m, g = !1, y = -1; for (m = 0; m < n.length; ++m) {
            const e = n[m];
            if (" " === e)
                g = !0;
            else {
                if ("\n" !== e)
                    break;
                y = m;
            }
        } let v = n.substring(0, y < m ? y + 1 : m); v && (n = n.substring(v.length), v = v.replace(/\n+/g, `$&${c}`)); let b = (l ? "|" : ">") + (g ? c ? "2" : "1" : "") + p; return e && (b += " " + a(e.replace(/ ?[\r\n]+/g, " ")), o && o()), l ? `${b}\n${c}${v}${n = n.replace(/\n+/g, `$&${c}`)}${d}` : `${b}\n${c}${Zo(`${v}${n = n.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${c}`)}${d}`, c, Xo, ti(r))}`; }
        function ai(e, t, n, r) { const { implicitKey: o, inFlow: i } = t, s = "string" == typeof e.value ? e : Object.assign({}, e, { value: String(e.value) }); let { type: a } = e; a !== Uo.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(s.value) && (a = Uo.QUOTE_DOUBLE); const u = e => { switch (e) {
            case Uo.BLOCK_FOLDED:
            case Uo.BLOCK_LITERAL: return o || i ? ii(s.value, t) : si(s, t, n, r);
            case Uo.QUOTE_DOUBLE: return ri(s.value, t);
            case Uo.QUOTE_SINGLE: return oi(s.value, t);
            case Uo.PLAIN: return function (e, t, n, r) { const { type: o, value: i } = e, { actualString: s, implicitKey: a, indent: u, inFlow: c } = t; if (a && /[\n[\]{},]/.test(i) || c && /[[\]{},]/.test(i))
                return ii(i, t); if (!i || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(i))
                return a || c || -1 === i.indexOf("\n") ? ii(i, t) : si(e, t, n, r); if (!a && !c && o !== Uo.PLAIN && -1 !== i.indexOf("\n"))
                return si(e, t, n, r); if ("" === u && ni(i))
                return t.forceBlockIndent = !0, si(e, t, n, r); const l = i.replace(/\n+/g, `$&\n${u}`); if (s) {
                const e = e => { var t; return e.default && "tag:yaml.org,2002:str" !== e.tag && (null === (t = e.test) || void 0 === t ? void 0 : t.test(l)); }, { compat: n, tags: r } = t.doc.schema;
                if (r.some(e) || (null == n ? void 0 : n.some(e)))
                    return ii(i, t);
            } return a ? l : Zo(l, u, Go, ti(t)); }(s, t, n, r);
            default: return null;
        } }; let c = u(a); if (null === c) {
            const { defaultKeyType: e, defaultStringType: n } = t.options, r = o && e || n;
            if (c = u(r), null === c)
                throw new Error(`Unsupported default string type ${r}`);
        } return c; }
        function ui(e, t) { const n = Object.assign({ blockQuote: !0, commentString: Ho, defaultKeyType: null, defaultStringType: "PLAIN", directives: null, doubleQuotedAsJSON: !1, doubleQuotedMinMultiLineLength: 40, falseStr: "false", indentSeq: !0, lineWidth: 80, minContentWidth: 20, nullStr: "null", simpleKeys: !1, singleQuote: null, trueStr: "true", verifyAliasOrder: !0 }, e.schema.toStringOptions, t); let r; switch (n.collectionStyle) {
            case "block":
                r = !1;
                break;
            case "flow":
                r = !0;
                break;
            default: r = null;
        } return { anchors: new Set, doc: e, indent: "", indentStep: "number" == typeof n.indent ? " ".repeat(n.indent) : "  ", inFlow: r, options: n }; }
        function ci(e, t, n, r) { var o; if (yo(e))
            return e.toString(t, n, r); if (ho(e)) {
            if (t.doc.directives)
                return e.toString(t);
            if (null === (o = t.resolvedAliases) || void 0 === o ? void 0 : o.has(e))
                throw new TypeError("Cannot stringify circular structure without alias nodes");
            t.resolvedAliases ? t.resolvedAliases.add(e) : t.resolvedAliases = new Set([e]), e = e.resolve(t.doc);
        } let i; const s = Eo(e) ? e : t.doc.createNode(e, { onTagObj: e => i = e }); i || (i = function (e, t) { if (t.tag) {
            const n = e.filter((e => e.tag === t.tag));
            if (n.length > 0)
                return n.find((e => e.format === t.format)) || n[0];
        } let n, r; if (vo(t)) {
            r = t.value;
            const o = e.filter((e => e.identify && e.identify(r)));
            n = o.find((e => e.format === t.format)) || o.find((e => !e.format));
        }
        else
            r = t, n = e.find((e => e.nodeClass && r instanceof e.nodeClass)); if (!n) {
            const e = r && r.constructor ? r.constructor.name : typeof r;
            throw new Error(`Tag not resolved for ${e} value`);
        } return n; }(t.doc.schema.tags, s)); const a = function (e, t, { anchors: n, doc: r }) { if (!r.directives)
            return ""; const o = [], i = (vo(e) || Do(e)) && e.anchor; i && Ro(i) && (n.add(i), o.push(`&${i}`)); const s = e.tag || (t.default ? null : t.tag); return s && o.push(r.directives.tagString(s)), o.join(" "); }(s, i, t); a.length > 0 && (t.indentAtStart = (t.indentAtStart || 0) + a.length + 1); const u = "function" == typeof i.stringify ? i.stringify(s, t, n, r) : vo(s) ? ai(s, t, n, r) : s.toString(t, n, r); return a ? vo(s) || "{" === u[0] || "[" === u[0] ? `${a} ${u}` : `${a}\n${t.indent}${u}` : u; }
        function li(e, t) { "debug" !== e && "warn" !== e || (void 0 !== s && s.emitWarning ? s.emitWarning(t) : a.warn(t)); }
        function pi(e, t, { key: n, value: r }) { if (e && e.doc.schema.merge && fi(n))
            if (r = ho(r) ? r.resolve(e.doc) : r, bo(r))
                for (const n of r.items)
                    di(e, t, n);
            else if (Array.isArray(r))
                for (const n of r)
                    di(e, t, n);
            else
                di(e, t, r);
        else {
            const o = qo(n, "", e);
            if (t instanceof Map)
                t.set(o, qo(r, o, e));
            else if (t instanceof Set)
                t.add(o);
            else {
                const i = function (e, t, n) { if (null === t)
                    return ""; if ("object" != typeof t)
                    return String(t); if (Eo(e) && n && n.doc) {
                    const t = ui(n.doc, {});
                    t.anchors = new Set;
                    for (const e of n.anchors.keys())
                        t.anchors.add(e.anchor);
                    t.inFlow = !0, t.inStringifyKey = !0;
                    const r = e.toString(t);
                    if (!n.mapKeyWarned) {
                        let e = JSON.stringify(r);
                        e.length > 40 && (e = e.substring(0, 36) + '..."'), li(n.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${e}. Set mapAsMap: true to use object keys.`), n.mapKeyWarned = !0;
                    }
                    return r;
                } return JSON.stringify(t); }(n, o, e), s = qo(r, i, e);
                i in t ? Object.defineProperty(t, i, { value: s, writable: !0, enumerable: !0, configurable: !0 }) : t[i] = s;
            }
        } return t; }
        var fi = e => "<<" === e || vo(e) && "<<" === e.value && (!e.type || e.type === Uo.PLAIN);
        function di(e, t, n) { const r = e && ho(n) ? n.resolve(e.doc) : n; if (!go(r))
            throw new Error("Merge sources must be maps or map aliases"); const o = r.toJSON(null, e, Map); for (const [e, n] of o)
            t instanceof Map ? t.has(e) || t.set(e, n) : t instanceof Set ? t.add(e) : Object.prototype.hasOwnProperty.call(t, e) || Object.defineProperty(t, e, { value: n, writable: !0, enumerable: !0, configurable: !0 }); return t; }
        function hi(e, t, n) { const r = Vo(e, void 0, n), o = Vo(t, void 0, n); return new mi(r, o); }
        var mi = class {
            constructor(e, t = null) { Object.defineProperty(this, fo, { value: co }), this.key = e, this.value = t; }
            clone(e) { let { key: t, value: n } = this; return Eo(t) && (t = t.clone(e)), Eo(n) && (n = n.clone(e)), new mi(t, n); }
            toJSON(e, t) { return pi(t, t && t.mapAsMap ? new Map : {}, this); }
            toString(e, t, n) { return e && e.doc ? function ({ key: e, value: t }, n, r, o) { const { allNullValues: i, doc: s, indent: a, indentStep: u, options: { commentString: c, indentSeq: l, simpleKeys: p } } = n; let f = Eo(e) && e.comment || null; if (p) {
                if (f)
                    throw new Error("With simple keys, key nodes cannot have comments");
                if (Do(e))
                    throw new Error("With simple keys, collection cannot be used as a key value");
            } let d = !p && (!e || f && null == t && !n.inFlow || Do(e) || (vo(e) ? e.type === Uo.BLOCK_FOLDED || e.type === Uo.BLOCK_LITERAL : "object" == typeof e)); n = Object.assign({}, n, { allNullValues: !1, implicitKey: !d && (p || !i), indent: a + u }); let h = !1, m = !1, g = ci(e, n, (() => h = !0), (() => m = !0)); if (!d && !n.inFlow && g.length > 1024) {
                if (p)
                    throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
                d = !0;
            } if (n.inFlow) {
                if (i || null == t)
                    return h && r && r(), "" === g ? "?" : d ? `? ${g}` : g;
            }
            else if (i && !p || null == t && d)
                return g = `? ${g}`, f && !h ? g += Jo(g, n.indent, c(f)) : m && o && o(), g; h && (f = null), d ? (f && (g += Jo(g, n.indent, c(f))), g = `? ${g}\n${a}:`) : (g = `${g}:`, f && (g += Jo(g, n.indent, c(f)))); let y = "", v = null; Eo(t) ? (t.spaceBefore && (y = "\n"), t.commentBefore && (y += `\n${Yo(c(t.commentBefore), n.indent)}`), v = t.comment) : t && "object" == typeof t && (t = s.createNode(t)), n.implicitKey = !1, d || f || !vo(t) || (n.indentAtStart = g.length + 1), m = !1, l || !(u.length >= 2) || n.inFlow || d || !bo(t) || t.flow || t.tag || t.anchor || (n.indent = n.indent.substr(2)); let b = !1; const D = ci(t, n, (() => b = !0), (() => m = !0)); let E = " "; return y || f ? E = "" !== D || n.inFlow ? `${y}\n${n.indent}` : y : !d && Do(t) ? ("[" === D[0] || "{" === D[0]) && !D.includes("\n") || (E = `\n${n.indent}`) : "" !== D && "\n" !== D[0] || (E = ""), g += E + D, n.inFlow ? b && r && r() : v && !b ? g += Jo(g, n.indent, c(v)) : m && o && o(), g; }(this, e, t, n) : JSON.stringify(this); }
        };
        function gi(e, t, n) { var r; return ((null !== (r = t.inFlow) && void 0 !== r ? r : e.flow) ? vi : yi)(e, t, n); }
        function yi({ comment: e, items: t }, n, { blockItemPrefix: r, flowChars: o, itemIndent: i, onChompKeep: s, onComment: a }) { const { indent: u, options: { commentString: c } } = n, l = Object.assign({}, n, { indent: i, type: null }); let p = !1; const f = []; for (let e = 0; e < t.length; ++e) {
            const o = t[e];
            let s = null;
            if (Eo(o))
                !p && o.spaceBefore && f.push(""), bi(n, f, o.commentBefore, p), o.comment && (s = o.comment);
            else if (yo(o)) {
                const e = Eo(o.key) ? o.key : null;
                e && (!p && e.spaceBefore && f.push(""), bi(n, f, e.commentBefore, p));
            }
            p = !1;
            let a = ci(o, l, (() => s = null), (() => p = !0));
            s && (a += Jo(a, i, c(s))), p && s && (p = !1), f.push(r + a);
        } let d; if (0 === f.length)
            d = o.start + o.end;
        else {
            d = f[0];
            for (let e = 1; e < f.length; ++e) {
                const t = f[e];
                d += t ? `\n${u}${t}` : "\n";
            }
        } return e ? (d += "\n" + Yo(c(e), u), a && a()) : p && s && s(), d; }
        function vi({ comment: e, items: t }, n, { flowChars: r, itemIndent: o, onComment: i }) { const { indent: s, indentStep: a, options: { commentString: u } } = n; o += a; const c = Object.assign({}, n, { indent: o, inFlow: !0, type: null }); let l = !1, p = 0; const f = []; for (let e = 0; e < t.length; ++e) {
            const r = t[e];
            let i = null;
            if (Eo(r))
                r.spaceBefore && f.push(""), bi(n, f, r.commentBefore, !1), r.comment && (i = r.comment);
            else if (yo(r)) {
                const e = Eo(r.key) ? r.key : null;
                e && (e.spaceBefore && f.push(""), bi(n, f, e.commentBefore, !1), e.comment && (l = !0));
                const t = Eo(r.value) ? r.value : null;
                t ? (t.comment && (i = t.comment), t.commentBefore && (l = !0)) : null == r.value && e && e.comment && (i = e.comment);
            }
            i && (l = !0);
            let s = ci(r, c, (() => i = null));
            e < t.length - 1 && (s += ","), i && (s += Jo(s, o, u(i))), !l && (f.length > p || s.includes("\n")) && (l = !0), f.push(s), p = f.length;
        } let d; const { start: h, end: m } = r; if (0 === f.length)
            d = h + m;
        else if (l || (l = f.reduce(((e, t) => e + t.length + 2), 2) > zo.maxFlowStringSingleLineLength), l) {
            d = h;
            for (const e of f)
                d += e ? `\n${a}${s}${e}` : "\n";
            d += `\n${s}${m}`;
        }
        else
            d = `${h} ${f.join(" ")} ${m}`; return e && (d += Jo(d, u(e), s), i && i()), d; }
        function bi({ indent: e, options: { commentString: t } }, n, r, o) { if (r && o && (r = r.replace(/^\n+/, "")), r) {
            const o = Yo(t(r), e);
            n.push(o.trimStart());
        } }
        function Di(e, t) { const n = vo(t) ? t.value : t; for (const r of e)
            if (yo(r)) {
                if (r.key === t || r.key === n)
                    return r;
                if (vo(r.key) && r.key.value === n)
                    return r;
            } }
        var Ei = class extends zo {
            constructor(e) { super(uo, e), this.items = []; }
            static get tagName() { return "tag:yaml.org,2002:map"; }
            add(e, t) { let n; n = yo(e) ? e : new mi(e && "object" == typeof e && "key" in e ? e.key : e, e.value); const r = Di(this.items, n.key), o = this.schema && this.schema.sortMapEntries; if (r) {
                if (!t)
                    throw new Error(`Key ${n.key} already set`);
                vo(r.value) && $o(n.value) ? r.value.value = n.value : r.value = n.value;
            }
            else if (o) {
                const e = this.items.findIndex((e => o(n, e) < 0));
                -1 === e ? this.items.push(n) : this.items.splice(e, 0, n);
            }
            else
                this.items.push(n); }
            delete(e) { const t = Di(this.items, e); return !!t && this.items.splice(this.items.indexOf(t), 1).length > 0; }
            get(e, t) { const n = Di(this.items, e), r = n && n.value; return !t && vo(r) ? r.value : r; }
            has(e) { return !!Di(this.items, e); }
            set(e, t) { this.add(new mi(e, t), !0); }
            toJSON(e, t, n) { const r = n ? new n : t && t.mapAsMap ? new Map : {}; t && t.onCreate && t.onCreate(r); for (const e of this.items)
                pi(t, r, e); return r; }
            toString(e, t, n) { if (!e)
                return JSON.stringify(this); for (const e of this.items)
                if (!yo(e))
                    throw new Error(`Map items must all be pairs; found ${JSON.stringify(e)} instead`); return !e.allNullValues && this.hasAllNullValues(!1) && (e = Object.assign({}, e, { allNullValues: !0 })), gi(this, e, { blockItemPrefix: "", flowChars: { start: "{", end: "}" }, itemIndent: e.indent || "", onChompKeep: n, onComment: t }); }
        }, Ci = { collection: "map", createNode: function (e, t, n) { const { keepUndefined: r, replacer: o } = n, i = new Ei(e), s = (e, s) => { if ("function" == typeof o)
                s = o.call(t, e, s);
            else if (Array.isArray(o) && !o.includes(e))
                return; (void 0 !== s || r) && i.items.push(hi(e, s, n)); }; if (t instanceof Map)
                for (const [e, n] of t)
                    s(e, n);
            else if (t && "object" == typeof t)
                for (const e of Object.keys(t))
                    s(e, t[e]); return "function" == typeof e.sortMapEntries && i.items.sort(e.sortMapEntries), i; }, default: !0, nodeClass: Ei, tag: "tag:yaml.org,2002:map", resolve: (e, t) => (go(e) || t("Expected a mapping for this tag"), e) }, wi = class extends zo {
            constructor(e) { super(po, e), this.items = []; }
            static get tagName() { return "tag:yaml.org,2002:seq"; }
            add(e) { this.items.push(e); }
            delete(e) { const t = Ai(e); return "number" == typeof t && this.items.splice(t, 1).length > 0; }
            get(e, t) { const n = Ai(e); if ("number" != typeof n)
                return; const r = this.items[n]; return !t && vo(r) ? r.value : r; }
            has(e) { const t = Ai(e); return "number" == typeof t && t < this.items.length; }
            set(e, t) { const n = Ai(e); if ("number" != typeof n)
                throw new Error(`Expected a valid index, not ${e}.`); const r = this.items[n]; vo(r) && $o(t) ? r.value = t : this.items[n] = t; }
            toJSON(e, t) { const n = []; t && t.onCreate && t.onCreate(n); let r = 0; for (const e of this.items)
                n.push(qo(e, String(r++), t)); return n; }
            toString(e, t, n) { return e ? gi(this, e, { blockItemPrefix: "- ", flowChars: { start: "[", end: "]" }, itemIndent: (e.indent || "") + "  ", onChompKeep: n, onComment: t }) : JSON.stringify(this); }
        };
        function Ai(e) { let t = vo(e) ? e.value : e; return t && "string" == typeof t && (t = Number(t)), "number" == typeof t && Number.isInteger(t) && t >= 0 ? t : null; }
        var Si = { collection: "seq", createNode: function (e, t, n) { const { replacer: r } = n, o = new wi(e); if (t && Symbol.iterator in Object(t)) {
                let e = 0;
                for (let i of t) {
                    if ("function" == typeof r) {
                        const n = t instanceof Set ? i : String(e++);
                        i = r.call(t, n, i);
                    }
                    o.items.push(Vo(i, void 0, n));
                }
            } return o; }, default: !0, nodeClass: wi, tag: "tag:yaml.org,2002:seq", resolve: (e, t) => (bo(e) || t("Expected a sequence for this tag"), e) }, xi = { identify: e => "string" == typeof e, default: !0, tag: "tag:yaml.org,2002:str", resolve: e => e, stringify: (e, t, n, r) => ai(e, t = Object.assign({ actualString: !0 }, t), n, r) }, Ti = { identify: e => null == e, createNode: () => new Uo(null), default: !0, tag: "tag:yaml.org,2002:null", test: /^(?:~|[Nn]ull|NULL)?$/, resolve: () => new Uo(null), stringify: ({ source: e }, t) => "string" == typeof e && Ti.test.test(e) ? e : t.options.nullStr }, ki = { identify: e => "boolean" == typeof e, default: !0, tag: "tag:yaml.org,2002:bool", test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/, resolve: e => new Uo("t" === e[0] || "T" === e[0]), stringify: ({ source: e, value: t }, n) => e && ki.test.test(e) && t === ("t" === e[0] || "T" === e[0]) ? e : t ? n.options.trueStr : n.options.falseStr };
        function Fi({ format: e, minFractionDigits: t, tag: n, value: r }) { if ("bigint" == typeof r)
            return String(r); const o = "number" == typeof r ? r : Number(r); if (!isFinite(o))
            return isNaN(o) ? ".nan" : o < 0 ? "-.inf" : ".inf"; let i = JSON.stringify(r); if (!e && t && (!n || "tag:yaml.org,2002:float" === n) && /^\d/.test(i)) {
            let e = i.indexOf(".");
            e < 0 && (e = i.length, i += ".");
            let n = t - (i.length - e - 1);
            for (; n-- > 0;)
                i += "0";
        } return i; }
        var Oi = { identify: e => "number" == typeof e, default: !0, tag: "tag:yaml.org,2002:float", test: /^(?:[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN))$/, resolve: e => "nan" === e.slice(-3).toLowerCase() ? NaN : "-" === e[0] ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, stringify: Fi }, _i = { identify: e => "number" == typeof e, default: !0, tag: "tag:yaml.org,2002:float", format: "EXP", test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/, resolve: e => parseFloat(e), stringify(e) { const t = Number(e.value); return isFinite(t) ? t.toExponential() : Fi(e); } }, Ni = { identify: e => "number" == typeof e, default: !0, tag: "tag:yaml.org,2002:float", test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/, resolve(e) { const t = new Uo(parseFloat(e)), n = e.indexOf("."); return -1 !== n && "0" === e[e.length - 1] && (t.minFractionDigits = e.length - n - 1), t; }, stringify: Fi }, Pi = e => "bigint" == typeof e || Number.isInteger(e), Mi = (e, t, n, { intAsBigInt: r }) => r ? BigInt(e) : parseInt(e.substring(t), n);
        function Ri(e, t, n) { const { value: r } = e; return Pi(r) && r >= 0 ? n + r.toString(t) : Fi(e); }
        var Ii = { identify: e => Pi(e) && e >= 0, default: !0, tag: "tag:yaml.org,2002:int", format: "OCT", test: /^0o[0-7]+$/, resolve: (e, t, n) => Mi(e, 2, 8, n), stringify: e => Ri(e, 8, "0o") }, ji = { identify: Pi, default: !0, tag: "tag:yaml.org,2002:int", test: /^[-+]?[0-9]+$/, resolve: (e, t, n) => Mi(e, 0, 10, n), stringify: Fi }, Bi = { identify: e => Pi(e) && e >= 0, default: !0, tag: "tag:yaml.org,2002:int", format: "HEX", test: /^0x[0-9a-fA-F]+$/, resolve: (e, t, n) => Mi(e, 2, 16, n), stringify: e => Ri(e, 16, "0x") }, Li = [Ci, Si, xi, Ti, ki, Ii, ji, Bi, Oi, _i, Ni];
        function qi(e) { return "bigint" == typeof e || Number.isInteger(e); }
        var $i = ({ value: e }) => JSON.stringify(e), Ui = [Ci, Si].concat([{ identify: e => "string" == typeof e, default: !0, tag: "tag:yaml.org,2002:str", resolve: e => e, stringify: $i }, { identify: e => null == e, createNode: () => new Uo(null), default: !0, tag: "tag:yaml.org,2002:null", test: /^null$/, resolve: () => null, stringify: $i }, { identify: e => "boolean" == typeof e, default: !0, tag: "tag:yaml.org,2002:bool", test: /^true|false$/, resolve: e => "true" === e, stringify: $i }, { identify: qi, default: !0, tag: "tag:yaml.org,2002:int", test: /^-?(?:0|[1-9][0-9]*)$/, resolve: (e, t, { intAsBigInt: n }) => n ? BigInt(e) : parseInt(e, 10), stringify: ({ value: e }) => qi(e) ? e.toString() : JSON.stringify(e) }, { identify: e => "number" == typeof e, default: !0, tag: "tag:yaml.org,2002:float", test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/, resolve: e => parseFloat(e), stringify: $i }], { default: !0, tag: "", test: /^/, resolve: (e, t) => (t(`Unresolved plain scalar ${JSON.stringify(e)}`), e) }), Vi = { identify: e => e instanceof Uint8Array, default: !1, tag: "tag:yaml.org,2002:binary", resolve(e, t) { if ("function" == typeof u)
                return u.from(e, "base64"); if ("function" == typeof atob) {
                const t = atob(e.replace(/[\n\r]/g, "")), n = new Uint8Array(t.length);
                for (let e = 0; e < t.length; ++e)
                    n[e] = t.charCodeAt(e);
                return n;
            } return t("This environment does not support reading binary tags; either Buffer or atob is required"), e; }, stringify({ comment: e, type: t, value: n }, r, o, i) { const s = n; let a; if ("function" == typeof u)
                a = s instanceof u ? s.toString("base64") : u.from(s.buffer).toString("base64");
            else {
                if ("function" != typeof btoa)
                    throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
                {
                    let e = "";
                    for (let t = 0; t < s.length; ++t)
                        e += String.fromCharCode(s[t]);
                    a = btoa(e);
                }
            } if (t || (t = Uo.BLOCK_LITERAL), t !== Uo.QUOTE_DOUBLE) {
                const e = Math.max(r.options.lineWidth - r.indent.length, r.options.minContentWidth), n = Math.ceil(a.length / e), o = new Array(n);
                for (let t = 0, r = 0; t < n; ++t, r += e)
                    o[t] = a.substr(r, e);
                a = o.join(t === Uo.BLOCK_LITERAL ? "\n" : " ");
            } return ai({ comment: e, type: t, value: a }, r, o, i); } };
        function Wi(e, t) { if (bo(e))
            for (let n = 0; n < e.items.length; ++n) {
                let r = e.items[n];
                if (!yo(r)) {
                    if (go(r)) {
                        r.items.length > 1 && t("Each pair must have its own sequence indicator");
                        const e = r.items[0] || new mi(new Uo(null));
                        if (r.commentBefore && (e.key.commentBefore = e.key.commentBefore ? `${r.commentBefore}\n${e.key.commentBefore}` : r.commentBefore), r.comment) {
                            const t = e.value || e.key;
                            t.comment = t.comment ? `${r.comment}\n${t.comment}` : r.comment;
                        }
                        r = e;
                    }
                    e.items[n] = yo(r) ? r : new mi(r);
                }
            }
        else
            t("Expected a sequence for this tag"); return e; }
        function Ki(e, t, n) { const { replacer: r } = n, o = new wi(e); o.tag = "tag:yaml.org,2002:pairs"; let i = 0; if (t && Symbol.iterator in Object(t))
            for (let e of t) {
                let s, a;
                if ("function" == typeof r && (e = r.call(t, String(i++), e)), Array.isArray(e)) {
                    if (2 !== e.length)
                        throw new TypeError(`Expected [key, value] tuple: ${e}`);
                    s = e[0], a = e[1];
                }
                else if (e && e instanceof Object) {
                    const t = Object.keys(e);
                    if (1 !== t.length)
                        throw new TypeError(`Expected { key: value } tuple: ${e}`);
                    s = t[0], a = e[s];
                }
                else
                    s = e;
                o.items.push(hi(s, a, n));
            } return o; }
        var zi = { collection: "seq", default: !1, tag: "tag:yaml.org,2002:pairs", resolve: Wi, createNode: Ki }, Hi = class extends wi {
            constructor() { super(), this.add = Ei.prototype.add.bind(this), this.delete = Ei.prototype.delete.bind(this), this.get = Ei.prototype.get.bind(this), this.has = Ei.prototype.has.bind(this), this.set = Ei.prototype.set.bind(this), this.tag = Hi.tag; }
            toJSON(e, t) { if (!t)
                return super.toJSON(e); const n = new Map; t && t.onCreate && t.onCreate(n); for (const e of this.items) {
                let r, o;
                if (yo(e) ? (r = qo(e.key, "", t), o = qo(e.value, r, t)) : r = qo(e, "", t), n.has(r))
                    throw new Error("Ordered maps must not include duplicate keys");
                n.set(r, o);
            } return n; }
        };
        Hi.tag = "tag:yaml.org,2002:omap";
        var Yi = { collection: "seq", identify: e => e instanceof Map, nodeClass: Hi, default: !1, tag: "tag:yaml.org,2002:omap", resolve(e, t) { const n = Wi(e, t), r = []; for (const { key: e } of n.items)
                vo(e) && (r.includes(e.value) ? t(`Ordered maps must not include duplicate keys: ${e.value}`) : r.push(e.value)); return Object.assign(new Hi, n); }, createNode(e, t, n) { const r = Ki(e, t, n), o = new Hi; return o.items = r.items, o; } };
        function Ji({ value: e, source: t }, n) { return t && (e ? Gi : Xi).test.test(t) ? t : e ? n.options.trueStr : n.options.falseStr; }
        var Gi = { identify: e => !0 === e, default: !0, tag: "tag:yaml.org,2002:bool", test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/, resolve: () => new Uo(!0), stringify: Ji }, Xi = { identify: e => !1 === e, default: !0, tag: "tag:yaml.org,2002:bool", test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i, resolve: () => new Uo(!1), stringify: Ji }, Qi = { identify: e => "number" == typeof e, default: !0, tag: "tag:yaml.org,2002:float", test: /^[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN)$/, resolve: e => "nan" === e.slice(-3).toLowerCase() ? NaN : "-" === e[0] ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, stringify: Fi }, Zi = { identify: e => "number" == typeof e, default: !0, tag: "tag:yaml.org,2002:float", format: "EXP", test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/, resolve: e => parseFloat(e.replace(/_/g, "")), stringify(e) { const t = Number(e.value); return isFinite(t) ? t.toExponential() : Fi(e); } }, es = { identify: e => "number" == typeof e, default: !0, tag: "tag:yaml.org,2002:float", test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/, resolve(e) { const t = new Uo(parseFloat(e.replace(/_/g, ""))), n = e.indexOf("."); if (-1 !== n) {
                const r = e.substring(n + 1).replace(/_/g, "");
                "0" === r[r.length - 1] && (t.minFractionDigits = r.length);
            } return t; }, stringify: Fi }, ts = e => "bigint" == typeof e || Number.isInteger(e);
        function ns(e, t, n, { intAsBigInt: r }) { const o = e[0]; if ("-" !== o && "+" !== o || (t += 1), e = e.substring(t).replace(/_/g, ""), r) {
            switch (n) {
                case 2:
                    e = `0b${e}`;
                    break;
                case 8:
                    e = `0o${e}`;
                    break;
                case 16: e = `0x${e}`;
            }
            const t = BigInt(e);
            return "-" === o ? BigInt(-1) * t : t;
        } const i = parseInt(e, n); return "-" === o ? -1 * i : i; }
        function rs(e, t, n) { const { value: r } = e; if (ts(r)) {
            const e = r.toString(t);
            return r < 0 ? "-" + n + e.substr(1) : n + e;
        } return Fi(e); }
        var os = { identify: ts, default: !0, tag: "tag:yaml.org,2002:int", format: "BIN", test: /^[-+]?0b[0-1_]+$/, resolve: (e, t, n) => ns(e, 2, 2, n), stringify: e => rs(e, 2, "0b") }, is = { identify: ts, default: !0, tag: "tag:yaml.org,2002:int", format: "OCT", test: /^[-+]?0[0-7_]+$/, resolve: (e, t, n) => ns(e, 1, 8, n), stringify: e => rs(e, 8, "0") }, ss = { identify: ts, default: !0, tag: "tag:yaml.org,2002:int", test: /^[-+]?[0-9][0-9_]*$/, resolve: (e, t, n) => ns(e, 0, 10, n), stringify: Fi }, as = { identify: ts, default: !0, tag: "tag:yaml.org,2002:int", format: "HEX", test: /^[-+]?0x[0-9a-fA-F_]+$/, resolve: (e, t, n) => ns(e, 2, 16, n), stringify: e => rs(e, 16, "0x") }, us = class extends Ei {
            constructor(e) { super(e), this.tag = us.tag; }
            add(e) { let t; t = yo(e) ? e : "object" == typeof e && "key" in e && "value" in e && null === e.value ? new mi(e.key, null) : new mi(e, null), Di(this.items, t.key) || this.items.push(t); }
            get(e, t) { const n = Di(this.items, e); return !t && yo(n) ? vo(n.key) ? n.key.value : n.key : n; }
            set(e, t) { if ("boolean" != typeof t)
                throw new Error("Expected boolean value for set(key, value) in a YAML set, not " + typeof t); const n = Di(this.items, e); n && !t ? this.items.splice(this.items.indexOf(n), 1) : !n && t && this.items.push(new mi(e)); }
            toJSON(e, t) { return super.toJSON(e, t, Set); }
            toString(e, t, n) { if (!e)
                return JSON.stringify(this); if (this.hasAllNullValues(!0))
                return super.toString(Object.assign({}, e, { allNullValues: !0 }), t, n); throw new Error("Set items must all have null values"); }
        };
        us.tag = "tag:yaml.org,2002:set";
        var cs = { collection: "map", identify: e => e instanceof Set, nodeClass: us, default: !1, tag: "tag:yaml.org,2002:set", resolve(e, t) { if (go(e)) {
                if (e.hasAllNullValues(!0))
                    return Object.assign(new us, e);
                t("Set items must all have null values");
            }
            else
                t("Expected a mapping for this tag"); return e; }, createNode(e, t, n) { const { replacer: r } = n, o = new us(e); if (t && Symbol.iterator in Object(t))
                for (let e of t)
                    "function" == typeof r && (e = r.call(t, e, e)), o.items.push(hi(e, null, n)); return o; } };
        function ls(e, t) { const n = e[0], r = "-" === n || "+" === n ? e.substring(1) : e, o = e => t ? BigInt(e) : Number(e), i = r.replace(/_/g, "").split(":").reduce(((e, t) => e * o(60) + o(t)), o(0)); return "-" === n ? o(-1) * i : i; }
        function ps(e) { let { value: t } = e, n = e => e; if ("bigint" == typeof t)
            n = e => BigInt(e);
        else if (isNaN(t) || !isFinite(t))
            return Fi(e); let r = ""; t < 0 && (r = "-", t *= n(-1)); const o = n(60), i = [t % o]; return t < 60 ? i.unshift(0) : (t = (t - i[0]) / o, i.unshift(t % o), t >= 60 && (t = (t - i[0]) / o, i.unshift(t))), r + i.map((e => e < 10 ? "0" + String(e) : String(e))).join(":").replace(/000000\d*$/, ""); }
        var fs = { identify: e => "bigint" == typeof e || Number.isInteger(e), default: !0, tag: "tag:yaml.org,2002:int", format: "TIME", test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/, resolve: (e, t, { intAsBigInt: n }) => ls(e, n), stringify: ps }, ds = { identify: e => "number" == typeof e, default: !0, tag: "tag:yaml.org,2002:float", format: "TIME", test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/, resolve: e => ls(e, !1), stringify: ps }, hs = { identify: e => e instanceof Date, default: !0, tag: "tag:yaml.org,2002:timestamp", test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"), resolve(e) { const t = e.match(hs.test); if (!t)
                throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd"); const [, n, r, o, i, s, a] = t.map(Number), u = t[7] ? Number((t[7] + "00").substr(1, 3)) : 0; let c = Date.UTC(n, r - 1, o, i || 0, s || 0, a || 0, u); const l = t[8]; if (l && "Z" !== l) {
                let e = ls(l, !1);
                Math.abs(e) < 30 && (e *= 60), c -= 6e4 * e;
            } return new Date(c); }, stringify: ({ value: e }) => e.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "") }, ms = [Ci, Si, xi, Ti, Gi, Xi, os, is, ss, as, Qi, Zi, es, Vi, Yi, zi, cs, fs, ds, hs], gs = new Map([["core", Li], ["failsafe", [Ci, Si, xi]], ["json", Ui], ["yaml11", ms], ["yaml-1.1", ms]]), ys = { binary: Vi, bool: ki, float: Ni, floatExp: _i, floatNaN: Oi, floatTime: ds, int: ji, intHex: Bi, intOct: Ii, intTime: fs, map: Ci, null: Ti, omap: Yi, pairs: zi, seq: Si, set: cs, timestamp: hs }, vs = { "tag:yaml.org,2002:binary": Vi, "tag:yaml.org,2002:omap": Yi, "tag:yaml.org,2002:pairs": zi, "tag:yaml.org,2002:set": cs, "tag:yaml.org,2002:timestamp": hs };
        function bs(e, t) { let n = gs.get(t); if (!n) {
            if (!Array.isArray(e)) {
                const e = Array.from(gs.keys()).filter((e => "yaml11" !== e)).map((e => JSON.stringify(e))).join(", ");
                throw new Error(`Unknown schema "${t}"; use one of ${e} or define customTags array`);
            }
            n = [];
        } if (Array.isArray(e))
            for (const t of e)
                n = n.concat(t);
        else
            "function" == typeof e && (n = e(n.slice())); return n.map((e => { if ("string" != typeof e)
            return e; const t = ys[e]; if (t)
            return t; const n = Object.keys(ys).map((e => JSON.stringify(e))).join(", "); throw new Error(`Unknown custom tag "${e}"; use one of ${n}`); })); }
        var Ds = (e, t) => e.key < t.key ? -1 : e.key > t.key ? 1 : 0, Es = class {
            constructor({ compat: e, customTags: t, merge: n, resolveKnownTags: r, schema: o, sortMapEntries: i, toStringDefaults: s }) { this.compat = Array.isArray(e) ? bs(e, "compat") : e ? bs(null, e) : null, this.merge = !!n, this.name = "string" == typeof o && o || "core", this.knownTags = r ? vs : {}, this.tags = bs(t, this.name), this.toStringOptions = s || null, Object.defineProperty(this, uo, { value: Ci }), Object.defineProperty(this, lo, { value: xi }), Object.defineProperty(this, po, { value: Si }), this.sortMapEntries = !0 === i ? Ds : i || null; }
            clone() { const e = Object.create(Es.prototype, Object.getOwnPropertyDescriptors(this)); return e.tags = this.tags.slice(), e; }
        };
        function Cs(e, t, n, r) { if (r && "object" == typeof r)
            if (Array.isArray(r))
                for (let t = 0, n = r.length; t < n; ++t) {
                    const n = r[t], o = Cs(e, r, String(t), n);
                    void 0 === o ? delete r[t] : o !== n && (r[t] = o);
                }
            else if (r instanceof Map)
                for (const t of Array.from(r.keys())) {
                    const n = r.get(t), o = Cs(e, r, t, n);
                    void 0 === o ? r.delete(t) : o !== n && r.set(t, o);
                }
            else if (r instanceof Set)
                for (const t of Array.from(r)) {
                    const n = Cs(e, r, t, t);
                    void 0 === n ? r.delete(t) : n !== t && (r.delete(t), r.add(n));
                }
            else
                for (const [t, n] of Object.entries(r)) {
                    const o = Cs(e, r, t, n);
                    void 0 === o ? delete r[t] : o !== n && (r[t] = o);
                } return e.call(t, n, r); }
        var ws = class {
            constructor(e, t, n) { this.commentBefore = null, this.comment = null, this.errors = [], this.warnings = [], Object.defineProperty(this, fo, { value: ao }); let r = null; "function" == typeof t || Array.isArray(t) ? r = t : void 0 === n && t && (n = t, t = void 0); const o = Object.assign({ intAsBigInt: !1, keepSourceTokens: !1, logLevel: "warn", prettyErrors: !0, strict: !0, uniqueKeys: !0, version: "1.2" }, n); this.options = o; let { version: i } = o; (null == n ? void 0 : n.directives) ? (this.directives = n.directives.atDocument(), this.directives.yaml.explicit && (i = this.directives.yaml.version)) : this.directives = new Mo({ version: i }), this.setSchema(i, n), this.contents = void 0 === e ? null : this.createNode(e, r, n); }
            clone() { const e = Object.create(ws.prototype, { [fo]: { value: ao } }); return e.commentBefore = this.commentBefore, e.comment = this.comment, e.errors = this.errors.slice(), e.warnings = this.warnings.slice(), e.options = Object.assign({}, this.options), this.directives && (e.directives = this.directives.clone()), e.schema = this.schema.clone(), e.contents = Eo(this.contents) ? this.contents.clone(e.schema) : this.contents, this.range && (e.range = this.range.slice()), e; }
            add(e) { As(this.contents) && this.contents.add(e); }
            addIn(e, t) { As(this.contents) && this.contents.addIn(e, t); }
            createAlias(e, t) { if (!e.anchor) {
                const n = Io(this);
                e.anchor = !t || n.has(t) ? jo(t || "a", n) : t;
            } return new Bo(e.anchor); }
            createNode(e, t, n) { let r; if ("function" == typeof t)
                e = t.call({ "": e }, "", e), r = t;
            else if (Array.isArray(t)) {
                const e = e => "number" == typeof e || e instanceof String || e instanceof Number, n = t.filter(e).map(String);
                n.length > 0 && (t = t.concat(n)), r = t;
            }
            else
                void 0 === n && t && (n = t, t = void 0); const { aliasDuplicateObjects: o, anchorPrefix: i, flow: s, keepUndefined: a, onTagObj: u, tag: c } = n || {}, { onAnchor: l, setAnchors: p, sourceObjects: f } = function (e, t) { const n = [], r = new Map; let o = null; return { onAnchor(r) { n.push(r), o || (o = Io(e)); const i = jo(t, o); return o.add(i), i; }, setAnchors() { for (const e of n) {
                    const t = r.get(e);
                    if ("object" != typeof t || !t.anchor || !vo(t.node) && !Do(t.node)) {
                        const t = new Error("Failed to resolve repeated object (this should not happen)");
                        throw t.source = e, t;
                    }
                    t.node.anchor = t.anchor;
                } }, sourceObjects: r }; }(this, i || "a"), d = Vo(e, c, { aliasDuplicateObjects: null == o || o, keepUndefined: null != a && a, onAnchor: l, onTagObj: u, replacer: r, schema: this.schema, sourceObjects: f }); return s && Do(d) && (d.flow = !0), p(), d; }
            createPair(e, t, n = {}) { const r = this.createNode(e, null, n), o = this.createNode(t, null, n); return new mi(r, o); }
            delete(e) { return !!As(this.contents) && this.contents.delete(e); }
            deleteIn(e) { return Ko(e) ? null != this.contents && (this.contents = null, !0) : !!As(this.contents) && this.contents.deleteIn(e); }
            get(e, t) { return Do(this.contents) ? this.contents.get(e, t) : void 0; }
            getIn(e, t) { return Ko(e) ? !t && vo(this.contents) ? this.contents.value : this.contents : Do(this.contents) ? this.contents.getIn(e, t) : void 0; }
            has(e) { return !!Do(this.contents) && this.contents.has(e); }
            hasIn(e) { return Ko(e) ? void 0 !== this.contents : !!Do(this.contents) && this.contents.hasIn(e); }
            set(e, t) { null == this.contents ? this.contents = Wo(this.schema, [e], t) : As(this.contents) && this.contents.set(e, t); }
            setIn(e, t) { Ko(e) ? this.contents = t : null == this.contents ? this.contents = Wo(this.schema, Array.from(e), t) : As(this.contents) && this.contents.setIn(e, t); }
            setSchema(e, t = {}) { let n; switch ("number" == typeof e && (e = String(e)), e) {
                case "1.1":
                    this.directives ? this.directives.yaml.version = "1.1" : this.directives = new Mo({ version: "1.1" }), n = { merge: !0, resolveKnownTags: !1, schema: "yaml-1.1" };
                    break;
                case "1.2":
                    this.directives ? this.directives.yaml.version = "1.2" : this.directives = new Mo({ version: "1.2" }), n = { merge: !1, resolveKnownTags: !0, schema: "core" };
                    break;
                case null:
                    this.directives && delete this.directives, n = null;
                    break;
                default: {
                    const t = JSON.stringify(e);
                    throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${t}`);
                }
            } if (t.schema instanceof Object)
                this.schema = t.schema;
            else {
                if (!n)
                    throw new Error("With a null YAML version, the { schema: Schema } option is required");
                this.schema = new Es(Object.assign(n, t));
            } }
            toJS({ json: e, jsonArg: t, mapAsMap: n, maxAliasCount: r, onAnchor: o, reviver: i } = {}) { const s = { anchors: new Map, doc: this, keep: !e, mapAsMap: !0 === n, mapKeyWarned: !1, maxAliasCount: "number" == typeof r ? r : 100, stringify: ci }, a = qo(this.contents, t || "", s); if ("function" == typeof o)
                for (const { count: e, res: t } of s.anchors.values())
                    o(t, e); return "function" == typeof i ? Cs(i, { "": a }, "", a) : a; }
            toJSON(e, t) { return this.toJS({ json: !0, jsonArg: e, mapAsMap: !1, onAnchor: t }); }
            toString(e = {}) { if (this.errors.length > 0)
                throw new Error("Document with errors cannot be stringified"); if ("indent" in e && (!Number.isInteger(e.indent) || Number(e.indent) <= 0)) {
                const t = JSON.stringify(e.indent);
                throw new Error(`"indent" option must be a positive integer, not ${t}`);
            } return function (e, t) { var n; const r = []; let o = !0 === t.directives; if (!1 !== t.directives && e.directives) {
                const t = e.directives.toString(e);
                t ? (r.push(t), o = !0) : e.directives.docStart && (o = !0);
            } o && r.push("---"); const i = ui(e, t), { commentString: s } = i.options; if (e.commentBefore) {
                1 !== r.length && r.unshift("");
                const t = s(e.commentBefore);
                r.unshift(Yo(t, ""));
            } let a = !1, u = null; if (e.contents) {
                if (Eo(e.contents)) {
                    if (e.contents.spaceBefore && o && r.push(""), e.contents.commentBefore) {
                        const t = s(e.contents.commentBefore);
                        r.push(Yo(t, ""));
                    }
                    i.forceBlockIndent = !!e.comment, u = e.contents.comment;
                }
                const t = u ? void 0 : () => a = !0;
                let n = ci(e.contents, i, (() => u = null), t);
                u && (n += Jo(n, "", s(u))), "|" !== n[0] && ">" !== n[0] || "---" !== r[r.length - 1] ? r.push(n) : r[r.length - 1] = `--- ${n}`;
            }
            else
                r.push(ci(e.contents, i)); if (null === (n = e.directives) || void 0 === n ? void 0 : n.docEnd)
                if (e.comment) {
                    const t = s(e.comment);
                    t.includes("\n") ? (r.push("..."), r.push(Yo(t, ""))) : r.push(`... ${t}`);
                }
                else
                    r.push("...");
            else {
                let t = e.comment;
                t && a && (t = t.replace(/^\n+/, "")), t && (a && !u || "" === r[r.length - 1] || r.push(""), r.push(Yo(s(t), "")));
            } return r.join("\n") + "\n"; }(this, e); }
        };
        function As(e) { if (Do(e))
            return !0; throw new Error("Expected a YAML collection as document contents"); }
        var Ss = class extends Error {
            constructor(e, t, n, r) { super(), this.name = e, this.code = n, this.message = r, this.pos = t; }
        }, xs = class extends Ss {
            constructor(e, t, n) { super("YAMLParseError", e, t, n); }
        }, Ts = class extends Ss {
            constructor(e, t, n) { super("YAMLWarning", e, t, n); }
        }, ks = (e, t) => n => { if (-1 === n.pos[0])
            return; n.linePos = n.pos.map((e => t.linePos(e))); const { line: r, col: o } = n.linePos[0]; n.message += ` at line ${r}, column ${o}`; let i = o - 1, s = e.substring(t.lineStarts[r - 1], t.lineStarts[r]).replace(/[\n\r]+$/, ""); if (i >= 60 && s.length > 80) {
            const e = Math.min(i - 39, s.length - 79);
            s = "…" + s.substring(e), i -= e - 1;
        } if (s.length > 80 && (s = s.substring(0, 79) + "…"), r > 1 && /^ *$/.test(s.substring(0, i))) {
            let n = e.substring(t.lineStarts[r - 2], t.lineStarts[r - 1]);
            n.length > 80 && (n = n.substring(0, 79) + "…\n"), s = n + s;
        } if (/[^ ]/.test(s)) {
            let e = 1;
            const t = n.linePos[1];
            t && t.line === r && t.col > o && (e = Math.min(t.col - o, 80 - i));
            const a = " ".repeat(i) + "^".repeat(e);
            n.message += `:\n\n${s}\n${a}\n`;
        } };
        function Fs(e, { flow: t, indicator: n, next: r, offset: o, onError: i, startOnNewline: s }) { let a = !1, u = s, c = s, l = "", p = "", f = !1, d = !1, h = null, m = null, g = null, y = null, v = null; for (const r of e)
            switch (d && ("space" !== r.type && "newline" !== r.type && "comma" !== r.type && i(r.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"), d = !1), r.type) {
                case "space":
                    !t && u && "doc-start" !== n && "\t" === r.source[0] && i(r, "TAB_AS_INDENT", "Tabs are not allowed as indentation"), c = !0;
                    break;
                case "comment": {
                    c || i(r, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
                    const e = r.source.substring(1) || " ";
                    l ? l += p + e : l = e, p = "", u = !1;
                    break;
                }
                case "newline":
                    u ? l ? l += r.source : a = !0 : p += r.source, u = !0, f = !0, c = !0;
                    break;
                case "anchor":
                    h && i(r, "MULTIPLE_ANCHORS", "A node can have at most one anchor"), r.source.endsWith(":") && i(r.offset + r.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", !0), h = r, null === v && (v = r.offset), u = !1, c = !1, d = !0;
                    break;
                case "tag":
                    m && i(r, "MULTIPLE_TAGS", "A node can have at most one tag"), m = r, null === v && (v = r.offset), u = !1, c = !1, d = !0;
                    break;
                case n:
                    (h || m) && i(r, "BAD_PROP_ORDER", `Anchors and tags must be after the ${r.source} indicator`), y && i(r, "UNEXPECTED_TOKEN", `Unexpected ${r.source} in ${t || "collection"}`), y = r, u = !1, c = !1;
                    break;
                case "comma": if (t) {
                    g && i(r, "UNEXPECTED_TOKEN", `Unexpected , in ${t}`), g = r, u = !1, c = !1;
                    break;
                }
                default: i(r, "UNEXPECTED_TOKEN", `Unexpected ${r.type} token`), u = !1, c = !1;
            } const b = e[e.length - 1], D = b ? b.offset + b.source.length : o; return d && r && "space" !== r.type && "newline" !== r.type && "comma" !== r.type && ("scalar" !== r.type || "" !== r.source) && i(r.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"), { comma: g, found: y, spaceBefore: a, comment: l, hasNewline: f, anchor: h, tag: m, end: D, start: null != v ? v : D }; }
        function Os(e) { if (!e)
            return null; switch (e.type) {
            case "alias":
            case "scalar":
            case "double-quoted-scalar":
            case "single-quoted-scalar":
                if (e.source.includes("\n"))
                    return !0;
                if (e.end)
                    for (const t of e.end)
                        if ("newline" === t.type)
                            return !0;
                return !1;
            case "flow-collection":
                for (const t of e.items) {
                    for (const e of t.start)
                        if ("newline" === e.type)
                            return !0;
                    if (t.sep)
                        for (const e of t.sep)
                            if ("newline" === e.type)
                                return !0;
                    if (Os(t.key) || Os(t.value))
                        return !0;
                }
                return !1;
            default: return !0;
        } }
        function _s(e, t, n) { if ("flow-collection" === (null == t ? void 0 : t.type)) {
            const r = t.end[0];
            r.indent !== e || "]" !== r.source && "}" !== r.source || !Os(t) || n(r, "BAD_INDENT", "Flow end indicator should be more indented than parent", !0);
        } }
        function Ns(e, t, n) { const { uniqueKeys: r } = e.options; if (!1 === r)
            return !1; const o = "function" == typeof r ? r : (t, n) => t === n || vo(t) && vo(n) && t.value === n.value && !("<<" === t.value && e.schema.merge); return t.some((e => o(e.key, n))); }
        var Ps = "All mapping items must start at the same column";
        function Ms(e, t, n, r) { let o = ""; if (e) {
            let i = !1, s = "";
            for (const a of e) {
                const { source: e, type: u } = a;
                switch (u) {
                    case "space":
                        i = !0;
                        break;
                    case "comment": {
                        n && !i && r(a, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
                        const t = e.substring(1) || " ";
                        o ? o += s + t : o = t, s = "";
                        break;
                    }
                    case "newline":
                        o && (s += e), i = !0;
                        break;
                    default: r(a, "UNEXPECTED_TOKEN", `Unexpected ${u} at node end`);
                }
                t += e.length;
            }
        } return { comment: o, offset: t }; }
        var Rs = "Block collections are not allowed within flow collections", Is = e => e && ("block-map" === e.type || "block-seq" === e.type);
        function js(e, t, n) { const r = e.offset, o = function ({ offset: e, props: t }, n, r) { if ("block-scalar-header" !== t[0].type)
            return r(t[0], "IMPOSSIBLE", "Block scalar header not found"), null; const { source: o } = t[0], i = o[0]; let s = 0, a = "", u = -1; for (let t = 1; t < o.length; ++t) {
            const n = o[t];
            if (a || "-" !== n && "+" !== n) {
                const r = Number(n);
                !s && r ? s = r : -1 === u && (u = e + t);
            }
            else
                a = n;
        } -1 !== u && r(u, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${o}`); let c = !1, l = "", p = o.length; for (let e = 1; e < t.length; ++e) {
            const o = t[e];
            switch (o.type) {
                case "space": c = !0;
                case "newline":
                    p += o.source.length;
                    break;
                case "comment":
                    n && !c && r(o, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters"), p += o.source.length, l = o.source.substring(1);
                    break;
                case "error":
                    r(o, "UNEXPECTED_TOKEN", o.message), p += o.source.length;
                    break;
                default: {
                    r(o, "UNEXPECTED_TOKEN", `Unexpected token in block scalar header: ${o.type}`);
                    const e = o.source;
                    e && "string" == typeof e && (p += e.length);
                }
            }
        } return { mode: i, indent: s, chomp: a, comment: l, length: p }; }(e, t, n); if (!o)
            return { value: "", type: null, comment: "", range: [r, r, r] }; const i = ">" === o.mode ? Uo.BLOCK_FOLDED : Uo.BLOCK_LITERAL, s = e.source ? function (e) { const t = e.split(/\n( *)/), n = t[0], r = n.match(/^( *)/), o = [r && r[1] ? [r[1], n.slice(r[1].length)] : ["", n]]; for (let e = 1; e < t.length; e += 2)
            o.push([t[e], t[e + 1]]); return o; }(e.source) : []; let a = s.length; for (let e = s.length - 1; e >= 0; --e) {
            const t = s[e][1];
            if ("" !== t && "\r" !== t)
                break;
            a = e;
        } if (0 === a) {
            const t = "+" === o.chomp && s.length > 0 ? "\n".repeat(Math.max(1, s.length - 1)) : "";
            let n = r + o.length;
            return e.source && (n += e.source.length), { value: t, type: i, comment: o.comment, range: [r, n, n] };
        } let u = e.indent + o.indent, c = e.offset + o.length, l = 0; for (let e = 0; e < a; ++e) {
            const [t, r] = s[e];
            if ("" !== r && "\r" !== r) {
                if (t.length < u) {
                    const e = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
                    n(c + t.length, "MISSING_CHAR", e);
                }
                0 === o.indent && (u = t.length), l = e;
                break;
            }
            0 === o.indent && t.length > u && (u = t.length), c += t.length + r.length + 1;
        } for (let e = s.length - 1; e >= a; --e)
            s[e][0].length > u && (a = e + 1); let p = "", f = "", d = !1; for (let e = 0; e < l; ++e)
            p += s[e][0].slice(u) + "\n"; for (let e = l; e < a; ++e) {
            let [t, r] = s[e];
            c += t.length + r.length + 1;
            const a = "\r" === r[r.length - 1];
            if (a && (r = r.slice(0, -1)), r && t.length < u) {
                const e = "Block scalar lines must not be less indented than their " + (o.indent ? "explicit indentation indicator" : "first line");
                n(c - r.length - (a ? 2 : 1), "BAD_INDENT", e), t = "";
            }
            i === Uo.BLOCK_LITERAL ? (p += f + t.slice(u) + r, f = "\n") : t.length > u || "\t" === r[0] ? (" " === f ? f = "\n" : d || "\n" !== f || (f = "\n\n"), p += f + t.slice(u) + r, f = "\n", d = !0) : "" === r ? "\n" === f ? p += "\n" : f = "\n" : (p += f + r, f = " ", d = !1);
        } switch (o.chomp) {
            case "-": break;
            case "+":
                for (let e = a; e < s.length; ++e)
                    p += "\n" + s[e][0].slice(u);
                "\n" !== p[p.length - 1] && (p += "\n");
                break;
            default: p += "\n";
        } const h = r + o.length + e.source.length; return { value: p, type: i, comment: o.comment, range: [r, h, h] }; }
        function Bs(e, t, n) { const { offset: r, type: o, source: i, end: s } = e; let a, u; const c = (e, t, o) => n(r + e, t, o); switch (o) {
            case "scalar":
                a = Uo.PLAIN, u = function (e, t) { let n = ""; switch (e[0]) {
                    case "\t":
                        n = "a tab character";
                        break;
                    case ",":
                        n = "flow indicator character ,";
                        break;
                    case "%":
                        n = "directive indicator character %";
                        break;
                    case "|":
                    case ">":
                        n = `block scalar indicator ${e[0]}`;
                        break;
                    case "@":
                    case "`": n = `reserved character ${e[0]}`;
                } return n && t(0, "BAD_SCALAR_START", `Plain value cannot start with ${n}`), Ls(e); }(i, c);
                break;
            case "single-quoted-scalar":
                a = Uo.QUOTE_SINGLE, u = function (e, t) { return "'" === e[e.length - 1] && 1 !== e.length || t(e.length, "MISSING_CHAR", "Missing closing 'quote"), Ls(e.slice(1, -1)).replace(/''/g, "'"); }(i, c);
                break;
            case "double-quoted-scalar":
                a = Uo.QUOTE_DOUBLE, u = function (e, t) { let n = ""; for (let r = 1; r < e.length - 1; ++r) {
                    const o = e[r];
                    if ("\r" !== o || "\n" !== e[r + 1])
                        if ("\n" === o) {
                            const { fold: t, offset: o } = qs(e, r);
                            n += t, r = o;
                        }
                        else if ("\\" === o) {
                            let o = e[++r];
                            const i = $s[o];
                            if (i)
                                n += i;
                            else if ("\n" === o)
                                for (o = e[r + 1]; " " === o || "\t" === o;)
                                    o = e[1 + ++r];
                            else if ("\r" === o && "\n" === e[r + 1])
                                for (o = e[1 + ++r]; " " === o || "\t" === o;)
                                    o = e[1 + ++r];
                            else if ("x" === o || "u" === o || "U" === o) {
                                const i = { x: 2, u: 4, U: 8 }[o];
                                n += Us(e, r + 1, i, t), r += i;
                            }
                            else {
                                const o = e.substr(r - 1, 2);
                                t(r - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${o}`), n += o;
                            }
                        }
                        else if (" " === o || "\t" === o) {
                            const t = r;
                            let i = e[r + 1];
                            for (; " " === i || "\t" === i;)
                                i = e[1 + ++r];
                            "\n" === i || "\r" === i && "\n" === e[r + 2] || (n += r > t ? e.slice(t, r + 1) : o);
                        }
                        else
                            n += o;
                } return '"' === e[e.length - 1] && 1 !== e.length || t(e.length, "MISSING_CHAR", 'Missing closing "quote'), n; }(i, c);
                break;
            default: return n(e, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${o}`), { value: "", type: null, comment: "", range: [r, r + i.length, r + i.length] };
        } const l = r + i.length, p = Ms(s, l, t, n); return { value: u, type: a, comment: p.comment, range: [r, l, p.offset] }; }
        function Ls(e) { let t, n; try {
            t = new RegExp("(.*?)(?<![ \t])[ \t]*\r?\n", "sy"), n = new RegExp("[ \t]*(.*?)(?:(?<![ \t])[ \t]*)?\r?\n", "sy");
        }
        catch (e) {
            t = /(.*?)[ \t]*\r?\n/sy, n = /[ \t]*(.*?)[ \t]*\r?\n/sy;
        } let r = t.exec(e); if (!r)
            return e; let o = r[1], i = " ", s = t.lastIndex; for (n.lastIndex = s; r = n.exec(e);)
            "" === r[1] ? "\n" === i ? o += i : i = "\n" : (o += i + r[1], i = " "), s = n.lastIndex; const a = /[ \t]*(.*)/sy; return a.lastIndex = s, r = a.exec(e), o + i + (r && r[1] || ""); }
        function qs(e, t) { let n = "", r = e[t + 1]; for (; !(" " !== r && "\t" !== r && "\n" !== r && "\r" !== r || "\r" === r && "\n" !== e[t + 2]);)
            "\n" === r && (n += "\n"), r = e[(t += 1) + 1]; return n || (n = " "), { fold: n, offset: t }; }
        var $s = { 0: "\0", a: "", b: "\b", e: "", f: "\f", n: "\n", r: "\r", t: "\t", v: "\v", N: "", _: " ", L: "\u2028", P: "\u2029", " ": " ", '"': '"', "/": "/", "\\": "\\", "\t": "\t" };
        function Us(e, t, n, r) { const o = e.substr(t, n), i = o.length === n && /^[0-9a-fA-F]+$/.test(o) ? parseInt(o, 16) : NaN; if (isNaN(i)) {
            const o = e.substr(t - 2, n + 2);
            return r(t - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${o}`), o;
        } return String.fromCodePoint(i); }
        function Vs(e, t, n, r) { const { value: o, type: i, comment: s, range: a } = "block-scalar" === t.type ? js(t, e.options.strict, r) : Bs(t, e.options.strict, r), u = n ? e.directives.tagName(n.source, (e => r(n, "TAG_RESOLVE_FAILED", e))) : null, c = n && u ? function (e, t, n, r, o) { var i; if ("!" === n)
            return e[lo]; const s = []; for (const t of e.tags)
            if (!t.collection && t.tag === n) {
                if (!t.default || !t.test)
                    return t;
                s.push(t);
            } for (const e of s)
            if (null === (i = e.test) || void 0 === i ? void 0 : i.test(t))
                return e; const a = e.knownTags[n]; return a && !a.collection ? (e.tags.push(Object.assign({}, a, { default: !1, test: void 0 })), a) : (o(r, "TAG_RESOLVE_FAILED", `Unresolved tag: ${n}`, "tag:yaml.org,2002:str" !== n), e[lo]); }(e.schema, o, u, n, r) : "scalar" === t.type ? function ({ directives: e, schema: t }, n, r, o) { const i = t.tags.find((e => { var t; return e.default && (null === (t = e.test) || void 0 === t ? void 0 : t.test(n)); })) || t[lo]; if (t.compat) {
            const s = t.compat.find((e => { var t; return e.default && (null === (t = e.test) || void 0 === t ? void 0 : t.test(n)); })) || t[lo];
            i.tag !== s.tag && o(r, "TAG_RESOLVE_FAILED", `Value may be parsed as either ${e.tagString(i.tag)} or ${e.tagString(s.tag)}`, !0);
        } return i; }(e, o, t, r) : e.schema[lo]; let l; try {
            const i = c.resolve(o, (e => r(n || t, "TAG_RESOLVE_FAILED", e)), e.options);
            l = vo(i) ? i : new Uo(i);
        }
        catch (e) {
            const i = e instanceof Error ? e.message : String(e);
            r(n || t, "TAG_RESOLVE_FAILED", i), l = new Uo(o);
        } return l.range = a, l.source = o, i && (l.type = i), u && (l.tag = u), c.format && (l.format = c.format), s && (l.comment = s), l; }
        function Ws(e, t, n) { if (t) {
            null === n && (n = t.length);
            for (let r = n - 1; r >= 0; --r) {
                let n = t[r];
                switch (n.type) {
                    case "space":
                    case "comment":
                    case "newline":
                        e -= n.source.length;
                        continue;
                }
                for (n = t[++r]; "space" === (null == n ? void 0 : n.type);)
                    e += n.source.length, n = t[++r];
                break;
            }
        } return e; }
        var Ks = { composeNode: zs, composeEmptyNode: Hs };
        function zs(e, t, n, r) { const { spaceBefore: o, comment: i, anchor: s, tag: a } = n; let u, c = !0; switch (t.type) {
            case "alias":
                u = function ({ options: e }, { offset: t, source: n, end: r }, o) { const i = new Bo(n.substring(1)); "" === i.source && o(t, "BAD_ALIAS", "Alias cannot be an empty string"), i.source.endsWith(":") && o(t + n.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", !0); const s = t + n.length, a = Ms(r, s, e.strict, o); return i.range = [t, s, a.offset], a.comment && (i.comment = a.comment), i; }(e, t, r), (s || a) && r(t, "ALIAS_PROPS", "An alias node must not specify any properties");
                break;
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar":
            case "block-scalar":
                u = Vs(e, t, a, r), s && (u.anchor = s.source.substring(1));
                break;
            case "block-map":
            case "block-seq":
            case "flow-collection":
                u = function (e, t, n, r, o) { let i; switch (n.type) {
                    case "block-map":
                        i = function ({ composeNode: e, composeEmptyNode: t }, n, r, o) { var i; const s = new Ei(n.schema); n.atRoot && (n.atRoot = !1); let a = r.offset; for (const u of r.items) {
                            const { start: c, key: l, sep: p, value: f } = u, d = Fs(c, { indicator: "explicit-key-ind", next: l || (null == p ? void 0 : p[0]), offset: a, onError: o, startOnNewline: !0 }), h = !d.found;
                            if (h) {
                                if (l && ("block-seq" === l.type ? o(a, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key") : "indent" in l && l.indent !== r.indent && o(a, "BAD_INDENT", Ps)), !d.anchor && !d.tag && !p) {
                                    d.comment && (s.comment ? s.comment += "\n" + d.comment : s.comment = d.comment);
                                    continue;
                                }
                            }
                            else
                                (null === (i = d.found) || void 0 === i ? void 0 : i.indent) !== r.indent && o(a, "BAD_INDENT", Ps);
                            h && Os(l) && o(l, "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
                            const m = d.end, g = l ? e(n, l, d, o) : t(n, m, c, null, d, o);
                            n.schema.compat && _s(r.indent, l, o), Ns(n, s.items, g) && o(m, "DUPLICATE_KEY", "Map keys must be unique");
                            const y = Fs(p || [], { indicator: "map-value-ind", next: f, offset: g.range[2], onError: o, startOnNewline: !l || "block-scalar" === l.type });
                            if (a = y.end, y.found) {
                                h && ("block-map" !== (null == f ? void 0 : f.type) || y.hasNewline || o(a, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings"), n.options.strict && d.start < y.found.offset - 1024 && o(g.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key"));
                                const i = f ? e(n, f, y, o) : t(n, a, p, null, y, o);
                                n.schema.compat && _s(r.indent, f, o), a = i.range[2];
                                const c = new mi(g, i);
                                n.options.keepSourceTokens && (c.srcToken = u), s.items.push(c);
                            }
                            else {
                                h && o(g.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values"), y.comment && (g.comment ? g.comment += "\n" + y.comment : g.comment = y.comment);
                                const e = new mi(g);
                                n.options.keepSourceTokens && (e.srcToken = u), s.items.push(e);
                            }
                        } return s.range = [r.offset, a, a], s; }(e, t, n, o);
                        break;
                    case "block-seq":
                        i = function ({ composeNode: e, composeEmptyNode: t }, n, r, o) { const i = new wi(n.schema); n.atRoot && (n.atRoot = !1); let s = r.offset; for (const { start: a, value: u } of r.items) {
                            const c = Fs(a, { indicator: "seq-item-ind", next: u, offset: s, onError: o, startOnNewline: !0 });
                            if (s = c.end, !c.found) {
                                if (!(c.anchor || c.tag || u)) {
                                    c.comment && (i.comment = c.comment);
                                    continue;
                                }
                                u && "block-seq" === u.type ? o(s, "BAD_INDENT", "All sequence items must start at the same column") : o(s, "MISSING_CHAR", "Sequence item without - indicator");
                            }
                            const l = u ? e(n, u, c, o) : t(n, s, a, null, c, o);
                            n.schema.compat && _s(r.indent, u, o), s = l.range[2], i.items.push(l);
                        } return i.range = [r.offset, s, s], i; }(e, t, n, o);
                        break;
                    case "flow-collection": i = function ({ composeNode: e, composeEmptyNode: t }, n, r, o) { const i = "{" === r.start.source, s = i ? "flow map" : "flow sequence", a = i ? new Ei(n.schema) : new wi(n.schema); a.flow = !0; const u = n.atRoot; u && (n.atRoot = !1); let c = r.offset + r.start.source.length; for (let u = 0; u < r.items.length; ++u) {
                        const l = r.items[u], { start: p, key: f, sep: d, value: h } = l, m = Fs(p, { flow: s, indicator: "explicit-key-ind", next: f || (null == d ? void 0 : d[0]), offset: c, onError: o, startOnNewline: !1 });
                        if (!m.found) {
                            if (!(m.anchor || m.tag || d || h)) {
                                0 === u && m.comma ? o(m.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${s}`) : u < r.items.length - 1 && o(m.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${s}`), m.comment && (a.comment ? a.comment += "\n" + m.comment : a.comment = m.comment), c = m.end;
                                continue;
                            }
                            !i && n.options.strict && Os(f) && o(f, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                        }
                        if (0 === u)
                            m.comma && o(m.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${s}`);
                        else if (m.comma || o(m.start, "MISSING_CHAR", `Missing , between ${s} items`), m.comment) {
                            let e = "";
                            e: for (const t of p)
                                switch (t.type) {
                                    case "comma":
                                    case "space": break;
                                    case "comment":
                                        e = t.source.substring(1);
                                        break e;
                                    default: break e;
                                }
                            if (e) {
                                let t = a.items[a.items.length - 1];
                                yo(t) && (t = t.value || t.key), t.comment ? t.comment += "\n" + e : t.comment = e, m.comment = m.comment.substring(e.length + 1);
                            }
                        }
                        if (i || d || m.found) {
                            const r = m.end, u = f ? e(n, f, m, o) : t(n, r, p, null, m, o);
                            Is(f) && o(u.range, "BLOCK_IN_FLOW", Rs);
                            const g = Fs(d || [], { flow: s, indicator: "map-value-ind", next: h, offset: u.range[2], onError: o, startOnNewline: !1 });
                            if (g.found) {
                                if (!i && !m.found && n.options.strict) {
                                    if (d)
                                        for (const e of d) {
                                            if (e === g.found)
                                                break;
                                            if ("newline" === e.type) {
                                                o(e, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                                                break;
                                            }
                                        }
                                    m.start < g.found.offset - 1024 && o(g.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
                                }
                            }
                            else
                                h && ("source" in h && h.source && ":" === h.source[0] ? o(h, "MISSING_CHAR", `Missing space after : in ${s}`) : o(g.start, "MISSING_CHAR", `Missing , or : between ${s} items`));
                            const y = h ? e(n, h, g, o) : g.found ? t(n, g.end, d, null, g, o) : null;
                            y ? Is(h) && o(y.range, "BLOCK_IN_FLOW", Rs) : g.comment && (u.comment ? u.comment += "\n" + g.comment : u.comment = g.comment);
                            const v = new mi(u, y);
                            if (n.options.keepSourceTokens && (v.srcToken = l), i) {
                                const e = a;
                                Ns(n, e.items, u) && o(r, "DUPLICATE_KEY", "Map keys must be unique"), e.items.push(v);
                            }
                            else {
                                const e = new Ei(n.schema);
                                e.flow = !0, e.items.push(v), a.items.push(e);
                            }
                            c = y ? y.range[2] : g.end;
                        }
                        else {
                            const r = h ? e(n, h, m, o) : t(n, m.end, d, null, m, o);
                            a.items.push(r), c = r.range[2], Is(h) && o(r.range, "BLOCK_IN_FLOW", Rs);
                        }
                    } const l = i ? "}" : "]", [p, ...f] = r.end; let d = c; if (p && p.source === l)
                        d = p.offset + p.source.length;
                    else {
                        const e = s[0].toUpperCase() + s.substring(1);
                        o(c, u ? "MISSING_CHAR" : "BAD_INDENT", u ? `${e} must end with a ${l}` : `${e} in block collection must be sufficiently indented and end with a ${l}`), p && 1 !== p.source.length && f.unshift(p);
                    } if (f.length > 0) {
                        const e = Ms(f, d, n.options.strict, o);
                        e.comment && (a.comment ? a.comment += "\n" + e.comment : a.comment = e.comment), a.range = [r.offset, d, e.offset];
                    }
                    else
                        a.range = [r.offset, d, d]; return a; }(e, t, n, o);
                } if (!r)
                    return i; const s = t.directives.tagName(r.source, (e => o(r, "TAG_RESOLVE_FAILED", e))); if (!s)
                    return i; const a = i.constructor; if ("!" === s || s === a.tagName)
                    return i.tag = a.tagName, i; const u = go(i) ? "map" : "seq"; let c = t.schema.tags.find((e => e.collection === u && e.tag === s)); if (!c) {
                    const e = t.schema.knownTags[s];
                    if (!e || e.collection !== u)
                        return o(r, "TAG_RESOLVE_FAILED", `Unresolved tag: ${s}`, !0), i.tag = s, i;
                    t.schema.tags.push(Object.assign({}, e, { default: !1 })), c = e;
                } const l = c.resolve(i, (e => o(r, "TAG_RESOLVE_FAILED", e)), t.options), p = Eo(l) ? l : new Uo(l); return p.range = i.range, p.tag = s, (null == c ? void 0 : c.format) && (p.format = c.format), p; }(Ks, e, t, a, r), s && (u.anchor = s.source.substring(1));
                break;
            default: r(t, "UNEXPECTED_TOKEN", "error" === t.type ? t.message : `Unsupported token (type: ${t.type})`), u = Hs(e, t.offset, void 0, null, n, r), c = !1;
        } return s && "" === u.anchor && r(s, "BAD_ALIAS", "Anchor cannot be an empty string"), o && (u.spaceBefore = !0), i && ("scalar" === t.type && "" === t.source ? u.comment = i : u.commentBefore = i), e.options.keepSourceTokens && c && (u.srcToken = t), u; }
        function Hs(e, t, n, r, { spaceBefore: o, comment: i, anchor: s, tag: a }, u) { const c = Vs(e, { type: "scalar", offset: Ws(t, n, r), indent: -1, source: "" }, a, u); return s && (c.anchor = s.source.substring(1), "" === c.anchor && u(s, "BAD_ALIAS", "Anchor cannot be an empty string")), o && (c.spaceBefore = !0), i && (c.comment = i), c; }
        function Ys(e) { if ("number" == typeof e)
            return [e, e + 1]; if (Array.isArray(e))
            return 2 === e.length ? e : [e[0], e[1]]; const { offset: t, source: n } = e; return [t, t + ("string" == typeof n ? n.length : 1)]; }
        function Js(e) { var t; let n = "", r = !1, o = !1; for (let i = 0; i < e.length; ++i) {
            const s = e[i];
            switch (s[0]) {
                case "#":
                    n += ("" === n ? "" : o ? "\n\n" : "\n") + (s.substring(1) || " "), r = !0, o = !1;
                    break;
                case "%":
                    "#" !== (null === (t = e[i + 1]) || void 0 === t ? void 0 : t[0]) && (i += 1), r = !1;
                    break;
                default: r || (o = !0), r = !1;
            }
        } return { comment: n, afterEmptyLine: o }; }
        var Gs = class {
            constructor(e = {}) { this.doc = null, this.atDirectives = !1, this.prelude = [], this.errors = [], this.warnings = [], this.onError = (e, t, n, r) => { const o = Ys(e); r ? this.warnings.push(new Ts(o, t, n)) : this.errors.push(new xs(o, t, n)); }, this.directives = new Mo({ version: e.version || "1.2" }), this.options = e; }
            decorate(e, t) { const { comment: n, afterEmptyLine: r } = Js(this.prelude); if (n) {
                const o = e.contents;
                if (t)
                    e.comment = e.comment ? `${e.comment}\n${n}` : n;
                else if (r || e.directives.docStart || !o)
                    e.commentBefore = n;
                else if (Do(o) && !o.flow && o.items.length > 0) {
                    let e = o.items[0];
                    yo(e) && (e = e.key);
                    const t = e.commentBefore;
                    e.commentBefore = t ? `${n}\n${t}` : n;
                }
                else {
                    const e = o.commentBefore;
                    o.commentBefore = e ? `${n}\n${e}` : n;
                }
            } t ? (Array.prototype.push.apply(e.errors, this.errors), Array.prototype.push.apply(e.warnings, this.warnings)) : (e.errors = this.errors, e.warnings = this.warnings), this.prelude = [], this.errors = [], this.warnings = []; }
            streamInfo() { return { comment: Js(this.prelude).comment, directives: this.directives, errors: this.errors, warnings: this.warnings }; }
            *compose(e, t = !1, n = -1) { for (const t of e)
                yield* this.next(t); yield* this.end(t, n); }
            *next(e) { switch (e.type) {
                case "directive":
                    this.directives.add(e.source, ((t, n, r) => { const o = Ys(e); o[0] += t, this.onError(o, "BAD_DIRECTIVE", n, r); })), this.prelude.push(e.source), this.atDirectives = !0;
                    break;
                case "document": {
                    const t = function (e, t, { offset: n, start: r, value: o, end: i }, s) { const a = Object.assign({ directives: t }, e), u = new ws(void 0, a), c = { atRoot: !0, directives: u.directives, options: u.options, schema: u.schema }, l = Fs(r, { indicator: "doc-start", next: o || (null == i ? void 0 : i[0]), offset: n, onError: s, startOnNewline: !0 }); l.found && (u.directives.docStart = !0, !o || "block-map" !== o.type && "block-seq" !== o.type || l.hasNewline || s(l.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker")), u.contents = o ? zs(c, o, l, s) : Hs(c, l.end, r, null, l, s); const p = u.contents.range[2], f = Ms(i, p, !1, s); return f.comment && (u.comment = f.comment), u.range = [n, p, f.offset], u; }(this.options, this.directives, e, this.onError);
                    this.atDirectives && !t.directives.docStart && this.onError(e, "MISSING_CHAR", "Missing directives-end/doc-start indicator line"), this.decorate(t, !1), this.doc && (yield this.doc), this.doc = t, this.atDirectives = !1;
                    break;
                }
                case "byte-order-mark":
                case "space": break;
                case "comment":
                case "newline":
                    this.prelude.push(e.source);
                    break;
                case "error": {
                    const t = e.source ? `${e.message}: ${JSON.stringify(e.source)}` : e.message, n = new xs(Ys(e), "UNEXPECTED_TOKEN", t);
                    this.atDirectives || !this.doc ? this.errors.push(n) : this.doc.errors.push(n);
                    break;
                }
                case "doc-end": {
                    if (!this.doc) {
                        const t = "Unexpected doc-end without preceding document";
                        this.errors.push(new xs(Ys(e), "UNEXPECTED_TOKEN", t));
                        break;
                    }
                    this.doc.directives.docEnd = !0;
                    const t = Ms(e.end, e.offset + e.source.length, this.doc.options.strict, this.onError);
                    if (this.decorate(this.doc, !0), t.comment) {
                        const e = this.doc.comment;
                        this.doc.comment = e ? `${e}\n${t.comment}` : t.comment;
                    }
                    this.doc.range[2] = t.offset;
                    break;
                }
                default: this.errors.push(new xs(Ys(e), "UNEXPECTED_TOKEN", `Unsupported token ${e.type}`));
            } }
            *end(e = !1, t = -1) { if (this.doc)
                this.decorate(this.doc, !0), yield this.doc, this.doc = null;
            else if (e) {
                const e = Object.assign({ directives: this.directives }, this.options), n = new ws(void 0, e);
                this.atDirectives && this.onError(t, "MISSING_CHAR", "Missing directives-end indicator line"), n.range = [0, t, t], this.decorate(n, !1), yield n;
            } }
        }, Xs = {};
        function Qs(e, t = !0, n) { if (e) {
            const r = (e, t, r) => { const o = "number" == typeof e ? e : Array.isArray(e) ? e[0] : e.offset; if (!n)
                throw new xs([o, o + 1], t, r); n(o, t, r); };
            switch (e.type) {
                case "scalar":
                case "single-quoted-scalar":
                case "double-quoted-scalar": return Bs(e, t, r);
                case "block-scalar": return js(e, t, r);
            }
        } return null; }
        function Zs(e, t) { var n; const { implicitKey: r = !1, indent: o, inFlow: i = !1, offset: s = -1, type: a = "PLAIN" } = t, u = ai({ type: a, value: e }, { implicitKey: r, indent: o > 0 ? " ".repeat(o) : "", inFlow: i, options: { blockQuote: !0, lineWidth: -1 } }), c = null !== (n = t.end) && void 0 !== n ? n : [{ type: "newline", offset: -1, indent: o, source: "\n" }]; switch (u[0]) {
            case "|":
            case ">": {
                const e = u.indexOf("\n"), t = u.substring(0, e), n = u.substring(e + 1) + "\n", r = [{ type: "block-scalar-header", offset: s, indent: o, source: t }];
                return ta(r, c) || r.push({ type: "newline", offset: -1, indent: o, source: "\n" }), { type: "block-scalar", offset: s, indent: o, props: r, source: n };
            }
            case '"': return { type: "double-quoted-scalar", offset: s, indent: o, source: u, end: c };
            case "'": return { type: "single-quoted-scalar", offset: s, indent: o, source: u, end: c };
            default: return { type: "scalar", offset: s, indent: o, source: u, end: c };
        } }
        function ea(e, t, n = {}) { let { afterKey: r = !1, implicitKey: o = !1, inFlow: i = !1, type: s } = n, a = "indent" in e ? e.indent : null; if (r && "number" == typeof a && (a += 2), !s)
            switch (e.type) {
                case "single-quoted-scalar":
                    s = "QUOTE_SINGLE";
                    break;
                case "double-quoted-scalar":
                    s = "QUOTE_DOUBLE";
                    break;
                case "block-scalar": {
                    const t = e.props[0];
                    if ("block-scalar-header" !== t.type)
                        throw new Error("Invalid block scalar header");
                    s = ">" === t.source[0] ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
                    break;
                }
                default: s = "PLAIN";
            } const u = ai({ type: s, value: t }, { implicitKey: o || null === a, indent: null !== a && a > 0 ? " ".repeat(a) : "", inFlow: i, options: { blockQuote: !0, lineWidth: -1 } }); switch (u[0]) {
            case "|":
            case ">":
                !function (e, t) { const n = t.indexOf("\n"), r = t.substring(0, n), o = t.substring(n + 1) + "\n"; if ("block-scalar" === e.type) {
                    const t = e.props[0];
                    if ("block-scalar-header" !== t.type)
                        throw new Error("Invalid block scalar header");
                    t.source = r, e.source = o;
                }
                else {
                    const { offset: t } = e, n = "indent" in e ? e.indent : -1, i = [{ type: "block-scalar-header", offset: t, indent: n, source: r }];
                    ta(i, "end" in e ? e.end : void 0) || i.push({ type: "newline", offset: -1, indent: n, source: "\n" });
                    for (const t of Object.keys(e))
                        "type" !== t && "offset" !== t && delete e[t];
                    Object.assign(e, { type: "block-scalar", indent: n, props: i, source: o });
                } }(e, u);
                break;
            case '"':
                na(e, u, "double-quoted-scalar");
                break;
            case "'":
                na(e, u, "single-quoted-scalar");
                break;
            default: na(e, u, "scalar");
        } }
        function ta(e, t) { if (t)
            for (const n of t)
                switch (n.type) {
                    case "space":
                    case "comment":
                        e.push(n);
                        break;
                    case "newline": return e.push(n), !0;
                } return !1; }
        function na(e, t, n) { switch (e.type) {
            case "scalar":
            case "double-quoted-scalar":
            case "single-quoted-scalar":
                e.type = n, e.source = t;
                break;
            case "block-scalar": {
                const r = e.props.slice(1);
                let o = t.length;
                "block-scalar-header" === e.props[0].type && (o -= e.props[0].source.length);
                for (const e of r)
                    e.offset += o;
                delete e.props, Object.assign(e, { type: n, source: t, end: r });
                break;
            }
            case "block-map":
            case "block-seq": {
                const r = { type: "newline", offset: e.offset + t.length, indent: e.indent, source: "\n" };
                delete e.items, Object.assign(e, { type: n, source: t, end: [r] });
                break;
            }
            default: {
                const r = "indent" in e ? e.indent : -1, o = "end" in e && Array.isArray(e.end) ? e.end.filter((e => "space" === e.type || "comment" === e.type || "newline" === e.type)) : [];
                for (const t of Object.keys(e))
                    "type" !== t && "offset" !== t && delete e[t];
                Object.assign(e, { type: n, indent: r, source: t, end: o });
            }
        } }
        ((e, t) => { for (var n in t)
            d(e, n, { get: t[n], enumerable: !0 }); })(Xs, { BOM: () => pa, DOCUMENT: () => fa, FLOW_END: () => da, SCALAR: () => ha, createScalarToken: () => Zs, isCollection: () => ma, isScalar: () => ga, prettyToken: () => ya, resolveAsScalar: () => Qs, setScalarValue: () => ea, stringify: () => ra, tokenType: () => va, visit: () => ca });
        var ra = e => "type" in e ? oa(e) : ia(e);
        function oa(e) { switch (e.type) {
            case "block-scalar": {
                let t = "";
                for (const n of e.props)
                    t += oa(n);
                return t + e.source;
            }
            case "block-map":
            case "block-seq": {
                let t = "";
                for (const n of e.items)
                    t += ia(n);
                return t;
            }
            case "flow-collection": {
                let t = e.start.source;
                for (const n of e.items)
                    t += ia(n);
                for (const n of e.end)
                    t += n.source;
                return t;
            }
            case "document": {
                let t = ia(e);
                if (e.end)
                    for (const n of e.end)
                        t += n.source;
                return t;
            }
            default: {
                let t = e.source;
                if ("end" in e && e.end)
                    for (const n of e.end)
                        t += n.source;
                return t;
            }
        } }
        function ia({ start: e, key: t, sep: n, value: r }) { let o = ""; for (const t of e)
            o += t.source; if (t && (o += oa(t)), n)
            for (const e of n)
                o += e.source; return r && (o += oa(r)), o; }
        var sa = Symbol("break visit"), aa = Symbol("skip children"), ua = Symbol("remove item");
        function ca(e, t) { "type" in e && "document" === e.type && (e = { start: e.start, value: e.value }), la(Object.freeze([]), e, t); }
        function la(e, t, n) { let r = n(t, e); if ("symbol" == typeof r)
            return r; for (const o of ["key", "value"]) {
            const i = t[o];
            if (i && "items" in i) {
                for (let t = 0; t < i.items.length; ++t) {
                    const r = la(Object.freeze(e.concat([[o, t]])), i.items[t], n);
                    if ("number" == typeof r)
                        t = r - 1;
                    else {
                        if (r === sa)
                            return sa;
                        r === ua && (i.items.splice(t, 1), t -= 1);
                    }
                }
                "function" == typeof r && "key" === o && (r = r(t, e));
            }
        } return "function" == typeof r ? r(t, e) : r; }
        ca.BREAK = sa, ca.SKIP = aa, ca.REMOVE = ua, ca.itemAtPath = (e, t) => { let n = e; for (const [e, r] of t) {
            const t = n && n[e];
            if (!t || !("items" in t))
                return;
            n = t.items[r];
        } return n; }, ca.parentCollection = (e, t) => { const n = ca.itemAtPath(e, t.slice(0, -1)), r = t[t.length - 1][0], o = n && n[r]; if (o && "items" in o)
            return o; throw new Error("Parent collection not found"); };
        var pa = "\ufeff", fa = "", da = "", ha = "", ma = e => !!e && "items" in e, ga = e => !!e && ("scalar" === e.type || "single-quoted-scalar" === e.type || "double-quoted-scalar" === e.type || "block-scalar" === e.type);
        function ya(e) { switch (e) {
            case pa: return "<BOM>";
            case fa: return "<DOC>";
            case da: return "<FLOW_END>";
            case ha: return "<SCALAR>";
            default: return JSON.stringify(e);
        } }
        function va(e) { switch (e) {
            case pa: return "byte-order-mark";
            case fa: return "doc-mode";
            case da: return "flow-error-end";
            case ha: return "scalar";
            case "---": return "doc-start";
            case "...": return "doc-end";
            case "":
            case "\n":
            case "\r\n": return "newline";
            case "-": return "seq-item-ind";
            case "?": return "explicit-key-ind";
            case ":": return "map-value-ind";
            case "{": return "flow-map-start";
            case "}": return "flow-map-end";
            case "[": return "flow-seq-start";
            case "]": return "flow-seq-end";
            case ",": return "comma";
        } switch (e[0]) {
            case " ":
            case "\t": return "space";
            case "#": return "comment";
            case "%": return "directive-line";
            case "*": return "alias";
            case "&": return "anchor";
            case "!": return "tag";
            case "'": return "single-quoted-scalar";
            case '"': return "double-quoted-scalar";
            case "|":
            case ">": return "block-scalar-header";
        } return null; }
        function ba(e) { switch (e) {
            case void 0:
            case " ":
            case "\n":
            case "\r":
            case "\t": return !0;
            default: return !1;
        } }
        var Da = "0123456789ABCDEFabcdef".split(""), Ea = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split(""), Ca = ",[]{}".split(""), wa = " ,[]{}\n\r\t".split(""), Aa = e => !e || wa.includes(e), Sa = class {
            constructor() { this.lineStarts = [], this.addNewLine = e => this.lineStarts.push(e), this.linePos = e => { let t = 0, n = this.lineStarts.length; for (; t < n;) {
                const r = t + n >> 1;
                this.lineStarts[r] < e ? t = r + 1 : n = r;
            } return this.lineStarts[t] === e ? { line: t + 1, col: 1 } : 0 === t ? { line: 0, col: e } : { line: t, col: e - this.lineStarts[t - 1] + 1 }; }; }
        };
        function xa(e, t) { for (let n = 0; n < e.length; ++n)
            if (e[n].type === t)
                return !0; return !1; }
        function Ta(e) { for (let t = 0; t < e.length; ++t)
            switch (e[t].type) {
                case "space":
                case "comment":
                case "newline": break;
                default: return !0;
            } return !1; }
        function ka(e) { switch (null == e ? void 0 : e.type) {
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar":
            case "flow-collection": return !0;
            default: return !1;
        } }
        function Fa(e) { switch (e.type) {
            case "document": return e.start;
            case "block-map": {
                const t = e.items[e.items.length - 1];
                return t.sep || t.start;
            }
            case "block-seq": return e.items[e.items.length - 1].start;
            default: return [];
        } }
        function Oa(e) { var t; if (0 === e.length)
            return []; let n = e.length; e: for (; --n >= 0;)
            switch (e[n].type) {
                case "doc-start":
                case "explicit-key-ind":
                case "map-value-ind":
                case "seq-item-ind":
                case "newline": break e;
            } for (; "space" === (null === (t = e[++n]) || void 0 === t ? void 0 : t.type);)
            ; return e.splice(n, e.length); }
        function _a(e) { if ("flow-seq-start" === e.start.type)
            for (const t of e.items)
                !t.sep || t.value || xa(t.start, "explicit-key-ind") || xa(t.sep, "map-value-ind") || (t.key && (t.value = t.key), delete t.key, ka(t.value) ? t.value.end ? Array.prototype.push.apply(t.value.end, t.sep) : t.value.end = t.sep : Array.prototype.push.apply(t.start, t.sep), delete t.sep); }
        var Na = class {
            constructor(e) { this.atNewLine = !0, this.atScalar = !1, this.indent = 0, this.offset = 0, this.onKeyLine = !1, this.stack = [], this.source = "", this.type = "", this.lexer = new class {
                constructor() { this.atEnd = !1, this.blockScalarIndent = -1, this.blockScalarKeep = !1, this.buffer = "", this.flowKey = !1, this.flowLevel = 0, this.indentNext = 0, this.indentValue = 0, this.lineEndPos = null, this.next = null, this.pos = 0; }
                *lex(e, t = !1) { e && (this.buffer = this.buffer ? this.buffer + e : e, this.lineEndPos = null), this.atEnd = !t; let n = this.next || "stream"; for (; n && (t || this.hasChars(1));)
                    n = yield* this.parseNext(n); }
                atLineEnd() { let e = this.pos, t = this.buffer[e]; for (; " " === t || "\t" === t;)
                    t = this.buffer[++e]; return !t || "#" === t || "\n" === t || "\r" === t && "\n" === this.buffer[e + 1]; }
                charAt(e) { return this.buffer[this.pos + e]; }
                continueScalar(e) { let t = this.buffer[e]; if (this.indentNext > 0) {
                    let n = 0;
                    for (; " " === t;)
                        t = this.buffer[++n + e];
                    if ("\r" === t) {
                        const t = this.buffer[n + e + 1];
                        if ("\n" === t || !t && !this.atEnd)
                            return e + n + 1;
                    }
                    return "\n" === t || n >= this.indentNext || !t && !this.atEnd ? e + n : -1;
                } if ("-" === t || "." === t) {
                    const t = this.buffer.substr(e, 3);
                    if (("---" === t || "..." === t) && ba(this.buffer[e + 3]))
                        return -1;
                } return e; }
                getLine() { let e = this.lineEndPos; return ("number" != typeof e || -1 !== e && e < this.pos) && (e = this.buffer.indexOf("\n", this.pos), this.lineEndPos = e), -1 === e ? this.atEnd ? this.buffer.substring(this.pos) : null : ("\r" === this.buffer[e - 1] && (e -= 1), this.buffer.substring(this.pos, e)); }
                hasChars(e) { return this.pos + e <= this.buffer.length; }
                setNext(e) { return this.buffer = this.buffer.substring(this.pos), this.pos = 0, this.lineEndPos = null, this.next = e, null; }
                peek(e) { return this.buffer.substr(this.pos, e); }
                *parseNext(e) { switch (e) {
                    case "stream": return yield* this.parseStream();
                    case "line-start": return yield* this.parseLineStart();
                    case "block-start": return yield* this.parseBlockStart();
                    case "doc": return yield* this.parseDocument();
                    case "flow": return yield* this.parseFlowCollection();
                    case "quoted-scalar": return yield* this.parseQuotedScalar();
                    case "block-scalar": return yield* this.parseBlockScalar();
                    case "plain-scalar": return yield* this.parsePlainScalar();
                } }
                *parseStream() { let e = this.getLine(); if (null === e)
                    return this.setNext("stream"); if (e[0] === pa && (yield* this.pushCount(1), e = e.substring(1)), "%" === e[0]) {
                    let t = e.length;
                    const n = e.indexOf("#");
                    if (-1 !== n) {
                        const r = e[n - 1];
                        " " !== r && "\t" !== r || (t = n - 1);
                    }
                    for (;;) {
                        const n = e[t - 1];
                        if (" " !== n && "\t" !== n)
                            break;
                        t -= 1;
                    }
                    const r = (yield* this.pushCount(t)) + (yield* this.pushSpaces(!0));
                    return yield* this.pushCount(e.length - r), this.pushNewline(), "stream";
                } if (this.atLineEnd()) {
                    const t = yield* this.pushSpaces(!0);
                    return yield* this.pushCount(e.length - t), yield* this.pushNewline(), "stream";
                } return yield fa, yield* this.parseLineStart(); }
                *parseLineStart() { const e = this.charAt(0); if (!e && !this.atEnd)
                    return this.setNext("line-start"); if ("-" === e || "." === e) {
                    if (!this.atEnd && !this.hasChars(4))
                        return this.setNext("line-start");
                    const e = this.peek(3);
                    if ("---" === e && ba(this.charAt(3)))
                        return yield* this.pushCount(3), this.indentValue = 0, this.indentNext = 0, "doc";
                    if ("..." === e && ba(this.charAt(3)))
                        return yield* this.pushCount(3), "stream";
                } return this.indentValue = yield* this.pushSpaces(!1), this.indentNext > this.indentValue && !ba(this.charAt(1)) && (this.indentNext = this.indentValue), yield* this.parseBlockStart(); }
                *parseBlockStart() { const [e, t] = this.peek(2); if (!t && !this.atEnd)
                    return this.setNext("block-start"); if (("-" === e || "?" === e || ":" === e) && ba(t)) {
                    const e = (yield* this.pushCount(1)) + (yield* this.pushSpaces(!0));
                    return this.indentNext = this.indentValue + 1, this.indentValue += e, yield* this.parseBlockStart();
                } return "doc"; }
                *parseDocument() { yield* this.pushSpaces(!0); const e = this.getLine(); if (null === e)
                    return this.setNext("doc"); let t = yield* this.pushIndicators(); switch (e[t]) {
                    case "#": yield* this.pushCount(e.length - t);
                    case void 0: return yield* this.pushNewline(), yield* this.parseLineStart();
                    case "{":
                    case "[": return yield* this.pushCount(1), this.flowKey = !1, this.flowLevel = 1, "flow";
                    case "}":
                    case "]": return yield* this.pushCount(1), "doc";
                    case "*": return yield* this.pushUntil(Aa), "doc";
                    case '"':
                    case "'": return yield* this.parseQuotedScalar();
                    case "|":
                    case ">": return t += (yield* this.parseBlockScalarHeader()), t += (yield* this.pushSpaces(!0)), yield* this.pushCount(e.length - t), yield* this.pushNewline(), yield* this.parseBlockScalar();
                    default: return yield* this.parsePlainScalar();
                } }
                *parseFlowCollection() { let e, t, n = -1; do {
                    e = yield* this.pushNewline(), e > 0 ? (t = yield* this.pushSpaces(!1), this.indentValue = n = t) : t = 0, t += (yield* this.pushSpaces(!0));
                } while (e + t > 0); const r = this.getLine(); if (null === r)
                    return this.setNext("flow"); if ((-1 !== n && n < this.indentNext && "#" !== r[0] || 0 === n && (r.startsWith("---") || r.startsWith("...")) && ba(r[3])) && (n !== this.indentNext - 1 || 1 !== this.flowLevel || "]" !== r[0] && "}" !== r[0]))
                    return this.flowLevel = 0, yield da, yield* this.parseLineStart(); let o = 0; for (; "," === r[o];)
                    o += (yield* this.pushCount(1)), o += (yield* this.pushSpaces(!0)), this.flowKey = !1; switch (o += (yield* this.pushIndicators()), r[o]) {
                    case void 0: return "flow";
                    case "#": return yield* this.pushCount(r.length - o), "flow";
                    case "{":
                    case "[": return yield* this.pushCount(1), this.flowKey = !1, this.flowLevel += 1, "flow";
                    case "}":
                    case "]": return yield* this.pushCount(1), this.flowKey = !0, this.flowLevel -= 1, this.flowLevel ? "flow" : "doc";
                    case "*": return yield* this.pushUntil(Aa), "flow";
                    case '"':
                    case "'": return this.flowKey = !0, yield* this.parseQuotedScalar();
                    case ":": {
                        const e = this.charAt(1);
                        if (this.flowKey || ba(e) || "," === e)
                            return this.flowKey = !1, yield* this.pushCount(1), yield* this.pushSpaces(!0), "flow";
                    }
                    default: return this.flowKey = !1, yield* this.parsePlainScalar();
                } }
                *parseQuotedScalar() { const e = this.charAt(0); let t = this.buffer.indexOf(e, this.pos + 1); if ("'" === e)
                    for (; -1 !== t && "'" === this.buffer[t + 1];)
                        t = this.buffer.indexOf("'", t + 2);
                else
                    for (; -1 !== t;) {
                        let e = 0;
                        for (; "\\" === this.buffer[t - 1 - e];)
                            e += 1;
                        if (e % 2 == 0)
                            break;
                        t = this.buffer.indexOf('"', t + 1);
                    } const n = this.buffer.substring(0, t); let r = n.indexOf("\n", this.pos); if (-1 !== r) {
                    for (; -1 !== r;) {
                        const e = this.continueScalar(r + 1);
                        if (-1 === e)
                            break;
                        r = n.indexOf("\n", e);
                    }
                    -1 !== r && (t = r - ("\r" === n[r - 1] ? 2 : 1));
                } if (-1 === t) {
                    if (!this.atEnd)
                        return this.setNext("quoted-scalar");
                    t = this.buffer.length;
                } return yield* this.pushToIndex(t + 1, !1), this.flowLevel ? "flow" : "doc"; }
                *parseBlockScalarHeader() { this.blockScalarIndent = -1, this.blockScalarKeep = !1; let e = this.pos; for (;;) {
                    const t = this.buffer[++e];
                    if ("+" === t)
                        this.blockScalarKeep = !0;
                    else if (t > "0" && t <= "9")
                        this.blockScalarIndent = Number(t) - 1;
                    else if ("-" !== t)
                        break;
                } return yield* this.pushUntil((e => ba(e) || "#" === e)); }
                *parseBlockScalar() { let e, t = this.pos - 1, n = 0; e: for (let r = this.pos; e = this.buffer[r]; ++r)
                    switch (e) {
                        case " ":
                            n += 1;
                            break;
                        case "\n":
                            t = r, n = 0;
                            break;
                        case "\r": {
                            const e = this.buffer[r + 1];
                            if (!e && !this.atEnd)
                                return this.setNext("block-scalar");
                            if ("\n" === e)
                                break;
                        }
                        default: break e;
                    } if (!e && !this.atEnd)
                    return this.setNext("block-scalar"); if (n >= this.indentNext) {
                    -1 === this.blockScalarIndent ? this.indentNext = n : this.indentNext += this.blockScalarIndent;
                    do {
                        const e = this.continueScalar(t + 1);
                        if (-1 === e)
                            break;
                        t = this.buffer.indexOf("\n", e);
                    } while (-1 !== t);
                    if (-1 === t) {
                        if (!this.atEnd)
                            return this.setNext("block-scalar");
                        t = this.buffer.length;
                    }
                } if (!this.blockScalarKeep)
                    for (;;) {
                        let e = t - 1, r = this.buffer[e];
                        "\r" === r && (r = this.buffer[--e]);
                        const o = e;
                        for (; " " === r || "\t" === r;)
                            r = this.buffer[--e];
                        if (!("\n" === r && e >= this.pos && e + 1 + n > o))
                            break;
                        t = e;
                    } return yield ha, yield* this.pushToIndex(t + 1, !0), yield* this.parseLineStart(); }
                *parsePlainScalar() { const e = this.flowLevel > 0; let t, n = this.pos - 1, r = this.pos - 1; for (; t = this.buffer[++r];)
                    if (":" === t) {
                        const t = this.buffer[r + 1];
                        if (ba(t) || e && "," === t)
                            break;
                        n = r;
                    }
                    else if (ba(t)) {
                        let o = this.buffer[r + 1];
                        if ("\r" === t && ("\n" === o ? (r += 1, t = "\n", o = this.buffer[r + 1]) : n = r), "#" === o || e && Ca.includes(o))
                            break;
                        if ("\n" === t) {
                            const e = this.continueScalar(r + 1);
                            if (-1 === e)
                                break;
                            r = Math.max(r, e - 2);
                        }
                    }
                    else {
                        if (e && Ca.includes(t))
                            break;
                        n = r;
                    } return t || this.atEnd ? (yield ha, yield* this.pushToIndex(n + 1, !0), e ? "flow" : "doc") : this.setNext("plain-scalar"); }
                *pushCount(e) { return e > 0 ? (yield this.buffer.substr(this.pos, e), this.pos += e, e) : 0; }
                *pushToIndex(e, t) { const n = this.buffer.slice(this.pos, e); return n ? (yield n, this.pos += n.length, n.length) : (t && (yield ""), 0); }
                *pushIndicators() { switch (this.charAt(0)) {
                    case "!": return (yield* this.pushTag()) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());
                    case "&": return (yield* this.pushUntil(Aa)) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());
                    case "-":
                    case "?":
                    case ":": {
                        const e = this.flowLevel > 0, t = this.charAt(1);
                        if (ba(t) || e && Ca.includes(t))
                            return e ? this.flowKey && (this.flowKey = !1) : this.indentNext = this.indentValue + 1, (yield* this.pushCount(1)) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());
                    }
                } return 0; }
                *pushTag() { if ("<" === this.charAt(1)) {
                    let e = this.pos + 2, t = this.buffer[e];
                    for (; !ba(t) && ">" !== t;)
                        t = this.buffer[++e];
                    return yield* this.pushToIndex(">" === t ? e + 1 : e, !1);
                } {
                    let e = this.pos + 1, t = this.buffer[e];
                    for (; t;)
                        if (Ea.includes(t))
                            t = this.buffer[++e];
                        else {
                            if ("%" !== t || !Da.includes(this.buffer[e + 1]) || !Da.includes(this.buffer[e + 2]))
                                break;
                            t = this.buffer[e += 3];
                        }
                    return yield* this.pushToIndex(e, !1);
                } }
                *pushNewline() { const e = this.buffer[this.pos]; return "\n" === e ? yield* this.pushCount(1) : "\r" === e && "\n" === this.charAt(1) ? yield* this.pushCount(2) : 0; }
                *pushSpaces(e) { let t, n = this.pos - 1; do {
                    t = this.buffer[++n];
                } while (" " === t || e && "\t" === t); const r = n - this.pos; return r > 0 && (yield this.buffer.substr(this.pos, r), this.pos = n), r; }
                *pushUntil(e) { let t = this.pos, n = this.buffer[t]; for (; !e(n);)
                    n = this.buffer[++t]; return yield* this.pushToIndex(t, !1); }
            }, this.onNewLine = e; }
            *parse(e, t = !1) { this.onNewLine && 0 === this.offset && this.onNewLine(0); for (const n of this.lexer.lex(e, t))
                yield* this.next(n); t || (yield* this.end()); }
            *next(e) { if (this.source = e, this.atScalar)
                return this.atScalar = !1, yield* this.step(), void (this.offset += e.length); const t = va(e); if (t)
                if ("scalar" === t)
                    this.atNewLine = !1, this.atScalar = !0, this.type = "scalar";
                else {
                    switch (this.type = t, yield* this.step(), t) {
                        case "newline":
                            this.atNewLine = !0, this.indent = 0, this.onNewLine && this.onNewLine(this.offset + e.length);
                            break;
                        case "space":
                            this.atNewLine && " " === e[0] && (this.indent += e.length);
                            break;
                        case "explicit-key-ind":
                        case "map-value-ind":
                        case "seq-item-ind":
                            this.atNewLine && (this.indent += e.length);
                            break;
                        case "doc-mode":
                        case "flow-error-end": return;
                        default: this.atNewLine = !1;
                    }
                    this.offset += e.length;
                }
            else {
                const t = `Not a YAML token: ${e}`;
                yield* this.pop({ type: "error", offset: this.offset, message: t, source: e }), this.offset += e.length;
            } }
            *end() { for (; this.stack.length > 0;)
                yield* this.pop(); }
            get sourceToken() { return { type: this.type, offset: this.offset, indent: this.indent, source: this.source }; }
            *step() { const e = this.peek(1); if ("doc-end" !== this.type || e && "doc-end" === e.type) {
                if (!e)
                    return yield* this.stream();
                switch (e.type) {
                    case "document": return yield* this.document(e);
                    case "alias":
                    case "scalar":
                    case "single-quoted-scalar":
                    case "double-quoted-scalar": return yield* this.scalar(e);
                    case "block-scalar": return yield* this.blockScalar(e);
                    case "block-map": return yield* this.blockMap(e);
                    case "block-seq": return yield* this.blockSequence(e);
                    case "flow-collection": return yield* this.flowCollection(e);
                    case "doc-end": return yield* this.documentEnd(e);
                }
                yield* this.pop();
            }
            else {
                for (; this.stack.length > 0;)
                    yield* this.pop();
                this.stack.push({ type: "doc-end", offset: this.offset, source: this.source });
            } }
            peek(e) { return this.stack[this.stack.length - e]; }
            *pop(e) { const t = e || this.stack.pop(); if (t)
                if (0 === this.stack.length)
                    yield t;
                else {
                    const e = this.peek(1);
                    switch ("block-scalar" === t.type ? t.indent = "indent" in e ? e.indent : 0 : "flow-collection" === t.type && "document" === e.type && (t.indent = 0), "flow-collection" === t.type && _a(t), e.type) {
                        case "document":
                            e.value = t;
                            break;
                        case "block-scalar":
                            e.props.push(t);
                            break;
                        case "block-map": {
                            const n = e.items[e.items.length - 1];
                            if (n.value)
                                return e.items.push({ start: [], key: t, sep: [] }), void (this.onKeyLine = !0);
                            if (!n.sep)
                                return Object.assign(n, { key: t, sep: [] }), void (this.onKeyLine = !xa(n.start, "explicit-key-ind"));
                            n.value = t;
                            break;
                        }
                        case "block-seq": {
                            const n = e.items[e.items.length - 1];
                            n.value ? e.items.push({ start: [], value: t }) : n.value = t;
                            break;
                        }
                        case "flow-collection": {
                            const n = e.items[e.items.length - 1];
                            return void (!n || n.value ? e.items.push({ start: [], key: t, sep: [] }) : n.sep ? n.value = t : Object.assign(n, { key: t, sep: [] }));
                        }
                        default: yield* this.pop(), yield* this.pop(t);
                    }
                    if (!("document" !== e.type && "block-map" !== e.type && "block-seq" !== e.type || "block-map" !== t.type && "block-seq" !== t.type)) {
                        const n = t.items[t.items.length - 1];
                        n && !n.sep && !n.value && n.start.length > 0 && !Ta(n.start) && (0 === t.indent || n.start.every((e => "comment" !== e.type || e.indent < t.indent))) && ("document" === e.type ? e.end = n.start : e.items.push({ start: n.start }), t.items.splice(-1, 1));
                    }
                }
            else {
                const e = "Tried to pop an empty stack";
                yield { type: "error", offset: this.offset, source: "", message: e };
            } }
            *stream() { switch (this.type) {
                case "directive-line": return void (yield { type: "directive", offset: this.offset, source: this.source });
                case "byte-order-mark":
                case "space":
                case "comment":
                case "newline": return void (yield this.sourceToken);
                case "doc-mode":
                case "doc-start": {
                    const e = { type: "document", offset: this.offset, start: [] };
                    return "doc-start" === this.type && e.start.push(this.sourceToken), void this.stack.push(e);
                }
            } yield { type: "error", offset: this.offset, message: `Unexpected ${this.type} token in YAML stream`, source: this.source }; }
            *document(e) { if (e.value)
                return yield* this.lineEnd(e); switch (this.type) {
                case "doc-start": return void (Ta(e.start) ? (yield* this.pop(), yield* this.step()) : e.start.push(this.sourceToken));
                case "anchor":
                case "tag":
                case "space":
                case "comment":
                case "newline": return void e.start.push(this.sourceToken);
            } const t = this.startBlockValue(e); t ? this.stack.push(t) : yield { type: "error", offset: this.offset, message: `Unexpected ${this.type} token in YAML document`, source: this.source }; }
            *scalar(e) { if ("map-value-ind" === this.type) {
                const t = Oa(Fa(this.peek(2)));
                let n;
                e.end ? (n = e.end, n.push(this.sourceToken), delete e.end) : n = [this.sourceToken];
                const r = { type: "block-map", offset: e.offset, indent: e.indent, items: [{ start: t, key: e, sep: n }] };
                this.onKeyLine = !0, this.stack[this.stack.length - 1] = r;
            }
            else
                yield* this.lineEnd(e); }
            *blockScalar(e) { switch (this.type) {
                case "space":
                case "comment":
                case "newline": return void e.props.push(this.sourceToken);
                case "scalar":
                    if (e.source = this.source, this.atNewLine = !0, this.indent = 0, this.onNewLine) {
                        let e = this.source.indexOf("\n") + 1;
                        for (; 0 !== e;)
                            this.onNewLine(this.offset + e), e = this.source.indexOf("\n", e) + 1;
                    }
                    yield* this.pop();
                    break;
                default: yield* this.pop(), yield* this.step();
            } }
            *blockMap(e) { var t; const n = e.items[e.items.length - 1]; switch (this.type) {
                case "newline":
                    if (this.onKeyLine = !1, n.value) {
                        const t = "end" in n.value ? n.value.end : void 0, r = Array.isArray(t) ? t[t.length - 1] : void 0;
                        "comment" === (null == r ? void 0 : r.type) ? null == t || t.push(this.sourceToken) : e.items.push({ start: [this.sourceToken] });
                    }
                    else
                        n.sep ? n.sep.push(this.sourceToken) : n.start.push(this.sourceToken);
                    return;
                case "space":
                case "comment":
                    if (n.value)
                        e.items.push({ start: [this.sourceToken] });
                    else if (n.sep)
                        n.sep.push(this.sourceToken);
                    else {
                        if (this.atIndentedComment(n.start, e.indent)) {
                            const r = e.items[e.items.length - 2], o = null === (t = null == r ? void 0 : r.value) || void 0 === t ? void 0 : t.end;
                            if (Array.isArray(o))
                                return Array.prototype.push.apply(o, n.start), o.push(this.sourceToken), void e.items.pop();
                        }
                        n.start.push(this.sourceToken);
                    }
                    return;
            } if (this.indent >= e.indent) {
                const t = !this.onKeyLine && this.indent === e.indent && (n.sep || Ta(n.start));
                switch (this.type) {
                    case "anchor":
                    case "tag": return void (t || n.value ? (e.items.push({ start: [this.sourceToken] }), this.onKeyLine = !0) : n.sep ? n.sep.push(this.sourceToken) : n.start.push(this.sourceToken));
                    case "explicit-key-ind": return n.sep || xa(n.start, "explicit-key-ind") ? t || n.value ? e.items.push({ start: [this.sourceToken] }) : this.stack.push({ type: "block-map", offset: this.offset, indent: this.indent, items: [{ start: [this.sourceToken] }] }) : n.start.push(this.sourceToken), void (this.onKeyLine = !0);
                    case "map-value-ind":
                        if (xa(n.start, "explicit-key-ind"))
                            if (n.sep)
                                if (n.value)
                                    e.items.push({ start: [], key: null, sep: [this.sourceToken] });
                                else if (xa(n.sep, "map-value-ind"))
                                    this.stack.push({ type: "block-map", offset: this.offset, indent: this.indent, items: [{ start: [], key: null, sep: [this.sourceToken] }] });
                                else if (ka(n.key) && !xa(n.sep, "newline")) {
                                    const e = Oa(n.start), t = n.key, r = n.sep;
                                    r.push(this.sourceToken), delete n.key, delete n.sep, this.stack.push({ type: "block-map", offset: this.offset, indent: this.indent, items: [{ start: e, key: t, sep: r }] });
                                }
                                else
                                    n.sep.push(this.sourceToken);
                            else if (xa(n.start, "newline"))
                                Object.assign(n, { key: null, sep: [this.sourceToken] });
                            else {
                                const e = Oa(n.start);
                                this.stack.push({ type: "block-map", offset: this.offset, indent: this.indent, items: [{ start: e, key: null, sep: [this.sourceToken] }] });
                            }
                        else
                            n.sep ? n.value || t ? e.items.push({ start: [], key: null, sep: [this.sourceToken] }) : xa(n.sep, "map-value-ind") ? this.stack.push({ type: "block-map", offset: this.offset, indent: this.indent, items: [{ start: [], key: null, sep: [this.sourceToken] }] }) : n.sep.push(this.sourceToken) : Object.assign(n, { key: null, sep: [this.sourceToken] });
                        return void (this.onKeyLine = !0);
                    case "alias":
                    case "scalar":
                    case "single-quoted-scalar":
                    case "double-quoted-scalar": {
                        const r = this.flowScalar(this.type);
                        return void (t || n.value ? (e.items.push({ start: [], key: r, sep: [] }), this.onKeyLine = !0) : n.sep ? this.stack.push(r) : (Object.assign(n, { key: r, sep: [] }), this.onKeyLine = !0));
                    }
                    default: {
                        const r = this.startBlockValue(e);
                        if (r)
                            return t && "block-seq" !== r.type && xa(n.start, "explicit-key-ind") && e.items.push({ start: [] }), void this.stack.push(r);
                    }
                }
            } yield* this.pop(), yield* this.step(); }
            *blockSequence(e) { var t; const n = e.items[e.items.length - 1]; switch (this.type) {
                case "newline":
                    if (n.value) {
                        const t = "end" in n.value ? n.value.end : void 0, r = Array.isArray(t) ? t[t.length - 1] : void 0;
                        "comment" === (null == r ? void 0 : r.type) ? null == t || t.push(this.sourceToken) : e.items.push({ start: [this.sourceToken] });
                    }
                    else
                        n.start.push(this.sourceToken);
                    return;
                case "space":
                case "comment":
                    if (n.value)
                        e.items.push({ start: [this.sourceToken] });
                    else {
                        if (this.atIndentedComment(n.start, e.indent)) {
                            const r = e.items[e.items.length - 2], o = null === (t = null == r ? void 0 : r.value) || void 0 === t ? void 0 : t.end;
                            if (Array.isArray(o))
                                return Array.prototype.push.apply(o, n.start), o.push(this.sourceToken), void e.items.pop();
                        }
                        n.start.push(this.sourceToken);
                    }
                    return;
                case "anchor":
                case "tag":
                    if (n.value || this.indent <= e.indent)
                        break;
                    return void n.start.push(this.sourceToken);
                case "seq-item-ind":
                    if (this.indent !== e.indent)
                        break;
                    return void (n.value || xa(n.start, "seq-item-ind") ? e.items.push({ start: [this.sourceToken] }) : n.start.push(this.sourceToken));
            } if (this.indent > e.indent) {
                const t = this.startBlockValue(e);
                if (t)
                    return void this.stack.push(t);
            } yield* this.pop(), yield* this.step(); }
            *flowCollection(e) { const t = e.items[e.items.length - 1]; if ("flow-error-end" === this.type) {
                let e;
                do {
                    yield* this.pop(), e = this.peek(1);
                } while (e && "flow-collection" === e.type);
            }
            else if (0 === e.end.length) {
                switch (this.type) {
                    case "comma":
                    case "explicit-key-ind": return void (!t || t.sep ? e.items.push({ start: [this.sourceToken] }) : t.start.push(this.sourceToken));
                    case "map-value-ind": return void (!t || t.value ? e.items.push({ start: [], key: null, sep: [this.sourceToken] }) : t.sep ? t.sep.push(this.sourceToken) : Object.assign(t, { key: null, sep: [this.sourceToken] }));
                    case "space":
                    case "comment":
                    case "newline":
                    case "anchor":
                    case "tag": return void (!t || t.value ? e.items.push({ start: [this.sourceToken] }) : t.sep ? t.sep.push(this.sourceToken) : t.start.push(this.sourceToken));
                    case "alias":
                    case "scalar":
                    case "single-quoted-scalar":
                    case "double-quoted-scalar": {
                        const n = this.flowScalar(this.type);
                        return void (!t || t.value ? e.items.push({ start: [], key: n, sep: [] }) : t.sep ? this.stack.push(n) : Object.assign(t, { key: n, sep: [] }));
                    }
                    case "flow-map-end":
                    case "flow-seq-end": return void e.end.push(this.sourceToken);
                }
                const n = this.startBlockValue(e);
                n ? this.stack.push(n) : (yield* this.pop(), yield* this.step());
            }
            else {
                const t = this.peek(2);
                if ("block-map" === t.type && ("map-value-ind" === this.type && t.indent === e.indent || "newline" === this.type && !t.items[t.items.length - 1].sep))
                    yield* this.pop(), yield* this.step();
                else if ("map-value-ind" === this.type && "flow-collection" !== t.type) {
                    const n = Oa(Fa(t));
                    _a(e);
                    const r = e.end.splice(1, e.end.length);
                    r.push(this.sourceToken);
                    const o = { type: "block-map", offset: e.offset, indent: e.indent, items: [{ start: n, key: e, sep: r }] };
                    this.onKeyLine = !0, this.stack[this.stack.length - 1] = o;
                }
                else
                    yield* this.lineEnd(e);
            } }
            flowScalar(e) { if (this.onNewLine) {
                let e = this.source.indexOf("\n") + 1;
                for (; 0 !== e;)
                    this.onNewLine(this.offset + e), e = this.source.indexOf("\n", e) + 1;
            } return { type: e, offset: this.offset, indent: this.indent, source: this.source }; }
            startBlockValue(e) { switch (this.type) {
                case "alias":
                case "scalar":
                case "single-quoted-scalar":
                case "double-quoted-scalar": return this.flowScalar(this.type);
                case "block-scalar-header": return { type: "block-scalar", offset: this.offset, indent: this.indent, props: [this.sourceToken], source: "" };
                case "flow-map-start":
                case "flow-seq-start": return { type: "flow-collection", offset: this.offset, indent: this.indent, start: this.sourceToken, items: [], end: [] };
                case "seq-item-ind": return { type: "block-seq", offset: this.offset, indent: this.indent, items: [{ start: [this.sourceToken] }] };
                case "explicit-key-ind": {
                    this.onKeyLine = !0;
                    const t = Oa(Fa(e));
                    return t.push(this.sourceToken), { type: "block-map", offset: this.offset, indent: this.indent, items: [{ start: t }] };
                }
                case "map-value-ind": {
                    this.onKeyLine = !0;
                    const t = Oa(Fa(e));
                    return { type: "block-map", offset: this.offset, indent: this.indent, items: [{ start: t, key: null, sep: [this.sourceToken] }] };
                }
            } return null; }
            atIndentedComment(e, t) { return "comment" === this.type && !(this.indent <= t) && e.every((e => "newline" === e.type || "space" === e.type)); }
            *documentEnd(e) { "doc-mode" !== this.type && (e.end ? e.end.push(this.sourceToken) : e.end = [this.sourceToken], "newline" === this.type && (yield* this.pop())); }
            *lineEnd(e) { switch (this.type) {
                case "comma":
                case "doc-start":
                case "doc-end":
                case "flow-seq-end":
                case "flow-map-end":
                case "map-value-ind":
                    yield* this.pop(), yield* this.step();
                    break;
                case "newline": this.onKeyLine = !1;
                default: e.end ? e.end.push(this.sourceToken) : e.end = [this.sourceToken], "newline" === this.type && (yield* this.pop());
            } }
        };
        var Pa = b(D());
        function Ma(e, t) { if (e === t)
            return !0; if (null == e || null == t)
            return !1; if (typeof e != typeof t)
            return !1; if ("object" != typeof e)
            return !1; if (Array.isArray(e) !== Array.isArray(t))
            return !1; let n, r; if (Array.isArray(e)) {
            if (e.length !== t.length)
                return !1;
            for (n = 0; n < e.length; n++)
                if (!Ma(e[n], t[n]))
                    return !1;
        }
        else {
            const o = [];
            for (r in e)
                o.push(r);
            o.sort();
            const i = [];
            for (r in t)
                i.push(r);
            if (i.sort(), !Ma(o, i))
                return !1;
            for (n = 0; n < o.length; n++)
                if (!Ma(e[o[n]], t[o[n]]))
                    return !1;
        } return !0; }
        function Ra(e) { return "number" == typeof e; }
        function Ia(e) { return void 0 !== e; }
        function ja(e) { return "boolean" == typeof e; }
        function Ba(e) { return "string" == typeof e; }
        function La(e) { var t; return e ? e instanceof Error && null != (t = e.stack) ? t : e.toString() : "null"; }
        var qa = b(D());
        function $a(e) { return e.title ? e.title : e.$id ? Ua(e.$id) : e.$ref || e._$ref ? Ua(e.$ref || e._$ref) : e.closestTitle || (Array.isArray(e.type) ? e.type.join(" | ") : e.type); }
        function Ua(e) { const t = e.match(/^(?:.*\/)?(.*?)(?:\.schema\.json)?$/); let n = !!t && t[1]; return n || (n = "typeNotFound", a.error(`$ref (${e}) not parsed properly`)), n; }
        function Va(e, t) { const n = It.parse(t); let r = qa.basename(n.fsPath); return qa.extname(n.fsPath) || (r += ".json"), Object.getOwnPropertyDescriptor(e, "name") ? Object.getOwnPropertyDescriptor(e, "name").value + ` (${r})` : e.title ? e.description ? e.title + " - " + e.description + ` (${r})` : e.title + ` (${r})` : r; }
        function Wa(e) { return "object" !== e.type && !Ka(e); }
        function Ka(e) { return !!(e.anyOf || e.allOf || e.oneOf); }
        function za(e, t, n) { if (null !== e && "object" == typeof e) {
            var r = t + "\t";
            if (Array.isArray(e)) {
                if (0 === e.length)
                    return "[]";
                for (var o = "[\n", i = 0; i < e.length; i++)
                    o += r + za(e[i], r, n), i < e.length - 1 && (o += ","), o += "\n";
                return o + (t + "]");
            }
            var s = Object.keys(e);
            if (0 === s.length)
                return "{}";
            for (o = "{\n", i = 0; i < s.length; i++) {
                var a = s[i];
                o += r + JSON.stringify(a) + ": " + za(e[a], r, n), i < s.length - 1 && (o += ","), o += "\n";
            }
            return o + (t + "}");
        } return n(e); }
        var Ha = _r();
        !function () { function e(e, t, n, r) { void 0 === t && (t = []), void 0 === n && (n = Promise), void 0 === r && (r = {}), this.schemaService = e, this.contributions = t, this.promiseConstructor = n, this.clientCapabilities = r; } e.prototype.doResolve = function (e) { for (var t = this.contributions.length - 1; t >= 0; t--) {
            var n = this.contributions[t].resolveCompletion;
            if (n) {
                var r = n(e);
                if (r)
                    return r;
            }
        } return this.promiseConstructor.resolve(e); }, e.prototype.doComplete = function (e, t, n) { var r = this, o = { items: [], isIncomplete: !1 }, i = e.getText(), s = e.offsetAt(t), u = n.getNodeFromOffset(s, !0); if (this.isInComment(e, u ? u.offset : 0, s))
            return Promise.resolve(o); if (u && s === u.offset + u.length && s > 0) {
            var c = i[s - 1];
            ("object" === u.type && "}" === c || "array" === u.type && "]" === c) && (u = u.parent);
        } var l, p = this.getCurrentWord(e, s); if (!u || "string" !== u.type && "number" !== u.type && "boolean" !== u.type && "null" !== u.type) {
            var f = s - p.length;
            f > 0 && '"' === i[f - 1] && f--, l = He.create(e.positionAt(f), t);
        }
        else
            l = He.create(e.positionAt(u.offset), e.positionAt(u.offset + u.length)); var d = {}, h = { add: function (e) { var t = e.label, n = d[t]; if (n)
                n.documentation || (n.documentation = e.documentation), n.detail || (n.detail = e.detail);
            else {
                if ((t = t.replace(/[\n]/g, "↵")).length > 60) {
                    var r = t.substr(0, 57).trim() + "...";
                    d[r] || (t = r);
                }
                l && void 0 !== e.insertText && (e.textEdit = Dt.replace(l, e.insertText)), e.label = t, d[t] = e, o.items.push(e);
            } }, setAsIncomplete: function () { o.isIncomplete = !0; }, error: function (e) { a.error(e); }, log: function (e) { a.log(e); }, getNumberOfProposals: function () { return o.items.length; } }; return this.schemaService.getSchemaForResource(e.uri, n).then((function (t) { var a = [], c = !0, f = "", m = void 0; if (u && "string" === u.type) {
            var g = u.parent;
            g && "property" === g.type && g.keyNode === u && (c = !g.valueNode, m = g, f = i.substr(u.offset + 1, u.length - 2), g && (u = g.parent));
        } if (u && "object" === u.type) {
            if (u.offset === s)
                return o;
            u.properties.forEach((function (e) { m && m === e || (d[e.keyNode.value] = dn.create("__")); }));
            var y = "";
            c && (y = r.evaluateSeparatorAfter(e, e.offsetAt(l.end))), t ? r.getPropertyCompletions(t, n, u, c, y, h) : r.getSchemaLessPropertyCompletions(n, u, f, h);
            var v = Kr(u);
            r.contributions.forEach((function (t) { var n = t.collectPropertyCompletions(e.uri, v, p, c, "" === y, h); n && a.push(n); })), !t && p.length > 0 && '"' !== i.charAt(s - p.length - 1) && (h.add({ kind: nn.Property, label: r.getLabelForValue(p), insertText: r.getInsertTextForProperty(p, void 0, !1, y), insertTextFormat: on.Snippet, documentation: "" }), h.setAsIncomplete());
        } var b = {}; return t ? r.getValueCompletions(t, n, u, s, e, h, b) : r.getSchemaLessValueCompletions(n, u, s, e, h), r.contributions.length > 0 && r.getContributedValueCompletions(n, u, s, e, h, a), r.promiseConstructor.all(a).then((function () { if (0 === h.getNumberOfProposals()) {
            var t = s;
            !u || "string" !== u.type && "number" !== u.type && "boolean" !== u.type && "null" !== u.type || (t = u.offset + u.length);
            var n = r.evaluateSeparatorAfter(e, t);
            r.addFillerValueCompletions(b, n, h);
        } return o; })); })); }, e.prototype.getPropertyCompletions = function (e, t, n, r, o, i) { var s = this; t.getMatchingSchemas(e.schema, n.offset).forEach((function (e) { if (e.node === n && !e.inverted) {
            var t = e.schema.properties;
            t && Object.keys(t).forEach((function (e) { var n = t[e]; if ("object" == typeof n && !n.deprecationMessage && !n.doNotSuggest) {
                var a = { kind: nn.Property, label: e, insertText: s.getInsertTextForProperty(e, n, r, o), insertTextFormat: on.Snippet, filterText: s.getFilterTextForValue(e), documentation: s.fromMarkup(n.markdownDescription) || n.description || "" };
                void 0 !== n.suggestSortText && (a.sortText = n.suggestSortText), a.insertText && Lt(a.insertText, "$1" + o) && (a.command = { title: "Suggest", command: "editor.action.triggerSuggest" }), i.add(a);
            } }));
            var a = e.schema.propertyNames;
            if ("object" == typeof a && !a.deprecationMessage && !a.doNotSuggest) {
                var u = function (e, t) { void 0 === t && (t = void 0); var n = { kind: nn.Property, label: e, insertText: s.getInsertTextForProperty(e, void 0, r, o), insertTextFormat: on.Snippet, filterText: s.getFilterTextForValue(e), documentation: t || s.fromMarkup(a.markdownDescription) || a.description || "" }; void 0 !== a.suggestSortText && (n.sortText = a.suggestSortText), n.insertText && Lt(n.insertText, "$1" + o) && (n.command = { title: "Suggest", command: "editor.action.triggerSuggest" }), i.add(n); };
                if (a.enum)
                    for (var c = 0; c < a.enum.length; c++) {
                        var l = void 0;
                        a.markdownEnumDescriptions && c < a.markdownEnumDescriptions.length ? l = s.fromMarkup(a.markdownEnumDescriptions[c]) : a.enumDescriptions && c < a.enumDescriptions.length && (l = a.enumDescriptions[c]), u(a.enum[c], l);
                    }
                a.const && u(a.const);
            }
        } })); }, e.prototype.getSchemaLessPropertyCompletions = function (e, t, n, r) { var o = this, i = function (e) { e.properties.forEach((function (e) { var t = e.keyNode.value; r.add({ kind: nn.Property, label: t, insertText: o.getInsertTextForValue(t, ""), insertTextFormat: on.Snippet, filterText: o.getFilterTextForValue(t), documentation: "" }); })); }; if (t.parent)
            if ("property" === t.parent.type) {
                var s = t.parent.keyNode.value;
                e.visit((function (e) { return "property" === e.type && e !== t.parent && e.keyNode.value === s && e.valueNode && "object" === e.valueNode.type && i(e.valueNode), !0; }));
            }
            else
                "array" === t.parent.type && t.parent.items.forEach((function (e) { "object" === e.type && e !== t && i(e); }));
        else
            "object" === t.type && r.add({ kind: nn.Property, label: "$schema", insertText: this.getInsertTextForProperty("$schema", void 0, !0, ""), insertTextFormat: on.Snippet, documentation: "", filterText: this.getFilterTextForValue("$schema") }); }, e.prototype.getSchemaLessValueCompletions = function (e, t, n, r, o) { var i = this, s = n; if (!t || "string" !== t.type && "number" !== t.type && "boolean" !== t.type && "null" !== t.type || (s = t.offset + t.length, t = t.parent), !t)
            return o.add({ kind: this.getSuggestionKind("object"), label: "Empty object", insertText: this.getInsertTextForValue({}, ""), insertTextFormat: on.Snippet, documentation: "" }), void o.add({ kind: this.getSuggestionKind("array"), label: "Empty array", insertText: this.getInsertTextForValue([], ""), insertTextFormat: on.Snippet, documentation: "" }); var a = this.evaluateSeparatorAfter(r, s), u = function (e) { e.parent && !zr(e.parent, n, !0) && o.add({ kind: i.getSuggestionKind(e.type), label: i.getLabelTextForMatchingNode(e, r), insertText: i.getInsertTextForMatchingNode(e, r, a), insertTextFormat: on.Snippet, documentation: "" }), "boolean" === e.type && i.addBooleanValueCompletion(!e.value, a, o); }; if ("property" === t.type && n > (t.colonOffset || 0)) {
            var c = t.valueNode;
            if (c && (n > c.offset + c.length || "object" === c.type || "array" === c.type))
                return;
            var l = t.keyNode.value;
            e.visit((function (e) { return "property" === e.type && e.keyNode.value === l && e.valueNode && u(e.valueNode), !0; })), "$schema" === l && t.parent && !t.parent.parent && this.addDollarSchemaCompletions(a, o);
        } if ("array" === t.type)
            if (t.parent && "property" === t.parent.type) {
                var p = t.parent.keyNode.value;
                e.visit((function (e) { return "property" === e.type && e.keyNode.value === p && e.valueNode && "array" === e.valueNode.type && e.valueNode.items.forEach(u), !0; }));
            }
            else
                t.items.forEach(u); }, e.prototype.getValueCompletions = function (e, t, n, r, o, i, s) { var a = r, u = void 0, c = void 0; if (!n || "string" !== n.type && "number" !== n.type && "boolean" !== n.type && "null" !== n.type || (a = n.offset + n.length, c = n, n = n.parent), n) {
            if ("property" === n.type && r > (n.colonOffset || 0)) {
                var l = n.valueNode;
                if (l && r > l.offset + l.length)
                    return;
                u = n.keyNode.value, n = n.parent;
            }
            if (n && (void 0 !== u || "array" === n.type)) {
                for (var p = this.evaluateSeparatorAfter(o, a), f = 0, d = t.getMatchingSchemas(e.schema, n.offset, c); f < d.length; f++) {
                    var h = d[f];
                    if (h.node === n && !h.inverted && h.schema) {
                        if ("array" === n.type && h.schema.items)
                            if (Array.isArray(h.schema.items)) {
                                var m = this.findItemAtOffset(n, o, r);
                                m < h.schema.items.length && this.addSchemaValueCompletions(h.schema.items[m], p, i, s);
                            }
                            else
                                this.addSchemaValueCompletions(h.schema.items, p, i, s);
                        if (void 0 !== u) {
                            var g = !1;
                            if (h.schema.properties && (D = h.schema.properties[u]) && (g = !0, this.addSchemaValueCompletions(D, p, i, s)), h.schema.patternProperties && !g)
                                for (var y = 0, v = Object.keys(h.schema.patternProperties); y < v.length; y++) {
                                    var b = v[y];
                                    if (qt(b).test(u)) {
                                        g = !0;
                                        var D = h.schema.patternProperties[b];
                                        this.addSchemaValueCompletions(D, p, i, s);
                                    }
                                }
                            h.schema.additionalProperties && !g && (D = h.schema.additionalProperties, this.addSchemaValueCompletions(D, p, i, s));
                        }
                    }
                }
                "$schema" !== u || n.parent || this.addDollarSchemaCompletions(p, i), s.boolean && (this.addBooleanValueCompletion(!0, p, i), this.addBooleanValueCompletion(!1, p, i)), s.null && this.addNullValueCompletion(p, i);
            }
        }
        else
            this.addSchemaValueCompletions(e.schema, "", i, s); }, e.prototype.getContributedValueCompletions = function (e, t, n, r, o, i) { if (t) {
            if ("string" !== t.type && "number" !== t.type && "boolean" !== t.type && "null" !== t.type || (t = t.parent), t && "property" === t.type && n > (t.colonOffset || 0)) {
                var s = t.keyNode.value, a = t.valueNode;
                if ((!a || n <= a.offset + a.length) && t.parent) {
                    var u = Kr(t.parent);
                    this.contributions.forEach((function (e) { var t = e.collectValueCompletions(r.uri, u, s, o); t && i.push(t); }));
                }
            }
        }
        else
            this.contributions.forEach((function (e) { var t = e.collectDefaultCompletions(r.uri, o); t && i.push(t); })); }, e.prototype.addSchemaValueCompletions = function (e, t, n, r) { var o = this; "object" == typeof e && (this.addEnumValueCompletions(e, t, n), this.addDefaultValueCompletions(e, t, n), this.collectTypes(e, r), Array.isArray(e.allOf) && e.allOf.forEach((function (e) { return o.addSchemaValueCompletions(e, t, n, r); })), Array.isArray(e.anyOf) && e.anyOf.forEach((function (e) { return o.addSchemaValueCompletions(e, t, n, r); })), Array.isArray(e.oneOf) && e.oneOf.forEach((function (e) { return o.addSchemaValueCompletions(e, t, n, r); }))); }, e.prototype.addDefaultValueCompletions = function (e, t, n, r) { var o = this; void 0 === r && (r = 0); var i = !1; if (Vt(e.default)) {
            for (var s = e.type, a = e.default, u = r; u > 0; u--)
                a = [a], s = "array";
            n.add({ kind: this.getSuggestionKind(s), label: this.getLabelForValue(a), insertText: this.getInsertTextForValue(a, t), insertTextFormat: on.Snippet, detail: Ha("json.suggest.default", "Default value") }), i = !0;
        } Array.isArray(e.examples) && e.examples.forEach((function (s) { for (var a = e.type, u = s, c = r; c > 0; c--)
            u = [u], a = "array"; n.add({ kind: o.getSuggestionKind(a), label: o.getLabelForValue(u), insertText: o.getInsertTextForValue(u, t), insertTextFormat: on.Snippet }), i = !0; })), Array.isArray(e.defaultSnippets) && e.defaultSnippets.forEach((function (s) { var a, u, c = e.type, l = s.body, p = s.label; if (Vt(l)) {
            e.type;
            for (var f = r; f > 0; f--)
                l = [l];
            a = o.getInsertTextForSnippetValue(l, t), u = o.getFilterTextForSnippetValue(l), p = p || o.getLabelForSnippetValue(l);
        }
        else {
            if ("string" != typeof s.bodyText)
                return;
            var d = "", h = "", m = "";
            for (f = r; f > 0; f--)
                d = d + m + "[\n", h = h + "\n" + m + "]", m += "\t", c = "array";
            a = d + m + s.bodyText.split("\n").join("\n" + m) + h + t, p = p || a, u = a.replace(/[\n]/g, "");
        } n.add({ kind: o.getSuggestionKind(c), label: p, documentation: o.fromMarkup(s.markdownDescription) || s.description, insertText: a, insertTextFormat: on.Snippet, filterText: u }), i = !0; })), !i && "object" == typeof e.items && !Array.isArray(e.items) && r < 5 && this.addDefaultValueCompletions(e.items, t, n, r + 1); }, e.prototype.addEnumValueCompletions = function (e, t, n) { if (Vt(e.const) && n.add({ kind: this.getSuggestionKind(e.type), label: this.getLabelForValue(e.const), insertText: this.getInsertTextForValue(e.const, t), insertTextFormat: on.Snippet, documentation: this.fromMarkup(e.markdownDescription) || e.description }), Array.isArray(e.enum))
            for (var r = 0, o = e.enum.length; r < o; r++) {
                var i = e.enum[r], s = this.fromMarkup(e.markdownDescription) || e.description;
                e.markdownEnumDescriptions && r < e.markdownEnumDescriptions.length && this.doesSupportMarkdown() ? s = this.fromMarkup(e.markdownEnumDescriptions[r]) : e.enumDescriptions && r < e.enumDescriptions.length && (s = e.enumDescriptions[r]), n.add({ kind: this.getSuggestionKind(e.type), label: this.getLabelForValue(i), insertText: this.getInsertTextForValue(i, t), insertTextFormat: on.Snippet, documentation: s });
            } }, e.prototype.collectTypes = function (e, t) { if (!Array.isArray(e.enum) && !Vt(e.const)) {
            var n = e.type;
            Array.isArray(n) ? n.forEach((function (e) { return t[e] = !0; })) : n && (t[n] = !0);
        } }, e.prototype.addFillerValueCompletions = function (e, t, n) { e.object && n.add({ kind: this.getSuggestionKind("object"), label: "{}", insertText: this.getInsertTextForGuessedValue({}, t), insertTextFormat: on.Snippet, detail: Ha("defaults.object", "New object"), documentation: "" }), e.array && n.add({ kind: this.getSuggestionKind("array"), label: "[]", insertText: this.getInsertTextForGuessedValue([], t), insertTextFormat: on.Snippet, detail: Ha("defaults.array", "New array"), documentation: "" }); }, e.prototype.addBooleanValueCompletion = function (e, t, n) { n.add({ kind: this.getSuggestionKind("boolean"), label: e ? "true" : "false", insertText: this.getInsertTextForValue(e, t), insertTextFormat: on.Snippet, documentation: "" }); }, e.prototype.addNullValueCompletion = function (e, t) { t.add({ kind: this.getSuggestionKind("null"), label: "null", insertText: "null" + e, insertTextFormat: on.Snippet, documentation: "" }); }, e.prototype.addDollarSchemaCompletions = function (e, t) { var n = this, r = this.schemaService.getRegisteredSchemaIds((function (e) { return "http" === e || "https" === e; })); r.forEach((function (r) { return t.add({ kind: nn.Module, label: n.getLabelForValue(r), filterText: n.getFilterTextForValue(r), insertText: n.getInsertTextForValue(r, e), insertTextFormat: on.Snippet, documentation: "" }); })); }, e.prototype.getLabelForValue = function (e) { return JSON.stringify(e); }, e.prototype.getFilterTextForValue = function (e) { return JSON.stringify(e); }, e.prototype.getFilterTextForSnippetValue = function (e) { return JSON.stringify(e).replace(/\$\{\d+:([^}]+)\}|\$\d+/g, "$1"); }, e.prototype.getLabelForSnippetValue = function (e) { return JSON.stringify(e).replace(/\$\{\d+:([^}]+)\}|\$\d+/g, "$1"); }, e.prototype.getInsertTextForPlainText = function (e) { return e.replace(/[\\\$\}]/g, "\\$&"); }, e.prototype.getInsertTextForValue = function (e, t) { var n = JSON.stringify(e, null, "\t"); return "{}" === n ? "{$1}" + t : "[]" === n ? "[$1]" + t : this.getInsertTextForPlainText(n + t); }, e.prototype.getInsertTextForSnippetValue = function (e, t) { return za(e, "", (function (e) { return "string" == typeof e && "^" === e[0] ? e.substr(1) : JSON.stringify(e); })) + t; }, e.prototype.getInsertTextForGuessedValue = function (e, t) { switch (typeof e) {
            case "object": return null === e ? "${1:null}" + t : this.getInsertTextForValue(e, t);
            case "string":
                var n = JSON.stringify(e);
                return n = n.substr(1, n.length - 2), '"${1:' + (n = this.getInsertTextForPlainText(n)) + '}"' + t;
            case "number":
            case "boolean": return "${1:" + JSON.stringify(e) + "}" + t;
        } return this.getInsertTextForValue(e, t); }, e.prototype.getSuggestionKind = function (e) { if (Array.isArray(e)) {
            var t = e;
            e = t.length > 0 ? t[0] : void 0;
        } if (!e)
            return nn.Value; switch (e) {
            case "string":
            default: return nn.Value;
            case "object": return nn.Module;
            case "property": return nn.Property;
        } }, e.prototype.getLabelTextForMatchingNode = function (e, t) { switch (e.type) {
            case "array": return "[]";
            case "object": return "{}";
            default: return t.getText().substr(e.offset, e.length);
        } }, e.prototype.getInsertTextForMatchingNode = function (e, t, n) { switch (e.type) {
            case "array": return this.getInsertTextForValue([], n);
            case "object": return this.getInsertTextForValue({}, n);
            default:
                var r = t.getText().substr(e.offset, e.length) + n;
                return this.getInsertTextForPlainText(r);
        } }, e.prototype.getInsertTextForProperty = function (e, t, n, r) { var o = this.getInsertTextForValue(e, ""); if (!n)
            return o; var i, s = o + ": ", a = 0; if (t) {
            if (Array.isArray(t.defaultSnippets)) {
                if (1 === t.defaultSnippets.length) {
                    var u = t.defaultSnippets[0].body;
                    Vt(u) && (i = this.getInsertTextForSnippetValue(u, ""));
                }
                a += t.defaultSnippets.length;
            }
            if (t.enum && (i || 1 !== t.enum.length || (i = this.getInsertTextForGuessedValue(t.enum[0], "")), a += t.enum.length), Vt(t.default) && (i || (i = this.getInsertTextForGuessedValue(t.default, "")), a++), Array.isArray(t.examples) && t.examples.length && (i || (i = this.getInsertTextForGuessedValue(t.examples[0], "")), a += t.examples.length), 0 === a) {
                var c = Array.isArray(t.type) ? t.type[0] : t.type;
                switch (c || (t.properties ? c = "object" : t.items && (c = "array")), c) {
                    case "boolean":
                        i = "$1";
                        break;
                    case "string":
                        i = '"$1"';
                        break;
                    case "object":
                        i = "{$1}";
                        break;
                    case "array":
                        i = "[$1]";
                        break;
                    case "number":
                    case "integer":
                        i = "${1:0}";
                        break;
                    case "null":
                        i = "${1:null}";
                        break;
                    default: return o;
                }
            }
        } return (!i || a > 1) && (i = "$1"), s + i + r; }, e.prototype.getCurrentWord = function (e, t) { for (var n = t - 1, r = e.getText(); n >= 0 && -1 === ' \t\n\r\v":{[,]}'.indexOf(r.charAt(n));)
            n--; return r.substring(n + 1, t); }, e.prototype.evaluateSeparatorAfter = function (e, t) { var n = _e(e.getText(), !0); switch (n.setPosition(t), n.scan()) {
            case 5:
            case 2:
            case 4:
            case 17: return "";
            default: return ",";
        } }, e.prototype.findItemAtOffset = function (e, t, n) { for (var r = _e(t.getText(), !0), o = e.items, i = o.length - 1; i >= 0; i--) {
            var s = o[i];
            if (n > s.offset + s.length)
                return r.setPosition(s.offset + s.length), 5 === r.scan() && n >= r.getTokenOffset() + r.getTokenLength() ? i + 1 : i;
            if (n >= s.offset)
                return i;
        } return 0; }, e.prototype.isInComment = function (e, t, n) { var r = _e(e.getText(), !1); r.setPosition(t); for (var o = r.scan(); 17 !== o && r.getTokenOffset() + r.getTokenLength() < n;)
            o = r.scan(); return (12 === o || 13 === o) && r.getTokenOffset() <= n; }, e.prototype.fromMarkup = function (e) { if (e && this.doesSupportMarkdown())
            return { kind: Zt.Markdown, value: e }; }, e.prototype.doesSupportMarkdown = function () { if (!Vt(this.supportsMarkdown)) {
            var e = this.clientCapabilities.textDocument && this.clientCapabilities.textDocument.completion;
            this.supportsMarkdown = e && e.completionItem && Array.isArray(e.completionItem.documentationFormat) && -1 !== e.completionItem.documentationFormat.indexOf(Zt.Markdown);
        } return this.supportsMarkdown; }, e.prototype.doesSupportsCommitCharacters = function () { if (!Vt(this.supportsCommitCharacters)) {
            var e = this.clientCapabilities.textDocument && this.clientCapabilities.textDocument.completion;
            this.supportsCommitCharacters = e && e.completionItem && !!e.completionItem.commitCharactersSupport;
        } return this.supportsCommitCharacters; }; }();
        var Ya = _r(), Ja = function () { function e(e, t) { this.jsonSchemaService = e, this.promise = t, this.validationEnabled = !0; } return e.prototype.configure = function (e) { e && (this.validationEnabled = !1 !== e.validate, this.commentSeverity = e.allowComments ? void 0 : pt.Error); }, e.prototype.doValidation = function (e, t, n, r) { var o = this; if (!this.validationEnabled)
            return this.promise.resolve([]); var i = [], s = {}, a = function (e) { var t = e.range.start.line + " " + e.range.start.character + " " + e.message; s[t] || (s[t] = !0, i.push(e)); }, u = function (r) { var s = (null == n ? void 0 : n.trailingCommas) ? Za(n.trailingCommas) : pt.Error, u = (null == n ? void 0 : n.comments) ? Za(n.comments) : o.commentSeverity, c = (null == n ? void 0 : n.schemaValidation) ? Za(n.schemaValidation) : pt.Warning, l = (null == n ? void 0 : n.schemaRequest) ? Za(n.schemaRequest) : pt.Warning; if (r) {
            if (r.errors.length && t.root && l) {
                var p = t.root, f = "object" === p.type ? p.properties[0] : void 0;
                if (f && "$schema" === f.keyNode.value) {
                    var d = f.valueNode || f, h = He.create(e.positionAt(d.offset), e.positionAt(d.offset + d.length));
                    a(gt.create(h, r.errors[0], l, Er.SchemaResolveError));
                }
                else
                    h = He.create(e.positionAt(p.offset), e.positionAt(p.offset + 1)), a(gt.create(h, r.errors[0], l, Er.SchemaResolveError));
            }
            else if (c) {
                var m = t.validate(e, r.schema, c);
                m && m.forEach(a);
            }
            Xa(r.schema) && (u = void 0), Qa(r.schema) && (s = void 0);
        } for (var g = 0, y = t.syntaxErrors; g < y.length; g++) {
            var v = y[g];
            if (v.code === Er.TrailingComma) {
                if ("number" != typeof s)
                    continue;
                v.severity = s;
            }
            a(v);
        } if ("number" == typeof u) {
            var b = Ya("InvalidCommentToken", "Comments are not permitted in JSON.");
            t.comments.forEach((function (e) { a(gt.create(e, b, u, Er.CommentNotPermitted)); }));
        } return i; }; if (r) {
            var c = r.id || "schemaservice://untitled/" + Ga++;
            return this.jsonSchemaService.resolveSchemaContent(new Qr(r), c, {}).then((function (e) { return u(e); }));
        } return this.jsonSchemaService.getSchemaForResource(e.uri, t).then((function (e) { return u(e); })); }, e; }(), Ga = 0;
        function Xa(e) { if (e && "object" == typeof e) {
            if (Wt(e.allowComments))
                return e.allowComments;
            if (e.allOf)
                for (var t = 0, n = e.allOf; t < n.length; t++) {
                    var r = Xa(n[t]);
                    if (Wt(r))
                        return r;
                }
        } }
        function Qa(e) { if (e && "object" == typeof e) {
            if (Wt(e.allowTrailingCommas))
                return e.allowTrailingCommas;
            var t = e;
            if (Wt(t.allowsTrailingCommas))
                return t.allowsTrailingCommas;
            if (e.allOf)
                for (var n = 0, r = e.allOf; n < r.length; n++) {
                    var o = Qa(r[n]);
                    if (Wt(o))
                        return o;
                }
        } }
        function Za(e) { switch (e) {
            case "error": return pt.Error;
            case "warning": return pt.Warning;
            case "ignore": return;
        } }
        function eu(e) { return e < 48 ? 0 : e <= 57 ? e - 48 : (e < 97 && (e += 32), e >= 97 && e <= 102 ? e - 97 + 10 : 0); }
        function tu(e) { if ("#" === e[0])
            switch (e.length) {
                case 4: return { red: 17 * eu(e.charCodeAt(1)) / 255, green: 17 * eu(e.charCodeAt(2)) / 255, blue: 17 * eu(e.charCodeAt(3)) / 255, alpha: 1 };
                case 5: return { red: 17 * eu(e.charCodeAt(1)) / 255, green: 17 * eu(e.charCodeAt(2)) / 255, blue: 17 * eu(e.charCodeAt(3)) / 255, alpha: 17 * eu(e.charCodeAt(4)) / 255 };
                case 7: return { red: (16 * eu(e.charCodeAt(1)) + eu(e.charCodeAt(2))) / 255, green: (16 * eu(e.charCodeAt(3)) + eu(e.charCodeAt(4))) / 255, blue: (16 * eu(e.charCodeAt(5)) + eu(e.charCodeAt(6))) / 255, alpha: 1 };
                case 9: return { red: (16 * eu(e.charCodeAt(1)) + eu(e.charCodeAt(2))) / 255, green: (16 * eu(e.charCodeAt(3)) + eu(e.charCodeAt(4))) / 255, blue: (16 * eu(e.charCodeAt(5)) + eu(e.charCodeAt(6))) / 255, alpha: (16 * eu(e.charCodeAt(7)) + eu(e.charCodeAt(8))) / 255 };
            } }
        var nu = function () { function e(e) { this.schemaService = e; } return e.prototype.findDocumentSymbols = function (e, t, n) { var r = this; void 0 === n && (n = { resultLimit: Number.MAX_VALUE }); var o = t.root; if (!o)
            return []; var i = n.resultLimit || Number.MAX_VALUE, s = e.uri; if (("vscode://defaultsettings/keybindings.json" === s || Lt(s.toLowerCase(), "/user/keybindings.json")) && "array" === o.type) {
            for (var a = [], u = 0, c = o.items; u < c.length; u++) {
                var l = c[u];
                if ("object" === l.type)
                    for (var p = 0, f = l.properties; p < f.length; p++) {
                        var d = f[p];
                        if ("key" === d.keyNode.value && d.valueNode) {
                            var h = Je.create(e.uri, ru(e, l));
                            if (a.push({ name: Wr(d.valueNode), kind: wn.Function, location: h }), --i <= 0)
                                return n && n.onResultLimitExceeded && n.onResultLimitExceeded(s), a;
                        }
                    }
            }
            return a;
        } for (var m = [{ node: o, containerName: "" }], g = 0, y = !1, v = [], b = function (t, n) { "array" === t.type ? t.items.forEach((function (e) { e && m.push({ node: e, containerName: n }); })) : "object" === t.type && t.properties.forEach((function (t) { var o = t.valueNode; if (o)
            if (i > 0) {
                i--;
                var s = Je.create(e.uri, ru(e, t)), a = n ? n + "." + t.keyNode.value : t.keyNode.value;
                v.push({ name: r.getKeyLabel(t), kind: r.getSymbolKind(o.type), location: s, containerName: n }), m.push({ node: o, containerName: a });
            }
            else
                y = !0; })); }; g < m.length;) {
            var D = m[g++];
            b(D.node, D.containerName);
        } return y && n && n.onResultLimitExceeded && n.onResultLimitExceeded(s), v; }, e.prototype.findDocumentSymbols2 = function (e, t, n) { var r = this; void 0 === n && (n = { resultLimit: Number.MAX_VALUE }); var o = t.root; if (!o)
            return []; var i = n.resultLimit || Number.MAX_VALUE, s = e.uri; if (("vscode://defaultsettings/keybindings.json" === s || Lt(s.toLowerCase(), "/user/keybindings.json")) && "array" === o.type) {
            for (var a = [], u = 0, c = o.items; u < c.length; u++) {
                var l = c[u];
                if ("object" === l.type)
                    for (var p = 0, f = l.properties; p < f.length; p++) {
                        var d = f[p];
                        if ("key" === d.keyNode.value && d.valueNode) {
                            var h = ru(e, l), m = ru(e, d.keyNode);
                            if (a.push({ name: Wr(d.valueNode), kind: wn.Function, range: h, selectionRange: m }), --i <= 0)
                                return n && n.onResultLimitExceeded && n.onResultLimitExceeded(s), a;
                        }
                    }
            }
            return a;
        } for (var g = [], y = [{ node: o, result: g }], v = 0, b = !1, D = function (t, n) { "array" === t.type ? t.items.forEach((function (t, o) { if (t)
            if (i > 0) {
                i--;
                var s = ru(e, t), a = s, u = { name: String(o), kind: r.getSymbolKind(t.type), range: s, selectionRange: a, children: [] };
                n.push(u), y.push({ result: u.children, node: t });
            }
            else
                b = !0; })) : "object" === t.type && t.properties.forEach((function (t) { var o = t.valueNode; if (o)
            if (i > 0) {
                i--;
                var s = ru(e, t), a = ru(e, t.keyNode), u = [], c = { name: r.getKeyLabel(t), kind: r.getSymbolKind(o.type), range: s, selectionRange: a, children: u, detail: r.getDetail(o) };
                n.push(c), y.push({ result: u, node: o });
            }
            else
                b = !0; })); }; v < y.length;) {
            var E = y[v++];
            D(E.node, E.result);
        } return b && n && n.onResultLimitExceeded && n.onResultLimitExceeded(s), g; }, e.prototype.getSymbolKind = function (e) { switch (e) {
            case "object": return wn.Module;
            case "string": return wn.String;
            case "number": return wn.Number;
            case "array": return wn.Array;
            case "boolean": return wn.Boolean;
            default: return wn.Variable;
        } }, e.prototype.getKeyLabel = function (e) { var t = e.keyNode.value; return t && (t = t.replace(/[\n]/g, "↵")), t && t.trim() ? t : '"' + t + '"'; }, e.prototype.getDetail = function (e) { if (e)
            return "boolean" === e.type || "number" === e.type || "null" === e.type || "string" === e.type ? String(e.value) : "array" === e.type ? e.children.length ? void 0 : "[]" : "object" === e.type ? e.children.length ? void 0 : "{}" : void 0; }, e.prototype.findDocumentColors = function (e, t, n) { return this.schemaService.getSchemaForResource(e.uri, t).then((function (r) { var o = []; if (r)
            for (var i = n && "number" == typeof n.resultLimit ? n.resultLimit : Number.MAX_VALUE, s = {}, a = 0, u = t.getMatchingSchemas(r.schema); a < u.length; a++) {
                var c = u[a];
                if (!c.inverted && c.schema && ("color" === c.schema.format || "color-hex" === c.schema.format) && c.node && "string" === c.node.type) {
                    var l = String(c.node.offset);
                    if (!s[l]) {
                        var p = tu(Wr(c.node));
                        if (p) {
                            var f = ru(e, c.node);
                            o.push({ color: p, range: f });
                        }
                        if (s[l] = !0, --i <= 0)
                            return n && n.onResultLimitExceeded && n.onResultLimitExceeded(e.uri), o;
                    }
                }
            } return o; })); }, e.prototype.getColorPresentations = function (e, t, n, r) { var o, i = [], s = Math.round(255 * n.red), a = Math.round(255 * n.green), u = Math.round(255 * n.blue); function c(e) { var t = e.toString(16); return 2 !== t.length ? "0" + t : t; } return o = 1 === n.alpha ? "#" + c(s) + c(a) + c(u) : "#" + c(s) + c(a) + c(u) + c(Math.round(255 * n.alpha)), i.push({ label: o, textEdit: Dt.replace(r, JSON.stringify(o)) }), i; }, e; }();
        function ru(e, t) { return He.create(e.positionAt(t.offset), e.positionAt(t.offset + t.length)); }
        var ou, iu, su, au, uu, cu = _r(), lu = { schemaAssociations: [], schemas: { "http://json-schema.org/schema#": { $ref: "http://json-schema.org/draft-07/schema#" }, "http://json-schema.org/draft-04/schema#": { $schema: "http://json-schema.org/draft-04/schema#", definitions: { schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } }, positiveInteger: { type: "integer", minimum: 0 }, positiveIntegerDefault0: { allOf: [{ $ref: "#/definitions/positiveInteger" }, { default: 0 }] }, simpleTypes: { type: "string", enum: ["array", "boolean", "integer", "null", "number", "object", "string"] }, stringArray: { type: "array", items: { type: "string" }, minItems: 1, uniqueItems: !0 } }, type: "object", properties: { id: { type: "string", format: "uri" }, $schema: { type: "string", format: "uri" }, title: { type: "string" }, description: { type: "string" }, default: {}, multipleOf: { type: "number", minimum: 0, exclusiveMinimum: !0 }, maximum: { type: "number" }, exclusiveMaximum: { type: "boolean", default: !1 }, minimum: { type: "number" }, exclusiveMinimum: { type: "boolean", default: !1 }, maxLength: { allOf: [{ $ref: "#/definitions/positiveInteger" }] }, minLength: { allOf: [{ $ref: "#/definitions/positiveIntegerDefault0" }] }, pattern: { type: "string", format: "regex" }, additionalItems: { anyOf: [{ type: "boolean" }, { $ref: "#" }], default: {} }, items: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }], default: {} }, maxItems: { allOf: [{ $ref: "#/definitions/positiveInteger" }] }, minItems: { allOf: [{ $ref: "#/definitions/positiveIntegerDefault0" }] }, uniqueItems: { type: "boolean", default: !1 }, maxProperties: { allOf: [{ $ref: "#/definitions/positiveInteger" }] }, minProperties: { allOf: [{ $ref: "#/definitions/positiveIntegerDefault0" }] }, required: { allOf: [{ $ref: "#/definitions/stringArray" }] }, additionalProperties: { anyOf: [{ type: "boolean" }, { $ref: "#" }], default: {} }, definitions: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, properties: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, patternProperties: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, dependencies: { type: "object", additionalProperties: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }] } }, enum: { type: "array", minItems: 1, uniqueItems: !0 }, type: { anyOf: [{ $ref: "#/definitions/simpleTypes" }, { type: "array", items: { $ref: "#/definitions/simpleTypes" }, minItems: 1, uniqueItems: !0 }] }, format: { anyOf: [{ type: "string", enum: ["date-time", "uri", "email", "hostname", "ipv4", "ipv6", "regex"] }, { type: "string" }] }, allOf: { allOf: [{ $ref: "#/definitions/schemaArray" }] }, anyOf: { allOf: [{ $ref: "#/definitions/schemaArray" }] }, oneOf: { allOf: [{ $ref: "#/definitions/schemaArray" }] }, not: { allOf: [{ $ref: "#" }] } }, dependencies: { exclusiveMaximum: ["maximum"], exclusiveMinimum: ["minimum"] }, default: {} }, "http://json-schema.org/draft-07/schema#": { definitions: { schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } }, nonNegativeInteger: { type: "integer", minimum: 0 }, nonNegativeIntegerDefault0: { allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }] }, simpleTypes: { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] }, stringArray: { type: "array", items: { type: "string" }, uniqueItems: !0, default: [] } }, type: ["object", "boolean"], properties: { $id: { type: "string", format: "uri-reference" }, $schema: { type: "string", format: "uri" }, $ref: { type: "string", format: "uri-reference" }, $comment: { type: "string" }, title: { type: "string" }, description: { type: "string" }, default: !0, readOnly: { type: "boolean", default: !1 }, examples: { type: "array", items: !0 }, multipleOf: { type: "number", exclusiveMinimum: 0 }, maximum: { type: "number" }, exclusiveMaximum: { type: "number" }, minimum: { type: "number" }, exclusiveMinimum: { type: "number" }, maxLength: { $ref: "#/definitions/nonNegativeInteger" }, minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, pattern: { type: "string", format: "regex" }, additionalItems: { $ref: "#" }, items: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }], default: !0 }, maxItems: { $ref: "#/definitions/nonNegativeInteger" }, minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, uniqueItems: { type: "boolean", default: !1 }, contains: { $ref: "#" }, maxProperties: { $ref: "#/definitions/nonNegativeInteger" }, minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, required: { $ref: "#/definitions/stringArray" }, additionalProperties: { $ref: "#" }, definitions: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, properties: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, patternProperties: { type: "object", additionalProperties: { $ref: "#" }, propertyNames: { format: "regex" }, default: {} }, dependencies: { type: "object", additionalProperties: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }] } }, propertyNames: { $ref: "#" }, const: !0, enum: { type: "array", items: !0, minItems: 1, uniqueItems: !0 }, type: { anyOf: [{ $ref: "#/definitions/simpleTypes" }, { type: "array", items: { $ref: "#/definitions/simpleTypes" }, minItems: 1, uniqueItems: !0 }] }, format: { type: "string" }, contentMediaType: { type: "string" }, contentEncoding: { type: "string" }, if: { $ref: "#" }, then: { $ref: "#" }, else: { $ref: "#" }, allOf: { $ref: "#/definitions/schemaArray" }, anyOf: { $ref: "#/definitions/schemaArray" }, oneOf: { $ref: "#/definitions/schemaArray" }, not: { $ref: "#" } }, default: !0 } } }, pu = { id: cu("schema.json.id", "A unique identifier for the schema."), $schema: cu("schema.json.$schema", "The schema to verify this document against."), title: cu("schema.json.title", "A descriptive title of the element."), description: cu("schema.json.description", "A long description of the element. Used in hover menus and suggestions."), default: cu("schema.json.default", "A default value. Used by suggestions."), multipleOf: cu("schema.json.multipleOf", "A number that should cleanly divide the current value (i.e. have no remainder)."), maximum: cu("schema.json.maximum", "The maximum numerical value, inclusive by default."), exclusiveMaximum: cu("schema.json.exclusiveMaximum", "Makes the maximum property exclusive."), minimum: cu("schema.json.minimum", "The minimum numerical value, inclusive by default."), exclusiveMinimum: cu("schema.json.exclusiveMininum", "Makes the minimum property exclusive."), maxLength: cu("schema.json.maxLength", "The maximum length of a string."), minLength: cu("schema.json.minLength", "The minimum length of a string."), pattern: cu("schema.json.pattern", "A regular expression to match the string against. It is not implicitly anchored."), additionalItems: cu("schema.json.additionalItems", "For arrays, only when items is set as an array. If it is a schema, then this schema validates items after the ones specified by the items array. If it is false, then additional items will cause validation to fail."), items: cu("schema.json.items", "For arrays. Can either be a schema to validate every element against or an array of schemas to validate each item against in order (the first schema will validate the first element, the second schema will validate the second element, and so on."), maxItems: cu("schema.json.maxItems", "The maximum number of items that can be inside an array. Inclusive."), minItems: cu("schema.json.minItems", "The minimum number of items that can be inside an array. Inclusive."), uniqueItems: cu("schema.json.uniqueItems", "If all of the items in the array must be unique. Defaults to false."), maxProperties: cu("schema.json.maxProperties", "The maximum number of properties an object can have. Inclusive."), minProperties: cu("schema.json.minProperties", "The minimum number of properties an object can have. Inclusive."), required: cu("schema.json.required", "An array of strings that lists the names of all properties required on this object."), additionalProperties: cu("schema.json.additionalProperties", "Either a schema or a boolean. If a schema, then used to validate all properties not matched by 'properties' or 'patternProperties'. If false, then any properties not matched by either will cause this schema to fail."), definitions: cu("schema.json.definitions", "Not used for validation. Place subschemas here that you wish to reference inline with $ref."), properties: cu("schema.json.properties", "A map of property names to schemas for each property."), patternProperties: cu("schema.json.patternProperties", "A map of regular expressions on property names to schemas for matching properties."), dependencies: cu("schema.json.dependencies", "A map of property names to either an array of property names or a schema. An array of property names means the property named in the key depends on the properties in the array being present in the object in order to be valid. If the value is a schema, then the schema is only applied to the object if the property in the key exists on the object."), enum: cu("schema.json.enum", "The set of literal values that are valid."), type: cu("schema.json.type", "Either a string of one of the basic schema types (number, integer, null, array, object, boolean, string) or an array of strings specifying a subset of those types."), format: cu("schema.json.format", "Describes the format expected for the value."), allOf: cu("schema.json.allOf", "An array of schemas, all of which must match."), anyOf: cu("schema.json.anyOf", "An array of schemas, where at least one must match."), oneOf: cu("schema.json.oneOf", "An array of schemas, exactly one of which must match."), not: cu("schema.json.not", "A schema which must not match."), $id: cu("schema.json.$id", "A unique identifier for the schema."), $ref: cu("schema.json.$ref", "Reference a definition hosted on any location."), $comment: cu("schema.json.$comment", "Comments from schema authors to readers or maintainers of the schema."), readOnly: cu("schema.json.readOnly", "Indicates that the value of the instance is managed exclusively by the owning authority."), examples: cu("schema.json.examples", "Sample JSON values associated with a particular schema, for the purpose of illustrating usage."), contains: cu("schema.json.contains", 'An array instance is valid against "contains" if at least one of its elements is valid against the given schema.'), propertyNames: cu("schema.json.propertyNames", "If the instance is an object, this keyword validates if every property name in the instance validates against the provided schema."), const: cu("schema.json.const", "An instance validates successfully against this keyword if its value is equal to the value of the keyword."), contentMediaType: cu("schema.json.contentMediaType", "Describes the media type of a string property."), contentEncoding: cu("schema.json.contentEncoding", "Describes the content encoding of a string property."), if: cu("schema.json.if", 'The validation outcome of the "if" subschema controls which of the "then" or "else" keywords are evaluated.'), then: cu("schema.json.then", 'The "if" subschema is used for validation when the "if" subschema succeeds.'), else: cu("schema.json.else", 'The "else" subschema is used for validation when the "if" subschema fails.') };
        for (uu in lu.schemas)
            for (au in (ou = lu.schemas[uu]).properties)
                "boolean" == typeof (iu = ou.properties[au]) && (iu = ou.properties[au] = {}), (su = pu[au]) ? iu.description = su : a.log(au + ": localize('schema.json." + au + '\', "")');
        function fu(e, t) { var n = []; return t.visit((function (r) { var o; if ("property" === r.type && "$ref" === r.keyNode.value && "string" === (null === (o = r.valueNode) || void 0 === o ? void 0 : o.type)) {
            var i = r.valueNode.value, s = function (e, t) { var n = function (e) { return "#" === e ? [] : "#" !== e[0] || "/" !== e[1] ? null : e.substring(2).split(/\//).map(mu); }(t); return n ? hu(n, e.root) : null; }(t, i);
            if (s) {
                var a = e.positionAt(s.offset);
                n.push({ target: e.uri + "#" + (a.line + 1) + "," + (a.character + 1), range: du(e, r.valueNode) });
            }
        } return !0; })), Promise.resolve(n); }
        function du(e, t) { return He.create(e.positionAt(t.offset + 1), e.positionAt(t.offset + t.length - 1)); }
        function hu(e, t) { if (!t)
            return null; if (0 === e.length)
            return t; var n = e.shift(); if (t && "object" === t.type) {
            var r = t.properties.find((function (e) { return e.keyNode.value === n; }));
            return r ? hu(e, r.valueNode) : null;
        } if (t && "array" === t.type && n.match(/^(0|[1-9][0-9]*)$/)) {
            var o = Number.parseInt(n), i = t.items[o];
            return i ? hu(e, i) : null;
        } return null; }
        function mu(e) { return e.replace(/~1/g, "/").replace(/~0/g, "~"); }
        function gu(e, t) { for (const n of t.documents)
            if (n.internalDocument && n.internalDocument.range[0] <= e && n.internalDocument.range[2] >= e)
                return n; return 1 === t.documents.length ? t.documents[0] : null; }
        function yu(e) { const t = ["mapping", "scalar", "sequence"]; return e ? e.filter((e => { if ("string" == typeof e) {
            const n = e.split(" "), r = n[1] && n[1].toLowerCase() || "scalar";
            return "map" !== r && -1 !== t.indexOf(r);
        } return !1; })) : []; }
        function vu(e, t) { if (!t || !e)
            return !1; if (t.length !== e.length)
            return !1; for (let n = e.length - 1; n >= 0; n--)
            if (e[n] !== t[n])
                return !1; return !0; }
        var bu, Du, Eu = _r(), Cu = "Property {0} is not allowed.", wu = { "color-hex": { errorMessage: Eu("colorHexFormatWarning", "Invalid color format. Use #RGB, #RGBA, #RRGGBB or #RRGGBBAA."), pattern: /^#([0-9A-Fa-f]{3,4}|([0-9A-Fa-f]{2}){3,4})$/ }, "date-time": { errorMessage: Eu("dateTimeFormatWarning", "String is not a RFC3339 date-time."), pattern: /^(\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)([01][0-9]|2[0-3]):([0-5][0-9]))$/i }, date: { errorMessage: Eu("dateFormatWarning", "String is not a RFC3339 date."), pattern: /^(\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/i }, time: { errorMessage: Eu("timeFormatWarning", "String is not a RFC3339 time."), pattern: /^([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)([01][0-9]|2[0-3]):([0-5][0-9]))$/i }, email: { errorMessage: Eu("emailFormatWarning", "String is not an e-mail address."), pattern: /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/ } }, Au = "YAML";
        (Du = bu || (bu = {})).missingRequiredPropWarning = "missingRequiredPropWarning", Du.typeMismatchWarning = "typeMismatchWarning", Du.constWarning = "constWarning";
        var Su, xu = { [bu.missingRequiredPropWarning]: 'Missing property "{0}".', [bu.typeMismatchWarning]: 'Incorrect type. Expected "{0}".', [bu.constWarning]: "Value must be {0}." }, Tu = class {
            constructor(e, t, n, r) { this.offset = n, this.length = r, this.parent = e, this.internalNode = t; }
            getNodeFromOffsetEndInclusive(e) { const t = [], n = r => { if (e >= r.offset && e <= r.offset + r.length) {
                const o = r.children;
                for (let r = 0; r < o.length && o[r].offset <= e; r++) {
                    const e = n(o[r]);
                    e && t.push(e);
                }
                return r;
            } return null; }, r = n(this); let o = Number.MAX_VALUE, i = null; for (const n of t) {
                const t = n.length + n.offset - e + (e - n.offset);
                t < o && (i = n, o = t);
            } return i || r; }
            get children() { return []; }
            toString() { return "type: " + this.type + " (" + this.offset + "/" + this.length + ")" + (this.parent ? " parent: {" + this.parent.toString() + "}" : ""); }
        }, ku = class extends Tu {
            constructor(e, t, n, r) { super(e, t, n, r), this.type = "null", this.value = null; }
        }, Fu = class extends Tu {
            constructor(e, t, n, r, o) { super(e, t, r, o), this.type = "boolean", this.value = n; }
        }, Ou = class extends Tu {
            constructor(e, t, n, r) { super(e, t, n, r), this.type = "array", this.items = []; }
            get children() { return this.items; }
        }, _u = class extends Tu {
            constructor(e, t, n, r) { super(e, t, n, r), this.type = "number", this.isInteger = !0, this.value = Number.NaN; }
        }, Nu = class extends Tu {
            constructor(e, t, n, r) { super(e, t, n, r), this.type = "string", this.value = ""; }
        }, Pu = class extends Tu {
            constructor(e, t, n, r) { super(e, t, n, r), this.type = "property", this.colonOffset = -1; }
            get children() { return this.valueNode ? [this.keyNode, this.valueNode] : [this.keyNode]; }
        }, Mu = class extends Tu {
            constructor(e, t, n, r) { super(e, t, n, r), this.type = "object", this.properties = []; }
            get children() { return this.properties; }
        };
        function Ru(e) { if (void 0 !== e)
            return ja(e) ? e ? {} : { not: {} } : ("object" != typeof e && (a.warn(`Wrong schema: ${JSON.stringify(e)}, it MUST be an Object or Boolean`), e = { type: e }), e); }
        !function (e) { e[e.Key = 0] = "Key", e[e.Enum = 1] = "Enum"; }(Su || (Su = {}));
        var Iu = class {
            constructor(e = -1, t = null) { this.focusOffset = e, this.exclude = t, this.schemas = []; }
            add(e) { this.schemas.push(e); }
            merge(e) { this.schemas.push(...e.schemas); }
            include(e) { return (-1 === this.focusOffset || qu(e, this.focusOffset)) && e !== this.exclude; }
            newSub() { return new Iu(-1, this.exclude); }
        }, ju = class {
            constructor() { }
            get schemas() { return []; }
            add(e) { }
            merge(e) { }
            include(e) { return !0; }
            newSub() { return this; }
        };
        ju.instance = new ju;
        var Bu = class {
            constructor(e) { this.problems = [], this.propertiesMatches = 0, this.propertiesValueMatches = 0, this.primaryValueMatches = 0, this.enumValueMatch = !1, this.enumValues = e ? [] : null; }
            hasProblems() { return !!this.problems.length; }
            mergeAll(e) { for (const t of e)
                this.merge(t); }
            merge(e) { this.problems = this.problems.concat(e.problems); }
            mergeEnumValues(e) { if (!this.enumValueMatch && !e.enumValueMatch && this.enumValues && e.enumValues) {
                this.enumValues = this.enumValues.concat(e.enumValues);
                for (const e of this.problems)
                    e.code === Er.EnumValueMismatch && (e.message = Eu("enumWarning", "Value is not accepted. Valid values: {0}.", [...new Set(this.enumValues)].map((e => JSON.stringify(e))).join(", ")));
            } }
            mergeWarningGeneric(e, t) { var n, r; if (null == (n = this.problems) ? void 0 : n.length)
                for (const n of t) {
                    const t = this.problems.filter((e => e.problemType === n));
                    for (const o of t) {
                        const t = null == (r = e.problems) ? void 0 : r.find((e => e.problemType === n && o.location.offset === e.location.offset && (n !== bu.missingRequiredPropWarning || vu(e.problemArgs, o.problemArgs))));
                        t && (t.problemArgs.length && (t.problemArgs.filter((e => !o.problemArgs.includes(e))).forEach((e => o.problemArgs.push(e))), o.message = zu(o.problemType, o.problemArgs)), this.mergeSources(t, o));
                    }
                } }
            mergePropertyMatch(e) { this.merge(e), this.propertiesMatches++, (e.enumValueMatch || !e.hasProblems() && e.propertiesMatches) && this.propertiesValueMatches++, e.enumValueMatch && e.enumValues && this.primaryValueMatches++; }
            mergeSources(e, t) { const n = e.source.replace("yaml-schema: ", ""); t.source.includes(n) || (t.source = t.source + " | " + n), t.schemaUri.includes(e.schemaUri[0]) || (t.schemaUri = t.schemaUri.concat(e.schemaUri)); }
            compareGeneric(e) { const t = this.hasProblems(); return t !== e.hasProblems() ? t ? -1 : 1 : this.enumValueMatch !== e.enumValueMatch ? e.enumValueMatch ? -1 : 1 : this.propertiesValueMatches !== e.propertiesValueMatches ? this.propertiesValueMatches - e.propertiesValueMatches : this.primaryValueMatches !== e.primaryValueMatches ? this.primaryValueMatches - e.primaryValueMatches : this.propertiesMatches - e.propertiesMatches; }
            compareKubernetes(e) { const t = this.hasProblems(); return this.propertiesMatches !== e.propertiesMatches ? this.propertiesMatches - e.propertiesMatches : this.enumValueMatch !== e.enumValueMatch ? e.enumValueMatch ? -1 : 1 : this.primaryValueMatches !== e.primaryValueMatches ? this.primaryValueMatches - e.primaryValueMatches : this.propertiesValueMatches !== e.propertiesValueMatches ? this.propertiesValueMatches - e.propertiesValueMatches : t !== e.hasProblems() ? t ? -1 : 1 : this.propertiesMatches - e.propertiesMatches; }
        };
        function Lu(e) { switch (e.type) {
            case "array": return e.children.map(Lu);
            case "object": {
                const t = Object.create(null);
                for (let n = 0, r = e.children; n < r.length; n++) {
                    const e = r[n], o = e.children[1];
                    o && (t[e.children[0].value] = Lu(o));
                }
                return t;
            }
            case "null":
            case "string":
            case "number":
            case "boolean": return e.value;
            default: return;
        } }
        function qu(e, t, n = !1) { return t >= e.offset && t <= e.offset + e.length || n && t === e.offset + e.length; }
        function $u(e, t, n) { if (void 0 === n && (n = !1), qu(e, t, n)) {
            const r = e.children;
            if (Array.isArray(r))
                for (let e = 0; e < r.length && r[e].offset <= t; e++) {
                    const o = $u(r[e], t, n);
                    if (o)
                        return o;
                }
            return e;
        } }
        var Uu = class {
            constructor(e, t = [], n = []) { this.root = e, this.syntaxErrors = t, this.comments = n; }
            getNodeFromOffset(e, t = !1) { if (this.root)
                return $u(this.root, e, t); }
            getNodeFromOffsetEndInclusive(e) { return this.root && this.root.getNodeFromOffsetEndInclusive(e); }
            visit(e) { if (this.root) {
                const t = n => { let r = e(n); const o = n.children; if (Array.isArray(o))
                    for (let e = 0; e < o.length && r; e++)
                        r = t(o[e]); return r; };
                t(this.root);
            } }
            validate(e, t) { if (this.root && t) {
                const n = new Bu(this.isKubernetes);
                return Vu(this.root, t, t, n, ju.instance, { isKubernetes: this.isKubernetes, disableAdditionalProperties: this.disableAdditionalProperties, uri: this.uri }), n.problems.map((t => { const n = He.create(e.positionAt(t.location.offset), e.positionAt(t.location.offset + t.location.length)), r = gt.create(n, t.message, t.severity, t.code ? t.code : Er.Undefined, t.source); return r.data = { schemaUri: t.schemaUri, ...t.data }, r; }));
            } return null; }
            getMatchingSchemas(e, t = -1, n = null, r) { const o = new Iu(t, n); return this.root && e && Vu(this.root, e, e, new Bu(this.isKubernetes), o, { isKubernetes: this.isKubernetes, disableAdditionalProperties: this.disableAdditionalProperties, uri: this.uri, callFromAutoComplete: r }), o.schemas; }
        };
        function Vu(e, t, n, r, o, i) { const { isKubernetes: s, callFromAutoComplete: a } = i; if (e && "object" == typeof t) {
            switch (t.url || (t.url = n.url), t.closestTitle = t.title || n.closestTitle, e.type) {
                case "object":
                    !function (e, t, r, o) { var a; const u = Object.create(null), c = [], l = [...e.properties]; for (; l.length > 0;) {
                        const e = l.pop(), t = e.keyNode.value;
                        if ("<<" === t && e.valueNode)
                            switch (e.valueNode.type) {
                                case "object":
                                    l.push(...e.valueNode.properties);
                                    break;
                                case "array": e.valueNode.items.forEach((e => { var t; e && (t = e.properties, Symbol.iterator in Object(t)) && l.push(...e.properties); }));
                            }
                        else
                            u[t] = e.valueNode, c.push(t);
                    } if (Array.isArray(t.required))
                        for (const o of t.required)
                            if (void 0 === u[o]) {
                                const i = e.parent && "property" === e.parent.type && e.parent.keyNode, s = i ? { offset: i.offset, length: i.length } : { offset: e.offset, length: 1 };
                                r.problems.push({ location: s, severity: pt.Warning, message: zu(bu.missingRequiredPropWarning, [o]), source: Wu(t, n), schemaUri: Ku(t, n), problemArgs: [o], problemType: bu.missingRequiredPropWarning });
                            } const p = e => { let t = c.indexOf(e); for (; t >= 0;)
                        c.splice(t, 1), t = c.indexOf(e); }; if (t.properties)
                        for (const e of Object.keys(t.properties)) {
                            p(e);
                            const c = t.properties[e], l = u[e];
                            if (l)
                                if (ja(c))
                                    if (c)
                                        r.propertiesMatches++, r.propertiesValueMatches++;
                                    else {
                                        const o = l.parent;
                                        r.problems.push({ location: { offset: o.keyNode.offset, length: o.keyNode.length }, severity: pt.Warning, message: t.errorMessage || Eu("DisallowedExtraPropWarning", Cu, e), source: Wu(t, n), schemaUri: Ku(t, n) });
                                    }
                                else {
                                    c.url = null != (a = t.url) ? a : n.url;
                                    const e = new Bu(s);
                                    Vu(l, c, t, e, o, i), r.mergePropertyMatch(e), r.mergeEnumValues(e);
                                }
                        } if (t.patternProperties)
                        for (const e of Object.keys(t.patternProperties)) {
                            const a = oo(e);
                            for (const l of c.slice(0))
                                if (a.test(l)) {
                                    p(l);
                                    const a = u[l];
                                    if (a) {
                                        const u = t.patternProperties[e];
                                        if (ja(u))
                                            if (u)
                                                r.propertiesMatches++, r.propertiesValueMatches++;
                                            else {
                                                const e = a.parent;
                                                r.problems.push({ location: { offset: e.keyNode.offset, length: e.keyNode.length }, severity: pt.Warning, message: t.errorMessage || Eu("DisallowedExtraPropWarning", Cu, l), source: Wu(t, n), schemaUri: Ku(t, n) });
                                            }
                                        else {
                                            const e = new Bu(s);
                                            Vu(a, u, t, e, o, i), r.mergePropertyMatch(e), r.mergeEnumValues(e);
                                        }
                                    }
                                }
                        } if ("object" == typeof t.additionalProperties)
                        for (const e of c) {
                            const n = u[e];
                            if (n) {
                                const e = new Bu(s);
                                Vu(n, t.additionalProperties, t, e, o, i), r.mergePropertyMatch(e), r.mergeEnumValues(e);
                            }
                        }
                    else if ((!1 === t.additionalProperties || "object" === t.type && void 0 === t.additionalProperties && !0 === i.disableAdditionalProperties) && c.length > 0) {
                        const e = t.properties && Object.keys(t.properties).filter((e => !u[e]));
                        for (const o of c) {
                            const i = u[o];
                            if (i) {
                                let s = null;
                                "property" !== i.type ? (s = i.parent, "object" === s.type && (s = s.properties[0])) : s = i;
                                const a = { location: { offset: s.keyNode.offset, length: s.keyNode.length }, severity: pt.Warning, message: t.errorMessage || Eu("DisallowedExtraPropWarning", Cu, o), source: Wu(t, n), schemaUri: Ku(t, n) };
                                (null == e ? void 0 : e.length) && (a.data = { properties: e }), r.problems.push(a);
                            }
                        }
                    } if (Ra(t.maxProperties) && e.properties.length > t.maxProperties && r.problems.push({ location: { offset: e.offset, length: e.length }, severity: pt.Warning, message: Eu("MaxPropWarning", "Object has more properties than limit of {0}.", t.maxProperties), source: Wu(t, n), schemaUri: Ku(t, n) }), Ra(t.minProperties) && e.properties.length < t.minProperties && r.problems.push({ location: { offset: e.offset, length: e.length }, severity: pt.Warning, message: Eu("MinPropWarning", "Object has fewer properties than the required number of {0}", t.minProperties), source: Wu(t, n), schemaUri: Ku(t, n) }), t.dependencies)
                        for (const a of Object.keys(t.dependencies))
                            if (u[a]) {
                                const c = t.dependencies[a];
                                if (Array.isArray(c))
                                    for (const o of c)
                                        u[o] ? r.propertiesValueMatches++ : r.problems.push({ location: { offset: e.offset, length: e.length }, severity: pt.Warning, message: Eu("RequiredDependentPropWarning", "Object is missing property {0} required by property {1}.", o, a), source: Wu(t, n), schemaUri: Ku(t, n) });
                                else {
                                    const n = Ru(c);
                                    if (n) {
                                        const a = new Bu(s);
                                        Vu(e, n, t, a, o, i), r.mergePropertyMatch(a), r.mergeEnumValues(a);
                                    }
                                }
                            } const f = Ru(t.propertyNames); if (f)
                        for (const n of e.properties) {
                            const e = n.keyNode;
                            e && Vu(e, f, t, r, ju.instance, i);
                        } }(e, t, r, o);
                    break;
                case "array":
                    !function (e, t, r, o) { if (Array.isArray(t.items)) {
                        const a = t.items;
                        for (let n = 0; n < a.length; n++) {
                            const u = Ru(a[n]), c = new Bu(s), l = e.items[n];
                            l ? (Vu(l, u, t, c, o, i), r.mergePropertyMatch(c), r.mergeEnumValues(c)) : e.items.length >= a.length && r.propertiesValueMatches++;
                        }
                        if (e.items.length > a.length)
                            if ("object" == typeof t.additionalItems)
                                for (let n = a.length; n < e.items.length; n++) {
                                    const a = new Bu(s);
                                    Vu(e.items[n], t.additionalItems, t, a, o, i), r.mergePropertyMatch(a), r.mergeEnumValues(a);
                                }
                            else
                                !1 === t.additionalItems && r.problems.push({ location: { offset: e.offset, length: e.length }, severity: pt.Warning, message: Eu("additionalItemsWarning", "Array has too many items according to schema. Expected {0} or fewer.", a.length), source: Wu(t, n), schemaUri: Ku(t, n) });
                    }
                    else {
                        const n = Ru(t.items);
                        if (n) {
                            const a = new Bu(s);
                            e.items.forEach((e => { if (n.oneOf && 1 === n.oneOf.length) {
                                const s = { ...Ru(n.oneOf[0]) };
                                s.title = t.title, s.closestTitle = t.closestTitle, Vu(e, s, t, a, o, i), r.mergePropertyMatch(a), r.mergeEnumValues(a);
                            }
                            else
                                Vu(e, n, t, a, o, i), r.mergePropertyMatch(a), r.mergeEnumValues(a); }));
                        }
                    } const a = Ru(t.contains); if (a && (e.items.some((e => { const n = new Bu(s); return Vu(e, a, t, n, ju.instance, i), !n.hasProblems(); })) || r.problems.push({ location: { offset: e.offset, length: e.length }, severity: pt.Warning, message: t.errorMessage || Eu("requiredItemMissingWarning", "Array does not contain required item."), source: Wu(t, n), schemaUri: Ku(t, n) })), Ra(t.minItems) && e.items.length < t.minItems && r.problems.push({ location: { offset: e.offset, length: e.length }, severity: pt.Warning, message: Eu("minItemsWarning", "Array has too few items. Expected {0} or more.", t.minItems), source: Wu(t, n), schemaUri: Ku(t, n) }), Ra(t.maxItems) && e.items.length > t.maxItems && r.problems.push({ location: { offset: e.offset, length: e.length }, severity: pt.Warning, message: Eu("maxItemsWarning", "Array has too many items. Expected {0} or fewer.", t.maxItems), source: Wu(t, n), schemaUri: Ku(t, n) }), !0 === t.uniqueItems) {
                        const o = Lu(e);
                        o.some(((e, t) => t !== o.lastIndexOf(e))) && r.problems.push({ location: { offset: e.offset, length: e.length }, severity: pt.Warning, message: Eu("uniqueItemsWarning", "Array has duplicate items."), source: Wu(t, n), schemaUri: Ku(t, n) });
                    } }(e, t, r, o);
                    break;
                case "string":
                    !function (e, t, r) { if (Ra(t.minLength) && e.value.length < t.minLength && r.problems.push({ location: { offset: e.offset, length: e.length }, severity: pt.Warning, message: Eu("minLengthWarning", "String is shorter than the minimum length of {0}.", t.minLength), source: Wu(t, n), schemaUri: Ku(t, n) }), Ra(t.maxLength) && e.value.length > t.maxLength && r.problems.push({ location: { offset: e.offset, length: e.length }, severity: pt.Warning, message: Eu("maxLengthWarning", "String is longer than the maximum length of {0}.", t.maxLength), source: Wu(t, n), schemaUri: Ku(t, n) }), Ba(t.pattern) && (oo(t.pattern).test(e.value) || r.problems.push({ location: { offset: e.offset, length: e.length }, severity: pt.Warning, message: t.patternErrorMessage || t.errorMessage || Eu("patternWarning", 'String does not match the pattern of "{0}".', t.pattern), source: Wu(t, n), schemaUri: Ku(t, n) })), t.format)
                        switch (t.format) {
                            case "uri":
                            case "uri-reference":
                                {
                                    let o;
                                    if (e.value)
                                        try {
                                            It.parse(e.value).scheme || "uri" !== t.format || (o = Eu("uriSchemeMissing", "URI with a scheme is expected."));
                                        }
                                        catch (e) {
                                            o = e.message;
                                        }
                                    else
                                        o = Eu("uriEmpty", "URI expected.");
                                    o && r.problems.push({ location: { offset: e.offset, length: e.length }, severity: pt.Warning, message: t.patternErrorMessage || t.errorMessage || Eu("uriFormatWarning", "String is not a URI: {0}", o), source: Wu(t, n), schemaUri: Ku(t, n) });
                                }
                                break;
                            case "color-hex":
                            case "date-time":
                            case "date":
                            case "time":
                            case "email": {
                                const o = wu[t.format];
                                e.value && o.pattern.exec(e.value) || r.problems.push({ location: { offset: e.offset, length: e.length }, severity: pt.Warning, message: t.patternErrorMessage || t.errorMessage || o.errorMessage, source: Wu(t, n), schemaUri: Ku(t, n) });
                            }
                        } }(e, t, r);
                    break;
                case "number":
                    !function (e, t, r) { const o = e.value; function i(e, t) { return Ra(t) ? t : ja(t) && t ? e : void 0; } function s(e, t) { if (!ja(t) || !t)
                        return e; } Ra(t.multipleOf) && o % t.multipleOf != 0 && r.problems.push({ location: { offset: e.offset, length: e.length }, severity: pt.Warning, message: Eu("multipleOfWarning", "Value is not divisible by {0}.", t.multipleOf), source: Wu(t, n), schemaUri: Ku(t, n) }); const a = i(t.minimum, t.exclusiveMinimum); Ra(a) && o <= a && r.problems.push({ location: { offset: e.offset, length: e.length }, severity: pt.Warning, message: Eu("exclusiveMinimumWarning", "Value is below the exclusive minimum of {0}.", a), source: Wu(t, n), schemaUri: Ku(t, n) }); const u = i(t.maximum, t.exclusiveMaximum); Ra(u) && o >= u && r.problems.push({ location: { offset: e.offset, length: e.length }, severity: pt.Warning, message: Eu("exclusiveMaximumWarning", "Value is above the exclusive maximum of {0}.", u), source: Wu(t, n), schemaUri: Ku(t, n) }); const c = s(t.minimum, t.exclusiveMinimum); Ra(c) && o < c && r.problems.push({ location: { offset: e.offset, length: e.length }, severity: pt.Warning, message: Eu("minimumWarning", "Value is below the minimum of {0}.", c), source: Wu(t, n), schemaUri: Ku(t, n) }); const l = s(t.maximum, t.exclusiveMaximum); Ra(l) && o > l && r.problems.push({ location: { offset: e.offset, length: e.length }, severity: pt.Warning, message: Eu("maximumWarning", "Value is above the maximum of {0}.", l), source: Wu(t, n), schemaUri: Ku(t, n) }); }(e, t, r);
                    break;
                case "property": return Vu(e.valueNode, t, t, r, o, i);
            }
            !function () { function l(t) { return e.type === t || "integer" === t && "number" === e.type && e.isInteger; } if (Array.isArray(t.type))
                t.type.some(l) || r.problems.push({ location: { offset: e.offset, length: e.length }, severity: pt.Warning, message: t.errorMessage || Eu("typeArrayMismatchWarning", "Incorrect type. Expected one of {0}.", t.type.join(", ")), source: Wu(t, n), schemaUri: Ku(t, n) });
            else if (t.type && !l(t.type)) {
                const o = "object" === t.type ? $a(t) : t.type;
                r.problems.push({ location: { offset: e.offset, length: e.length }, severity: pt.Warning, message: t.errorMessage || zu(bu.typeMismatchWarning, [o]), source: Wu(t, n), schemaUri: Ku(t, n), problemType: bu.typeMismatchWarning, problemArgs: [o] });
            } if (Array.isArray(t.allOf))
                for (const n of t.allOf)
                    Vu(e, Ru(n), t, r, o, i); const p = Ru(t.not); if (p) {
                const a = new Bu(s), u = o.newSub();
                Vu(e, p, t, a, u, i), a.hasProblems() || r.problems.push({ location: { offset: e.offset, length: e.length }, severity: pt.Warning, message: Eu("notSchemaWarning", "Matches a schema that is not allowed."), source: Wu(t, n), schemaUri: Ku(t, n) });
                for (const e of u.schemas)
                    e.inverted = !e.inverted, o.add(e);
            } const f = (l, p) => { const f = [], d = [], h = []; let m = null; for (const n of l) {
                const r = { ...Ru(n) }, l = new Bu(s), g = o.newSub();
                Vu(e, r, t, l, g, i), l.hasProblems() && !a || (f.push(r), d.push(r), 0 === l.propertiesMatches && h.push(r), r.format && d.pop()), m = m ? s ? u(l, m, r, g) : c(e, p, l, m, r, g) : { schema: r, validationResult: l, matchingSchemas: g };
            } return d.length > 1 && (d.length > 1 || 0 === h.length) && p && r.problems.push({ location: { offset: e.offset, length: 1 }, severity: pt.Warning, message: Eu("oneOfWarning", "Matches multiple schemas when only one must validate."), source: Wu(t, n), schemaUri: Ku(t, n) }), null !== m && (r.merge(m.validationResult), r.propertiesMatches += m.validationResult.propertiesMatches, r.propertiesValueMatches += m.validationResult.propertiesValueMatches, o.merge(m.matchingSchemas)), f.length; }; Array.isArray(t.anyOf) && f(t.anyOf, !1), Array.isArray(t.oneOf) && f(t.oneOf, !0); const d = (t, n) => { const a = new Bu(s), u = o.newSub(); Vu(e, Ru(t), n, a, u, i), r.merge(a), r.propertiesMatches += a.propertiesMatches, r.propertiesValueMatches += a.propertiesValueMatches, o.merge(u); }, h = Ru(t.if); if (h && ((n, r, a, u) => { const c = Ru(n), l = new Bu(s), p = o.newSub(); Vu(e, c, r, l, p, i), o.merge(p); const { filePatternAssociation: f } = c; f && (new hc(f).matchesPattern(i.uri) || l.problems.push({ location: { offset: e.offset, length: e.length }, severity: pt.Warning, message: Eu("ifFilePatternAssociation", `filePatternAssociation '${f}' does not match with doc uri '${i.uri}'.`), source: Wu(t, r), schemaUri: Ku(t, r) })), l.hasProblems() ? u && d(u, r) : a && d(a, r); })(h, t, Ru(t.then), Ru(t.else)), Array.isArray(t.enum)) {
                const o = Lu(e);
                let i = !1;
                for (const e of t.enum)
                    if (Ma(o, e) || a && Ba(o) && Ba(e) && o && e.startsWith(o)) {
                        i = !0;
                        break;
                    }
                r.enumValues = t.enum, r.enumValueMatch = i, i || r.problems.push({ location: { offset: e.offset, length: e.length }, severity: pt.Warning, code: Er.EnumValueMismatch, message: t.errorMessage || Eu("enumWarning", "Value is not accepted. Valid values: {0}.", t.enum.map((e => JSON.stringify(e))).join(", ")), source: Wu(t, n), schemaUri: Ku(t, n) });
            } Ia(t.const) && (Ma(Lu(e), t.const) ? r.enumValueMatch = !0 : (r.problems.push({ location: { offset: e.offset, length: e.length }, severity: pt.Warning, code: Er.EnumValueMismatch, problemType: bu.constWarning, message: t.errorMessage || zu(bu.constWarning, [JSON.stringify(t.const)]), source: Wu(t, n), schemaUri: Ku(t, n), problemArgs: [JSON.stringify(t.const)] }), r.enumValueMatch = !1), r.enumValues = [t.const]), t.deprecationMessage && e.parent && r.problems.push({ location: { offset: e.parent.offset, length: e.parent.length }, severity: pt.Warning, message: t.deprecationMessage, source: Wu(t, n), schemaUri: Ku(t, n) }); }(), o.add({ node: e, schema: t });
        } function u(e, t, n, r) { const o = e.compareKubernetes(t.validationResult); return o > 0 ? t = { schema: n, validationResult: e, matchingSchemas: r } : 0 === o && (t.matchingSchemas.merge(r), t.validationResult.mergeEnumValues(e)), t; } function c(e, t, n, r, o, i) { if (t || n.hasProblems() || r.validationResult.hasProblems() && !a) {
            const s = n.compareGeneric(r.validationResult);
            s > 0 || 0 === s && t && "object" === r.schema.type && "null" !== e.type && e.type !== r.schema.type ? r = { schema: o, validationResult: n, matchingSchemas: i } : 0 === s && (r.matchingSchemas.merge(i), r.validationResult.mergeEnumValues(n), r.validationResult.mergeWarningGeneric(n, [bu.missingRequiredPropWarning, bu.typeMismatchWarning, bu.constWarning]));
        }
        else
            r.matchingSchemas.merge(i), r.validationResult.propertiesMatches += n.propertiesMatches, r.validationResult.propertiesValueMatches += n.propertiesValueMatches; return r; } }
        function Wu(e, t) { var n; if (e) {
            let r;
            if (e.title)
                r = e.title;
            else if (e.closestTitle)
                r = e.closestTitle;
            else if (t.closestTitle)
                r = t.closestTitle;
            else {
                const o = null != (n = e.url) ? n : t.url;
                if (o) {
                    const e = It.parse(o);
                    "file" === e.scheme && (r = e.fsPath), r = e.toString();
                }
            }
            if (r)
                return `yaml-schema: ${r}`;
        } return Au; }
        function Ku(e, t) { var n; const r = null != (n = e.url) ? n : t.url; return r ? [r] : []; }
        function zu(e, t) { return Eu(e, xu[e], t.join(" | ")); }
        var Hu = 0;
        function Yu(e, t, n, r) { if (e || (Hu = 0), !t)
            return null; if (go(t))
            return function (e, t, n, r) { let o; o = e.flow && !e.range ? function (e) { let t = Number.MAX_SAFE_INTEGER, n = 0; for (const r of e.items)
                yo(r) && (Eo(r.key) && r.key.range && r.key.range[0] <= t && (t = r.key.range[0]), Eo(r.value) && r.value.range && r.value.range[2] >= n && (n = r.value.range[2])); return [t, n, n]; }(e) : e.range; const i = new Mu(t, e, ...Gu(o, r)); for (const t of e.items)
                yo(t) && i.properties.push(Yu(i, t, n, r)); return i; }(t, e, n, r); if (yo(t))
            return function (e, t, n, r) { const o = e.key, i = e.value, s = o.range[0]; let a = o.range[1], u = o.range[2]; i && (a = i.range[1], u = i.range[2]); const c = new Pu(t, e, ...Gu([s, a, u], r)); if (ho(o)) {
                const e = new Nu(t, o, ...Ju(o.range));
                e.value = o.source, c.keyNode = e;
            }
            else
                c.keyNode = Yu(c, o, n, r); return c.valueNode = Yu(c, i, n, r), c; }(t, e, n, r); if (bo(t))
            return function (e, t, n, r) { const o = new Ou(t, e, ...Ju(e.range)); for (const t of e.items)
                if (Eo(t)) {
                    const e = Yu(o, t, n, r);
                    e && o.children.push(e);
                } return o; }(t, e, n, r); if (vo(t))
            return function (e, t) { if (null === e.value)
                return new ku(t, e, ...Ju(e.range)); switch (typeof e.value) {
                case "string": {
                    const n = new Nu(t, e, ...Ju(e.range));
                    return n.value = e.value, n;
                }
                case "boolean": return new Fu(t, e, e.value, ...Ju(e.range));
                case "number": {
                    const n = new _u(t, e, ...Ju(e.range));
                    return n.value = e.value, n.isInteger = Number.isInteger(n.value), n;
                }
                default: {
                    const n = new Nu(t, e, ...Ju(e.range));
                    return n.value = e.source, n;
                }
            } }(t, e); if (ho(t)) {
            if (Hu > 1e3)
                return;
            return function (e, t, n, r) { Hu++; const o = e.resolve(n); if (o)
                return Yu(t, o, n, r); {
                const n = new Nu(t, e, ...Ju(e.range));
                return n.value = e.source, n;
            } }(t, e, n, r);
        } }
        function Ju(e) { return [e[0], e[1] - e[0]]; }
        function Gu(e, t) { const n = t.linePos(e[0]), r = t.linePos(e[1]), o = [e[0], e[1] - e[0]]; return n.line === r.line || t.lineStarts.length === r.line && 1 !== r.col || o[1]--, o; }
        function Xu(e) { return void 0 !== e.start; }
        function Qu(e, t, n) { let r = n(t, e); if ("symbol" == typeof r)
            return r; for (const o of ["key", "value"]) {
            const i = t[o];
            if (i && "items" in i) {
                for (let t = 0; t < i.items.length; ++t) {
                    const r = Qu(Object.freeze(e.concat([[o, t]])), i.items[t], n);
                    if ("number" == typeof r)
                        t = r - 1;
                    else {
                        if (r === xo.BREAK)
                            return xo.BREAK;
                        r === xo.REMOVE && (i.items.splice(t, 1), t -= 1);
                    }
                }
                "function" == typeof r && "key" === o && (r = r(t, e));
            }
        } const o = t.sep; if (o)
            for (let t = 0; t < o.length; ++t) {
                const r = Qu(Object.freeze(e), o[t], n);
                if ("number" == typeof r)
                    t = r - 1;
                else {
                    if (r === xo.BREAK)
                        return xo.BREAK;
                    r === xo.REMOVE && (o.items.splice(t, 1), t -= 1);
                }
            } return "function" == typeof r ? r(t, e) : r; }
        var Zu = class extends Uu {
            constructor(e) { super(null, []), this.lineCounter = e; }
            clone() { const e = new Zu(this.lineCounter); return e.isKubernetes = this.isKubernetes, e.disableAdditionalProperties = this.disableAdditionalProperties, e.uri = this.uri, e.currentDocIndex = this.currentDocIndex, e._lineComments = this.lineComments.slice(), e.internalDocument = this._internalDocument.clone(), e; }
            collectLineComments() { this._lineComments = [], this._internalDocument.commentBefore && this._internalDocument.commentBefore.split("\n").forEach((e => this._lineComments.push(`#${e}`))), xo(this.internalDocument, ((e, t) => { (null == t ? void 0 : t.commentBefore) && (null == t ? void 0 : t.commentBefore.split("\n")).forEach((e => this._lineComments.push(`#${e}`))), (null == t ? void 0 : t.comment) && this._lineComments.push(`#${t.comment}`); })), this._internalDocument.comment && this._lineComments.push(`#${this._internalDocument.comment}`); }
            set internalDocument(e) { this._internalDocument = e, this.root = Yu(null, this._internalDocument.contents, this._internalDocument, this.lineCounter); }
            get internalDocument() { return this._internalDocument; }
            get lineComments() { return this._lineComments || this.collectLineComments(), this._lineComments; }
            set lineComments(e) { this._lineComments = e; }
            get errors() { return this.internalDocument.errors.map(nc); }
            get warnings() { return this.internalDocument.warnings.map(nc); }
            getNodeFromPosition(e, t, n) { const r = t.getPosition(e), o = t.getLineContent(r.line); if (0 === o.trim().length)
                return [this.findClosestNode(e, t, n), !0]; const i = o.substring(r.character).match(/^([ ]+)\n?$/), s = !!i, a = null == i ? void 0 : i[1].length; let u; return xo(this.internalDocument, ((t, n) => { if (!n)
                return; const r = n.range; return r ? r[0] <= e && r[1] >= e || s && e + a === r[2] && vo(n) && null === n.value ? void (u = n) : xo.SKIP : void 0; })), [u, !1]; }
            findClosestNode(e, t, n) { let r, o = this.internalDocument.range[2], i = this.internalDocument.range[0]; xo(this.internalDocument, ((t, n) => { if (!n)
                return; const s = n.range; if (!s)
                return; const a = s[1] - e; i <= s[0] && a <= 0 && Math.abs(a) <= o && (o = Math.abs(a), i = s[0], r = n); })); const s = t.getPosition(e), a = function (e, t) { if (e.length < t)
                return 0; for (let n = 0; n < t; n++) {
                const t = e.charCodeAt(n);
                if (32 !== t && 9 !== t)
                    return n;
            } return t; }(t.getLineContent(s.line), s.character); return vo(r) && null === r.value || a === s.character && (r = this.getProperParentByIndentation(a, r, t, "", n)), r; }
            getProperParentByIndentation(e, t, n, r, o, i) { if (!t)
                return this.internalDocument.contents; if (o = o || 2, Eo(t) && t.range) {
                const s = n.getPosition(t.range[0]), a = n.getLineContent(s.line);
                if ((r = "" === r ? a.trim() : r).startsWith("-") && e === o && r === a.trim() && (s.character += e), s.character > e && s.character > 0) {
                    const s = this.getParent(t);
                    if (s)
                        return this.getProperParentByIndentation(e, s, n, r, o, i);
                }
                else {
                    if (!(s.character < e))
                        return t;
                    {
                        const e = this.getParent(t);
                        if (yo(e) && Eo(e.value))
                            return e.value;
                        if (yo(i) && Eo(i.value))
                            return i.value;
                    }
                }
            }
            else if (yo(t)) {
                i = t;
                const s = this.getParent(t);
                return this.getProperParentByIndentation(e, s, n, r, o, i);
            } return t; }
            getParent(e) { return function (e, t) { let n; if (xo(e, ((e, r, o) => { if (r === t)
                return n = o[o.length - 1], xo.BREAK; })), !mo(n))
                return n; }(this.internalDocument, e); }
        }, ec = class {
            constructor(e, t) { this.documents = e, this.tokens = t, this.errors = [], this.warnings = []; }
        }, tc = new class {
            constructor() { this.cache = new Map; }
            getYamlDocument(e, t, n = !1) { return this.ensureCache(e, null != t ? t : sc, n), this.cache.get(e.uri).document; }
            clear() { this.cache.clear(); }
            ensureCache(e, t, n) { const r = e.uri; this.cache.has(r) || this.cache.set(r, { version: -1, document: new ec([], []), parserOptions: sc }); const o = this.cache.get(r); if (o.version !== e.version || t.customTags && !vu(o.parserOptions.customTags, t.customTags)) {
                let r = e.getText();
                n && !/\S/.test(r) && (r = `{${r}}`);
                const i = function (e, t = sc, n) { var r; const o = { strict: !1, customTags: oc(t.customTags), version: null != (r = t.yamlVersion) ? r : sc.yamlVersion, keepSourceTokens: !0 }, i = new Gs(o), s = new Sa; let a = !1; if (n) {
                    const t = new ic(n), r = t.getPosition(e.length);
                    a = 0 === t.getLineContent(r.line).trim().length;
                } const u = (a ? new Na : new Na(s.addNewLine)).parse(e), c = Array.from(u), l = i.compose(c, !0, e.length), p = Array.from(l, (e => function (e, t) { const n = new Zu(t); return n.internalDocument = e, n; }(e, s))); return new ec(p, c); }(r, t, e);
                o.document = i, o.version = e.version, o.parserOptions = t;
            } }
        };
        function nc(e) { return { message: e.message, location: { start: e.pos[0], end: e.pos[1], toLineEnd: !0 }, severity: 1, code: Er.Undefined }; }
        var rc = class {
            constructor(e, t) { this.tag = e, this.type = t; }
            get collection() { return "mapping" === this.type ? "map" : "sequence" === this.type ? "seq" : void 0; }
            resolve(e) { return go(e) && "mapping" === this.type || bo(e) && "sequence" === this.type || "string" == typeof e && "scalar" === this.type ? e : void 0; }
        };
        function oc(e) { const t = [], n = yu(e); for (const e of n) {
            const n = e.split(" "), r = n[0], o = n[1] && n[1].toLowerCase() || "scalar";
            t.push(new rc(r, o));
        } return t.push(new class {
            constructor() { this.tag = "!include", this.type = "scalar"; }
            resolve(e, t) { if (e && e.length > 0 && e.trim())
                return e; t("!include without value"); }
        }), t; }
        var ic = class {
            constructor(e) { this.doc = e; }
            getLineCount() { return this.doc.lineCount; }
            getLineLength(e) { const t = this.doc.getLineOffsets(); return e >= t.length ? this.doc.getText().length : e < 0 ? 0 : (e + 1 < t.length ? t[e + 1] : this.doc.getText().length) - t[e]; }
            getLineContent(e) { const t = this.doc.getLineOffsets(); if (e >= t.length)
                return this.doc.getText(); if (e < 0)
                return ""; const n = e + 1 < t.length ? t[e + 1] : this.doc.getText().length; return this.doc.getText().substring(t[e], n); }
            getLineCharCode(e, t) { return this.doc.getText(He.create(e - 1, t, e - 1, t + 1)).charCodeAt(0); }
            getText(e) { return this.doc.getText(e); }
            getPosition(e) { return this.doc.positionAt(e); }
        }, sc = { customTags: [], yamlVersion: "1.2" };
        function ac(e) { const t = e.match(/^#\s+yaml-language-server\s*:/g); return null !== t && 1 === t.length; }
        var uc, cc, lc = _r(), pc = new class {
            compile() { return () => !0; }
        }, fc = E(), dc = pc.compile(fc);
        (cc = uc || (uc = {}))[cc.delete = 0] = "delete", cc[cc.add = 1] = "add", cc[cc.deleteAll = 2] = "deleteAll";
        var hc = class {
            constructor(e) { try {
                this.patternRegExp = new RegExp(function (e) { return e.replace(/[-\\{}+?|^$.,[\]()#\s]/g, "\\$&").replace(/[*]/g, ".*"); }(e) + "$");
            }
            catch (e) {
                this.patternRegExp = null;
            } this.schemas = []; }
            addSchema(e) { this.schemas.push(e); }
            matchesPattern(e) { return this.patternRegExp && this.patternRegExp.test(e); }
            getSchemas() { return this.schemas; }
        }, mc = class extends eo {
            constructor(e, t, n) { super(e, t, n), this.schemaUriToNameAndDescription = new Map, this.customSchemaProvider = void 0, this.requestService = e, this.schemaPriorityMapping = new Map; }
            registerCustomSchemaProvider(e) { this.customSchemaProvider = e; }
            getAllSchemas() { const e = [], t = new Set; for (const n of this.filePatternAssociations) {
                const r = n.uris[0];
                if (t.has(r))
                    continue;
                t.add(r);
                const o = { uri: r, fromStore: !1, usedForCurrentFile: !1 };
                if (this.schemaUriToNameAndDescription.has(r)) {
                    const { name: e, description: t, versions: n } = this.schemaUriToNameAndDescription.get(r);
                    o.name = e, o.description = t, o.fromStore = !0, o.versions = n;
                }
                e.push(o);
            } return e; }
            async resolveSchemaContent(e, t, n) { const r = e.errors.slice(0); let o = e.schema; const i = this.contextService; if (!dc(o)) {
                const n = [];
                for (const e of dc.errors)
                    n.push(`${e.instancePath} : ${e.message}`);
                r.push(`Schema '${Va(e.schema, t)}' is not valid:\n${n.join("\n")}`);
            } const s = (e, t, n, o) => { const i = ((e, t) => { if (!t)
                return e; let n = e; return "/" === t[0] && (t = t.substr(1)), t.split("/").some((e => (n = n[e], !n))), n; })(t, o); if (i)
                for (const t in i)
                    Object.prototype.hasOwnProperty.call(i, t) && !Object.prototype.hasOwnProperty.call(e, t) && (e[t] = i[t]);
            else
                r.push(lc("json.schema.invalidref", "$ref '{0}' in '{1}' can not be resolved.", o, n)); }, a = (e, t, n, o, a) => { i && !/^\w+:\/\/.*/.test(t) && (t = i.resolveRelativePath(t, o)), t = this.normalizeId(t); const c = this.getOrAddSchemaHandle(t); return c.getUnresolvedSchema().then((o => { if (a[t] = !0, o.errors.length) {
                const e = n ? t + "#" + n : t;
                r.push(lc("json.schema.problemloadingref", "Problems loading reference '{0}': {1}", e, o.errors[0]));
            } return s(e, o.schema, t, n), e.url = t, u(e, o.schema, t, c.dependencies); })); }, u = async (e, t, n, r) => { if (!e || "object" != typeof e)
                return null; const i = [e], u = [], c = [], l = e => { const o = []; for (; e.$ref;) {
                const i = e.$ref, u = i.split("#", 2);
                if (e._$ref = e.$ref, delete e.$ref, u[0].length > 0)
                    return void c.push(a(e, u[0], u[1], n, r));
                -1 === o.indexOf(i) && (s(e, t, n, u[1]), o.push(i));
            } ((...e) => { for (const t of e)
                "object" == typeof t && i.push(t); })(e.items, e.additionalItems, e.additionalProperties, e.not, e.contains, e.propertyNames, e.if, e.then, e.else), ((...e) => { for (const t of e)
                if ("object" == typeof t)
                    for (const e in t) {
                        const n = t[e];
                        "object" == typeof n && i.push(n);
                    } })(e.definitions, e.properties, e.patternProperties, e.dependencies), ((...e) => { for (const t of e)
                if (Array.isArray(t))
                    for (const e of t)
                        "object" == typeof e && i.push(e); })(e.anyOf, e.allOf, e.oneOf, e.items, e.schemaSequence); }; if (n.indexOf("#") > 0) {
                const e = n.split("#", 2);
                if (e[0].length > 0 && e[1].length > 0) {
                    const t = {};
                    await a(t, e[0], e[1], n, r);
                    for (const e in o)
                        "required" !== e && Object.prototype.hasOwnProperty.call(o, e) && !Object.prototype.hasOwnProperty.call(t, e) && (t[e] = o[e]);
                    o = t;
                }
            } for (; i.length;) {
                const e = i.pop();
                u.indexOf(e) >= 0 || (u.push(e), l(e));
            } return Promise.all(c); }; return await u(o, o, t, n), new Zr(o, r); }
            getSchemaForResource(e, t) { const n = n => { const r = super.createCombinedSchema(e, n); return r.getResolvedSchema().then((e => (e.schema && "object" == typeof e.schema && (e.schema.url = r.url), e.schema && e.schema.schemaSequence && e.schema.schemaSequence[t.currentDocIndex] ? new Zr(e.schema.schemaSequence[t.currentDocIndex]) : e))); }, r = () => { const t = Object.create(null), r = []; for (const n of this.filePatternAssociations)
                if (n.matchesPattern(e))
                    for (const e of n.getURIs())
                        t[e] || (r.push(e), t[e] = !0); const o = this.normalizeId(e); if (this.schemasById[o] && r.push(o), r.length > 0) {
                const e = this.highestPrioritySchemas(r);
                return n(e);
            } return Promise.resolve(null); }, o = (() => { let n = function (e) { if (e instanceof Zu) {
                const t = e.lineComments.find((e => ac(e)));
                if (null != t) {
                    const e = t.match(/\$schema=\S+/g);
                    if (null !== e && e.length >= 1)
                        return e.length >= 2 && a.log("Several $schema attributes have been found on the yaml-language-server modeline. The first one will be picked."), e[0].substring("$schema=".length);
                }
            } }(t); if (void 0 !== n) {
                if (!n.startsWith("file:") && !n.startsWith("http")) {
                    let t = "";
                    if (n.indexOf("#") > 0) {
                        const e = n.split("#", 2);
                        n = e[0], t = e[1];
                    }
                    if (Pa.isAbsolute(n))
                        n = It.file(n).toString();
                    else {
                        const t = It.parse(e);
                        n = It.file(Pa.resolve(Pa.parse(t.fsPath).dir, n)).toString();
                    }
                    t.length > 0 && (n += "#" + t);
                }
                return n;
            } })(); return o ? n([o]) : this.customSchemaProvider ? this.customSchemaProvider(e).then((e => Array.isArray(e) ? 0 === e.length ? r() : Promise.all(e.map((e => this.resolveCustomSchema(e, t)))).then((e => ({ errors: [], schema: { anyOf: e.map((e => e.schema)) } })), (() => r())) : e ? this.resolveCustomSchema(e, t) : r())).then((e => e), (() => r())) : r(); }
            addSchemaPriority(e, t) { let n = this.schemaPriorityMapping.get(e); n ? (n = n.add(t), this.schemaPriorityMapping.set(e, n)) : this.schemaPriorityMapping.set(e, (new Set).add(t)); }
            highestPrioritySchemas(e) { let t = 0; const n = new Map; return e.forEach((e => { (this.schemaPriorityMapping.get(e) || [0]).forEach((r => { r > t && (t = r); let o = n.get(r); o ? (o = o.concat(e), n.set(r, o)) : n.set(r, [e]); })); })), n.get(t) || []; }
            async resolveCustomSchema(e, t) { const n = await this.loadSchema(e), r = await this.resolveSchemaContent(n, e, []); return r.schema && (r.schema.url = e), r.schema && r.schema.schemaSequence && r.schema.schemaSequence[t.currentDocIndex] ? new Zr(r.schema.schemaSequence[t.currentDocIndex]) : r; }
            async saveSchema(e, t) { const n = this.normalizeId(e); return this.getOrAddSchemaHandle(n, t), this.schemaPriorityMapping.set(n, (new Set).add(Lc.Settings)), Promise.resolve(void 0); }
            async deleteSchemas(e) { return e.schemas.forEach((e => { this.deleteSchema(e); })), Promise.resolve(void 0); }
            async deleteSchema(e) { const t = this.normalizeId(e); return this.schemasById[t] && delete this.schemasById[t], this.schemaPriorityMapping.delete(t), Promise.resolve(void 0); }
            async addContent(e) { const t = await this.getResolvedSchema(e.schema); if (t) {
                const n = this.resolveJSONSchemaToSection(t.schema, e.path);
                "object" == typeof n && (n[e.key] = e.content), await this.saveSchema(e.schema, t.schema);
            } }
            async deleteContent(e) { const t = await this.getResolvedSchema(e.schema); if (t) {
                const n = this.resolveJSONSchemaToSection(t.schema, e.path);
                "object" == typeof n && delete n[e.key], await this.saveSchema(e.schema, t.schema);
            } }
            resolveJSONSchemaToSection(e, t) { const n = t.split("/"); let r = e; for (const e of n)
                "" !== e && (this.resolveNext(r, e), r = r[e]); return r; }
            resolveNext(e, t) { if (Array.isArray(e) && isNaN(t))
                throw new Error("Expected a number after the array object"); if ("object" == typeof e && "string" != typeof t)
                throw new Error("Expected a string after the object"); }
            normalizeId(e) { try {
                return It.parse(e).toString();
            }
            catch (t) {
                return e;
            } }
            getOrAddSchemaHandle(e, t) { return super.getOrAddSchemaHandle(e, t); }
            loadSchema(e) { const t = this.requestService; return super.loadSchema(e).then((n => { if (n.errors && void 0 === n.schema)
                return t(e).then((t => { if (!t) {
                    const t = lc("json.schema.nocontent", "Unable to load schema from '{0}': No content. {1}", gc(e), n.errors);
                    return new Qr({}, [t]);
                } try {
                    const e = function (e, t, n) { let r; const o = function (e, t = {}) { const { lineCounter: n, prettyErrors: r } = function (e) { const t = !1 !== e.prettyErrors; return { lineCounter: e.lineCounter || t && new Sa || null, prettyErrors: t }; }(t), o = new Na(null == n ? void 0 : n.addNewLine), i = new Gs(t); let s = null; for (const t of i.compose(o.parse(e), !0, e.length))
                        if (s) {
                            if ("silent" !== s.options.logLevel) {
                                s.errors.push(new xs(t.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
                                break;
                            }
                        }
                        else
                            s = t; return r && n && (s.errors.forEach(ks(e, n)), s.warnings.forEach(ks(e, n))), s; }(e, n); if (!o)
                        return null; if (o.warnings.forEach((e => li(o.options.logLevel, e))), o.errors.length > 0) {
                        if ("silent" !== o.options.logLevel)
                            throw o.errors[0];
                        o.errors = [];
                    } return o.toJS(Object.assign({ reviver: r }, n)); }(t);
                    return new Qr(e, []);
                }
                catch (t) {
                    const n = lc("json.schema.invalidFormat", "Unable to parse content from '{0}': {1}.", gc(e), t);
                    return new Qr({}, [n]);
                } }), (e => { let t = e.toString(); const n = e.toString().split("Error: "); return n.length > 1 && (t = n[1]), new Qr({}, [t]); })); if (n.uri = e, this.schemaUriToNameAndDescription.has(e)) {
                const { name: t, description: r, versions: o } = this.schemaUriToNameAndDescription.get(e);
                n.schema.title = null != t ? t : n.schema.title, n.schema.description = null != r ? r : n.schema.description, n.schema.versions = null != o ? o : n.schema.versions;
            } return n; })); }
            registerExternalSchema(e, t, n, r, o, i) { return (r || o) && this.schemaUriToNameAndDescription.set(e, { name: r, description: o, versions: i }), super.registerExternalSchema(e, t, n); }
            clearExternalSchemas() { super.clearExternalSchemas(); }
            setSchemaContributions(e) { super.setSchemaContributions(e); }
            getRegisteredSchemaIds(e) { return super.getRegisteredSchemaIds(e); }
            getResolvedSchema(e) { return super.getResolvedSchema(e); }
            onResourceChange(e) { return super.onResourceChange(e); }
        };
        function gc(e) { try {
            const t = It.parse(e);
            if ("file" === t.scheme)
                return t.fsPath;
        }
        catch (e) { } return e; }
        function yc(e, t) { for (const n of e)
            n.isKubernetes = t; }
        t.YAMLSchemaService = mc;
        var vc = b(D());
        function bc(e) { if (e)
            return e.replace(/([^\n\r])(\r?\n)([^\n\r])/gm, "$1\n\n$3").replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&"); }
        function Dc(e) { for (const t of e.start)
            if ("anchor" === t.type)
                return t; if (e.sep && Array.isArray(e.sep))
            for (const t of e.sep)
                if ("anchor" === t.type)
                    return t; }
        var Ec = (e, t) => { const n = t.positionAt(e.location.start), r = { start: n, end: e.location.toLineEnd ? Ke.create(n.line, new ic(t).getLineLength(n.line)) : t.positionAt(e.location.end) }; return gt.create(r, e.message, e.severity, e.code, Au); }, Cc = class {
            constructor(e, t) { this.telemetry = t, this.validators = [], this.MATCHES_MULTIPLE = "Matches multiple schemas when only one must validate.", this.validationEnabled = !0, this.jsonValidation = new Ja(e, Promise); }
            configure(e) { this.validators = [], e && (this.validationEnabled = e.validate, this.customTags = e.customTags, this.disableAdditionalProperties = e.disableAdditionalProperties, this.yamlVersion = e.yamlVersion, "forbid" !== e.flowMapping && "forbid" !== e.flowSequence || this.validators.push(new class {
                constructor(e) { this.forbidMapping = "forbid" === e.flowMapping, this.forbidSequence = "forbid" === e.flowSequence; }
                validate(e, t) { const n = []; return xo(t.internalDocument, ((t, r) => { var o, i; this.forbidMapping && go(r) && "flow-collection" === (null == (o = r.srcToken) ? void 0 : o.type) && n.push(gt.create(this.getRangeOf(e, r.srcToken), "Flow style mapping is forbidden", pt.Error, "flowMap")), this.forbidSequence && bo(r) && "flow-collection" === (null == (i = r.srcToken) ? void 0 : i.type) && n.push(gt.create(this.getRangeOf(e, r.srcToken), "Flow style sequence is forbidden", pt.Error, "flowSeq")); })), n; }
                getRangeOf(e, t) { return He.create(e.positionAt(t.start.offset), e.positionAt(t.end.pop().offset)); }
            }(e))), this.validators.push(new class {
                validate(e, t) { const n = [], r = new Set, o = new Set, i = new Map; xo(t.internalDocument, ((e, n, s) => { Eo(n) && ((Do(n) || vo(n)) && n.anchor && (r.add(n), i.set(n, s[s.length - 1])), ho(n) && o.add(n.resolve(t.internalDocument))); })); for (const t of r)
                    if (!o.has(t)) {
                        const r = this.getAnchorNode(i.get(t));
                        if (r) {
                            const t = He.create(e.positionAt(r.offset), e.positionAt(r.offset + r.source.length)), o = gt.create(t, `Unused anchor "${r.source}"`, pt.Hint, 0);
                            o.tags = [dt.Unnecessary], n.push(o);
                        }
                    } return n; }
                getAnchorNode(e) { if (e && e.srcToken) {
                    const t = e.srcToken;
                    if (Xu(t))
                        return Dc(t);
                    if (Xs.isCollection(t))
                        for (const e of t.items) {
                            const t = Dc(e);
                            if (t)
                                return t;
                        }
                } }
            }); }
            async doValidation(e, t = !1) { if (!this.validationEnabled)
                return Promise.resolve([]); const n = []; try {
                const r = tc.getYamlDocument(e, { customTags: this.customTags, yamlVersion: this.yamlVersion }, !0);
                let o = 0;
                for (const i of r.documents) {
                    i.isKubernetes = t, i.currentDocIndex = o, i.disableAdditionalProperties = this.disableAdditionalProperties, i.uri = e.uri;
                    const r = await this.jsonValidation.doValidation(e, i), s = i;
                    s.errors.length > 0 && n.push(...s.errors), s.warnings.length > 0 && n.push(...s.warnings), n.push(...r), n.push(...this.runAdditionalValidators(e, i)), o++;
                }
            }
            catch (e) {
                this.telemetry.sendError("yaml.validation.error", { error: La(e) });
            } let r; const o = new Set, i = []; for (let s of n) {
                if (t && s.message === this.MATCHES_MULTIPLE)
                    continue;
                if (Object.prototype.hasOwnProperty.call(s, "location") && (s = Ec(s, e)), s.source || (s.source = Au), r && r.message === s.message && r.range.end.line === s.range.start.line && Math.abs(r.range.end.character - s.range.end.character) >= 1) {
                    r.range.end = s.range.end;
                    continue;
                }
                r = s;
                const n = s.range.start.line + " " + s.range.start.character + " " + s.message;
                o.has(n) || (i.push(s), o.add(n));
            } return i; }
            runAdditionalValidators(e, t) { const n = []; for (const r of this.validators)
                n.push(...r.validate(e, t)); return n; }
        };
        t.YAMLValidation = Cc;
        var wc, Ac = b(C()), Sc = b(w());
        function xc(e, t) { if (!e)
            return; const n = [], r = tc.getYamlDocument(e); for (const t of r.documents)
            r.documents.length > 1 && n.push(Tc(e, t.root)), t.visit((t => { var r; if ("object" === t.type && "array" === (null == (r = t.parent) ? void 0 : r.type) && n.push(Tc(e, t)), "property" === t.type && t.valueNode)
                switch (t.valueNode.type) {
                    case "array":
                    case "object":
                        n.push(Tc(e, t));
                        break;
                    case "string": {
                        const r = e.positionAt(t.offset), o = e.positionAt(t.valueNode.offset + t.valueNode.length);
                        r.line !== o.line && n.push(Tc(e, t));
                        break;
                    }
                    default: return !0;
                } return !0; })); const o = t && t.rangeLimit; return "number" != typeof o || n.length <= o ? n : (t && t.onRangeLimitExceeded && t.onRangeLimitExceeded(e.uri), n.slice(0, t.rangeLimit)); }
        function Tc(e, t) { const n = e.positionAt(t.offset); let r = e.positionAt(t.offset + t.length); const o = e.getText(He.create(n, r)), i = o.length - o.trimRight().length; return i > 0 && (r = e.positionAt(t.offset + t.length - i)), at.create(n.line, r.line, n.character, r.character); }
        (wc || (wc = {})).JUMP_TO_SCHEMA = "jumpToSchema";
        var kc = b(D()), Fc = class {
            constructor(e) { this.indentation = e; }
            write(e) { if ("flow-collection" !== e.internalNode.srcToken.type)
                return null; const t = e.internalNode.srcToken, n = "flow-map-start" === t.start.type ? "block-map" : "block-seq", r = e.parent.type, o = { type: n, offset: t.offset, indent: t.indent, items: [] }; for (const e of t.items)
                Xs.visit(e, (({ key: e, sep: t, value: i }) => { if ("block-map" === n) {
                    const n = [{ type: "space", indent: 0, offset: e.offset, source: this.indentation }];
                    "property" === r && n.unshift({ type: "newline", indent: 0, offset: e.offset, source: "\n" }), o.items.push({ start: n, key: e, sep: t, value: i });
                }
                else
                    "block-seq" === n && o.items.push({ start: [{ type: "newline", indent: 0, offset: i.offset, source: "\n" }, { type: "space", indent: 0, offset: i.offset, source: this.indentation }, { type: "seq-item-ind", indent: 0, offset: i.offset, source: "-" }, { type: "space", indent: 0, offset: i.offset, source: " " }], value: i }); if ("flow-collection" === i.type)
                    return xo.SKIP; })); return Xs.stringify(o); }
        };
        function Oc(e, t) { const n = {}; return n[e] = t, { changes: n }; }
        var _c = new class {
            constructor() { this.commands = new Map; }
            executeCommand(e) { if (this.commands.has(e.command))
                return this.commands.get(e.command)(...e.arguments); throw new Error(`Command '${e.command}' not found`); }
            registerCommand(e, t) { this.commands.set(e, t); }
        };
        function Nc(e, t) { const { position: n } = t, r = new ic(e); if ("\n" === t.ch) {
            const e = r.getLineContent(n.line - 1);
            if (e.trimRight().endsWith(":")) {
                const o = r.getLineContent(n.line), i = o.substring(n.character, o.length), s = -1 !== e.indexOf(" - ");
                if (0 === i.trimRight().length) {
                    const r = n.character - (e.length - e.trimLeft().length);
                    if (r === t.options.tabSize && !s)
                        return;
                    const i = [];
                    return o.length > 0 && i.push(Dt.del(He.create(n, Ke.create(n.line, o.length - 1)))), i.push(Dt.insert(n, " ".repeat(t.options.tabSize + (s ? 2 - r : 0)))), i;
                }
                if (s)
                    return [Dt.insert(n, " ".repeat(t.options.tabSize))];
            }
            if (e.trimRight().endsWith("|"))
                return [Dt.insert(n, " ".repeat(t.options.tabSize))];
            if (e.includes(" - ") && !e.includes(": "))
                return [Dt.insert(n, "- ")];
            if (e.includes(" - ") && e.includes(": "))
                return [Dt.insert(n, "  ")];
        } }
        function Pc(e) { const t = new Map; return e ? (e.url ? e.url.startsWith("schemaservice://combinedSchema/") ? Mc(e, t) : t.set(e.url, e) : Mc(e, t), t) : t; }
        function Mc(e, t) { e.allOf && Rc(e.allOf, t), e.anyOf && Rc(e.anyOf, t), e.oneOf && Rc(e.oneOf, t); }
        function Rc(e, t) { for (const n of e)
            ja(n) || !n.url || t.has(n.url) || t.set(n.url, n); }
        function Ic(e, t, n, r, o) { let i; for (o.spacesDiff = 0, o.looksLikeAlignment = !1, i = 0; i < t && i < r && e.charCodeAt(i) === n.charCodeAt(i); i++)
            ; let s = 0, a = 0; for (let n = i; n < t; n++)
            32 === e.charCodeAt(n) ? s++ : a++; let u = 0, c = 0; for (let e = i; e < r; e++)
            32 === n.charCodeAt(e) ? u++ : c++; if (s > 0 && a > 0)
            return; if (u > 0 && c > 0)
            return; const l = Math.abs(a - c), p = Math.abs(s - u); if (0 === l)
            return o.spacesDiff = p, void (p > 0 && 0 <= u - 1 && u - 1 < e.length && u < n.length && 32 !== n.charCodeAt(u) && 32 === e.charCodeAt(u - 1) && 44 === e.charCodeAt(e.length - 1) && (o.looksLikeAlignment = !0)); p % l == 0 && (o.spacesDiff = p / l); }
        function jc(e, t, n, r, o = 0, i = 0) { if (null !== e && "object" == typeof e) {
            const s = 0 === o && r.shouldIndentWithTab || o > 0 ? t + r.indentation : "";
            if (Array.isArray(e)) {
                if (i += 1, 0 === e.length)
                    return "";
                let a = "";
                for (let u = 0; u < e.length; u++) {
                    let c = e[u];
                    "object" == typeof e[u] ? (Array.isArray(e[u]) || (c = Bc(e[u], i)), a += jc(c, t, n, r, o += 1, i)) : a += "\n" + s + "- " + n(e[u]);
                }
                return a;
            }
            {
                const i = Object.keys(e);
                if (0 === i.length)
                    return "";
                let a = 0 === o && r.newLineFirst || o > 0 ? "\n" : "";
                for (let u = 0; u < i.length; u++) {
                    const c = i[u], l = "object" == typeof e[c], p = l ? ":" : ": ", f = s + (l && /^\s|-/.test(c) ? r.indentation : "");
                    0 !== o || 0 !== u || r.indentFirstObject ? a += s + c + p + jc(e[c], f, n, r, o += 1, 0) : a += t + c + p + jc(e[c], f, n, r, o += 1, 0), u < i.length - 1 && (a += "\n");
                }
                return a;
            }
        } return n(e); }
        function Bc(e, t) { const n = {}; for (let r = 0; r < Object.keys(e).length; r++) {
            const o = Object.keys(e)[r];
            0 === r ? n["- ".repeat(t) + o] = e[o] : n["  ".repeat(t) + o] = e[o];
        } return n; }
        var Lc, qc, $c = _r(), Uc = /[\\]+"/g, Vc = nn.Class, Wc = /^\d+$/;
        function Kc(e) { let t; if (t = "string" == typeof e ? e : "" + e, 0 === t.length)
            return t; if ("true" === t || "false" === t || "null" === t || Wc.test(t))
            return `"${t}"`; -1 !== t.indexOf('"') && (t = t.replace(Uc, '"')); let n = !isNaN(parseInt(t)) || "@" === t.charAt(0); if (!n) {
            let e = t.indexOf(":", 0);
            for (; e > 0 && e < t.length; e = t.indexOf(":", e + 1)) {
                if (e === t.length - 1) {
                    n = !0;
                    break;
                }
                const r = t.charAt(e + 1);
                if ("\t" === r || " " === r) {
                    n = !0;
                    break;
                }
            }
        } return n && (t = `"${t}"`), t; }
        function zc() { }
        (qc = Lc || (Lc = {}))[qc.SchemaStore = 1] = "SchemaStore", qc[qc.SchemaAssociation = 2] = "SchemaAssociation", qc[qc.Settings = 3] = "Settings", t.getLanguageService = function (e, t, n, r, o, i) { const s = new mc(e, t), u = new class {
            constructor(e, t = {}, n, r) { this.schemaService = e, this.clientCapabilities = t, this.yamlDocument = n, this.telemetry = r, this.completionEnabled = !0, this.arrayPrefixIndentation = ""; }
            configure(e) { e && (this.completionEnabled = e.completion), this.customTags = e.customTags, this.yamlVersion = e.yamlVersion, this.configuredIndentation = e.indentation, this.disableDefaultProperties = e.disableDefaultProperties, this.parentSkeletonSelectedFirst = e.parentSkeletonSelectedFirst; }
            async doComplete(e, t, n = !1, r = !0) { const o = hn.create([], !1); if (!this.completionEnabled)
                return o; const i = this.yamlDocument.getYamlDocument(e, { customTags: this.customTags, yamlVersion: this.yamlVersion }, !0), s = new ic(e); if (this.configuredIndentation)
                this.indentation = this.configuredIndentation;
            else {
                const e = function (e, t, n) { const r = Math.min(e.getLineCount(), 1e4); let o = 0, i = 0, s = "", a = 0; const u = [2, 4, 6, 8, 3, 5, 7], c = [0, 0, 0, 0, 0, 0, 0, 0, 0], l = new class {
                    constructor() { this.spacesDiff = 0, this.looksLikeAlignment = !1; }
                }; for (let t = 1; t <= r; t++) {
                    const n = e.getLineLength(t), r = e.getLineContent(t), u = n <= 65536;
                    let p = !1, f = 0, d = 0, h = 0;
                    for (let o = 0, i = n; o < i; o++) {
                        const n = u ? r.charCodeAt(o) : e.getLineCharCode(t, o);
                        if (9 === n)
                            h++;
                        else {
                            if (32 !== n) {
                                p = !0, f = o;
                                break;
                            }
                            d++;
                        }
                    }
                    if (!p)
                        continue;
                    if (h > 0 ? o++ : d > 1 && i++, Ic(s, a, r, f, l), l.looksLikeAlignment && 2 !== l.spacesDiff)
                        continue;
                    const m = l.spacesDiff;
                    m <= 8 && c[m]++, s = r, a = f;
                } let p = true; o !== i && (p = o < i); let f = 2; if (p) {
                    let e = p ? 0 : .1 * r;
                    u.forEach((t => { const n = c[t]; n > e && (e = n, f = t); })), 4 === f && c[4] > 0 && c[2] > 0 && c[2] >= c[4] / 2 && (f = 2);
                } return { insertSpaces: p, tabSize: f }; }(s);
                this.indentation = e.insertSpaces ? " ".repeat(e.tabSize) : "\t";
            } yc(i.documents, n); for (const t of i.documents)
                t.uri = e.uri; const u = e.offsetAt(t), c = e.getText(); if (":" === c.charAt(u - 1))
                return Promise.resolve(o); let l = gu(u, i); if (null === l)
                return Promise.resolve(o); l = l.clone(); let [p, f] = l.getNodeFromPosition(u, s, this.indentation.length); const d = this.getCurrentWord(e, u); let h = s.getLineContent(t.line); const m = h.substring(t.character), g = /^[ ]+\n?$/.test(m); this.arrayPrefixIndentation = ""; let y = null; if (g) {
                y = He.create(t, Ke.create(t.line, h.length));
                const e = 0 === h.trim().length, n = h.match(/^\s*(-)\s*$/);
                if (p && vo(p) && !e && !n) {
                    const e = h.match(/^([\s-]*)[^:]+[ \t]+\n?$/);
                    (null == e ? void 0 : e.length) && (y = He.create(Ke.create(t.line, e[1].length), Ke.create(t.line, h.length)));
                }
            }
            else if (p && vo(p) && "null" === p.value) {
                const t = e.positionAt(p.range[0]);
                t.character += 1;
                const n = e.positionAt(p.range[2]);
                n.character += 1, y = He.create(t, n);
            }
            else if (p && vo(p) && p.value) {
                const t = e.positionAt(p.range[0]);
                u > 0 && t.character > 0 && "-" === c.charAt(u - 1) && (t.character -= 1), y = He.create(t, e.positionAt(p.range[1]));
            }
            else if (p && vo(p) && null === p.value && "-" === d)
                y = He.create(t, t), this.arrayPrefixIndentation = " ";
            else {
                let n = e.offsetAt(t) - d.length;
                n > 0 && '"' === c[n - 1] && n--, y = He.create(e.positionAt(n), t);
            } const v = {}, b = "__", D = { add: (e, t) => { const n = !!e.parent; let r = e.label; if (!r)
                    return void a.warn(`Ignoring CompletionItem without label: ${JSON.stringify(e)}`); if (Ba(r) || (r = String(r)), r = r.replace(/[\n]/g, "↵"), r.length > 60) {
                    const e = r.substr(0, 57).trim() + "...";
                    v[e] || (r = e);
                } if (e.insertText.endsWith("$1") && !n && (e.insertText = e.insertText.substr(0, e.insertText.length - 2)), y && y.start.line === y.end.line && (e.textEdit = Dt.replace(y, e.insertText)), e.label = r, n)
                    return void function (e) { var t; if ((null == (t = v[e.label]) ? void 0 : t.label) === b)
                        return; const n = e.parent.schema, r = $a(n), i = n.markdownDescription || n.description; let s = o.items.find((e => { var t; return (null == (t = e.parent) ? void 0 : t.schema) === n && e.kind === Vc; })); s && s.parent.insertTexts.includes(e.insertText) || (s ? s.parent.insertTexts.push(e.insertText) : (s = { ...e, label: r, documentation: i, sortText: "_" + r, kind: Vc }, s.label = s.label || e.label, s.parent.insertTexts = [e.insertText], o.items.push(s))); }(e); this.arrayPrefixIndentation && this.updateCompletionText(e, this.arrayPrefixIndentation + e.insertText); const i = v[r], s = (null == i ? void 0 : i.label) !== b && (null == i ? void 0 : i.insertText) !== e.insertText; if (i) {
                    if (s) {
                        const n = this.mergeSimpleInsertTexts(r, i.insertText, e.insertText, t);
                        n ? this.updateCompletionText(i, n) : (v[r] = e, o.items.push(e));
                    }
                }
                else
                    v[r] = e, o.items.push(e); i && !i.documentation && e.documentation && (i.documentation = e.documentation); }, error: e => { this.telemetry.sendError("yaml.completion.error", { error: La(e) }); }, log: e => { a.log(e); }, getNumberOfProposals: () => o.items.length, result: o }; this.customTags.length > 0 && this.getCustomTagValueCompletions(D), h.endsWith("\n") && (h = h.substr(0, h.length - 1)); try {
                const n = await this.schemaService.getSchemaForResource(e.uri, l);
                if ((!n || n.errors.length) && 0 === t.line && 0 === t.character && !ac(h)) {
                    const e = { kind: nn.Text, label: "Inline schema", insertText: "# yaml-language-server: $schema=", insertTextFormat: on.PlainText };
                    o.items.push(e);
                }
                if (ac(h) || function (e, t) { let n = !1; for (const r of e) {
                    if ("document" === r.type)
                        Qu([], r, (e => { var o; if (Xu(e) && "comment" === (null == (o = e.value) ? void 0 : o.type)) {
                            if (r.offset <= t && e.value.source.length + e.value.offset >= t)
                                return n = !0, xo.BREAK;
                        }
                        else if ("comment" === e.type && e.offset <= t && e.offset + e.source.length >= t)
                            return n = !0, xo.BREAK; }));
                    else if ("comment" === r.type && r.offset <= t && r.source.length + r.offset >= t)
                        return !0;
                    if (n)
                        break;
                } return n; }(i.tokens, u)) {
                    const e = h.indexOf("$schema=");
                    return -1 !== e && e + "$schema=".length <= t.character && this.schemaService.getAllSchemas().forEach((e => { var t; const n = { kind: nn.Constant, label: null != (t = e.name) ? t : e.uri, detail: e.description, insertText: e.uri, insertTextFormat: on.PlainText, insertTextMode: ln.asIs }; o.items.push(n); })), o;
                }
                if (!n || n.errors.length)
                    return o;
                let a = null;
                if (!p)
                    if (!l.internalDocument.contents || vo(l.internalDocument.contents)) {
                        const e = l.internalDocument.createNode({});
                        e.range = [u, u + 1, u + 1], l.internalDocument.contents = e, l.internalDocument = l.internalDocument, p = e;
                    }
                    else
                        p = l.findClosestNode(u, s), f = !0;
                const m = p;
                if (p)
                    if (0 === h.length)
                        p = l.internalDocument.contents;
                    else {
                        const n = l.getParent(p);
                        if (n) {
                            if (vo(p)) {
                                if (p.value) {
                                    if (yo(n)) {
                                        if (n.value === p) {
                                            if (h.trim().length > 0 && h.indexOf(":") < 0) {
                                                const e = this.createTempObjNode(d, p, l), t = l.getParent(n);
                                                if (bo(l.internalDocument.contents)) {
                                                    const t = function (e, t) { for (const [n, r] of e.items.entries())
                                                        if (t === r)
                                                            return n; }(l.internalDocument.contents, n);
                                                    "number" == typeof t && (l.internalDocument.set(t, e), l.internalDocument = l.internalDocument);
                                                }
                                                else
                                                    t && (go(t) || bo(t)) ? (t.set(n.key, e), l.internalDocument = l.internalDocument) : (l.internalDocument.set(n.key, e), l.internalDocument = l.internalDocument);
                                                a = e.items[0], p = e;
                                            }
                                            else if (0 === h.trim().length) {
                                                const e = l.getParent(n);
                                                e && (p = e);
                                            }
                                        }
                                        else if (n.key === p) {
                                            const e = l.getParent(n);
                                            a = n, e && (p = e);
                                        }
                                    }
                                    else if (bo(n))
                                        if (h.trim().length > 0) {
                                            const e = this.createTempObjNode(d, p, l);
                                            n.delete(p), n.add(e), l.internalDocument = l.internalDocument, p = e;
                                        }
                                        else
                                            p = n;
                                }
                                else if (null === p.value)
                                    if (yo(n)) {
                                        if (n.key === p)
                                            p = n;
                                        else if (Eo(n.key) && n.key.range) {
                                            const r = l.getParent(n);
                                            if (f && r && go(r) && function (e) { if (e.items.length > 1)
                                                return !1; const t = e.items[0]; return vo(t.key) && vo(t.value) && "" === t.key.value && !t.value.value; }(r))
                                                p = r;
                                            else {
                                                const o = e.positionAt(n.key.range[0]);
                                                if (t.character > o.character && t.line !== o.line) {
                                                    const e = this.createTempObjNode(d, p, l);
                                                    r && (go(r) || bo(r)) ? (r.set(n.key, e), l.internalDocument = l.internalDocument) : (l.internalDocument.set(n.key, e), l.internalDocument = l.internalDocument), a = e.items[0], p = e;
                                                }
                                                else
                                                    o.character === t.character && r && (p = r);
                                            }
                                        }
                                    }
                                    else if (bo(n))
                                        if ("-" !== h.charAt(t.character - 1)) {
                                            const e = this.createTempObjNode(d, p, l);
                                            n.delete(p), n.add(e), l.internalDocument = l.internalDocument, p = e;
                                        }
                                        else if ("-" === h.charAt(t.character - 1)) {
                                            const e = this.createTempObjNode("", p, l);
                                            n.delete(p), n.add(e), l.internalDocument = l.internalDocument, p = e;
                                        }
                                        else
                                            p = n;
                            }
                            else if (go(p) && !f && 0 === h.trim().length && bo(n)) {
                                const e = s.getLineContent(t.line + 1);
                                s.getLineCount() !== t.line + 1 && 0 !== e.trim().length || (p = n);
                            }
                        }
                        else if (vo(p)) {
                            const e = this.createTempObjNode(d, p, l);
                            l.internalDocument.contents = e, l.internalDocument = l.internalDocument, a = e.items[0], p = e;
                        }
                        else if (go(p))
                            for (const e of p.items)
                                Eo(e.value) && e.value.range && e.value.range[0] === u + 1 && (p = e.value);
                        else if (bo(p) && "-" !== h.charAt(t.character - 1)) {
                            const e = this.createTempObjNode(d, p, l);
                            e.items = [], l.internalDocument = l.internalDocument;
                            for (const t of p.items)
                                go(t) && t.items.forEach((t => { e.items.push(t); }));
                            p = e;
                        }
                    }
                if (p && go(p)) {
                    const e = p.items;
                    for (const t of e)
                        a && a === t || vo(t.key) && (v[t.key.value + ""] = dn.create(b));
                    this.addPropertyCompletions(n, l, p, m, "", D, s, y, r), !n && d.length > 0 && '"' !== c.charAt(u - d.length - 1) && D.add({ kind: nn.Property, label: d, insertText: this.getInsertTextForProperty(d, null, ""), insertTextFormat: on.Snippet });
                }
                const g = {};
                this.getValueCompletions(n, l, p, u, e, D, g, r);
            }
            catch (e) {
                this.telemetry.sendError("yaml.completion.error", { error: La(e) });
            } this.finalizeParentCompletion(o); const E = o.items.filter(((e, t, n) => t === n.findIndex((t => t.label === e.label && t.insertText === e.insertText && t.kind === e.kind)))); return (null == E ? void 0 : E.length) > 0 && (o.items = E), o; }
            updateCompletionText(e, t) { e.insertText = t, e.textEdit && (e.textEdit.newText = t); }
            mergeSimpleInsertTexts(e, t, n, r) { const o = e => e.includes("\n"), i = e => { const t = e.indexOf("\n"); return t > 0 && 0 === e.substring(t, e.length).trim().length; }; if (o(t) || o(n))
                return r && i(t) && !i(n) && !n.startsWith("\n") ? n : void 0; const s = this.getValuesFromInsertText(t), a = this.getValuesFromInsertText(n), u = Array.prototype.concat(s, a); return u.length ? 1 === u.length ? `${e}: \${1:${u[0]}}` : `${e}: \${1|${u.join(",")}|}` : void 0; }
            getValuesFromInsertText(e) { const t = e.substring(e.indexOf(":") + 1).trim(); if (!t)
                return []; const n = t.match(/^\${1[|:]([^|]*)+\|?}$/); return n ? n[1].split(",") : [t]; }
            finalizeParentCompletion(e) { e.items.forEach((e => { if ("parent" in e) {
                const t = e.parent.indent || "";
                let n = (e => { let t = 0; return e.map((e => { const n = e.match(/\$([0-9]+)|\${[0-9]+:/g); if (!n)
                    return e; const r = n.map((e => +e.replace(/\${([0-9]+)[:|]/g, "$1").replace("$", ""))).reduce(((e, t) => t > e ? t : e), 0), o = e.replace(/\$([0-9]+)/g, ((e, n) => "$" + (+n + t))).replace(/\${([0-9]+)[:|]/g, ((e, n) => "${" + (+n + t) + ":")); return t += r, o; })); })(e.parent.insertTexts).join(`\n${t}`);
                n.endsWith("$1") && (n = n.substring(0, n.length - 2)), e.insertText = this.arrayPrefixIndentation + n, e.textEdit && (e.textEdit.newText = e.insertText);
                const r = n.replace(/\${[0-9]+[:|](.*)}/g, ((e, t) => t)).replace(/\$([0-9]+)/g, ""), o = e.documentation ? [e.documentation, "", "----", ""] : [];
                e.documentation = { kind: Zt.Markdown, value: [...o, "```yaml", t + r, "```"].join("\n") }, delete e.parent;
            } })); }
            createTempObjNode(e, t, n) { const r = {}; r[e] = null; const o = n.internalDocument.createNode(r); return o.range = t.range, o.items[0].key.range = t.range, o.items[0].value.range = t.range, o; }
            addPropertyCompletions(e, t, n, r, o, i, s, a, u) { var c, l, p; const f = t.getMatchingSchemas(e.schema, -1, null, u), d = s.getText(a), h = s.getLineContent(a.start.line), m = 0 === h.trim().length, g = -1 !== h.indexOf(":"), y = 0 === h.trimLeft().indexOf("-"), v = t.getParent(n), b = f.find((e => e.node.internalNode === r && e.schema.properties)), D = f.filter((e => e.schema.oneOf)).map((e => e.schema.oneOf))[0]; let E = !1; (null == D ? void 0 : D.length) < f.length && (null == D || D.forEach(((e, t) => { var n, r; (null == (n = f[t]) ? void 0 : n.schema.oneOf) || (null == (r = f[t]) ? void 0 : r.schema.properties) !== e.properties || (E = !0); }))); for (const e of f) {
                if ((e.node.internalNode === n && !b || e.node.internalNode === r && !g || (null == (c = e.node.parent) ? void 0 : c.internalNode) === r && !g) && !e.inverted) {
                    this.collectDefaultSnippets(e.schema, o, i, { newLineFirst: !1, indentFirstObject: !1, shouldIndentWithTab: y });
                    const t = e.schema.properties;
                    if (t) {
                        const u = e.schema.maxProperties;
                        if (void 0 === u || void 0 === n.items || n.items.length < u || n.items.length === u && !m)
                            for (const u in t)
                                if (Object.prototype.hasOwnProperty.call(t, u)) {
                                    const c = t[u];
                                    if ("object" == typeof c && !c.deprecationMessage && !c.doNotSuggest) {
                                        let t, f = "";
                                        if (v && bo(v) && n.items.length <= 1 && !m) {
                                            const e = s.getText(), t = e.lastIndexOf("-", n.range[0] - 1);
                                            if (t >= 0) {
                                                const r = a.end.character - a.start.character;
                                                f = " " + e.slice(t + 1, n.range[1] - r);
                                            }
                                        }
                                        f += this.arrayPrefixIndentation, "array" === c.type && (t = n.items.find((e => vo(e.key) && e.key.range && e.key.value === u && vo(e.value) && !e.value.value && s.getPosition(e.key.range[2]).line === a.end.line - 1))) && t && (Array.isArray(c.items) ? this.addSchemaValueCompletions(c.items[0], o, i, {}, "property") : "object" == typeof c.items && "object" === c.items.type && this.addArrayItemValueCompletion(c.items, o, i));
                                        let h = u;
                                        u.startsWith(d) && g || (h = this.getInsertTextForProperty(u, c, o, f + this.indentation));
                                        const y = vo(r) && null === r.value || go(r) && 0 === r.items.length, b = (null == (l = e.schema.required) ? void 0 : l.length) > 0;
                                        this.parentSkeletonSelectedFirst && y && b || i.add({ kind: nn.Property, label: u, insertText: h, insertTextFormat: on.Snippet, documentation: this.fromMarkup(c.markdownDescription) || c.description || "" }, E), (null == (p = e.schema.required) ? void 0 : p.includes(u)) && i.add({ label: u, insertText: this.getInsertTextForProperty(u, c, o, f + this.indentation), insertTextFormat: on.Snippet, documentation: this.fromMarkup(c.markdownDescription) || c.description || "", parent: { schema: e.schema, indent: f } });
                                    }
                                }
                    }
                    if (v && bo(v) && Wa(e.schema) && this.addSchemaValueCompletions(e.schema, o, i, {}, "property", Array.isArray(v.items)), e.schema.propertyNames && e.schema.additionalProperties && "object" === e.schema.type) {
                        const t = Ru(e.schema.propertyNames), n = t.title || "property";
                        i.add({ kind: nn.Property, label: n, insertText: `\${1:${n}}: `, insertTextFormat: on.Snippet, documentation: this.fromMarkup(t.markdownDescription) || t.description || "" });
                    }
                }
                v && e.node.internalNode === v && e.schema.defaultSnippets && (1 === n.items.length ? this.collectDefaultSnippets(e.schema, o, i, { newLineFirst: !1, indentFirstObject: !1, shouldIndentWithTab: !0 }, 1) : this.collectDefaultSnippets(e.schema, o, i, { newLineFirst: !1, indentFirstObject: !0, shouldIndentWithTab: !1 }, 1));
            } }
            getValueCompletions(e, t, n, r, o, i, s, a) { let u = null; if (n && vo(n) && (n = t.getParent(n)), n) {
                if (yo(n)) {
                    const e = n.value;
                    if (e && e.range && r > e.range[0] + e.range[2])
                        return;
                    u = vo(n.key) ? n.key.value + "" : null, n = t.getParent(n);
                }
                if (n && (null !== u || bo(n))) {
                    const c = "", l = t.getMatchingSchemas(e.schema, -1, null, a);
                    for (const e of l)
                        if (e.node.internalNode === n && !e.inverted && e.schema) {
                            if (e.schema.items && (this.collectDefaultSnippets(e.schema, c, i, { newLineFirst: !1, indentFirstObject: !1, shouldIndentWithTab: !1 }), bo(n) && n.items))
                                if (Array.isArray(e.schema.items)) {
                                    const t = this.findItemAtOffset(n, o, r);
                                    t < e.schema.items.length && this.addSchemaValueCompletions(e.schema.items[t], c, i, s, "value");
                                }
                                else
                                    "object" != typeof e.schema.items || "object" !== e.schema.items.type && !Ka(e.schema.items) ? this.addSchemaValueCompletions(e.schema.items, c, i, s, "value") : this.addSchemaValueCompletions(e.schema.items, c, i, s, "value", !0);
                            if (e.schema.properties) {
                                const t = e.schema.properties[u];
                                t && this.addSchemaValueCompletions(t, c, i, s, "value");
                            }
                            else
                                e.schema.additionalProperties && this.addSchemaValueCompletions(e.schema.additionalProperties, c, i, s, "value");
                        }
                    s.boolean && (this.addBooleanValueCompletion(!0, c, i), this.addBooleanValueCompletion(!1, c, i)), s.null && this.addNullValueCompletion(c, i);
                }
            }
            else
                this.addSchemaValueCompletions(e.schema, "", i, s, "value"); }
            addArrayItemValueCompletion(e, t, n, r) { const o = $a(e), i = `- ${this.getInsertTextForObject(e, t).insertText.trimLeft()}`, s = o ? " type `" + o + "`" : "", a = e.description ? " (" + e.description + ")" : "", u = this.getDocumentationWithMarkdownText(`Create an item of an array${s}${a}`, i); n.add({ kind: this.getSuggestionKind(e.type), label: "- (array item) " + (o || r), documentation: u, insertText: i, insertTextFormat: on.Snippet }); }
            getInsertTextForProperty(e, t, n, r = this.indentation) { const o = this.getInsertTextForValue(e, "", "string"), i = o + ":"; let s, a = 0; if (t) {
                let e = Array.isArray(t.type) ? t.type[0] : t.type;
                if (e || (t.properties ? e = "object" : t.items ? e = "array" : t.anyOf && (e = "anyOf")), Array.isArray(t.defaultSnippets)) {
                    if (1 === t.defaultSnippets.length) {
                        const e = t.defaultSnippets[0].body;
                        Ia(e) && (s = this.getInsertTextForSnippetValue(e, "", { newLineFirst: !0, indentFirstObject: !1, shouldIndentWithTab: !1 }, 1), s.startsWith(" ") || s.startsWith("\n") || (s = " " + s));
                    }
                    a += t.defaultSnippets.length;
                }
                if (t.enum && (s || 1 !== t.enum.length || (s = " " + this.getInsertTextForGuessedValue(t.enum[0], "", e)), a += t.enum.length), t.const && (s || (s = this.getInsertTextForGuessedValue(t.const, "", e), s = function (e) { return e.replace(/\$\{1:(.*)\}/, "$1"); }(s), s = " " + s), a++), Ia(t.default) && (s || (s = " " + this.getInsertTextForGuessedValue(t.default, "", e)), a++), Array.isArray(t.examples) && t.examples.length && (s || (s = " " + this.getInsertTextForGuessedValue(t.examples[0], "", e)), a += t.examples.length), t.properties)
                    return `${i}\n${this.getInsertTextForObject(t, n, r).insertText}`;
                if (t.items)
                    return `${i}\n${r}- ${this.getInsertTextForArray(t.items, n, 1, r).insertText}`;
                if (0 === a)
                    switch (e) {
                        case "boolean":
                        case "string":
                        case "anyOf":
                            s = " $1";
                            break;
                        case "object":
                            s = `\n${r}`;
                            break;
                        case "array":
                            s = `\n${r}- `;
                            break;
                        case "number":
                        case "integer":
                            s = " ${1:0}";
                            break;
                        case "null":
                            s = " ${1:null}";
                            break;
                        default: return o;
                    }
            } return (!s || a > 1) && (s = " $1"), i + s + n; }
            getInsertTextForObject(e, t, n = this.indentation, r = 1) { let o = ""; return e.properties ? (Object.keys(e.properties).forEach((i => { const s = e.properties[i]; let a = Array.isArray(s.type) ? s.type[0] : s.type; if (a || (s.anyOf && (a = "anyOf"), s.properties && (a = "object"), s.items && (a = "array")), e.required && e.required.indexOf(i) > -1)
                switch (a) {
                    case "boolean":
                    case "string":
                    case "number":
                    case "integer":
                    case "anyOf": {
                        let e = s.default || s.const;
                        e ? ("string" === a && (e = Kc(e)), o += `${n}${i}: \${${r++}:${e}}\n`) : o += `${n}${i}: $${r++}\n`;
                        break;
                    }
                    case "array":
                        {
                            const e = this.getInsertTextForArray(s.items, t, r++, n), a = e.insertText.split("\n");
                            let u = e.insertText;
                            if (a.length > 1) {
                                for (let e = 1; e < a.length; e++) {
                                    const t = a[e];
                                    a[e] = `  ${t}`;
                                }
                                u = a.join("\n");
                            }
                            r = e.insertIndex, o += `${n}${i}:\n${n}${this.indentation}- ${u}\n`;
                        }
                        break;
                    case "object": {
                        const e = this.getInsertTextForObject(s, t, `${n}${this.indentation}`, r++);
                        r = e.insertIndex, o += `${n}${i}:\n${e.insertText}\n`;
                    }
                }
            else if (!this.disableDefaultProperties && void 0 !== s.default)
                switch (a) {
                    case "boolean":
                    case "number":
                    case "integer":
                        o += `${n}${"null" === i ? this.getInsertTextForValue(i, "", "string") : i}: \${${r++}:${s.default}}\n`;
                        break;
                    case "string": o += `${n}${i}: \${${r++}:${Kc(s.default)}}\n`;
                } })), 0 === o.trim().length && (o = `${n}$${r++}\n`), o = o.trimRight() + t, { insertText: o, insertIndex: r }) : (o = `${n}$${r++}\n`, { insertText: o, insertIndex: r }); }
            getInsertTextForArray(e, t, n = 1, r = this.indentation) { let o = ""; if (!e)
                return o = "$" + n++, { insertText: o, insertIndex: n }; let i = Array.isArray(e.type) ? e.type[0] : e.type; switch (i || (e.properties && (i = "object"), e.items && (i = "array")), e.type) {
                case "boolean":
                    o = `\${${n++}:false}`;
                    break;
                case "number":
                case "integer":
                    o = `\${${n++}:0}`;
                    break;
                case "string":
                    o = `\${${n++}:""}`;
                    break;
                case "object": {
                    const i = this.getInsertTextForObject(e, t, `${r}  `, n++);
                    o = i.insertText.trimLeft(), n = i.insertIndex;
                }
            } return { insertText: o, insertIndex: n }; }
            getInsertTextForGuessedValue(e, t, n) { switch (typeof e) {
                case "object": return null === e ? "${1:null}" + t : this.getInsertTextForValue(e, t, n);
                case "string": {
                    let r = JSON.stringify(e);
                    return r = r.substr(1, r.length - 2), r = this.getInsertTextForPlainText(r), "string" === n && (r = Kc(r)), "${1:" + r + "}" + t;
                }
                case "number":
                case "boolean": return "${1:" + e + "}" + t;
            } return this.getInsertTextForValue(e, t, n); }
            getInsertTextForPlainText(e) { return e.replace(/[\\$}]/g, "\\$&"); }
            getInsertTextForValue(e, t, n) { if (null === e)
                return "null"; switch (typeof e) {
                case "object": {
                    const n = this.indentation;
                    return this.getInsertTemplateForValue(e, n, { index: 1 }, t);
                }
                case "number":
                case "boolean": return this.getInsertTextForPlainText(e + t);
            } return "string" === (n = Array.isArray(n) ? n[0] : n) && (e = Kc(e)), this.getInsertTextForPlainText(e + t); }
            getInsertTemplateForValue(e, t, n, r) { if (Array.isArray(e)) {
                let r = "\n";
                for (const o of e)
                    r += `${t}- \${${n.index++}:${o}}\n`;
                return r;
            } if ("object" == typeof e) {
                let o = "\n";
                for (const i in e)
                    if (Object.prototype.hasOwnProperty.call(e, i)) {
                        const s = e[i];
                        let a;
                        o += `${t}\${${n.index++}:${i}}:`, a = "object" == typeof s ? `${this.getInsertTemplateForValue(s, t + this.indentation, n, r)}` : ` \${${n.index++}:${this.getInsertTextForPlainText(s + r)}}\n`, o += `${a}`;
                    }
                return o;
            } return this.getInsertTextForPlainText(e + r); }
            addSchemaValueCompletions(e, t, n, r, o, i) { "object" == typeof e && (this.addEnumValueCompletions(e, t, n, i), this.addDefaultValueCompletions(e, t, n), this.collectTypes(e, r), i && "value" === o && !Ka(e) && this.addArrayItemValueCompletion(e, t, n), Array.isArray(e.allOf) && e.allOf.forEach((e => this.addSchemaValueCompletions(e, t, n, r, o, i))), Array.isArray(e.anyOf) && e.anyOf.forEach((e => this.addSchemaValueCompletions(e, t, n, r, o, i))), Array.isArray(e.oneOf) && e.oneOf.forEach((e => this.addSchemaValueCompletions(e, t, n, r, o, i)))); }
            collectTypes(e, t) { if (Array.isArray(e.enum) || Ia(e.const))
                return; const n = e.type; Array.isArray(n) ? n.forEach((function (e) { return t[e] = !0; })) : n && (t[n] = !0); }
            addDefaultValueCompletions(e, t, n, r = 0) { let o = !1; if (Ia(e.default)) {
                let i, s = e.type, a = e.default;
                for (let e = r; e > 0; e--)
                    a = [a], s = "array";
                i = "object" == typeof a ? "Default value" : a.toString().replace(Uc, '"'), n.add({ kind: this.getSuggestionKind(s), label: i, insertText: this.getInsertTextForValue(a, t, s), insertTextFormat: on.Snippet, detail: $c("json.suggest.default", "Default value") }), o = !0;
            } Array.isArray(e.examples) && e.examples.forEach((i => { let s = e.type, a = i; for (let e = r; e > 0; e--)
                a = [a], s = "array"; n.add({ kind: this.getSuggestionKind(s), label: this.getLabelForValue(a), insertText: this.getInsertTextForValue(a, t, s), insertTextFormat: on.Snippet }), o = !0; })), this.collectDefaultSnippets(e, t, n, { newLineFirst: !0, indentFirstObject: !0, shouldIndentWithTab: !0 }), o || "object" != typeof e.items || Array.isArray(e.items) || this.addDefaultValueCompletions(e.items, t, n, r + 1); }
            addEnumValueCompletions(e, t, n, r) { if (Ia(e.const) && !r && n.add({ kind: this.getSuggestionKind(e.type), label: this.getLabelForValue(e.const), insertText: this.getInsertTextForValue(e.const, t, e.type), insertTextFormat: on.Snippet, documentation: this.fromMarkup(e.markdownDescription) || e.description }), Array.isArray(e.enum))
                for (let r = 0, o = e.enum.length; r < o; r++) {
                    const o = e.enum[r];
                    let i = this.fromMarkup(e.markdownDescription) || e.description;
                    e.markdownEnumDescriptions && r < e.markdownEnumDescriptions.length && this.doesSupportMarkdown() ? i = this.fromMarkup(e.markdownEnumDescriptions[r]) : e.enumDescriptions && r < e.enumDescriptions.length && (i = e.enumDescriptions[r]), n.add({ kind: this.getSuggestionKind(e.type), label: this.getLabelForValue(o), insertText: this.getInsertTextForValue(o, t, e.type), insertTextFormat: on.Snippet, documentation: i });
                } }
            getLabelForValue(e) { return null === e ? "null" : Array.isArray(e) ? JSON.stringify(e) : "" + e; }
            collectDefaultSnippets(e, t, n, r, o = 0) { if (Array.isArray(e.defaultSnippets))
                for (const i of e.defaultSnippets) {
                    let s, a, u = e.type, c = i.body, l = i.label;
                    if (Ia(c)) {
                        const n = i.type || e.type;
                        if (0 === o && "array" === n) {
                            const e = {};
                            Object.keys(c).forEach(((t, n) => { 0 !== n || t.startsWith("-") ? e[`  ${t}`] = c[t] : e[`- ${t}`] = c[t]; })), c = e;
                        }
                        s = this.getInsertTextForSnippetValue(c, t, r), l = l || this.getLabelForSnippetValue(c);
                    }
                    else if ("string" == typeof i.bodyText) {
                        let e = "", n = "", r = "";
                        for (let t = o; t > 0; t--)
                            e = e + r + "[\n", n = n + "\n" + r + "]", r += this.indentation, u = "array";
                        s = e + r + i.bodyText.split("\n").join("\n" + r) + n + t, l = l || s, a = s.replace(/[\n]/g, "");
                    }
                    n.add({ kind: i.suggestionKind || this.getSuggestionKind(u), label: l, sortText: i.sortText || i.label, documentation: this.fromMarkup(i.markdownDescription) || i.description, insertText: s, insertTextFormat: on.Snippet, filterText: a });
                } }
            getInsertTextForSnippetValue(e, t, n, r) { return jc(e, "", (e => { if ("string" == typeof e) {
                if ("^" === e[0])
                    return e.substr(1);
                if ("true" === e || "false" === e)
                    return `"${e}"`;
            } return e; }), { ...n, indentation: this.indentation }, r) + t; }
            addBooleanValueCompletion(e, t, n) { n.add({ kind: this.getSuggestionKind("boolean"), label: e ? "true" : "false", insertText: this.getInsertTextForValue(e, t, "boolean"), insertTextFormat: on.Snippet, documentation: "" }); }
            addNullValueCompletion(e, t) { t.add({ kind: this.getSuggestionKind("null"), label: "null", insertText: "null" + e, insertTextFormat: on.Snippet, documentation: "" }); }
            getLabelForSnippetValue(e) { return JSON.stringify(e).replace(/\$\{\d+:([^}]+)\}|\$\d+/g, "$1"); }
            getCustomTagValueCompletions(e) { yu(this.customTags).forEach((t => { const n = t.split(" ")[0]; this.addCustomTagValueCompletion(e, " ", n); })); }
            addCustomTagValueCompletion(e, t, n) { e.add({ kind: this.getSuggestionKind("string"), label: n, insertText: n + t, insertTextFormat: on.Snippet, documentation: "" }); }
            getDocumentationWithMarkdownText(e, t) { let n = e; return this.doesSupportMarkdown() && (t = t.replace(/\${[0-9]+[:|](.*)}/g, ((e, t) => t)).replace(/\$([0-9]+)/g, ""), n = this.fromMarkup(`${e}\n \`\`\`\n${t}\n\`\`\``)), n; }
            getSuggestionKind(e) { if (Array.isArray(e)) {
                const t = e;
                e = t.length > 0 ? t[0] : null;
            } if (!e)
                return nn.Value; switch (e) {
                case "string":
                default: return nn.Value;
                case "object": return nn.Module;
                case "property": return nn.Property;
            } }
            getCurrentWord(e, t) { let n = t - 1; const r = e.getText(); for (; n >= 0 && -1 === ' \t\n\r\v":{[,]}'.indexOf(r.charAt(n));)
                n--; return r.substring(n + 1, t); }
            fromMarkup(e) { if (e && this.doesSupportMarkdown())
                return { kind: Zt.Markdown, value: e }; }
            doesSupportMarkdown() { if (void 0 === this.supportsMarkdown) {
                const e = this.clientCapabilities.textDocument && this.clientCapabilities.textDocument.completion;
                this.supportsMarkdown = e && e.completionItem && Array.isArray(e.completionItem.documentationFormat) && -1 !== e.completionItem.documentationFormat.indexOf(Zt.Markdown);
            } return this.supportsMarkdown; }
            findItemAtOffset(e, t, n) { for (let t = e.items.length - 1; t >= 0; t--) {
                const r = e.items[t];
                if (Eo(r) && r.range) {
                    if (n > r.range[1])
                        return t;
                    if (n >= r.range[0])
                        return t;
                }
            } return 0; }
        }(s, i, tc, r), c = new class {
            constructor(e, t) { this.telemetry = t, this.shouldHover = !0, this.schemaService = e; }
            configure(e) { e && (this.shouldHover = e.hover); }
            doHover(e, t, n = !1) { try {
                if (!this.shouldHover || !e)
                    return Promise.resolve(void 0);
                const r = tc.getYamlDocument(e), o = gu(e.offsetAt(t), r);
                if (null === o)
                    return Promise.resolve(void 0);
                yc(r.documents, n);
                const i = r.documents.indexOf(o);
                return o.currentDocIndex = i, this.getHover(e, t, o);
            }
            catch (e) {
                this.telemetry.sendError("yaml.hover.error", { error: La(e) });
            } }
            getHover(e, t, n) { const r = e.offsetAt(t); let o = n.getNodeFromOffset(r); if (!o || ("object" === o.type || "array" === o.type) && r > o.offset + 1 && r < o.offset + o.length - 1)
                return Promise.resolve(null); const i = o; if ("string" === o.type) {
                const e = o.parent;
                if (e && "property" === e.type && e.keyNode === o && (o = e.valueNode, !o))
                    return Promise.resolve(null);
            } const s = He.create(e.positionAt(i.offset), e.positionAt(i.offset + i.length)), a = e => e.replace(/\|\|\s*$/, ""); return this.schemaService.getSchemaForResource(e.uri, n).then((e => { if (e && o && !e.errors.length) {
                const r = n.getMatchingSchemas(e.schema, o.offset);
                let i, u, c, l;
                const p = [];
                r.every((e => { if ((e.node === o || "property" === o.type && o.valueNode === e.node) && !e.inverted && e.schema) {
                    if (i = i || e.schema.title || e.schema.closestTitle, u = u || e.schema.markdownDescription || bc(e.schema.description), e.schema.enum) {
                        const t = e.schema.enum.indexOf(Lu(o));
                        e.schema.markdownEnumDescriptions ? c = e.schema.markdownEnumDescriptions[t] : e.schema.enumDescriptions && (c = bc(e.schema.enumDescriptions[t])), c && (l = e.schema.enum[t], "string" != typeof l && (l = JSON.stringify(l)));
                    }
                    e.schema.anyOf && function (e, t, n) { let r = 0; for (const o of t)
                        e === o.node && o.schema !== n && n.anyOf.forEach((e => { o.schema.title === e.title && o.schema.description === e.description && o.schema.properties === e.properties && r++; })); return r === n.anyOf.length; }(o, r, e.schema) && (i = "", u = "", e.schema.anyOf.forEach(((t, n) => { i += t.title || e.schema.closestTitle || "", u += t.markdownDescription || bc(t.description) || "", n !== e.schema.anyOf.length - 1 && (i += " || ", u += " || "); })), i = a(i), u = a(u)), e.schema.examples && e.schema.examples.forEach((e => { p.push(JSON.stringify(e)); }));
                } return !0; }));
                let f = "";
                return i && (f = "#### " + bc(i)), u && (f.length > 0 && (f += "\n\n"), f += u), c && (f.length > 0 && (f += "\n\n"), f += `\`${t = l, -1 !== t.indexOf("`") ? "`` " + t + " ``" : t}\`: ${c}`), 0 !== p.length && (f.length > 0 && (f += "\n\n"), f += "Examples:", p.forEach((e => { f += `\n\n\`\`\`${e}\`\`\``; }))), f.length > 0 && e.schema.url && (f += `\n\nSource: [${function (e) { let t = "JSON Schema"; const n = e.url; if (n) {
                    const e = It.parse(n);
                    t = vc.basename(e.fsPath);
                }
                else
                    e.title && (t = e.title); return t; }(e.schema)}](${e.schema.url})`), { contents: { kind: "markdown", value: f }, range: s };
            } var t; return null; })); }
        }(s, r), l = new class {
            constructor(e, t) { this.telemetry = t, this.jsonDocumentSymbols = new nu(e), this.jsonDocumentSymbols.getKeyLabel = e => { const t = e.keyNode.internalNode; let n = ""; return n = go(t) ? "{}" : bo(t) ? "[]" : t.source, n; }; }
            findDocumentSymbols(e, t = { resultLimit: Number.MAX_VALUE }) { let n = []; try {
                const r = tc.getYamlDocument(e);
                if (!r || 0 === r.documents.length)
                    return null;
                for (const o of r.documents)
                    o.root && (n = n.concat(this.jsonDocumentSymbols.findDocumentSymbols(e, o, t)));
            }
            catch (e) {
                this.telemetry.sendError("yaml.documentSymbols.error", { error: La(e) });
            } return n; }
            findHierarchicalDocumentSymbols(e, t = { resultLimit: Number.MAX_VALUE }) { let n = []; try {
                const r = tc.getYamlDocument(e);
                if (!r || 0 === r.documents.length)
                    return null;
                for (const o of r.documents)
                    o.root && (n = n.concat(this.jsonDocumentSymbols.findDocumentSymbols2(e, o, t)));
            }
            catch (e) {
                this.telemetry.sendError("yaml.hierarchicalDocumentSymbols.error", { error: La(e) });
            } return n; }
        }(s, r), p = new Cc(s, r), f = new class {
            constructor() { this.formatterEnabled = !0; }
            configure(e) { e && (this.formatterEnabled = e.format); }
            format(e, t) { if (!this.formatterEnabled)
                return []; try {
                const n = e.getText(), r = { parser: "yaml", plugins: [Sc], tabWidth: t.tabWidth || t.tabSize, singleQuote: t.singleQuote, bracketSpacing: t.bracketSpacing, proseWrap: "always" === t.proseWrap ? "always" : "never" === t.proseWrap ? "never" : "preserve", printWidth: t.printWidth }, o = Ac.format(n, r);
                return [Dt.replace(He.create(Ke.create(0, 0), e.positionAt(n.length)), o)];
            }
            catch (e) {
                return [];
            } }
        }, d = new class {
            constructor(e) { this.clientCapabilities = e, this.indentation = "  "; }
            configure(e) { this.indentation = e.indentation; }
            getCodeAction(e, t) { if (!t.context.diagnostics)
                return; const n = []; return n.push(...this.getConvertToBooleanActions(t.context.diagnostics, e)), n.push(...this.getJumpToSchemaActions(t.context.diagnostics)), n.push(...this.getTabToSpaceConverting(t.context.diagnostics, e)), n.push(...this.getUnusedAnchorsDelete(t.context.diagnostics, e)), n.push(...this.getConvertToBlockStyleActions(t.context.diagnostics, e)), n; }
            getJumpToSchemaActions(e) { var t, n, r, o, i; if (null == (o = null == (r = null == (n = null == (t = this.clientCapabilities) ? void 0 : t.window) ? void 0 : n.showDocument) ? void 0 : r.support) || !o)
                return []; const s = new Map; for (const t of e) {
                const e = (null == (i = t.data) ? void 0 : i.schemaUri) || [];
                for (const n of e)
                    n && (s.has(n) || s.set(n, []), s.get(n).push(t));
            } const a = []; for (const e of s.keys()) {
                const t = In.create(`Jump to schema location (${kc.basename(e)})`, vt.create("JumpToSchema", wc.JUMP_TO_SCHEMA, e));
                t.diagnostics = s.get(e), a.push(t);
            } return a; }
            getTabToSpaceConverting(e, t) { const n = [], r = new ic(t), o = []; for (const i of e)
                if ("Using tabs can lead to unpredictable results" === i.message) {
                    if (o.includes(i.range.start.line))
                        continue;
                    const e = r.getLineContent(i.range.start.line);
                    let s = 0, a = "";
                    for (let t = i.range.start.character; t <= i.range.end.character && "\t" === e.charAt(t); t++)
                        s++, a += this.indentation;
                    o.push(i.range.start.line);
                    let u = i.range;
                    s !== i.range.end.character - i.range.start.character && (u = He.create(i.range.start, Ke.create(i.range.end.line, i.range.start.character + s))), n.push(In.create("Convert Tab to Spaces", Oc(t.uri, [Dt.replace(u, a)]), On.QuickFix));
                } if (0 !== n.length) {
                const e = [];
                for (let t = 0; t <= r.getLineCount(); t++) {
                    const n = r.getLineContent(t);
                    let o = 0, i = "";
                    for (let r = 0; r < n.length; r++) {
                        const s = n.charAt(r);
                        if (" " !== s && "\t" !== s) {
                            0 !== o && (e.push(Dt.replace(He.create(t, r - o, t, r), i)), o = 0, i = "");
                            break;
                        }
                        " " !== s || 0 === o ? "\t" === s && (i += this.indentation, o++) : (e.push(Dt.replace(He.create(t, r - o, t, r), i)), o = 0, i = "");
                    }
                    0 !== o && e.push(Dt.replace(He.create(t, 0, t, r.getLineLength(t)), i));
                }
                e.length > 0 && n.push(In.create("Convert all Tabs to Spaces", Oc(t.uri, e), On.QuickFix));
            } return n; }
            getUnusedAnchorsDelete(e, t) { const n = [], r = new ic(t); for (const o of e)
                if (o.message.startsWith("Unused anchor") && o.source === Au) {
                    const e = He.create(o.range.start, o.range.end), i = r.getText(e), s = io(r.getLineContent(e.end.line), e.end.character);
                    e.end.character = s;
                    const a = In.create(`Delete unused anchor: ${i}`, Oc(t.uri, [Dt.del(e)]), On.QuickFix);
                    a.diagnostics = [o], n.push(a);
                } return n; }
            getConvertToBooleanActions(e, t) { const n = []; for (const r of e)
                if ('Incorrect type. Expected "boolean".' === r.message) {
                    const e = t.getText(r.range).toLocaleLowerCase();
                    if ('"true"' === e || '"false"' === e || "'true'" === e || "'false'" === e) {
                        const o = e.includes("true") ? "true" : "false";
                        n.push(In.create("Convert to boolean", Oc(t.uri, [Dt.replace(r.range, o)]), On.QuickFix));
                    }
                } return n; }
            getConvertToBlockStyleActions(e, t) { const n = []; for (const r of e)
                if ("flowMap" === r.code || "flowSeq" === r.code) {
                    const e = tc.getYamlDocument(t), o = t.offsetAt(r.range.start), i = gu(o, e).getNodeFromOffset(o);
                    if (go(i.internalNode) || bo(i.internalNode)) {
                        const e = go(i.internalNode) ? "map" : "sequence", o = new Fc(this.indentation);
                        n.push(In.create(`Convert to block style ${e}`, Oc(t.uri, [Dt.replace(r.range, o.write(i))]), On.QuickFix));
                    }
                } return n; }
        }(i), h = new class {
            constructor(e, t) { this.schemaService = e, this.telemetry = t; }
            async getCodeLens(e) { const t = []; try {
                const n = tc.getYamlDocument(e);
                let r = new Map;
                for (const t of n.documents) {
                    const n = await this.schemaService.getSchemaForResource(e.uri, t);
                    (null == n ? void 0 : n.schema) && (r = new Map([...Pc(null == n ? void 0 : n.schema), ...r]));
                }
                for (const e of r) {
                    const n = Bn.create(He.create(0, 0, 0, 0));
                    n.command = { title: Va(e[1], e[0]), command: wc.JUMP_TO_SCHEMA, arguments: [e[0]] }, t.push(n);
                }
            }
            catch (e) {
                this.telemetry.sendError("yaml.codeLens.error", { error: La(e) });
            } return t; }
            resolveCodeLens(e) { return e; }
        }(s, r), m = new class {
            constructor(e) { this.telemetry = e; }
            findLinks(e) { try {
                const t = tc.getYamlDocument(e), n = [];
                for (const r of t.documents)
                    n.push(fu(e, r));
                return Promise.all(n).then((e => [].concat(...e)));
            }
            catch (e) {
                this.telemetry.sendError("yaml.documentLink.error", { error: La(e) });
            } }
        }(r), g = new class {
            constructor(e) { this.telemetry = e; }
            getDefinition(e, t) { try {
                const n = tc.getYamlDocument(e), r = e.offsetAt(t.position), o = gu(r, n);
                if (o) {
                    const [t] = o.getNodeFromPosition(r, new ic(e));
                    if (t && ho(t)) {
                        const n = t.resolve(o.internalDocument);
                        if (n && n.range) {
                            const t = He.create(e.positionAt(n.range[0]), e.positionAt(n.range[2])), r = He.create(e.positionAt(n.range[0]), e.positionAt(n.range[1]));
                            return [Xe.create(e.uri, t, r)];
                        }
                    }
                }
            }
            catch (e) {
                this.telemetry.sendError("yaml.definition.error", { error: La(e) });
            } }
        }(r); return new zc(s, o, n), function (e, t) { e.registerCommand(wc.JUMP_TO_SCHEMA, (async (e) => { if (e) {
            if (!e.startsWith("file") && !/^[a-z]:[\\/]/i.test(e)) {
                const t = It.parse(e);
                e = It.from({ scheme: "json-schema", authority: t.authority, path: t.path.endsWith(".json") ? t.path : t.path + ".json", fragment: e }).toString();
            }
            /^[a-z]:[\\/]/i.test(e) && (e = It.file(e).toString()), await t.window.showDocument({ uri: e, external: !1, takeFocus: !0 }) || t.window.showErrorMessage(`Cannot open ${e}`);
        } })); }(_c, n), { configure: e => { s.clearExternalSchemas(), e.schemas && (s.schemaPriorityMapping = new Map, e.schemas.forEach((e => { const t = e.priority ? e.priority : 0; s.addSchemaPriority(e.uri, t), s.registerExternalSchema(e.uri, e.fileMatch, e.schema, e.name, e.description, e.versions); }))), p.configure(e), c.configure(e), u.configure(e), f.configure(e), d.configure(e); }, registerCustomSchemaProvider: e => { s.registerCustomSchemaProvider(e); }, findLinks: m.findLinks.bind(m), doComplete: u.doComplete.bind(u), doValidation: p.doValidation.bind(p), doHover: c.doHover.bind(c), findDocumentSymbols: l.findDocumentSymbols.bind(l), findDocumentSymbols2: l.findHierarchicalDocumentSymbols.bind(l), doDefinition: g.getDefinition.bind(g), resetSchema: e => s.onResourceChange(e), doFormat: f.format.bind(f), doDocumentOnTypeFormatting: Nc, addSchema: (e, t) => s.saveSchema(e, t), deleteSchema: e => s.deleteSchema(e), modifySchemaContent: e => s.addContent(e), deleteSchemaContent: e => s.deleteContent(e), deleteSchemasWhole: e => s.deleteSchemas(e), getFoldingRanges: xc, getCodeAction: (e, t) => d.getCodeAction(e, t), getCodeLens: e => h.getCodeLens(e), resolveCodeLens: e => h.resolveCodeLens(e) }; };
        var Hc = b(Ce());
        t.SettingsState = class {
            constructor() { this.yamlConfigurationSettings = void 0, this.schemaAssociations = void 0, this.formatterRegistration = null, this.specificValidatorPaths = [], this.schemaConfigurationSettings = [], this.yamlShouldValidate = !0, this.yamlFormatterSettings = { singleQuote: !1, bracketSpacing: !0, proseWrap: "preserve", printWidth: 80, enable: !0 }, this.yamlShouldHover = !0, this.yamlShouldCompletion = !0, this.schemaStoreSettings = [], this.customTags = [], this.schemaStoreEnabled = !0, this.schemaStoreUrl = "https://www.schemastore.org/api/json/catalog.json", this.indentation = void 0, this.disableAdditionalProperties = !1, this.disableDefaultProperties = !1, this.suggest = { parentSkeletonSelectedFirst: !1 }, this.maxItemsComputed = 5e3, this.pendingValidationRequests = {}, this.validationDelayMs = 200, this.documents = new Hc.TextDocuments(br), this.workspaceRoot = null, this.workspaceFolders = [], this.clientDynamicRegisterSupport = !1, this.hierarchicalDocumentSymbolSupport = !1, this.hasWorkspaceFolderCapability = !1, this.hasConfigurationCapability = !1, this.useVSCodeContentRequest = !1, this.yamlVersion = "1.2", this.useSchemaSelectionRequests = !1, this.hasWsChangeWatchedFileDynamicRegistration = !1, this.fileExtensions = [".yml", ".yaml"]; }
        };
    }, 6508: (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }), t.mergeObjects = void 0, t.mergeObjects = function e(t, n) { if (!t)
            return n; if (!n)
            return t; const r = {}; for (const o of [...Object.keys(t), ...Object.keys(n)])
            t[o] && n[o] ? Array.isArray(t[o]) ? r[o] = t[o].concat(n[o]) : r[o] = e(t[o], n[o]) : r[o] = t[o] ?? n[o]; return r; };
    }, 82: e => { e.exports = function (e) { return e && "object" == typeof e && "function" == typeof e.copy && "function" == typeof e.fill && "function" == typeof e.readUInt8; }; }, 4895: (e, t, n) => {
        "use strict";
        var r = n(2635), o = n(3138), i = n(2094), s = n(198);
        function a(e) { return e.call.bind(e); }
        var u = "undefined" != typeof BigInt, c = "undefined" != typeof Symbol, l = a(Object.prototype.toString), p = a(Number.prototype.valueOf), f = a(String.prototype.valueOf), d = a(Boolean.prototype.valueOf);
        if (u)
            var h = a(BigInt.prototype.valueOf);
        if (c)
            var m = a(Symbol.prototype.valueOf);
        function g(e, t) { if ("object" != typeof e)
            return !1; try {
            return t(e), !0;
        }
        catch (e) {
            return !1;
        } }
        function y(e) { return "[object Map]" === l(e); }
        function v(e) { return "[object Set]" === l(e); }
        function b(e) { return "[object WeakMap]" === l(e); }
        function D(e) { return "[object WeakSet]" === l(e); }
        function E(e) { return "[object ArrayBuffer]" === l(e); }
        function C(e) { return "undefined" != typeof ArrayBuffer && (E.working ? E(e) : e instanceof ArrayBuffer); }
        function w(e) { return "[object DataView]" === l(e); }
        function A(e) { return "undefined" != typeof DataView && (w.working ? w(e) : e instanceof DataView); }
        t.isArgumentsObject = r, t.isGeneratorFunction = o, t.isTypedArray = s, t.isPromise = function (e) { return "undefined" != typeof Promise && e instanceof Promise || null !== e && "object" == typeof e && "function" == typeof e.then && "function" == typeof e.catch; }, t.isArrayBufferView = function (e) { return "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e) : s(e) || A(e); }, t.isUint8Array = function (e) { return "Uint8Array" === i(e); }, t.isUint8ClampedArray = function (e) { return "Uint8ClampedArray" === i(e); }, t.isUint16Array = function (e) { return "Uint16Array" === i(e); }, t.isUint32Array = function (e) { return "Uint32Array" === i(e); }, t.isInt8Array = function (e) { return "Int8Array" === i(e); }, t.isInt16Array = function (e) { return "Int16Array" === i(e); }, t.isInt32Array = function (e) { return "Int32Array" === i(e); }, t.isFloat32Array = function (e) { return "Float32Array" === i(e); }, t.isFloat64Array = function (e) { return "Float64Array" === i(e); }, t.isBigInt64Array = function (e) { return "BigInt64Array" === i(e); }, t.isBigUint64Array = function (e) { return "BigUint64Array" === i(e); }, y.working = "undefined" != typeof Map && y(new Map), t.isMap = function (e) { return "undefined" != typeof Map && (y.working ? y(e) : e instanceof Map); }, v.working = "undefined" != typeof Set && v(new Set), t.isSet = function (e) { return "undefined" != typeof Set && (v.working ? v(e) : e instanceof Set); }, b.working = "undefined" != typeof WeakMap && b(new WeakMap), t.isWeakMap = function (e) { return "undefined" != typeof WeakMap && (b.working ? b(e) : e instanceof WeakMap); }, D.working = "undefined" != typeof WeakSet && D(new WeakSet), t.isWeakSet = function (e) { return D(e); }, E.working = "undefined" != typeof ArrayBuffer && E(new ArrayBuffer), t.isArrayBuffer = C, w.working = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView && w(new DataView(new ArrayBuffer(1), 0, 1)), t.isDataView = A;
        var S = "undefined" != typeof SharedArrayBuffer ? SharedArrayBuffer : void 0;
        function x(e) { return "[object SharedArrayBuffer]" === l(e); }
        function T(e) { return void 0 !== S && (void 0 === x.working && (x.working = x(new S)), x.working ? x(e) : e instanceof S); }
        function k(e) { return g(e, p); }
        function F(e) { return g(e, f); }
        function O(e) { return g(e, d); }
        function _(e) { return u && g(e, h); }
        function N(e) { return c && g(e, m); }
        t.isSharedArrayBuffer = T, t.isAsyncFunction = function (e) { return "[object AsyncFunction]" === l(e); }, t.isMapIterator = function (e) { return "[object Map Iterator]" === l(e); }, t.isSetIterator = function (e) { return "[object Set Iterator]" === l(e); }, t.isGeneratorObject = function (e) { return "[object Generator]" === l(e); }, t.isWebAssemblyCompiledModule = function (e) { return "[object WebAssembly.Module]" === l(e); }, t.isNumberObject = k, t.isStringObject = F, t.isBooleanObject = O, t.isBigIntObject = _, t.isSymbolObject = N, t.isBoxedPrimitive = function (e) { return k(e) || F(e) || O(e) || _(e) || N(e); }, t.isAnyArrayBuffer = function (e) { return "undefined" != typeof Uint8Array && (C(e) || T(e)); }, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach((function (e) { Object.defineProperty(t, e, { enumerable: !1, value: function () { throw new Error(e + " is not supported in userland"); } }); }));
    }, 3335: (e, t, n) => { var r = n(4406), o = n(3716), i = Object.getOwnPropertyDescriptors || function (e) { for (var t = Object.keys(e), n = {}, r = 0; r < t.length; r++)
        n[t[r]] = Object.getOwnPropertyDescriptor(e, t[r]); return n; }, s = /%[sdj%]/g; t.format = function (e) { if (!D(e)) {
        for (var t = [], n = 0; n < arguments.length; n++)
            t.push(l(arguments[n]));
        return t.join(" ");
    } n = 1; for (var r = arguments, o = r.length, i = String(e).replace(s, (function (e) { if ("%%" === e)
        return "%"; if (n >= o)
        return e; switch (e) {
        case "%s": return String(r[n++]);
        case "%d": return Number(r[n++]);
        case "%j": try {
            return JSON.stringify(r[n++]);
        }
        catch (e) {
            return "[Circular]";
        }
        default: return e;
    } })), a = r[n]; n < o; a = r[++n])
        v(a) || !w(a) ? i += " " + a : i += " " + l(a); return i; }, t.deprecate = function (e, n) { if (void 0 !== r && !0 === r.noDeprecation)
        return e; if (void 0 === r)
        return function () { return t.deprecate(e, n).apply(this, arguments); }; var i = !1; return function () { if (!i) {
        if (r.throwDeprecation)
            throw new Error(n);
        r.traceDeprecation ? o.trace(n) : o.error(n), i = !0;
    } return e.apply(this, arguments); }; }; var a = {}, u = /^$/; if (r.env.NODE_DEBUG) {
        var c = r.env.NODE_DEBUG;
        c = c.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), u = new RegExp("^" + c + "$", "i");
    } function l(e, n) { var r = { seen: [], stylize: f }; return arguments.length >= 3 && (r.depth = arguments[2]), arguments.length >= 4 && (r.colors = arguments[3]), y(n) ? r.showHidden = n : n && t._extend(r, n), E(r.showHidden) && (r.showHidden = !1), E(r.depth) && (r.depth = 2), E(r.colors) && (r.colors = !1), E(r.customInspect) && (r.customInspect = !0), r.colors && (r.stylize = p), d(r, e, r.depth); } function p(e, t) { var n = l.styles[t]; return n ? "[" + l.colors[n][0] + "m" + e + "[" + l.colors[n][1] + "m" : e; } function f(e, t) { return e; } function d(e, n, r) { if (e.customInspect && n && x(n.inspect) && n.inspect !== t.inspect && (!n.constructor || n.constructor.prototype !== n)) {
        var o = n.inspect(r, e);
        return D(o) || (o = d(e, o, r)), o;
    } var i = function (e, t) { if (E(t))
        return e.stylize("undefined", "undefined"); if (D(t)) {
        var n = "'" + JSON.stringify(t).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return e.stylize(n, "string");
    } return b(t) ? e.stylize("" + t, "number") : y(t) ? e.stylize("" + t, "boolean") : v(t) ? e.stylize("null", "null") : void 0; }(e, n); if (i)
        return i; var s = Object.keys(n), a = function (e) { var t = {}; return e.forEach((function (e, n) { t[e] = !0; })), t; }(s); if (e.showHidden && (s = Object.getOwnPropertyNames(n)), S(n) && (s.indexOf("message") >= 0 || s.indexOf("description") >= 0))
        return h(n); if (0 === s.length) {
        if (x(n)) {
            var u = n.name ? ": " + n.name : "";
            return e.stylize("[Function" + u + "]", "special");
        }
        if (C(n))
            return e.stylize(RegExp.prototype.toString.call(n), "regexp");
        if (A(n))
            return e.stylize(Date.prototype.toString.call(n), "date");
        if (S(n))
            return h(n);
    } var c, l = "", p = !1, f = ["{", "}"]; return g(n) && (p = !0, f = ["[", "]"]), x(n) && (l = " [Function" + (n.name ? ": " + n.name : "") + "]"), C(n) && (l = " " + RegExp.prototype.toString.call(n)), A(n) && (l = " " + Date.prototype.toUTCString.call(n)), S(n) && (l = " " + h(n)), 0 !== s.length || p && 0 != n.length ? r < 0 ? C(n) ? e.stylize(RegExp.prototype.toString.call(n), "regexp") : e.stylize("[Object]", "special") : (e.seen.push(n), c = p ? function (e, t, n, r, o) { for (var i = [], s = 0, a = t.length; s < a; ++s)
        _(t, String(s)) ? i.push(m(e, t, n, r, String(s), !0)) : i.push(""); return o.forEach((function (o) { o.match(/^\d+$/) || i.push(m(e, t, n, r, o, !0)); })), i; }(e, n, r, a, s) : s.map((function (t) { return m(e, n, r, a, t, p); })), e.seen.pop(), function (e, t, n) { return e.reduce((function (e, t) { return t.indexOf("\n"), e + t.replace(/\u001b\[\d\d?m/g, "").length + 1; }), 0) > 60 ? n[0] + ("" === t ? "" : t + "\n ") + " " + e.join(",\n  ") + " " + n[1] : n[0] + t + " " + e.join(", ") + " " + n[1]; }(c, l, f)) : f[0] + l + f[1]; } function h(e) { return "[" + Error.prototype.toString.call(e) + "]"; } function m(e, t, n, r, o, i) { var s, a, u; if ((u = Object.getOwnPropertyDescriptor(t, o) || { value: t[o] }).get ? a = u.set ? e.stylize("[Getter/Setter]", "special") : e.stylize("[Getter]", "special") : u.set && (a = e.stylize("[Setter]", "special")), _(r, o) || (s = "[" + o + "]"), a || (e.seen.indexOf(u.value) < 0 ? (a = v(n) ? d(e, u.value, null) : d(e, u.value, n - 1)).indexOf("\n") > -1 && (a = i ? a.split("\n").map((function (e) { return "  " + e; })).join("\n").slice(2) : "\n" + a.split("\n").map((function (e) { return "   " + e; })).join("\n")) : a = e.stylize("[Circular]", "special")), E(s)) {
        if (i && o.match(/^\d+$/))
            return a;
        (s = JSON.stringify("" + o)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (s = s.slice(1, -1), s = e.stylize(s, "name")) : (s = s.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), s = e.stylize(s, "string"));
    } return s + ": " + a; } function g(e) { return Array.isArray(e); } function y(e) { return "boolean" == typeof e; } function v(e) { return null === e; } function b(e) { return "number" == typeof e; } function D(e) { return "string" == typeof e; } function E(e) { return void 0 === e; } function C(e) { return w(e) && "[object RegExp]" === T(e); } function w(e) { return "object" == typeof e && null !== e; } function A(e) { return w(e) && "[object Date]" === T(e); } function S(e) { return w(e) && ("[object Error]" === T(e) || e instanceof Error); } function x(e) { return "function" == typeof e; } function T(e) { return Object.prototype.toString.call(e); } function k(e) { return e < 10 ? "0" + e.toString(10) : e.toString(10); } t.debuglog = function (e) { if (e = e.toUpperCase(), !a[e])
        if (u.test(e)) {
            var n = r.pid;
            a[e] = function () { var r = t.format.apply(t, arguments); o.error("%s %d: %s", e, n, r); };
        }
        else
            a[e] = function () { }; return a[e]; }, t.inspect = l, l.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, l.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, t.types = n(4895), t.isArray = g, t.isBoolean = y, t.isNull = v, t.isNullOrUndefined = function (e) { return null == e; }, t.isNumber = b, t.isString = D, t.isSymbol = function (e) { return "symbol" == typeof e; }, t.isUndefined = E, t.isRegExp = C, t.types.isRegExp = C, t.isObject = w, t.isDate = A, t.types.isDate = A, t.isError = S, t.types.isNativeError = S, t.isFunction = x, t.isPrimitive = function (e) { return null === e || "boolean" == typeof e || "number" == typeof e || "string" == typeof e || "symbol" == typeof e || void 0 === e; }, t.isBuffer = n(82); var F = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]; function O() { var e = new Date, t = [k(e.getHours()), k(e.getMinutes()), k(e.getSeconds())].join(":"); return [e.getDate(), F[e.getMonth()], t].join(" "); } function _(e, t) { return Object.prototype.hasOwnProperty.call(e, t); } t.log = function () { o.log("%s - %s", O(), t.format.apply(t, arguments)); }, t.inherits = n(1285), t._extend = function (e, t) { if (!t || !w(t))
        return e; for (var n = Object.keys(t), r = n.length; r--;)
        e[n[r]] = t[n[r]]; return e; }; var N = "undefined" != typeof Symbol ? Symbol("util.promisify.custom") : void 0; function P(e, t) { if (!e) {
        var n = new Error("Promise was rejected with a falsy value");
        n.reason = e, e = n;
    } return t(e); } t.promisify = function (e) { if ("function" != typeof e)
        throw new TypeError('The "original" argument must be of type Function'); if (N && e[N]) {
        var t;
        if ("function" != typeof (t = e[N]))
            throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(t, N, { value: t, enumerable: !1, writable: !1, configurable: !0 }), t;
    } function t() { for (var t, n, r = new Promise((function (e, r) { t = e, n = r; })), o = [], i = 0; i < arguments.length; i++)
        o.push(arguments[i]); o.push((function (e, r) { e ? n(e) : t(r); })); try {
        e.apply(this, o);
    }
    catch (e) {
        n(e);
    } return r; } return Object.setPrototypeOf(t, Object.getPrototypeOf(e)), N && Object.defineProperty(t, N, { value: t, enumerable: !1, writable: !1, configurable: !0 }), Object.defineProperties(t, i(e)); }, t.promisify.custom = N, t.callbackify = function (e) { if ("function" != typeof e)
        throw new TypeError('The "original" argument must be of type Function'); function t() { for (var t = [], n = 0; n < arguments.length; n++)
        t.push(arguments[n]); var o = t.pop(); if ("function" != typeof o)
        throw new TypeError("The last argument must be of type Function"); var i = this, s = function () { return o.apply(i, arguments); }; e.apply(this, t).then((function (e) { r.nextTick(s.bind(null, null, e)); }), (function (e) { r.nextTick(P.bind(null, e, s)); })); } return Object.setPrototypeOf(t, Object.getPrototypeOf(e)), Object.defineProperties(t, i(e)), t; }; }, 4881: (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { TextDocument: () => r });
        var r, o = function (e, t, n) { if (n || 2 === arguments.length)
            for (var r, o = 0, i = t.length; o < i; o++)
                !r && o in t || (r || (r = Array.prototype.slice.call(t, 0, o)), r[o] = t[o]); return e.concat(r || Array.prototype.slice.call(t)); }, i = function () { function e(e, t, n, r) { this._uri = e, this._languageId = t, this._version = n, this._content = r, this._lineOffsets = void 0; } return Object.defineProperty(e.prototype, "uri", { get: function () { return this._uri; }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "languageId", { get: function () { return this._languageId; }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "version", { get: function () { return this._version; }, enumerable: !1, configurable: !0 }), e.prototype.getText = function (e) { if (e) {
            var t = this.offsetAt(e.start), n = this.offsetAt(e.end);
            return this._content.substring(t, n);
        } return this._content; }, e.prototype.update = function (t, n) { for (var r = 0, i = t; r < i.length; r++) {
            var s = i[r];
            if (e.isIncremental(s)) {
                var c = u(s.range), l = this.offsetAt(c.start), p = this.offsetAt(c.end);
                this._content = this._content.substring(0, l) + s.text + this._content.substring(p, this._content.length);
                var f = Math.max(c.start.line, 0), d = Math.max(c.end.line, 0), h = this._lineOffsets, m = a(s.text, !1, l);
                if (d - f === m.length)
                    for (var g = 0, y = m.length; g < y; g++)
                        h[g + f + 1] = m[g];
                else
                    m.length < 1e4 ? h.splice.apply(h, o([f + 1, d - f], m, !1)) : this._lineOffsets = h = h.slice(0, f + 1).concat(m, h.slice(d + 1));
                var v = s.text.length - (p - l);
                if (0 !== v)
                    for (g = f + 1 + m.length, y = h.length; g < y; g++)
                        h[g] = h[g] + v;
            }
            else {
                if (!e.isFull(s))
                    throw new Error("Unknown change event received");
                this._content = s.text, this._lineOffsets = void 0;
            }
        } this._version = n; }, e.prototype.getLineOffsets = function () { return void 0 === this._lineOffsets && (this._lineOffsets = a(this._content, !0)), this._lineOffsets; }, e.prototype.positionAt = function (e) { e = Math.max(Math.min(e, this._content.length), 0); var t = this.getLineOffsets(), n = 0, r = t.length; if (0 === r)
            return { line: 0, character: e }; for (; n < r;) {
            var o = Math.floor((n + r) / 2);
            t[o] > e ? r = o : n = o + 1;
        } var i = n - 1; return { line: i, character: e - t[i] }; }, e.prototype.offsetAt = function (e) { var t = this.getLineOffsets(); if (e.line >= t.length)
            return this._content.length; if (e.line < 0)
            return 0; var n = t[e.line], r = e.line + 1 < t.length ? t[e.line + 1] : this._content.length; return Math.max(Math.min(n + e.character, r), n); }, Object.defineProperty(e.prototype, "lineCount", { get: function () { return this.getLineOffsets().length; }, enumerable: !1, configurable: !0 }), e.isIncremental = function (e) { var t = e; return null != t && "string" == typeof t.text && void 0 !== t.range && (void 0 === t.rangeLength || "number" == typeof t.rangeLength); }, e.isFull = function (e) { var t = e; return null != t && "string" == typeof t.text && void 0 === t.range && void 0 === t.rangeLength; }, e; }();
        function s(e, t) { if (e.length <= 1)
            return e; var n = e.length / 2 | 0, r = e.slice(0, n), o = e.slice(n); s(r, t), s(o, t); for (var i = 0, a = 0, u = 0; i < r.length && a < o.length;) {
            var c = t(r[i], o[a]);
            e[u++] = c <= 0 ? r[i++] : o[a++];
        } for (; i < r.length;)
            e[u++] = r[i++]; for (; a < o.length;)
            e[u++] = o[a++]; return e; }
        function a(e, t, n) { void 0 === n && (n = 0); for (var r = t ? [n] : [], o = 0; o < e.length; o++) {
            var i = e.charCodeAt(o);
            13 !== i && 10 !== i || (13 === i && o + 1 < e.length && 10 === e.charCodeAt(o + 1) && o++, r.push(n + o + 1));
        } return r; }
        function u(e) { var t = e.start, n = e.end; return t.line > n.line || t.line === n.line && t.character > n.character ? { start: n, end: t } : e; }
        function c(e) { var t = u(e.range); return t !== e.range ? { newText: e.newText, range: t } : e; }
        !function (e) { e.create = function (e, t, n, r) { return new i(e, t, n, r); }, e.update = function (e, t, n) { if (e instanceof i)
            return e.update(t, n), e; throw new Error("TextDocument.update: document must be created by TextDocument.create"); }, e.applyEdits = function (e, t) { for (var n = e.getText(), r = 0, o = [], i = 0, a = s(t.map(c), (function (e, t) { var n = e.range.start.line - t.range.start.line; return 0 === n ? e.range.start.character - t.range.start.character : n; })); i < a.length; i++) {
            var u = a[i], l = e.offsetAt(u.range.start);
            if (l < r)
                throw new Error("Overlapping edit");
            l > r && o.push(n.substring(r, l)), u.newText.length && o.push(u.newText), r = e.offsetAt(u.range.end);
        } return o.push(n.substr(r)), o.join(""); }; }(r || (r = {}));
    }, 2094: (e, t, n) => {
        "use strict";
        var r = n(3243), o = n(2191), i = n(2680), s = n(326), a = i("Object.prototype.toString"), u = n(7226)(), c = "undefined" == typeof globalThis ? n.g : globalThis, l = o(), p = i("String.prototype.slice"), f = {}, d = Object.getPrototypeOf;
        u && s && d && r(l, (function (e) { if ("function" == typeof c[e]) {
            var t = new c[e];
            if (Symbol.toStringTag in t) {
                var n = d(t), r = s(n, Symbol.toStringTag);
                if (!r) {
                    var o = d(n);
                    r = s(o, Symbol.toStringTag);
                }
                f[e] = r.get;
            }
        } }));
        var h = n(198);
        e.exports = function (e) { return !!h(e) && (u && Symbol.toStringTag in e ? function (e) { var t = !1; return r(f, (function (n, r) { if (!t)
            try {
                var o = n.call(e);
                o === r && (t = o);
            }
            catch (e) { } })), t; }(e) : p(a(e), 8, -1)); };
    }, 7595: e => { function t(e) { var t = new Error("Cannot find module '" + e + "'"); throw t.code = "MODULE_NOT_FOUND", t; } t.keys = () => [], t.resolve = t, t.id = 7595, e.exports = t; }, 2191: (e, t, n) => {
        "use strict";
        var r = ["BigInt64Array", "BigUint64Array", "Float32Array", "Float64Array", "Int16Array", "Int32Array", "Int8Array", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray"], o = "undefined" == typeof globalThis ? n.g : globalThis;
        e.exports = function () { for (var e = [], t = 0; t < r.length; t++)
            "function" == typeof o[r[t]] && (e[e.length] = r[t]); return e; };
    } }, t = {}; function n(r) { var o = t[r]; if (void 0 !== o)
    return o.exports; var i = t[r] = { exports: {} }; return e[r](i, i.exports, n), i.exports; } n.d = (e, t) => { for (var r in t)
    n.o(t, r) && !n.o(e, r) && Object.defineProperty(e, r, { enumerable: !0, get: t[r] }); }, n.g = function () { if ("object" == typeof globalThis)
    return globalThis; try {
    return this || new Function("return this")();
}
catch (e) {
    if ("object" == typeof window)
        return window;
} }(), n.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), n.r = e => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }); }; var r = {}; return (() => {
    "use strict";
    var e = r;
    Object.defineProperty(e, "__esModule", { value: !0 }), e.YamlService = void 0;
    const t = n(3401), o = n(6984);
    class i extends t.BaseService {
        $service;
        schemas = {};
        constructor(e) { super(e), this.$service = (0, o.getLanguageService)((e => { e = e.replace("file:///", ""); let t = this.schemas[e]; return t ? Promise.resolve(t) : Promise.reject(`Unable to load schema at ${e}`); }), null, null, null, null); }
        $getYamlSchemaUri(e) { return this.getOption(e, "schemaUri"); }
        addDocument(e) { super.addDocument(e), this.$configureService(e.uri); }
        $configureService(e) { let t = this.getOption(e, "schemas"); t?.forEach((t => { t.uri === this.$getYamlSchemaUri(e) && (t.fileMatch ??= [], t.fileMatch.push(e)); let n = t.schema ?? this.schemas[t.uri]; n && (this.schemas[t.uri] = n), this.$service.resetSchema(t.uri), t.schema = void 0; })), this.$service.configure({ schemas: t, hover: !0, validate: !0, completion: !0, format: !0, customTags: !1 }); }
        removeDocument(e) { super.removeDocument(e); let t = this.getOption(e.uri, "schemas"); t?.forEach((t => { t.uri === this.$getYamlSchemaUri(e.uri) && (t.fileMatch = t.fileMatch?.filter((t => t != e.uri))); })), this.$service.configure({ schemas: t }); }
        setOptions(e, t, n = !1) { super.setOptions(e, t, n), this.$configureService(e); }
        setGlobalOptions(e) { super.setGlobalOptions(e), this.$configureService(""); }
        format(e, t, n) { let r = this.getDocument(e.uri); return r ? this.$service.doFormat(r, {}) : []; }
        async doHover(e, t) { let n = this.getDocument(e.uri); return n ? this.$service.doHover(n, t) : null; }
        async doValidation(e) { let t = this.getDocument(e.uri); return t ? this.$service.doValidation(t, !1) : []; }
        async doComplete(e, t) { let n = this.getDocument(e.uri); return n ? this.$service.doComplete(n, t, !1) : null; }
        async doResolve(e) { return e; }
    }
    e.YamlService = i;
})(), r; })()));



/***/ })

}]);
//# sourceMappingURL=bundle.346.js.map