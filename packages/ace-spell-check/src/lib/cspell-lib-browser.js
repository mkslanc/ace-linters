var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all2) => {
  for (var name in all2)
    __defProp(target, name, { get: all2[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// ../../node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "../../node_modules/base64-js/index.js"(exports) {
    "use strict";
    init_shim();
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// ../../node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "../../node_modules/ieee754/index.js"(exports) {
    init_shim();
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// ../../node_modules/node-stdlib-browser/node_modules/buffer/index.js
var require_buffer = __commonJS({
  "../../node_modules/node-stdlib-browser/node_modules/buffer/index.js"(exports) {
    "use strict";
    init_shim();
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer4;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer4.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer4.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        var proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer4.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer4.isBuffer(this)) return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer4.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer4.isBuffer(this)) return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      var buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer4.prototype);
      return buf;
    }
    function Buffer4(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer4.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      var valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer4.from(valueOf, encodingOrOffset, length);
      }
      var b = fromObject(value);
      if (b) return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer4.from(
          value[Symbol.toPrimitive]("string"),
          encodingOrOffset,
          length
        );
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer4.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer4.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer4, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer4.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer4.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer4.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer4.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      var length = byteLength(string, encoding) | 0;
      var buf = createBuffer(length);
      var actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(length);
      for (var i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      var buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer4.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer4.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer4.alloc(+length);
    }
    Buffer4.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer4.prototype;
    };
    Buffer4.compare = function compare2(a, b) {
      if (isInstance(a, Uint8Array)) a = Buffer4.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array)) b = Buffer4.from(b, b.offset, b.byteLength);
      if (!Buffer4.isBuffer(a) || !Buffer4.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b) return 0;
      var x = a.length;
      var y = b.length;
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    Buffer4.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer4.concat = function concat2(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer4.alloc(0);
      }
      var i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      var buffer = Buffer4.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            Buffer4.from(buf).copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer4.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer4.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      var len = string.length;
      var mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer4.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      var loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer4.prototype._isBuffer = true;
    function swap(b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer4.prototype.swap16 = function swap162() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer4.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer4.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer4.prototype.toString = function toString2() {
      var length = this.length;
      if (length === 0) return "";
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer4.prototype.toLocaleString = Buffer4.prototype.toString;
    Buffer4.prototype.equals = function equals(b) {
      if (!Buffer4.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
      if (this === b) return true;
      return Buffer4.compare(this, b) === 0;
    };
    Buffer4.prototype.inspect = function inspect() {
      var str = "";
      var max3 = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max3).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max3) str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer4.prototype[customInspectSymbol] = Buffer4.prototype.inspect;
    }
    Buffer4.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer4.from(target, target.offset, target.byteLength);
      }
      if (!Buffer4.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer4.from(val, encoding);
      }
      if (Buffer4.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      var i;
      if (dir) {
        var foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          var found = true;
          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found) return i;
        }
      }
      return -1;
    }
    Buffer4.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer4.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer4.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      var strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer4.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining) length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer4.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i = start;
      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      var res = "";
      var i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      var len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      var out = "";
      for (var i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = "";
      for (var i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer4.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start) end = start;
      var newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer4.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
      if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer4.prototype.readUintLE = Buffer4.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer4.prototype.readUintBE = Buffer4.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      var val = this[offset + --byteLength2];
      var mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer4.prototype.readUint8 = Buffer4.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer4.prototype.readUint16LE = Buffer4.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer4.prototype.readUint16BE = Buffer4.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer4.prototype.readUint32LE = Buffer4.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer4.prototype.readUint32BE = Buffer4.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer4.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer4.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      var i = byteLength2;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer4.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer4.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer4.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer4.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer4.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer4.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer4.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer4.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer4.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max3, min2) {
      if (!Buffer4.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max3 || value < min2) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
    }
    Buffer4.prototype.writeUintLE = Buffer4.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var mul = 1;
      var i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer4.prototype.writeUintBE = Buffer4.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer4.prototype.writeUint8 = Buffer4.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer4.prototype.writeUint16LE = Buffer4.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer4.prototype.writeUint16BE = Buffer4.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer4.prototype.writeUint32LE = Buffer4.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer4.prototype.writeUint32BE = Buffer4.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer4.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer4.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer4.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer4.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer4.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer4.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer4.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function checkIEEE754(buf, value, offset, ext, max3, min2) {
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer4.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer4.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer4.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer4.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer4.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer4.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer4.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer4.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      var i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = Buffer4.isBuffer(val) ? val : Buffer4.from(val, encoding);
        var len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      var c, hi, lo;
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = (function() {
      var alphabet = "0123456789abcdef";
      var table = new Array(256);
      for (var i = 0; i < 16; ++i) {
        var i16 = i * 16;
        for (var j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    })();
  }
});

// src/shims/process-browser.js
function runTimeout(fn) {
  return setTimeout(fn, 0);
}
function drainQueue() {
  if (draining) return;
  draining = true;
  while (queue.length) {
    const fn = queue.shift();
    try {
      fn();
    } catch (error) {
      runTimeout(() => {
        throw error;
      });
    }
  }
  draining = false;
}
function nextTick(fn, ...args) {
  queue.push(() => fn(...args));
  if (queue.length === 1 && !draining) {
    if (typeof queueMicrotask === "function") {
      queueMicrotask(drainQueue);
    } else {
      runTimeout(drainQueue);
    }
  }
}
function notSupported(name) {
  throw new Error(`process.${name} is not supported in browser builds.`);
}
var queue, draining, startTime, processShim, process_browser_default;
var init_process_browser = __esm({
  "src/shims/process-browser.js"() {
    init_shim();
    queue = [];
    draining = false;
    startTime = Date.now();
    processShim = {
      title: "browser",
      browser: true,
      env: {},
      argv: [],
      version: "",
      versions: {},
      execPath: "/browser",
      execArgv: [],
      arch: "browser",
      platform: "browser",
      pid: 1,
      nextTick,
      cwd() {
        return "/";
      },
      chdir() {
        notSupported("chdir");
      },
      umask() {
        return 0;
      },
      hrtime(previousTimestamp) {
        const nowMs = typeof performance !== "undefined" && typeof performance.now === "function" ? performance.now() : Date.now() - startTime;
        const seconds = Math.floor(nowMs / 1e3);
        const nanoseconds = Math.floor(nowMs % 1e3 * 1e6);
        if (!previousTimestamp) return [seconds, nanoseconds];
        const prevNs = previousTimestamp[0] * 1e9 + previousTimestamp[1];
        const currNs = seconds * 1e9 + nanoseconds;
        const diff = currNs - prevNs;
        return [Math.floor(diff / 1e9), diff % 1e9];
      },
      uptime() {
        return (Date.now() - startTime) / 1e3;
      },
      emitWarning() {
      },
      on() {
      },
      addListener() {
      },
      once() {
      },
      off() {
      },
      removeListener() {
      },
      removeAllListeners() {
      },
      listeners() {
        return [];
      },
      binding(name) {
        notSupported(`binding(${name})`);
      }
    };
    process_browser_default = processShim;
  }
});

// ../../node_modules/node-stdlib-browser/helpers/esbuild/shim.js
var import_buffer, _globalThis, _global;
var init_shim = __esm({
  "../../node_modules/node-stdlib-browser/helpers/esbuild/shim.js"() {
    import_buffer = __toESM(require_buffer());
    init_process_browser();
    _globalThis = (function(Object2) {
      function get() {
        var _global3 = this || self;
        delete Object2.prototype.__magic__;
        return _global3;
      }
      if (typeof globalThis === "object") {
        return globalThis;
      }
      if (this) {
        return get();
      } else {
        Object2.defineProperty(Object2.prototype, "__magic__", {
          configurable: true,
          get
        });
        var _global2 = __magic__;
        return _global2;
      }
    })(Object);
    _global = _globalThis;
  }
});

// ../../node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "../../node_modules/has-symbols/shams.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = /* @__PURE__ */ Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (var _ in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(obj, sym)
        );
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// ../../node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "../../node_modules/has-tostringtag/shams.js"(exports, module) {
    "use strict";
    init_shim();
    var hasSymbols = require_shams();
    module.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});

// ../../node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS({
  "../../node_modules/es-object-atoms/index.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = Object;
  }
});

// ../../node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "../../node_modules/es-errors/index.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = Error;
  }
});

// ../../node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "../../node_modules/es-errors/eval.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = EvalError;
  }
});

// ../../node_modules/es-errors/range.js
var require_range = __commonJS({
  "../../node_modules/es-errors/range.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = RangeError;
  }
});

// ../../node_modules/es-errors/ref.js
var require_ref = __commonJS({
  "../../node_modules/es-errors/ref.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = ReferenceError;
  }
});

// ../../node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "../../node_modules/es-errors/syntax.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = SyntaxError;
  }
});

// ../../node_modules/es-errors/type.js
var require_type = __commonJS({
  "../../node_modules/es-errors/type.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = TypeError;
  }
});

// ../../node_modules/es-errors/uri.js
var require_uri = __commonJS({
  "../../node_modules/es-errors/uri.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = URIError;
  }
});

// ../../node_modules/math-intrinsics/abs.js
var require_abs = __commonJS({
  "../../node_modules/math-intrinsics/abs.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = Math.abs;
  }
});

// ../../node_modules/math-intrinsics/floor.js
var require_floor = __commonJS({
  "../../node_modules/math-intrinsics/floor.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = Math.floor;
  }
});

// ../../node_modules/math-intrinsics/max.js
var require_max = __commonJS({
  "../../node_modules/math-intrinsics/max.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = Math.max;
  }
});

// ../../node_modules/math-intrinsics/min.js
var require_min = __commonJS({
  "../../node_modules/math-intrinsics/min.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = Math.min;
  }
});

// ../../node_modules/math-intrinsics/pow.js
var require_pow = __commonJS({
  "../../node_modules/math-intrinsics/pow.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = Math.pow;
  }
});

// ../../node_modules/math-intrinsics/round.js
var require_round = __commonJS({
  "../../node_modules/math-intrinsics/round.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = Math.round;
  }
});

// ../../node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS({
  "../../node_modules/math-intrinsics/isNaN.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = Number.isNaN || function isNaN2(a) {
      return a !== a;
    };
  }
});

// ../../node_modules/math-intrinsics/sign.js
var require_sign = __commonJS({
  "../../node_modules/math-intrinsics/sign.js"(exports, module) {
    "use strict";
    init_shim();
    var $isNaN = require_isNaN();
    module.exports = function sign(number) {
      if ($isNaN(number) || number === 0) {
        return number;
      }
      return number < 0 ? -1 : 1;
    };
  }
});

// ../../node_modules/gopd/gOPD.js
var require_gOPD = __commonJS({
  "../../node_modules/gopd/gOPD.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = Object.getOwnPropertyDescriptor;
  }
});

// ../../node_modules/gopd/index.js
var require_gopd = __commonJS({
  "../../node_modules/gopd/index.js"(exports, module) {
    "use strict";
    init_shim();
    var $gOPD = require_gOPD();
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module.exports = $gOPD;
  }
});

// ../../node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "../../node_modules/es-define-property/index.js"(exports, module) {
    "use strict";
    init_shim();
    var $defineProperty = Object.defineProperty || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    module.exports = $defineProperty;
  }
});

// ../../node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "../../node_modules/has-symbols/index.js"(exports, module) {
    "use strict";
    init_shim();
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof /* @__PURE__ */ Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// ../../node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS({
  "../../node_modules/get-proto/Reflect.getPrototypeOf.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  }
});

// ../../node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS({
  "../../node_modules/get-proto/Object.getPrototypeOf.js"(exports, module) {
    "use strict";
    init_shim();
    var $Object = require_es_object_atoms();
    module.exports = $Object.getPrototypeOf || null;
  }
});

// ../../node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "../../node_modules/function-bind/implementation.js"(exports, module) {
    "use strict";
    init_shim();
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max3 = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max3(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// ../../node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "../../node_modules/function-bind/index.js"(exports, module) {
    "use strict";
    init_shim();
    var implementation = require_implementation();
    module.exports = Function.prototype.bind || implementation;
  }
});

// ../../node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS({
  "../../node_modules/call-bind-apply-helpers/functionCall.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = Function.prototype.call;
  }
});

// ../../node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS({
  "../../node_modules/call-bind-apply-helpers/functionApply.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = Function.prototype.apply;
  }
});

// ../../node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS({
  "../../node_modules/call-bind-apply-helpers/reflectApply.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  }
});

// ../../node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS({
  "../../node_modules/call-bind-apply-helpers/actualApply.js"(exports, module) {
    "use strict";
    init_shim();
    var bind = require_function_bind();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var $reflectApply = require_reflectApply();
    module.exports = $reflectApply || bind.call($call, $apply);
  }
});

// ../../node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS({
  "../../node_modules/call-bind-apply-helpers/index.js"(exports, module) {
    "use strict";
    init_shim();
    var bind = require_function_bind();
    var $TypeError = require_type();
    var $call = require_functionCall();
    var $actualApply = require_actualApply();
    module.exports = function callBindBasic(args) {
      if (args.length < 1 || typeof args[0] !== "function") {
        throw new $TypeError("a function is required");
      }
      return $actualApply(bind, $call, args);
    };
  }
});

// ../../node_modules/dunder-proto/get.js
var require_get = __commonJS({
  "../../node_modules/dunder-proto/get.js"(exports, module) {
    "use strict";
    init_shim();
    var callBind = require_call_bind_apply_helpers();
    var gOPD = require_gopd();
    var hasProtoAccessor;
    try {
      hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
      [].__proto__ === Array.prototype;
    } catch (e) {
      if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
        throw e;
      }
    }
    var desc = !!hasProtoAccessor && gOPD && gOPD(
      Object.prototype,
      /** @type {keyof typeof Object.prototype} */
      "__proto__"
    );
    var $Object = Object;
    var $getPrototypeOf = $Object.getPrototypeOf;
    module.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
      /** @type {import('./get')} */
      function getDunder(value) {
        return $getPrototypeOf(value == null ? value : $Object(value));
      }
    ) : false;
  }
});

// ../../node_modules/get-proto/index.js
var require_get_proto = __commonJS({
  "../../node_modules/get-proto/index.js"(exports, module) {
    "use strict";
    init_shim();
    var reflectGetProto = require_Reflect_getPrototypeOf();
    var originalGetProto = require_Object_getPrototypeOf();
    var getDunderProto = require_get();
    module.exports = reflectGetProto ? function getProto(O) {
      return reflectGetProto(O);
    } : originalGetProto ? function getProto(O) {
      if (!O || typeof O !== "object" && typeof O !== "function") {
        throw new TypeError("getProto: not an object");
      }
      return originalGetProto(O);
    } : getDunderProto ? function getProto(O) {
      return getDunderProto(O);
    } : null;
  }
});

// ../../node_modules/hasown/index.js
var require_hasown = __commonJS({
  "../../node_modules/hasown/index.js"(exports, module) {
    "use strict";
    init_shim();
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module.exports = bind.call(call, $hasOwn);
  }
});

// ../../node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "../../node_modules/get-intrinsic/index.js"(exports, module) {
    "use strict";
    init_shim();
    var undefined2;
    var $Object = require_es_object_atoms();
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var abs = require_abs();
    var floor = require_floor();
    var max3 = require_max();
    var min2 = require_min();
    var pow = require_pow();
    var round = require_round();
    var sign = require_sign();
    var $Function = Function;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = require_gopd();
    var $defineProperty = require_es_define_property();
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? (function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    })() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = require_get_proto();
    var $ObjectGPO = require_Object_getPrototypeOf();
    var $ReflectGPO = require_Reflect_getPrototypeOf();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": $Object,
      "%Object.getOwnPropertyDescriptor%": $gOPD,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
      "%Function.prototype.call%": $call,
      "%Function.prototype.apply%": $apply,
      "%Object.defineProperty%": $defineProperty,
      "%Object.getPrototypeOf%": $ObjectGPO,
      "%Math.abs%": abs,
      "%Math.floor%": floor,
      "%Math.max%": max3,
      "%Math.min%": min2,
      "%Math.pow%": pow,
      "%Math.round%": round,
      "%Math.sign%": sign,
      "%Reflect.getPrototypeOf%": $ReflectGPO
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn2 = require_hasown();
    var $concat = bind.call($call, Array.prototype.concat);
    var $spliceApply = bind.call($apply, Array.prototype.splice);
    var $replace = bind.call($call, String.prototype.replace);
    var $strSlice = bind.call($call, String.prototype.slice);
    var $exec = bind.call($call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first2 = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first2 === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first2 !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match2, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match2;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn2(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn2(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first2 = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first2 === '"' || first2 === "'" || first2 === "`" || (last === '"' || last === "'" || last === "`")) && first2 !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn2(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void undefined2;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn2(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// ../../node_modules/define-data-property/index.js
var require_define_data_property = __commonJS({
  "../../node_modules/define-data-property/index.js"(exports, module) {
    "use strict";
    init_shim();
    var $defineProperty = require_es_define_property();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var gopd = require_gopd();
    module.exports = function defineDataProperty(obj, property, value) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new $TypeError("`obj` must be an object or a function`");
      }
      if (typeof property !== "string" && typeof property !== "symbol") {
        throw new $TypeError("`property` must be a string or a symbol`");
      }
      if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
        throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
        throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
        throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
        throw new $TypeError("`loose`, if provided, must be a boolean");
      }
      var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
      var nonWritable = arguments.length > 4 ? arguments[4] : null;
      var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
      var loose = arguments.length > 6 ? arguments[6] : false;
      var desc = !!gopd && gopd(obj, property);
      if ($defineProperty) {
        $defineProperty(obj, property, {
          configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
          enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
          value,
          writable: nonWritable === null && desc ? desc.writable : !nonWritable
        });
      } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
        obj[property] = value;
      } else {
        throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      }
    };
  }
});

// ../../node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "../../node_modules/has-property-descriptors/index.js"(exports, module) {
    "use strict";
    init_shim();
    var $defineProperty = require_es_define_property();
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      return !!$defineProperty;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!$defineProperty) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e) {
        return true;
      }
    };
    module.exports = hasPropertyDescriptors;
  }
});

// ../../node_modules/set-function-length/index.js
var require_set_function_length = __commonJS({
  "../../node_modules/set-function-length/index.js"(exports, module) {
    "use strict";
    init_shim();
    var GetIntrinsic = require_get_intrinsic();
    var define2 = require_define_data_property();
    var hasDescriptors = require_has_property_descriptors()();
    var gOPD = require_gopd();
    var $TypeError = require_type();
    var $floor = GetIntrinsic("%Math.floor%");
    module.exports = function setFunctionLength(fn, length) {
      if (typeof fn !== "function") {
        throw new $TypeError("`fn` is not a function");
      }
      if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
        throw new $TypeError("`length` must be a positive 32-bit integer");
      }
      var loose = arguments.length > 2 && !!arguments[2];
      var functionLengthIsConfigurable = true;
      var functionLengthIsWritable = true;
      if ("length" in fn && gOPD) {
        var desc = gOPD(fn, "length");
        if (desc && !desc.configurable) {
          functionLengthIsConfigurable = false;
        }
        if (desc && !desc.writable) {
          functionLengthIsWritable = false;
        }
      }
      if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
        if (hasDescriptors) {
          define2(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length,
            true,
            true
          );
        } else {
          define2(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length
          );
        }
      }
      return fn;
    };
  }
});

// ../../node_modules/call-bind-apply-helpers/applyBind.js
var require_applyBind = __commonJS({
  "../../node_modules/call-bind-apply-helpers/applyBind.js"(exports, module) {
    "use strict";
    init_shim();
    var bind = require_function_bind();
    var $apply = require_functionApply();
    var actualApply = require_actualApply();
    module.exports = function applyBind() {
      return actualApply(bind, $apply, arguments);
    };
  }
});

// ../../node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "../../node_modules/call-bind/index.js"(exports, module) {
    "use strict";
    init_shim();
    var setFunctionLength = require_set_function_length();
    var $defineProperty = require_es_define_property();
    var callBindBasic = require_call_bind_apply_helpers();
    var applyBind = require_applyBind();
    module.exports = function callBind(originalFunction) {
      var func = callBindBasic(arguments);
      var adjustedLength = originalFunction.length - (arguments.length - 1);
      return setFunctionLength(
        func,
        1 + (adjustedLength > 0 ? adjustedLength : 0),
        true
      );
    };
    if ($defineProperty) {
      $defineProperty(module.exports, "apply", { value: applyBind });
    } else {
      module.exports.apply = applyBind;
    }
  }
});

// ../../node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "../../node_modules/call-bind/callBound.js"(exports, module) {
    "use strict";
    init_shim();
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// ../../node_modules/is-arguments/index.js
var require_is_arguments = __commonJS({
  "../../node_modules/is-arguments/index.js"(exports, module) {
    "use strict";
    init_shim();
    var hasToStringTag = require_shams2()();
    var callBound = require_callBound();
    var $toString = callBound("Object.prototype.toString");
    var isStandardArguments = function isArguments(value) {
      if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
        return false;
      }
      return $toString(value) === "[object Arguments]";
    };
    var isLegacyArguments = function isArguments(value) {
      if (isStandardArguments(value)) {
        return true;
      }
      return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
    };
    var supportsStandardArguments = (function() {
      return isStandardArguments(arguments);
    })();
    isStandardArguments.isLegacyArguments = isLegacyArguments;
    module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
  }
});

// ../../node_modules/is-generator-function/index.js
var require_is_generator_function = __commonJS({
  "../../node_modules/is-generator-function/index.js"(exports, module) {
    "use strict";
    init_shim();
    var toStr = Object.prototype.toString;
    var fnToStr = Function.prototype.toString;
    var isFnRegex = /^\s*(?:function)?\*/;
    var hasToStringTag = require_shams2()();
    var getProto = Object.getPrototypeOf;
    var getGeneratorFunc = function() {
      if (!hasToStringTag) {
        return false;
      }
      try {
        return Function("return function*() {}")();
      } catch (e) {
      }
    };
    var GeneratorFunction;
    module.exports = function isGeneratorFunction(fn) {
      if (typeof fn !== "function") {
        return false;
      }
      if (isFnRegex.test(fnToStr.call(fn))) {
        return true;
      }
      if (!hasToStringTag) {
        var str = toStr.call(fn);
        return str === "[object GeneratorFunction]";
      }
      if (!getProto) {
        return false;
      }
      if (typeof GeneratorFunction === "undefined") {
        var generatorFunc = getGeneratorFunc();
        GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
      }
      return getProto(fn) === GeneratorFunction;
    };
  }
});

// ../../node_modules/is-callable/index.js
var require_is_callable = __commonJS({
  "../../node_modules/is-callable/index.js"(exports, module) {
    "use strict";
    init_shim();
    var fnToStr = Function.prototype.toString;
    var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
    var badArrayLike;
    var isCallableMarker;
    if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
      try {
        badArrayLike = Object.defineProperty({}, "length", {
          get: function() {
            throw isCallableMarker;
          }
        });
        isCallableMarker = {};
        reflectApply(function() {
          throw 42;
        }, null, badArrayLike);
      } catch (_) {
        if (_ !== isCallableMarker) {
          reflectApply = null;
        }
      }
    } else {
      reflectApply = null;
    }
    var constructorRegex = /^\s*class\b/;
    var isES6ClassFn = function isES6ClassFunction(value) {
      try {
        var fnStr = fnToStr.call(value);
        return constructorRegex.test(fnStr);
      } catch (e) {
        return false;
      }
    };
    var tryFunctionObject = function tryFunctionToStr(value) {
      try {
        if (isES6ClassFn(value)) {
          return false;
        }
        fnToStr.call(value);
        return true;
      } catch (e) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var objectClass = "[object Object]";
    var fnClass = "[object Function]";
    var genClass = "[object GeneratorFunction]";
    var ddaClass = "[object HTMLAllCollection]";
    var ddaClass2 = "[object HTML document.all class]";
    var ddaClass3 = "[object HTMLCollection]";
    var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
    var isIE68 = !(0 in [,]);
    var isDDA = function isDocumentDotAll() {
      return false;
    };
    if (typeof document === "object") {
      all2 = document.all;
      if (toStr.call(all2) === toStr.call(document.all)) {
        isDDA = function isDocumentDotAll(value) {
          if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
            try {
              var str = toStr.call(value);
              return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
            } catch (e) {
            }
          }
          return false;
        };
      }
    }
    var all2;
    module.exports = reflectApply ? function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      try {
        reflectApply(value, null, badArrayLike);
      } catch (e) {
        if (e !== isCallableMarker) {
          return false;
        }
      }
      return !isES6ClassFn(value) && tryFunctionObject(value);
    } : function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      if (hasToStringTag) {
        return tryFunctionObject(value);
      }
      if (isES6ClassFn(value)) {
        return false;
      }
      var strClass = toStr.call(value);
      if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
        return false;
      }
      return tryFunctionObject(value);
    };
  }
});

// ../../node_modules/for-each/index.js
var require_for_each = __commonJS({
  "../../node_modules/for-each/index.js"(exports, module) {
    "use strict";
    init_shim();
    var isCallable = require_is_callable();
    var toStr = Object.prototype.toString;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var forEachArray = function forEachArray2(array, iterator, receiver) {
      for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty2.call(array, i)) {
          if (receiver == null) {
            iterator(array[i], i, array);
          } else {
            iterator.call(receiver, array[i], i, array);
          }
        }
      }
    };
    var forEachString = function forEachString2(string, iterator, receiver) {
      for (var i = 0, len = string.length; i < len; i++) {
        if (receiver == null) {
          iterator(string.charAt(i), i, string);
        } else {
          iterator.call(receiver, string.charAt(i), i, string);
        }
      }
    };
    var forEachObject = function forEachObject2(object, iterator, receiver) {
      for (var k in object) {
        if (hasOwnProperty2.call(object, k)) {
          if (receiver == null) {
            iterator(object[k], k, object);
          } else {
            iterator.call(receiver, object[k], k, object);
          }
        }
      }
    };
    function isArray2(x) {
      return toStr.call(x) === "[object Array]";
    }
    module.exports = function forEach2(list, iterator, thisArg) {
      if (!isCallable(iterator)) {
        throw new TypeError("iterator must be a function");
      }
      var receiver;
      if (arguments.length >= 3) {
        receiver = thisArg;
      }
      if (isArray2(list)) {
        forEachArray(list, iterator, receiver);
      } else if (typeof list === "string") {
        forEachString(list, iterator, receiver);
      } else {
        forEachObject(list, iterator, receiver);
      }
    };
  }
});

// ../../node_modules/possible-typed-array-names/index.js
var require_possible_typed_array_names = __commonJS({
  "../../node_modules/possible-typed-array-names/index.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = [
      "Float16Array",
      "Float32Array",
      "Float64Array",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "BigInt64Array",
      "BigUint64Array"
    ];
  }
});

// ../../node_modules/available-typed-arrays/index.js
var require_available_typed_arrays = __commonJS({
  "../../node_modules/available-typed-arrays/index.js"(exports, module) {
    "use strict";
    init_shim();
    var possibleNames = require_possible_typed_array_names();
    var g = typeof globalThis === "undefined" ? _global : globalThis;
    module.exports = function availableTypedArrays() {
      var out = [];
      for (var i = 0; i < possibleNames.length; i++) {
        if (typeof g[possibleNames[i]] === "function") {
          out[out.length] = possibleNames[i];
        }
      }
      return out;
    };
  }
});

// ../../node_modules/call-bound/index.js
var require_call_bound = __commonJS({
  "../../node_modules/call-bound/index.js"(exports, module) {
    "use strict";
    init_shim();
    var GetIntrinsic = require_get_intrinsic();
    var callBindBasic = require_call_bind_apply_helpers();
    var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
    module.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = (
        /** @type {(this: unknown, ...args: unknown[]) => unknown} */
        GetIntrinsic(name, !!allowMissing)
      );
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBindBasic(
          /** @type {const} */
          [intrinsic]
        );
      }
      return intrinsic;
    };
  }
});

// ../../node_modules/which-typed-array/index.js
var require_which_typed_array = __commonJS({
  "../../node_modules/which-typed-array/index.js"(exports, module) {
    "use strict";
    init_shim();
    var forEach2 = require_for_each();
    var availableTypedArrays = require_available_typed_arrays();
    var callBind = require_call_bind();
    var callBound = require_call_bound();
    var gOPD = require_gopd();
    var getProto = require_get_proto();
    var $toString = callBound("Object.prototype.toString");
    var hasToStringTag = require_shams2()();
    var g = typeof globalThis === "undefined" ? _global : globalThis;
    var typedArrays = availableTypedArrays();
    var $slice = callBound("String.prototype.slice");
    var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
      for (var i = 0; i < array.length; i += 1) {
        if (array[i] === value) {
          return i;
        }
      }
      return -1;
    };
    var cache3 = { __proto__: null };
    if (hasToStringTag && gOPD && getProto) {
      forEach2(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        if (Symbol.toStringTag in arr && getProto) {
          var proto = getProto(arr);
          var descriptor = gOPD(proto, Symbol.toStringTag);
          if (!descriptor && proto) {
            var superProto = getProto(proto);
            descriptor = gOPD(superProto, Symbol.toStringTag);
          }
          if (descriptor && descriptor.get) {
            var bound = callBind(descriptor.get);
            cache3[
              /** @type {`$${import('.').TypedArrayName}`} */
              "$" + typedArray
            ] = bound;
          }
        }
      });
    } else {
      forEach2(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        var fn = arr.slice || arr.set;
        if (fn) {
          var bound = (
            /** @type {import('./types').BoundSlice | import('./types').BoundSet} */
            // @ts-expect-error TODO FIXME
            callBind(fn)
          );
          cache3[
            /** @type {`$${import('.').TypedArrayName}`} */
            "$" + typedArray
          ] = bound;
        }
      });
    }
    var tryTypedArrays = function tryAllTypedArrays(value) {
      var found = false;
      forEach2(
        /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
        cache3,
        /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
        function(getter, typedArray) {
          if (!found) {
            try {
              if ("$" + getter(value) === typedArray) {
                found = /** @type {import('.').TypedArrayName} */
                $slice(typedArray, 1);
              }
            } catch (e) {
            }
          }
        }
      );
      return found;
    };
    var trySlices = function tryAllSlices(value) {
      var found = false;
      forEach2(
        /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
        cache3,
        /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
        function(getter, name) {
          if (!found) {
            try {
              getter(value);
              found = /** @type {import('.').TypedArrayName} */
              $slice(name, 1);
            } catch (e) {
            }
          }
        }
      );
      return found;
    };
    module.exports = function whichTypedArray(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      if (!hasToStringTag) {
        var tag = $slice($toString(value), 8, -1);
        if ($indexOf(typedArrays, tag) > -1) {
          return tag;
        }
        if (tag !== "Object") {
          return false;
        }
        return trySlices(value);
      }
      if (!gOPD) {
        return null;
      }
      return tryTypedArrays(value);
    };
  }
});

// ../../node_modules/is-typed-array/index.js
var require_is_typed_array = __commonJS({
  "../../node_modules/is-typed-array/index.js"(exports, module) {
    "use strict";
    init_shim();
    var whichTypedArray = require_which_typed_array();
    module.exports = function isTypedArray(value) {
      return !!whichTypedArray(value);
    };
  }
});

// ../../node_modules/util/support/types.js
var require_types = __commonJS({
  "../../node_modules/util/support/types.js"(exports) {
    "use strict";
    init_shim();
    var isArgumentsObject = require_is_arguments();
    var isGeneratorFunction = require_is_generator_function();
    var whichTypedArray = require_which_typed_array();
    var isTypedArray = require_is_typed_array();
    function uncurryThis(f) {
      return f.call.bind(f);
    }
    var BigIntSupported = typeof BigInt !== "undefined";
    var SymbolSupported = typeof Symbol !== "undefined";
    var ObjectToString = uncurryThis(Object.prototype.toString);
    var numberValue = uncurryThis(Number.prototype.valueOf);
    var stringValue = uncurryThis(String.prototype.valueOf);
    var booleanValue = uncurryThis(Boolean.prototype.valueOf);
    if (BigIntSupported) {
      bigIntValue = uncurryThis(BigInt.prototype.valueOf);
    }
    var bigIntValue;
    if (SymbolSupported) {
      symbolValue = uncurryThis(Symbol.prototype.valueOf);
    }
    var symbolValue;
    function checkBoxedPrimitive(value, prototypeValueOf) {
      if (typeof value !== "object") {
        return false;
      }
      try {
        prototypeValueOf(value);
        return true;
      } catch (e) {
        return false;
      }
    }
    exports.isArgumentsObject = isArgumentsObject;
    exports.isGeneratorFunction = isGeneratorFunction;
    exports.isTypedArray = isTypedArray;
    function isPromise(input) {
      return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
    }
    exports.isPromise = isPromise;
    function isArrayBufferView(value) {
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        return ArrayBuffer.isView(value);
      }
      return isTypedArray(value) || isDataView(value);
    }
    exports.isArrayBufferView = isArrayBufferView;
    function isUint8Array(value) {
      return whichTypedArray(value) === "Uint8Array";
    }
    exports.isUint8Array = isUint8Array;
    function isUint8ClampedArray(value) {
      return whichTypedArray(value) === "Uint8ClampedArray";
    }
    exports.isUint8ClampedArray = isUint8ClampedArray;
    function isUint16Array(value) {
      return whichTypedArray(value) === "Uint16Array";
    }
    exports.isUint16Array = isUint16Array;
    function isUint32Array(value) {
      return whichTypedArray(value) === "Uint32Array";
    }
    exports.isUint32Array = isUint32Array;
    function isInt8Array(value) {
      return whichTypedArray(value) === "Int8Array";
    }
    exports.isInt8Array = isInt8Array;
    function isInt16Array(value) {
      return whichTypedArray(value) === "Int16Array";
    }
    exports.isInt16Array = isInt16Array;
    function isInt32Array(value) {
      return whichTypedArray(value) === "Int32Array";
    }
    exports.isInt32Array = isInt32Array;
    function isFloat32Array(value) {
      return whichTypedArray(value) === "Float32Array";
    }
    exports.isFloat32Array = isFloat32Array;
    function isFloat64Array(value) {
      return whichTypedArray(value) === "Float64Array";
    }
    exports.isFloat64Array = isFloat64Array;
    function isBigInt64Array(value) {
      return whichTypedArray(value) === "BigInt64Array";
    }
    exports.isBigInt64Array = isBigInt64Array;
    function isBigUint64Array(value) {
      return whichTypedArray(value) === "BigUint64Array";
    }
    exports.isBigUint64Array = isBigUint64Array;
    function isMapToString(value) {
      return ObjectToString(value) === "[object Map]";
    }
    isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
    function isMap(value) {
      if (typeof Map === "undefined") {
        return false;
      }
      return isMapToString.working ? isMapToString(value) : value instanceof Map;
    }
    exports.isMap = isMap;
    function isSetToString(value) {
      return ObjectToString(value) === "[object Set]";
    }
    isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
    function isSet(value) {
      if (typeof Set === "undefined") {
        return false;
      }
      return isSetToString.working ? isSetToString(value) : value instanceof Set;
    }
    exports.isSet = isSet;
    function isWeakMapToString(value) {
      return ObjectToString(value) === "[object WeakMap]";
    }
    isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
    function isWeakMap(value) {
      if (typeof WeakMap === "undefined") {
        return false;
      }
      return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
    }
    exports.isWeakMap = isWeakMap;
    function isWeakSetToString(value) {
      return ObjectToString(value) === "[object WeakSet]";
    }
    isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
    function isWeakSet(value) {
      return isWeakSetToString(value);
    }
    exports.isWeakSet = isWeakSet;
    function isArrayBufferToString(value) {
      return ObjectToString(value) === "[object ArrayBuffer]";
    }
    isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
    function isArrayBuffer(value) {
      if (typeof ArrayBuffer === "undefined") {
        return false;
      }
      return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
    }
    exports.isArrayBuffer = isArrayBuffer;
    function isDataViewToString(value) {
      return ObjectToString(value) === "[object DataView]";
    }
    isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
    function isDataView(value) {
      if (typeof DataView === "undefined") {
        return false;
      }
      return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
    }
    exports.isDataView = isDataView;
    var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
    function isSharedArrayBufferToString(value) {
      return ObjectToString(value) === "[object SharedArrayBuffer]";
    }
    function isSharedArrayBuffer(value) {
      if (typeof SharedArrayBufferCopy === "undefined") {
        return false;
      }
      if (typeof isSharedArrayBufferToString.working === "undefined") {
        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
      }
      return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
    }
    exports.isSharedArrayBuffer = isSharedArrayBuffer;
    function isAsyncFunction(value) {
      return ObjectToString(value) === "[object AsyncFunction]";
    }
    exports.isAsyncFunction = isAsyncFunction;
    function isMapIterator(value) {
      return ObjectToString(value) === "[object Map Iterator]";
    }
    exports.isMapIterator = isMapIterator;
    function isSetIterator(value) {
      return ObjectToString(value) === "[object Set Iterator]";
    }
    exports.isSetIterator = isSetIterator;
    function isGeneratorObject(value) {
      return ObjectToString(value) === "[object Generator]";
    }
    exports.isGeneratorObject = isGeneratorObject;
    function isWebAssemblyCompiledModule(value) {
      return ObjectToString(value) === "[object WebAssembly.Module]";
    }
    exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
    function isNumberObject(value) {
      return checkBoxedPrimitive(value, numberValue);
    }
    exports.isNumberObject = isNumberObject;
    function isStringObject(value) {
      return checkBoxedPrimitive(value, stringValue);
    }
    exports.isStringObject = isStringObject;
    function isBooleanObject(value) {
      return checkBoxedPrimitive(value, booleanValue);
    }
    exports.isBooleanObject = isBooleanObject;
    function isBigIntObject(value) {
      return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
    }
    exports.isBigIntObject = isBigIntObject;
    function isSymbolObject(value) {
      return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
    }
    exports.isSymbolObject = isSymbolObject;
    function isBoxedPrimitive(value) {
      return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
    }
    exports.isBoxedPrimitive = isBoxedPrimitive;
    function isAnyArrayBuffer(value) {
      return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
    }
    exports.isAnyArrayBuffer = isAnyArrayBuffer;
    ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
      Object.defineProperty(exports, method, {
        enumerable: false,
        value: function() {
          throw new Error(method + " is not supported in userland");
        }
      });
    });
  }
});

// ../../node_modules/util/support/isBufferBrowser.js
var require_isBufferBrowser = __commonJS({
  "../../node_modules/util/support/isBufferBrowser.js"(exports, module) {
    init_shim();
    module.exports = function isBuffer(arg) {
      return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
    };
  }
});

// ../../node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "../../node_modules/inherits/inherits_browser.js"(exports, module) {
    init_shim();
    if (typeof Object.create === "function") {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// ../../node_modules/util/util.js
var require_util = __commonJS({
  "../../node_modules/util/util.js"(exports) {
    init_shim();
    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
      var keys3 = Object.keys(obj);
      var descriptors = {};
      for (var i = 0; i < keys3.length; i++) {
        descriptors[keys3[i]] = Object.getOwnPropertyDescriptor(obj, keys3[i]);
      }
      return descriptors;
    };
    var formatRegExp = /%[sdj%]/g;
    exports.format = function(f) {
      if (!isString2(f)) {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect(arguments[i]));
        }
        return objects.join(" ");
      }
      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function(x2) {
        if (x2 === "%%") return "%";
        if (i >= len) return x2;
        switch (x2) {
          case "%s":
            return String(args[i++]);
          case "%d":
            return Number(args[i++]);
          case "%j":
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return "[Circular]";
            }
          default:
            return x2;
        }
      });
      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull(x) || !isObject(x)) {
          str += " " + x;
        } else {
          str += " " + inspect(x);
        }
      }
      return str;
    };
    exports.deprecate = function(fn, msg) {
      if (typeof process_browser_default !== "undefined" && process_browser_default.noDeprecation === true) {
        return fn;
      }
      if (typeof process_browser_default === "undefined") {
        return function() {
          return exports.deprecate(fn, msg).apply(this, arguments);
        };
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process_browser_default.throwDeprecation) {
            throw new Error(msg);
          } else if (process_browser_default.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    };
    var debugs = {};
    var debugEnvRegex = /^$/;
    if (process_browser_default.env.NODE_DEBUG) {
      debugEnv = process_browser_default.env.NODE_DEBUG;
      debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
      debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
    }
    var debugEnv;
    exports.debuglog = function(set) {
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (debugEnvRegex.test(set)) {
          var pid = process_browser_default.pid;
          debugs[set] = function() {
            var msg = exports.format.apply(exports, arguments);
            console.error("%s %d: %s", set, pid, msg);
          };
        } else {
          debugs[set] = function() {
          };
        }
      }
      return debugs[set];
    };
    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3) ctx.depth = arguments[2];
      if (arguments.length >= 4) ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        ctx.showHidden = opts;
      } else if (opts) {
        exports._extend(ctx, opts);
      }
      if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
      if (isUndefined(ctx.depth)) ctx.depth = 2;
      if (isUndefined(ctx.colors)) ctx.colors = false;
      if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
      if (ctx.colors) ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports.inspect = inspect;
    inspect.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      // "name": intentionally not styling
      "regexp": "red"
    };
    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];
      if (style) {
        return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash = {};
      array.forEach(function(val, idx2) {
        hash[val] = true;
      });
      return hash;
    }
    function formatValue(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString2(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
      var keys3 = Object.keys(value);
      var visibleKeys = arrayToHash(keys3);
      if (ctx.showHidden) {
        keys3 = Object.getOwnPropertyNames(value);
      }
      if (isError4(value) && (keys3.indexOf("message") >= 0 || keys3.indexOf("description") >= 0)) {
        return formatError(value);
      }
      if (keys3.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ": " + value.name : "";
          return ctx.stylize("[Function" + name + "]", "special");
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), "date");
        }
        if (isError4(value)) {
          return formatError(value);
        }
      }
      var base = "", array = false, braces = ["{", "}"];
      if (isArray2(value)) {
        array = true;
        braces = ["[", "]"];
      }
      if (isFunction(value)) {
        var n = value.name ? ": " + value.name : "";
        base = " [Function" + n + "]";
      }
      if (isRegExp(value)) {
        base = " " + RegExp.prototype.toString.call(value);
      }
      if (isDate(value)) {
        base = " " + Date.prototype.toUTCString.call(value);
      }
      if (isError4(value)) {
        base = " " + formatError(value);
      }
      if (keys3.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        } else {
          return ctx.stylize("[Object]", "special");
        }
      }
      ctx.seen.push(value);
      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys3);
      } else {
        output = keys3.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }
    function formatPrimitive(ctx, value) {
      if (isUndefined(value))
        return ctx.stylize("undefined", "undefined");
      if (isString2(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, "string");
      }
      if (isNumber(value))
        return ctx.stylize("" + value, "number");
      if (isBoolean(value))
        return ctx.stylize("" + value, "boolean");
      if (isNull(value))
        return ctx.stylize("null", "null");
    }
    function formatError(value) {
      return "[" + Error.prototype.toString.call(value) + "]";
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys3) {
      var output = [];
      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty2(value, String(i))) {
          output.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            String(i),
            true
          ));
        } else {
          output.push("");
        }
      }
      keys3.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            key,
            true
          ));
        }
      });
      return output;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize("[Getter/Setter]", "special");
        } else {
          str = ctx.stylize("[Getter]", "special");
        }
      } else {
        if (desc.set) {
          str = ctx.stylize("[Setter]", "special");
        }
      }
      if (!hasOwnProperty2(visibleKeys, key)) {
        name = "[" + key + "]";
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf("\n") > -1) {
            if (array) {
              str = str.split("\n").map(function(line) {
                return "  " + line;
              }).join("\n").slice(2);
            } else {
              str = "\n" + str.split("\n").map(function(line) {
                return "   " + line;
              }).join("\n");
            }
          }
        } else {
          str = ctx.stylize("[Circular]", "special");
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify("" + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.slice(1, -1);
          name = ctx.stylize(name, "name");
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, "string");
        }
      }
      return name + ": " + str;
    }
    function reduceToSingleString(output, base, braces) {
      var numLinesEst = 0;
      var length = output.reduce(function(prev, cur) {
        numLinesEst++;
        if (cur.indexOf("\n") >= 0) numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      if (length > 60) {
        return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
      }
      return braces[0] + base + " " + output.join(", ") + " " + braces[1];
    }
    exports.types = require_types();
    function isArray2(ar) {
      return Array.isArray(ar);
    }
    exports.isArray = isArray2;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports.isNumber = isNumber;
    function isString2(arg) {
      return typeof arg === "string";
    }
    exports.isString = isString2;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re) {
      return isObject(re) && objectToString(re) === "[object RegExp]";
    }
    exports.isRegExp = isRegExp;
    exports.types.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports.isObject = isObject;
    function isDate(d) {
      return isObject(d) && objectToString(d) === "[object Date]";
    }
    exports.isDate = isDate;
    exports.types.isDate = isDate;
    function isError4(e) {
      return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
    }
    exports.isError = isError4;
    exports.types.isNativeError = isError4;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports.isPrimitive = isPrimitive;
    exports.isBuffer = require_isBufferBrowser();
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    function pad(n) {
      return n < 10 ? "0" + n.toString(10) : n.toString(10);
    }
    var months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function timestamp() {
      var d = /* @__PURE__ */ new Date();
      var time = [
        pad(d.getHours()),
        pad(d.getMinutes()),
        pad(d.getSeconds())
      ].join(":");
      return [d.getDate(), months[d.getMonth()], time].join(" ");
    }
    exports.log = function() {
      console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments));
    };
    exports.inherits = require_inherits_browser();
    exports._extend = function(origin, add) {
      if (!add || !isObject(add)) return origin;
      var keys3 = Object.keys(add);
      var i = keys3.length;
      while (i--) {
        origin[keys3[i]] = add[keys3[i]];
      }
      return origin;
    };
    function hasOwnProperty2(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? /* @__PURE__ */ Symbol("util.promisify.custom") : void 0;
    exports.promisify = function promisify2(original) {
      if (typeof original !== "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn = original[kCustomPromisifiedSymbol];
        if (typeof fn !== "function") {
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        }
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
        return fn;
      }
      function fn() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function(resolve2, reject) {
          promiseResolve = resolve2;
          promiseReject = reject;
        });
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        args.push(function(err, value) {
          if (err) {
            promiseReject(err);
          } else {
            promiseResolve(value);
          }
        });
        try {
          original.apply(this, args);
        } catch (err) {
          promiseReject(err);
        }
        return promise;
      }
      Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
      if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true
      });
      return Object.defineProperties(
        fn,
        getOwnPropertyDescriptors(original)
      );
    };
    exports.promisify.custom = kCustomPromisifiedSymbol;
    function callbackifyOnRejected(reason, cb) {
      if (!reason) {
        var newReason = new Error("Promise was rejected with a falsy value");
        newReason.reason = reason;
        reason = newReason;
      }
      return cb(reason);
    }
    function callbackify(original) {
      if (typeof original !== "function") {
        throw new TypeError('The "original" argument must be of type Function');
      }
      function callbackified() {
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        var maybeCb = args.pop();
        if (typeof maybeCb !== "function") {
          throw new TypeError("The last argument must be of type Function");
        }
        var self2 = this;
        var cb = function() {
          return maybeCb.apply(self2, arguments);
        };
        original.apply(this, args).then(
          function(ret) {
            process_browser_default.nextTick(cb.bind(null, null, ret));
          },
          function(rej) {
            process_browser_default.nextTick(callbackifyOnRejected.bind(null, rej, cb));
          }
        );
      }
      Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
      Object.defineProperties(
        callbackified,
        getOwnPropertyDescriptors(original)
      );
      return callbackified;
    }
    exports.callbackify = callbackify;
  }
});

// ../../node_modules/assert/build/internal/errors.js
var require_errors = __commonJS({
  "../../node_modules/assert/build/internal/errors.js"(exports, module) {
    "use strict";
    init_shim();
    function _typeof(obj) {
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var codes2 = {};
    var assert12;
    var util;
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      var NodeError = /* @__PURE__ */ (function(_Base) {
        _inherits(NodeError2, _Base);
        function NodeError2(arg1, arg2, arg3) {
          var _this;
          _classCallCheck(this, NodeError2);
          _this = _possibleConstructorReturn(this, _getPrototypeOf(NodeError2).call(this, getMessage(arg1, arg2, arg3)));
          _this.code = code;
          return _this;
        }
        return NodeError2;
      })(Base);
      codes2[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i) {
          return String(i);
        });
        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      if (assert12 === void 0) assert12 = require_assert();
      assert12(typeof name === "string", "'name' must be a string");
      var determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      var msg;
      if (endsWith(name, " argument")) {
        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      } else {
        var type = includes(name, ".") ? "property" : "argument";
        msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      }
      msg += ". Received type ".concat(_typeof(actual));
      return msg;
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_VALUE", function(name, value) {
      var reason = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "is invalid";
      if (util === void 0) util = require_util();
      var inspected = util.inspect(value);
      if (inspected.length > 128) {
        inspected = "".concat(inspected.slice(0, 128), "...");
      }
      return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
    }, TypeError, RangeError);
    createErrorType("ERR_INVALID_RETURN_VALUE", function(input, name, value) {
      var type;
      if (value && value.constructor && value.constructor.name) {
        type = "instance of ".concat(value.constructor.name);
      } else {
        type = "type ".concat(_typeof(value));
      }
      return "Expected ".concat(input, ' to be returned from the "').concat(name, '"') + " function but got ".concat(type, ".");
    }, TypeError);
    createErrorType("ERR_MISSING_ARGS", function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (assert12 === void 0) assert12 = require_assert();
      assert12(args.length > 0, "At least one arg needs to be specified");
      var msg = "The ";
      var len = args.length;
      args = args.map(function(a) {
        return '"'.concat(a, '"');
      });
      switch (len) {
        case 1:
          msg += "".concat(args[0], " argument");
          break;
        case 2:
          msg += "".concat(args[0], " and ").concat(args[1], " arguments");
          break;
        default:
          msg += args.slice(0, len - 1).join(", ");
          msg += ", and ".concat(args[len - 1], " arguments");
          break;
      }
      return "".concat(msg, " must be specified");
    }, TypeError);
    module.exports.codes = codes2;
  }
});

// ../../node_modules/assert/build/internal/assert/assertion_error.js
var require_assertion_error = __commonJS({
  "../../node_modules/assert/build/internal/assert/assertion_error.js"(exports, module) {
    "use strict";
    init_shim();
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys.forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2)) return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2)) return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
        return _setPrototypeOf(Wrapper, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    function isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _construct(Parent, args, Class) {
      if (isNativeReflectConstruct()) {
        _construct = Reflect.construct;
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [null];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2) _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _typeof(obj) {
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    var _require = require_util();
    var inspect = _require.inspect;
    var _require2 = require_errors();
    var ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE;
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function repeat(str, count2) {
      count2 = Math.floor(count2);
      if (str.length == 0 || count2 == 0) return "";
      var maxCount = str.length * count2;
      count2 = Math.floor(Math.log(count2) / Math.log(2));
      while (count2) {
        str += str;
        count2--;
      }
      str += str.substring(0, maxCount - str.length);
      return str;
    }
    var blue = "";
    var green = "";
    var red = "";
    var white = "";
    var kReadableOperator = {
      deepStrictEqual: "Expected values to be strictly deep-equal:",
      strictEqual: "Expected values to be strictly equal:",
      strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
      deepEqual: "Expected values to be loosely deep-equal:",
      equal: "Expected values to be loosely equal:",
      notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
      notStrictEqual: 'Expected "actual" to be strictly unequal to:',
      notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
      notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
      notEqual: 'Expected "actual" to be loosely unequal to:',
      notIdentical: "Values identical but not reference-equal:"
    };
    var kMaxShortLength = 10;
    function copyError(source) {
      var keys3 = Object.keys(source);
      var target = Object.create(Object.getPrototypeOf(source));
      keys3.forEach(function(key) {
        target[key] = source[key];
      });
      Object.defineProperty(target, "message", {
        value: source.message
      });
      return target;
    }
    function inspectValue(val) {
      return inspect(val, {
        compact: false,
        customInspect: false,
        depth: 1e3,
        maxArrayLength: Infinity,
        // Assert compares only enumerable properties (with a few exceptions).
        showHidden: false,
        // Having a long line as error is better than wrapping the line for
        // comparison for now.
        // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
        // have meta information about the inspected properties (i.e., know where
        // in what line the property starts and ends).
        breakLength: Infinity,
        // Assert does not detect proxies currently.
        showProxy: false,
        sorted: true,
        // Inspect getters as we also check them when comparing entries.
        getters: true
      });
    }
    function createErrDiff(actual, expected, operator) {
      var other = "";
      var res = "";
      var lastPos = 0;
      var end = "";
      var skipped = false;
      var actualInspected = inspectValue(actual);
      var actualLines = actualInspected.split("\n");
      var expectedLines = inspectValue(expected).split("\n");
      var i = 0;
      var indicator = "";
      if (operator === "strictEqual" && _typeof(actual) === "object" && _typeof(expected) === "object" && actual !== null && expected !== null) {
        operator = "strictEqualObject";
      }
      if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
        var inputLength = actualLines[0].length + expectedLines[0].length;
        if (inputLength <= kMaxShortLength) {
          if ((_typeof(actual) !== "object" || actual === null) && (_typeof(expected) !== "object" || expected === null) && (actual !== 0 || expected !== 0)) {
            return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
          }
        } else if (operator !== "strictEqualObject") {
          var maxLength = process_browser_default.stderr && process_browser_default.stderr.isTTY ? process_browser_default.stderr.columns : 80;
          if (inputLength < maxLength) {
            while (actualLines[0][i] === expectedLines[0][i]) {
              i++;
            }
            if (i > 2) {
              indicator = "\n  ".concat(repeat(" ", i), "^");
              i = 0;
            }
          }
        }
      }
      var a = actualLines[actualLines.length - 1];
      var b = expectedLines[expectedLines.length - 1];
      while (a === b) {
        if (i++ < 2) {
          end = "\n  ".concat(a).concat(end);
        } else {
          other = a;
        }
        actualLines.pop();
        expectedLines.pop();
        if (actualLines.length === 0 || expectedLines.length === 0) break;
        a = actualLines[actualLines.length - 1];
        b = expectedLines[expectedLines.length - 1];
      }
      var maxLines = Math.max(actualLines.length, expectedLines.length);
      if (maxLines === 0) {
        var _actualLines = actualInspected.split("\n");
        if (_actualLines.length > 30) {
          _actualLines[26] = "".concat(blue, "...").concat(white);
          while (_actualLines.length > 27) {
            _actualLines.pop();
          }
        }
        return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join("\n"), "\n");
      }
      if (i > 3) {
        end = "\n".concat(blue, "...").concat(white).concat(end);
        skipped = true;
      }
      if (other !== "") {
        end = "\n  ".concat(other).concat(end);
        other = "";
      }
      var printedLines = 0;
      var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
      var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");
      for (i = 0; i < maxLines; i++) {
        var cur = i - lastPos;
        if (actualLines.length < i + 1) {
          if (cur > 1 && i > 2) {
            if (cur > 4) {
              res += "\n".concat(blue, "...").concat(white);
              skipped = true;
            } else if (cur > 3) {
              res += "\n  ".concat(expectedLines[i - 2]);
              printedLines++;
            }
            res += "\n  ".concat(expectedLines[i - 1]);
            printedLines++;
          }
          lastPos = i;
          other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
          printedLines++;
        } else if (expectedLines.length < i + 1) {
          if (cur > 1 && i > 2) {
            if (cur > 4) {
              res += "\n".concat(blue, "...").concat(white);
              skipped = true;
            } else if (cur > 3) {
              res += "\n  ".concat(actualLines[i - 2]);
              printedLines++;
            }
            res += "\n  ".concat(actualLines[i - 1]);
            printedLines++;
          }
          lastPos = i;
          res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
          printedLines++;
        } else {
          var expectedLine = expectedLines[i];
          var actualLine = actualLines[i];
          var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ",") || actualLine.slice(0, -1) !== expectedLine);
          if (divergingLines && endsWith(expectedLine, ",") && expectedLine.slice(0, -1) === actualLine) {
            divergingLines = false;
            actualLine += ",";
          }
          if (divergingLines) {
            if (cur > 1 && i > 2) {
              if (cur > 4) {
                res += "\n".concat(blue, "...").concat(white);
                skipped = true;
              } else if (cur > 3) {
                res += "\n  ".concat(actualLines[i - 2]);
                printedLines++;
              }
              res += "\n  ".concat(actualLines[i - 1]);
              printedLines++;
            }
            lastPos = i;
            res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
            other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
            printedLines += 2;
          } else {
            res += other;
            other = "";
            if (cur === 1 || i === 0) {
              res += "\n  ".concat(actualLine);
              printedLines++;
            }
          }
        }
        if (printedLines > 20 && i < maxLines - 2) {
          return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
        }
      }
      return "".concat(msg).concat(skipped ? skippedMsg : "", "\n").concat(res).concat(other).concat(end).concat(indicator);
    }
    var AssertionError2 = /* @__PURE__ */ (function(_Error) {
      _inherits(AssertionError3, _Error);
      function AssertionError3(options) {
        var _this;
        _classCallCheck(this, AssertionError3);
        if (_typeof(options) !== "object" || options === null) {
          throw new ERR_INVALID_ARG_TYPE("options", "Object", options);
        }
        var message = options.message, operator = options.operator, stackStartFn = options.stackStartFn;
        var actual = options.actual, expected = options.expected;
        var limit = Error.stackTraceLimit;
        Error.stackTraceLimit = 0;
        if (message != null) {
          _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError3).call(this, String(message)));
        } else {
          if (process_browser_default.stderr && process_browser_default.stderr.isTTY) {
            if (process_browser_default.stderr && process_browser_default.stderr.getColorDepth && process_browser_default.stderr.getColorDepth() !== 1) {
              blue = "\x1B[34m";
              green = "\x1B[32m";
              white = "\x1B[39m";
              red = "\x1B[31m";
            } else {
              blue = "";
              green = "";
              white = "";
              red = "";
            }
          }
          if (_typeof(actual) === "object" && actual !== null && _typeof(expected) === "object" && expected !== null && "stack" in actual && actual instanceof Error && "stack" in expected && expected instanceof Error) {
            actual = copyError(actual);
            expected = copyError(expected);
          }
          if (operator === "deepStrictEqual" || operator === "strictEqual") {
            _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError3).call(this, createErrDiff(actual, expected, operator)));
          } else if (operator === "notDeepStrictEqual" || operator === "notStrictEqual") {
            var base = kReadableOperator[operator];
            var res = inspectValue(actual).split("\n");
            if (operator === "notStrictEqual" && _typeof(actual) === "object" && actual !== null) {
              base = kReadableOperator.notStrictEqualObject;
            }
            if (res.length > 30) {
              res[26] = "".concat(blue, "...").concat(white);
              while (res.length > 27) {
                res.pop();
              }
            }
            if (res.length === 1) {
              _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError3).call(this, "".concat(base, " ").concat(res[0])));
            } else {
              _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError3).call(this, "".concat(base, "\n\n").concat(res.join("\n"), "\n")));
            }
          } else {
            var _res = inspectValue(actual);
            var other = "";
            var knownOperators = kReadableOperator[operator];
            if (operator === "notDeepEqual" || operator === "notEqual") {
              _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);
              if (_res.length > 1024) {
                _res = "".concat(_res.slice(0, 1021), "...");
              }
            } else {
              other = "".concat(inspectValue(expected));
              if (_res.length > 512) {
                _res = "".concat(_res.slice(0, 509), "...");
              }
              if (other.length > 512) {
                other = "".concat(other.slice(0, 509), "...");
              }
              if (operator === "deepEqual" || operator === "equal") {
                _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
              } else {
                other = " ".concat(operator, " ").concat(other);
              }
            }
            _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError3).call(this, "".concat(_res).concat(other)));
          }
        }
        Error.stackTraceLimit = limit;
        _this.generatedMessage = !message;
        Object.defineProperty(_assertThisInitialized(_this), "name", {
          value: "AssertionError [ERR_ASSERTION]",
          enumerable: false,
          writable: true,
          configurable: true
        });
        _this.code = "ERR_ASSERTION";
        _this.actual = actual;
        _this.expected = expected;
        _this.operator = operator;
        if (Error.captureStackTrace) {
          Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
        }
        _this.stack;
        _this.name = "AssertionError";
        return _possibleConstructorReturn(_this);
      }
      _createClass(AssertionError3, [{
        key: "toString",
        value: function toString2() {
          return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
        }
      }, {
        key: inspect.custom,
        value: function value(recurseTimes, ctx) {
          return inspect(this, _objectSpread({}, ctx, {
            customInspect: false,
            depth: 0
          }));
        }
      }]);
      return AssertionError3;
    })(_wrapNativeSuper(Error));
    module.exports = AssertionError2;
  }
});

// ../../node_modules/es6-object-assign/index.js
var require_es6_object_assign = __commonJS({
  "../../node_modules/es6-object-assign/index.js"(exports, module) {
    "use strict";
    init_shim();
    function assign2(target, firstSource) {
      if (target === void 0 || target === null) {
        throw new TypeError("Cannot convert first argument to object");
      }
      var to = Object(target);
      for (var i = 1; i < arguments.length; i++) {
        var nextSource = arguments[i];
        if (nextSource === void 0 || nextSource === null) {
          continue;
        }
        var keysArray = Object.keys(Object(nextSource));
        for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
          var nextKey = keysArray[nextIndex];
          var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
          if (desc !== void 0 && desc.enumerable) {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
      return to;
    }
    function polyfill() {
      if (!Object.assign) {
        Object.defineProperty(Object, "assign", {
          enumerable: false,
          configurable: true,
          writable: true,
          value: assign2
        });
      }
    }
    module.exports = {
      assign: assign2,
      polyfill
    };
  }
});

// ../../node_modules/object-keys/isArguments.js
var require_isArguments = __commonJS({
  "../../node_modules/object-keys/isArguments.js"(exports, module) {
    "use strict";
    init_shim();
    var toStr = Object.prototype.toString;
    module.exports = function isArguments(value) {
      var str = toStr.call(value);
      var isArgs = str === "[object Arguments]";
      if (!isArgs) {
        isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
      }
      return isArgs;
    };
  }
});

// ../../node_modules/object-keys/implementation.js
var require_implementation2 = __commonJS({
  "../../node_modules/object-keys/implementation.js"(exports, module) {
    "use strict";
    init_shim();
    var keysShim;
    if (!Object.keys) {
      has = Object.prototype.hasOwnProperty;
      toStr = Object.prototype.toString;
      isArgs = require_isArguments();
      isEnumerable = Object.prototype.propertyIsEnumerable;
      hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
      hasProtoEnumBug = isEnumerable.call(function() {
      }, "prototype");
      dontEnums = [
        "toString",
        "toLocaleString",
        "valueOf",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "constructor"
      ];
      equalsConstructorPrototype = function(o) {
        var ctor = o.constructor;
        return ctor && ctor.prototype === o;
      };
      excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true
      };
      hasAutomationEqualityBug = (function() {
        if (typeof window === "undefined") {
          return false;
        }
        for (var k in window) {
          try {
            if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
              try {
                equalsConstructorPrototype(window[k]);
              } catch (e) {
                return true;
              }
            }
          } catch (e) {
            return true;
          }
        }
        return false;
      })();
      equalsConstructorPrototypeIfNotBuggy = function(o) {
        if (typeof window === "undefined" || !hasAutomationEqualityBug) {
          return equalsConstructorPrototype(o);
        }
        try {
          return equalsConstructorPrototype(o);
        } catch (e) {
          return false;
        }
      };
      keysShim = function keys3(object) {
        var isObject = object !== null && typeof object === "object";
        var isFunction = toStr.call(object) === "[object Function]";
        var isArguments = isArgs(object);
        var isString2 = isObject && toStr.call(object) === "[object String]";
        var theKeys = [];
        if (!isObject && !isFunction && !isArguments) {
          throw new TypeError("Object.keys called on a non-object");
        }
        var skipProto = hasProtoEnumBug && isFunction;
        if (isString2 && object.length > 0 && !has.call(object, 0)) {
          for (var i = 0; i < object.length; ++i) {
            theKeys.push(String(i));
          }
        }
        if (isArguments && object.length > 0) {
          for (var j = 0; j < object.length; ++j) {
            theKeys.push(String(j));
          }
        } else {
          for (var name in object) {
            if (!(skipProto && name === "prototype") && has.call(object, name)) {
              theKeys.push(String(name));
            }
          }
        }
        if (hasDontEnumBug) {
          var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
          for (var k = 0; k < dontEnums.length; ++k) {
            if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) {
              theKeys.push(dontEnums[k]);
            }
          }
        }
        return theKeys;
      };
    }
    var has;
    var toStr;
    var isArgs;
    var isEnumerable;
    var hasDontEnumBug;
    var hasProtoEnumBug;
    var dontEnums;
    var equalsConstructorPrototype;
    var excludedKeys;
    var hasAutomationEqualityBug;
    var equalsConstructorPrototypeIfNotBuggy;
    module.exports = keysShim;
  }
});

// ../../node_modules/object-keys/index.js
var require_object_keys = __commonJS({
  "../../node_modules/object-keys/index.js"(exports, module) {
    "use strict";
    init_shim();
    var slice = Array.prototype.slice;
    var isArgs = require_isArguments();
    var origKeys = Object.keys;
    var keysShim = origKeys ? function keys3(o) {
      return origKeys(o);
    } : require_implementation2();
    var originalKeys = Object.keys;
    keysShim.shim = function shimObjectKeys() {
      if (Object.keys) {
        var keysWorksWithArguments = (function() {
          var args = Object.keys(arguments);
          return args && args.length === arguments.length;
        })(1, 2);
        if (!keysWorksWithArguments) {
          Object.keys = function keys3(object) {
            if (isArgs(object)) {
              return originalKeys(slice.call(object));
            }
            return originalKeys(object);
          };
        }
      } else {
        Object.keys = keysShim;
      }
      return Object.keys || keysShim;
    };
    module.exports = keysShim;
  }
});

// ../../node_modules/define-properties/index.js
var require_define_properties = __commonJS({
  "../../node_modules/define-properties/index.js"(exports, module) {
    "use strict";
    init_shim();
    var keys3 = require_object_keys();
    var hasSymbols = typeof Symbol === "function" && typeof /* @__PURE__ */ Symbol("foo") === "symbol";
    var toStr = Object.prototype.toString;
    var concat2 = Array.prototype.concat;
    var defineDataProperty = require_define_data_property();
    var isFunction = function(fn) {
      return typeof fn === "function" && toStr.call(fn) === "[object Function]";
    };
    var supportsDescriptors = require_has_property_descriptors()();
    var defineProperty = function(object, name, value, predicate) {
      if (name in object) {
        if (predicate === true) {
          if (object[name] === value) {
            return;
          }
        } else if (!isFunction(predicate) || !predicate()) {
          return;
        }
      }
      if (supportsDescriptors) {
        defineDataProperty(object, name, value, true);
      } else {
        defineDataProperty(object, name, value);
      }
    };
    var defineProperties = function(object, map2) {
      var predicates = arguments.length > 2 ? arguments[2] : {};
      var props = keys3(map2);
      if (hasSymbols) {
        props = concat2.call(props, Object.getOwnPropertySymbols(map2));
      }
      for (var i = 0; i < props.length; i += 1) {
        defineProperty(object, props[i], map2[props[i]], predicates[props[i]]);
      }
    };
    defineProperties.supportsDescriptors = !!supportsDescriptors;
    module.exports = defineProperties;
  }
});

// ../../node_modules/object-is/implementation.js
var require_implementation3 = __commonJS({
  "../../node_modules/object-is/implementation.js"(exports, module) {
    "use strict";
    init_shim();
    var numberIsNaN = function(value) {
      return value !== value;
    };
    module.exports = function is(a, b) {
      if (a === 0 && b === 0) {
        return 1 / a === 1 / b;
      }
      if (a === b) {
        return true;
      }
      if (numberIsNaN(a) && numberIsNaN(b)) {
        return true;
      }
      return false;
    };
  }
});

// ../../node_modules/object-is/polyfill.js
var require_polyfill = __commonJS({
  "../../node_modules/object-is/polyfill.js"(exports, module) {
    "use strict";
    init_shim();
    var implementation = require_implementation3();
    module.exports = function getPolyfill() {
      return typeof Object.is === "function" ? Object.is : implementation;
    };
  }
});

// ../../node_modules/object-is/shim.js
var require_shim = __commonJS({
  "../../node_modules/object-is/shim.js"(exports, module) {
    "use strict";
    init_shim();
    var getPolyfill = require_polyfill();
    var define2 = require_define_properties();
    module.exports = function shimObjectIs() {
      var polyfill = getPolyfill();
      define2(Object, { is: polyfill }, {
        is: function testObjectIs() {
          return Object.is !== polyfill;
        }
      });
      return polyfill;
    };
  }
});

// ../../node_modules/object-is/index.js
var require_object_is = __commonJS({
  "../../node_modules/object-is/index.js"(exports, module) {
    "use strict";
    init_shim();
    var define2 = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation3();
    var getPolyfill = require_polyfill();
    var shim = require_shim();
    var polyfill = callBind(getPolyfill(), Object);
    define2(polyfill, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = polyfill;
  }
});

// ../../node_modules/is-nan/implementation.js
var require_implementation4 = __commonJS({
  "../../node_modules/is-nan/implementation.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = function isNaN2(value) {
      return value !== value;
    };
  }
});

// ../../node_modules/is-nan/polyfill.js
var require_polyfill2 = __commonJS({
  "../../node_modules/is-nan/polyfill.js"(exports, module) {
    "use strict";
    init_shim();
    var implementation = require_implementation4();
    module.exports = function getPolyfill() {
      if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a")) {
        return Number.isNaN;
      }
      return implementation;
    };
  }
});

// ../../node_modules/is-nan/shim.js
var require_shim2 = __commonJS({
  "../../node_modules/is-nan/shim.js"(exports, module) {
    "use strict";
    init_shim();
    var define2 = require_define_properties();
    var getPolyfill = require_polyfill2();
    module.exports = function shimNumberIsNaN() {
      var polyfill = getPolyfill();
      define2(Number, { isNaN: polyfill }, {
        isNaN: function testIsNaN() {
          return Number.isNaN !== polyfill;
        }
      });
      return polyfill;
    };
  }
});

// ../../node_modules/is-nan/index.js
var require_is_nan = __commonJS({
  "../../node_modules/is-nan/index.js"(exports, module) {
    "use strict";
    init_shim();
    var callBind = require_call_bind();
    var define2 = require_define_properties();
    var implementation = require_implementation4();
    var getPolyfill = require_polyfill2();
    var shim = require_shim2();
    var polyfill = callBind(getPolyfill(), Number);
    define2(polyfill, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = polyfill;
  }
});

// ../../node_modules/assert/build/internal/util/comparisons.js
var require_comparisons = __commonJS({
  "../../node_modules/assert/build/internal/util/comparisons.js"(exports, module) {
    "use strict";
    init_shim();
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
    function _iterableToArrayLimit(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = void 0;
      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    function _typeof(obj) {
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    var regexFlagsSupported = /a/g.flags !== void 0;
    var arrayFromSet = function arrayFromSet2(set) {
      var array = [];
      set.forEach(function(value) {
        return array.push(value);
      });
      return array;
    };
    var arrayFromMap = function arrayFromMap2(map2) {
      var array = [];
      map2.forEach(function(value, key) {
        return array.push([key, value]);
      });
      return array;
    };
    var objectIs = Object.is ? Object.is : require_object_is();
    var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
      return [];
    };
    var numberIsNaN = Number.isNaN ? Number.isNaN : require_is_nan();
    function uncurryThis(f) {
      return f.call.bind(f);
    }
    var hasOwnProperty2 = uncurryThis(Object.prototype.hasOwnProperty);
    var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
    var objectToString = uncurryThis(Object.prototype.toString);
    var _require$types = require_util().types;
    var isAnyArrayBuffer = _require$types.isAnyArrayBuffer;
    var isArrayBufferView = _require$types.isArrayBufferView;
    var isDate = _require$types.isDate;
    var isMap = _require$types.isMap;
    var isRegExp = _require$types.isRegExp;
    var isSet = _require$types.isSet;
    var isNativeError = _require$types.isNativeError;
    var isBoxedPrimitive = _require$types.isBoxedPrimitive;
    var isNumberObject = _require$types.isNumberObject;
    var isStringObject = _require$types.isStringObject;
    var isBooleanObject = _require$types.isBooleanObject;
    var isBigIntObject = _require$types.isBigIntObject;
    var isSymbolObject = _require$types.isSymbolObject;
    var isFloat32Array = _require$types.isFloat32Array;
    var isFloat64Array = _require$types.isFloat64Array;
    function isNonIndex(key) {
      if (key.length === 0 || key.length > 10) return true;
      for (var i = 0; i < key.length; i++) {
        var code = key.charCodeAt(i);
        if (code < 48 || code > 57) return true;
      }
      return key.length === 10 && key >= Math.pow(2, 32);
    }
    function getOwnNonIndexProperties(value) {
      return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
    }
    function compare2(a, b) {
      if (a === b) {
        return 0;
      }
      var x = a.length;
      var y = b.length;
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y) {
        return -1;
      }
      if (y < x) {
        return 1;
      }
      return 0;
    }
    var ONLY_ENUMERABLE = void 0;
    var kStrict = true;
    var kLoose = false;
    var kNoIterator = 0;
    var kIsArray = 1;
    var kIsSet = 2;
    var kIsMap = 3;
    function areSimilarRegExps(a, b) {
      return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
    }
    function areSimilarFloatArrays(a, b) {
      if (a.byteLength !== b.byteLength) {
        return false;
      }
      for (var offset = 0; offset < a.byteLength; offset++) {
        if (a[offset] !== b[offset]) {
          return false;
        }
      }
      return true;
    }
    function areSimilarTypedArrays(a, b) {
      if (a.byteLength !== b.byteLength) {
        return false;
      }
      return compare2(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
    }
    function areEqualArrayBuffers(buf1, buf2) {
      return buf1.byteLength === buf2.byteLength && compare2(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
    }
    function isEqualBoxedPrimitive(val1, val2) {
      if (isNumberObject(val1)) {
        return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
      }
      if (isStringObject(val1)) {
        return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
      }
      if (isBooleanObject(val1)) {
        return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
      }
      if (isBigIntObject(val1)) {
        return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
      }
      return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
    }
    function innerDeepEqual(val1, val2, strict, memos) {
      if (val1 === val2) {
        if (val1 !== 0) return true;
        return strict ? objectIs(val1, val2) : true;
      }
      if (strict) {
        if (_typeof(val1) !== "object") {
          return typeof val1 === "number" && numberIsNaN(val1) && numberIsNaN(val2);
        }
        if (_typeof(val2) !== "object" || val1 === null || val2 === null) {
          return false;
        }
        if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
          return false;
        }
      } else {
        if (val1 === null || _typeof(val1) !== "object") {
          if (val2 === null || _typeof(val2) !== "object") {
            return val1 == val2;
          }
          return false;
        }
        if (val2 === null || _typeof(val2) !== "object") {
          return false;
        }
      }
      var val1Tag = objectToString(val1);
      var val2Tag = objectToString(val2);
      if (val1Tag !== val2Tag) {
        return false;
      }
      if (Array.isArray(val1)) {
        if (val1.length !== val2.length) {
          return false;
        }
        var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
        var keys22 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
        if (keys1.length !== keys22.length) {
          return false;
        }
        return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
      }
      if (val1Tag === "[object Object]") {
        if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {
          return false;
        }
      }
      if (isDate(val1)) {
        if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
          return false;
        }
      } else if (isRegExp(val1)) {
        if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {
          return false;
        }
      } else if (isNativeError(val1) || val1 instanceof Error) {
        if (val1.message !== val2.message || val1.name !== val2.name) {
          return false;
        }
      } else if (isArrayBufferView(val1)) {
        if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
          if (!areSimilarFloatArrays(val1, val2)) {
            return false;
          }
        } else if (!areSimilarTypedArrays(val1, val2)) {
          return false;
        }
        var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
        var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
        if (_keys.length !== _keys2.length) {
          return false;
        }
        return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
      } else if (isSet(val1)) {
        if (!isSet(val2) || val1.size !== val2.size) {
          return false;
        }
        return keyCheck(val1, val2, strict, memos, kIsSet);
      } else if (isMap(val1)) {
        if (!isMap(val2) || val1.size !== val2.size) {
          return false;
        }
        return keyCheck(val1, val2, strict, memos, kIsMap);
      } else if (isAnyArrayBuffer(val1)) {
        if (!areEqualArrayBuffers(val1, val2)) {
          return false;
        }
      } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
        return false;
      }
      return keyCheck(val1, val2, strict, memos, kNoIterator);
    }
    function getEnumerables(val, keys3) {
      return keys3.filter(function(k) {
        return propertyIsEnumerable(val, k);
      });
    }
    function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
      if (arguments.length === 5) {
        aKeys = Object.keys(val1);
        var bKeys = Object.keys(val2);
        if (aKeys.length !== bKeys.length) {
          return false;
        }
      }
      var i = 0;
      for (; i < aKeys.length; i++) {
        if (!hasOwnProperty2(val2, aKeys[i])) {
          return false;
        }
      }
      if (strict && arguments.length === 5) {
        var symbolKeysA = objectGetOwnPropertySymbols(val1);
        if (symbolKeysA.length !== 0) {
          var count2 = 0;
          for (i = 0; i < symbolKeysA.length; i++) {
            var key = symbolKeysA[i];
            if (propertyIsEnumerable(val1, key)) {
              if (!propertyIsEnumerable(val2, key)) {
                return false;
              }
              aKeys.push(key);
              count2++;
            } else if (propertyIsEnumerable(val2, key)) {
              return false;
            }
          }
          var symbolKeysB = objectGetOwnPropertySymbols(val2);
          if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count2) {
            return false;
          }
        } else {
          var _symbolKeysB = objectGetOwnPropertySymbols(val2);
          if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
            return false;
          }
        }
      }
      if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
        return true;
      }
      if (memos === void 0) {
        memos = {
          val1: /* @__PURE__ */ new Map(),
          val2: /* @__PURE__ */ new Map(),
          position: 0
        };
      } else {
        var val2MemoA = memos.val1.get(val1);
        if (val2MemoA !== void 0) {
          var val2MemoB = memos.val2.get(val2);
          if (val2MemoB !== void 0) {
            return val2MemoA === val2MemoB;
          }
        }
        memos.position++;
      }
      memos.val1.set(val1, memos.position);
      memos.val2.set(val2, memos.position);
      var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
      memos.val1.delete(val1);
      memos.val2.delete(val2);
      return areEq;
    }
    function setHasEqualElement(set, val1, strict, memo) {
      var setValues = arrayFromSet(set);
      for (var i = 0; i < setValues.length; i++) {
        var val2 = setValues[i];
        if (innerDeepEqual(val1, val2, strict, memo)) {
          set.delete(val2);
          return true;
        }
      }
      return false;
    }
    function findLooseMatchingPrimitives(prim) {
      switch (_typeof(prim)) {
        case "undefined":
          return null;
        case "object":
          return void 0;
        case "symbol":
          return false;
        case "string":
          prim = +prim;
        // Loose equal entries exist only if the string is possible to convert to
        // a regular number and not NaN.
        // Fall through
        case "number":
          if (numberIsNaN(prim)) {
            return false;
          }
      }
      return true;
    }
    function setMightHaveLoosePrim(a, b, prim) {
      var altValue = findLooseMatchingPrimitives(prim);
      if (altValue != null) return altValue;
      return b.has(altValue) && !a.has(altValue);
    }
    function mapMightHaveLoosePrim(a, b, prim, item, memo) {
      var altValue = findLooseMatchingPrimitives(prim);
      if (altValue != null) {
        return altValue;
      }
      var curB = b.get(altValue);
      if (curB === void 0 && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
        return false;
      }
      return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
    }
    function setEquiv(a, b, strict, memo) {
      var set = null;
      var aValues = arrayFromSet(a);
      for (var i = 0; i < aValues.length; i++) {
        var val = aValues[i];
        if (_typeof(val) === "object" && val !== null) {
          if (set === null) {
            set = /* @__PURE__ */ new Set();
          }
          set.add(val);
        } else if (!b.has(val)) {
          if (strict) return false;
          if (!setMightHaveLoosePrim(a, b, val)) {
            return false;
          }
          if (set === null) {
            set = /* @__PURE__ */ new Set();
          }
          set.add(val);
        }
      }
      if (set !== null) {
        var bValues = arrayFromSet(b);
        for (var _i = 0; _i < bValues.length; _i++) {
          var _val = bValues[_i];
          if (_typeof(_val) === "object" && _val !== null) {
            if (!setHasEqualElement(set, _val, strict, memo)) return false;
          } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {
            return false;
          }
        }
        return set.size === 0;
      }
      return true;
    }
    function mapHasEqualEntry(set, map2, key1, item1, strict, memo) {
      var setValues = arrayFromSet(set);
      for (var i = 0; i < setValues.length; i++) {
        var key2 = setValues[i];
        if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map2.get(key2), strict, memo)) {
          set.delete(key2);
          return true;
        }
      }
      return false;
    }
    function mapEquiv(a, b, strict, memo) {
      var set = null;
      var aEntries = arrayFromMap(a);
      for (var i = 0; i < aEntries.length; i++) {
        var _aEntries$i = _slicedToArray(aEntries[i], 2), key = _aEntries$i[0], item1 = _aEntries$i[1];
        if (_typeof(key) === "object" && key !== null) {
          if (set === null) {
            set = /* @__PURE__ */ new Set();
          }
          set.add(key);
        } else {
          var item2 = b.get(key);
          if (item2 === void 0 && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {
            if (strict) return false;
            if (!mapMightHaveLoosePrim(a, b, key, item1, memo)) return false;
            if (set === null) {
              set = /* @__PURE__ */ new Set();
            }
            set.add(key);
          }
        }
      }
      if (set !== null) {
        var bEntries = arrayFromMap(b);
        for (var _i2 = 0; _i2 < bEntries.length; _i2++) {
          var _bEntries$_i = _slicedToArray(bEntries[_i2], 2), key = _bEntries$_i[0], item = _bEntries$_i[1];
          if (_typeof(key) === "object" && key !== null) {
            if (!mapHasEqualEntry(set, a, key, item, strict, memo)) return false;
          } else if (!strict && (!a.has(key) || !innerDeepEqual(a.get(key), item, false, memo)) && !mapHasEqualEntry(set, a, key, item, false, memo)) {
            return false;
          }
        }
        return set.size === 0;
      }
      return true;
    }
    function objEquiv(a, b, strict, keys3, memos, iterationType) {
      var i = 0;
      if (iterationType === kIsSet) {
        if (!setEquiv(a, b, strict, memos)) {
          return false;
        }
      } else if (iterationType === kIsMap) {
        if (!mapEquiv(a, b, strict, memos)) {
          return false;
        }
      } else if (iterationType === kIsArray) {
        for (; i < a.length; i++) {
          if (hasOwnProperty2(a, i)) {
            if (!hasOwnProperty2(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {
              return false;
            }
          } else if (hasOwnProperty2(b, i)) {
            return false;
          } else {
            var keysA = Object.keys(a);
            for (; i < keysA.length; i++) {
              var key = keysA[i];
              if (!hasOwnProperty2(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {
                return false;
              }
            }
            if (keysA.length !== Object.keys(b).length) {
              return false;
            }
            return true;
          }
        }
      }
      for (i = 0; i < keys3.length; i++) {
        var _key = keys3[i];
        if (!innerDeepEqual(a[_key], b[_key], strict, memos)) {
          return false;
        }
      }
      return true;
    }
    function isDeepEqual(val1, val2) {
      return innerDeepEqual(val1, val2, kLoose);
    }
    function isDeepStrictEqual(val1, val2) {
      return innerDeepEqual(val1, val2, kStrict);
    }
    module.exports = {
      isDeepEqual,
      isDeepStrictEqual
    };
  }
});

// ../../node_modules/assert/build/assert.js
var require_assert = __commonJS({
  "../../node_modules/assert/build/assert.js"(exports, module) {
    "use strict";
    init_shim();
    function _typeof(obj) {
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var _require = require_errors();
    var _require$codes = _require.codes;
    var ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE;
    var ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var AssertionError2 = require_assertion_error();
    var _require2 = require_util();
    var inspect = _require2.inspect;
    var _require$types = require_util().types;
    var isPromise = _require$types.isPromise;
    var isRegExp = _require$types.isRegExp;
    var objectAssign = Object.assign ? Object.assign : require_es6_object_assign().assign;
    var objectIs = Object.is ? Object.is : require_object_is();
    var isDeepEqual;
    var isDeepStrictEqual;
    function lazyLoadComparison() {
      var comparison = require_comparisons();
      isDeepEqual = comparison.isDeepEqual;
      isDeepStrictEqual = comparison.isDeepStrictEqual;
    }
    var warned = false;
    var assert12 = module.exports = ok;
    var NO_EXCEPTION_SENTINEL = {};
    function innerFail(obj) {
      if (obj.message instanceof Error) throw obj.message;
      throw new AssertionError2(obj);
    }
    function fail(actual, expected, message, operator, stackStartFn) {
      var argsLen = arguments.length;
      var internalMessage;
      if (argsLen === 0) {
        internalMessage = "Failed";
      } else if (argsLen === 1) {
        message = actual;
        actual = void 0;
      } else {
        if (warned === false) {
          warned = true;
          var warn = process_browser_default.emitWarning ? process_browser_default.emitWarning : console.warn.bind(console);
          warn("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
        }
        if (argsLen === 2) operator = "!=";
      }
      if (message instanceof Error) throw message;
      var errArgs = {
        actual,
        expected,
        operator: operator === void 0 ? "fail" : operator,
        stackStartFn: stackStartFn || fail
      };
      if (message !== void 0) {
        errArgs.message = message;
      }
      var err = new AssertionError2(errArgs);
      if (internalMessage) {
        err.message = internalMessage;
        err.generatedMessage = true;
      }
      throw err;
    }
    assert12.fail = fail;
    assert12.AssertionError = AssertionError2;
    function innerOk(fn, argLen, value, message) {
      if (!value) {
        var generatedMessage = false;
        if (argLen === 0) {
          generatedMessage = true;
          message = "No value argument passed to `assert.ok()`";
        } else if (message instanceof Error) {
          throw message;
        }
        var err = new AssertionError2({
          actual: value,
          expected: true,
          message,
          operator: "==",
          stackStartFn: fn
        });
        err.generatedMessage = generatedMessage;
        throw err;
      }
    }
    function ok() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      innerOk.apply(void 0, [ok, args.length].concat(args));
    }
    assert12.ok = ok;
    assert12.equal = function equal(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (actual != expected) {
        innerFail({
          actual,
          expected,
          message,
          operator: "==",
          stackStartFn: equal
        });
      }
    };
    assert12.notEqual = function notEqual(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (actual == expected) {
        innerFail({
          actual,
          expected,
          message,
          operator: "!=",
          stackStartFn: notEqual
        });
      }
    };
    assert12.deepEqual = function deepEqual2(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (isDeepEqual === void 0) lazyLoadComparison();
      if (!isDeepEqual(actual, expected)) {
        innerFail({
          actual,
          expected,
          message,
          operator: "deepEqual",
          stackStartFn: deepEqual2
        });
      }
    };
    assert12.notDeepEqual = function notDeepEqual(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (isDeepEqual === void 0) lazyLoadComparison();
      if (isDeepEqual(actual, expected)) {
        innerFail({
          actual,
          expected,
          message,
          operator: "notDeepEqual",
          stackStartFn: notDeepEqual
        });
      }
    };
    assert12.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (isDeepEqual === void 0) lazyLoadComparison();
      if (!isDeepStrictEqual(actual, expected)) {
        innerFail({
          actual,
          expected,
          message,
          operator: "deepStrictEqual",
          stackStartFn: deepStrictEqual
        });
      }
    };
    assert12.notDeepStrictEqual = notDeepStrictEqual;
    function notDeepStrictEqual(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (isDeepEqual === void 0) lazyLoadComparison();
      if (isDeepStrictEqual(actual, expected)) {
        innerFail({
          actual,
          expected,
          message,
          operator: "notDeepStrictEqual",
          stackStartFn: notDeepStrictEqual
        });
      }
    }
    assert12.strictEqual = function strictEqual2(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (!objectIs(actual, expected)) {
        innerFail({
          actual,
          expected,
          message,
          operator: "strictEqual",
          stackStartFn: strictEqual2
        });
      }
    };
    assert12.notStrictEqual = function notStrictEqual(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (objectIs(actual, expected)) {
        innerFail({
          actual,
          expected,
          message,
          operator: "notStrictEqual",
          stackStartFn: notStrictEqual
        });
      }
    };
    var Comparison = function Comparison2(obj, keys3, actual) {
      var _this = this;
      _classCallCheck(this, Comparison2);
      keys3.forEach(function(key) {
        if (key in obj) {
          if (actual !== void 0 && typeof actual[key] === "string" && isRegExp(obj[key]) && obj[key].test(actual[key])) {
            _this[key] = actual[key];
          } else {
            _this[key] = obj[key];
          }
        }
      });
    };
    function compareExceptionKey(actual, expected, key, message, keys3, fn) {
      if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
        if (!message) {
          var a = new Comparison(actual, keys3);
          var b = new Comparison(expected, keys3, actual);
          var err = new AssertionError2({
            actual: a,
            expected: b,
            operator: "deepStrictEqual",
            stackStartFn: fn
          });
          err.actual = actual;
          err.expected = expected;
          err.operator = fn.name;
          throw err;
        }
        innerFail({
          actual,
          expected,
          message,
          operator: fn.name,
          stackStartFn: fn
        });
      }
    }
    function expectedException(actual, expected, msg, fn) {
      if (typeof expected !== "function") {
        if (isRegExp(expected)) return expected.test(actual);
        if (arguments.length === 2) {
          throw new ERR_INVALID_ARG_TYPE("expected", ["Function", "RegExp"], expected);
        }
        if (_typeof(actual) !== "object" || actual === null) {
          var err = new AssertionError2({
            actual,
            expected,
            message: msg,
            operator: "deepStrictEqual",
            stackStartFn: fn
          });
          err.operator = fn.name;
          throw err;
        }
        var keys3 = Object.keys(expected);
        if (expected instanceof Error) {
          keys3.push("name", "message");
        } else if (keys3.length === 0) {
          throw new ERR_INVALID_ARG_VALUE("error", expected, "may not be an empty object");
        }
        if (isDeepEqual === void 0) lazyLoadComparison();
        keys3.forEach(function(key) {
          if (typeof actual[key] === "string" && isRegExp(expected[key]) && expected[key].test(actual[key])) {
            return;
          }
          compareExceptionKey(actual, expected, key, msg, keys3, fn);
        });
        return true;
      }
      if (expected.prototype !== void 0 && actual instanceof expected) {
        return true;
      }
      if (Error.isPrototypeOf(expected)) {
        return false;
      }
      return expected.call({}, actual) === true;
    }
    function getActual(fn) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", "Function", fn);
      }
      try {
        fn();
      } catch (e) {
        return e;
      }
      return NO_EXCEPTION_SENTINEL;
    }
    function checkIsPromise(obj) {
      return isPromise(obj) || obj !== null && _typeof(obj) === "object" && typeof obj.then === "function" && typeof obj.catch === "function";
    }
    function waitForActual(promiseFn) {
      return Promise.resolve().then(function() {
        var resultPromise;
        if (typeof promiseFn === "function") {
          resultPromise = promiseFn();
          if (!checkIsPromise(resultPromise)) {
            throw new ERR_INVALID_RETURN_VALUE("instance of Promise", "promiseFn", resultPromise);
          }
        } else if (checkIsPromise(promiseFn)) {
          resultPromise = promiseFn;
        } else {
          throw new ERR_INVALID_ARG_TYPE("promiseFn", ["Function", "Promise"], promiseFn);
        }
        return Promise.resolve().then(function() {
          return resultPromise;
        }).then(function() {
          return NO_EXCEPTION_SENTINEL;
        }).catch(function(e) {
          return e;
        });
      });
    }
    function expectsError(stackStartFn, actual, error, message) {
      if (typeof error === "string") {
        if (arguments.length === 4) {
          throw new ERR_INVALID_ARG_TYPE("error", ["Object", "Error", "Function", "RegExp"], error);
        }
        if (_typeof(actual) === "object" && actual !== null) {
          if (actual.message === error) {
            throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error message "'.concat(actual.message, '" is identical to the message.'));
          }
        } else if (actual === error) {
          throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error "'.concat(actual, '" is identical to the message.'));
        }
        message = error;
        error = void 0;
      } else if (error != null && _typeof(error) !== "object" && typeof error !== "function") {
        throw new ERR_INVALID_ARG_TYPE("error", ["Object", "Error", "Function", "RegExp"], error);
      }
      if (actual === NO_EXCEPTION_SENTINEL) {
        var details = "";
        if (error && error.name) {
          details += " (".concat(error.name, ")");
        }
        details += message ? ": ".concat(message) : ".";
        var fnType = stackStartFn.name === "rejects" ? "rejection" : "exception";
        innerFail({
          actual: void 0,
          expected: error,
          operator: stackStartFn.name,
          message: "Missing expected ".concat(fnType).concat(details),
          stackStartFn
        });
      }
      if (error && !expectedException(actual, error, message, stackStartFn)) {
        throw actual;
      }
    }
    function expectsNoError(stackStartFn, actual, error, message) {
      if (actual === NO_EXCEPTION_SENTINEL) return;
      if (typeof error === "string") {
        message = error;
        error = void 0;
      }
      if (!error || expectedException(actual, error)) {
        var details = message ? ": ".concat(message) : ".";
        var fnType = stackStartFn.name === "doesNotReject" ? "rejection" : "exception";
        innerFail({
          actual,
          expected: error,
          operator: stackStartFn.name,
          message: "Got unwanted ".concat(fnType).concat(details, "\n") + 'Actual message: "'.concat(actual && actual.message, '"'),
          stackStartFn
        });
      }
      throw actual;
    }
    assert12.throws = function throws(promiseFn) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      expectsError.apply(void 0, [throws, getActual(promiseFn)].concat(args));
    };
    assert12.rejects = function rejects(promiseFn) {
      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }
      return waitForActual(promiseFn).then(function(result) {
        return expectsError.apply(void 0, [rejects, result].concat(args));
      });
    };
    assert12.doesNotThrow = function doesNotThrow(fn) {
      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        args[_key4 - 1] = arguments[_key4];
      }
      expectsNoError.apply(void 0, [doesNotThrow, getActual(fn)].concat(args));
    };
    assert12.doesNotReject = function doesNotReject(fn) {
      for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
        args[_key5 - 1] = arguments[_key5];
      }
      return waitForActual(fn).then(function(result) {
        return expectsNoError.apply(void 0, [doesNotReject, result].concat(args));
      });
    };
    assert12.ifError = function ifError(err) {
      if (err !== null && err !== void 0) {
        var message = "ifError got unwanted exception: ";
        if (_typeof(err) === "object" && typeof err.message === "string") {
          if (err.message.length === 0 && err.constructor) {
            message += err.constructor.name;
          } else {
            message += err.message;
          }
        } else {
          message += inspect(err);
        }
        var newErr = new AssertionError2({
          actual: err,
          expected: null,
          operator: "ifError",
          message,
          stackStartFn: ifError
        });
        var origStack = err.stack;
        if (typeof origStack === "string") {
          var tmp2 = origStack.split("\n");
          tmp2.shift();
          var tmp1 = newErr.stack.split("\n");
          for (var i = 0; i < tmp2.length; i++) {
            var pos = tmp1.indexOf(tmp2[i]);
            if (pos !== -1) {
              tmp1 = tmp1.slice(0, pos);
              break;
            }
          }
          newErr.stack = "".concat(tmp1.join("\n"), "\n").concat(tmp2.join("\n"));
        }
        throw newErr;
      }
    };
    function strict() {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }
      innerOk.apply(void 0, [strict, args.length].concat(args));
    }
    assert12.strict = objectAssign(strict, assert12, {
      equal: assert12.strictEqual,
      deepEqual: assert12.deepStrictEqual,
      notEqual: assert12.notStrictEqual,
      notDeepEqual: assert12.notDeepStrictEqual
    });
    assert12.strict.strict = assert12.strict;
  }
});

// ../../node_modules/path-browserify/index.js
var require_path_browserify = __commonJS({
  "../../node_modules/path-browserify/index.js"(exports, module) {
    "use strict";
    init_shim();
    function assertPath(path) {
      if (typeof path !== "string") {
        throw new TypeError("Path must be a string. Received " + JSON.stringify(path));
      }
    }
    function normalizeStringPosix(path, allowAboveRoot) {
      var res = "";
      var lastSegmentLength = 0;
      var lastSlash = -1;
      var dots = 0;
      var code;
      for (var i = 0; i <= path.length; ++i) {
        if (i < path.length)
          code = path.charCodeAt(i);
        else if (code === 47)
          break;
        else
          code = 47;
        if (code === 47) {
          if (lastSlash === i - 1 || dots === 1) {
          } else if (lastSlash !== i - 1 && dots === 2) {
            if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
              if (res.length > 2) {
                var lastSlashIndex = res.lastIndexOf("/");
                if (lastSlashIndex !== res.length - 1) {
                  if (lastSlashIndex === -1) {
                    res = "";
                    lastSegmentLength = 0;
                  } else {
                    res = res.slice(0, lastSlashIndex);
                    lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                  }
                  lastSlash = i;
                  dots = 0;
                  continue;
                }
              } else if (res.length === 2 || res.length === 1) {
                res = "";
                lastSegmentLength = 0;
                lastSlash = i;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              if (res.length > 0)
                res += "/..";
              else
                res = "..";
              lastSegmentLength = 2;
            }
          } else {
            if (res.length > 0)
              res += "/" + path.slice(lastSlash + 1, i);
            else
              res = path.slice(lastSlash + 1, i);
            lastSegmentLength = i - lastSlash - 1;
          }
          lastSlash = i;
          dots = 0;
        } else if (code === 46 && dots !== -1) {
          ++dots;
        } else {
          dots = -1;
        }
      }
      return res;
    }
    function _format(sep2, pathObject) {
      var dir = pathObject.dir || pathObject.root;
      var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
      if (!dir) {
        return base;
      }
      if (dir === pathObject.root) {
        return dir + base;
      }
      return dir + sep2 + base;
    }
    var posix3 = {
      // path.resolve([from ...], to)
      resolve: function resolve2() {
        var resolvedPath = "";
        var resolvedAbsolute = false;
        var cwd;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path;
          if (i >= 0)
            path = arguments[i];
          else {
            if (cwd === void 0)
              cwd = process_browser_default.cwd();
            path = cwd;
          }
          assertPath(path);
          if (path.length === 0) {
            continue;
          }
          resolvedPath = path + "/" + resolvedPath;
          resolvedAbsolute = path.charCodeAt(0) === 47;
        }
        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
        if (resolvedAbsolute) {
          if (resolvedPath.length > 0)
            return "/" + resolvedPath;
          else
            return "/";
        } else if (resolvedPath.length > 0) {
          return resolvedPath;
        } else {
          return ".";
        }
      },
      normalize: function normalize4(path) {
        assertPath(path);
        if (path.length === 0) return ".";
        var isAbsolute2 = path.charCodeAt(0) === 47;
        var trailingSeparator = path.charCodeAt(path.length - 1) === 47;
        path = normalizeStringPosix(path, !isAbsolute2);
        if (path.length === 0 && !isAbsolute2) path = ".";
        if (path.length > 0 && trailingSeparator) path += "/";
        if (isAbsolute2) return "/" + path;
        return path;
      },
      isAbsolute: function isAbsolute2(path) {
        assertPath(path);
        return path.length > 0 && path.charCodeAt(0) === 47;
      },
      join: function join2() {
        if (arguments.length === 0)
          return ".";
        var joined;
        for (var i = 0; i < arguments.length; ++i) {
          var arg = arguments[i];
          assertPath(arg);
          if (arg.length > 0) {
            if (joined === void 0)
              joined = arg;
            else
              joined += "/" + arg;
          }
        }
        if (joined === void 0)
          return ".";
        return posix3.normalize(joined);
      },
      relative: function relative2(from, to) {
        assertPath(from);
        assertPath(to);
        if (from === to) return "";
        from = posix3.resolve(from);
        to = posix3.resolve(to);
        if (from === to) return "";
        var fromStart = 1;
        for (; fromStart < from.length; ++fromStart) {
          if (from.charCodeAt(fromStart) !== 47)
            break;
        }
        var fromEnd = from.length;
        var fromLen = fromEnd - fromStart;
        var toStart = 1;
        for (; toStart < to.length; ++toStart) {
          if (to.charCodeAt(toStart) !== 47)
            break;
        }
        var toEnd = to.length;
        var toLen = toEnd - toStart;
        var length = fromLen < toLen ? fromLen : toLen;
        var lastCommonSep = -1;
        var i = 0;
        for (; i <= length; ++i) {
          if (i === length) {
            if (toLen > length) {
              if (to.charCodeAt(toStart + i) === 47) {
                return to.slice(toStart + i + 1);
              } else if (i === 0) {
                return to.slice(toStart + i);
              }
            } else if (fromLen > length) {
              if (from.charCodeAt(fromStart + i) === 47) {
                lastCommonSep = i;
              } else if (i === 0) {
                lastCommonSep = 0;
              }
            }
            break;
          }
          var fromCode = from.charCodeAt(fromStart + i);
          var toCode = to.charCodeAt(toStart + i);
          if (fromCode !== toCode)
            break;
          else if (fromCode === 47)
            lastCommonSep = i;
        }
        var out = "";
        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
          if (i === fromEnd || from.charCodeAt(i) === 47) {
            if (out.length === 0)
              out += "..";
            else
              out += "/..";
          }
        }
        if (out.length > 0)
          return out + to.slice(toStart + lastCommonSep);
        else {
          toStart += lastCommonSep;
          if (to.charCodeAt(toStart) === 47)
            ++toStart;
          return to.slice(toStart);
        }
      },
      _makeLong: function _makeLong(path) {
        return path;
      },
      dirname: function dirname2(path) {
        assertPath(path);
        if (path.length === 0) return ".";
        var code = path.charCodeAt(0);
        var hasRoot = code === 47;
        var end = -1;
        var matchedSlash = true;
        for (var i = path.length - 1; i >= 1; --i) {
          code = path.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              end = i;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1) return hasRoot ? "/" : ".";
        if (hasRoot && end === 1) return "//";
        return path.slice(0, end);
      },
      basename: function basename4(path, ext) {
        if (ext !== void 0 && typeof ext !== "string") throw new TypeError('"ext" argument must be a string');
        assertPath(path);
        var start = 0;
        var end = -1;
        var matchedSlash = true;
        var i;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
          if (ext.length === path.length && ext === path) return "";
          var extIdx = ext.length - 1;
          var firstNonSlashEnd = -1;
          for (i = path.length - 1; i >= 0; --i) {
            var code = path.charCodeAt(i);
            if (code === 47) {
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i + 1;
              }
              if (extIdx >= 0) {
                if (code === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end) end = firstNonSlashEnd;
          else if (end === -1) end = path.length;
          return path.slice(start, end);
        } else {
          for (i = path.length - 1; i >= 0; --i) {
            if (path.charCodeAt(i) === 47) {
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
          }
          if (end === -1) return "";
          return path.slice(start, end);
        }
      },
      extname: function extname2(path) {
        assertPath(path);
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var preDotState = 0;
        for (var i = path.length - 1; i >= 0; --i) {
          var code = path.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path.slice(startDot, end);
      },
      format: function format3(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
          throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
        }
        return _format("/", pathObject);
      },
      parse: function parse2(path) {
        assertPath(path);
        var ret = { root: "", dir: "", base: "", ext: "", name: "" };
        if (path.length === 0) return ret;
        var code = path.charCodeAt(0);
        var isAbsolute2 = code === 47;
        var start;
        if (isAbsolute2) {
          ret.root = "/";
          start = 1;
        } else {
          start = 0;
        }
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var i = path.length - 1;
        var preDotState = 0;
        for (; i >= start; --i) {
          code = path.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
          if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          if (end !== -1) {
            if (startPart === 0 && isAbsolute2) ret.base = ret.name = path.slice(1, end);
            else ret.base = ret.name = path.slice(startPart, end);
          }
        } else {
          if (startPart === 0 && isAbsolute2) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
          } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
          }
          ret.ext = path.slice(startDot, end);
        }
        if (startPart > 0) ret.dir = path.slice(0, startPart - 1);
        else if (isAbsolute2) ret.dir = "/";
        return ret;
      },
      sep: "/",
      delimiter: ":",
      win32: null,
      posix: null
    };
    posix3.posix = posix3;
    module.exports = posix3;
  }
});

// src/shims/path-browserify-win32.js
var path_browserify_win32_exports = {};
__export(path_browserify_win32_exports, {
  basename: () => basename2,
  default: () => path_browserify_win32_default,
  delimiter: () => delimiter,
  dirname: () => dirname,
  extname: () => extname,
  format: () => format,
  isAbsolute: () => isAbsolute,
  join: () => join,
  normalize: () => normalize,
  parse: () => parse,
  posix: () => posix,
  relative: () => relative,
  resolve: () => resolve,
  sep: () => sep,
  win32: () => win32
});
var import_path_browserify, patchedPath, resolve, normalize, isAbsolute, join, relative, dirname, basename2, extname, format, parse, sep, delimiter, win32, posix, path_browserify_win32_default;
var init_path_browserify_win32 = __esm({
  "src/shims/path-browserify-win32.js"() {
    init_shim();
    import_path_browserify = __toESM(require_path_browserify());
    patchedPath = import_path_browserify.default;
    patchedPath.win32 = patchedPath.win32 || import_path_browserify.default;
    patchedPath.posix = patchedPath.posix || import_path_browserify.default;
    ({
      resolve,
      normalize,
      isAbsolute,
      join,
      relative,
      dirname,
      basename: basename2,
      extname,
      format,
      parse,
      sep,
      delimiter,
      win32,
      posix
    } = patchedPath);
    path_browserify_win32_default = patchedPath;
  }
});

// ../../node_modules/node-stdlib-browser/node_modules/punycode/punycode.js
var require_punycode = __commonJS({
  "../../node_modules/node-stdlib-browser/node_modules/punycode/punycode.js"(exports, module) {
    init_shim();
    (function(root) {
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = typeof module == "object" && module && !module.nodeType && module;
      var freeGlobal = typeof _global == "object" && _global;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
        root = freeGlobal;
      }
      var punycode, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter2 = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
      function error(type) {
        throw new RangeError(errors[type]);
      }
      function map2(array, fn) {
        var length = array.length;
        var result = [];
        while (length--) {
          result[length] = fn(array[length]);
        }
        return result;
      }
      function mapDomain(string, fn) {
        var parts = string.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string = parts[1];
        }
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map2(labels, fn).join(".");
        return result + encoded;
      }
      function ucs2decode(string) {
        var output = [], counter = 0, length = string.length, value, extra;
        while (counter < length) {
          value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      function ucs2encode(array) {
        return map2(array, function(value) {
          var output = "";
          if (value > 65535) {
            value -= 65536;
            output += stringFromCharCode(value >>> 10 & 1023 | 55296);
            value = 56320 | value & 1023;
          }
          output += stringFromCharCode(value);
          return output;
        }).join("");
      }
      function basicToDigit(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      }
      function digitToBasic(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      }
      function adapt(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (; delta > baseMinusTMin * tMax >> 1; k += base) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      }
      function decode2(input) {
        var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, baseMinusT;
        basic = input.lastIndexOf(delimiter2);
        if (basic < 0) {
          basic = 0;
        }
        for (j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 128) {
            error("not-basic");
          }
          output.push(input.charCodeAt(j));
        }
        for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          for (oldi = i, w = 1, k = base; ; k += base) {
            if (index >= inputLength) {
              error("invalid-input");
            }
            digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base || digit > floor((maxInt - i) / w)) {
              error("overflow");
            }
            i += digit * w;
            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t) {
              break;
            }
            baseMinusT = base - t;
            if (w > floor(maxInt / baseMinusT)) {
              error("overflow");
            }
            w *= baseMinusT;
          }
          out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor(i / out) > maxInt - n) {
            error("overflow");
          }
          n += floor(i / out);
          i %= out;
          output.splice(i++, 0, n);
        }
        return ucs2encode(output);
      }
      function encode(input) {
        var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
        input = ucs2decode(input);
        inputLength = input.length;
        n = initialN;
        delta = 0;
        bias = initialBias;
        for (j = 0; j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue < 128) {
            output.push(stringFromCharCode(currentValue));
          }
        }
        handledCPCount = basicLength = output.length;
        if (basicLength) {
          output.push(delimiter2);
        }
        while (handledCPCount < inputLength) {
          for (m = maxInt, j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue >= n && currentValue < m) {
              m = currentValue;
            }
          }
          handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error("overflow");
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < n && ++delta > maxInt) {
              error("overflow");
            }
            if (currentValue == n) {
              for (q = delta, k = base; ; k += base) {
                t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q < t) {
                  break;
                }
                qMinusT = q - t;
                baseMinusT = base - t;
                output.push(
                  stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
                );
                q = floor(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
          ++delta;
          ++n;
        }
        return output.join("");
      }
      function toUnicode(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode2(string.slice(4).toLowerCase()) : string;
        });
      }
      function toASCII(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
        });
      }
      punycode = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        "version": "1.4.1",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode2,
        "encode": encode,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        define("punycode", function() {
          return punycode;
        });
      } else if (freeExports && freeModule) {
        if (module.exports == freeExports) {
          freeModule.exports = punycode;
        } else {
          for (key in punycode) {
            punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
          }
        }
      } else {
        root.punycode = punycode;
      }
    })(exports);
  }
});

// (disabled):../../node_modules/object-inspect/util.inspect
var require_util2 = __commonJS({
  "(disabled):../../node_modules/object-inspect/util.inspect"() {
    init_shim();
  }
});

// ../../node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "../../node_modules/object-inspect/index.js"(exports, module) {
    init_shim();
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
      return O.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    var utilInspect = require_util2();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
    module.exports = function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray2(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect(value, from, noIndent) {
        if (from) {
          seen = $arrSlice.call(seen);
          seen.push(from);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function" && !isRegExp(obj)) {
        var name = nameOf(obj);
        var keys3 = arrObjKeys(obj, inspect);
        return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys3.length > 0 ? " { " + $join.call(keys3, ", ") + " }" : "");
      }
      if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
          s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
        }
        s += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s += "...";
        }
        s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s;
      }
      if (isArray2(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError4(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
          mapForEach.call(obj, function(value, key) {
            mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
          });
        }
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
          setForEach.call(obj, function(value) {
            setParts.push(inspect(value, obj));
          });
        }
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
      }
      if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString2(obj)) {
        return markBoxed(inspect(String(obj)));
      }
      if (typeof window !== "undefined" && obj === window) {
        return "{ [object Window] }";
      }
      if (typeof globalThis !== "undefined" && obj === globalThis || typeof _global !== "undefined" && obj === _global) {
        return "{ [object globalThis] }";
      }
      if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s, defaultStyle, opts) {
      var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
      return quoteChar + s + quoteChar;
    }
    function quote(s) {
      return $replace.call(String(s), /"/g, "&quot;");
    }
    function isArray2(obj) {
      return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isDate(obj) {
      return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isRegExp(obj) {
      return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isError4(obj) {
      return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isString2(obj) {
      return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isNumber(obj) {
      return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isBoolean(obj) {
      return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isSymbol(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    var hasOwn2 = Object.prototype.hasOwnProperty || function(key) {
      return key in this;
    };
    function has(obj, key) {
      return hasOwn2.call(obj, key);
    }
    function toStr(obj) {
      return objectToString.call(obj);
    }
    function nameOf(f) {
      if (f.name) {
        return f.name;
      }
      var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
      if (m) {
        return m[1];
      }
      return null;
    }
    function indexOf(xs, x) {
      if (xs.indexOf) {
        return xs.indexOf(x);
      }
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) {
          return i;
        }
      }
      return -1;
    }
    function isMap(x) {
      if (!mapSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        mapSize.call(x);
        try {
          setSize.call(x);
        } catch (s) {
          return true;
        }
        return x instanceof Map;
      } catch (e) {
      }
      return false;
    }
    function isWeakMap(x) {
      if (!weakMapHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x, weakMapHas);
        try {
          weakSetHas.call(x, weakSetHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakMap;
      } catch (e) {
      }
      return false;
    }
    function isWeakRef(x) {
      if (!weakRefDeref || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isSet(x) {
      if (!setSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        setSize.call(x);
        try {
          mapSize.call(x);
        } catch (m) {
          return true;
        }
        return x instanceof Set;
      } catch (e) {
      }
      return false;
    }
    function isWeakSet(x) {
      if (!weakSetHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x, weakSetHas);
        try {
          weakMapHas.call(x, weakMapHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakSet;
      } catch (e) {
      }
      return false;
    }
    function isElement(x) {
      if (!x || typeof x !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
        return true;
      }
      return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var s = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s, "single", opts);
    }
    function lowbyte(c) {
      var n = c.charCodeAt(0);
      var x = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n];
      if (x) {
        return "\\" + x;
      }
      return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type) {
      return type + " { ? }";
    }
    function collectionOf(type, size, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type + " (" + size + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect) {
      var isArr = isArray2(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
          xs[i] = has(obj, i) ? inspect(obj[i], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
          symMap["$" + syms[k]] = syms[k];
        }
      }
      for (var key in obj) {
        if (!has(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key)) {
          xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j = 0; j < syms.length; j++) {
          if (isEnumerable.call(obj, syms[j])) {
            xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
          }
        }
      }
      return xs;
    }
  }
});

// ../../node_modules/side-channel/index.js
var require_side_channel = __commonJS({
  "../../node_modules/side-channel/index.js"(exports, module) {
    "use strict";
    init_shim();
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var inspect = require_object_inspect();
    var $TypeError = require_type();
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $Map = GetIntrinsic("%Map%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var listGetNode = function(list, key) {
      var prev = list;
      var curr;
      for (; (curr = prev.next) !== null; prev = curr) {
        if (curr.key === key) {
          prev.next = curr.next;
          curr.next = /** @type {NonNullable<typeof list.next>} */
          list.next;
          list.next = curr;
          return curr;
        }
      }
    };
    var listGet = function(objects, key) {
      var node = listGetNode(objects, key);
      return node && node.value;
    };
    var listSet = function(objects, key, value) {
      var node = listGetNode(objects, key);
      if (node) {
        node.value = value;
      } else {
        objects.next = /** @type {import('.').ListNode<typeof value>} */
        {
          // eslint-disable-line no-param-reassign, no-extra-parens
          key,
          next: objects.next,
          value
        };
      }
    };
    var listHas = function(objects, key) {
      return !!listGetNode(objects, key);
    };
    module.exports = function getSideChannel() {
      var $wm;
      var $m;
      var $o;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        },
        get: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapGet($m, key);
            }
          } else {
            if ($o) {
              return listGet($o, key);
            }
          }
        },
        has: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapHas($m, key);
            }
          } else {
            if ($o) {
              return listHas($o, key);
            }
          }
          return false;
        },
        set: function(key, value) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key, value);
          } else if ($Map) {
            if (!$m) {
              $m = new $Map();
            }
            $mapSet($m, key, value);
          } else {
            if (!$o) {
              $o = { key: {}, next: null };
            }
            listSet($o, key, value);
          }
        }
      };
      return channel;
    };
  }
});

// ../../node_modules/qs/lib/formats.js
var require_formats = __commonJS({
  "../../node_modules/qs/lib/formats.js"(exports, module) {
    "use strict";
    init_shim();
    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;
    var Format = {
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
    module.exports = {
      "default": Format.RFC3986,
      formatters: {
        RFC1738: function(value) {
          return replace.call(value, percentTwenties, "+");
        },
        RFC3986: function(value) {
          return String(value);
        }
      },
      RFC1738: Format.RFC1738,
      RFC3986: Format.RFC3986
    };
  }
});

// ../../node_modules/qs/lib/utils.js
var require_utils = __commonJS({
  "../../node_modules/qs/lib/utils.js"(exports, module) {
    "use strict";
    init_shim();
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var isArray2 = Array.isArray;
    var hexTable = (function() {
      var array = [];
      for (var i = 0; i < 256; ++i) {
        array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
      }
      return array;
    })();
    var compactQueue = function compactQueue2(queue2) {
      while (queue2.length > 1) {
        var item = queue2.pop();
        var obj = item.obj[item.prop];
        if (isArray2(obj)) {
          var compacted = [];
          for (var j = 0; j < obj.length; ++j) {
            if (typeof obj[j] !== "undefined") {
              compacted.push(obj[j]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
    };
    var arrayToObject = function arrayToObject2(source, options) {
      var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== "undefined") {
          obj[i] = source[i];
        }
      }
      return obj;
    };
    var merge4 = function merge5(target, source, options) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object") {
        if (isArray2(target)) {
          target.push(source);
        } else if (target && typeof target === "object") {
          if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source);
      }
      var mergeTarget = target;
      if (isArray2(target) && !isArray2(source)) {
        mergeTarget = arrayToObject(target, options);
      }
      if (isArray2(target) && isArray2(source)) {
        source.forEach(function(item, i) {
          if (has.call(target, i)) {
            var targetItem = target[i];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i] = merge5(targetItem, item, options);
            } else {
              target.push(item);
            }
          } else {
            target[i] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function(acc, key) {
        var value = source[key];
        if (has.call(acc, key)) {
          acc[key] = merge5(acc[key], value, options);
        } else {
          acc[key] = value;
        }
        return acc;
      }, mergeTarget);
    };
    var assign2 = function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
      }, target);
    };
    var decode2 = function(str, decoder, charset) {
      var strWithoutPlus = str.replace(/\+/g, " ");
      if (charset === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(strWithoutPlus);
      } catch (e) {
        return strWithoutPlus;
      }
    };
    var limit = 1024;
    var encode = function encode2(str, defaultEncoder, charset, kind, format3) {
      if (str.length === 0) {
        return str;
      }
      var string = str;
      if (typeof str === "symbol") {
        string = Symbol.prototype.toString.call(str);
      } else if (typeof str !== "string") {
        string = String(str);
      }
      if (charset === "iso-8859-1") {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
          return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
      }
      var out = "";
      for (var j = 0; j < string.length; j += limit) {
        var segment = string.length >= limit ? string.slice(j, j + limit) : string;
        var arr = [];
        for (var i = 0; i < segment.length; ++i) {
          var c = segment.charCodeAt(i);
          if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format3 === formats.RFC1738 && (c === 40 || c === 41)) {
            arr[arr.length] = segment.charAt(i);
            continue;
          }
          if (c < 128) {
            arr[arr.length] = hexTable[c];
            continue;
          }
          if (c < 2048) {
            arr[arr.length] = hexTable[192 | c >> 6] + hexTable[128 | c & 63];
            continue;
          }
          if (c < 55296 || c >= 57344) {
            arr[arr.length] = hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
            continue;
          }
          i += 1;
          c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i) & 1023);
          arr[arr.length] = hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
        }
        out += arr.join("");
      }
      return out;
    };
    var compact = function compact2(value) {
      var queue2 = [{ obj: { o: value }, prop: "o" }];
      var refs = [];
      for (var i = 0; i < queue2.length; ++i) {
        var item = queue2[i];
        var obj = item.obj[item.prop];
        var keys3 = Object.keys(obj);
        for (var j = 0; j < keys3.length; ++j) {
          var key = keys3[j];
          var val = obj[key];
          if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
            queue2.push({ obj, prop: key });
            refs.push(val);
          }
        }
      }
      compactQueue(queue2);
      return value;
    };
    var isRegExp = function isRegExp2(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    };
    var isBuffer = function isBuffer2(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };
    var combine3 = function combine4(a, b) {
      return [].concat(a, b);
    };
    var maybeMap = function maybeMap2(val, fn) {
      if (isArray2(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
          mapped.push(fn(val[i]));
        }
        return mapped;
      }
      return fn(val);
    };
    module.exports = {
      arrayToObject,
      assign: assign2,
      combine: combine3,
      compact,
      decode: decode2,
      encode,
      isBuffer,
      isRegExp,
      maybeMap,
      merge: merge4
    };
  }
});

// ../../node_modules/qs/lib/stringify.js
var require_stringify = __commonJS({
  "../../node_modules/qs/lib/stringify.js"(exports, module) {
    "use strict";
    init_shim();
    var getSideChannel = require_side_channel();
    var utils = require_utils();
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var arrayPrefixGenerators = {
      brackets: function brackets(prefix) {
        return prefix + "[]";
      },
      comma: "comma",
      indices: function indices(prefix, key) {
        return prefix + "[" + key + "]";
      },
      repeat: function repeat(prefix) {
        return prefix;
      }
    };
    var isArray2 = Array.isArray;
    var push = Array.prototype.push;
    var pushToArray = function(arr, valueOrArray) {
      push.apply(arr, isArray2(valueOrArray) ? valueOrArray : [valueOrArray]);
    };
    var toISO = Date.prototype.toISOString;
    var defaultFormat = formats["default"];
    var defaults = {
      addQueryPrefix: false,
      allowDots: false,
      allowEmptyArrays: false,
      arrayFormat: "indices",
      charset: "utf-8",
      charsetSentinel: false,
      delimiter: "&",
      encode: true,
      encodeDotInKeys: false,
      encoder: utils.encode,
      encodeValuesOnly: false,
      format: defaultFormat,
      formatter: formats.formatters[defaultFormat],
      // deprecated
      indices: false,
      serializeDate: function serializeDate(date) {
        return toISO.call(date);
      },
      skipNulls: false,
      strictNullHandling: false
    };
    var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
      return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
    };
    var sentinel = {};
    var stringify = function stringify2(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter2, sort, allowDots, serializeDate, format3, formatter, encodeValuesOnly, charset, sideChannel) {
      var obj = object;
      var tmpSc = sideChannel;
      var step = 0;
      var findFlag = false;
      while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
        var pos = tmpSc.get(object);
        step += 1;
        if (typeof pos !== "undefined") {
          if (pos === step) {
            throw new RangeError("Cyclic object value");
          } else {
            findFlag = true;
          }
        }
        if (typeof tmpSc.get(sentinel) === "undefined") {
          step = 0;
        }
      }
      if (typeof filter2 === "function") {
        obj = filter2(prefix, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      } else if (generateArrayPrefix === "comma" && isArray2(obj)) {
        obj = utils.maybeMap(obj, function(value2) {
          if (value2 instanceof Date) {
            return serializeDate(value2);
          }
          return value2;
        });
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, "key", format3) : prefix;
        }
        obj = "";
      }
      if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
          var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format3);
          return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset, "value", format3))];
        }
        return [formatter(prefix) + "=" + formatter(String(obj))];
      }
      var values = [];
      if (typeof obj === "undefined") {
        return values;
      }
      var objKeys;
      if (generateArrayPrefix === "comma" && isArray2(obj)) {
        if (encodeValuesOnly && encoder) {
          obj = utils.maybeMap(obj, encoder);
        }
        objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
      } else if (isArray2(filter2)) {
        objKeys = filter2;
      } else {
        var keys3 = Object.keys(obj);
        objKeys = sort ? keys3.sort(sort) : keys3;
      }
      var encodedPrefix = encodeDotInKeys ? prefix.replace(/\./g, "%2E") : prefix;
      var adjustedPrefix = commaRoundTrip && isArray2(obj) && obj.length === 1 ? encodedPrefix + "[]" : encodedPrefix;
      if (allowEmptyArrays && isArray2(obj) && obj.length === 0) {
        return adjustedPrefix + "[]";
      }
      for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
        if (skipNulls && value === null) {
          continue;
        }
        var encodedKey = allowDots && encodeDotInKeys ? key.replace(/\./g, "%2E") : key;
        var keyPrefix = isArray2(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + encodedKey : "[" + encodedKey + "]");
        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify2(
          value,
          keyPrefix,
          generateArrayPrefix,
          commaRoundTrip,
          allowEmptyArrays,
          strictNullHandling,
          skipNulls,
          encodeDotInKeys,
          generateArrayPrefix === "comma" && encodeValuesOnly && isArray2(obj) ? null : encoder,
          filter2,
          sort,
          allowDots,
          serializeDate,
          format3,
          formatter,
          encodeValuesOnly,
          charset,
          valueSideChannel
        ));
      }
      return values;
    };
    var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
        throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
      }
      if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
        throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
      }
      if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = opts.charset || defaults.charset;
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var format3 = formats["default"];
      if (typeof opts.format !== "undefined") {
        if (!has.call(formats.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format3 = opts.format;
      }
      var formatter = formats.formatters[format3];
      var filter2 = defaults.filter;
      if (typeof opts.filter === "function" || isArray2(opts.filter)) {
        filter2 = opts.filter;
      }
      var arrayFormat;
      if (opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
      } else if ("indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
      } else {
        arrayFormat = defaults.arrayFormat;
      }
      if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
      }
      var allowDots = typeof opts.allowDots === "undefined" ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
      return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        arrayFormat,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        commaRoundTrip: opts.commaRoundTrip,
        delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
        encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter2,
        format: format3,
        formatter,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module.exports = function(object, opts) {
      var obj = object;
      var options = normalizeStringifyOptions(opts);
      var objKeys;
      var filter2;
      if (typeof options.filter === "function") {
        filter2 = options.filter;
        obj = filter2("", obj);
      } else if (isArray2(options.filter)) {
        filter2 = options.filter;
        objKeys = filter2;
      }
      var keys3 = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
      var commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (options.sort) {
        objKeys.sort(options.sort);
      }
      var sideChannel = getSideChannel();
      for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        if (options.skipNulls && obj[key] === null) {
          continue;
        }
        pushToArray(keys3, stringify(
          obj[key],
          key,
          generateArrayPrefix,
          commaRoundTrip,
          options.allowEmptyArrays,
          options.strictNullHandling,
          options.skipNulls,
          options.encodeDotInKeys,
          options.encode ? options.encoder : null,
          options.filter,
          options.sort,
          options.allowDots,
          options.serializeDate,
          options.format,
          options.formatter,
          options.encodeValuesOnly,
          options.charset,
          sideChannel
        ));
      }
      var joined = keys3.join(options.delimiter);
      var prefix = options.addQueryPrefix === true ? "?" : "";
      if (options.charsetSentinel) {
        if (options.charset === "iso-8859-1") {
          prefix += "utf8=%26%2310003%3B&";
        } else {
          prefix += "utf8=%E2%9C%93&";
        }
      }
      return joined.length > 0 ? prefix + joined : "";
    };
  }
});

// ../../node_modules/qs/lib/parse.js
var require_parse = __commonJS({
  "../../node_modules/qs/lib/parse.js"(exports, module) {
    "use strict";
    init_shim();
    var utils = require_utils();
    var has = Object.prototype.hasOwnProperty;
    var isArray2 = Array.isArray;
    var defaults = {
      allowDots: false,
      allowEmptyArrays: false,
      allowPrototypes: false,
      allowSparse: false,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: false,
      comma: false,
      decodeDotInKeys: false,
      decoder: utils.decode,
      delimiter: "&",
      depth: 5,
      duplicates: "combine",
      ignoreQueryPrefix: false,
      interpretNumericEntities: false,
      parameterLimit: 1e3,
      parseArrays: true,
      plainObjects: false,
      strictDepth: false,
      strictNullHandling: false
    };
    var interpretNumericEntities = function(str) {
      return str.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
      });
    };
    var parseArrayValue = function(val, options) {
      if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
        return val.split(",");
      }
      return val;
    };
    var isoSentinel = "utf8=%26%2310003%3B";
    var charsetSentinel = "utf8=%E2%9C%93";
    var parseValues = function parseQueryStringValues(str, options) {
      var obj = { __proto__: null };
      var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
      cleanStr = cleanStr.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
      var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
      var parts = cleanStr.split(options.delimiter, limit);
      var skipIndex = -1;
      var i;
      var charset = options.charset;
      if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
          if (parts[i].indexOf("utf8=") === 0) {
            if (parts[i] === charsetSentinel) {
              charset = "utf-8";
            } else if (parts[i] === isoSentinel) {
              charset = "iso-8859-1";
            }
            skipIndex = i;
            i = parts.length;
          }
        }
      }
      for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
          continue;
        }
        var part = parts[i];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key, val;
        if (pos === -1) {
          key = options.decoder(part, defaults.decoder, charset, "key");
          val = options.strictNullHandling ? null : "";
        } else {
          key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
          val = utils.maybeMap(
            parseArrayValue(part.slice(pos + 1), options),
            function(encodedVal) {
              return options.decoder(encodedVal, defaults.decoder, charset, "value");
            }
          );
        }
        if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
          val = interpretNumericEntities(val);
        }
        if (part.indexOf("[]=") > -1) {
          val = isArray2(val) ? [val] : val;
        }
        var existing = has.call(obj, key);
        if (existing && options.duplicates === "combine") {
          obj[key] = utils.combine(obj[key], val);
        } else if (!existing || options.duplicates === "last") {
          obj[key] = val;
        }
      }
      return obj;
    };
    var parseObject = function(chain, val, options, valuesParsed) {
      var leaf = valuesParsed ? val : parseArrayValue(val, options);
      for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];
        if (root === "[]" && options.parseArrays) {
          obj = options.allowEmptyArrays && (leaf === "" || options.strictNullHandling && leaf === null) ? [] : [].concat(leaf);
        } else {
          obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
          var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
          var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, ".") : cleanRoot;
          var index = parseInt(decodedRoot, 10);
          if (!options.parseArrays && decodedRoot === "") {
            obj = { 0: leaf };
          } else if (!isNaN(index) && root !== decodedRoot && String(index) === decodedRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
            obj = [];
            obj[index] = leaf;
          } else if (decodedRoot !== "__proto__") {
            obj[decodedRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    };
    var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
      if (!givenKey) {
        return;
      }
      var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = options.depth > 0 && brackets.exec(key);
      var parent = segment ? key.slice(0, segment.index) : key;
      var keys3 = [];
      if (parent) {
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys3.push(parent);
      }
      var i = 0;
      while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys3.push(segment[1]);
      }
      if (segment) {
        if (options.strictDepth === true) {
          throw new RangeError("Input depth exceeded depth option of " + options.depth + " and strictDepth is true");
        }
        keys3.push("[" + key.slice(segment.index) + "]");
      }
      return parseObject(keys3, val, options, valuesParsed);
    };
    var normalizeParseOptions = function normalizeParseOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
        throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
      }
      if (typeof opts.decodeDotInKeys !== "undefined" && typeof opts.decodeDotInKeys !== "boolean") {
        throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
      }
      if (opts.decoder !== null && typeof opts.decoder !== "undefined" && typeof opts.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
      var duplicates = typeof opts.duplicates === "undefined" ? defaults.duplicates : opts.duplicates;
      if (duplicates !== "combine" && duplicates !== "first" && duplicates !== "last") {
        throw new TypeError("The duplicates option must be either combine, first, or last");
      }
      var allowDots = typeof opts.allowDots === "undefined" ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
      return {
        allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
        decodeDotInKeys: typeof opts.decodeDotInKeys === "boolean" ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
        decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
        duplicates,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
        strictDepth: typeof opts.strictDepth === "boolean" ? !!opts.strictDepth : defaults.strictDepth,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module.exports = function(str, opts) {
      var options = normalizeParseOptions(opts);
      if (str === "" || str === null || typeof str === "undefined") {
        return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      }
      var tempObj = typeof str === "string" ? parseValues(str, options) : str;
      var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var keys3 = Object.keys(tempObj);
      for (var i = 0; i < keys3.length; ++i) {
        var key = keys3[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
        obj = utils.merge(obj, newObj, options);
      }
      if (options.allowSparse === true) {
        return obj;
      }
      return utils.compact(obj);
    };
  }
});

// ../../node_modules/qs/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/qs/lib/index.js"(exports, module) {
    "use strict";
    init_shim();
    var stringify = require_stringify();
    var parse2 = require_parse();
    var formats = require_formats();
    module.exports = {
      formats,
      parse: parse2,
      stringify
    };
  }
});

// ../../node_modules/node-stdlib-browser/cjs/proxy/url.js
var require_url = __commonJS({
  "../../node_modules/node-stdlib-browser/cjs/proxy/url.js"(exports, module) {
    "use strict";
    init_shim();
    Object.defineProperty(exports, "__esModule", { value: true });
    var require$$0 = require_punycode();
    var require$$1 = require_lib();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var require$$0__default = /* @__PURE__ */ _interopDefaultLegacy(require$$0);
    var require$$1__default = /* @__PURE__ */ _interopDefaultLegacy(require$$1);
    var punycode = require$$0__default["default"];
    function Url() {
      this.protocol = null;
      this.slashes = null;
      this.auth = null;
      this.host = null;
      this.port = null;
      this.hostname = null;
      this.hash = null;
      this.search = null;
      this.query = null;
      this.pathname = null;
      this.path = null;
      this.href = null;
    }
    var protocolPattern = /^([a-z0-9.+-]+:)/i;
    var portPattern = /:[0-9]*$/;
    var simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/;
    var delims = [
      "<",
      ">",
      '"',
      "`",
      " ",
      "\r",
      "\n",
      "	"
    ];
    var unwise = [
      "{",
      "}",
      "|",
      "\\",
      "^",
      "`"
    ].concat(delims);
    var autoEscape = ["'"].concat(unwise);
    var nonHostChars = [
      "%",
      "/",
      "?",
      ";",
      "#"
    ].concat(autoEscape);
    var hostEndingChars = [
      "/",
      "?",
      "#"
    ];
    var hostnameMaxLen = 255;
    var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
    var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
    var unsafeProtocol = {
      javascript: true,
      "javascript:": true
    };
    var hostlessProtocol = {
      javascript: true,
      "javascript:": true
    };
    var slashedProtocol = {
      http: true,
      https: true,
      ftp: true,
      gopher: true,
      file: true,
      "http:": true,
      "https:": true,
      "ftp:": true,
      "gopher:": true,
      "file:": true
    };
    var querystring = require$$1__default["default"];
    function urlParse(url, parseQueryString, slashesDenoteHost) {
      if (url && typeof url === "object" && url instanceof Url) {
        return url;
      }
      var u = new Url();
      u.parse(url, parseQueryString, slashesDenoteHost);
      return u;
    }
    Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
      if (typeof url !== "string") {
        throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
      }
      var queryIndex = url.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#", uSplit = url.split(splitter), slashRegex = /\\/g;
      uSplit[0] = uSplit[0].replace(slashRegex, "/");
      url = uSplit.join(splitter);
      var rest = url;
      rest = rest.trim();
      if (!slashesDenoteHost && url.split("#").length === 1) {
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
          this.path = rest;
          this.href = rest;
          this.pathname = simplePath[1];
          if (simplePath[2]) {
            this.search = simplePath[2];
            if (parseQueryString) {
              this.query = querystring.parse(this.search.substr(1));
            } else {
              this.query = this.search.substr(1);
            }
          } else if (parseQueryString) {
            this.search = "";
            this.query = {};
          }
          return this;
        }
      }
      var proto = protocolPattern.exec(rest);
      if (proto) {
        proto = proto[0];
        var lowerProto = proto.toLowerCase();
        this.protocol = lowerProto;
        rest = rest.substr(proto.length);
      }
      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@/]+@[^@/]+/)) {
        var slashes = rest.substr(0, 2) === "//";
        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest = rest.substr(2);
          this.slashes = true;
        }
      }
      if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
        var hostEnd = -1;
        for (var i = 0; i < hostEndingChars.length; i++) {
          var hec = rest.indexOf(hostEndingChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        var auth, atSign;
        if (hostEnd === -1) {
          atSign = rest.lastIndexOf("@");
        } else {
          atSign = rest.lastIndexOf("@", hostEnd);
        }
        if (atSign !== -1) {
          auth = rest.slice(0, atSign);
          rest = rest.slice(atSign + 1);
          this.auth = decodeURIComponent(auth);
        }
        hostEnd = -1;
        for (var i = 0; i < nonHostChars.length; i++) {
          var hec = rest.indexOf(nonHostChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        if (hostEnd === -1) {
          hostEnd = rest.length;
        }
        this.host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);
        this.parseHost();
        this.hostname = this.hostname || "";
        var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./);
          for (var i = 0, l = hostparts.length; i < l; i++) {
            var part = hostparts[i];
            if (!part) {
              continue;
            }
            if (!part.match(hostnamePartPattern)) {
              var newpart = "";
              for (var j = 0, k = part.length; j < k; j++) {
                if (part.charCodeAt(j) > 127) {
                  newpart += "x";
                } else {
                  newpart += part[j];
                }
              }
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i);
                var notHost = hostparts.slice(i + 1);
                var bit = part.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest = "/" + notHost.join(".") + rest;
                }
                this.hostname = validParts.join(".");
                break;
              }
            }
          }
        }
        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = "";
        } else {
          this.hostname = this.hostname.toLowerCase();
        }
        if (!ipv6Hostname) {
          this.hostname = punycode.toASCII(this.hostname);
        }
        var p = this.port ? ":" + this.port : "";
        var h = this.hostname || "";
        this.host = h + p;
        this.href += this.host;
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);
          if (rest[0] !== "/") {
            rest = "/" + rest;
          }
        }
      }
      if (!unsafeProtocol[lowerProto]) {
        for (var i = 0, l = autoEscape.length; i < l; i++) {
          var ae = autoEscape[i];
          if (rest.indexOf(ae) === -1) {
            continue;
          }
          var esc = encodeURIComponent(ae);
          if (esc === ae) {
            esc = escape(ae);
          }
          rest = rest.split(ae).join(esc);
        }
      }
      var hash = rest.indexOf("#");
      if (hash !== -1) {
        this.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
      }
      var qm = rest.indexOf("?");
      if (qm !== -1) {
        this.search = rest.substr(qm);
        this.query = rest.substr(qm + 1);
        if (parseQueryString) {
          this.query = querystring.parse(this.query);
        }
        rest = rest.slice(0, qm);
      } else if (parseQueryString) {
        this.search = "";
        this.query = {};
      }
      if (rest) {
        this.pathname = rest;
      }
      if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
        this.pathname = "/";
      }
      if (this.pathname || this.search) {
        var p = this.pathname || "";
        var s = this.search || "";
        this.path = p + s;
      }
      this.href = this.format();
      return this;
    };
    function urlFormat(obj) {
      if (typeof obj === "string") {
        obj = urlParse(obj);
      }
      if (!(obj instanceof Url)) {
        return Url.prototype.format.call(obj);
      }
      return obj.format();
    }
    Url.prototype.format = function() {
      var auth = this.auth || "";
      if (auth) {
        auth = encodeURIComponent(auth);
        auth = auth.replace(/%3A/i, ":");
        auth += "@";
      }
      var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = false, query = "";
      if (this.host) {
        host = auth + this.host;
      } else if (this.hostname) {
        host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
        if (this.port) {
          host += ":" + this.port;
        }
      }
      if (this.query && typeof this.query === "object" && Object.keys(this.query).length) {
        query = querystring.stringify(this.query, {
          arrayFormat: "repeat",
          addQueryPrefix: false
        });
      }
      var search = this.search || query && "?" + query || "";
      if (protocol && protocol.substr(-1) !== ":") {
        protocol += ":";
      }
      if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
        host = "//" + (host || "");
        if (pathname && pathname.charAt(0) !== "/") {
          pathname = "/" + pathname;
        }
      } else if (!host) {
        host = "";
      }
      if (hash && hash.charAt(0) !== "#") {
        hash = "#" + hash;
      }
      if (search && search.charAt(0) !== "?") {
        search = "?" + search;
      }
      pathname = pathname.replace(/[?#]/g, function(match2) {
        return encodeURIComponent(match2);
      });
      search = search.replace("#", "%23");
      return protocol + host + pathname + search + hash;
    };
    function urlResolve(source, relative2) {
      return urlParse(source, false, true).resolve(relative2);
    }
    Url.prototype.resolve = function(relative2) {
      return this.resolveObject(urlParse(relative2, false, true)).format();
    };
    function urlResolveObject(source, relative2) {
      if (!source) {
        return relative2;
      }
      return urlParse(source, false, true).resolveObject(relative2);
    }
    Url.prototype.resolveObject = function(relative2) {
      if (typeof relative2 === "string") {
        var rel = new Url();
        rel.parse(relative2, false, true);
        relative2 = rel;
      }
      var result = new Url();
      var tkeys = Object.keys(this);
      for (var tk = 0; tk < tkeys.length; tk++) {
        var tkey = tkeys[tk];
        result[tkey] = this[tkey];
      }
      result.hash = relative2.hash;
      if (relative2.href === "") {
        result.href = result.format();
        return result;
      }
      if (relative2.slashes && !relative2.protocol) {
        var rkeys = Object.keys(relative2);
        for (var rk = 0; rk < rkeys.length; rk++) {
          var rkey = rkeys[rk];
          if (rkey !== "protocol") {
            result[rkey] = relative2[rkey];
          }
        }
        if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
          result.pathname = "/";
          result.path = result.pathname;
        }
        result.href = result.format();
        return result;
      }
      if (relative2.protocol && relative2.protocol !== result.protocol) {
        if (!slashedProtocol[relative2.protocol]) {
          var keys3 = Object.keys(relative2);
          for (var v = 0; v < keys3.length; v++) {
            var k = keys3[v];
            result[k] = relative2[k];
          }
          result.href = result.format();
          return result;
        }
        result.protocol = relative2.protocol;
        if (!relative2.host && !hostlessProtocol[relative2.protocol]) {
          var relPath = (relative2.pathname || "").split("/");
          while (relPath.length && !(relative2.host = relPath.shift())) {
          }
          if (!relative2.host) {
            relative2.host = "";
          }
          if (!relative2.hostname) {
            relative2.hostname = "";
          }
          if (relPath[0] !== "") {
            relPath.unshift("");
          }
          if (relPath.length < 2) {
            relPath.unshift("");
          }
          result.pathname = relPath.join("/");
        } else {
          result.pathname = relative2.pathname;
        }
        result.search = relative2.search;
        result.query = relative2.query;
        result.host = relative2.host || "";
        result.auth = relative2.auth;
        result.hostname = relative2.hostname || relative2.host;
        result.port = relative2.port;
        if (result.pathname || result.search) {
          var p = result.pathname || "";
          var s = result.search || "";
          result.path = p + s;
        }
        result.slashes = result.slashes || relative2.slashes;
        result.href = result.format();
        return result;
      }
      var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative2.host || relative2.pathname && relative2.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative2.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative2.pathname && relative2.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
      if (psychotic) {
        result.hostname = "";
        result.port = null;
        if (result.host) {
          if (srcPath[0] === "") {
            srcPath[0] = result.host;
          } else {
            srcPath.unshift(result.host);
          }
        }
        result.host = "";
        if (relative2.protocol) {
          relative2.hostname = null;
          relative2.port = null;
          if (relative2.host) {
            if (relPath[0] === "") {
              relPath[0] = relative2.host;
            } else {
              relPath.unshift(relative2.host);
            }
          }
          relative2.host = null;
        }
        mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
      }
      if (isRelAbs) {
        result.host = relative2.host || relative2.host === "" ? relative2.host : result.host;
        result.hostname = relative2.hostname || relative2.hostname === "" ? relative2.hostname : result.hostname;
        result.search = relative2.search;
        result.query = relative2.query;
        srcPath = relPath;
      } else if (relPath.length) {
        if (!srcPath) {
          srcPath = [];
        }
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative2.search;
        result.query = relative2.query;
      } else if (relative2.search != null) {
        if (psychotic) {
          result.host = srcPath.shift();
          result.hostname = result.host;
          var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
          if (authInHost) {
            result.auth = authInHost.shift();
            result.hostname = authInHost.shift();
            result.host = result.hostname;
          }
        }
        result.search = relative2.search;
        result.query = relative2.query;
        if (result.pathname !== null || result.search !== null) {
          result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
        }
        result.href = result.format();
        return result;
      }
      if (!srcPath.length) {
        result.pathname = null;
        if (result.search) {
          result.path = "/" + result.search;
        } else {
          result.path = null;
        }
        result.href = result.format();
        return result;
      }
      var last = srcPath.slice(-1)[0];
      var hasTrailingSlash = (result.host || relative2.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
      var up = 0;
      for (var i = srcPath.length; i >= 0; i--) {
        last = srcPath[i];
        if (last === ".") {
          srcPath.splice(i, 1);
        } else if (last === "..") {
          srcPath.splice(i, 1);
          up++;
        } else if (up) {
          srcPath.splice(i, 1);
          up--;
        }
      }
      if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
          srcPath.unshift("..");
        }
      }
      if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
        srcPath.unshift("");
      }
      if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
        srcPath.push("");
      }
      var isAbsolute2 = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
      if (psychotic) {
        result.hostname = isAbsolute2 ? "" : srcPath.length ? srcPath.shift() : "";
        result.host = result.hostname;
        var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.hostname = authInHost.shift();
          result.host = result.hostname;
        }
      }
      mustEndAbs = mustEndAbs || result.host && srcPath.length;
      if (mustEndAbs && !isAbsolute2) {
        srcPath.unshift("");
      }
      if (srcPath.length > 0) {
        result.pathname = srcPath.join("/");
      } else {
        result.pathname = null;
        result.path = null;
      }
      if (result.pathname !== null || result.search !== null) {
        result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
      }
      result.auth = relative2.auth || result.auth;
      result.slashes = result.slashes || relative2.slashes;
      result.href = result.format();
      return result;
    };
    Url.prototype.parseHost = function() {
      var host = this.host;
      var port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ":") {
          this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host) {
        this.hostname = host;
      }
    };
    var parse2 = urlParse;
    var resolve$1 = urlResolve;
    var resolveObject = urlResolveObject;
    var format3 = urlFormat;
    var Url_1 = Url;
    function normalizeArray(parts, allowAboveRoot) {
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === ".") {
          parts.splice(i, 1);
        } else if (last === "..") {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up--; up) {
          parts.unshift("..");
        }
      }
      return parts;
    }
    function resolve2() {
      var resolvedPath = "", resolvedAbsolute = false;
      for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = i >= 0 ? arguments[i] : "/";
        if (typeof path !== "string") {
          throw new TypeError("Arguments to path.resolve must be strings");
        } else if (!path) {
          continue;
        }
        resolvedPath = path + "/" + resolvedPath;
        resolvedAbsolute = path.charAt(0) === "/";
      }
      resolvedPath = normalizeArray(filter2(resolvedPath.split("/"), function(p) {
        return !!p;
      }), !resolvedAbsolute).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    }
    function filter2(xs, f) {
      if (xs.filter) return xs.filter(f);
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
      }
      return res;
    }
    var _globalThis2 = (function(Object2) {
      function get() {
        var _global3 = this || self;
        delete Object2.prototype.__magic__;
        return _global3;
      }
      if (typeof globalThis === "object") {
        return globalThis;
      }
      if (this) {
        return get();
      } else {
        Object2.defineProperty(Object2.prototype, "__magic__", {
          configurable: true,
          get
        });
        var _global2 = __magic__;
        return _global2;
      }
    })(Object);
    var formatImport = (
      /** @type {formatImport}*/
      format3
    );
    var parseImport = (
      /** @type {parseImport}*/
      parse2
    );
    var resolveImport = (
      /** @type {resolveImport}*/
      resolve$1
    );
    var UrlImport = (
      /** @type {UrlImport}*/
      Url_1
    );
    var URL2 = _globalThis2.URL;
    var URLSearchParams = _globalThis2.URLSearchParams;
    var percentRegEx2 = /%/g;
    var backslashRegEx2 = /\\/g;
    var newlineRegEx2 = /\n/g;
    var carriageReturnRegEx2 = /\r/g;
    var tabRegEx2 = /\t/g;
    var CHAR_FORWARD_SLASH = 47;
    function isURLInstance(instance) {
      var resolved = (
        /** @type {URL|null} */
        instance != null ? instance : null
      );
      return Boolean(resolved !== null && (resolved == null ? void 0 : resolved.href) && (resolved == null ? void 0 : resolved.origin));
    }
    function getPathFromURLPosix(url) {
      if (url.hostname !== "") {
        throw new TypeError('File URL host must be "localhost" or empty on browser');
      }
      var pathname = url.pathname;
      for (var n = 0; n < pathname.length; n++) {
        if (pathname[n] === "%") {
          var third = pathname.codePointAt(n + 2) | 32;
          if (pathname[n + 1] === "2" && third === 102) {
            throw new TypeError("File URL path must not include encoded / characters");
          }
        }
      }
      return decodeURIComponent(pathname);
    }
    function encodePathChars(filepath) {
      if (filepath.includes("%")) {
        filepath = filepath.replace(percentRegEx2, "%25");
      }
      if (filepath.includes("\\")) {
        filepath = filepath.replace(backslashRegEx2, "%5C");
      }
      if (filepath.includes("\n")) {
        filepath = filepath.replace(newlineRegEx2, "%0A");
      }
      if (filepath.includes("\r")) {
        filepath = filepath.replace(carriageReturnRegEx2, "%0D");
      }
      if (filepath.includes("	")) {
        filepath = filepath.replace(tabRegEx2, "%09");
      }
      return filepath;
    }
    var domainToASCII = (
      /**
       * @type {domainToASCII}
       */
      function domainToASCII2(domain) {
        if (typeof domain === "undefined") {
          throw new TypeError('The "domain" argument must be specified');
        }
        return new URL2("http://" + domain).hostname;
      }
    );
    var domainToUnicode = (
      /**
       * @type {domainToUnicode}
       */
      function domainToUnicode2(domain) {
        if (typeof domain === "undefined") {
          throw new TypeError('The "domain" argument must be specified');
        }
        return new URL2("http://" + domain).hostname;
      }
    );
    var pathToFileURL2 = (
      /**
       * @type {(url: string) => URL}
       */
      function pathToFileURL3(filepath) {
        var outURL = new URL2("file://");
        var resolved = resolve2(filepath);
        var filePathLast = filepath.charCodeAt(filepath.length - 1);
        if (filePathLast === CHAR_FORWARD_SLASH && resolved[resolved.length - 1] !== "/") {
          resolved += "/";
        }
        outURL.pathname = encodePathChars(resolved);
        return outURL;
      }
    );
    var fileURLToPath5 = (
      /**
       * @type {fileURLToPath & ((path: string | URL) => string)}
       */
      function fileURLToPath6(path) {
        if (!isURLInstance(path) && typeof path !== "string") {
          throw new TypeError('The "path" argument must be of type string or an instance of URL. Received type ' + typeof path + " (" + path + ")");
        }
        var resolved = new URL2(path);
        if (resolved.protocol !== "file:") {
          throw new TypeError("The URL must be of scheme file");
        }
        return getPathFromURLPosix(resolved);
      }
    );
    var formatImportWithOverloads = (
      /**
       * @type {(
       *   ((urlObject: URL, options?: URLFormatOptions) => string) &
       *   ((urlObject: UrlObject | string, options?: never) => string)
       * )}
       */
      function formatImportWithOverloads2(urlObject, options) {
        var _options$auth, _options$fragment, _options$search, _options$unicode;
        if (options === void 0) {
          options = {};
        }
        if (!(urlObject instanceof URL2)) {
          return formatImport(urlObject);
        }
        if (typeof options !== "object" || options === null) {
          throw new TypeError('The "options" argument must be of type object.');
        }
        var auth = (_options$auth = options.auth) != null ? _options$auth : true;
        var fragment = (_options$fragment = options.fragment) != null ? _options$fragment : true;
        var search = (_options$search = options.search) != null ? _options$search : true;
        (_options$unicode = options.unicode) != null ? _options$unicode : false;
        var parsed = new URL2(urlObject.toString());
        if (!auth) {
          parsed.username = "";
          parsed.password = "";
        }
        if (!fragment) {
          parsed.hash = "";
        }
        if (!search) {
          parsed.search = "";
        }
        return parsed.toString();
      }
    );
    var api = {
      format: formatImportWithOverloads,
      parse: parseImport,
      resolve: resolveImport,
      resolveObject,
      Url: UrlImport,
      URL: URL2,
      URLSearchParams,
      domainToASCII,
      domainToUnicode,
      pathToFileURL: pathToFileURL2,
      fileURLToPath: fileURLToPath5
    };
    exports.URL = URL2;
    exports.URLSearchParams = URLSearchParams;
    exports.Url = UrlImport;
    exports["default"] = api;
    exports.domainToASCII = domainToASCII;
    exports.domainToUnicode = domainToUnicode;
    exports.fileURLToPath = fileURLToPath5;
    exports.format = formatImportWithOverloads;
    exports.parse = parseImport;
    exports.pathToFileURL = pathToFileURL2;
    exports.resolve = resolveImport;
    exports.resolveObject = resolveObject;
    exports = module.exports = api;
  }
});

// ../../node_modules/events/events.js
var require_events = __commonJS({
  "../../node_modules/events/events.js"(exports, module) {
    "use strict";
    init_shim();
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn) console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter2() {
      EventEmitter2.init.call(this);
    }
    module.exports = EventEmitter2;
    module.exports.once = once;
    EventEmitter2.EventEmitter = EventEmitter2;
    EventEmitter2.prototype._events = void 0;
    EventEmitter2.prototype._eventsCount = 0;
    EventEmitter2.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter2, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter2.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter2.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter2.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter2.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter2.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter2.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter2.prototype.on = EventEmitter2.prototype.addListener;
    EventEmitter2.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter2.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter2.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter2.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys3 = Object.keys(events);
        var key;
        for (i = 0; i < keys3.length; ++i) {
          key = keys3[i];
          if (key === "removeListener") continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    };
    function _listeners2(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter2.prototype.listeners = function listeners(type) {
      return _listeners2(this, type, true);
    };
    EventEmitter2.prototype.rawListeners = function rawListeners(type) {
      return _listeners2(this, type, false);
    };
    EventEmitter2.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter2.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function(resolve2, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve2([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/stream-browser.js
var require_stream_browser = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
    init_shim();
    module.exports = require_events().EventEmitter;
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
    "use strict";
    init_shim();
    function ownKeys(object, enumerableOnly) {
      var keys3 = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys3.push.apply(keys3, symbols);
      }
      return keys3;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = require_buffer();
    var Buffer4 = _require.Buffer;
    var _require2 = require_util();
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer4.prototype.copy.call(src, target, offset);
    }
    module.exports = /* @__PURE__ */ (function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0) this.tail.next = entry;
          else this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0) this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0) return;
          var ret = this.head.data;
          if (this.length === 1) this.head = this.tail = null;
          else this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join2(s) {
          if (this.length === 0) return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next) ret += s + p.data;
          return ret;
        }
      }, {
        key: "concat",
        value: function concat2(n) {
          if (this.length === 0) return Buffer4.alloc(0);
          var ret = Buffer4.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret;
          if (n < this.head.data.length) {
            ret = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first2() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret = p.data;
          n -= ret.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length) ret += str;
            else ret += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next) this.head = p.next;
                else this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret = Buffer4.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret, ret.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next) this.head = p.next;
                else this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_, options) {
          return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    })();
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
    "use strict";
    init_shim();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process_browser_default.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process_browser_default.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process_browser_default.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process_browser_default.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process_browser_default.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process_browser_default.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process_browser_default.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose) return;
      if (self2._readableState && !self2._readableState.emitClose) return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
      else stream.emit("error", err);
    }
    module.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// ../../node_modules/readable-stream/errors-browser.js
var require_errors_browser = __commonJS({
  "../../node_modules/readable-stream/errors-browser.js"(exports, module) {
    "use strict";
    init_shim();
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var codes2 = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      var NodeError = /* @__PURE__ */ (function(_Base) {
        _inheritsLoose(NodeError2, _Base);
        function NodeError2(arg1, arg2, arg3) {
          return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
        }
        return NodeError2;
      })(Base);
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes2[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i) {
          return String(i);
        });
        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      var determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      var msg;
      if (endsWith(name, " argument")) {
        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      } else {
        var type = includes(name, ".") ? "property" : "argument";
        msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      }
      msg += ". Received type ".concat(typeof actual);
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module.exports.codes = codes2;
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
    "use strict";
    init_shim();
    var ERR_INVALID_OPT_VALUE = require_errors_browser().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module.exports = {
      getHighWaterMark
    };
  }
});

// ../../node_modules/util-deprecate/browser.js
var require_browser = __commonJS({
  "../../node_modules/util-deprecate/browser.js"(exports, module) {
    init_shim();
    module.exports = deprecate;
    function deprecate(fn, msg) {
      if (config("noDeprecation")) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (config("throwDeprecation")) {
            throw new Error(msg);
          } else if (config("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    }
    function config(name) {
      try {
        if (!_global.localStorage) return false;
      } catch (_) {
        return false;
      }
      var val = _global.localStorage[name];
      if (null == val) return false;
      return String(val).toLowerCase() === "true";
    }
  }
});

// ../../node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "../../node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_browser()
    };
    var Stream3 = require_stream_browser();
    var Buffer4 = require_buffer().Buffer;
    var OurUint8Array = (typeof _global !== "undefined" ? _global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer4.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer4.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits_browser()(Writable, Stream3);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object)) return true;
          if (this !== Writable) return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
      }
      Stream3.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process_browser_default.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process_browser_default.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer4.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf) encoding = "buffer";
      else if (!encoding) encoding = state.defaultEncoding;
      if (typeof cb !== "function") cb = nop;
      if (state.ending) writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string") encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer4.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret) state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev) stream._writev(chunk, state.onwrite);
      else stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process_browser_default.nextTick(cb, er);
        process_browser_default.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er) onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process_browser_default.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished) onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count2 = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count2] = entry;
          if (!entry.isBuf) allBuffers = false;
          entry = entry.next;
          count2 += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null) state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending) endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process_browser_default.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished) process_browser_default.nextTick(cb);
        else stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// ../../node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "../../node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
    "use strict";
    init_shim();
    var objectKeys = Object.keys || function(obj) {
      var keys4 = [];
      for (var key in obj) keys4.push(key);
      return keys4;
    };
    module.exports = Duplex;
    var Readable2 = require_stream_readable();
    var Writable = require_stream_writable();
    require_inherits_browser()(Duplex, Readable2);
    {
      keys3 = objectKeys(Writable.prototype);
      for (v = 0; v < keys3.length; v++) {
        method = keys3[v];
        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys3;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex)) return new Duplex(options);
      Readable2.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false) this.readable = false;
        if (options.writable === false) this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended) return;
      process_browser_default.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// ../../node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "../../node_modules/safe-buffer/index.js"(exports, module) {
    init_shim();
    var buffer = require_buffer();
    var Buffer4 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer4.from && Buffer4.alloc && Buffer4.allocUnsafe && Buffer4.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer4(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer4.prototype);
    copyProps(Buffer4, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer4(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer4(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer4(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// ../../node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "../../node_modules/string_decoder/lib/string_decoder.js"(exports) {
    "use strict";
    init_shim();
    var Buffer4 = require_safe_buffer().Buffer;
    var isEncoding = Buffer4.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc) return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried) return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer4.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer4.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0) return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127) return 0;
      else if (byte >> 5 === 6) return 2;
      else if (byte >> 4 === 14) return 3;
      else if (byte >> 3 === 30) return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i) return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2) nb = 0;
          else self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0) return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed) return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0) return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
    "use strict";
    init_shim();
    var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called) return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function") return eos(stream, null, opts);
      if (!opts) opts = {};
      callback = once(callback || noop);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable) onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable) callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable) callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req) onrequest();
        else stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false) stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module.exports = eos;
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
    "use strict";
    init_shim();
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished = require_end_of_stream();
    var kLastResolve = /* @__PURE__ */ Symbol("lastResolve");
    var kLastReject = /* @__PURE__ */ Symbol("lastReject");
    var kError = /* @__PURE__ */ Symbol("error");
    var kEnded = /* @__PURE__ */ Symbol("ended");
    var kLastPromise = /* @__PURE__ */ Symbol("lastPromise");
    var kHandlePromise = /* @__PURE__ */ Symbol("handlePromise");
    var kStream = /* @__PURE__ */ Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve2 = iter[kLastResolve];
      if (resolve2 !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve2(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process_browser_default.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve2, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve2(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve2, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve2, reject) {
            process_browser_default.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve2(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve2, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve2(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve2, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve2(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve2;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve2 = iterator[kLastResolve];
        if (resolve2 !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve2(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module.exports = createReadableStreamAsyncIterator;
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/from-browser.js
var require_from_browser = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module) {
    init_shim();
    module.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  }
});

// ../../node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "../../node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = Readable2;
    var Duplex;
    Readable2.ReadableState = ReadableState;
    var EE = require_events().EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream3 = require_stream_browser();
    var Buffer4 = require_buffer().Buffer;
    var OurUint8Array = (typeof _global !== "undefined" ? _global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer4.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer4.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require_util();
    var debug2;
    if (debugUtil && debugUtil.debuglog) {
      debug2 = debugUtil.debuglog("stream");
    } else {
      debug2 = function debug3() {
      };
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits_browser()(Readable2, Stream3);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
      else emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable2(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable2)) return new Readable2(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
      }
      Stream3.call(this);
    }
    Object.defineProperty(Readable2.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable2.prototype.destroy = destroyImpl.destroy;
    Readable2.prototype._undestroy = destroyImpl.undestroy;
    Readable2.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable2.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer4.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable2.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug2("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck) er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer4.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
              else maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if (state.needReadable) emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable2.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable2.prototype.setEncoding = function(enc) {
      if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "") this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended) return 0;
      if (state.objectMode) return 1;
      if (n !== n) {
        if (state.flowing && state.length) return state.buffer.head.data.length;
        else return state.length;
      }
      if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length) return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable2.prototype.read = function(n) {
      debug2("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0) state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug2("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug2("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug2("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug2("reading or ended", doRead);
      } else if (doRead) {
        debug2("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0) state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading) n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0) ret = fromList(n, state);
      else ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended) state.needReadable = true;
        if (nOrig !== n && state.ended) endReadable(this);
      }
      if (ret !== null) this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug2("onEofChunk");
      if (state.ended) return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug2("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug2("emitReadable", state.flowing);
        state.emittedReadable = true;
        process_browser_default.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug2("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process_browser_default.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug2("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable2.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable2.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug2("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process_browser_default.stdout && dest !== process_browser_default.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted) process_browser_default.nextTick(endFn);
      else src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug2("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug2("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug2("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug2("ondata");
        var ret = dest.write(chunk);
        debug2("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug2("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug2("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug2("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug2("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug2("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug2("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable2.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0) return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) dests[i].emit("unpipe", this, {
          hasUnpiped: false
        });
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1) return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1) state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable2.prototype.on = function(ev, fn) {
      var res = Stream3.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false) this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug2("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process_browser_default.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable2.prototype.addListener = Readable2.prototype.on;
    Readable2.prototype.removeListener = function(ev, fn) {
      var res = Stream3.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process_browser_default.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable2.prototype.removeAllListeners = function(ev) {
      var res = Stream3.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process_browser_default.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug2("readable nexttick read 0");
      self2.read(0);
    }
    Readable2.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug2("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process_browser_default.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug2("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading) stream.read(0);
    }
    Readable2.prototype.pause = function() {
      debug2("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug2("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug2("flow", state.flowing);
      while (state.flowing && stream.read() !== null) ;
    }
    Readable2.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug2("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug2("wrapped data");
        if (state.decoder) chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0)) return;
        else if (!state.objectMode && (!chunk || !chunk.length)) return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = /* @__PURE__ */ (function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          })(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug2("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable2.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable2.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable2.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable2._fromList = fromList;
    Object.defineProperty(Readable2.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0) return null;
      var ret;
      if (state.objectMode) ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.first();
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug2("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process_browser_default.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug2("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable2.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from_browser();
        }
        return from(Readable2, iterable, opts);
      };
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
      }
      return -1;
    }
  }
});

// ../../node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "../../node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = Transform;
    var _require$codes = require_errors_browser().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex();
    require_inherits_browser()(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform)) return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er) return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// ../../node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "../../node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = PassThrough2;
    var Transform = require_stream_transform();
    require_inherits_browser()(PassThrough2, Transform);
    function PassThrough2(options) {
      if (!(this instanceof PassThrough2)) return new PassThrough2(options);
      Transform.call(this, options);
    }
    PassThrough2.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// ../../node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "../../node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
    "use strict";
    init_shim();
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called) return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors_browser().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop(err) {
      if (err) throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0) eos = require_end_of_stream();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err) return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed) return;
        if (destroyed) return;
        destroyed = true;
        if (isRequest(stream)) return stream.abort();
        if (typeof stream.destroy === "function") return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe2(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length) return noop;
      if (typeof streams[streams.length - 1] !== "function") return noop;
      return streams.pop();
    }
    function pipeline3() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0])) streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error) error = err;
          if (err) destroys.forEach(call);
          if (reading) return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe2);
    }
    module.exports = pipeline3;
  }
});

// ../../node_modules/stream-browserify/index.js
var require_stream_browserify = __commonJS({
  "../../node_modules/stream-browserify/index.js"(exports, module) {
    init_shim();
    module.exports = Stream3;
    var EE = require_events().EventEmitter;
    var inherits = require_inherits_browser();
    inherits(Stream3, EE);
    Stream3.Readable = require_stream_readable();
    Stream3.Writable = require_stream_writable();
    Stream3.Duplex = require_stream_duplex();
    Stream3.Transform = require_stream_transform();
    Stream3.PassThrough = require_stream_passthrough();
    Stream3.finished = require_end_of_stream();
    Stream3.pipeline = require_pipeline();
    Stream3.Stream = Stream3;
    function Stream3() {
      EE.call(this);
    }
    Stream3.prototype.pipe = function(dest, options) {
      var source = this;
      function ondata(chunk) {
        if (dest.writable) {
          if (false === dest.write(chunk) && source.pause) {
            source.pause();
          }
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
      }
      var didOnEnd = false;
      function onend() {
        if (didOnEnd) return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd) return;
        didOnEnd = true;
        if (typeof dest.destroy === "function") dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, "error") === 0) {
          throw er;
        }
      }
      source.on("error", onerror);
      dest.on("error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
  }
});

// ../../node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "../../node_modules/pako/lib/zlib/zstream.js"(exports, module) {
    "use strict";
    init_shim();
    function ZStream() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    module.exports = ZStream;
  }
});

// ../../node_modules/pako/lib/utils/common.js
var require_common = __commonJS({
  "../../node_modules/pako/lib/utils/common.js"(exports) {
    "use strict";
    init_shim();
    var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
    function _has2(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    exports.assign = function(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (var p in source) {
          if (_has2(source, p)) {
            obj[p] = source[p];
          }
        }
      }
      return obj;
    };
    exports.shrinkBuf = function(buf, size) {
      if (buf.length === size) {
        return buf;
      }
      if (buf.subarray) {
        return buf.subarray(0, size);
      }
      buf.length = size;
      return buf;
    };
    var fnTyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        if (src.subarray && dest.subarray) {
          dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
          return;
        }
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src[src_offs + i];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        var i, l, len, pos, chunk, result;
        len = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          len += chunks[i].length;
        }
        result = new Uint8Array(len);
        pos = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          chunk = chunks[i];
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      }
    };
    var fnUntyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src[src_offs + i];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        return [].concat.apply([], chunks);
      }
    };
    exports.setTyped = function(on) {
      if (on) {
        exports.Buf8 = Uint8Array;
        exports.Buf16 = Uint16Array;
        exports.Buf32 = Int32Array;
        exports.assign(exports, fnTyped);
      } else {
        exports.Buf8 = Array;
        exports.Buf16 = Array;
        exports.Buf32 = Array;
        exports.assign(exports, fnUntyped);
      }
    };
    exports.setTyped(TYPED_OK);
  }
});

// ../../node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "../../node_modules/pako/lib/zlib/trees.js"(exports) {
    "use strict";
    init_shim();
    var utils = require_common();
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = (
      /* extra bits for each length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
    );
    var extra_dbits = (
      /* extra bits for each distance code */
      [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
    );
    var extra_blbits = (
      /* extra bits for each bit length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
    );
    var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    function d_code(dist) {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    }
    function put_short(s, w) {
      s.pending_buf[s.pending++] = w & 255;
      s.pending_buf[s.pending++] = w >>> 8 & 255;
    }
    function send_bits(s, value, length) {
      if (s.bi_valid > Buf_size - length) {
        s.bi_buf |= value << s.bi_valid & 65535;
        put_short(s, s.bi_buf);
        s.bi_buf = value >> Buf_size - s.bi_valid;
        s.bi_valid += length - Buf_size;
      } else {
        s.bi_buf |= value << s.bi_valid & 65535;
        s.bi_valid += length;
      }
    }
    function send_code(s, c, tree) {
      send_bits(
        s,
        tree[c * 2],
        tree[c * 2 + 1]
        /*.Len*/
      );
    }
    function bi_reverse(code, len) {
      var res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    }
    function bi_flush(s) {
      if (s.bi_valid === 16) {
        put_short(s, s.bi_buf);
        s.bi_buf = 0;
        s.bi_valid = 0;
      } else if (s.bi_valid >= 8) {
        s.pending_buf[s.pending++] = s.bi_buf & 255;
        s.bi_buf >>= 8;
        s.bi_valid -= 8;
      }
    }
    function gen_bitlen(s, desc) {
      var tree = desc.dyn_tree;
      var max_code = desc.max_code;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var extra = desc.stat_desc.extra_bits;
      var base = desc.stat_desc.extra_base;
      var max_length = desc.stat_desc.max_length;
      var h;
      var n, m;
      var bits;
      var xbits;
      var f;
      var overflow = 0;
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s.bl_count[bits] = 0;
      }
      tree[s.heap[s.heap_max] * 2 + 1] = 0;
      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
        n = s.heap[h];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n * 2 + 1] = bits;
        if (n > max_code) {
          continue;
        }
        s.bl_count[bits]++;
        xbits = 0;
        if (n >= base) {
          xbits = extra[n - base];
        }
        f = tree[n * 2];
        s.opt_len += f * (bits + xbits);
        if (has_stree) {
          s.static_len += f * (stree[n * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s.bl_count[bits] === 0) {
          bits--;
        }
        s.bl_count[bits]--;
        s.bl_count[bits + 1] += 2;
        s.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n = s.bl_count[bits];
        while (n !== 0) {
          m = s.heap[--h];
          if (m > max_code) {
            continue;
          }
          if (tree[m * 2 + 1] !== bits) {
            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
            tree[m * 2 + 1] = bits;
          }
          n--;
        }
      }
    }
    function gen_codes(tree, max_code, bl_count) {
      var next_code = new Array(MAX_BITS + 1);
      var code = 0;
      var bits;
      var n;
      for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = code + bl_count[bits - 1] << 1;
      }
      for (n = 0; n <= max_code; n++) {
        var len = tree[n * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n * 2] = bi_reverse(next_code[len]++, len);
      }
    }
    function tr_static_init() {
      var n;
      var bits;
      var length;
      var code;
      var dist;
      var bl_count = new Array(MAX_BITS + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length;
        for (n = 0; n < 1 << extra_lbits[code]; n++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < 1 << extra_dbits[code]; n++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n = 0; n < D_CODES; n++) {
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    }
    function init_block(s) {
      var n;
      for (n = 0; n < L_CODES; n++) {
        s.dyn_ltree[n * 2] = 0;
      }
      for (n = 0; n < D_CODES; n++) {
        s.dyn_dtree[n * 2] = 0;
      }
      for (n = 0; n < BL_CODES; n++) {
        s.bl_tree[n * 2] = 0;
      }
      s.dyn_ltree[END_BLOCK * 2] = 1;
      s.opt_len = s.static_len = 0;
      s.last_lit = s.matches = 0;
    }
    function bi_windup(s) {
      if (s.bi_valid > 8) {
        put_short(s, s.bi_buf);
      } else if (s.bi_valid > 0) {
        s.pending_buf[s.pending++] = s.bi_buf;
      }
      s.bi_buf = 0;
      s.bi_valid = 0;
    }
    function copy_block(s, buf, len, header) {
      bi_windup(s);
      if (header) {
        put_short(s, len);
        put_short(s, ~len);
      }
      utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
      s.pending += len;
    }
    function smaller(tree, n, m, depth) {
      var _n2 = n * 2;
      var _m2 = m * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
    }
    function pqdownheap(s, tree, k) {
      var v = s.heap[k];
      var j = k << 1;
      while (j <= s.heap_len) {
        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
          j++;
        }
        if (smaller(tree, v, s.heap[j], s.depth)) {
          break;
        }
        s.heap[k] = s.heap[j];
        k = j;
        j <<= 1;
      }
      s.heap[k] = v;
    }
    function compress_block(s, ltree, dtree) {
      var dist;
      var lc;
      var lx = 0;
      var code;
      var extra;
      if (s.last_lit !== 0) {
        do {
          dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
          lc = s.pending_buf[s.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code(s, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s, code + LITERALS + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s, dist, extra);
            }
          }
        } while (lx < s.last_lit);
      }
      send_code(s, END_BLOCK, ltree);
    }
    function build_tree(s, desc) {
      var tree = desc.dyn_tree;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var elems = desc.stat_desc.elems;
      var n, m;
      var max_code = -1;
      var node;
      s.heap_len = 0;
      s.heap_max = HEAP_SIZE;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== 0) {
          s.heap[++s.heap_len] = max_code = n;
          s.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = 0;
        }
      }
      while (s.heap_len < 2) {
        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s.depth[node] = 0;
        s.opt_len--;
        if (has_stree) {
          s.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n = s.heap_len >> 1; n >= 1; n--) {
        pqdownheap(s, tree, n);
      }
      node = elems;
      do {
        n = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[
          1
          /*SMALLEST*/
        ] = s.heap[s.heap_len--];
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
        m = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[--s.heap_max] = n;
        s.heap[--s.heap_max] = m;
        tree[node * 2] = tree[n * 2] + tree[m * 2];
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
        tree[n * 2 + 1] = tree[m * 2 + 1] = node;
        s.heap[
          1
          /*SMALLEST*/
        ] = node++;
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
      } while (s.heap_len >= 2);
      s.heap[--s.heap_max] = s.heap[
        1
        /*SMALLEST*/
      ];
      gen_bitlen(s, desc);
      gen_codes(tree, max_code, s.bl_count);
    }
    function scan_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count2 = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count2 < max_count && curlen === nextlen) {
          continue;
        } else if (count2 < min_count) {
          s.bl_tree[curlen * 2] += count2;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s.bl_tree[curlen * 2]++;
          }
          s.bl_tree[REP_3_6 * 2]++;
        } else if (count2 <= 10) {
          s.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s.bl_tree[REPZ_11_138 * 2]++;
        }
        count2 = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function send_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count2 = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count2 < max_count && curlen === nextlen) {
          continue;
        } else if (count2 < min_count) {
          do {
            send_code(s, curlen, s.bl_tree);
          } while (--count2 !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s, curlen, s.bl_tree);
            count2--;
          }
          send_code(s, REP_3_6, s.bl_tree);
          send_bits(s, count2 - 3, 2);
        } else if (count2 <= 10) {
          send_code(s, REPZ_3_10, s.bl_tree);
          send_bits(s, count2 - 3, 3);
        } else {
          send_code(s, REPZ_11_138, s.bl_tree);
          send_bits(s, count2 - 11, 7);
        }
        count2 = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function build_bl_tree(s) {
      var max_blindex;
      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
      build_tree(s, s.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    }
    function send_all_trees(s, lcodes, dcodes, blcodes) {
      var rank;
      send_bits(s, lcodes - 257, 5);
      send_bits(s, dcodes - 1, 5);
      send_bits(s, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s, s.dyn_ltree, lcodes - 1);
      send_tree(s, s.dyn_dtree, dcodes - 1);
    }
    function detect_data_type(s) {
      var black_mask = 4093624447;
      var n;
      for (n = 0; n <= 31; n++, black_mask >>>= 1) {
        if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS; n++) {
        if (s.dyn_ltree[n * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    }
    var static_init_done = false;
    function _tr_init(s) {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
      s.bi_buf = 0;
      s.bi_valid = 0;
      init_block(s);
    }
    function _tr_stored_block(s, buf, stored_len, last) {
      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      copy_block(s, buf, stored_len, true);
    }
    function _tr_align(s) {
      send_bits(s, STATIC_TREES << 1, 3);
      send_code(s, END_BLOCK, static_ltree);
      bi_flush(s);
    }
    function _tr_flush_block(s, buf, stored_len, last) {
      var opt_lenb, static_lenb;
      var max_blindex = 0;
      if (s.level > 0) {
        if (s.strm.data_type === Z_UNKNOWN) {
          s.strm.data_type = detect_data_type(s);
        }
        build_tree(s, s.l_desc);
        build_tree(s, s.d_desc);
        max_blindex = build_bl_tree(s);
        opt_lenb = s.opt_len + 3 + 7 >>> 3;
        static_lenb = s.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block(s, buf, stored_len, last);
      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s, static_ltree, static_dtree);
      } else {
        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
      }
      init_block(s);
      if (last) {
        bi_windup(s);
      }
    }
    function _tr_tally(s, dist, lc) {
      s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
      s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
      s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
      s.last_lit++;
      if (dist === 0) {
        s.dyn_ltree[lc * 2]++;
      } else {
        s.matches++;
        dist--;
        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s.dyn_dtree[d_code(dist) * 2]++;
      }
      return s.last_lit === s.lit_bufsize - 1;
    }
    exports._tr_init = _tr_init;
    exports._tr_stored_block = _tr_stored_block;
    exports._tr_flush_block = _tr_flush_block;
    exports._tr_tally = _tr_tally;
    exports._tr_align = _tr_align;
  }
});

// ../../node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "../../node_modules/pako/lib/zlib/adler32.js"(exports, module) {
    "use strict";
    init_shim();
    function adler32(adler, buf, len, pos) {
      var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
      while (len !== 0) {
        n = len > 2e3 ? 2e3 : len;
        len -= n;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    }
    module.exports = adler32;
  }
});

// ../../node_modules/pako/lib/zlib/crc32.js
var require_crc32 = __commonJS({
  "../../node_modules/pako/lib/zlib/crc32.js"(exports, module) {
    "use strict";
    init_shim();
    function makeTable() {
      var c, table = [];
      for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
      }
      return table;
    }
    var crcTable = makeTable();
    function crc32(crc, buf, len, pos) {
      var t = crcTable, end = pos + len;
      crc ^= -1;
      for (var i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
      }
      return crc ^ -1;
    }
    module.exports = crc32;
  }
});

// ../../node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS({
  "../../node_modules/pako/lib/zlib/messages.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version"
      /* Z_VERSION_ERROR (-6) */
    };
  }
});

// ../../node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "../../node_modules/pako/lib/zlib/deflate.js"(exports) {
    "use strict";
    init_shim();
    var utils = require_common();
    var trees = require_trees();
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var msg = require_messages();
    var Z_NO_FLUSH = 0;
    var Z_PARTIAL_FLUSH = 1;
    var Z_FULL_FLUSH = 3;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_BUF_ERROR = -5;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_FILTERED = 1;
    var Z_HUFFMAN_ONLY = 2;
    var Z_RLE = 3;
    var Z_FIXED = 4;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_UNKNOWN = 2;
    var Z_DEFLATED = 8;
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    var PRESET_DICT = 32;
    var INIT_STATE = 42;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 3;
    function err(strm, errorCode) {
      strm.msg = msg[errorCode];
      return errorCode;
    }
    function rank(f) {
      return (f << 1) - (f > 4 ? 9 : 0);
    }
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    function flush_pending(strm) {
      var s = strm.state;
      var len = s.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
      strm.next_out += len;
      s.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s.pending -= len;
      if (s.pending === 0) {
        s.pending_out = 0;
      }
    }
    function flush_block_only(s, last) {
      trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
      s.block_start = s.strstart;
      flush_pending(s.strm);
    }
    function put_byte(s, b) {
      s.pending_buf[s.pending++] = b;
    }
    function putShortMSB(s, b) {
      s.pending_buf[s.pending++] = b >>> 8 & 255;
      s.pending_buf[s.pending++] = b & 255;
    }
    function read_buf(strm, buf, start, size) {
      var len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      utils.arraySet(buf, strm.input, strm.next_in, len, start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    }
    function longest_match(s, cur_match) {
      var chain_length = s.max_chain_length;
      var scan2 = s.strstart;
      var match2;
      var len;
      var best_len = s.prev_length;
      var nice_match = s.nice_match;
      var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
      var _win = s.window;
      var wmask = s.w_mask;
      var prev = s.prev;
      var strend = s.strstart + MAX_MATCH;
      var scan_end1 = _win[scan2 + best_len - 1];
      var scan_end = _win[scan2 + best_len];
      if (s.prev_length >= s.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s.lookahead) {
        nice_match = s.lookahead;
      }
      do {
        match2 = cur_match;
        if (_win[match2 + best_len] !== scan_end || _win[match2 + best_len - 1] !== scan_end1 || _win[match2] !== _win[scan2] || _win[++match2] !== _win[scan2 + 1]) {
          continue;
        }
        scan2 += 2;
        match2++;
        do {
        } while (_win[++scan2] === _win[++match2] && _win[++scan2] === _win[++match2] && _win[++scan2] === _win[++match2] && _win[++scan2] === _win[++match2] && _win[++scan2] === _win[++match2] && _win[++scan2] === _win[++match2] && _win[++scan2] === _win[++match2] && _win[++scan2] === _win[++match2] && scan2 < strend);
        len = MAX_MATCH - (strend - scan2);
        scan2 = strend - MAX_MATCH;
        if (len > best_len) {
          s.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan2 + best_len - 1];
          scan_end = _win[scan2 + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s.lookahead) {
        return best_len;
      }
      return s.lookahead;
    }
    function fill_window(s) {
      var _w_size = s.w_size;
      var p, n, m, more, str;
      do {
        more = s.window_size - s.lookahead - s.strstart;
        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
          s.match_start -= _w_size;
          s.strstart -= _w_size;
          s.block_start -= _w_size;
          n = s.hash_size;
          p = n;
          do {
            m = s.head[--p];
            s.head[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          n = _w_size;
          p = n;
          do {
            m = s.prev[--p];
            s.prev[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          more += _w_size;
        }
        if (s.strm.avail_in === 0) {
          break;
        }
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;
        if (s.lookahead + s.insert >= MIN_MATCH) {
          str = s.strstart - s.insert;
          s.ins_h = s.window[str];
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
          while (s.insert) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
            s.insert--;
            if (s.lookahead + s.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
    }
    function deflate_stored(s, flush) {
      var max_block_size = 65535;
      if (max_block_size > s.pending_buf_size - 5) {
        max_block_size = s.pending_buf_size - 5;
      }
      for (; ; ) {
        if (s.lookahead <= 1) {
          fill_window(s);
          if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.strstart += s.lookahead;
        s.lookahead = 0;
        var max_start = s.block_start + max_block_size;
        if (s.strstart === 0 || s.strstart >= max_start) {
          s.lookahead = s.strstart - max_start;
          s.strstart = max_start;
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.strstart > s.block_start) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_NEED_MORE;
    }
    function deflate_fast(s, flush) {
      var hash_head;
      var bflush;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
            s.match_length--;
            do {
              s.strstart++;
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            } while (--s.match_length !== 0);
            s.strstart++;
          } else {
            s.strstart += s.match_length;
            s.match_length = 0;
            s.ins_h = s.window[s.strstart];
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
          }
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_slow(s, flush) {
      var hash_head;
      var bflush;
      var max_insert;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
          if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
            s.match_length = MIN_MATCH - 1;
          }
        }
        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
          max_insert = s.strstart + s.lookahead - MIN_MATCH;
          bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
          s.lookahead -= s.prev_length - 1;
          s.prev_length -= 2;
          do {
            if (++s.strstart <= max_insert) {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
          } while (--s.prev_length !== 0);
          s.match_available = 0;
          s.match_length = MIN_MATCH - 1;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s.match_available) {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
          if (bflush) {
            flush_block_only(s, false);
          }
          s.strstart++;
          s.lookahead--;
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s.match_available = 1;
          s.strstart++;
          s.lookahead--;
        }
      }
      if (s.match_available) {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        s.match_available = 0;
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_rle(s, flush) {
      var bflush;
      var prev;
      var scan2, strend;
      var _win = s.window;
      for (; ; ) {
        if (s.lookahead <= MAX_MATCH) {
          fill_window(s);
          if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.match_length = 0;
        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
          scan2 = s.strstart - 1;
          prev = _win[scan2];
          if (prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2]) {
            strend = s.strstart + MAX_MATCH;
            do {
            } while (prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2] && prev === _win[++scan2] && scan2 < strend);
            s.match_length = MAX_MATCH - (strend - scan2);
            if (s.match_length > s.lookahead) {
              s.match_length = s.lookahead;
            }
          }
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          s.strstart += s.match_length;
          s.match_length = 0;
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_huff(s, flush) {
      var bflush;
      for (; ; ) {
        if (s.lookahead === 0) {
          fill_window(s);
          if (s.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s.match_length = 0;
        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table;
    configuration_table = [
      /*      good lazy nice chain */
      new Config(0, 0, 0, 0, deflate_stored),
      /* 0 store only */
      new Config(4, 4, 8, 4, deflate_fast),
      /* 1 max speed, no lazy matches */
      new Config(4, 5, 16, 8, deflate_fast),
      /* 2 */
      new Config(4, 6, 32, 32, deflate_fast),
      /* 3 */
      new Config(4, 4, 16, 16, deflate_slow),
      /* 4 lazy matches */
      new Config(8, 16, 32, 32, deflate_slow),
      /* 5 */
      new Config(8, 16, 128, 128, deflate_slow),
      /* 6 */
      new Config(8, 32, 128, 256, deflate_slow),
      /* 7 */
      new Config(32, 128, 258, 1024, deflate_slow),
      /* 8 */
      new Config(32, 258, 258, 4096, deflate_slow)
      /* 9 max compression */
    ];
    function lm_init(s) {
      s.window_size = 2 * s.w_size;
      zero(s.head);
      s.max_lazy_match = configuration_table[s.level].max_lazy;
      s.good_match = configuration_table[s.level].good_length;
      s.nice_match = configuration_table[s.level].nice_length;
      s.max_chain_length = configuration_table[s.level].max_chain;
      s.strstart = 0;
      s.block_start = 0;
      s.lookahead = 0;
      s.insert = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      s.ins_h = 0;
    }
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
      this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
      this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new utils.Buf16(MAX_BITS + 1);
      this.heap = new utils.Buf16(2 * L_CODES + 1);
      zero(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new utils.Buf16(2 * L_CODES + 1);
      zero(this.depth);
      this.l_buf = 0;
      this.lit_bufsize = 0;
      this.last_lit = 0;
      this.d_buf = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    function deflateResetKeep(strm) {
      var s;
      if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      s = strm.state;
      s.pending = 0;
      s.pending_out = 0;
      if (s.wrap < 0) {
        s.wrap = -s.wrap;
      }
      s.status = s.wrap ? INIT_STATE : BUSY_STATE;
      strm.adler = s.wrap === 2 ? 0 : 1;
      s.last_flush = Z_NO_FLUSH;
      trees._tr_init(s);
      return Z_OK;
    }
    function deflateReset(strm) {
      var ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    }
    function deflateSetHeader(strm, head) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    }
    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      var wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      var s = new DeflateState();
      strm.state = s;
      s.strm = strm;
      s.wrap = wrap;
      s.gzhead = null;
      s.w_bits = windowBits;
      s.w_size = 1 << s.w_bits;
      s.w_mask = s.w_size - 1;
      s.hash_bits = memLevel + 7;
      s.hash_size = 1 << s.hash_bits;
      s.hash_mask = s.hash_size - 1;
      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s.window = new utils.Buf8(s.w_size * 2);
      s.head = new utils.Buf16(s.hash_size);
      s.prev = new utils.Buf16(s.w_size);
      s.lit_bufsize = 1 << memLevel + 6;
      s.pending_buf_size = s.lit_bufsize * 4;
      s.pending_buf = new utils.Buf8(s.pending_buf_size);
      s.d_buf = 1 * s.lit_bufsize;
      s.l_buf = (1 + 2) * s.lit_bufsize;
      s.level = level;
      s.strategy = strategy;
      s.method = method;
      return deflateReset(strm);
    }
    function deflateInit(strm, level) {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    }
    function deflate(strm, flush) {
      var old_flush, s;
      var beg, val;
      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      s = strm.state;
      if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      s.strm = strm;
      old_flush = s.last_flush;
      s.last_flush = flush;
      if (s.status === INIT_STATE) {
        if (s.wrap === 2) {
          strm.adler = 0;
          put_byte(s, 31);
          put_byte(s, 139);
          put_byte(s, 8);
          if (!s.gzhead) {
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, OS_CODE);
            s.status = BUSY_STATE;
          } else {
            put_byte(
              s,
              (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
            );
            put_byte(s, s.gzhead.time & 255);
            put_byte(s, s.gzhead.time >> 8 & 255);
            put_byte(s, s.gzhead.time >> 16 & 255);
            put_byte(s, s.gzhead.time >> 24 & 255);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, s.gzhead.os & 255);
            if (s.gzhead.extra && s.gzhead.extra.length) {
              put_byte(s, s.gzhead.extra.length & 255);
              put_byte(s, s.gzhead.extra.length >> 8 & 255);
            }
            if (s.gzhead.hcrc) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
            }
            s.gzindex = 0;
            s.status = EXTRA_STATE;
          }
        } else {
          var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
          var level_flags = -1;
          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
            level_flags = 0;
          } else if (s.level < 6) {
            level_flags = 1;
          } else if (s.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s.strstart !== 0) {
            header |= PRESET_DICT;
          }
          header += 31 - header % 31;
          s.status = BUSY_STATE;
          putShortMSB(s, header);
          if (s.strstart !== 0) {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 65535);
          }
          strm.adler = 1;
        }
      }
      if (s.status === EXTRA_STATE) {
        if (s.gzhead.extra) {
          beg = s.pending;
          while (s.gzindex < (s.gzhead.extra.length & 65535)) {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                break;
              }
            }
            put_byte(s, s.gzhead.extra[s.gzindex] & 255);
            s.gzindex++;
          }
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (s.gzindex === s.gzhead.extra.length) {
            s.gzindex = 0;
            s.status = NAME_STATE;
          }
        } else {
          s.status = NAME_STATE;
        }
      }
      if (s.status === NAME_STATE) {
        if (s.gzhead.name) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.name.length) {
              val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.gzindex = 0;
            s.status = COMMENT_STATE;
          }
        } else {
          s.status = COMMENT_STATE;
        }
      }
      if (s.status === COMMENT_STATE) {
        if (s.gzhead.comment) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.comment.length) {
              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.status = HCRC_STATE;
          }
        } else {
          s.status = HCRC_STATE;
        }
      }
      if (s.status === HCRC_STATE) {
        if (s.gzhead.hcrc) {
          if (s.pending + 2 > s.pending_buf_size) {
            flush_pending(strm);
          }
          if (s.pending + 2 <= s.pending_buf_size) {
            put_byte(s, strm.adler & 255);
            put_byte(s, strm.adler >> 8 & 255);
            strm.adler = 0;
            s.status = BUSY_STATE;
          }
        } else {
          s.status = BUSY_STATE;
        }
      }
      if (s.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
        var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            trees._tr_align(s);
          } else if (flush !== Z_BLOCK) {
            trees._tr_stored_block(s, 0, 0, false);
            if (flush === Z_FULL_FLUSH) {
              zero(s.head);
              if (s.lookahead === 0) {
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s.wrap === 2) {
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        put_byte(s, strm.adler >> 16 & 255);
        put_byte(s, strm.adler >> 24 & 255);
        put_byte(s, strm.total_in & 255);
        put_byte(s, strm.total_in >> 8 & 255);
        put_byte(s, strm.total_in >> 16 & 255);
        put_byte(s, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s.wrap > 0) {
        s.wrap = -s.wrap;
      }
      return s.pending !== 0 ? Z_OK : Z_STREAM_END;
    }
    function deflateEnd(strm) {
      var status;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      status = strm.state.status;
      if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    }
    function deflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var s;
      var str, n;
      var wrap;
      var avail;
      var next;
      var input;
      var tmpDict;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      s = strm.state;
      wrap = s.wrap;
      if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
        return Z_STREAM_ERROR;
      }
      if (wrap === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }
      s.wrap = 0;
      if (dictLength >= s.w_size) {
        if (wrap === 0) {
          zero(s.head);
          s.strstart = 0;
          s.block_start = 0;
          s.insert = 0;
        }
        tmpDict = new utils.Buf8(s.w_size);
        utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
        dictionary = tmpDict;
        dictLength = s.w_size;
      }
      avail = strm.avail_in;
      next = strm.next_in;
      input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s);
      while (s.lookahead >= MIN_MATCH) {
        str = s.strstart;
        n = s.lookahead - (MIN_MATCH - 1);
        do {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
        } while (--n);
        s.strstart = str;
        s.lookahead = MIN_MATCH - 1;
        fill_window(s);
      }
      s.strstart += s.lookahead;
      s.block_start = s.strstart;
      s.insert = s.lookahead;
      s.lookahead = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s.wrap = wrap;
      return Z_OK;
    }
    exports.deflateInit = deflateInit;
    exports.deflateInit2 = deflateInit2;
    exports.deflateReset = deflateReset;
    exports.deflateResetKeep = deflateResetKeep;
    exports.deflateSetHeader = deflateSetHeader;
    exports.deflate = deflate;
    exports.deflateEnd = deflateEnd;
    exports.deflateSetDictionary = deflateSetDictionary;
    exports.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// ../../node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "../../node_modules/pako/lib/zlib/inffast.js"(exports, module) {
    "use strict";
    init_shim();
    var BAD = 30;
    var TYPE = 12;
    module.exports = function inflate_fast(strm, start) {
      var state;
      var _in;
      var last;
      var _out;
      var beg;
      var end;
      var dmax;
      var wsize;
      var whave;
      var wnext;
      var s_window;
      var hold;
      var bits;
      var lcode;
      var dcode;
      var lmask;
      var dmask;
      var here;
      var op;
      var len;
      var dist;
      var from;
      var from_source;
      var input, output;
      state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                        }
                        from = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from++];
                          if (len > 1) {
                            output[_out++] = from_source[from++];
                          }
                        }
                      } else {
                        from = _out - dist;
                        do {
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from++];
                          if (len > 1) {
                            output[_out++] = output[from++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break top;
              }
              break;
            }
        } while (_in < last && _out < end);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits;
      return;
    };
  }
});

// ../../node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "../../node_modules/pako/lib/zlib/inftrees.js"(exports, module) {
    "use strict";
    init_shim();
    var utils = require_common();
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = [
      /* Length codes 257..285 base */
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ];
    var lext = [
      /* Length codes 257..285 extra */
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ];
    var dbase = [
      /* Distance codes 0..29 base */
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ];
    var dext = [
      /* Distance codes 0..29 extra */
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ];
    module.exports = function inflate_table(type, lens, lens_index, codes2, table, table_index, work, opts) {
      var bits = opts.bits;
      var len = 0;
      var sym = 0;
      var min2 = 0, max3 = 0;
      var root = 0;
      var curr = 0;
      var drop = 0;
      var left = 0;
      var used = 0;
      var huff = 0;
      var incr;
      var fill;
      var low;
      var mask;
      var next;
      var base = null;
      var base_index = 0;
      var end;
      var count2 = new utils.Buf16(MAXBITS + 1);
      var offs = new utils.Buf16(MAXBITS + 1);
      var extra = null;
      var extra_index = 0;
      var here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count2[len] = 0;
      }
      for (sym = 0; sym < codes2; sym++) {
        count2[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max3 = MAXBITS; max3 >= 1; max3--) {
        if (count2[max3] !== 0) {
          break;
        }
      }
      if (root > max3) {
        root = max3;
      }
      if (max3 === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min2 = 1; min2 < max3; min2++) {
        if (count2[min2] !== 0) {
          break;
        }
      }
      if (root < min2) {
        root = min2;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count2[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES || max3 !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count2[len];
      }
      for (sym = 0; sym < codes2; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base = extra = work;
        end = 19;
      } else if (type === LENS) {
        base = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;
      } else {
        base = dbase;
        extra = dext;
        end = -1;
      }
      huff = 0;
      sym = 0;
      len = min2;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] < end) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end) {
          here_op = extra[extra_index + work[sym]];
          here_val = base[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min2 = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count2[len] === 0) {
          if (len === max3) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min2;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max3) {
            left -= count2[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          low = huff & mask;
          table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    };
  }
});

// ../../node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "../../node_modules/pako/lib/zlib/inflate.js"(exports) {
    "use strict";
    init_shim();
    var utils = require_common();
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var inflate_fast = require_inffast();
    var inflate_table = require_inftrees();
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_TREES = 6;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_NEED_DICT = 2;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_MEM_ERROR = -4;
    var Z_BUF_ERROR = -5;
    var Z_DEFLATED = 8;
    var HEAD = 1;
    var FLAGS = 2;
    var TIME = 3;
    var OS = 4;
    var EXLEN = 5;
    var EXTRA = 6;
    var NAME = 7;
    var COMMENT = 8;
    var HCRC = 9;
    var DICTID = 10;
    var DICT = 11;
    var TYPE = 12;
    var TYPEDO = 13;
    var STORED = 14;
    var COPY_ = 15;
    var COPY = 16;
    var TABLE = 17;
    var LENLENS = 18;
    var CODELENS = 19;
    var LEN_ = 20;
    var LEN = 21;
    var LENEXT = 22;
    var DIST = 23;
    var DISTEXT = 24;
    var MATCH = 25;
    var LIT = 26;
    var CHECK = 27;
    var LENGTH = 28;
    var DONE = 29;
    var BAD = 30;
    var MEM = 31;
    var SYNC = 32;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    function zswap32(q) {
      return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
    }
    function InflateState() {
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new utils.Buf16(320);
      this.work = new utils.Buf16(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    function inflateResetKeep(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
      state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    }
    function inflateReset(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    }
    function inflateReset2(strm, windowBits) {
      var wrap;
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    }
    function inflateInit2(strm, windowBits) {
      var ret;
      var state;
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      state = new InflateState();
      strm.state = state;
      state.window = null;
      ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    }
    function inflateInit(strm) {
      return inflateInit2(strm, DEF_WBITS);
    }
    var virgin = true;
    var lenfix;
    var distfix;
    function fixedtables(state) {
      if (virgin) {
        var sym;
        lenfix = new utils.Buf32(512);
        distfix = new utils.Buf32(32);
        sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    }
    function updatewindow(strm, src, end, copy) {
      var dist;
      var state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new utils.Buf8(state.wsize);
      }
      if (copy >= state.wsize) {
        utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        utils.arraySet(state.window, src, end - copy, dist, state.wnext);
        copy -= dist;
        if (copy) {
          utils.arraySet(state.window, src, end - copy, copy, 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    }
    function inflate(strm, flush) {
      var state;
      var input, output;
      var next;
      var put;
      var have, left;
      var hold;
      var bits;
      var _in, _out;
      var copy;
      var from;
      var from_source;
      var here = 0;
      var here_bits, here_op, here_val;
      var last_bits, last_op, last_val;
      var len;
      var ret;
      var hbuf = new utils.Buf8(4);
      var opts;
      var n;
      var order = (
        /* permutation of code lengths */
        [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
      );
      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK;
      inf_leave:
        for (; ; ) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS;
                break;
              }
              state.flags = 0;
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || /* check if zlib header allowed */
              (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len;
              } else if (len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break;
              }
              state.dmax = 1 << len;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = TIME;
            /* falls through */
            case TIME:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = OS;
            /* falls through */
            case OS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN;
            /* falls through */
            case EXLEN:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA;
            /* falls through */
            case EXTRA:
              if (state.flags & 1024) {
                copy = state.length;
                if (copy > have) {
                  copy = have;
                }
                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Array(state.head.extra_len);
                    }
                    utils.arraySet(
                      state.head.extra,
                      input,
                      next,
                      // extra field is limited to 65536 bytes
                      // - no need for additional size check
                      copy,
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len
                    );
                  }
                  if (state.flags & 512) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  state.length -= copy;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME;
            /* falls through */
            case NAME:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT;
            /* falls through */
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
            /* falls through */
            case HCRC:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT;
            /* falls through */
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            /* falls through */
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave;
              }
            /* falls through */
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break;
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            /* falls through */
            case COPY_:
              state.mode = COPY;
            /* falls through */
            case COPY:
              copy = state.length;
              if (copy) {
                if (copy > have) {
                  copy = have;
                }
                if (copy > left) {
                  copy = left;
                }
                if (copy === 0) {
                  break inf_leave;
                }
                utils.arraySet(output, input, next, copy, put);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = LENLENS;
            /* falls through */
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = { bits: state.lenbits };
              ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = CODELENS;
            /* falls through */
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n = here_bits + 2;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    len = state.lens[state.have - 1];
                    copy = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n = here_bits + 3;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n = here_bits + 7;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  while (copy--) {
                    state.lens[state.have++] = len;
                  }
                }
              }
              if (state.mode === BAD) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break;
              }
              state.lenbits = 9;
              opts = { bits: state.lenbits };
              ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break;
              }
              state.mode = LEN_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            /* falls through */
            case LEN_:
              state.mode = LEN;
            /* falls through */
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inflate_fast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            /* falls through */
            case LENEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST;
            /* falls through */
            case DIST:
              for (; ; ) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            /* falls through */
            case DISTEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            /* falls through */
            case MATCH:
              if (left === 0) {
                break inf_leave;
              }
              copy = _out - left;
              if (state.offset > copy) {
                copy = state.offset - copy;
                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                }
                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from = state.wsize - copy;
                } else {
                  from = state.wnext - copy;
                }
                if (copy > state.length) {
                  copy = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from = put - state.offset;
                copy = state.length;
              }
              if (copy > left) {
                copy = left;
              }
              left -= copy;
              state.length -= copy;
              do {
                output[put++] = from_source[from++];
              } while (--copy);
              if (state.length === 0) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (_out) {
                  strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
                  state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                }
                _out = left;
                if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = LENGTH;
            /* falls through */
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = DONE;
            /* falls through */
            case DONE:
              ret = Z_STREAM_END;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
            /* falls through */
            default:
              return Z_STREAM_ERROR;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
        state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    }
    function inflateEnd(strm) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      var state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    }
    function inflateGetHeader(strm, head) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    }
    function inflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var state;
      var dictid;
      var ret;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      return Z_OK;
    }
    exports.inflateReset = inflateReset;
    exports.inflateReset2 = inflateReset2;
    exports.inflateResetKeep = inflateResetKeep;
    exports.inflateInit = inflateInit;
    exports.inflateInit2 = inflateInit2;
    exports.inflate = inflate;
    exports.inflateEnd = inflateEnd;
    exports.inflateGetHeader = inflateGetHeader;
    exports.inflateSetDictionary = inflateSetDictionary;
    exports.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// ../../node_modules/pako/lib/zlib/constants.js
var require_constants = __commonJS({
  "../../node_modules/pako/lib/zlib/constants.js"(exports, module) {
    "use strict";
    init_shim();
    module.exports = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      //Z_MEM_ERROR:     -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
  }
});

// ../../node_modules/browserify-zlib/lib/binding.js
var require_binding = __commonJS({
  "../../node_modules/browserify-zlib/lib/binding.js"(exports) {
    "use strict";
    init_shim();
    var assert12 = require_assert();
    var Zstream = require_zstream();
    var zlib_deflate = require_deflate();
    var zlib_inflate = require_inflate();
    var constants2 = require_constants();
    for (key in constants2) {
      exports[key] = constants2[key];
    }
    var key;
    exports.NONE = 0;
    exports.DEFLATE = 1;
    exports.INFLATE = 2;
    exports.GZIP = 3;
    exports.GUNZIP = 4;
    exports.DEFLATERAW = 5;
    exports.INFLATERAW = 6;
    exports.UNZIP = 7;
    var GZIP_HEADER_ID1 = 31;
    var GZIP_HEADER_ID2 = 139;
    function Zlib(mode) {
      if (typeof mode !== "number" || mode < exports.DEFLATE || mode > exports.UNZIP) {
        throw new TypeError("Bad argument");
      }
      this.dictionary = null;
      this.err = 0;
      this.flush = 0;
      this.init_done = false;
      this.level = 0;
      this.memLevel = 0;
      this.mode = mode;
      this.strategy = 0;
      this.windowBits = 0;
      this.write_in_progress = false;
      this.pending_close = false;
      this.gzip_id_bytes_read = 0;
    }
    Zlib.prototype.close = function() {
      if (this.write_in_progress) {
        this.pending_close = true;
        return;
      }
      this.pending_close = false;
      assert12(this.init_done, "close before init");
      assert12(this.mode <= exports.UNZIP);
      if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {
        zlib_deflate.deflateEnd(this.strm);
      } else if (this.mode === exports.INFLATE || this.mode === exports.GUNZIP || this.mode === exports.INFLATERAW || this.mode === exports.UNZIP) {
        zlib_inflate.inflateEnd(this.strm);
      }
      this.mode = exports.NONE;
      this.dictionary = null;
    };
    Zlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {
      return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);
    };
    Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
      return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);
    };
    Zlib.prototype._write = function(async, flush, input, in_off, in_len, out, out_off, out_len) {
      assert12.equal(arguments.length, 8);
      assert12(this.init_done, "write before init");
      assert12(this.mode !== exports.NONE, "already finalized");
      assert12.equal(false, this.write_in_progress, "write already in progress");
      assert12.equal(false, this.pending_close, "close is pending");
      this.write_in_progress = true;
      assert12.equal(false, flush === void 0, "must provide flush value");
      this.write_in_progress = true;
      if (flush !== exports.Z_NO_FLUSH && flush !== exports.Z_PARTIAL_FLUSH && flush !== exports.Z_SYNC_FLUSH && flush !== exports.Z_FULL_FLUSH && flush !== exports.Z_FINISH && flush !== exports.Z_BLOCK) {
        throw new Error("Invalid flush value");
      }
      if (input == null) {
        input = import_buffer.Buffer.alloc(0);
        in_len = 0;
        in_off = 0;
      }
      this.strm.avail_in = in_len;
      this.strm.input = input;
      this.strm.next_in = in_off;
      this.strm.avail_out = out_len;
      this.strm.output = out;
      this.strm.next_out = out_off;
      this.flush = flush;
      if (!async) {
        this._process();
        if (this._checkError()) {
          return this._afterSync();
        }
        return;
      }
      var self2 = this;
      process_browser_default.nextTick(function() {
        self2._process();
        self2._after();
      });
      return this;
    };
    Zlib.prototype._afterSync = function() {
      var avail_out = this.strm.avail_out;
      var avail_in = this.strm.avail_in;
      this.write_in_progress = false;
      return [avail_in, avail_out];
    };
    Zlib.prototype._process = function() {
      var next_expected_header_byte = null;
      switch (this.mode) {
        case exports.DEFLATE:
        case exports.GZIP:
        case exports.DEFLATERAW:
          this.err = zlib_deflate.deflate(this.strm, this.flush);
          break;
        case exports.UNZIP:
          if (this.strm.avail_in > 0) {
            next_expected_header_byte = this.strm.next_in;
          }
          switch (this.gzip_id_bytes_read) {
            case 0:
              if (next_expected_header_byte === null) {
                break;
              }
              if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {
                this.gzip_id_bytes_read = 1;
                next_expected_header_byte++;
                if (this.strm.avail_in === 1) {
                  break;
                }
              } else {
                this.mode = exports.INFLATE;
                break;
              }
            // fallthrough
            case 1:
              if (next_expected_header_byte === null) {
                break;
              }
              if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2) {
                this.gzip_id_bytes_read = 2;
                this.mode = exports.GUNZIP;
              } else {
                this.mode = exports.INFLATE;
              }
              break;
            default:
              throw new Error("invalid number of gzip magic number bytes read");
          }
        // fallthrough
        case exports.INFLATE:
        case exports.GUNZIP:
        case exports.INFLATERAW:
          this.err = zlib_inflate.inflate(
            this.strm,
            this.flush
            // If data was encoded with dictionary
          );
          if (this.err === exports.Z_NEED_DICT && this.dictionary) {
            this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary);
            if (this.err === exports.Z_OK) {
              this.err = zlib_inflate.inflate(this.strm, this.flush);
            } else if (this.err === exports.Z_DATA_ERROR) {
              this.err = exports.Z_NEED_DICT;
            }
          }
          while (this.strm.avail_in > 0 && this.mode === exports.GUNZIP && this.err === exports.Z_STREAM_END && this.strm.next_in[0] !== 0) {
            this.reset();
            this.err = zlib_inflate.inflate(this.strm, this.flush);
          }
          break;
        default:
          throw new Error("Unknown mode " + this.mode);
      }
    };
    Zlib.prototype._checkError = function() {
      switch (this.err) {
        case exports.Z_OK:
        case exports.Z_BUF_ERROR:
          if (this.strm.avail_out !== 0 && this.flush === exports.Z_FINISH) {
            this._error("unexpected end of file");
            return false;
          }
          break;
        case exports.Z_STREAM_END:
          break;
        case exports.Z_NEED_DICT:
          if (this.dictionary == null) {
            this._error("Missing dictionary");
          } else {
            this._error("Bad dictionary");
          }
          return false;
        default:
          this._error("Zlib error");
          return false;
      }
      return true;
    };
    Zlib.prototype._after = function() {
      if (!this._checkError()) {
        return;
      }
      var avail_out = this.strm.avail_out;
      var avail_in = this.strm.avail_in;
      this.write_in_progress = false;
      this.callback(avail_in, avail_out);
      if (this.pending_close) {
        this.close();
      }
    };
    Zlib.prototype._error = function(message) {
      if (this.strm.msg) {
        message = this.strm.msg;
      }
      this.onerror(
        message,
        this.err
        // no hope of rescue.
      );
      this.write_in_progress = false;
      if (this.pending_close) {
        this.close();
      }
    };
    Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
      assert12(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])");
      assert12(windowBits >= 8 && windowBits <= 15, "invalid windowBits");
      assert12(level >= -1 && level <= 9, "invalid compression level");
      assert12(memLevel >= 1 && memLevel <= 9, "invalid memlevel");
      assert12(strategy === exports.Z_FILTERED || strategy === exports.Z_HUFFMAN_ONLY || strategy === exports.Z_RLE || strategy === exports.Z_FIXED || strategy === exports.Z_DEFAULT_STRATEGY, "invalid strategy");
      this._init(level, windowBits, memLevel, strategy, dictionary);
      this._setDictionary();
    };
    Zlib.prototype.params = function() {
      throw new Error("deflateParams Not supported");
    };
    Zlib.prototype.reset = function() {
      this._reset();
      this._setDictionary();
    };
    Zlib.prototype._init = function(level, windowBits, memLevel, strategy, dictionary) {
      this.level = level;
      this.windowBits = windowBits;
      this.memLevel = memLevel;
      this.strategy = strategy;
      this.flush = exports.Z_NO_FLUSH;
      this.err = exports.Z_OK;
      if (this.mode === exports.GZIP || this.mode === exports.GUNZIP) {
        this.windowBits += 16;
      }
      if (this.mode === exports.UNZIP) {
        this.windowBits += 32;
      }
      if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW) {
        this.windowBits = -1 * this.windowBits;
      }
      this.strm = new Zstream();
      switch (this.mode) {
        case exports.DEFLATE:
        case exports.GZIP:
        case exports.DEFLATERAW:
          this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
          break;
        case exports.INFLATE:
        case exports.GUNZIP:
        case exports.INFLATERAW:
        case exports.UNZIP:
          this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);
          break;
        default:
          throw new Error("Unknown mode " + this.mode);
      }
      if (this.err !== exports.Z_OK) {
        this._error("Init error");
      }
      this.dictionary = dictionary;
      this.write_in_progress = false;
      this.init_done = true;
    };
    Zlib.prototype._setDictionary = function() {
      if (this.dictionary == null) {
        return;
      }
      this.err = exports.Z_OK;
      switch (this.mode) {
        case exports.DEFLATE:
        case exports.DEFLATERAW:
          this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);
          break;
        default:
          break;
      }
      if (this.err !== exports.Z_OK) {
        this._error("Failed to set dictionary");
      }
    };
    Zlib.prototype._reset = function() {
      this.err = exports.Z_OK;
      switch (this.mode) {
        case exports.DEFLATE:
        case exports.DEFLATERAW:
        case exports.GZIP:
          this.err = zlib_deflate.deflateReset(this.strm);
          break;
        case exports.INFLATE:
        case exports.INFLATERAW:
        case exports.GUNZIP:
          this.err = zlib_inflate.inflateReset(this.strm);
          break;
        default:
          break;
      }
      if (this.err !== exports.Z_OK) {
        this._error("Failed to reset stream");
      }
    };
    exports.Zlib = Zlib;
  }
});

// ../../node_modules/browserify-zlib/lib/index.js
var require_lib2 = __commonJS({
  "../../node_modules/browserify-zlib/lib/index.js"(exports) {
    "use strict";
    init_shim();
    var Buffer4 = require_buffer().Buffer;
    var Transform = require_stream_browserify().Transform;
    var binding = require_binding();
    var util = require_util();
    var assert12 = require_assert().ok;
    var kMaxLength = require_buffer().kMaxLength;
    var kRangeErrorMessage = "Cannot create final Buffer. It would be larger than 0x" + kMaxLength.toString(16) + " bytes";
    binding.Z_MIN_WINDOWBITS = 8;
    binding.Z_MAX_WINDOWBITS = 15;
    binding.Z_DEFAULT_WINDOWBITS = 15;
    binding.Z_MIN_CHUNK = 64;
    binding.Z_MAX_CHUNK = Infinity;
    binding.Z_DEFAULT_CHUNK = 16 * 1024;
    binding.Z_MIN_MEMLEVEL = 1;
    binding.Z_MAX_MEMLEVEL = 9;
    binding.Z_DEFAULT_MEMLEVEL = 8;
    binding.Z_MIN_LEVEL = -1;
    binding.Z_MAX_LEVEL = 9;
    binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;
    var bkeys = Object.keys(binding);
    for (bk = 0; bk < bkeys.length; bk++) {
      bkey = bkeys[bk];
      if (bkey.match(/^Z/)) {
        Object.defineProperty(exports, bkey, {
          enumerable: true,
          value: binding[bkey],
          writable: false
        });
      }
    }
    var bkey;
    var bk;
    var codes2 = {
      Z_OK: binding.Z_OK,
      Z_STREAM_END: binding.Z_STREAM_END,
      Z_NEED_DICT: binding.Z_NEED_DICT,
      Z_ERRNO: binding.Z_ERRNO,
      Z_STREAM_ERROR: binding.Z_STREAM_ERROR,
      Z_DATA_ERROR: binding.Z_DATA_ERROR,
      Z_MEM_ERROR: binding.Z_MEM_ERROR,
      Z_BUF_ERROR: binding.Z_BUF_ERROR,
      Z_VERSION_ERROR: binding.Z_VERSION_ERROR
    };
    var ckeys = Object.keys(codes2);
    for (ck = 0; ck < ckeys.length; ck++) {
      ckey = ckeys[ck];
      codes2[codes2[ckey]] = ckey;
    }
    var ckey;
    var ck;
    Object.defineProperty(exports, "codes", {
      enumerable: true,
      value: Object.freeze(codes2),
      writable: false
    });
    exports.Deflate = Deflate;
    exports.Inflate = Inflate;
    exports.Gzip = Gzip;
    exports.Gunzip = Gunzip;
    exports.DeflateRaw = DeflateRaw;
    exports.InflateRaw = InflateRaw;
    exports.Unzip = Unzip;
    exports.createDeflate = function(o) {
      return new Deflate(o);
    };
    exports.createInflate = function(o) {
      return new Inflate(o);
    };
    exports.createDeflateRaw = function(o) {
      return new DeflateRaw(o);
    };
    exports.createInflateRaw = function(o) {
      return new InflateRaw(o);
    };
    exports.createGzip = function(o) {
      return new Gzip(o);
    };
    exports.createGunzip = function(o) {
      return new Gunzip(o);
    };
    exports.createUnzip = function(o) {
      return new Unzip(o);
    };
    exports.deflate = function(buffer, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Deflate(opts), buffer, callback);
    };
    exports.deflateSync = function(buffer, opts) {
      return zlibBufferSync(new Deflate(opts), buffer);
    };
    exports.gzip = function(buffer, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Gzip(opts), buffer, callback);
    };
    exports.gzipSync = function(buffer, opts) {
      return zlibBufferSync(new Gzip(opts), buffer);
    };
    exports.deflateRaw = function(buffer, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new DeflateRaw(opts), buffer, callback);
    };
    exports.deflateRawSync = function(buffer, opts) {
      return zlibBufferSync(new DeflateRaw(opts), buffer);
    };
    exports.unzip = function(buffer, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Unzip(opts), buffer, callback);
    };
    exports.unzipSync = function(buffer, opts) {
      return zlibBufferSync(new Unzip(opts), buffer);
    };
    exports.inflate = function(buffer, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Inflate(opts), buffer, callback);
    };
    exports.inflateSync = function(buffer, opts) {
      return zlibBufferSync(new Inflate(opts), buffer);
    };
    exports.gunzip = function(buffer, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new Gunzip(opts), buffer, callback);
    };
    exports.gunzipSync = function(buffer, opts) {
      return zlibBufferSync(new Gunzip(opts), buffer);
    };
    exports.inflateRaw = function(buffer, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      }
      return zlibBuffer(new InflateRaw(opts), buffer, callback);
    };
    exports.inflateRawSync = function(buffer, opts) {
      return zlibBufferSync(new InflateRaw(opts), buffer);
    };
    function zlibBuffer(engine, buffer, callback) {
      var buffers = [];
      var nread = 0;
      engine.on("error", onError);
      engine.on("end", onEnd);
      engine.end(buffer);
      flow();
      function flow() {
        var chunk;
        while (null !== (chunk = engine.read())) {
          buffers.push(chunk);
          nread += chunk.length;
        }
        engine.once("readable", flow);
      }
      function onError(err) {
        engine.removeListener("end", onEnd);
        engine.removeListener("readable", flow);
        callback(err);
      }
      function onEnd() {
        var buf;
        var err = null;
        if (nread >= kMaxLength) {
          err = new RangeError(kRangeErrorMessage);
        } else {
          buf = Buffer4.concat(buffers, nread);
        }
        buffers = [];
        engine.close();
        callback(err, buf);
      }
    }
    function zlibBufferSync(engine, buffer) {
      if (typeof buffer === "string") buffer = Buffer4.from(buffer);
      if (!Buffer4.isBuffer(buffer)) throw new TypeError("Not a string or buffer");
      var flushFlag = engine._finishFlushFlag;
      return engine._processChunk(buffer, flushFlag);
    }
    function Deflate(opts) {
      if (!(this instanceof Deflate)) return new Deflate(opts);
      Zlib.call(this, opts, binding.DEFLATE);
    }
    function Inflate(opts) {
      if (!(this instanceof Inflate)) return new Inflate(opts);
      Zlib.call(this, opts, binding.INFLATE);
    }
    function Gzip(opts) {
      if (!(this instanceof Gzip)) return new Gzip(opts);
      Zlib.call(this, opts, binding.GZIP);
    }
    function Gunzip(opts) {
      if (!(this instanceof Gunzip)) return new Gunzip(opts);
      Zlib.call(this, opts, binding.GUNZIP);
    }
    function DeflateRaw(opts) {
      if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);
      Zlib.call(this, opts, binding.DEFLATERAW);
    }
    function InflateRaw(opts) {
      if (!(this instanceof InflateRaw)) return new InflateRaw(opts);
      Zlib.call(this, opts, binding.INFLATERAW);
    }
    function Unzip(opts) {
      if (!(this instanceof Unzip)) return new Unzip(opts);
      Zlib.call(this, opts, binding.UNZIP);
    }
    function isValidFlushFlag(flag) {
      return flag === binding.Z_NO_FLUSH || flag === binding.Z_PARTIAL_FLUSH || flag === binding.Z_SYNC_FLUSH || flag === binding.Z_FULL_FLUSH || flag === binding.Z_FINISH || flag === binding.Z_BLOCK;
    }
    function Zlib(opts, mode) {
      var _this = this;
      this._opts = opts = opts || {};
      this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;
      Transform.call(this, opts);
      if (opts.flush && !isValidFlushFlag(opts.flush)) {
        throw new Error("Invalid flush flag: " + opts.flush);
      }
      if (opts.finishFlush && !isValidFlushFlag(opts.finishFlush)) {
        throw new Error("Invalid flush flag: " + opts.finishFlush);
      }
      this._flushFlag = opts.flush || binding.Z_NO_FLUSH;
      this._finishFlushFlag = typeof opts.finishFlush !== "undefined" ? opts.finishFlush : binding.Z_FINISH;
      if (opts.chunkSize) {
        if (opts.chunkSize < exports.Z_MIN_CHUNK || opts.chunkSize > exports.Z_MAX_CHUNK) {
          throw new Error("Invalid chunk size: " + opts.chunkSize);
        }
      }
      if (opts.windowBits) {
        if (opts.windowBits < exports.Z_MIN_WINDOWBITS || opts.windowBits > exports.Z_MAX_WINDOWBITS) {
          throw new Error("Invalid windowBits: " + opts.windowBits);
        }
      }
      if (opts.level) {
        if (opts.level < exports.Z_MIN_LEVEL || opts.level > exports.Z_MAX_LEVEL) {
          throw new Error("Invalid compression level: " + opts.level);
        }
      }
      if (opts.memLevel) {
        if (opts.memLevel < exports.Z_MIN_MEMLEVEL || opts.memLevel > exports.Z_MAX_MEMLEVEL) {
          throw new Error("Invalid memLevel: " + opts.memLevel);
        }
      }
      if (opts.strategy) {
        if (opts.strategy != exports.Z_FILTERED && opts.strategy != exports.Z_HUFFMAN_ONLY && opts.strategy != exports.Z_RLE && opts.strategy != exports.Z_FIXED && opts.strategy != exports.Z_DEFAULT_STRATEGY) {
          throw new Error("Invalid strategy: " + opts.strategy);
        }
      }
      if (opts.dictionary) {
        if (!Buffer4.isBuffer(opts.dictionary)) {
          throw new Error("Invalid dictionary: it should be a Buffer instance");
        }
      }
      this._handle = new binding.Zlib(mode);
      var self2 = this;
      this._hadError = false;
      this._handle.onerror = function(message, errno) {
        _close(self2);
        self2._hadError = true;
        var error = new Error(message);
        error.errno = errno;
        error.code = exports.codes[errno];
        self2.emit("error", error);
      };
      var level = exports.Z_DEFAULT_COMPRESSION;
      if (typeof opts.level === "number") level = opts.level;
      var strategy = exports.Z_DEFAULT_STRATEGY;
      if (typeof opts.strategy === "number") strategy = opts.strategy;
      this._handle.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary);
      this._buffer = Buffer4.allocUnsafe(this._chunkSize);
      this._offset = 0;
      this._level = level;
      this._strategy = strategy;
      this.once("end", this.close);
      Object.defineProperty(this, "_closed", {
        get: function() {
          return !_this._handle;
        },
        configurable: true,
        enumerable: true
      });
    }
    util.inherits(Zlib, Transform);
    Zlib.prototype.params = function(level, strategy, callback) {
      if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL) {
        throw new RangeError("Invalid compression level: " + level);
      }
      if (strategy != exports.Z_FILTERED && strategy != exports.Z_HUFFMAN_ONLY && strategy != exports.Z_RLE && strategy != exports.Z_FIXED && strategy != exports.Z_DEFAULT_STRATEGY) {
        throw new TypeError("Invalid strategy: " + strategy);
      }
      if (this._level !== level || this._strategy !== strategy) {
        var self2 = this;
        this.flush(binding.Z_SYNC_FLUSH, function() {
          assert12(self2._handle, "zlib binding closed");
          self2._handle.params(level, strategy);
          if (!self2._hadError) {
            self2._level = level;
            self2._strategy = strategy;
            if (callback) callback();
          }
        });
      } else {
        process_browser_default.nextTick(callback);
      }
    };
    Zlib.prototype.reset = function() {
      assert12(this._handle, "zlib binding closed");
      return this._handle.reset();
    };
    Zlib.prototype._flush = function(callback) {
      this._transform(Buffer4.alloc(0), "", callback);
    };
    Zlib.prototype.flush = function(kind, callback) {
      var _this2 = this;
      var ws = this._writableState;
      if (typeof kind === "function" || kind === void 0 && !callback) {
        callback = kind;
        kind = binding.Z_FULL_FLUSH;
      }
      if (ws.ended) {
        if (callback) process_browser_default.nextTick(callback);
      } else if (ws.ending) {
        if (callback) this.once("end", callback);
      } else if (ws.needDrain) {
        if (callback) {
          this.once("drain", function() {
            return _this2.flush(kind, callback);
          });
        }
      } else {
        this._flushFlag = kind;
        this.write(Buffer4.alloc(0), "", callback);
      }
    };
    Zlib.prototype.close = function(callback) {
      _close(this, callback);
      process_browser_default.nextTick(emitCloseNT, this);
    };
    function _close(engine, callback) {
      if (callback) process_browser_default.nextTick(callback);
      if (!engine._handle) return;
      engine._handle.close();
      engine._handle = null;
    }
    function emitCloseNT(self2) {
      self2.emit("close");
    }
    Zlib.prototype._transform = function(chunk, encoding, cb) {
      var flushFlag;
      var ws = this._writableState;
      var ending = ws.ending || ws.ended;
      var last = ending && (!chunk || ws.length === chunk.length);
      if (chunk !== null && !Buffer4.isBuffer(chunk)) return cb(new Error("invalid input"));
      if (!this._handle) return cb(new Error("zlib binding closed"));
      if (last) flushFlag = this._finishFlushFlag;
      else {
        flushFlag = this._flushFlag;
        if (chunk.length >= ws.length) {
          this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;
        }
      }
      this._processChunk(chunk, flushFlag, cb);
    };
    Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {
      var availInBefore = chunk && chunk.length;
      var availOutBefore = this._chunkSize - this._offset;
      var inOff = 0;
      var self2 = this;
      var async = typeof cb === "function";
      if (!async) {
        var buffers = [];
        var nread = 0;
        var error;
        this.on("error", function(er) {
          error = er;
        });
        assert12(this._handle, "zlib binding closed");
        do {
          var res = this._handle.writeSync(
            flushFlag,
            chunk,
            // in
            inOff,
            // in_off
            availInBefore,
            // in_len
            this._buffer,
            // out
            this._offset,
            //out_off
            availOutBefore
          );
        } while (!this._hadError && callback(res[0], res[1]));
        if (this._hadError) {
          throw error;
        }
        if (nread >= kMaxLength) {
          _close(this);
          throw new RangeError(kRangeErrorMessage);
        }
        var buf = Buffer4.concat(buffers, nread);
        _close(this);
        return buf;
      }
      assert12(this._handle, "zlib binding closed");
      var req = this._handle.write(
        flushFlag,
        chunk,
        // in
        inOff,
        // in_off
        availInBefore,
        // in_len
        this._buffer,
        // out
        this._offset,
        //out_off
        availOutBefore
      );
      req.buffer = chunk;
      req.callback = callback;
      function callback(availInAfter, availOutAfter) {
        if (this) {
          this.buffer = null;
          this.callback = null;
        }
        if (self2._hadError) return;
        var have = availOutBefore - availOutAfter;
        assert12(have >= 0, "have should not go down");
        if (have > 0) {
          var out = self2._buffer.slice(self2._offset, self2._offset + have);
          self2._offset += have;
          if (async) {
            self2.push(out);
          } else {
            buffers.push(out);
            nread += out.length;
          }
        }
        if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
          availOutBefore = self2._chunkSize;
          self2._offset = 0;
          self2._buffer = Buffer4.allocUnsafe(self2._chunkSize);
        }
        if (availOutAfter === 0) {
          inOff += availInBefore - availInAfter;
          availInBefore = availInAfter;
          if (!async) return true;
          var newReq = self2._handle.write(flushFlag, chunk, inOff, availInBefore, self2._buffer, self2._offset, self2._chunkSize);
          newReq.callback = callback;
          newReq.buffer = chunk;
          return;
        }
        if (!async) return false;
        cb();
      }
    };
    util.inherits(Deflate, Zlib);
    util.inherits(Inflate, Zlib);
    util.inherits(Gzip, Zlib);
    util.inherits(Gunzip, Zlib);
    util.inherits(DeflateRaw, Zlib);
    util.inherits(InflateRaw, Zlib);
    util.inherits(Unzip, Zlib);
  }
});

// src/shims/node-fs.js
var node_fs_exports = {};
__export(node_fs_exports, {
  constants: () => constants,
  createReadStream: () => createReadStream,
  createWriteStream: () => createWriteStream,
  default: () => node_fs_default,
  existsSync: () => existsSync,
  promises: () => promises,
  readFileSync: () => readFileSync,
  readdirSync: () => readdirSync,
  realpathSync: () => realpathSync,
  statSync: () => statSync,
  toNamespacedPath: () => toNamespacedPath,
  writeFileSync: () => writeFileSync
});
import {
  createVfsReadStream,
  hasVfsFile,
  readVfsFile,
  readVfsFileSync,
  realpathVfs,
  statVfsFile
} from "./cspell-vfs.js";
function existsSync(pathLike) {
  return hasVfsFile(pathLike);
}
function readFileSync(pathLike, options) {
  const encoding = typeof options === "string" ? options : options == null ? void 0 : options.encoding;
  const content = readVfsFileSync(pathLike, encoding);
  if (content !== void 0) return content;
  throw unavailableError("fs.readFileSync");
}
function writeFileSync() {
  throw unavailableError("fs.writeFileSync");
}
function readdirSync() {
  return [];
}
function statSync(_path, options) {
  const stat = statVfsFile(_path);
  if (stat) return stat;
  if (options && options.throwIfNoEntry === false) {
    return void 0;
  }
  return fakeStats;
}
function realpathSync(pathLike) {
  return realpathVfs(pathLike);
}
function toNamespacedPath(pathLike) {
  return realpathVfs(pathLike);
}
function createWriteStream() {
  return new import_stream_browserify.default.PassThrough();
}
function createReadStream(pathLike) {
  return createVfsReadStream(pathLike) || new import_stream_browserify.default.PassThrough();
}
var import_stream_browserify, unavailableError, fakeStats, constants, promises, node_fs_default;
var init_node_fs = __esm({
  "src/shims/node-fs.js"() {
    init_shim();
    import_stream_browserify = __toESM(require_stream_browserify());
    unavailableError = (apiName) => new Error(`[ace-spell-check] ${apiName} is not available in browser builds.`);
    fakeStats = {
      isFile: () => false,
      isDirectory: () => false,
      isSymbolicLink: () => false
    };
    constants = {};
    promises = {
      async readFile(pathLike, options) {
        const encoding = typeof options === "string" ? options : options == null ? void 0 : options.encoding;
        const content = await readVfsFile(pathLike, encoding);
        if (content !== void 0) return content;
        throw unavailableError("fs.promises.readFile");
      },
      async writeFile() {
        throw unavailableError("fs.promises.writeFile");
      },
      async mkdir() {
        throw unavailableError("fs.promises.mkdir");
      },
      async readdir() {
        return [];
      },
      async stat(pathLike) {
        const stat = statVfsFile(pathLike);
        if (stat) return stat;
        throw unavailableError("fs.promises.stat");
      },
      async realpath(pathLike) {
        return realpathVfs(pathLike);
      }
    };
    node_fs_default = {
      constants,
      promises,
      existsSync,
      readFileSync,
      writeFileSync,
      readdirSync,
      statSync,
      realpathSync,
      toNamespacedPath,
      createWriteStream,
      createReadStream
    };
  }
});

// ../../node_modules/cspell-glob/node_modules/picomatch/lib/constants.js
var require_constants2 = __commonJS({
  "../../node_modules/cspell-glob/node_modules/picomatch/lib/constants.js"(exports, module) {
    "use strict";
    init_shim();
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var SEP = "/";
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR,
      SEP
    };
    var WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`,
      SEP: "\\"
    };
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      // regular expressions
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      // Replace globs with equivalent patterns to reduce parsing time.
      REPLACEMENTS: {
        __proto__: null,
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      // Digits
      CHAR_0: 48,
      /* 0 */
      CHAR_9: 57,
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: 65,
      /* A */
      CHAR_LOWERCASE_A: 97,
      /* a */
      CHAR_UPPERCASE_Z: 90,
      /* Z */
      CHAR_LOWERCASE_Z: 122,
      /* z */
      CHAR_LEFT_PARENTHESES: 40,
      /* ( */
      CHAR_RIGHT_PARENTHESES: 41,
      /* ) */
      CHAR_ASTERISK: 42,
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: 38,
      /* & */
      CHAR_AT: 64,
      /* @ */
      CHAR_BACKWARD_SLASH: 92,
      /* \ */
      CHAR_CARRIAGE_RETURN: 13,
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: 94,
      /* ^ */
      CHAR_COLON: 58,
      /* : */
      CHAR_COMMA: 44,
      /* , */
      CHAR_DOT: 46,
      /* . */
      CHAR_DOUBLE_QUOTE: 34,
      /* " */
      CHAR_EQUAL: 61,
      /* = */
      CHAR_EXCLAMATION_MARK: 33,
      /* ! */
      CHAR_FORM_FEED: 12,
      /* \f */
      CHAR_FORWARD_SLASH: 47,
      /* / */
      CHAR_GRAVE_ACCENT: 96,
      /* ` */
      CHAR_HASH: 35,
      /* # */
      CHAR_HYPHEN_MINUS: 45,
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: 60,
      /* < */
      CHAR_LEFT_CURLY_BRACE: 123,
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: 91,
      /* [ */
      CHAR_LINE_FEED: 10,
      /* \n */
      CHAR_NO_BREAK_SPACE: 160,
      /* \u00A0 */
      CHAR_PERCENT: 37,
      /* % */
      CHAR_PLUS: 43,
      /* + */
      CHAR_QUESTION_MARK: 63,
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      /* > */
      CHAR_RIGHT_CURLY_BRACE: 125,
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      /* ] */
      CHAR_SEMICOLON: 59,
      /* ; */
      CHAR_SINGLE_QUOTE: 39,
      /* ' */
      CHAR_SPACE: 32,
      /*   */
      CHAR_TAB: 9,
      /* \t */
      CHAR_UNDERSCORE: 95,
      /* _ */
      CHAR_VERTICAL_LINE: 124,
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      /* \uFEFF */
      /**
       * Create EXTGLOB_CHARS
       */
      extglobChars(chars) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      /**
       * Create GLOB_CHARS
       */
      globChars(win322) {
        return win322 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});

// ../../node_modules/cspell-glob/node_modules/picomatch/lib/utils.js
var require_utils2 = __commonJS({
  "../../node_modules/cspell-glob/node_modules/picomatch/lib/utils.js"(exports) {
    "use strict";
    init_shim();
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants2();
    exports.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports.isRegexChar = (str) => str.length === 1 && exports.hasRegexChars(str);
    exports.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports.isWindows = () => {
      if (typeof navigator !== "undefined" && navigator.platform) {
        const platform = navigator.platform.toLowerCase();
        return platform === "win32" || platform === "windows";
      }
      if (typeof process_browser_default !== "undefined" && process_browser_default.platform) {
        return process_browser_default.platform === "win32";
      }
      return false;
    };
    exports.removeBackslashes = (str) => {
      return str.replace(REGEX_REMOVE_BACKSLASH, (match2) => {
        return match2 === "\\" ? "" : match2;
      });
    };
    exports.escapeLast = (input, char, lastIdx) => {
      const idx2 = input.lastIndexOf(char, lastIdx);
      if (idx2 === -1) return input;
      if (input[idx2 - 1] === "\\") return exports.escapeLast(input, char, idx2 - 1);
      return `${input.slice(0, idx2)}\\${input.slice(idx2)}`;
    };
    exports.removePrefix = (input, state = {}) => {
      let output = input;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
      }
      return output;
    };
    exports.wrapOutput = (input, state = {}, options = {}) => {
      const prepend = options.contains ? "" : "^";
      const append = options.contains ? "" : "$";
      let output = `${prepend}(?:${input})${append}`;
      if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
    exports.basename = (path, { windows } = {}) => {
      const segs = path.split(windows ? /[\\/]/ : "/");
      const last = segs[segs.length - 1];
      if (last === "") {
        return segs[segs.length - 2];
      }
      return last;
    };
  }
});

// ../../node_modules/cspell-glob/node_modules/picomatch/lib/scan.js
var require_scan = __commonJS({
  "../../node_modules/cspell-glob/node_modules/picomatch/lib/scan.js"(exports, module) {
    "use strict";
    init_shim();
    var utils = require_utils2();
    var {
      CHAR_ASTERISK,
      /* * */
      CHAR_AT,
      /* @ */
      CHAR_BACKWARD_SLASH,
      /* \ */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_EXCLAMATION_MARK,
      /* ! */
      CHAR_FORWARD_SLASH,
      /* / */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_PLUS,
      /* + */
      CHAR_QUESTION_MARK,
      /* ? */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_RIGHT_SQUARE_BRACKET
      /* ] */
    } = require_constants2();
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    var scan2 = (input, options) => {
      const opts = options || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index >= length;
      const peek = () => str.charCodeAt(index + 1);
      const advance = () => {
        prev = code;
        return str.charCodeAt(++index);
      };
      while (index < length) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces--;
              if (braces === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished === true) continue;
          if (prev === CHAR_DOT && index === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            isExtglob = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = true;
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base = str;
      let prefix = "";
      let glob = "";
      if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
      } else if (isGlob === true) {
        base = "";
        glob = str;
      } else {
        base = str;
      }
      if (base && base !== "" && base !== "/" && base !== str) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob) glob = utils.removeBackslashes(glob);
        if (base && backslashes === true) {
          base = utils.removeBackslashes(base);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base,
        glob,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx2 = 0; idx2 < slashes.length; idx2++) {
          const n = prevIndex ? prevIndex + 1 : start;
          const i = slashes[idx2];
          const value = input.slice(n, i);
          if (opts.tokens) {
            if (idx2 === 0 && start !== 0) {
              tokens[idx2].isPrefix = true;
              tokens[idx2].value = prefix;
            } else {
              tokens[idx2].value = value;
            }
            depth(tokens[idx2]);
            state.maxDepth += tokens[idx2].depth;
          }
          if (idx2 !== 0 || value !== "") {
            parts.push(value);
          }
          prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts.push(value);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    module.exports = scan2;
  }
});

// ../../node_modules/cspell-glob/node_modules/picomatch/lib/parse.js
var require_parse2 = __commonJS({
  "../../node_modules/cspell-glob/node_modules/picomatch/lib/parse.js"(exports, module) {
    "use strict";
    init_shim();
    var constants2 = require_constants2();
    var utils = require_utils2();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants2;
    var expandRange2 = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value = `[${args.join("-")}]`;
      try {
        new RegExp(value);
      } catch (ex) {
        return args.map((v) => utils.escapeRegex(v)).join("..");
      }
      return value;
    };
    var syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse2 = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = { ...options };
      const max3 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max3) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max3}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const PLATFORM_CHARS = constants2.globChars(opts.windows);
      const EXTGLOB_CHARS = constants2.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces = [];
      const stack = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n = 1) => input[state.index + n];
      const advance = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count2 = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance();
          state.start++;
          count2++;
        }
        if (count2 % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output) append(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.output = (prev.output || prev.value) + tok.value;
          prev.value += tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value2) => {
        const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push({ type, value: value2, output: state.output ? "" : ONE_CHAR });
        push({ type: "paren", extglob: true, value: advance(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            const expression = parse2(rest, { ...options, fastpaths: false }).output;
            output = token.close = `)${expression})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push({ type: "paren", extglob: true, value, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first2, rest, index) => {
          if (first2 === "\\") {
            backslashes = true;
            return m;
          }
          if (first2 === "?") {
            if (esc) {
              return esc + first2 + (rest ? QMARK.repeat(rest.length) : "");
            }
            if (index === 0) {
              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
            }
            return QMARK.repeat(chars.length);
          }
          if (first2 === ".") {
            return DOT_LITERAL.repeat(chars.length);
          }
          if (first2 === "*") {
            if (esc) {
              return esc + first2 + (rest ? star : "");
            }
            return star;
          }
          return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m) => {
              return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils.wrapOutput(output, state, options);
        return state;
      }
      while (!eos()) {
        value = advance();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push({ type: "text", value });
            continue;
          }
          const match2 = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match2 && match2[0].length > 2) {
            slashes = match2[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance();
          } else {
            value += advance();
          }
          if (state.brackets === 0) {
            push({ type: "text", value });
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx2 = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx2);
                const rest2 = prev.value.slice(idx2 + 2);
                const posix3 = POSIX_REGEX_SOURCE[rest2];
                if (posix3) {
                  prev.value = pre + posix3;
                  state.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append({ value });
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils.escapeRegex(value);
          prev.value += value;
          append({ value });
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push({ type: "text", value });
          }
          continue;
        }
        if (value === "(") {
          increment("parens");
          push({ type: "paren", value });
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment("brackets");
          }
          push({ type: "bracket", value });
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append({ value });
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment("braces");
          const open = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open);
          push(open);
          continue;
        }
        if (value === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === true || !brace) {
            push({ type: "text", value, output: value });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range = [];
            for (let i = arr.length - 1; i >= 0; i--) {
              tokens.pop();
              if (arr[i].type === "brace") {
                break;
              }
              if (arr[i].type !== "dots") {
                range.unshift(arr[i].value);
              }
            }
            output = expandRange2(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out;
            for (const t of toks) {
              state.output += t.output || t.value;
            }
          }
          push({ type: "brace", value, output });
          decrement("braces");
          braces.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces[braces.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push({ type: "comma", value, output });
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push({ type: "slash", value, output: SLASH_LITERAL });
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".") prev.output = DOT_LITERAL;
            const brace = braces[braces.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push({ type: "text", value, output: DOT_LITERAL });
            continue;
          }
          push({ type: "dot", value, output: DOT_LITERAL });
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value;
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push({ type: "text", value, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push({ type: "qmark", value, output: QMARK_NO_DOT });
            continue;
          }
          push({ type: "qmark", value, output: QMARK });
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push({ type: "plus", value, output: PLUS_LITERAL });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push({ type: "plus", value });
            continue;
          }
          push({ type: "plus", value: PLUS_LITERAL });
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push({ type: "at", extglob: true, value, output: "" });
            continue;
          }
          push({ type: "text", value });
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match2 = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match2) {
            value += match2[0];
            state.index += match2[0].length;
          }
          push({ type: "text", value });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push({ type: "star", value, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push({ type: "star", value, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token = { type: "star", value, output: star };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value;
          push(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse2.fastpaths = (input, options) => {
      const opts = { ...options };
      const max3 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max3) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max3}`);
      }
      input = REPLACEMENTS[input] || input;
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants2.globChars(opts.windows);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true) return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR}${star}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
          default: {
            const match2 = /^(.*?)\.(\w+)$/.exec(str);
            if (!match2) return;
            const source2 = create(match2[1]);
            if (!source2) return;
            return source2 + DOT_LITERAL + match2[2];
          }
        }
      };
      const output = utils.removePrefix(input, state);
      let source = create(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL}?`;
      }
      return source;
    };
    module.exports = parse2;
  }
});

// ../../node_modules/cspell-glob/node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS({
  "../../node_modules/cspell-glob/node_modules/picomatch/lib/picomatch.js"(exports, module) {
    "use strict";
    init_shim();
    var scan2 = require_scan();
    var parse2 = require_parse2();
    var utils = require_utils2();
    var constants2 = require_constants2();
    var isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch = (glob, options, returnState = false) => {
      if (Array.isArray(glob)) {
        const fns = glob.map((input) => picomatch(input, options, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str);
            if (state2) return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix3 = opts.windows;
      const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const { isMatch, match: match2, output } = picomatch.test(input, regex, options, { glob, posix: posix3 });
        const result = { glob, state, regex, posix: posix3, input, output, match: match2, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state;
      }
      return matcher;
    };
    picomatch.test = (input, regex, options, { glob, posix: posix3 } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options || {};
      const format3 = opts.format || (posix3 ? utils.toPosixSlashes : null);
      let match2 = input === glob;
      let output = match2 && format3 ? format3(input) : input;
      if (match2 === false) {
        output = format3 ? format3(input) : input;
        match2 = output === glob;
      }
      if (match2 === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match2 = picomatch.matchBase(input, regex, options, posix3);
        } else {
          match2 = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match2), match: match2, output };
    };
    picomatch.matchBase = (input, glob, options) => {
      const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
      return regex.test(utils.basename(input));
    };
    picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    picomatch.parse = (pattern, options) => {
      if (Array.isArray(pattern)) return pattern.map((p) => picomatch.parse(p, options));
      return parse2(pattern, { ...options, fastpaths: false });
    };
    picomatch.scan = (input, options) => scan2(input, options);
    picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options || {};
      const prepend = opts.contains ? "" : "^";
      const append = opts.contains ? "" : "$";
      let source = `${prepend}(?:${state.output})${append}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch.toRegex(source, options);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse2.fastpaths(input, options);
      }
      if (!parsed.output) {
        parsed = parse2(input, options);
      }
      return picomatch.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch.toRegex = (source, options) => {
      try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true) throw err;
        return /$^/;
      }
    };
    picomatch.constants = constants2;
    module.exports = picomatch;
  }
});

// ../../node_modules/cspell-glob/node_modules/picomatch/index.js
var require_picomatch2 = __commonJS({
  "../../node_modules/cspell-glob/node_modules/picomatch/index.js"(exports, module) {
    "use strict";
    init_shim();
    var pico = require_picomatch();
    var utils = require_utils2();
    function picomatch(glob, options, returnState = false) {
      if (options && (options.windows === null || options.windows === void 0)) {
        options = { ...options, windows: utils.isWindows() };
      }
      return pico(glob, options, returnState);
    }
    Object.assign(picomatch, pico);
    module.exports = picomatch;
  }
});

// ../../node_modules/node-stdlib-browser/cjs/mock/empty.js
var require_empty = __commonJS({
  "../../node_modules/node-stdlib-browser/cjs/mock/empty.js"(exports, module) {
    "use strict";
    init_shim();
    var empty = null;
    module.exports = empty;
  }
});

// ../../node_modules/os-browserify/browser.js
var require_browser2 = __commonJS({
  "../../node_modules/os-browserify/browser.js"(exports) {
    init_shim();
    exports.endianness = function() {
      return "LE";
    };
    exports.hostname = function() {
      if (typeof location !== "undefined") {
        return location.hostname;
      } else return "";
    };
    exports.loadavg = function() {
      return [];
    };
    exports.uptime = function() {
      return 0;
    };
    exports.freemem = function() {
      return Number.MAX_VALUE;
    };
    exports.totalmem = function() {
      return Number.MAX_VALUE;
    };
    exports.cpus = function() {
      return [];
    };
    exports.type = function() {
      return "Browser";
    };
    exports.release = function() {
      if (typeof navigator !== "undefined") {
        return navigator.appVersion;
      }
      return "";
    };
    exports.networkInterfaces = exports.getNetworkInterfaces = function() {
      return {};
    };
    exports.arch = function() {
      return "javascript";
    };
    exports.platform = function() {
      return "browser";
    };
    exports.tmpdir = exports.tmpDir = function() {
      return "/tmp";
    };
    exports.EOL = "\n";
    exports.homedir = function() {
      return "/";
    };
  }
});

// ../../node_modules/resolve-from/index.js
var require_resolve_from = __commonJS({
  "../../node_modules/resolve-from/index.js"(exports, module) {
    "use strict";
    init_shim();
    var path = (init_path_browserify_win32(), __toCommonJS(path_browserify_win32_exports));
    var Module = require_empty();
    var fs = (init_node_fs(), __toCommonJS(node_fs_exports));
    var resolveFrom2 = (fromDirectory, moduleId, silent) => {
      if (typeof fromDirectory !== "string") {
        throw new TypeError(`Expected \`fromDir\` to be of type \`string\`, got \`${typeof fromDirectory}\``);
      }
      if (typeof moduleId !== "string") {
        throw new TypeError(`Expected \`moduleId\` to be of type \`string\`, got \`${typeof moduleId}\``);
      }
      try {
        fromDirectory = fs.realpathSync(fromDirectory);
      } catch (error) {
        if (error.code === "ENOENT") {
          fromDirectory = path.resolve(fromDirectory);
        } else if (silent) {
          return;
        } else {
          throw error;
        }
      }
      const fromFile = path.join(fromDirectory, "noop.js");
      const resolveFileName = () => Module._resolveFilename(moduleId, {
        id: fromFile,
        filename: fromFile,
        paths: Module._nodeModulePaths(fromDirectory)
      });
      if (silent) {
        try {
          return resolveFileName();
        } catch (error) {
          return;
        }
      }
      return resolveFileName();
    };
    module.exports = (fromDirectory, moduleId) => resolveFrom2(fromDirectory, moduleId);
    module.exports.silent = (fromDirectory, moduleId) => resolveFrom2(fromDirectory, moduleId, true);
  }
});

// src/cspell-bundle-entry.js
init_shim();

// ../../node_modules/cspell-lib/dist/lib/spellCheckFile.js
init_shim();

// src/shims/cspell-config-lib-lite.js
init_shim();
function satisfiesCSpellConfigFile(_value) {
  return false;
}

// ../../node_modules/cspell-lib/dist/lib/Document/isBinaryDoc.js
init_shim();

// ../../node_modules/cspell-lib/dist/lib/fileTypes.js
init_shim();

// ../../node_modules/@cspell/filetypes/dist/index.js
init_shim();

// ../../node_modules/@cspell/filetypes/dist/filetypes.js
init_shim();

// ../../node_modules/@cspell/filetypes/dist/definitions.js
init_shim();
var definitions = [
  { id: "ada", extensions: [".adb", ".ads"] },
  { id: "apiblueprint", extensions: [".apib", ".apiblueprint"] },
  { id: "argdown", extensions: [".ad", ".adown", ".argdn", ".argdown"] },
  { id: "asciidoc", extensions: [".adoc", ".asc", ".asciidoc"] },
  { id: "bat", extensions: [".bat", ".cmd"] },
  { id: "bazel", extensions: [".bazel", ".bzl"] },
  { id: "bibtex", extensions: [".bib"] },
  { id: "bicep", extensions: [".bicep"] },
  { id: "c", extensions: [".c", ".i"] },
  { id: "cache_files", extensions: [], filenames: [".DS_Store", ".cspellcache", ".eslintcache"] },
  { id: "clojure", extensions: [".clj", ".cljc", ".cljs", ".cljx", ".clojure", ".edn"] },
  { id: "cmake", extensions: [".cmake"], filenames: ["CMakeLists.txt"] },
  { id: "codeowners", extensions: [], filenames: ["codeowners"] },
  { id: "coffeescript", extensions: [".coffee", ".cson", ".iced"] },
  {
    id: "cpp",
    extensions: [
      ".c++",
      ".c++m",
      ".cc",
      ".ccm",
      ".cpp",
      ".cppm",
      ".cxx",
      ".cxxm",
      ".h",
      ".h++",
      ".h.in",
      ".hh",
      ".hpp",
      ".hpp.in",
      ".hxx",
      ".ii",
      ".inl",
      ".ino",
      ".ipp",
      ".ixx",
      ".mm",
      ".tpp",
      ".txx"
    ]
  },
  { id: "cpp_embedded_latex", extensions: [] },
  { id: "csharp", extensions: [".cake", ".cs", ".csx"] },
  { id: "css", extensions: [".css"] },
  { id: "cuda-cpp", extensions: [".cu", ".cuh"] },
  { id: "dart", extensions: [".dart"] },
  { id: "dhall", extensions: [".dhall"] },
  { id: "diff", extensions: [".diff", ".patch", ".rej"] },
  { id: "dockercompose", extensions: [], filenames: ["*docker*compose*.yaml", "*docker*compose*.yml", "compose.*.yaml", "compose.*.yml", "compose.yaml", "compose.yml"] },
  {
    id: "dockerfile",
    extensions: [".containerfile", ".dockerfile"],
    filenames: ["*.Dockerfile.*", "Containerfile", "Containerfile.*", "Dockerfile", "Dockerfile.*", "Dockerfile.dev", "dockerfile"]
  },
  { id: "elisp", extensions: [".el"] },
  { id: "elixir", extensions: [".ex", ".exs"] },
  { id: "elm", extensions: [".elm"] },
  { id: "erb", extensions: [".erb", ".html.erb", ".rhtml"] },
  { id: "fsharp", extensions: [".fs", ".fsi", ".fsscript", ".fsx"] },
  { id: "git-commit", extensions: [], filenames: ["COMMIT_EDITMSG", "MERGE_MSG"] },
  { id: "git-rebase", extensions: [], filenames: ["git-rebase-todo"] },
  { id: "github-issues", extensions: [".github-issues"] },
  { id: "go", extensions: [".go"] },
  { id: "godot", extensions: [".gd", ".godot", ".tres", ".tscn"] },
  { id: "gradle", extensions: [".gradle"] },
  { id: "groovy", extensions: [".gradle", ".groovy", ".gvy", ".jenkinsfile", ".nf"], filenames: ["Jenkinsfile", "Jenkinsfile*"] },
  { id: "haml", extensions: [".haml"] },
  { id: "handlebars", extensions: [".handlebars", ".hbs", ".hjs"] },
  { id: "haskell", extensions: [".hs", ".lhs"] },
  { id: "haxe", extensions: [".hx"] },
  { id: "hlsl", extensions: [".cginc", ".compute", ".fx", ".fxh", ".hlsl", ".hlsli", ".psh", ".vsh"] },
  { id: "html", extensions: [".asp", ".aspx", ".ejs", ".htm", ".html", ".jshtm", ".jsp", ".mdoc", ".rhtml", ".shtml", ".volt", ".vue", ".xht", ".xhtml"] },
  { id: "ignore", extensions: [".git-blame-ignore-revs", ".gitignore", ".gitignore_global", ".npmignore"], filenames: [".*ignore"] },
  { id: "ini", extensions: [".conf", ".ini"] },
  { id: "jade", extensions: [".jade", ".pug"] },
  { id: "java", extensions: [".jav", ".java"] },
  { id: "javascript", extensions: [".cjs", ".es6", ".js", ".mjs", ".pac"], filenames: ["jakefile"] },
  { id: "javascriptreact", extensions: [".jsx"] },
  { id: "jinja", extensions: [".j2", ".jinja", ".jinja2"] },
  {
    id: "json",
    extensions: [
      ".babelrc",
      ".bowerrc",
      ".code-profile",
      ".css.map",
      ".eslintrc",
      ".geojson",
      ".har",
      ".ipynb",
      ".js.map",
      ".jscsrc",
      ".jshintrc",
      ".jslintrc",
      ".json",
      ".jsonc",
      ".jsonld",
      ".ts.map",
      ".tsbuildinfo",
      ".vuerc",
      ".webmanifest"
    ],
    filenames: [".watchmanconfig", "composer.lock"]
  },
  {
    id: "jsonc",
    extensions: [
      ".babelrc",
      ".code-workspace",
      ".color-theme.json",
      ".eslintrc",
      ".eslintrc.json",
      ".hintrc",
      ".icon-theme.json",
      ".jsfmtrc",
      ".jshintrc",
      ".jsonc",
      ".language-configuration.json",
      ".swcrc"
    ],
    filenames: [
      ".babelrc.json",
      ".code-workspace",
      ".devcontainer.json",
      ".ember-cli",
      "argv.json",
      "babel.config.json",
      "devcontainer.json",
      "extensions.json",
      "jsconfig-*.json",
      "jsconfig.*.json",
      "jsconfig.json",
      "keybindings.json",
      "launch.json",
      "profiles.json",
      "settings.json",
      "tasks.json",
      "tsconfig-*.json",
      "tsconfig.*.json",
      "tsconfig.json",
      "typedoc.json"
    ]
  },
  { id: "jsonl", extensions: [".jsonl"] },
  { id: "jsx-tags", extensions: [] },
  { id: "julia", extensions: [".jl"] },
  { id: "juliamarkdown", extensions: [".jmd"] },
  { id: "jungle", extensions: [".jungle"] },
  { id: "kotlin", extensions: [".kt"] },
  { id: "latex", extensions: [".ctx", ".ltx", ".tex"] },
  { id: "less", extensions: [".less"] },
  { id: "lisp", extensions: [".fasl", ".l", ".lisp", ".lsp"] },
  { id: "literate haskell", extensions: [".lhs"] },
  { id: "lock", extensions: [".lock"], filenames: ["Cargo.lock", "berksfile.lock", "composer.lock", "package-lock.json"] },
  { id: "log", extensions: [".log"], filenames: ["*.log.?"] },
  { id: "lua", extensions: [".lua"] },
  { id: "makefile", extensions: [".mak", ".mk"], filenames: ["GNUmakefile", "Makefile", "OCamlMakefile", "makefile"] },
  { id: "map", extensions: [".map", ".css.map", ".ts.map", ".js.map"] },
  { id: "markdown", extensions: [".markdn", ".markdown", ".md", ".mdown", ".mdtext", ".mdtxt", ".mdwn", ".mkd", ".workbook"] },
  { id: "markdown_latex_combined", extensions: [] },
  { id: "markdown-math", extensions: [] },
  { id: "mdx", extensions: [".mdx"] },
  { id: "monkeyc", extensions: [".mb", ".mc"] },
  { id: "mustache", extensions: [".mst", ".mu", ".mustache", ".stache"] },
  { id: "nix", extensions: [".nix"] },
  { id: "nunjucks", extensions: [".nj", ".njk", ".nunj", ".nunjs", ".nunjucks", ".tmpl", ".tpl"] },
  { id: "objective-c", extensions: [".m"] },
  { id: "objective-cpp", extensions: [".mm"] },
  { id: "ocaml", extensions: [".eliom", ".eliomi", ".ml", ".mli", ".mll", ".mly"] },
  { id: "pdf", extensions: [".pdf"] },
  { id: "pem", extensions: [".pem", ".private-key.pem"] },
  { id: "pem-private-key", extensions: [".private-key.pem"] },
  { id: "perl", extensions: [".PL", ".pl", ".pm", ".pod", ".psgi", ".t"] },
  { id: "perl6", extensions: [".nqp", ".p6", ".pl6", ".pm6"] },
  { id: "php", extensions: [".ctp", ".php", ".php4", ".php5", ".phtml"] },
  { id: "plaintext", extensions: [".txt"] },
  { id: "powershell", extensions: [".ps1", ".psd1", ".psm1", ".psrc", ".pssc"] },
  {
    id: "properties",
    extensions: [".cfg", ".conf", ".directory", ".editorconfig", ".gitattributes", ".gitconfig", ".gitmodules", ".npmrc", ".properties", ".repo"],
    filenames: [".env", "gitconfig"]
  },
  { id: "protobuf", extensions: [".proto", ".txtpb", ".textproto", ".textpb", ".pbtxt"] },
  { id: "puppet", extensions: [".puppet"] },
  { id: "purescript", extensions: [".purs"] },
  { id: "python", extensions: [".cpy", ".gyp", ".gypi", ".ipy", ".py", ".pyi", ".pyt", ".pyw", ".rpy"], filenames: ["SConscript", "SConstruct"] },
  { id: "r", extensions: [".R", ".r", ".rhistory", ".rprofile", ".rt"] },
  { id: "raku", extensions: [".nqp", ".p6", ".pl6", ".pm6", ".raku", ".rakudoc", ".rakumod", ".rakutest"] },
  { id: "razor", extensions: [".cshtml", ".razor"] },
  { id: "rescript", extensions: [".res", ".resi"] },
  { id: "restructuredtext", extensions: [".rst"] },
  { id: "rsa", extensions: [".pub"], filenames: ["id_rsa", "id_rsa.pub"] },
  {
    id: "ruby",
    extensions: [".erb", ".gemspec", ".podspec", ".rake", ".rb", ".rbi", ".rbx", ".rjs", ".ru"],
    filenames: [
      "Gemfile",
      "appfile",
      "appraisals",
      "berksfile",
      "berksfile.lock",
      "brewfile",
      "capfile",
      "cheffile",
      "dangerfile",
      "deliverfile",
      "fastfile",
      "gemfile",
      "guardfile",
      "gymfile",
      "hobofile",
      "matchfile",
      "podfile",
      "puppetfile",
      "rakefile",
      "rantfile",
      "scanfile",
      "snapfile",
      "thorfile",
      "vagrantfile"
    ]
  },
  { id: "rust", extensions: [".rs"] },
  { id: "sass", extensions: [".sass"] },
  { id: "scala", extensions: [".sbt", ".sc", ".scala"] },
  { id: "scss", extensions: [".scss"] },
  { id: "search-result", extensions: [".code-search"] },
  { id: "shaderlab", extensions: [".cginc", ".shader"] },
  {
    id: "shellscript",
    extensions: [
      ".Xsession",
      ".bash",
      ".bash_aliases",
      ".bash_login",
      ".bash_logout",
      ".bash_profile",
      ".bashrc",
      ".csh",
      ".cshrc",
      ".ebuild",
      ".eclass",
      ".fish",
      ".install",
      ".ksh",
      ".profile",
      ".sh",
      ".tcshrc",
      ".xprofile",
      ".xsession",
      ".xsessionrc",
      ".yash_profile",
      ".yashrc",
      ".zlogin",
      ".zlogout",
      ".zprofile",
      ".zsh",
      ".zsh-theme",
      ".zshenv",
      ".zshrc"
    ],
    filenames: [".env.*", ".envrc", ".hushlogin", "APKBUILD", "PKGBUILD", "bashrc_Apple_Terminal", "zlogin", "zlogout", "zprofile", "zshenv", "zshrc", "zshrc_Apple_Terminal"]
  },
  { id: "snippets", extensions: [".code-snippets"] },
  { id: "sql", extensions: [".dsql", ".sql"] },
  { id: "stylus", extensions: [".styl"] },
  { id: "svelte", extensions: [".svelte"] },
  { id: "swift", extensions: [".swift"] },
  { id: "terraform", extensions: [".hcl", ".tf", ".tf.json", ".tfvars"] },
  { id: "tex", extensions: [".bbx", ".cbx", ".cls", ".sty"] },
  { id: "tfvars", extensions: [".tfvars"], description: "Terraform Variables" },
  { id: "todo", extensions: [], filenames: ["todo"] },
  { id: "toml", extensions: [".toml"], filenames: ["Cargo.lock", "Cargo.toml"] },
  { id: "typescript", extensions: [".cts", ".mts", ".ts"] },
  { id: "typescriptreact", extensions: [".tsx"] },
  { id: "typst", extensions: [".typst"] },
  { id: "vala", extensions: [".vala"] },
  { id: "vb", extensions: [".bas", ".brs", ".vb", ".vba", ".vbs"] },
  { id: "vue", extensions: [".vue"] },
  {
    id: "xml",
    extensions: [
      ".ascx",
      ".atom",
      ".axaml",
      ".axml",
      ".bpmn",
      ".config",
      ".cpt",
      ".csl",
      ".csproj",
      ".csproj.user",
      ".dita",
      ".ditamap",
      ".dtd",
      ".dtml",
      ".ent",
      ".fsproj",
      ".fxml",
      ".iml",
      ".isml",
      ".jmx",
      ".launch",
      ".menu",
      ".mod",
      ".mxml",
      ".nuspec",
      ".opml",
      ".owl",
      ".proj",
      ".props",
      ".pt",
      ".publishsettings",
      ".pubxml",
      ".pubxml.user",
      ".rbxlx",
      ".rbxmx",
      ".rdf",
      ".rng",
      ".rss",
      ".shproj",
      ".storyboard",
      ".svg",
      ".targets",
      ".tld",
      ".tmx",
      ".vbproj",
      ".vbproj.user",
      ".vcxproj",
      ".vcxproj.filters",
      ".wsdl",
      ".wxi",
      ".wxl",
      ".wxs",
      ".xaml",
      ".xbl",
      ".xib",
      ".xlf",
      ".xliff",
      ".xml",
      ".xoml",
      ".xpdl",
      ".xsd",
      ".xul"
    ]
  },
  { id: "xsl", extensions: [".xsl", ".xslt"] },
  { id: "yaml", extensions: [".cff", ".eyaml", ".eyml", ".yaml", ".yaml-tmlanguage", ".yaml-tmpreferences", ".yaml-tmtheme", ".yml"] },
  { id: "binary", extensions: [".bin", ".cur", ".dll", ".eot", ".exe", ".gz", ".lib", ".o", ".obj", ".phar", ".zip"], format: "Binary" },
  { id: "dll", extensions: [".dll"], format: "Binary" },
  { id: "exe", extensions: [".exe"], format: "Binary" },
  { id: "fonts", extensions: [".ttf", ".woff", ".woff2"], format: "Binary" },
  { id: "gzip", extensions: [".gz"], format: "Binary" },
  {
    id: "image",
    extensions: [".bmp", ".exr", ".gif", ".heic", ".ico", ".jpeg", ".jpg", ".pbm", ".pgm", ".png", ".ppm", ".ras", ".sgi", ".tiff", ".webp", ".xbm"],
    format: "Binary",
    description: "Some image extensions"
  },
  { id: "jar", extensions: [".jar"], format: "Binary" },
  { id: "mdb", extensions: [".mdb"], format: "Binary", description: "Microsoft Access DB" },
  { id: "object-file", extensions: [".o", ".obj"], format: "Binary" },
  { id: "spv", extensions: [".spv"], format: "Binary", description: "SPSS Output Document" },
  { id: "trie", extensions: [".trie"], format: "Binary", description: "CSpell dictionary file." },
  { id: "video", extensions: [".avi", ".flv", ".mkv", ".mov", ".mp4", ".mpeg", ".mpg", ".wmv"], format: "Binary" },
  { id: "webm", extensions: [".webm"], format: "Binary", description: "WebM is an audiovisual media file format." },
  { id: "wheel", extensions: [".whl"], format: "Binary" },
  { id: "zig", extensions: [".zig"], description: "Zig programming language" },
  { id: "zon", extensions: [".zon"], description: "Zig programming language package file" }
];

// ../../node_modules/@cspell/filetypes/dist/filetypes.js
var binaryFormatIds = definitions.filter((d) => d.format === "Binary").map((d) => d.id);
var binaryLanguages = /* @__PURE__ */ new Set(["binary", "image", "video", "fonts", ...binaryFormatIds]);
var generatedFiles = /* @__PURE__ */ new Set([
  ...binaryLanguages,
  "map",
  "lock",
  "pdf",
  "cache_files",
  "rsa",
  "pem",
  "trie",
  "log"
]);
var languageIds = definitions.map(({ id }) => id);
var mapExtensionToSetOfLanguageIds = buildLanguageExtensionMapSet(definitions);
var mapExtensionToLanguageIds = buildExtensionToLanguageIdMap(mapExtensionToSetOfLanguageIds);
var idsWithRegExp = definitions.map(defToRegExp).filter((f) => !!f);
function isFileTypeGenerated(fileTypeId) {
  return doesSetContainAnyOf(generatedFiles, fileTypeId);
}
function doesSetContainAnyOf(setOfIds, fileTypeId) {
  if (typeof fileTypeId === "string") {
    return setOfIds.has(fileTypeId);
  }
  for (const id of fileTypeId) {
    if (setOfIds.has(id)) {
      return true;
    }
  }
  return false;
}
function buildLanguageExtensionMapSet(defs) {
  return defs.reduce((map2, def) => {
    var _a19;
    function addId(value) {
      autoResolve(map2, value, () => /* @__PURE__ */ new Set()).add(def.id);
    }
    def.extensions.forEach(addId);
    (_a19 = def.filenames) == null ? void 0 : _a19.forEach((filename) => typeof filename === "string" ? addId(filename) : void 0);
    return map2;
  }, /* @__PURE__ */ new Map());
}
function buildExtensionToLanguageIdMap(map2) {
  return new Map([...map2].map(([k, s]) => [k, [...s]]));
}
function matchPatternsToFilename(basename4) {
  return idsWithRegExp.filter(({ regexp }) => regexp.test(basename4)).map(({ id }) => id);
}
function _getLanguagesForBasename(basename4) {
  const found = mapExtensionToLanguageIds.get(basename4);
  if (found)
    return found;
  const patternMatches = matchPatternsToFilename(basename4);
  if (patternMatches.length)
    return patternMatches;
  for (let pos = basename4.indexOf("."); pos >= 0; pos = basename4.indexOf(".", pos + 1)) {
    const ids = mapExtensionToLanguageIds.get(basename4.slice(pos));
    if (ids)
      return ids;
  }
  return void 0;
}
function findMatchingFileTypes(filename) {
  filename = basename(filename);
  return _getLanguagesForBasename(filename) || _getLanguagesForBasename(filename.toLowerCase()) || [];
}
var regExpPathSep = /[\\/]/g;
function basename(filename) {
  return regExpPathSep.test(filename) ? filename.split(regExpPathSep).slice(-1).join("") : filename;
}
function autoResolve(map2, key, resolve2) {
  const found = map2.get(key);
  if (found !== void 0 || map2.has(key))
    return found;
  const value = resolve2(key);
  map2.set(key, value);
  return value;
}
function escapeRegEx(s) {
  return s.replaceAll(/[|\\{}()[\]^$+*?.]/g, "\\$&").replaceAll("-", "\\x2d");
}
function stringOrGlob(s) {
  return s.includes("*") ? simpleGlob(s) : s;
}
function simpleGlob(s) {
  s = s.replaceAll("**", "*");
  let pattern = "";
  for (const char of s) {
    switch (char) {
      case "?": {
        pattern += ".";
        break;
      }
      case "*": {
        pattern += ".*";
        break;
      }
      default: {
        pattern += escapeRegEx(char);
      }
    }
  }
  return new RegExp(pattern);
}
function defToRegExp(def) {
  if (!def.filenames)
    return void 0;
  const regExps = def.filenames.map(stringOrGlob).map((f) => f instanceof RegExp ? f : void 0).filter((f) => !!f);
  if (!regExps.length)
    return void 0;
  const regexp = new RegExp(regExps.map((r) => r.source).join("|"));
  return { regexp, id: def.id };
}

// ../../node_modules/cspell-lib/dist/lib/util/Uri.js
init_shim();
var import_node_assert3 = __toESM(require_assert(), 1);

// ../../node_modules/@cspell/url/dist/index.js
init_shim();
var import_node_assert = __toESM(require_assert(), 1);
init_path_browserify_win32();
var import_node_url = __toESM(require_url(), 1);
var isURLRegEx = /^(\w[\w-]{1,63}:\/|data:|stdin:)/i;
function toURL(url, relativeTo) {
  return normalizeWindowsUrl(url instanceof URL ? url : new URL(url, relativeTo));
}
function urlParent(url) {
  url = toURL(url);
  if (url.protocol === "data:") return url;
  const hasTrailingSlash = url.pathname.endsWith("/");
  if (!url.pathname.startsWith("/")) {
    if (!url.pathname) return url;
    const pathname = url.pathname.split("/").slice(0, hasTrailingSlash ? -2 : -1).join("/") + "/";
    return new URL(url.protocol + (url.host ? "//" + url.host : "") + pathname + url.search + url.hash);
  }
  return new URL(hasTrailingSlash ? ".." : ".", url);
}
function basenameOfUrlPathname(path) {
  const adj = path.endsWith("/") ? 2 : 0;
  const idx2 = path.lastIndexOf("/", path.length - adj);
  return idx2 >= 0 ? path.slice(idx2 + 1) : path;
}
function isUrlLike(filename) {
  return filename instanceof URL || isURLRegEx.test(filename);
}
function hasProtocol(url, protocol) {
  protocol = protocol.endsWith(":") ? protocol : protocol + ":";
  return typeof url === "string" ? url.startsWith(protocol) : url.protocol === protocol;
}
function addTrailingSlash(url) {
  if (url.pathname.endsWith("/")) return url;
  const urlWithSlash = new URL(url.href);
  urlWithSlash.pathname += "/";
  return urlWithSlash;
}
function urlToUrlRelative(urlFrom, urlTo) {
  let pFrom = urlFrom.pathname;
  const pTo = urlTo.pathname;
  if (pFrom === pTo) return "";
  pFrom = pFrom.endsWith("/") ? pFrom : new URL("./", urlFrom).pathname;
  if (pTo.startsWith(pFrom)) return decodeURIComponent(pTo.slice(pFrom.length));
  const p0 = pFrom;
  const p1 = pTo;
  if (p1.startsWith(p0)) return decodeURIComponent(p0 === p1 ? "" : p1.slice(p0.lastIndexOf("/") + 1));
  const p0Parts = p0.split("/").slice(0, -1);
  const p1Parts = p1.split("/");
  let i = 0;
  for (i = 0; i < p0Parts.length && i < p1Parts.length - 1 && p0Parts[i] === p1Parts[i]; ++i) ;
  const rel = "../".repeat(p0Parts.length - i) + p1Parts.slice(i).join("/");
  return decodeURIComponent(rel.length < p1.length ? rel : p1);
}
var regExpWindowsPath = /^[\\/]([a-zA-Z]:[\\/])/;
var badUncLocalhostUrl = /^(\/+[a-zA-Z])\$/;
function normalizeWindowsUrl(url) {
  url = typeof url === "string" ? new URL(url) : url;
  if (url.protocol === "file:") {
    let pathname = url.pathname.replaceAll("%3A", ":").replaceAll("%3a", ":").replaceAll("%24", "$");
    if (!url.host) pathname = pathname.replace(badUncLocalhostUrl, "$1:");
    pathname = pathname.replace(regExpWindowsPath, (d) => d.toUpperCase());
    if (pathname !== url.pathname) {
      url = new URL(url);
      url.pathname = pathname;
      return fixUncUrl(url);
    }
  }
  return fixUncUrl(url);
}
function fixUncUrl(url) {
  if (url.href.startsWith("file:////")) return new URL(url.href.replace(/^file:\/{4}/, "file://"));
  return url;
}
var regMatchFilename = /filename=([^;,]*)/;
function urlBasename(url) {
  function guessDataUrlName(header) {
    const filenameMatch = header.match(regMatchFilename);
    if (filenameMatch) return filenameMatch[1];
    return header.split(";", 1)[0].replaceAll(/\W/g, ".");
  }
  url = toURL(url);
  if (url.protocol === "data:") return guessDataUrlName(url.pathname.split(",", 1)[0]);
  return basenameOfUrlPathname(url.pathname);
}
var isWindows = process_browser_default.platform === "win32";
var windowsUrlPathRegExp = /^\/[a-zA-Z]:\//;
function isWindowsPathnameWithDriveLatter(pathname) {
  return windowsUrlPathRegExp.test(pathname);
}
function isFileURL(url) {
  return hasProtocol(url, "file:");
}
function toFilePathOrHref(url) {
  return isFileURL(url) && url.toString().startsWith("file:///") ? toFilePath(url) : url.toString();
}
function toFilePath(url) {
  try {
    if (isWindows) {
      const u = new URL(url);
      if (!isWindowsPathnameWithDriveLatter(u.pathname)) {
        const cwdUrl = (0, import_node_url.pathToFileURL)(process_browser_default.cwd());
        if (cwdUrl.hostname) return (0, import_node_url.fileURLToPath)(new URL(u.pathname, cwdUrl));
        u.pathname = `/${cwdUrl.pathname.split("/")[1]}${u.pathname}`;
        return (0, import_node_url.fileURLToPath)(u);
      }
    }
    return pathWindowsDriveLetterToUpper((0, import_node_url.fileURLToPath)(url));
  } catch {
    return url.toString();
  }
}
var regExpWindowsPathDriveLetter = /^([a-zA-Z]):[\\/]/;
function pathWindowsDriveLetterToUpper(absoluteFilePath) {
  return absoluteFilePath.replace(regExpWindowsPathDriveLetter, (s) => s.toUpperCase());
}
var regExpWindowsFileUrl = /^file:\/\/\/[a-zA-Z]:\//;
function isWindowsFileUrl(url) {
  return regExpWindowsFileUrl.test(url.toString());
}
var isWindowsPathRegEx = regExpWindowsPathDriveLetter;
var isWindowsPathname = regExpWindowsPath;
var percentRegEx = /%/g;
var backslashRegEx = /\\/g;
var newlineRegEx = /\n/g;
var carriageReturnRegEx = /\r/g;
var tabRegEx = /\t/g;
var questionRegex = /\?/g;
var hashRegex = /#/g;
var ProtocolFile = "file:";
var _FileUrlBuilder_instances, toFileURL_fn, urlToFilePathOrHref_fn, getFsRootURL_fn, _a;
var FileUrlBuilder = (_a = class {
  constructor(options = {}) {
    __privateAdd(this, _FileUrlBuilder_instances);
    __publicField(this, "windows");
    __publicField(this, "path");
    __publicField(this, "cwd");
    var _a19, _b2, _c, _d, _e, _f, _g, _h, _i;
    const sep2 = (_a19 = options.path) == null ? void 0 : _a19.sep;
    this.windows = (_c = (_b2 = options.windows) != null ? _b2 : sep2 ? sep2 === "\\" : void 0) != null ? _c : isWindows;
    this.path = (_d = options.path) != null ? _d : this.windows ? path_browserify_win32_default.win32 : path_browserify_win32_default.posix;
    this.cwd = (_e = options.cwd) != null ? _e : this.pathToFileURL(this.path.resolve() + "/", this.rootFileURL());
    (0, import_node_assert.default)(this.path.sep === (this.windows ? "\\" : "/"), `Path separator should match OS type Windows: ${this.windows === true ? "true" : ((_f = this.windows) != null ? _f : "undefined") || "false"}, sep: ${this.path.sep}, options: ` + JSON.stringify({
      isWindows,
      sep: `${sep2}`,
      windows: options.windows,
      pathSep: (_g = options.path) == null ? void 0 : _g.sep,
      n: (_h = options.path) == null ? void 0 : _h.normalize("path/file.txt"),
      cwd: (_i = options.cwd) == null ? void 0 : _i.href,
      win32: this.path === path_browserify_win32_default.win32,
      posix: this.path === path_browserify_win32_default.posix,
      "win32.normalize": this.path.normalize === path_browserify_win32_default.win32.normalize,
      "posix.normalize": this.path.normalize === path_browserify_win32_default.posix.normalize
    }));
  }
  /**
  * Encode special characters in a file path to use in a URL.
  * @param filepath
  * @returns
  */
  encodePathChars(filepath) {
    filepath = filepath.replaceAll(percentRegEx, "%25");
    if (!this.windows && !isWindows && filepath.includes("\\")) filepath = filepath.replaceAll(backslashRegEx, "%5C");
    filepath = filepath.replaceAll(newlineRegEx, "%0A");
    filepath = filepath.replaceAll(carriageReturnRegEx, "%0D");
    filepath = filepath.replaceAll(tabRegEx, "%09");
    return filepath;
  }
  /**
  * Normalize a file path for use in a URL.
  * ```js
  * const url = new URL(normalizeFilePathForUrl('path\\to\\file.txt'), 'file:///Users/user/');
  * // Result: file:///Users/user/path/to/file.txt
  * ```
  * @param filePath
  * @returns a normalized file path for use as a relative path in a URL.
  */
  normalizeFilePathForUrl(filePath) {
    filePath = this.encodePathChars(filePath);
    filePath = filePath.replaceAll(questionRegex, "%3F");
    filePath = filePath.replaceAll(hashRegex, "%23");
    return filePath.replaceAll("\\", "/").replace(isWindowsPathRegEx, (drive) => `/${drive}`.toUpperCase());
  }
  /**
  * Try to make a file URL.
  * - if filenameOrUrl is already a URL, it is returned as is.
  * @param filenameOrUrl
  * @param relativeTo - optional URL, if given, filenameOrUrl will be parsed as relative.
  * @returns a URL
  */
  toFileURL(filenameOrUrl, relativeTo) {
    return normalizeWindowsUrl(__privateMethod(this, _FileUrlBuilder_instances, toFileURL_fn).call(this, filenameOrUrl, relativeTo));
  }
  /**
  * Try to make a URL for a directory.
  * - if dirOrUrl is already a URL, a slash is appended to the pathname.
  * @param dirOrUrl - directory path to convert to a file URL.
  * @param relativeTo - optional URL, if given, filenameOrUrl will be parsed as relative.
  * @returns a URL
  */
  toFileDirURL(dirOrUrl, relativeTo) {
    return addTrailingSlash(this.toFileURL(dirOrUrl, relativeTo));
  }
  urlToFilePathOrHref(url) {
    url = this.toFileURL(url);
    return __privateMethod(this, _FileUrlBuilder_instances, urlToFilePathOrHref_fn).call(this, url);
  }
  /**
  * Calculate the relative path to go from `urlFrom` to `urlTo`.
  * The protocol is not evaluated. Only the `url.pathname` is used.
  * The result: `new URL(relative(urlFrom, urlTo), urlFrom).pathname === urlTo.pathname`
  * @param urlFrom
  * @param urlTo
  * @returns the relative path
  */
  relative(urlFrom, urlTo) {
    if (urlFrom.protocol === urlTo.protocol && urlFrom.protocol === ProtocolFile) {
      if (urlFrom.href === urlTo.href) return "";
      urlFrom = urlFrom.pathname.endsWith("/") ? urlFrom : new URL("./", urlFrom);
      const fromPath = urlFrom.pathname;
      const toPath = urlTo.pathname;
      if (toPath.startsWith(fromPath)) return decodeURIComponent(toPath.slice(fromPath.length));
      const pFrom = __privateMethod(this, _FileUrlBuilder_instances, urlToFilePathOrHref_fn).call(this, urlFrom);
      const pTo = __privateMethod(this, _FileUrlBuilder_instances, urlToFilePathOrHref_fn).call(this, urlTo);
      const toIsDir = urlTo.pathname.endsWith("/");
      let pathname = this.normalizeFilePathForUrl(this.path.relative(pFrom, pTo));
      if (toIsDir && !pathname.endsWith("/")) pathname += "/";
      return decodeURIComponent(pathname);
    }
    return decodeURIComponent(urlToUrlRelative(urlFrom, urlTo));
  }
  /**
  * Get the parent directory of a URL.
  * @param url
  */
  urlDirname(url) {
    return urlParent(this.toFileURL(url));
  }
  pathToFileURL(pathname, relativeToURL) {
    return new URL(this.normalizeFilePathForUrl(pathname), relativeToURL || this.cwd);
  }
  rootFileURL(filePath) {
    const path = this.path;
    const p = path.parse(path.normalize(path.resolve(filePath != null ? filePath : ".")));
    return new URL(this.normalizeFilePathForUrl(p.root), __privateMethod(this, _FileUrlBuilder_instances, getFsRootURL_fn).call(this));
  }
  /**
  * Determine if a filePath is absolute.
  *
  * @param filePath
  * @returns true if `URL` or `path.isAbsolute(filePath)`
  */
  isAbsolute(filePath) {
    return isUrlLike(filePath) || this.path.isAbsolute(filePath);
  }
  isUrlLike(url) {
    return isUrlLike(url);
  }
}, _FileUrlBuilder_instances = new WeakSet(), /**
* Try to make a file URL.
* - if filenameOrUrl is already a URL, it is returned as is.
* @param filenameOrUrl
* @param relativeTo - optional URL, if given, filenameOrUrl will be parsed as relative.
* @returns a URL
*/
toFileURL_fn = function(filenameOrUrl, relativeTo) {
  if (typeof filenameOrUrl !== "string") return filenameOrUrl;
  if (isUrlLike(filenameOrUrl)) return normalizeWindowsUrl(new URL(filenameOrUrl));
  relativeTo != null ? relativeTo : relativeTo = this.cwd;
  isWindows && (filenameOrUrl = filenameOrUrl.replaceAll("\\", "/"));
  if (this.isAbsolute(filenameOrUrl) && isFileURL(relativeTo)) {
    const pathname2 = this.normalizeFilePathForUrl(filenameOrUrl);
    if (isWindowsFileUrl(relativeTo) && !isWindowsPathnameWithDriveLatter(pathname2)) {
      const relFilePrefix = relativeTo.toString().slice(0, 10);
      return normalizeWindowsUrl(new URL(relFilePrefix + pathname2));
    }
    return normalizeWindowsUrl(new URL("file://" + pathname2));
  }
  if (isUrlLike(relativeTo)) {
    const pathname2 = this.normalizeFilePathForUrl(filenameOrUrl);
    return normalizeWindowsUrl(new URL(pathname2, relativeTo));
  }
  const appendSlash = filenameOrUrl.endsWith("/") ? "/" : "";
  const pathname = this.normalizeFilePathForUrl(this.path.resolve(relativeTo.toString(), filenameOrUrl)) + appendSlash;
  return normalizeWindowsUrl(new URL("file://" + pathname));
}, urlToFilePathOrHref_fn = function(url) {
  if (url.protocol !== ProtocolFile || url.hostname) return url.href;
  return pathWindowsDriveLetterToUpper((this.path === path_browserify_win32_default ? toFilePathOrHref(url) : decodeURIComponent(url.pathname.split("/").join(this.path.sep))).replace(isWindowsPathname, "$1"));
}, getFsRootURL_fn = function() {
  if (this.path === path_browserify_win32_default) return (0, import_node_url.pathToFileURL)("/");
  const p = this.path.resolve("/");
  return new URL(this.normalizeFilePathForUrl(p), "file:///");
}, _a);
var fileUrlBuilder = new FileUrlBuilder();
function toFileURL(filenameOrUrl, relativeTo) {
  return fileUrlBuilder.toFileURL(filenameOrUrl, relativeTo);
}
function toFileDirURL(dir) {
  return fileUrlBuilder.toFileDirURL(dir);
}

// ../../node_modules/cspell-io/dist/index.js
init_shim();
var import_node_buffer = __toESM(require_buffer(), 1);
var zlib = __toESM(require_lib2(), 1);
var import_node_zlib = __toESM(require_lib2(), 1);

// ../../node_modules/@cspell/cspell-service-bus/dist/esm/index.js
init_shim();

// ../../node_modules/@cspell/cspell-service-bus/dist/esm/bus.js
init_shim();

// ../../node_modules/@cspell/cspell-service-bus/dist/esm/errors.js
init_shim();
var ErrorUnhandledRequest = class extends Error {
  constructor(request) {
    super(`Unhandled Request: ${request.type}`);
    __publicField(this, "request");
    this.request = request;
  }
};
var ErrorServiceRequestDepthExceeded = class extends Error {
  constructor(request, depth) {
    super(`Service Request Depth ${depth} Exceeded: ${request.type}`);
    __publicField(this, "request");
    __publicField(this, "depth");
    this.request = request;
    this.depth = depth;
  }
};
var UnhandledHandlerError = class extends Error {
  constructor(handlerName, handlerDescription, cause) {
    super(`Unhandled Error in Handler: ${handlerName}`);
    __publicField(this, "handlerName");
    __publicField(this, "handlerDescription");
    __publicField(this, "cause");
    this.handlerName = handlerName;
    this.handlerDescription = handlerDescription;
    this.cause = cause;
  }
};

// ../../node_modules/@cspell/cspell-service-bus/dist/esm/request.js
init_shim();
var BaseServiceRequest = class {
  constructor(type, params) {
    __publicField(this, "type");
    __publicField(this, "params");
    __publicField(this, "__r");
    this.type = type;
    this.params = params;
  }
};
var ServiceRequestCls = class extends BaseServiceRequest {
  constructor(type, params) {
    super(type, params);
  }
};
function createResponse(value, _req) {
  return { value };
}
function createResponseFail(_request, error) {
  return { error };
}
function isServiceResponseSuccess(res) {
  return "value" in res && res.error === void 0;
}

// ../../node_modules/@cspell/cspell-service-bus/dist/esm/bus.js
var MAX_DEPTH = 10;
var ServiceBus = class {
  constructor(handlers2 = []) {
    __publicField(this, "handlers", []);
    handlers2.forEach((h) => this.addHandler(h));
  }
  addHandler(handler, name = "anonymous", description) {
    const h = typeof handler === "function" ? { fn: handler, name, description } : handler;
    const { fn, name: _name, description: _description } = h;
    this.handlers.push({ fn, name: _name, description: _description });
    return this;
  }
  dispatch(request) {
    let depth = 0;
    const dispatcher = { dispatch };
    const handler = this.reduceHandlers(this.handlers, request, dispatcher, this.defaultHandler);
    function dispatch(request2) {
      ++depth;
      if (depth >= MAX_DEPTH) {
        return createResponseFail(request2, new ErrorServiceRequestDepthExceeded(request2, depth));
      }
      const response = handler(request2);
      --depth;
      return response;
    }
    return dispatch(request);
  }
  defaultHandler(request) {
    return createResponseFail(request, new ErrorUnhandledRequest(request));
  }
  reduceHandlers(handlers2, request, dispatcher, defaultHandler) {
    const _handlers = handlers2.map((m) => ({ ...m, fn: m.fn(dispatcher) }));
    const handler = _handlers.reduce((next, h) => {
      const fn = h.fn(next);
      return (req) => {
        try {
          return fn(req);
        } catch (e) {
          return createResponseFail(request, new UnhandledHandlerError(h.name, h.description, e));
        }
      };
    }, defaultHandler);
    return handler;
  }
};

// ../../node_modules/@cspell/cspell-service-bus/dist/esm/createRequestHandler.js
init_shim();
function createRequestHandler(requestDef, fn, name, description) {
  return createIsRequestHandler(requestDef.is, fn, name != null ? name : requestDef.type, description);
}
function createIsRequestHandlerFn(isA, fn) {
  return (dispatcher) => (next) => (request) => isA(request) ? fn(request, next, dispatcher) : next(request);
}
function createIsRequestHandler(isA, fn, name, description) {
  return {
    fn: createIsRequestHandlerFn(isA, fn),
    name,
    description
  };
}

// ../../node_modules/@cspell/cspell-service-bus/dist/esm/requestFactory.js
init_shim();
function requestFactory(requestType) {
  const _RequestClass = class _RequestClass extends ServiceRequestCls {
    constructor(params) {
      super(requestType, params);
    }
    static is(req) {
      return req instanceof _RequestClass && req.type === requestType;
    }
    static create(params) {
      return new _RequestClass(params);
    }
    static createRequestHandler(fn, name, description) {
      return createRequestHandler(_RequestClass, fn, name, description);
    }
  };
  __publicField(_RequestClass, "type", requestType);
  __publicField(_RequestClass, "__request");
  let RequestClass = _RequestClass;
  return RequestClass;
}

// ../../node_modules/cspell-io/dist/index.js
init_node_fs();
init_node_fs();
var import_node_url2 = __toESM(require_url(), 1);
var import_node_util = __toESM(require_util(), 1);
var Stream2 = __toESM(require_stream_browserify(), 1);
var import_node_assert2 = __toESM(require_assert(), 1);
var CFileReference = class CFileReference2 {
  constructor(url, encoding, baseFilename, gz) {
    /**
    * Use to ensure the nominal type separation between CFileReference and FileReference
    * See: https://github.com/microsoft/TypeScript/wiki/FAQ#when-and-why-are-classes-nominal
    */
    __publicField(this, "_");
    __publicField(this, "gz");
    var _a19;
    this.url = url;
    this.encoding = encoding;
    this.baseFilename = baseFilename;
    this.gz = (_a19 = gz != null ? gz : (baseFilename == null ? void 0 : baseFilename.endsWith(".gz")) || void 0) != null ? _a19 : url.pathname.endsWith(".gz") || void 0;
  }
  static isCFileReference(obj) {
    return obj instanceof CFileReference2;
  }
  static from(fileReference, encoding, baseFilename, gz) {
    if (CFileReference2.isCFileReference(fileReference)) return fileReference;
    if (fileReference instanceof URL) return new CFileReference2(fileReference, encoding, baseFilename, gz);
    return new CFileReference2(fileReference.url, fileReference.encoding, fileReference.baseFilename, fileReference.gz);
  }
  toJson() {
    return {
      url: this.url.href,
      encoding: this.encoding,
      baseFilename: this.baseFilename,
      gz: this.gz
    };
  }
};
function toFileReference(file, encoding, baseFilename, gz) {
  const fileReference = typeof file === "string" ? toFileURL(file) : file;
  if (fileReference instanceof URL) return new CFileReference(fileReference, encoding, baseFilename, gz);
  return CFileReference.from(fileReference);
}
function isFileReference(ref) {
  return CFileReference.isCFileReference(ref) || !(ref instanceof URL) && typeof ref !== "string";
}
function toFileResourceRequest(file, encoding, signal) {
  const fileReference = typeof file === "string" ? toFileURL(file) : file;
  if (fileReference instanceof URL) return {
    url: fileReference,
    encoding,
    signal
  };
  return {
    url: fileReference.url,
    encoding: encoding != null ? encoding : fileReference.encoding,
    signal
  };
}
var ErrorNotImplemented = class extends Error {
  constructor(method, options) {
    super(`Method ${method} is not supported.`, options);
    this.method = method;
  }
};
var AssertionError = class extends Error {
  constructor(message, options) {
    super(message, options);
    this.message = message;
  }
};
function assert$1(value, message) {
  if (!value) throw new AssertionError(message != null ? message : "Assertion failed");
}
function toUint8Array(data) {
  if (data instanceof Uint8Array) return data;
  return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
}
function arrayBufferViewToBuffer(data) {
  if (data instanceof import_node_buffer.Buffer) return data;
  return import_node_buffer.Buffer.from(data.buffer, data.byteOffset, data.byteLength);
}
function copyArrayBufferView(data) {
  return new Uint8Array(data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength));
}
function swap16(data) {
  arrayBufferViewToBuffer(data).swap16();
  return data;
}
function swapBytes(data) {
  return swap16(copyArrayBufferView(data));
}
var BOM_BE = 65279;
var BOM_LE = 65534;
var decoderUTF8 = new TextDecoder("utf8");
var decoderUTF16LE = new TextDecoder("utf-16le");
var decoderUTF16BE = createTextDecoderUtf16BE();
var encoderUTF8 = new TextEncoder();
function decodeUtf16LE(data) {
  const buf = toUint8Array(data);
  const bom = buf[0] << 8 | buf[1];
  return decoderUTF16LE.decode(bom === BOM_LE ? buf.subarray(2) : buf);
}
function decodeUtf16BE(data) {
  const buf = toUint8Array(data);
  const bom = buf[0] << 8 | buf[1];
  return decoderUTF16BE.decode(bom === BOM_BE ? buf.subarray(2) : buf);
}
function decodeToString(data, encoding) {
  if (isGZipped(data)) return decodeToString(decompressBuffer(data), encoding);
  const buf = toUint8Array(data);
  const bom = buf[0] << 8 | buf[1];
  if (bom === BOM_BE || buf[0] === 0 && buf[1] !== 0) return decodeUtf16BE(buf);
  if (bom === BOM_LE || buf[0] !== 0 && buf[1] === 0) return decodeUtf16LE(buf);
  if (!encoding) return decoderUTF8.decode(buf);
  switch (encoding) {
    case "utf-16be":
    case "utf16be":
      return decodeUtf16BE(buf);
    case "utf-16le":
    case "utf16le":
      return decodeUtf16LE(buf);
    case "utf-8":
    case "utf8":
      return decoderUTF8.decode(buf);
  }
  throw new UnsupportedEncodingError(encoding);
}
function decode(data, encoding) {
  switch (encoding) {
    case "base64":
    case "base64url":
    case "hex":
      return arrayBufferViewToBuffer(data).toString(encoding);
  }
  return decodeToString(data, encoding);
}
function encodeString$1(str, encoding, bom) {
  switch (encoding) {
    case void 0:
    case "utf-8":
    case "utf8":
      return encoderUTF8.encode(str);
    case "utf-16be":
    case "utf16be":
      return encodeUtf16BE(str, bom);
    case "utf-16le":
    case "utf16le":
      return encodeUtf16LE(str, bom);
  }
  return import_node_buffer.Buffer.from(str, encoding);
}
function encodeUtf16LE(str, bom = true) {
  const buf = import_node_buffer.Buffer.from(str, "utf16le");
  if (bom) {
    const target = import_node_buffer.Buffer.alloc(buf.length + 2);
    target.writeUint16LE(BOM_BE);
    buf.copy(target, 2);
    return target;
  }
  return buf;
}
function encodeUtf16BE(str, bom = true) {
  return swap16(encodeUtf16LE(str, bom));
}
function createTextDecoderUtf16BE() {
  try {
    return new TextDecoder("utf-16be");
  } catch {
    return {
      encoding: "utf-16be",
      fatal: false,
      ignoreBOM: false,
      decode: (input) => decoderUTF16LE.decode(swapBytes(input))
    };
  }
}
var UnsupportedEncodingError = class extends Error {
  constructor(encoding) {
    super(`Unsupported encoding: ${encoding}`);
  }
};
function isGZipped(data) {
  if (typeof data === "string") return false;
  const buf = toUint8Array(data);
  return buf[0] === 31 && buf[1] === 139;
}
function decompressBuffer(data) {
  if (!isGZipped(data)) return data;
  return (0, import_node_zlib.gunzipSync)(arrayBufferViewToBuffer(data));
}
async function decompress(data, method = "gzip") {
  const ds = new DecompressionStream(method || "deflate-raw");
  const writer = ds.writable.getWriter();
  writer.write(data);
  writer.close();
  const reader = ds.readable.getReader();
  const chunks = [];
  let size = 0;
  while (true) {
    const chunk = await reader.read();
    if (chunk.done) break;
    chunks.push(chunk.value);
    size += chunk.value.length;
  }
  const result = new Uint8Array(size);
  for (let offset = 0, i = 0; i < chunks.length; i++) {
    result.set(chunks[i], offset);
    offset += chunks[i].length;
  }
  return result;
}
var _gz, _text, _data, _a2;
var CFileResource = (_a2 = class {
  constructor(url, content, encoding, baseFilename, gz) {
    __publicField(this, "baseFilename");
    __publicField(this, "url");
    __publicField(this, "content");
    __publicField(this, "encoding");
    __privateAdd(this, _gz);
    __privateAdd(this, _text);
    __privateAdd(this, _data);
    this.url = url;
    this.content = content;
    this.encoding = encoding;
    this.baseFilename = baseFilename != null ? baseFilename : url.protocol !== "data:" && url.pathname.split("/").pop() || void 0;
    __privateSet(this, _gz, gz);
  }
  get gz() {
    if (__privateGet(this, _gz) !== void 0) return __privateGet(this, _gz);
    if (this.url.pathname.endsWith(".gz")) return true;
    if (typeof this.content === "string") return false;
    return isGZipped(this.content);
  }
  getText(encoding) {
    if (__privateGet(this, _text) !== void 0) return __privateGet(this, _text);
    const text = typeof this.content === "string" ? this.content : decode(this.content, encoding != null ? encoding : this.encoding);
    __privateSet(this, _text, text);
    return text;
  }
  async getBytes(unzip) {
    if (unzip !== false && __privateGet(this, _data) !== void 0) return __privateGet(this, _data);
    if (typeof this.content === "string") {
      __privateSet(this, _data, encodeString$1(this.content, this.encoding));
      return __privateGet(this, _data);
    }
    if (unzip != null ? unzip : isGZipped(this.content)) {
      __privateSet(this, _data, await decompress(this.content, "gzip"));
      return __privateGet(this, _data);
    }
    return this.content;
  }
  toJson() {
    return {
      url: this.url.href,
      content: this.getText(),
      encoding: this.encoding,
      baseFilename: this.baseFilename,
      gz: this.gz
    };
  }
  static isCFileResource(obj) {
    return obj instanceof _a2;
  }
  static from(urlOrFileResource, content, encoding, baseFilename, gz) {
    if (_a2.isCFileResource(urlOrFileResource)) {
      if (content) {
        const { url, encoding: encoding2, baseFilename: baseFilename2, gz: gz2 } = urlOrFileResource;
        return new _a2(url, content, encoding2, baseFilename2, gz2);
      }
      return urlOrFileResource;
    }
    if (urlOrFileResource instanceof URL) {
      assert$1(content !== void 0);
      return new _a2(urlOrFileResource, content, encoding, baseFilename, gz);
    }
    if (content !== void 0) {
      const fileRef = urlOrFileResource;
      return new _a2(fileRef.url, content, fileRef.encoding, fileRef.baseFilename, fileRef.gz);
    }
    assert$1("content" in urlOrFileResource && urlOrFileResource.content !== void 0);
    const fileResource = urlOrFileResource;
    return new _a2(fileResource.url, fileResource.content, fileResource.encoding, fileResource.baseFilename, fileResource.gz);
  }
}, _gz = new WeakMap(), _text = new WeakMap(), _data = new WeakMap(), _a2);
function fromFileResource(fileResource, encoding) {
  return CFileResource.from(encoding ? {
    ...fileResource,
    encoding
  } : fileResource);
}
function compareStats(left, right) {
  if (left === right) return 0;
  if (left.eTag || right.eTag) return left.eTag === right.eTag ? 0 : (left.eTag || "") < (right.eTag || "") ? -1 : 1;
  const diff = left.size - right.size || left.mtimeMs - right.mtimeMs;
  return diff < 0 ? -1 : diff > 0 ? 1 : 0;
}
function urlOrReferenceToUrl(urlOrReference) {
  return urlOrReference instanceof URL ? urlOrReference : urlOrReference.url;
}
function toReadFileOptions(options) {
  if (!options) return options;
  if (typeof options === "string") return { encoding: options };
  return options;
}
function toError$1(e) {
  if (e instanceof Error) return e;
  if (typeof e === "object" && e && "message" in e && typeof e.message === "string") return new Error(e.message, { cause: e });
  return new Error(e && e.toString());
}
var FileType = /* @__PURE__ */ (function(FileType2) {
  FileType2[FileType2["Unknown"] = 0] = "Unknown";
  FileType2[FileType2["File"] = 1] = "File";
  FileType2[FileType2["Directory"] = 2] = "Directory";
  FileType2[FileType2["SymbolicLink"] = 64] = "SymbolicLink";
  return FileType2;
})({});
function encodeDataUrl(data, mediaType, attributes) {
  if (typeof data === "string") return encodeString(data, mediaType, attributes);
  return `data:${mediaType}${encodeAttributes(attributes || [])};base64,${arrayBufferViewToBuffer(data).toString("base64url")}`;
}
function toDataUrl(data, mediaType, attributes) {
  return new URL(encodeDataUrl(data, mediaType, attributes));
}
function encodeString(data, mediaType, attributes) {
  mediaType = mediaType || "text/plain";
  attributes = attributes || [];
  const asUrlComp = encodeURIComponent(data);
  const asBase64 = import_node_buffer.Buffer.from(data).toString("base64url");
  const useBase64 = asBase64.length < asUrlComp.length - 7;
  const encoded = useBase64 ? asBase64 : asUrlComp;
  const attribMap = new Map([["charset", "utf-8"], ...attributes]);
  attribMap.set("charset", "utf-8");
  const attribs = encodeAttributes(attribMap);
  return `data:${mediaType}${attribs}${useBase64 ? ";base64" : ""},${encoded}`;
}
function encodeAttributes(attributes) {
  return [...attributes].map(([key, value]) => `;${key}=${encodeURIComponent(value)}`).join("");
}
var dataUrlRegExHead = /^data:(?<mediaType>[^;,]*)(?<attributes>(?:;[^=]+=[^;,]*)*)(?<base64>;base64)?$/;
function decodeDataUrl(url) {
  url = url.toString();
  const [head, encodedData] = url.split(",", 2);
  if (!head || encodedData === void 0) throw new Error("Not a data url");
  const match2 = head.match(dataUrlRegExHead);
  if (!match2 || !match2.groups) throw new Error("Not a data url");
  const mediaType = match2.groups["mediaType"] || "";
  const rawAttributes = (match2.groups["attributes"] || "").split(";").filter((a) => !!a).map((entry) => entry.split("=", 2)).map(([key, value]) => [key, decodeURIComponent(value)]);
  const attributes = new Map(rawAttributes);
  const encoding = attributes.get("charset");
  return {
    mediaType,
    data: !!match2.groups["base64"] ? import_node_buffer.Buffer.from(encodedData, "base64url") : import_node_buffer.Buffer.from(decodeURIComponent(encodedData)),
    encoding,
    attributes
  };
}
function guessMimeType(filename) {
  if (filename.endsWith(".trie")) return {
    mimeType: "application/vnd.cspell.dictionary+trie",
    encoding: "utf-8"
  };
  if (filename.endsWith(".trie.gz")) return { mimeType: "application/vnd.cspell.dictionary+trie.gz" };
  if (filename.endsWith(".txt")) return {
    mimeType: "text/plain",
    encoding: "utf-8"
  };
  if (filename.endsWith(".txt.gz")) return { mimeType: "application/gzip" };
  if (filename.endsWith(".gz")) return { mimeType: "application/gzip" };
  if (filename.endsWith(".json")) return {
    mimeType: "application/json",
    encoding: "utf-8"
  };
  if (filename.endsWith(".yaml") || filename.endsWith(".yml")) return {
    mimeType: "application/x-yaml",
    encoding: "utf-8"
  };
}
var _fetch = globalThis.fetch;
var FetchUrlError = class FetchUrlError2 extends Error {
  constructor(message, code, status, url) {
    super(message);
    this.code = code;
    this.status = status;
    this.url = url;
    this.name = "FetchUrlError";
  }
  static create(url, status, message) {
    if (status === 404) return new FetchUrlError2(message || "URL not found.", "ENOENT", status, url);
    if (status >= 400 && status < 500) return new FetchUrlError2(message || "Permission denied.", "EACCES", status, url);
    return new FetchUrlError2(message || "Fatal Error", "ECONNREFUSED", status, url);
  }
  static fromError(url, e) {
    const cause = getCause(e);
    if (cause) return new FetchUrlError2(cause.message, cause.code, void 0, url);
    if (isNodeError(e)) return new FetchUrlError2(e.message, e.code, void 0, url);
    return new FetchUrlError2(e.message, void 0, void 0, url);
  }
};
function isNodeError(e) {
  if (e instanceof Error && "code" in e && typeof e.code === "string") return true;
  if (e && typeof e === "object" && "code" in e && typeof e.code === "string") return true;
  return false;
}
function isError(e) {
  return e instanceof Error;
}
function isErrorWithOptionalCause(e) {
  return isError(e) && (!("cause" in e) || isNodeError(e.cause) || isNodeError(e));
}
function getCause(e) {
  return isErrorWithOptionalCause(e) ? e.cause : void 0;
}
function toFetchUrlError(err, url) {
  return err instanceof FetchUrlError ? err : FetchUrlError.fromError(url, toError(err));
}
function toError(err) {
  return err instanceof Error ? err : new Error("Unknown Error", { cause: err });
}
async function fetchHead(request) {
  const url = toURL$1(request);
  try {
    const r = await _fetch(url, { method: "HEAD" });
    if (!r.ok) throw FetchUrlError.create(url, r.status);
    return r.headers;
  } catch (e) {
    throw toFetchUrlError(e, url);
  }
}
async function fetchURL(url, signal) {
  try {
    const response = await _fetch(signal ? new Request(url, { signal }) : url);
    if (!response.ok) throw FetchUrlError.create(url, response.status);
    return await response.bytes();
  } catch (e) {
    throw toFetchUrlError(e, url);
  }
}
function toURL$1(url) {
  return typeof url === "string" ? new URL(url) : url;
}
async function getStatHttp(url) {
  const headers = await fetchHead(url);
  const eTag = headers.get("etag") || void 0;
  const guessSize = Number.parseInt(headers.get("content-length") || "0", 10);
  return {
    size: eTag ? -1 : guessSize,
    mtimeMs: 0,
    eTag
  };
}
var RequestType$4 = "fs:readFile";
var RequestFsReadFile = requestFactory(RequestType$4);
var RequestType$3 = "fs:readFileSync";
var RequestFsReadFileTextSync = requestFactory(RequestType$3);
var RequestTypeStat = "fs:stat";
var RequestFsStat = requestFactory(RequestTypeStat);
var RequestTypeStatSync = "fs:statSync";
var RequestFsStatSync = requestFactory(RequestTypeStatSync);
var RequestType$2 = "fs:writeFile";
var RequestFsWriteFile = requestFactory(RequestType$2);
var RequestType$1 = "zlib:inflate";
var RequestZlibInflate = requestFactory(RequestType$1);
var RequestType = "fs:readDir";
var RequestFsReadDirectory = requestFactory(RequestType);
var isGzFileRegExp = /\.gz($|[?#])/;
function isGzFile(url) {
  return isGzFileRegExp.test(typeof url === "string" ? url : url.pathname);
}
var pGzip = (0, import_node_util.promisify)(import_node_zlib.gzip);
var handleRequestFsReadFile = RequestFsReadFile.createRequestHandler(({ params }) => {
  const baseFilename = urlBasename(params.url);
  return createResponse(promises.readFile((0, import_node_url2.fileURLToPath)(params.url)).then((content) => CFileResource.from(params.url, content, params.encoding, baseFilename)));
}, void 0, "Node: Read Binary File.");
var handleRequestFsReadFileSync = RequestFsReadFileTextSync.createRequestHandler(({ params }) => createResponse(CFileResource.from({
  ...params,
  content: readFileSync((0, import_node_url2.fileURLToPath)(params.url))
})), void 0, "Node: Sync Read Binary File.");
var handleRequestFsReadDirectory = RequestFsReadDirectory.createRequestHandler(({ params }) => {
  return createResponse(promises.readdir((0, import_node_url2.fileURLToPath)(params.url), { withFileTypes: true }).then((entries) => direntToDirEntries(params.url, entries)));
}, void 0, "Node: Read Directory.");
var handleRequestZlibInflate = RequestZlibInflate.createRequestHandler(({ params }) => createResponse((0, import_node_zlib.gunzipSync)(arrayBufferViewToBuffer(params.data))), void 0, "Node: gz deflate.");
var supportedFetchProtocols = {
  "http:": true,
  "https:": true
};
var handleRequestFsReadFileHttp = RequestFsReadFile.createRequestHandler((req, next) => {
  const { url, signal, encoding } = req.params;
  if (!(url.protocol in supportedFetchProtocols)) return next(req);
  return createResponse(fetchURL(url, signal).then((content) => CFileResource.from({
    url,
    encoding,
    content
  })));
}, void 0, "Node: Read Http(s) file.");
var handleRequestFsReadFileSyncData = RequestFsReadFileTextSync.createRequestHandler((req, next) => {
  const { url, encoding } = req.params;
  if (url.protocol !== "data:") return next(req);
  const data = decodeDataUrl(url);
  return createResponse(CFileResource.from({
    url,
    content: data.data,
    encoding,
    baseFilename: data.attributes.get("filename")
  }));
}, void 0, "Node: Read data: urls.");
var handleRequestFsReadFileData = RequestFsReadFile.createRequestHandler((req, next, dispatcher) => {
  const { url } = req.params;
  if (url.protocol !== "data:") return next(req);
  const res = dispatcher.dispatch(RequestFsReadFileTextSync.create(req.params));
  if (!isServiceResponseSuccess(res)) return res;
  return createResponse(Promise.resolve(res.value));
}, void 0, "Node: Read data: urls.");
var handleRequestFsStat = RequestFsStat.createRequestHandler(({ params }) => createResponse(toPromiseStats(promises.stat((0, import_node_url2.fileURLToPath)(params.url)))), void 0, "Node: fs.stat.");
function toStats(stat) {
  return {
    size: stat.size,
    mtimeMs: stat.mtimeMs,
    fileType: toFileType(stat)
  };
}
function toPromiseStats(pStat) {
  return pStat.then(toStats);
}
var handleRequestFsStatSync = RequestFsStatSync.createRequestHandler((req) => {
  const { params } = req;
  try {
    return createResponse(statSync((0, import_node_url2.fileURLToPath)(params.url)));
  } catch (e) {
    return createResponseFail(req, toError$1(e));
  }
}, void 0, "Node: fs.stat.");
var handleRequestFsStatHttp = RequestFsStat.createRequestHandler((req, next) => {
  const { url } = req.params;
  if (!(url.protocol in supportedFetchProtocols)) return next(req);
  return createResponse(getStatHttp(url));
}, void 0, "Node: http get stat");
var handleRequestFsWriteFile = RequestFsWriteFile.createRequestHandler(({ params }) => createResponse(writeFile(params, params.content)), void 0, "Node: fs.writeFile");
async function writeFile(fileRef, content) {
  const gz = isGZipped(content);
  const { url, encoding, baseFilename } = fileRef;
  const resultRef = {
    url,
    encoding,
    baseFilename,
    gz
  };
  await promises.writeFile((0, import_node_url2.fileURLToPath)(fileRef.url), encodeContent(fileRef, content));
  return resultRef;
}
var handleRequestFsWriteFileDataUrl = RequestFsWriteFile.createRequestHandler((req, next) => {
  const fileResource = req.params;
  const { url } = req.params;
  if (url.protocol !== "data:") return next(req);
  const gz = isGZipped(fileResource.content);
  const baseFilename = fileResource.baseFilename || "file.txt" + (gz ? ".gz" : "");
  const mt = guessMimeType(baseFilename);
  const mediaType = (mt == null ? void 0 : mt.mimeType) || "text/plain";
  const dataUrl = toDataUrl(fileResource.content, mediaType, [["filename", baseFilename]]);
  return createResponse(Promise.resolve({
    url: dataUrl,
    baseFilename,
    gz,
    encoding: mt == null ? void 0 : mt.encoding
  }));
}, void 0, "Node: fs.writeFile DataUrl");
var handleRequestFsWriteFileGz = RequestFsWriteFile.createRequestHandler((req, next, dispatcher) => {
  const fileResource = req.params;
  if (!fileResource.gz && !isGzFile(fileResource.url) && (!fileResource.baseFilename || !isGzFile(fileResource.baseFilename))) return next(req);
  if (typeof fileResource.content !== "string" && isGZipped(fileResource.content)) return next(req);
  return createResponse(compressAndChainWriteRequest(dispatcher, fileResource, fileResource.content));
}, void 0, "Node: fs.writeFile compressed");
async function compressAndChainWriteRequest(dispatcher, fileRef, content) {
  const buf = await pGzip(encodeContent(fileRef, content));
  const res = dispatcher.dispatch(RequestFsWriteFile.create({
    ...fileRef,
    content: buf
  }));
  assert$1(isServiceResponseSuccess(res));
  return res.value;
}
function registerHandlers(serviceBus) {
  [
    handleRequestFsReadFile,
    handleRequestFsReadFileSync,
    handleRequestFsWriteFile,
    handleRequestFsWriteFileDataUrl,
    handleRequestFsWriteFileGz,
    handleRequestFsReadFileHttp,
    handleRequestFsReadFileData,
    handleRequestFsReadFileSyncData,
    handleRequestFsReadDirectory,
    handleRequestZlibInflate,
    handleRequestFsStatSync,
    handleRequestFsStat,
    handleRequestFsStatHttp
  ].forEach((handler) => serviceBus.addHandler(handler));
}
function encodeContent(ref, content) {
  if (typeof content === "string") {
    if ([
      void 0,
      "utf8",
      "utf-8"
    ].includes(ref.encoding)) return content;
    return arrayBufferViewToBuffer(encodeString$1(content, ref.encoding));
  }
  return arrayBufferViewToBuffer(content);
}
function mapperDirentToDirEntry(dir) {
  return (dirent) => direntToDirEntry(dir, dirent);
}
function direntToDirEntries(dir, dirent) {
  return dirent.map(mapperDirentToDirEntry(dir));
}
function direntToDirEntry(dir, dirent) {
  return {
    name: dirent.name,
    dir,
    fileType: toFileType(dirent)
  };
}
function toFileType(statLike) {
  const t = statLike.isFile() ? FileType.File : statLike.isDirectory() ? FileType.Directory : FileType.Unknown;
  return statLike.isSymbolicLink() ? t | FileType.SymbolicLink : t;
}
var defaultCSpellIONode = void 0;
var CSpellIONode = class {
  constructor(serviceBus = new ServiceBus()) {
    this.serviceBus = serviceBus;
    registerHandlers(serviceBus);
  }
  readFile(urlOrFilename, options) {
    const readOptions = toReadFileOptions(options);
    const ref = toFileResourceRequest(urlOrFilename, readOptions == null ? void 0 : readOptions.encoding, readOptions == null ? void 0 : readOptions.signal);
    const res = this.serviceBus.dispatch(RequestFsReadFile.create(ref));
    if (!isServiceResponseSuccess(res)) throw genError(res.error, "readFile");
    return res.value;
  }
  readDirectory(urlOrFilename) {
    const ref = toFileReference(urlOrFilename);
    const res = this.serviceBus.dispatch(RequestFsReadDirectory.create(ref));
    if (!isServiceResponseSuccess(res)) throw genError(res.error, "readDirectory");
    return res.value;
  }
  readFileSync(urlOrFilename, encoding) {
    const ref = toFileReference(urlOrFilename, encoding);
    const res = this.serviceBus.dispatch(RequestFsReadFileTextSync.create(ref));
    if (!isServiceResponseSuccess(res)) throw genError(res.error, "readFileSync");
    return res.value;
  }
  writeFile(urlOrFilename, content) {
    const ref = toFileReference(urlOrFilename);
    const fileResource = CFileResource.from(ref, content);
    const res = this.serviceBus.dispatch(RequestFsWriteFile.create(fileResource));
    if (!isServiceResponseSuccess(res)) throw genError(res.error, "writeFile");
    return res.value;
  }
  getStat(urlOrFilename) {
    const ref = toFileReference(urlOrFilename);
    const res = this.serviceBus.dispatch(RequestFsStat.create(ref));
    if (!isServiceResponseSuccess(res)) throw genError(res.error, "getStat");
    return res.value;
  }
  getStatSync(urlOrFilename) {
    const ref = toFileReference(urlOrFilename);
    const res = this.serviceBus.dispatch(RequestFsStatSync.create(ref));
    if (!isServiceResponseSuccess(res)) throw genError(res.error, "getStatSync");
    return res.value;
  }
  compareStats(left, right) {
    return compareStats(left, right);
  }
  toURL(urlOrFilename, relativeTo) {
    if (isFileReference(urlOrFilename)) return urlOrFilename.url;
    return toURL(urlOrFilename, relativeTo);
  }
  toFileURL(urlOrFilename, relativeTo) {
    if (isFileReference(urlOrFilename)) return urlOrFilename.url;
    return toFileURL(urlOrFilename, relativeTo);
  }
  urlBasename(urlOrFilename) {
    return urlBasename(this.toURL(urlOrFilename));
  }
  urlDirname(urlOrFilename) {
    return urlParent(this.toURL(urlOrFilename));
  }
};
function genError(err, alt) {
  return err || new ErrorNotImplemented(alt);
}
function getDefaultCSpellIO() {
  if (defaultCSpellIONode) return defaultCSpellIONode;
  const cspellIO = new CSpellIONode();
  defaultCSpellIONode = cspellIO;
  return cspellIO;
}
var debug = false;
async function findUpFromUrl(name, from, options) {
  const { type: entryType = "file", stopAt, fs } = options;
  let dir = new URL(".", from);
  const root = new URL("/", dir);
  const predicate = makePredicate(fs, name, entryType);
  const stopAtHrefs = new Set((Array.isArray(stopAt) ? stopAt : [stopAt || root]).map((p) => new URL(".", p).href));
  let last = "";
  while (dir.href !== last) {
    const found = await predicate(dir);
    if (found !== void 0) return found;
    last = dir.href;
    if (dir.href === root.href || stopAtHrefs.has(dir.href)) break;
    dir = new URL("..", dir);
  }
}
function makePredicate(fs, name, entryType) {
  if (typeof name === "function") return name;
  const checkStat = entryType === "file" || entryType === "!file" ? "isFile" : "isDirectory";
  const checkValue = entryType.startsWith("!") ? false : true;
  function checkName(dir, name2) {
    const f = new URL(name2, dir);
    return fs.stat(f).then((stats) => (stats.isUnknown() || stats[checkStat]() === checkValue) && f || void 0).catch(() => void 0);
  }
  if (!Array.isArray(name)) return (dir) => checkName(dir, name);
  return async (dir) => {
    const pending = name.map((n) => checkName(dir, n));
    for (const p of pending) {
      const found = await p;
      if (found) return found;
    }
  };
}
var _core, _a3;
var CVFileSystem = (_a3 = class {
  constructor(core) {
    __privateAdd(this, _core);
    __publicField(this, "readFile");
    __publicField(this, "writeFile");
    __publicField(this, "stat");
    __publicField(this, "readDirectory");
    __publicField(this, "getCapabilities");
    __privateSet(this, _core, core);
    this.readFile = __privateGet(this, _core).readFile.bind(__privateGet(this, _core));
    this.writeFile = __privateGet(this, _core).writeFile.bind(__privateGet(this, _core));
    this.stat = __privateGet(this, _core).stat.bind(__privateGet(this, _core));
    this.readDirectory = __privateGet(this, _core).readDirectory.bind(__privateGet(this, _core));
    this.getCapabilities = __privateGet(this, _core).getCapabilities.bind(__privateGet(this, _core));
  }
  get providerInfo() {
    return __privateGet(this, _core).providerInfo;
  }
  get hasProvider() {
    return __privateGet(this, _core).hasProvider;
  }
  findUp(name, from, options = {}) {
    return findUpFromUrl(name, from, {
      ...options,
      fs: __privateGet(this, _core)
    });
  }
}, _core = new WeakMap(), _a3);
var FSCapabilityFlags = /* @__PURE__ */ (function(FSCapabilityFlags2) {
  FSCapabilityFlags2[FSCapabilityFlags2["None"] = 0] = "None";
  FSCapabilityFlags2[FSCapabilityFlags2["Stat"] = 1] = "Stat";
  FSCapabilityFlags2[FSCapabilityFlags2["Read"] = 2] = "Read";
  FSCapabilityFlags2[FSCapabilityFlags2["Write"] = 4] = "Write";
  FSCapabilityFlags2[FSCapabilityFlags2["ReadWrite"] = 6] = "ReadWrite";
  FSCapabilityFlags2[FSCapabilityFlags2["ReadDir"] = 8] = "ReadDir";
  FSCapabilityFlags2[FSCapabilityFlags2["WriteDir"] = 16] = "WriteDir";
  FSCapabilityFlags2[FSCapabilityFlags2["ReadWriteDir"] = 24] = "ReadWriteDir";
  return FSCapabilityFlags2;
})({});
function cspellIOToFsProvider(cspellIO) {
  const capabilities = FSCapabilityFlags.Stat | FSCapabilityFlags.ReadWrite | FSCapabilityFlags.ReadDir;
  const capabilitiesHttp = capabilities & ~FSCapabilityFlags.Write & ~FSCapabilityFlags.ReadDir;
  const capMap = {
    "file:": capabilities,
    "http:": capabilitiesHttp,
    "https:": capabilitiesHttp
  };
  const name = "CSpellIO";
  const supportedProtocols = /* @__PURE__ */ new Set([
    "file:",
    "http:",
    "https:"
  ]);
  const fs = {
    providerInfo: { name },
    stat: (url) => cspellIO.getStat(url),
    readFile: (url, options) => cspellIO.readFile(url, options),
    readDirectory: (url) => cspellIO.readDirectory(url),
    writeFile: (file) => cspellIO.writeFile(file.url, file.content),
    dispose: () => void 0,
    capabilities,
    getCapabilities(url) {
      return fsCapabilities(capMap[url.protocol] || FSCapabilityFlags.None);
    }
  };
  return {
    name,
    getFileSystem: (url, _next) => {
      return supportedProtocols.has(url.protocol) ? fs : void 0;
    }
  };
}
function wrapError(e) {
  if (e instanceof VFSError) return e;
  return e;
}
var VFSError = class extends Error {
  constructor(message, options) {
    super(message, options);
  }
};
var VFSErrorUnsupportedRequest = class extends VFSError {
  constructor(request, url, parameters) {
    super(`Unsupported request: ${request}`);
    __publicField(this, "url");
    this.request = request;
    this.parameters = parameters;
    this.url = url == null ? void 0 : url.toString();
  }
};
var CFsCapabilities = class {
  constructor(flags) {
    this.flags = flags;
  }
  get readFile() {
    return !!(this.flags & FSCapabilityFlags.Read);
  }
  get writeFile() {
    return !!(this.flags & FSCapabilityFlags.Write);
  }
  get readDirectory() {
    return !!(this.flags & FSCapabilityFlags.ReadDir);
  }
  get writeDirectory() {
    return !!(this.flags & FSCapabilityFlags.WriteDir);
  }
  get stat() {
    return !!(this.flags & FSCapabilityFlags.Stat);
  }
};
function fsCapabilities(flags) {
  return new CFsCapabilities(flags);
}
var WrappedProviderFs = class WrappedProviderFs2 {
  constructor(fs, eventLogger) {
    __publicField(this, "hasProvider");
    __publicField(this, "capabilities");
    __publicField(this, "providerInfo");
    __publicField(this, "_capabilities");
    this.fs = fs;
    this.eventLogger = eventLogger;
    this.hasProvider = !!fs;
    this.capabilities = (fs == null ? void 0 : fs.capabilities) || FSCapabilityFlags.None;
    this._capabilities = fsCapabilities(this.capabilities);
    this.providerInfo = (fs == null ? void 0 : fs.providerInfo) || { name: "unknown" };
  }
  logEvent(method, event, traceID, url, message) {
    this.eventLogger({
      method,
      event,
      url,
      traceID,
      ts: performance.now(),
      message
    });
  }
  getCapabilities(url) {
    var _a19;
    if ((_a19 = this.fs) == null ? void 0 : _a19.getCapabilities) return this.fs.getCapabilities(url);
    return this._capabilities;
  }
  async stat(urlRef) {
    const traceID = performance.now();
    const url = urlOrReferenceToUrl(urlRef);
    this.logEvent("stat", "start", traceID, url);
    try {
      checkCapabilityOrThrow(this.fs, this.capabilities, FSCapabilityFlags.Stat, "stat", url);
      return new CVfsStat(await this.fs.stat(urlRef));
    } catch (e) {
      this.logEvent("stat", "error", traceID, url, e instanceof Error ? e.message : "");
      throw wrapError(e);
    } finally {
      this.logEvent("stat", "end", traceID, url);
    }
  }
  async readFile(urlRef, optionsOrEncoding) {
    const traceID = performance.now();
    const url = urlOrReferenceToUrl(urlRef);
    this.logEvent("readFile", "start", traceID, url);
    try {
      checkCapabilityOrThrow(this.fs, this.capabilities, FSCapabilityFlags.Read, "readFile", url);
      const readOptions = toOptions(optionsOrEncoding);
      return fromFileResource(await this.fs.readFile(urlRef, readOptions), readOptions == null ? void 0 : readOptions.encoding);
    } catch (e) {
      this.logEvent("readFile", "error", traceID, url, e instanceof Error ? e.message : "");
      throw wrapError(e);
    } finally {
      this.logEvent("readFile", "end", traceID, url);
    }
  }
  async readDirectory(url) {
    const traceID = performance.now();
    this.logEvent("readDir", "start", traceID, url);
    try {
      checkCapabilityOrThrow(this.fs, this.capabilities, FSCapabilityFlags.ReadDir, "readDirectory", url);
      return (await this.fs.readDirectory(url)).map((e) => new CVfsDirEntry(e));
    } catch (e) {
      this.logEvent("readDir", "error", traceID, url, e instanceof Error ? e.message : "");
      throw wrapError(e);
    } finally {
      this.logEvent("readDir", "end", traceID, url);
    }
  }
  async writeFile(file) {
    const traceID = performance.now();
    const url = file.url;
    this.logEvent("writeFile", "start", traceID, url);
    try {
      checkCapabilityOrThrow(this.fs, this.capabilities, FSCapabilityFlags.Write, "writeFile", file.url);
      return await this.fs.writeFile(file);
    } catch (e) {
      this.logEvent("writeFile", "error", traceID, url, e instanceof Error ? e.message : "");
      throw wrapError(e);
    } finally {
      this.logEvent("writeFile", "end", traceID, url);
    }
  }
  static disposeOf(fs) {
    var _a19;
    fs instanceof WrappedProviderFs2 && ((_a19 = fs.fs) == null ? void 0 : _a19.dispose());
  }
};
function checkCapabilityOrThrow(fs, capabilities, flag, name, url) {
  if (!(capabilities & flag)) throw new VFSErrorUnsupportedRequest(name, url);
}
var CFileType = class {
  constructor(fileType) {
    this.fileType = fileType;
  }
  isFile() {
    return this.fileType === FileType.File;
  }
  isDirectory() {
    return this.fileType === FileType.Directory;
  }
  isUnknown() {
    return !this.fileType;
  }
  isSymbolicLink() {
    return !!(this.fileType & FileType.SymbolicLink);
  }
};
var CVfsStat = class extends CFileType {
  constructor(stat) {
    super(stat.fileType || FileType.Unknown);
    this.stat = stat;
  }
  get size() {
    return this.stat.size;
  }
  get mtimeMs() {
    return this.stat.mtimeMs;
  }
  get eTag() {
    return this.stat.eTag;
  }
};
var CVfsDirEntry = class extends CFileType {
  constructor(entry) {
    super(entry.fileType);
    __publicField(this, "_url");
    this.entry = entry;
  }
  get name() {
    return this.entry.name;
  }
  get dir() {
    return this.entry.dir;
  }
  get url() {
    if (this._url) return this._url;
    this._url = new URL(this.entry.name, this.entry.dir);
    return this._url;
  }
  toJSON() {
    return {
      name: this.name,
      dir: this.dir,
      fileType: this.fileType
    };
  }
};
function chopUrl(url) {
  if (!url) return "";
  const href = url.href;
  const parts = href.split("/");
  const n = parts.indexOf("node_modules");
  if (n > 0) {
    const tail = parts.slice(Math.max(parts.length - 3, n + 1));
    return parts.slice(0, n + 1).join("/") + "/\u2026/" + tail.join("/");
  }
  return href;
}
function rPad(str, len, ch = " ") {
  return str.padEnd(len, ch);
}
function toOptions(val) {
  return typeof val === "string" ? { encoding: val } : val;
}
var CVirtualFS = class {
  constructor() {
    __publicField(this, "providers", /* @__PURE__ */ new Set());
    __publicField(this, "cachedFs", /* @__PURE__ */ new Map());
    __publicField(this, "revCacheFs", /* @__PURE__ */ new Map());
    __publicField(this, "fsc");
    __publicField(this, "fs");
    __publicField(this, "loggingEnabled", debug);
    __publicField(this, "log", console.log);
    __publicField(this, "logEvent", (event) => {
      if (this.loggingEnabled) {
        const id = event.traceID.toFixed(13).replaceAll(/\d{4}(?=\d)/g, "$&.");
        const msg = event.message ? `
		${event.message}` : "";
        const method = rPad(`${event.method}-${event.event}`, 16);
        this.log(`${method} ID:${id} ts:${event.ts.toFixed(13)} ${chopUrl(event.url)}${msg}`);
      }
    });
    this.fsc = fsPassThroughCore((url) => this._getFS(url));
    this.fs = new CVFileSystem(this.fsc);
  }
  enableLogging(value) {
    this.loggingEnabled = value != null ? value : true;
  }
  registerFileSystemProvider(...providers) {
    providers.forEach((provider) => this.providers.add(provider));
    this.reset();
    return { dispose: () => {
      for (const provider of providers) {
        for (const key of this.revCacheFs.get(provider) || []) this.cachedFs.delete(key);
        this.providers.delete(provider);
      }
      this.reset();
    } };
  }
  getFS(url) {
    return new CVFileSystem(this._getFS(url));
  }
  _getFS(url) {
    const key = `${url.protocol}${url.hostname}`;
    const cached = this.cachedFs.get(key);
    if (cached) return cached;
    const fnNext = (provider, next2) => {
      return (url2) => {
        let calledNext = false;
        const fs2 = provider.getFileSystem(url2, (_url) => {
          calledNext = calledNext || url2 === _url;
          return next2(_url);
        });
        if (fs2) {
          const s = this.revCacheFs.get(provider) || /* @__PURE__ */ new Set();
          s.add(key);
          this.revCacheFs.set(provider, s);
          return fs2;
        }
        if (!calledNext) return next2(url2);
      };
    };
    let next = (_url) => void 0;
    for (const provider of this.providers) next = fnNext(provider, next);
    const fs = new WrappedProviderFs(next(url), this.logEvent);
    this.cachedFs.set(key, fs);
    return fs;
  }
  reset() {
    this.disposeOfCachedFs();
  }
  disposeOfCachedFs() {
    for (const [key, fs] of [...this.cachedFs].reverse()) {
      try {
        WrappedProviderFs.disposeOf(fs);
      } catch {
      }
      this.cachedFs.delete(key);
    }
    this.cachedFs.clear();
    this.revCacheFs.clear();
  }
  dispose() {
    var _a19;
    this.disposeOfCachedFs();
    const providers = [...this.providers].reverse();
    for (const provider of providers) try {
      (_a19 = provider.dispose) == null ? void 0 : _a19.call(provider);
    } catch {
    }
  }
};
function fsPassThroughCore(fs) {
  function gfs(ur, name) {
    const url = urlOrReferenceToUrl(ur);
    const f = fs(url);
    if (!f.hasProvider) throw new VFSErrorUnsupportedRequest(name, url, ur instanceof URL ? void 0 : {
      url: ur.url.toString(),
      encoding: ur.encoding
    });
    return f;
  }
  return {
    providerInfo: { name: "default" },
    hasProvider: true,
    stat: async (url) => gfs(url, "stat").stat(url),
    readFile: async (url, options) => gfs(url, "readFile").readFile(url, options),
    writeFile: async (file) => gfs(file, "writeFile").writeFile(file),
    readDirectory: async (url) => gfs(url, "readDirectory").readDirectory(url).then((entries) => entries.map((e) => new CVfsDirEntry(e))),
    getCapabilities: (url) => gfs(url, "getCapabilities").getCapabilities(url)
  };
}
function createVirtualFS(cspellIO) {
  const cspell = cspellIO || getDefaultCSpellIO();
  const vfs = new CVirtualFS();
  vfs.registerFileSystemProvider(cspellIOToFsProvider(cspell));
  return vfs;
}
var defaultVirtualFs = void 0;
function getDefaultVirtualFs() {
  if (!defaultVirtualFs) defaultVirtualFs = createVirtualFS();
  return defaultVirtualFs;
}
var pipeline2 = (0, import_node_util.promisify)(Stream2.pipeline);

// ../../node_modules/vscode-uri/lib/esm/index.mjs
init_shim();
var LIB;
(() => {
  "use strict";
  var t = { 975: (t2) => {
    function e2(t3) {
      if ("string" != typeof t3) throw new TypeError("Path must be a string. Received " + JSON.stringify(t3));
    }
    function r2(t3, e3) {
      for (var r3, n3 = "", i2 = 0, o2 = -1, s2 = 0, h2 = 0; h2 <= t3.length; ++h2) {
        if (h2 < t3.length) r3 = t3.charCodeAt(h2);
        else {
          if (47 === r3) break;
          r3 = 47;
        }
        if (47 === r3) {
          if (o2 === h2 - 1 || 1 === s2) ;
          else if (o2 !== h2 - 1 && 2 === s2) {
            if (n3.length < 2 || 2 !== i2 || 46 !== n3.charCodeAt(n3.length - 1) || 46 !== n3.charCodeAt(n3.length - 2)) {
              if (n3.length > 2) {
                var a2 = n3.lastIndexOf("/");
                if (a2 !== n3.length - 1) {
                  -1 === a2 ? (n3 = "", i2 = 0) : i2 = (n3 = n3.slice(0, a2)).length - 1 - n3.lastIndexOf("/"), o2 = h2, s2 = 0;
                  continue;
                }
              } else if (2 === n3.length || 1 === n3.length) {
                n3 = "", i2 = 0, o2 = h2, s2 = 0;
                continue;
              }
            }
            e3 && (n3.length > 0 ? n3 += "/.." : n3 = "..", i2 = 2);
          } else n3.length > 0 ? n3 += "/" + t3.slice(o2 + 1, h2) : n3 = t3.slice(o2 + 1, h2), i2 = h2 - o2 - 1;
          o2 = h2, s2 = 0;
        } else 46 === r3 && -1 !== s2 ? ++s2 : s2 = -1;
      }
      return n3;
    }
    var n2 = { resolve: function() {
      for (var t3, n3 = "", i2 = false, o2 = arguments.length - 1; o2 >= -1 && !i2; o2--) {
        var s2;
        o2 >= 0 ? s2 = arguments[o2] : (void 0 === t3 && (t3 = process_browser_default.cwd()), s2 = t3), e2(s2), 0 !== s2.length && (n3 = s2 + "/" + n3, i2 = 47 === s2.charCodeAt(0));
      }
      return n3 = r2(n3, !i2), i2 ? n3.length > 0 ? "/" + n3 : "/" : n3.length > 0 ? n3 : ".";
    }, normalize: function(t3) {
      if (e2(t3), 0 === t3.length) return ".";
      var n3 = 47 === t3.charCodeAt(0), i2 = 47 === t3.charCodeAt(t3.length - 1);
      return 0 !== (t3 = r2(t3, !n3)).length || n3 || (t3 = "."), t3.length > 0 && i2 && (t3 += "/"), n3 ? "/" + t3 : t3;
    }, isAbsolute: function(t3) {
      return e2(t3), t3.length > 0 && 47 === t3.charCodeAt(0);
    }, join: function() {
      if (0 === arguments.length) return ".";
      for (var t3, r3 = 0; r3 < arguments.length; ++r3) {
        var i2 = arguments[r3];
        e2(i2), i2.length > 0 && (void 0 === t3 ? t3 = i2 : t3 += "/" + i2);
      }
      return void 0 === t3 ? "." : n2.normalize(t3);
    }, relative: function(t3, r3) {
      if (e2(t3), e2(r3), t3 === r3) return "";
      if ((t3 = n2.resolve(t3)) === (r3 = n2.resolve(r3))) return "";
      for (var i2 = 1; i2 < t3.length && 47 === t3.charCodeAt(i2); ++i2) ;
      for (var o2 = t3.length, s2 = o2 - i2, h2 = 1; h2 < r3.length && 47 === r3.charCodeAt(h2); ++h2) ;
      for (var a2 = r3.length - h2, c2 = s2 < a2 ? s2 : a2, f2 = -1, u2 = 0; u2 <= c2; ++u2) {
        if (u2 === c2) {
          if (a2 > c2) {
            if (47 === r3.charCodeAt(h2 + u2)) return r3.slice(h2 + u2 + 1);
            if (0 === u2) return r3.slice(h2 + u2);
          } else s2 > c2 && (47 === t3.charCodeAt(i2 + u2) ? f2 = u2 : 0 === u2 && (f2 = 0));
          break;
        }
        var l2 = t3.charCodeAt(i2 + u2);
        if (l2 !== r3.charCodeAt(h2 + u2)) break;
        47 === l2 && (f2 = u2);
      }
      var g2 = "";
      for (u2 = i2 + f2 + 1; u2 <= o2; ++u2) u2 !== o2 && 47 !== t3.charCodeAt(u2) || (0 === g2.length ? g2 += ".." : g2 += "/..");
      return g2.length > 0 ? g2 + r3.slice(h2 + f2) : (h2 += f2, 47 === r3.charCodeAt(h2) && ++h2, r3.slice(h2));
    }, _makeLong: function(t3) {
      return t3;
    }, dirname: function(t3) {
      if (e2(t3), 0 === t3.length) return ".";
      for (var r3 = t3.charCodeAt(0), n3 = 47 === r3, i2 = -1, o2 = true, s2 = t3.length - 1; s2 >= 1; --s2) if (47 === (r3 = t3.charCodeAt(s2))) {
        if (!o2) {
          i2 = s2;
          break;
        }
      } else o2 = false;
      return -1 === i2 ? n3 ? "/" : "." : n3 && 1 === i2 ? "//" : t3.slice(0, i2);
    }, basename: function(t3, r3) {
      if (void 0 !== r3 && "string" != typeof r3) throw new TypeError('"ext" argument must be a string');
      e2(t3);
      var n3, i2 = 0, o2 = -1, s2 = true;
      if (void 0 !== r3 && r3.length > 0 && r3.length <= t3.length) {
        if (r3.length === t3.length && r3 === t3) return "";
        var h2 = r3.length - 1, a2 = -1;
        for (n3 = t3.length - 1; n3 >= 0; --n3) {
          var c2 = t3.charCodeAt(n3);
          if (47 === c2) {
            if (!s2) {
              i2 = n3 + 1;
              break;
            }
          } else -1 === a2 && (s2 = false, a2 = n3 + 1), h2 >= 0 && (c2 === r3.charCodeAt(h2) ? -1 == --h2 && (o2 = n3) : (h2 = -1, o2 = a2));
        }
        return i2 === o2 ? o2 = a2 : -1 === o2 && (o2 = t3.length), t3.slice(i2, o2);
      }
      for (n3 = t3.length - 1; n3 >= 0; --n3) if (47 === t3.charCodeAt(n3)) {
        if (!s2) {
          i2 = n3 + 1;
          break;
        }
      } else -1 === o2 && (s2 = false, o2 = n3 + 1);
      return -1 === o2 ? "" : t3.slice(i2, o2);
    }, extname: function(t3) {
      e2(t3);
      for (var r3 = -1, n3 = 0, i2 = -1, o2 = true, s2 = 0, h2 = t3.length - 1; h2 >= 0; --h2) {
        var a2 = t3.charCodeAt(h2);
        if (47 !== a2) -1 === i2 && (o2 = false, i2 = h2 + 1), 46 === a2 ? -1 === r3 ? r3 = h2 : 1 !== s2 && (s2 = 1) : -1 !== r3 && (s2 = -1);
        else if (!o2) {
          n3 = h2 + 1;
          break;
        }
      }
      return -1 === r3 || -1 === i2 || 0 === s2 || 1 === s2 && r3 === i2 - 1 && r3 === n3 + 1 ? "" : t3.slice(r3, i2);
    }, format: function(t3) {
      if (null === t3 || "object" != typeof t3) throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t3);
      return (function(t4, e3) {
        var r3 = e3.dir || e3.root, n3 = e3.base || (e3.name || "") + (e3.ext || "");
        return r3 ? r3 === e3.root ? r3 + n3 : r3 + "/" + n3 : n3;
      })(0, t3);
    }, parse: function(t3) {
      e2(t3);
      var r3 = { root: "", dir: "", base: "", ext: "", name: "" };
      if (0 === t3.length) return r3;
      var n3, i2 = t3.charCodeAt(0), o2 = 47 === i2;
      o2 ? (r3.root = "/", n3 = 1) : n3 = 0;
      for (var s2 = -1, h2 = 0, a2 = -1, c2 = true, f2 = t3.length - 1, u2 = 0; f2 >= n3; --f2) if (47 !== (i2 = t3.charCodeAt(f2))) -1 === a2 && (c2 = false, a2 = f2 + 1), 46 === i2 ? -1 === s2 ? s2 = f2 : 1 !== u2 && (u2 = 1) : -1 !== s2 && (u2 = -1);
      else if (!c2) {
        h2 = f2 + 1;
        break;
      }
      return -1 === s2 || -1 === a2 || 0 === u2 || 1 === u2 && s2 === a2 - 1 && s2 === h2 + 1 ? -1 !== a2 && (r3.base = r3.name = 0 === h2 && o2 ? t3.slice(1, a2) : t3.slice(h2, a2)) : (0 === h2 && o2 ? (r3.name = t3.slice(1, s2), r3.base = t3.slice(1, a2)) : (r3.name = t3.slice(h2, s2), r3.base = t3.slice(h2, a2)), r3.ext = t3.slice(s2, a2)), h2 > 0 ? r3.dir = t3.slice(0, h2 - 1) : o2 && (r3.dir = "/"), r3;
    }, sep: "/", delimiter: ":", win32: null, posix: null };
    n2.posix = n2, t2.exports = n2;
  } }, e = {};
  function r(n2) {
    var i2 = e[n2];
    if (void 0 !== i2) return i2.exports;
    var o2 = e[n2] = { exports: {} };
    return t[n2](o2, o2.exports, r), o2.exports;
  }
  r.d = (t2, e2) => {
    for (var n2 in e2) r.o(e2, n2) && !r.o(t2, n2) && Object.defineProperty(t2, n2, { enumerable: true, get: e2[n2] });
  }, r.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), r.r = (t2) => {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
  };
  var n = {};
  let i;
  if (r.r(n), r.d(n, { URI: () => l, Utils: () => I }), "object" == typeof process_browser_default) i = "win32" === process_browser_default.platform;
  else if ("object" == typeof navigator) {
    let t2 = navigator.userAgent;
    i = t2.indexOf("Windows") >= 0;
  }
  const o = /^\w[\w\d+.-]*$/, s = /^\//, h = /^\/\//;
  function a(t2, e2) {
    if (!t2.scheme && e2) throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${t2.authority}", path: "${t2.path}", query: "${t2.query}", fragment: "${t2.fragment}"}`);
    if (t2.scheme && !o.test(t2.scheme)) throw new Error("[UriError]: Scheme contains illegal characters.");
    if (t2.path) {
      if (t2.authority) {
        if (!s.test(t2.path)) throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
      } else if (h.test(t2.path)) throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
    }
  }
  const c = "", f = "/", u = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
  class l {
    constructor(t2, e2, r2, n2, i2, o2 = false) {
      __publicField(this, "scheme");
      __publicField(this, "authority");
      __publicField(this, "path");
      __publicField(this, "query");
      __publicField(this, "fragment");
      "object" == typeof t2 ? (this.scheme = t2.scheme || c, this.authority = t2.authority || c, this.path = t2.path || c, this.query = t2.query || c, this.fragment = t2.fragment || c) : (this.scheme = /* @__PURE__ */ (function(t3, e3) {
        return t3 || e3 ? t3 : "file";
      })(t2, o2), this.authority = e2 || c, this.path = (function(t3, e3) {
        switch (t3) {
          case "https":
          case "http":
          case "file":
            e3 ? e3[0] !== f && (e3 = f + e3) : e3 = f;
        }
        return e3;
      })(this.scheme, r2 || c), this.query = n2 || c, this.fragment = i2 || c, a(this, o2));
    }
    static isUri(t2) {
      return t2 instanceof l || !!t2 && "string" == typeof t2.authority && "string" == typeof t2.fragment && "string" == typeof t2.path && "string" == typeof t2.query && "string" == typeof t2.scheme && "string" == typeof t2.fsPath && "function" == typeof t2.with && "function" == typeof t2.toString;
    }
    get fsPath() {
      return v(this, false);
    }
    with(t2) {
      if (!t2) return this;
      let { scheme: e2, authority: r2, path: n2, query: i2, fragment: o2 } = t2;
      return void 0 === e2 ? e2 = this.scheme : null === e2 && (e2 = c), void 0 === r2 ? r2 = this.authority : null === r2 && (r2 = c), void 0 === n2 ? n2 = this.path : null === n2 && (n2 = c), void 0 === i2 ? i2 = this.query : null === i2 && (i2 = c), void 0 === o2 ? o2 = this.fragment : null === o2 && (o2 = c), e2 === this.scheme && r2 === this.authority && n2 === this.path && i2 === this.query && o2 === this.fragment ? this : new d(e2, r2, n2, i2, o2);
    }
    static parse(t2, e2 = false) {
      const r2 = u.exec(t2);
      return r2 ? new d(r2[2] || c, w(r2[4] || c), w(r2[5] || c), w(r2[7] || c), w(r2[9] || c), e2) : new d(c, c, c, c, c);
    }
    static file(t2) {
      let e2 = c;
      if (i && (t2 = t2.replace(/\\/g, f)), t2[0] === f && t2[1] === f) {
        const r2 = t2.indexOf(f, 2);
        -1 === r2 ? (e2 = t2.substring(2), t2 = f) : (e2 = t2.substring(2, r2), t2 = t2.substring(r2) || f);
      }
      return new d("file", e2, t2, c, c);
    }
    static from(t2) {
      const e2 = new d(t2.scheme, t2.authority, t2.path, t2.query, t2.fragment);
      return a(e2, true), e2;
    }
    toString(t2 = false) {
      return b(this, t2);
    }
    toJSON() {
      return this;
    }
    static revive(t2) {
      if (t2) {
        if (t2 instanceof l) return t2;
        {
          const e2 = new d(t2);
          return e2._formatted = t2.external, e2._fsPath = t2._sep === g ? t2.fsPath : null, e2;
        }
      }
      return t2;
    }
  }
  const g = i ? 1 : void 0;
  class d extends l {
    constructor() {
      super(...arguments);
      __publicField(this, "_formatted", null);
      __publicField(this, "_fsPath", null);
    }
    get fsPath() {
      return this._fsPath || (this._fsPath = v(this, false)), this._fsPath;
    }
    toString(t2 = false) {
      return t2 ? b(this, true) : (this._formatted || (this._formatted = b(this, false)), this._formatted);
    }
    toJSON() {
      const t2 = { $mid: 1 };
      return this._fsPath && (t2.fsPath = this._fsPath, t2._sep = g), this._formatted && (t2.external = this._formatted), this.path && (t2.path = this.path), this.scheme && (t2.scheme = this.scheme), this.authority && (t2.authority = this.authority), this.query && (t2.query = this.query), this.fragment && (t2.fragment = this.fragment), t2;
    }
  }
  const p = { 58: "%3A", 47: "%2F", 63: "%3F", 35: "%23", 91: "%5B", 93: "%5D", 64: "%40", 33: "%21", 36: "%24", 38: "%26", 39: "%27", 40: "%28", 41: "%29", 42: "%2A", 43: "%2B", 44: "%2C", 59: "%3B", 61: "%3D", 32: "%20" };
  function m(t2, e2, r2) {
    let n2, i2 = -1;
    for (let o2 = 0; o2 < t2.length; o2++) {
      const s2 = t2.charCodeAt(o2);
      if (s2 >= 97 && s2 <= 122 || s2 >= 65 && s2 <= 90 || s2 >= 48 && s2 <= 57 || 45 === s2 || 46 === s2 || 95 === s2 || 126 === s2 || e2 && 47 === s2 || r2 && 91 === s2 || r2 && 93 === s2 || r2 && 58 === s2) -1 !== i2 && (n2 += encodeURIComponent(t2.substring(i2, o2)), i2 = -1), void 0 !== n2 && (n2 += t2.charAt(o2));
      else {
        void 0 === n2 && (n2 = t2.substr(0, o2));
        const e3 = p[s2];
        void 0 !== e3 ? (-1 !== i2 && (n2 += encodeURIComponent(t2.substring(i2, o2)), i2 = -1), n2 += e3) : -1 === i2 && (i2 = o2);
      }
    }
    return -1 !== i2 && (n2 += encodeURIComponent(t2.substring(i2))), void 0 !== n2 ? n2 : t2;
  }
  function y(t2) {
    let e2;
    for (let r2 = 0; r2 < t2.length; r2++) {
      const n2 = t2.charCodeAt(r2);
      35 === n2 || 63 === n2 ? (void 0 === e2 && (e2 = t2.substr(0, r2)), e2 += p[n2]) : void 0 !== e2 && (e2 += t2[r2]);
    }
    return void 0 !== e2 ? e2 : t2;
  }
  function v(t2, e2) {
    let r2;
    return r2 = t2.authority && t2.path.length > 1 && "file" === t2.scheme ? `//${t2.authority}${t2.path}` : 47 === t2.path.charCodeAt(0) && (t2.path.charCodeAt(1) >= 65 && t2.path.charCodeAt(1) <= 90 || t2.path.charCodeAt(1) >= 97 && t2.path.charCodeAt(1) <= 122) && 58 === t2.path.charCodeAt(2) ? e2 ? t2.path.substr(1) : t2.path[1].toLowerCase() + t2.path.substr(2) : t2.path, i && (r2 = r2.replace(/\//g, "\\")), r2;
  }
  function b(t2, e2) {
    const r2 = e2 ? y : m;
    let n2 = "", { scheme: i2, authority: o2, path: s2, query: h2, fragment: a2 } = t2;
    if (i2 && (n2 += i2, n2 += ":"), (o2 || "file" === i2) && (n2 += f, n2 += f), o2) {
      let t3 = o2.indexOf("@");
      if (-1 !== t3) {
        const e3 = o2.substr(0, t3);
        o2 = o2.substr(t3 + 1), t3 = e3.lastIndexOf(":"), -1 === t3 ? n2 += r2(e3, false, false) : (n2 += r2(e3.substr(0, t3), false, false), n2 += ":", n2 += r2(e3.substr(t3 + 1), false, true)), n2 += "@";
      }
      o2 = o2.toLowerCase(), t3 = o2.lastIndexOf(":"), -1 === t3 ? n2 += r2(o2, false, true) : (n2 += r2(o2.substr(0, t3), false, true), n2 += o2.substr(t3));
    }
    if (s2) {
      if (s2.length >= 3 && 47 === s2.charCodeAt(0) && 58 === s2.charCodeAt(2)) {
        const t3 = s2.charCodeAt(1);
        t3 >= 65 && t3 <= 90 && (s2 = `/${String.fromCharCode(t3 + 32)}:${s2.substr(3)}`);
      } else if (s2.length >= 2 && 58 === s2.charCodeAt(1)) {
        const t3 = s2.charCodeAt(0);
        t3 >= 65 && t3 <= 90 && (s2 = `${String.fromCharCode(t3 + 32)}:${s2.substr(2)}`);
      }
      n2 += r2(s2, true, false);
    }
    return h2 && (n2 += "?", n2 += r2(h2, false, false)), a2 && (n2 += "#", n2 += e2 ? a2 : m(a2, false, false)), n2;
  }
  function C(t2) {
    try {
      return decodeURIComponent(t2);
    } catch {
      return t2.length > 3 ? t2.substr(0, 3) + C(t2.substr(3)) : t2;
    }
  }
  const A = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
  function w(t2) {
    return t2.match(A) ? t2.replace(A, ((t3) => C(t3))) : t2;
  }
  var x = r(975);
  const P = x.posix || x, _ = "/";
  var I;
  !(function(t2) {
    t2.joinPath = function(t3, ...e2) {
      return t3.with({ path: P.join(t3.path, ...e2) });
    }, t2.resolvePath = function(t3, ...e2) {
      let r2 = t3.path, n2 = false;
      r2[0] !== _ && (r2 = _ + r2, n2 = true);
      let i2 = P.resolve(r2, ...e2);
      return n2 && i2[0] === _ && !t3.authority && (i2 = i2.substring(1)), t3.with({ path: i2 });
    }, t2.dirname = function(t3) {
      if (0 === t3.path.length || t3.path === _) return t3;
      let e2 = P.dirname(t3.path);
      return 1 === e2.length && 46 === e2.charCodeAt(0) && (e2 = ""), t3.with({ path: e2 });
    }, t2.basename = function(t3) {
      return P.basename(t3.path);
    }, t2.extname = function(t3) {
      return P.extname(t3.path);
    };
  })(I || (I = {})), LIB = n;
})();
var { URI, Utils } = LIB;

// ../../node_modules/cspell-lib/dist/lib/util/Uri.js
var STDIN_PROTOCOL = "stdin:";
function toUri(uriOrFile) {
  if (UriImpl.isUri(uriOrFile))
    return uriOrFile;
  if (URI.isUri(uriOrFile))
    return UriImpl.from(uriOrFile);
  if (uriOrFile instanceof URL)
    return UriImpl.parse(uriOrFile.toString());
  if (isHRef(uriOrFile))
    return UriImpl.parse(uriOrFile.href);
  if (isUri(uriOrFile))
    return UriImpl.from(uriOrFile);
  if (isUrlLike(uriOrFile))
    return UriImpl.parse(uriOrFile);
  return UriImpl.file(normalizeDriveLetter(uriOrFile));
}
var isWindows2 = process_browser_default.platform === "win32";
var hasDriveLetter = /^[a-zA-Z]:[\\/]/;
var rootUrl = toFileDirURL("/");
function uriToFilePath(uri) {
  let url = documentUriToURL(uri);
  url = url.protocol === "stdin:" ? new URL(url.pathname, rootUrl) : url;
  return toFilePathOrHref(url);
}
function normalizeDriveLetter(path) {
  return hasDriveLetter.test(path) ? path[0].toUpperCase() + path.slice(1) : path;
}
function isHRef(url) {
  return !!url && typeof url === "object" && typeof url.href === "string" || false;
}
function isUri(uri) {
  if (!uri || typeof uri !== "object")
    return false;
  if (UriImpl.isUri(uri))
    return true;
  if (URI.isUri(uri))
    return true;
  const u = uri;
  return typeof u.path === "string" && typeof u.scheme === "string";
}
function basename3(uri) {
  return Utils.basename(URI.from(uri));
}
function uriFrom(uri, ...parts) {
  return UriImpl.from(uri, ...parts);
}
var keys = ["scheme", "authority", "path", "query", "fragment"];
var UriImpl = class _UriImpl extends URI {
  constructor(uri) {
    super(uri.scheme, uri.authority, uri.path, uri.query, uri.fragment);
  }
  toString() {
    const path = encodeURI(this.path || "").replaceAll(/[#?]/g, (c) => `%${(c.codePointAt(0) || 0).toString(16)}`);
    const base = `${this.scheme}://${this.authority || ""}${path}`;
    const query = this.query && `?${this.query}` || "";
    const fragment = this.fragment && `#${this.fragment}` || "";
    const url = base + query + fragment;
    return url;
  }
  toJSON() {
    const { scheme, authority, path, query, fragment } = this;
    return { scheme, authority, path, query, fragment };
  }
  with(change) {
    const { scheme, authority, path, query, fragment } = this;
    const u = { scheme, authority, path, query, fragment };
    for (const key of keys) {
      if (change[key] && typeof change[key] === "string") {
        u[key] = change[key];
      }
    }
    return new _UriImpl(u);
  }
  static isUri(uri) {
    return uri instanceof _UriImpl;
  }
  static from(uri, ...parts) {
    let u = new _UriImpl(uri);
    for (const part of parts) {
      u = u.with(part);
    }
    return u;
  }
  static parse(uri) {
    if (uri.startsWith(STDIN_PROTOCOL)) {
      return _UriImpl.from(parseStdinUri(uri));
    }
    const u = URI.parse(uri);
    return _UriImpl.from(u);
  }
  static file(filename) {
    if (!isWindows2 && hasDriveLetter.test(filename)) {
      filename = "/" + filename.replaceAll("\\", "/");
    }
    const url = toFileURL(filename);
    return _UriImpl.parse(url.href);
  }
  static stdin(filePath = "") {
    return _UriImpl.from(_UriImpl.file(filePath), { scheme: "stdin" });
  }
};
function normalizeFilePath(path) {
  return normalizeDriveLetter(path.replaceAll("\\", "/"));
}
function parseStdinUri(uri) {
  (0, import_node_assert3.default)(uri.startsWith(STDIN_PROTOCOL));
  const idxSlash = STDIN_PROTOCOL.length;
  let idxSlashEnd = idxSlash;
  for (; uri[idxSlashEnd] === "/"; ++idxSlashEnd) {
  }
  const pathStart = idxSlashEnd;
  const iH = uri.indexOf("#", pathStart);
  const idxHash = iH > 0 ? iH : uri.length;
  const iQ = uri.indexOf("?", pathStart);
  const idxQ = iQ > 0 && iQ < idxHash ? iQ : idxHash;
  const pathEnd = idxQ;
  const path = uri.slice(pathStart, pathEnd);
  const query = idxQ < idxHash ? uri.slice(idxQ + 1, idxHash) : "";
  const hash = uri.slice(idxHash + 1);
  const pathPrefix = idxSlashEnd - idxSlash > 2 ? "/" : "";
  return {
    scheme: "stdin",
    path: pathPrefix + normalizeFilePath(decodeURI(path)),
    query: decodeURI(query),
    fragment: decodeURI(hash)
  };
}
function documentUriToURL(uri) {
  return toURL(uri instanceof URL ? uri : typeof uri === "string" ? toFileURL(uri) : new URL(uriFrom(uri).toString()));
}

// ../../node_modules/cspell-lib/dist/lib/Document/normalizeLanguageIds.js
init_shim();
function normalizeLanguageIds(languageId) {
  return (Array.isArray(languageId) ? languageId.join(",") : languageId).split(",").map((s) => s.trim());
}

// ../../node_modules/cspell-lib/dist/lib/Document/isBinaryDoc.js
function isBinaryDoc(document2) {
  return isBinaryFile2(toUri(document2.uri), document2.languageId, document2.text);
}
function isBinaryFile2(filename, languageId, text) {
  const filenameUri = toUri(filename);
  if (languageId) {
    const ids2 = normalizeLanguageIds(languageId);
    if (ids2.length)
      return isFileTypeGenerated(ids2);
  }
  const file = basename3(filenameUri);
  const ids = findMatchingFileTypes(file);
  if (ids.length)
    return isFileTypeGenerated(ids);
  return (text == null ? void 0 : text.slice(0, 1024).includes("\0")) || false;
}

// ../../node_modules/cspell-lib/dist/lib/Document/resolveDocument.js
init_shim();

// src/shims/node-fs-promises.js
init_shim();
import { readVfsFile as readVfsFile2, statVfsFile as statVfsFile2 } from "./cspell-vfs.js";
function unavailable(apiName) {
  throw new Error(`[ace-spell-check] ${apiName} is not available in browser builds.`);
}
async function readFile(pathLike, options) {
  const encoding = typeof options === "string" ? options : options == null ? void 0 : options.encoding;
  const content = await readVfsFile2(pathLike, encoding);
  if (content !== void 0) return content;
  return unavailable("fs.promises.readFile");
}

// ../../node_modules/cspell-lib/dist/lib/Models/TextDocument.js
init_shim();
var import_node_assert4 = __toESM(require_assert(), 1);

// ../../node_modules/vscode-languageserver-textdocument/lib/esm/main.js
init_shim();
var FullTextDocument = class _FullTextDocument {
  constructor(uri, languageId, version2, content) {
    this._uri = uri;
    this._languageId = languageId;
    this._version = version2;
    this._content = content;
    this._lineOffsets = void 0;
  }
  get uri() {
    return this._uri;
  }
  get languageId() {
    return this._languageId;
  }
  get version() {
    return this._version;
  }
  getText(range) {
    if (range) {
      const start = this.offsetAt(range.start);
      const end = this.offsetAt(range.end);
      return this._content.substring(start, end);
    }
    return this._content;
  }
  update(changes, version2) {
    for (const change of changes) {
      if (_FullTextDocument.isIncremental(change)) {
        const range = getWellformedRange(change.range);
        const startOffset = this.offsetAt(range.start);
        const endOffset = this.offsetAt(range.end);
        this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
        const startLine = Math.max(range.start.line, 0);
        const endLine = Math.max(range.end.line, 0);
        let lineOffsets = this._lineOffsets;
        const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
        if (endLine - startLine === addedLineOffsets.length) {
          for (let i = 0, len = addedLineOffsets.length; i < len; i++) {
            lineOffsets[i + startLine + 1] = addedLineOffsets[i];
          }
        } else {
          if (addedLineOffsets.length < 1e4) {
            lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);
          } else {
            this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
          }
        }
        const diff = change.text.length - (endOffset - startOffset);
        if (diff !== 0) {
          for (let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {
            lineOffsets[i] = lineOffsets[i] + diff;
          }
        }
      } else if (_FullTextDocument.isFull(change)) {
        this._content = change.text;
        this._lineOffsets = void 0;
      } else {
        throw new Error("Unknown change event received");
      }
    }
    this._version = version2;
  }
  getLineOffsets() {
    if (this._lineOffsets === void 0) {
      this._lineOffsets = computeLineOffsets(this._content, true);
    }
    return this._lineOffsets;
  }
  positionAt(offset) {
    offset = Math.max(Math.min(offset, this._content.length), 0);
    const lineOffsets = this.getLineOffsets();
    let low = 0, high = lineOffsets.length;
    if (high === 0) {
      return { line: 0, character: offset };
    }
    while (low < high) {
      const mid = Math.floor((low + high) / 2);
      if (lineOffsets[mid] > offset) {
        high = mid;
      } else {
        low = mid + 1;
      }
    }
    const line = low - 1;
    offset = this.ensureBeforeEOL(offset, lineOffsets[line]);
    return { line, character: offset - lineOffsets[line] };
  }
  offsetAt(position) {
    const lineOffsets = this.getLineOffsets();
    if (position.line >= lineOffsets.length) {
      return this._content.length;
    } else if (position.line < 0) {
      return 0;
    }
    const lineOffset = lineOffsets[position.line];
    if (position.character <= 0) {
      return lineOffset;
    }
    const nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
    const offset = Math.min(lineOffset + position.character, nextLineOffset);
    return this.ensureBeforeEOL(offset, lineOffset);
  }
  ensureBeforeEOL(offset, lineOffset) {
    while (offset > lineOffset && isEOL(this._content.charCodeAt(offset - 1))) {
      offset--;
    }
    return offset;
  }
  get lineCount() {
    return this.getLineOffsets().length;
  }
  static isIncremental(event) {
    const candidate = event;
    return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
  }
  static isFull(event) {
    const candidate = event;
    return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
  }
};
var TextDocument;
(function(TextDocument2) {
  function create(uri, languageId, version2, content) {
    return new FullTextDocument(uri, languageId, version2, content);
  }
  TextDocument2.create = create;
  function update(document2, changes, version2) {
    if (document2 instanceof FullTextDocument) {
      document2.update(changes, version2);
      return document2;
    } else {
      throw new Error("TextDocument.update: document must be created by TextDocument.create");
    }
  }
  TextDocument2.update = update;
  function applyEdits2(document2, edits) {
    const text = document2.getText();
    const sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b) => {
      const diff = a.range.start.line - b.range.start.line;
      if (diff === 0) {
        return a.range.start.character - b.range.start.character;
      }
      return diff;
    });
    let lastModifiedOffset = 0;
    const spans = [];
    for (const e of sortedEdits) {
      const startOffset = document2.offsetAt(e.range.start);
      if (startOffset < lastModifiedOffset) {
        throw new Error("Overlapping edit");
      } else if (startOffset > lastModifiedOffset) {
        spans.push(text.substring(lastModifiedOffset, startOffset));
      }
      if (e.newText.length) {
        spans.push(e.newText);
      }
      lastModifiedOffset = document2.offsetAt(e.range.end);
    }
    spans.push(text.substr(lastModifiedOffset));
    return spans.join("");
  }
  TextDocument2.applyEdits = applyEdits2;
})(TextDocument || (TextDocument = {}));
function mergeSort(data, compare2) {
  if (data.length <= 1) {
    return data;
  }
  const p = data.length / 2 | 0;
  const left = data.slice(0, p);
  const right = data.slice(p);
  mergeSort(left, compare2);
  mergeSort(right, compare2);
  let leftIdx = 0;
  let rightIdx = 0;
  let i = 0;
  while (leftIdx < left.length && rightIdx < right.length) {
    const ret = compare2(left[leftIdx], right[rightIdx]);
    if (ret <= 0) {
      data[i++] = left[leftIdx++];
    } else {
      data[i++] = right[rightIdx++];
    }
  }
  while (leftIdx < left.length) {
    data[i++] = left[leftIdx++];
  }
  while (rightIdx < right.length) {
    data[i++] = right[rightIdx++];
  }
  return data;
}
function computeLineOffsets(text, isAtLineStart, textOffset = 0) {
  const result = isAtLineStart ? [textOffset] : [];
  for (let i = 0; i < text.length; i++) {
    const ch = text.charCodeAt(i);
    if (isEOL(ch)) {
      if (ch === 13 && i + 1 < text.length && text.charCodeAt(i + 1) === 10) {
        i++;
      }
      result.push(textOffset + i + 1);
    }
  }
  return result;
}
function isEOL(char) {
  return char === 13 || char === 10;
}
function getWellformedRange(range) {
  const start = range.start;
  const end = range.end;
  if (start.line > end.line || start.line === end.line && start.character > end.character) {
    return { start: end, end: start };
  }
  return range;
}
function getWellformedEdit(textEdit) {
  const range = getWellformedRange(textEdit.range);
  if (range !== textEdit.range) {
    return { newText: textEdit.newText, range };
  }
  return textEdit;
}

// ../../node_modules/cspell-lib/dist/lib/fileSystem.js
init_shim();
function getVirtualFS() {
  return getDefaultVirtualFs();
}
function getFileSystem() {
  return getVirtualFS().fs;
}

// ../../node_modules/cspell-lib/dist/lib/Models/TextDocument.js
var TextDocumentImpl = class {
  constructor(uri, text, languageId, locale, version2) {
    __publicField(this, "languageId");
    __publicField(this, "locale");
    __publicField(this, "vsTextDoc");
    __publicField(this, "uri");
    this.languageId = languageId;
    this.locale = locale;
    const primaryLanguageId = typeof languageId === "string" ? languageId : languageId[0] || "plaintext";
    this.vsTextDoc = TextDocument.create(uri.toString(), primaryLanguageId, version2, text);
    this.uri = documentUriToURL(uri);
  }
  get version() {
    return this.vsTextDoc.version;
  }
  get text() {
    return this.vsTextDoc.getText();
  }
  positionAt(offset) {
    return this.vsTextDoc.positionAt(offset);
  }
  offsetAt(position) {
    return this.vsTextDoc.offsetAt(position);
  }
  lineAt(offset) {
    const position = this.vsTextDoc.positionAt(offset);
    return this.getLine(position.line);
  }
  getLine(lineNum) {
    const position = { line: lineNum, character: 0 };
    const end = { line: lineNum + 1, character: 0 };
    const range = {
      start: position,
      end
    };
    const lineOffset = this.vsTextDoc.offsetAt(position);
    const text = this.vsTextDoc.getText(range);
    return {
      text,
      offset: lineOffset,
      position
    };
  }
  /**
   * Iterate over the lines of a document one-by-one.
   * Changing the document between iterations can change the result
   */
  *getLines() {
    const range = {
      start: { line: 0, character: 0 },
      end: { line: 1, character: 0 }
    };
    while (this.vsTextDoc.offsetAt(range.end) > this.vsTextDoc.offsetAt(range.start)) {
      const offset = this.vsTextDoc.offsetAt(range.start);
      yield {
        text: this.vsTextDoc.getText(range),
        offset,
        position: range.start
      };
      ++range.start.line;
      ++range.end.line;
    }
  }
  /**
   * Apply edits to the text.
   * Note: the edits are applied one after the other.
   * @param edits - changes to the text
   * @param version - optional version to use.
   * @returns this
   */
  update(edits, version2) {
    version2 = version2 != null ? version2 : this.version + 1;
    for (const edit of edits) {
      const vsEdit = edit.range ? {
        range: { start: this.positionAt(edit.range[0]), end: this.positionAt(edit.range[1]) },
        text: edit.text
      } : edit;
      TextDocument.update(this.vsTextDoc, [vsEdit], version2);
    }
    return this;
  }
};
function createTextDocument({ uri, content, languageId, locale, version: version2 }) {
  version2 = version2 != null ? version2 : 1;
  uri = toUri(uri);
  languageId = languageId != null ? languageId : findMatchingFileTypes(basename3(uri));
  languageId = languageId.length === 0 ? "text" : languageId;
  return new TextDocumentImpl(uri, content, languageId, locale, version2);
}
function updateTextDocument(doc, edits, version2) {
  (0, import_node_assert4.default)(isTextDocumentImpl(doc), "Unknown TextDocument type");
  return doc.update(edits, version2);
}
function isTextDocumentImpl(doc) {
  return doc instanceof TextDocumentImpl;
}

// ../../node_modules/cspell-lib/dist/lib/util/util.js
init_shim();
var uniqueFn = uniqueFilterFnGenerator;
function uniqueFilterFnGenerator(extractFn) {
  const values = /* @__PURE__ */ new Set();
  const extractor = extractFn || ((a) => a);
  return (v) => {
    const vv = extractor(v);
    const ret = !values.has(vv);
    values.add(vv);
    return ret;
  };
}
function clean(src) {
  const r = src;
  for (const key of Object.keys(r)) {
    if (r[key] === void 0 || r[key] === null) {
      delete r[key];
    }
  }
  return r;
}
function scanMap(accFn, init) {
  let acc = init;
  let first2 = true;
  return function(value) {
    if (first2 && acc === void 0) {
      first2 = false;
      acc = value;
      return acc;
    }
    acc = accFn(acc, value);
    return acc;
  };
}
function isDefined(v) {
  return v !== void 0;
}
function isArrayEqual(a, b) {
  if (a === b)
    return true;
  let isMatch = a.length === b.length;
  for (let i = 0; i < a.length && isMatch; ++i) {
    isMatch = a[i] === b[i];
  }
  return isMatch;
}
function doSetsIntersect(a, b) {
  function compare2(a2, b2) {
    for (const item of a2) {
      if (b2.has(item))
        return true;
    }
    return false;
  }
  return a.size <= b.size ? compare2(a, b) : compare2(b, a);
}

// ../../node_modules/cspell-lib/dist/lib/Document/resolveDocument.js
var defaultEncoding = "utf8";
function documentToTextDocument(document2) {
  const { uri, text: content, languageId, locale } = document2;
  return createTextDocument({ uri, content, languageId, locale });
}
async function readDocument(filename, encoding = defaultEncoding) {
  const text = await readFile(filename, encoding);
  const uri = toUri(filename).toString();
  return {
    uri,
    text
  };
}
function resolveDocument(document2, encoding) {
  if (isDocumentWithText(document2))
    return Promise.resolve(document2);
  const uri = toUri(document2.uri);
  if (uri.scheme !== "file") {
    throw new Error(`Unsupported schema: "${uri.scheme}", open "${uri.toString()}"`);
  }
  return readDocument(uriToFilePath(uri), encoding);
}
function isDocumentWithText(doc) {
  return doc.text !== void 0;
}

// ../../node_modules/cspell-lib/dist/lib/perf/index.js
init_shim();

// ../../node_modules/cspell-lib/dist/lib/perf/timer.js
init_shim();
function createPerfTimer(name, onEnd, timeNowFn) {
  return new SimpleTimer(name, onEnd, timeNowFn);
}
var SimpleTimer = class {
  constructor(name, onEnd, timeNowFn = performance.now) {
    __publicField(this, "name");
    __publicField(this, "onEnd");
    __publicField(this, "timeNowFn");
    __publicField(this, "_start", performance.now());
    __publicField(this, "_elapsed");
    __publicField(this, "_running", true);
    this.name = name;
    this.onEnd = onEnd;
    this.timeNowFn = timeNowFn;
  }
  get startTime() {
    return this._start;
  }
  get elapsed() {
    var _a19;
    return (_a19 = this._elapsed) != null ? _a19 : performance.now() - this._start;
  }
  end() {
    var _a19;
    if (!this._running)
      return;
    this._running = false;
    const end = performance.now();
    this._elapsed = end - this._start;
    (_a19 = this.onEnd) == null ? void 0 : _a19.call(this, this._elapsed, this.name);
  }
  start() {
    this._start = performance.now();
    this._running = true;
  }
};

// ../../node_modules/@cspell/cspell-performance-monitor/dist/index.js
init_shim();
var symbolCSpell = /* @__PURE__ */ Symbol.for("cspell");
var globalThisCSpell = globalThis;
function _measurePerfStart(name, enabled) {
  if (!enabled) return;
  performance.mark(name + "-start");
}
function _measurePerfEnd(name, enabled) {
  if (!enabled) return;
  performance.mark(name + "-end");
  performance.measure(name, name + "-start", name + "-end");
}
function measurePerf(name) {
  const enabled = isEnabledPerformanceMeasurements();
  _measurePerfStart(name, enabled);
  return makeDisposableFunction(() => {
    _measurePerfEnd(name, enabled);
  });
}
function makeDisposableFunction(fn) {
  const disposableFn = fn;
  disposableFn[Symbol.dispose] = fn;
  disposableFn[Symbol.asyncDispose] = () => (fn(), Promise.resolve());
  return disposableFn;
}
function isEnabledPerformanceMeasurements() {
  var _a19;
  return !!((_a19 = globalThisCSpell[symbolCSpell]) == null ? void 0 : _a19.enablePerformanceMeasurements);
}

// ../../node_modules/cspell-lib/dist/lib/Settings/sanitizeSettings.js
init_shim();

// ../../node_modules/cspell-lib/dist/lib/util/clone.js
init_shim();
function cloneInto(src, dst, handlers2, keys3) {
  const keysToProcess = keys3 || Object.keys(handlers2);
  for (const key of keysToProcess) {
    if (src[key] === void 0)
      continue;
    const handler = handlers2[key];
    if (handler === skip)
      continue;
    handler(src, dst, key);
  }
  return dst;
}
function skip(_src, _dst, _key) {
}
function copy0(src, dst, key) {
  const value = src[key];
  if (value === void 0)
    return;
  dst[key] = value;
}
function copy1(src, dst, key) {
  if (src[key] === void 0)
    return;
  const value = src[key];
  if (value === void 0)
    return;
  if (Array.isArray(value)) {
    dst[key] = [...value];
    return;
  }
  if (value instanceof Set) {
    dst[key] = new Set(value);
    return;
  }
  if (value instanceof Map) {
    dst[key] = new Map(value);
    return;
  }
  if (value instanceof RegExp) {
    dst[key] = value;
    return;
  }
  if (typeof value === "object") {
    dst[key] = { ...value };
    return;
  }
  dst[key] = value;
}

// ../../node_modules/cspell-lib/dist/lib/Settings/sanitizeSettings.js
function cloneSettingsForExport(settings) {
  const result = {};
  const handlers2 = getHandlers();
  cloneInto(settings, result, handlers2);
  return result;
}
var handlers = {
  $schema: skip,
  __importRef: copyImportRefField,
  __imports: copyImportsField,
  source: copySourceField,
  id: skip,
  version: skip,
  allowCompoundWords: copy1,
  cache: skip,
  caseSensitive: copy1,
  description: skip,
  dictionaries: copy1,
  dictionaryDefinitions: copyDictionaryDefinitions,
  enabled: copy1,
  enabledLanguageIds: copy1,
  enableFiletypes: copy1,
  enabledFileTypes: copy1,
  enableGlobDot: copy1,
  engines: copy1,
  failFast: copy1,
  features: skip,
  files: copyGlobsSettingsFields,
  flagWords: copy1,
  gitignoreRoot: copy1,
  globRoot: copy1,
  ignorePaths: copyGlobsSettingsFields,
  ignoreRegExpList: copy1,
  ignoreWords: copy1,
  ignoreRandomStrings: copy1,
  import: skip,
  includeRegExpList: copy1,
  language: copy1,
  languageId: copy1,
  languageSettings: copyLanguageSettings,
  loadDefaultConfiguration: copy1,
  maxDuplicateProblems: copy1,
  maxFileSize: copy1,
  maxNumberOfProblems: copy1,
  minWordLength: copy1,
  minRandomLength: copy1,
  name: skip,
  noConfigSearch: copy1,
  noSuggestDictionaries: copy1,
  numSuggestions: copy1,
  overrides: copyOverrides,
  patterns: copyPatternsField,
  pnpFiles: skip,
  readonly: skip,
  reporters: skip,
  showStatus: copy1,
  spellCheckDelayMs: copy1,
  suggestionNumChanges: copy1,
  suggestionsTimeout: copy1,
  suggestWords: copy1,
  unknownWords: copy1,
  useGitignore: copy1,
  usePnP: skip,
  userWords: copy1,
  validateDirectives: copy1,
  vfs: skip,
  words: copy1,
  // Experimental
  parser: skip
};
function getHandlers() {
  return handlers;
}
function copyImportRefField(src, dst, key) {
  const ref = src[key];
  if (!ref)
    return;
  dst[key] = copyImportFileRef(ref);
}
function copyImportsField(src, dst, key) {
  const imports = src[key];
  if (!imports)
    return;
  dst[key] = new Map([...imports.entries()].map(([k, v]) => [k, copyImportFileRef(v)]));
}
function copyImportFileRef(src) {
  const ref = { filename: src.filename };
  copy0(src, ref, "error");
  return ref;
}
function copySourceField(src, dst, key) {
  if (!src[key])
    return;
  dst[key] = copySource(src[key]);
}
function copySource(src) {
  const source = { name: src.name };
  cpy(src, source, "filename");
  return source;
}
function copyGlobsSettingsFields(src, dst, key) {
  const globs = src[key];
  if (!globs)
    return;
  dst[key] = copyGlobOrGlobs(globs);
}
function copyGlobsOverrideFields(src, dst, key) {
  const globs = src[key];
  if (!globs)
    return;
  dst[key] = copyGlobOrGlobs(globs);
}
function copyGlobOrGlobs(globOrGlobs) {
  if (Array.isArray(globOrGlobs)) {
    return globOrGlobs.map(copyGlob);
  }
  return copyGlob(globOrGlobs);
}
function copyGlob(glob) {
  if (typeof glob === "string") {
    return glob;
  }
  const g = { glob: glob.glob };
  cpy(glob, g, "root");
  return g;
}
function copyDictionaryDefinitions(src, dst, key) {
  const defs = src[key];
  if (!defs)
    return;
  dst[key] = defs.map(copyDictionaryDefinition);
}
function copyDictionaryDefinition(src) {
  const def = { name: src.name };
  cpy(src, def, "path");
  cpy(src, def, "type");
  cpy(src, def, "description");
  return def;
}
function copyLanguageSettings(src, dst, key) {
  const langSettings = src[key];
  if (!langSettings)
    return;
  dst[key] = langSettings.map((src2) => {
    const dst2 = { languageId: src2.languageId };
    copyLanguageSetting(src2, dst2);
    return dst2;
  });
}
function cpy(src, dst, key) {
  const value = src[key];
  if (value === void 0)
    return;
  dst[key] = value;
}
var LanguageSettingsHandlers = {
  id: cpy,
  locale: cpy,
  local: cpy,
  allowCompoundWords: copy1,
  caseSensitive: copy1,
  description: skip,
  dictionaries: copy1,
  dictionaryDefinitions: copyDictionaryDefinitions,
  enabled: copy1,
  flagWords: copy1,
  ignoreRegExpList: copy1,
  ignoreWords: copy1,
  includeRegExpList: copy1,
  languageId: copy1,
  name: skip,
  noSuggestDictionaries: copy1,
  patterns: copyPatternsField,
  suggestWords: copy1,
  unknownWords: copy1,
  words: copy1,
  // Experimental
  parser: skip
};
function copyLanguageSetting(src, dst) {
  cloneInto(src, dst, LanguageSettingsHandlers);
}
var RegExpPatternDefinitionHandlers = {
  name: cpy,
  pattern: copy1,
  description: cpy
};
function copyPatternsField(src, dst, key) {
  const patterns = src[key];
  if (!patterns)
    return;
  dst[key] = patterns.map((p) => {
    const dst2 = { pattern: p.pattern, name: p.name };
    copyRegExpPatternDefinition(p, dst2);
    return dst2;
  });
}
function copyRegExpPatternDefinition(src, dst) {
  cloneInto(src, dst, RegExpPatternDefinitionHandlers);
}
var OverridesHandlers = {
  id: copy1,
  allowCompoundWords: copy1,
  caseSensitive: copy1,
  description: copy1,
  dictionaries: copy1,
  dictionaryDefinitions: copyDictionaryDefinitions,
  enabled: copy1,
  enabledFileTypes: copy1,
  enabledLanguageIds: copy1,
  enableFiletypes: copy1,
  filename: copyGlobsOverrideFields,
  flagWords: copy1,
  ignoreRandomStrings: copy1,
  ignoreRegExpList: copy1,
  ignoreWords: copy1,
  includeRegExpList: copy1,
  language: copy1,
  languageId: copy1,
  languageSettings: copyLanguageSettings,
  loadDefaultConfiguration: copy1,
  maxDuplicateProblems: copy1,
  maxFileSize: copy1,
  maxNumberOfProblems: copy1,
  minRandomLength: copy1,
  minWordLength: copy1,
  name: skip,
  noSuggestDictionaries: copy1,
  numSuggestions: copy1,
  patterns: copyPatternsField,
  pnpFiles: skip,
  suggestionNumChanges: copy1,
  suggestionsTimeout: copy1,
  suggestWords: copy1,
  unknownWords: copy1,
  usePnP: skip,
  words: copy1,
  parser: skip
};
function copyOverrides(src, dst, key) {
  const overrides = src[key];
  if (!overrides)
    return;
  dst[key] = overrides.map((src2) => {
    const dst2 = {};
    cloneInto(src2, dst2, OverridesHandlers);
    return dst2;
  });
}

// ../../node_modules/cspell-lib/dist/lib/textValidation/determineTextDocumentSettings.js
init_shim();
init_path_browserify_win32();

// src/shims/cspell-settings-index-lite.js
init_shim();

// ../../node_modules/cspell-lib/dist/lib/Settings/calcOverrideSettings.js
init_shim();

// ../../node_modules/cspell-lib/dist/lib/globs/checkFilenameMatchesGlob.js
init_shim();

// ../../node_modules/cspell-lib/dist/lib/globs/getGlobMatcher.js
init_shim();

// ../../node_modules/cspell-glob/dist/index.js
init_shim();
init_path_browserify_win32();
var import_picomatch = __toESM(require_picomatch2(), 1);
var { posix: posix2 } = path_browserify_win32_exports;
var isGlobalPatternRegExp = /^!*[*]{2}/;
var fileUrlBuilder2 = new FileUrlBuilder();
var GlobPlaceHolders = { cwd: "${cwd}" };
var GlobPatterns = {
  suffixAny: "/**",
  suffixDir: "/**/*",
  prefixAny: "**/"
};
function isGlobPatternWithOptionalRoot(g) {
  return typeof g !== "string" && typeof g.glob === "string";
}
function isGlobPatternWithRoot(g) {
  if (typeof g === "string") return false;
  return typeof g.root === "string" && "isGlobalPattern" in g;
}
function isGlobPatternNormalized(g) {
  if (!isGlobPatternWithRoot(g)) return false;
  const gr = g;
  return "rawGlob" in gr && "rawRoot" in gr && typeof gr.rawGlob === "string";
}
function isGlobPatternNormalizedToRoot(g, options) {
  if (!isGlobPatternNormalized(g)) return false;
  return g.root === options.root;
}
function urlBuilder(path = path_browserify_win32_exports) {
  return path === path_browserify_win32_exports ? fileUrlBuilder2 : new FileUrlBuilder({ path });
}
function normalizePattern(pattern, nested) {
  pattern = pattern.replace(/^(!!)+/, "");
  const isNeg = pattern.startsWith("!");
  const prefix = isNeg ? "!" : "";
  pattern = isNeg ? pattern.slice(1) : pattern;
  return (nested ? normalizePatternNested(pattern) : normalizePatternGeneral(pattern)).map((p) => prefix + p);
}
function normalizePatternNested(pattern) {
  if (!pattern.includes("/")) {
    if (pattern === "**") return ["**"];
    return ["**/" + pattern, "**/" + pattern + "/**"];
  }
  const hasLeadingSlash = pattern.startsWith("/");
  pattern = hasLeadingSlash ? pattern.slice(1) : pattern;
  if (pattern.endsWith("/")) return hasLeadingSlash || pattern.slice(0, -1).includes("/") ? [pattern + "**/*"] : ["**/" + pattern + "**/*"];
  if (pattern.endsWith("**")) return [pattern];
  return [pattern, pattern + "/**"];
}
function normalizePatternGeneral(pattern) {
  pattern = pattern.startsWith("/") ? pattern.slice(1) : pattern;
  pattern = pattern.endsWith("/") ? pattern + "**/*" : pattern;
  return [pattern];
}
function normalizeGlobPatterns(patterns, options) {
  function* normalize4() {
    for (const glob of patterns) {
      if (isGlobPatternNormalized(glob)) {
        yield isGlobPatternNormalizedToRoot(glob, options) ? glob : normalizeGlobToRoot(glob, options.root, options.nodePath || path_browserify_win32_exports);
        continue;
      }
      yield* normalizeGlobPattern(glob, options);
    }
  }
  return [...normalize4()];
}
function normalizeGlobPattern(g, options) {
  var _a19, _b2;
  const { root, nodePath: path = path_browserify_win32_exports, nested } = options;
  const builder = urlBuilder(path);
  const cwd = (_a19 = options.cwd) != null ? _a19 : path.resolve();
  const cwdUrl = builder.toFileDirURL(cwd);
  const rootUrl2 = builder.toFileDirURL(root, cwdUrl);
  const gIsGlobalPattern = isGlobPatternWithRoot(g) ? g.isGlobalPattern : void 0;
  g = !isGlobPatternWithOptionalRoot(g) ? { glob: g } : g;
  const gr = {
    ...g,
    root: (_b2 = g.root) != null ? _b2 : root
  };
  const rawRoot = gr.root;
  const rawGlob = g.glob;
  gr.glob = trimGlob(g.glob);
  if (gr.glob.startsWith(GlobPlaceHolders.cwd)) {
    gr.glob = gr.glob.replace(GlobPlaceHolders.cwd, "");
    gr.root = GlobPlaceHolders.cwd;
  }
  if (gr.root.startsWith(GlobPlaceHolders.cwd)) {
    const relRoot = gr.root.replace(GlobPlaceHolders.cwd, "./");
    const r = builder.toFileDirURL(relRoot, cwdUrl);
    r.pathname = posix2.normalize(r.pathname);
    gr.root = builder.urlToFilePathOrHref(r);
  }
  const isGlobalPattern = gIsGlobalPattern != null ? gIsGlobalPattern : isGlobalGlob(gr.glob);
  gr.root = builder.urlToFilePathOrHref(builder.toFileDirURL(gr.root, rootUrl2));
  return normalizePattern(gr.glob, nested).map((glob) => ({
    ...gr,
    glob,
    rawGlob,
    rawRoot,
    isGlobalPattern
  }));
}
function normalizeGlobToRoot(glob, root, path) {
  const builder = urlBuilder(path);
  glob = { ...glob };
  fixPatternRoot(glob, builder);
  const rootURL = builder.toFileDirURL(root);
  root = builder.urlToFilePathOrHref(rootURL);
  if (glob.root === root) return glob;
  const globRootUrl = builder.toFileDirURL(glob.root);
  const relFromRootToGlob = builder.relative(rootURL, globRootUrl);
  if (!relFromRootToGlob) return glob;
  if (glob.isGlobalPattern) return {
    ...glob,
    root
  };
  const relFromGlobToRoot = builder.relative(globRootUrl, rootURL);
  const globIsUnderRoot = isRelativeValueNested(relFromRootToGlob);
  const rootIsUnderGlob = isRelativeValueNested(relFromGlobToRoot);
  if (!globIsUnderRoot && !rootIsUnderGlob) return glob;
  const isNeg = glob.glob.startsWith("!");
  const g = isNeg ? glob.glob.slice(1) : glob.glob;
  const prefix = isNeg ? "!" : "";
  if (globIsUnderRoot) {
    const relGlob = relFromRootToGlob;
    return {
      ...glob,
      glob: prefix + posix2.join(relGlob, g),
      root
    };
  }
  const rebasedGlob = rebaseGlob(g, nRel(relFromRootToGlob), nRel(relFromGlobToRoot));
  return rebasedGlob ? {
    ...glob,
    glob: prefix + rebasedGlob,
    root
  } : glob;
}
function nRel(rel) {
  return rel.endsWith("/") ? rel : rel + "/";
}
function isRelativeValueNested(rel) {
  return !rel || !(rel === ".." || rel.startsWith("../") || rel.startsWith("/"));
}
function rebaseGlob(glob, fromRootToGlob, fromGlobToRoot) {
  if (!fromGlobToRoot || fromGlobToRoot === "/") return glob;
  if (fromRootToGlob.startsWith("../") && !fromGlobToRoot.startsWith("../") && glob.startsWith("**")) return glob;
  fromRootToGlob = nRel(fromRootToGlob);
  fromGlobToRoot = nRel(fromGlobToRoot);
  const relToParts = fromRootToGlob.split("/");
  const relFromParts = fromGlobToRoot.split("/");
  if (glob.startsWith(fromGlobToRoot) && fromRootToGlob === "../".repeat(relToParts.length - 1)) return glob.slice(fromGlobToRoot.length);
  const lastRelIdx = relToParts.findIndex((s) => s !== "..");
  const lastRel = lastRelIdx < 0 ? relToParts.length : lastRelIdx;
  const globParts = [...relToParts.slice(lastRel).filter((a) => a), ...glob.split("/")];
  relToParts.length = lastRel;
  if (fromRootToGlob.startsWith("../") && relFromParts.length !== relToParts.length + 1) return fromRootToGlob + (glob.startsWith("/") ? glob.slice(1) : glob);
  for (let i = 0; i < relFromParts.length && i < globParts.length; ++i) {
    const relSeg = relFromParts[i];
    const globSeg = globParts[i];
    if (!relSeg || globSeg === "**") return globParts.slice(i).join("/");
    if (relSeg !== globSeg && globSeg !== "*") break;
  }
  return fromRootToGlob + (glob.startsWith("/") ? glob.slice(1) : glob);
}
function trimGlob(glob) {
  glob = globRemoveComment(glob);
  glob = trimGlobLeft(glob);
  glob = trimGlobRight(glob);
  return glob;
}
function globRemoveComment(glob) {
  return glob.replace(/(?<=^|\s)#.*/, "");
}
var spaces = {
  " ": true,
  "	": true,
  "\n": true,
  "\r": true
};
function trimGlobRight(glob) {
  let i = glob.length - 1;
  while (i >= 0 && glob[i] in spaces) --i;
  if (glob[i] === "\\") ++i;
  ++i;
  return i ? glob.slice(0, i) : "";
}
function trimGlobLeft(glob) {
  return glob.trimStart();
}
function isGlobalGlob(glob) {
  return isGlobalPatternRegExp.test(glob);
}
function rootToUrl(root, builder) {
  if (root.startsWith(GlobPlaceHolders.cwd)) return new URL(builder.normalizeFilePathForUrl(root.replace(GlobPlaceHolders.cwd, ".")), builder.cwd);
  return builder.toFileDirURL(root);
}
function fixPatternRoot(glob, builder) {
  if (glob.root.startsWith(GlobPlaceHolders.cwd)) return glob;
  glob.root = builder.urlToFilePathOrHref(rootToUrl(glob.root, builder));
  return glob;
}
function workaroundPicomatchBug(glob) {
  const obj = {};
  return glob.split("/").map((s) => obj[s] ? `{${s},${s}}` : s).join("/");
}
var idGlobMatcher = 0;
var GlobMatcher = class {
  constructor(patterns, rootOrOptions, _nodePath) {
    /**
    * @param filename full path of file to match against.
    * @returns a GlobMatch - information about the match.
    */
    __publicField(this, "matchEx");
    __publicField(this, "path");
    __publicField(this, "patterns");
    __publicField(this, "patternsNormalizedToRoot");
    /**
    * path or href of the root directory.
    */
    __publicField(this, "root");
    __publicField(this, "dot");
    __publicField(this, "options");
    /**
    * Instance ID
    */
    __publicField(this, "id");
    var _a19, _b2, _c, _d, _e, _f, _g;
    this.id = idGlobMatcher++;
    const options = typeof rootOrOptions === "string" || rootOrOptions instanceof URL ? { root: rootOrOptions.toString() } : rootOrOptions != null ? rootOrOptions : {};
    const mode = (_a19 = options.mode) != null ? _a19 : "exclude";
    const isExcludeMode = mode !== "include";
    const nodePath = (_c = (_b2 = options.nodePath) != null ? _b2 : _nodePath) != null ? _c : path_browserify_win32_exports;
    this.path = nodePath;
    const cwd = (_d = options.cwd) != null ? _d : nodePath.resolve();
    const dot = (_e = options.dot) != null ? _e : isExcludeMode;
    const nested = (_f = options.nested) != null ? _f : isExcludeMode;
    const nobrace = options.nobrace;
    const root = (_g = options.root) != null ? _g : nodePath.resolve();
    const builder = new FileUrlBuilder({ path: nodePath });
    const rootURL = builder.toFileDirURL(root);
    const normalizedRoot = builder.urlToFilePathOrHref(rootURL);
    this.options = {
      root: normalizedRoot,
      dot,
      nodePath,
      nested,
      mode,
      nobrace,
      cwd
    };
    patterns = Array.isArray(patterns) ? patterns : typeof patterns === "string" ? patterns.split(/\r?\n/g) : [patterns];
    const globPatterns = normalizeGlobPatterns(patterns, this.options);
    this.patternsNormalizedToRoot = globPatterns.map((g) => normalizeGlobToRoot(g, normalizedRoot, nodePath)).filter((g) => builder.relative(builder.toFileDirURL(g.root), rootURL) === "");
    this.patterns = globPatterns;
    this.root = normalizedRoot;
    this.dot = dot;
    this.matchEx = buildMatcherFn(this.id, this.patterns, this.options);
  }
  /**
  * Check to see if a filename matches any of the globs.
  * If filename is relative, it is considered relative to the root.
  * If filename is absolute and contained within the root, it will be made relative before being tested for a glob match.
  * If filename is absolute and not contained within the root, it will be tested as is.
  * @param filename full path of the file to check.
  */
  match(filename) {
    return this.matchEx(filename).matched;
  }
};
function buildMatcherFn(_id, patterns, options) {
  const { nodePath, dot, nobrace } = options;
  const builder = new FileUrlBuilder({ path: nodePath });
  const makeReOptions = {
    dot,
    nobrace
  };
  const suffixDir = GlobPatterns.suffixDir;
  const rules = patterns.map((pattern, index) => ({
    pattern,
    index
  })).filter((r) => !!r.pattern.glob).filter((r) => !r.pattern.glob.startsWith("#")).map(({ pattern, index }) => {
    const matchNeg = pattern.glob.match(/^!/);
    const glob = pattern.glob.replace(/^!/, "");
    const isNeg = matchNeg && matchNeg[0].length & 1 && true || false;
    const reg = import_picomatch.default.makeRe(workaroundPicomatchBug(glob), makeReOptions);
    return {
      pattern,
      index,
      isNeg,
      fn: pattern.glob.endsWith(suffixDir) ? (filename) => {
        return reg.test(filename) || filename.endsWith("/") && reg.test(filename + " ");
      } : (filename) => {
        return reg.test(filename);
      },
      reg
    };
  });
  const negRules = rules.filter((r) => r.isNeg);
  const posRules = rules.filter((r) => !r.isNeg);
  const mapRoots = /* @__PURE__ */ new Map();
  const fn = (filename) => {
    const fileUrl = builder.toFileURL(filename);
    const relFilePathname = builder.relative(new URL("file:///"), fileUrl);
    let lastRoot = new URL("placeHolder://");
    let lastRel = "";
    function rootToUrl2(root) {
      const found = mapRoots.get(root);
      if (found) return found;
      const url = builder.toFileDirURL(root);
      mapRoots.set(root, url);
      return url;
    }
    function relativeToRoot(root) {
      if (root.href !== lastRoot.href) {
        lastRoot = root;
        lastRel = builder.relative(root, fileUrl);
      }
      return lastRel;
    }
    function testRules(rules2, matched) {
      for (const rule of rules2) {
        const pattern = rule.pattern;
        const root = pattern.root;
        const rootURL = rootToUrl2(root);
        const isRelPat = !pattern.isGlobalPattern;
        let fname = relFilePathname;
        if (isRelPat) {
          const relPathToFile = relativeToRoot(rootURL);
          if (!isRelativeValueNested(relPathToFile)) continue;
          fname = relPathToFile;
        }
        if (rule.fn(fname)) return {
          matched,
          glob: pattern.glob,
          root,
          pattern,
          index: rule.index,
          isNeg: rule.isNeg
        };
      }
    }
    return testRules(negRules, false) || testRules(posRules, true) || { matched: false };
  };
  return fn;
}

// ../../node_modules/cspell-lib/dist/lib/events/index.js
init_shim();

// ../../node_modules/cspell-lib/dist/lib/events/events.js
init_shim();

// ../../node_modules/cspell-lib/dist/lib/util/errors.js
init_shim();
var import_node_util2 = __toESM(require_util(), 1);
var allowStringOrUndefined = {
  string: true,
  undefined: true
};
function isError2(e) {
  if (e instanceof Error)
    return true;
  if (!e || typeof e !== "object")
    return false;
  const ex = e;
  return typeof ex.name === "string" && typeof ex.message === "string" && typeof ex.stack in allowStringOrUndefined;
}
function toError2(e, errorFactory = UnknownError) {
  if (isError2(e))
    return e;
  return new errorFactory(e);
}
var UnknownError = class extends Error {
  constructor(cause) {
    super((0, import_node_util2.format)(cause));
    __publicField(this, "cause");
    this.cause = cause;
  }
};
function catchPromiseError(p, handler) {
  if (p === void 0)
    return void 0;
  return _catchPromiseError(p, handler);
}
async function _catchPromiseError(p, handler) {
  try {
    return await p;
  } catch (e) {
    return handler(e);
  }
}

// ../../node_modules/cspell-lib/dist/lib/events/events.js
var _listeners;
var EventEmitter = class {
  constructor(name) {
    __publicField(this, "name");
    __privateAdd(this, _listeners, /* @__PURE__ */ new Set());
    /**
     * The event listeners can subscribe to.
     */
    __publicField(this, "on", (listener) => {
      __privateGet(this, _listeners).add(listener);
      return {
        dispose: () => {
          __privateGet(this, _listeners).delete(listener);
        }
      };
    });
    /**
     * Dispose this object and free resources.
     */
    __publicField(this, "dispose", () => {
      __privateGet(this, _listeners).clear();
    });
    this.name = name;
  }
  /**
   * Notify all subscribers of the {@link EventEmitter.on event}. Failure
   * of one or more listener will not fail this function call.
   *
   * @param data The event object.
   */
  fire(event) {
    let errors;
    for (const listener of __privateGet(this, _listeners)) {
      try {
        listener(event);
      } catch (e) {
        errors = errors != null ? errors : [];
        errors.push(toError2(e));
      }
    }
    return errors;
  }
};
_listeners = new WeakMap();
var _ClearCacheEvent = class _ClearCacheEvent extends EventEmitter {
  constructor() {
    super(_ClearCacheEvent.eventName);
  }
};
__publicField(_ClearCacheEvent, "eventName", "clear-cache");
var ClearCacheEvent = _ClearCacheEvent;
var clearCacheEvent = new ClearCacheEvent();
function onClearCache(listener) {
  return clearCacheEvent.on(listener);
}

// ../../node_modules/cspell-lib/dist/lib/globs/getGlobMatcher.js
var simpleGlobCache = /* @__PURE__ */ new Map();
var globCache = /* @__PURE__ */ new WeakMap();
onClearCache(() => {
  globCache = /* @__PURE__ */ new WeakMap();
  simpleGlobCache.clear();
});
var emptyIgnorePaths = [];
function getGlobMatcherForExcluding(glob) {
  if (!glob || Array.isArray(glob) && !glob.length)
    return getGlobMatcherGlobGlob(emptyIgnorePaths);
  return typeof glob === "string" ? getGlobMatcherGlobString(glob) : getGlobMatcherGlobGlob(glob);
}
function getGlobMatcherGlobString(glob) {
  const cached = simpleGlobCache.get(glob);
  if (cached)
    return cached;
  const m = new GlobMatcher(glob);
  simpleGlobCache.set(glob, m);
  return m;
}
function getGlobMatcherGlobGlob(glob) {
  const cached = globCache.get(glob);
  if (cached)
    return cached;
  const m = new GlobMatcher(glob);
  globCache.set(glob, m);
  return m;
}

// ../../node_modules/cspell-lib/dist/lib/globs/checkFilenameMatchesGlob.js
function checkFilenameMatchesExcludeGlob(filename, globs) {
  const m = getGlobMatcherForExcluding(globs);
  return m.match(filename);
}

// ../../node_modules/cspell-lib/dist/lib/Settings/CSpellSettingsServer.js
init_shim();
var import_node_assert5 = __toESM(require_assert());

// ../../node_modules/cspell-lib/dist/lib/util/AutoResolve.js
init_shim();
function autoResolve2(map2, key, resolve2) {
  const found = map2.get(key);
  if (found !== void 0 || map2.has(key))
    return found;
  const value = resolve2(key);
  map2.set(key, value);
  return value;
}
var CacheStatsTracker = class {
  constructor() {
    __publicField(this, "hits", 0);
    __publicField(this, "misses", 0);
    __publicField(this, "resolved", 0);
    __publicField(this, "deletes", 0);
    __publicField(this, "sets", 0);
    __publicField(this, "clears", 0);
    __publicField(this, "disposals", 0);
  }
  stats() {
    return {
      hits: this.hits,
      misses: this.misses,
      resolved: this.resolved,
      deletes: this.deletes,
      sets: this.sets,
      clears: this.clears,
      disposals: this.disposals
    };
  }
  clear() {
    this.hits = 0;
    this.misses = 0;
    this.resolved = 0;
    this.deletes = 0;
    this.sets = 0;
    ++this.clears;
  }
};
var AutoResolveCache = class {
  constructor() {
    __publicField(this, "map", /* @__PURE__ */ new Map());
  }
  get(k, resolve2) {
    return resolve2 ? autoResolve2(this.map, k, resolve2) : this.map.get(k);
  }
  has(k) {
    return this.map.has(k);
  }
  set(k, v) {
    this.map.set(k, v);
    return this;
  }
  delete(k) {
    return this.map.delete(k);
  }
  clear() {
    this.map.clear();
  }
  dispose() {
    this.clear();
  }
};
function createAutoResolveCache() {
  return new AutoResolveCache();
}
function autoResolveWeak(map2, key, resolve2) {
  const found = map2.get(key);
  if (found !== void 0 || map2.has(key))
    return found;
  const value = resolve2(key);
  map2.set(key, value);
  return value;
}
var AutoResolveWeakCache = class {
  constructor() {
    __publicField(this, "_map", /* @__PURE__ */ new WeakMap());
    __publicField(this, "_stats", new CacheStatsTracker());
  }
  get(k, resolve2) {
    const map2 = this._map;
    const found = map2.get(k);
    if (found !== void 0 || map2.has(k)) {
      ++this._stats.hits;
      return found;
    }
    ++this._stats.misses;
    if (!resolve2) {
      return void 0;
    }
    ++this._stats.resolved;
    const value = resolve2(k);
    map2.set(k, value);
    return value;
  }
  get map() {
    return this._map;
  }
  has(k) {
    return this._map.has(k);
  }
  set(k, v) {
    ++this._stats.sets;
    this._map.set(k, v);
    return this;
  }
  clear() {
    this._stats.clear();
    this._map = /* @__PURE__ */ new WeakMap();
  }
  delete(k) {
    ++this._stats.deletes;
    return this._map.delete(k);
  }
  dispose() {
    ++this._stats.disposals;
    this.clear();
  }
  stats() {
    return this._stats.stats();
  }
};
function createAutoResolveWeakCache() {
  return new AutoResolveWeakCache();
}
var AutoResolveWeakWeakCache = class {
  constructor() {
    __publicField(this, "_map", /* @__PURE__ */ new WeakMap());
    __publicField(this, "_stats", new CacheStatsTracker());
  }
  get(k, resolve2) {
    const map2 = this._map;
    const found = map2.get(k);
    const foundValue = found == null ? void 0 : found.deref();
    if (found !== void 0 && foundValue) {
      ++this._stats.hits;
      return foundValue;
    }
    ++this._stats.misses;
    if (!resolve2) {
      if (found) {
        map2.delete(k);
      }
      return void 0;
    }
    ++this._stats.resolved;
    const value = resolve2(k);
    map2.set(k, new WeakRef(value));
    return value;
  }
  get map() {
    return this._map;
  }
  has(k) {
    var _a19;
    return !!((_a19 = this._map.get(k)) == null ? void 0 : _a19.deref());
  }
  set(k, v) {
    ++this._stats.sets;
    this._map.set(k, new WeakRef(v));
    return this;
  }
  clear() {
    this._stats.clear();
    this._map = /* @__PURE__ */ new WeakMap();
  }
  delete(k) {
    ++this._stats.deletes;
    return this._map.delete(k);
  }
  dispose() {
    ++this._stats.disposals;
    this.clear();
  }
  stats() {
    return this._stats.stats();
  }
};
function createAutoResolveWeakWeakCache() {
  return new AutoResolveWeakWeakCache();
}

// ../../node_modules/cspell-lib/dist/lib/util/url.js
init_shim();
function cwdURL() {
  return toFileDirURL("./");
}
function toFileUrl(file) {
  return toFileURL(file, cwdURL());
}

// ../../node_modules/cspell-lib/dist/lib/Settings/constants.js
init_shim();
var configSettingsFileVersion0_1 = "0.1";
var ENV_CSPELL_GLOB_ROOT = "CSPELL_GLOB_ROOT";

// ../../node_modules/cspell-lib/dist/lib/Settings/internal/index.js
init_shim();

// ../../node_modules/cspell-lib/dist/lib/Settings/internal/CSpellSettingsInternalDef.js
init_shim();
var SymbolCSpellSettingsInternal = /* @__PURE__ */ Symbol("CSpellSettingsInternal");
function cleanCSpellSettingsInternal(parts) {
  return parts ? Object.assign(clean(parts), { [SymbolCSpellSettingsInternal]: true }) : { [SymbolCSpellSettingsInternal]: true };
}
function isCSpellSettingsInternal(cs) {
  return !!cs[SymbolCSpellSettingsInternal];
}

// ../../node_modules/cspell-lib/dist/lib/Settings/internal/DictionarySettings.js
init_shim();
init_path_browserify_win32();

// ../../node_modules/cspell-trie-lib/dist/index.js
init_shim();
function* iteratorToIterable(iterator) {
  var _a19;
  try {
    let n;
    while (!(n = iterator.next()).done) yield n.value;
  } catch (e) {
    if (iterator.throw) return iterator.throw(e);
    throw e;
  } finally {
    (_a19 = iterator.return) == null ? void 0 : _a19.call(iterator);
  }
}
function opAppendSync(...iterablesToAppend) {
  function* fnAppend(iter) {
    yield* iter;
    for (const i of iterablesToAppend) yield* i;
  }
  return fnAppend;
}
function opCombineSync(...fns) {
  function combine3(iter) {
    for (const fn of fns) iter = fn(iter);
    return iter;
  }
  return combine3;
}
function opConcatMapSync(mapFn) {
  function fnConcatMapSync(iterable) {
    function opConcatMapIterator() {
      const iter = iterable[Symbol.iterator]();
      let resultsIter = void 0;
      function nextConcatMap() {
        while (true) {
          if (resultsIter) {
            const { done: done2, value: value2 } = resultsIter.next();
            if (!done2) return { value: value2 };
            resultsIter = void 0;
          }
          const { done, value } = iter.next();
          if (done) return {
            done,
            value: void 0
          };
          resultsIter = mapFn(value)[Symbol.iterator]();
        }
      }
      return { next: nextConcatMap };
    }
    return { [Symbol.iterator]: opConcatMapIterator };
  }
  return fnConcatMapSync;
}
function opFilterSync(filterFn) {
  function opFilterIterable(iterable) {
    function opFilterIterator() {
      const iter = iterable[Symbol.iterator]();
      function nextOpFilter() {
        while (true) {
          const { done, value } = iter.next();
          if (done) return {
            done,
            value: void 0
          };
          if (filterFn(value)) return { value };
        }
      }
      return { next: nextOpFilter };
    }
    return { [Symbol.iterator]: opFilterIterator };
  }
  return opFilterIterable;
}
function opFlattenSync() {
  function* fn(iter) {
    for (const v of iter) yield* v;
  }
  return fn;
}
function opMapSync(mapFn) {
  function opMapIterable(iterable) {
    function opMapIterator() {
      const iter = iterable[Symbol.iterator]();
      function nextOpMap() {
        const { done, value } = iter.next();
        if (done) return {
          done,
          value: void 0
        };
        return { value: mapFn(value) };
      }
      return { next: nextOpMap };
    }
    return { [Symbol.iterator]: opMapIterator };
  }
  return opMapIterable;
}
function opReduceSync(reduceFn, initialValue) {
  function* reduce2(head, tail) {
    for (const v of tail) head = reduceFn(head, v);
    yield head;
  }
  function* fn(iter) {
    const ht = initialValue === void 0 ? headTail(iter) : {
      head: initialValue,
      tail: iter
    };
    if (!ht) return;
    yield* reduce2(ht.head, ht.tail);
  }
  return fn;
}
function headTail(iter) {
  const iterator = iter[Symbol.iterator]();
  const first2 = iterator.next();
  if (first2.done) return void 0;
  return {
    head: first2.value,
    tail: iteratorToIterable(iterator)
  };
}
function opUniqueSync(k) {
  function fnK(key) {
    function* fn2(iter) {
      const s = /* @__PURE__ */ new Set();
      for (const v of iter) {
        const kk = key(v);
        if (s.has(kk)) continue;
        s.add(kk);
        yield v;
      }
    }
    return fn2;
  }
  function* fn(iter) {
    const s = /* @__PURE__ */ new Set();
    for (const v of iter) {
      if (s.has(v)) continue;
      s.add(v);
      yield v;
    }
  }
  return k ? fnK(k) : fn;
}
function pipeSync(i, ...fns) {
  return opCombineSync(...fns)(i);
}
function reduceSync(iter, reduceFn, initialValue) {
  return [...initialValue === void 0 ? pipeSync(iter, opReduceSync(reduceFn)) : pipeSync(iter, opReduceSync(reduceFn, initialValue))][0];
}
var SymEmpty = /* @__PURE__ */ Symbol("memorizeLastCall");
function memorizeLastCall(fn) {
  let lastP = void 0;
  let lastR = SymEmpty;
  function calc(p) {
    if (lastP === p && lastR !== SymEmpty) return lastR;
    lastP = p;
    lastR = fn(p);
    return lastR;
  }
  return calc;
}
var defaultLegacyMinCompoundLength$2 = 3;
var _defaultFindOptions$1 = {
  matchCase: false,
  compoundMode: "compound",
  legacyMinCompoundLength: defaultLegacyMinCompoundLength$2
};
Object.freeze(_defaultFindOptions$1);
var knownCompoundModes$1 = new Map([
  "none",
  "compound",
  "legacy"
].map((a) => [a, a]));
var notFound = {
  found: false,
  compoundUsed: false,
  caseMatched: false,
  forbidden: void 0
};
Object.freeze(notFound);
function findWordNode$1(root, word, options) {
  return _findWordNode$1(root, word, options);
}
function findWord$1(root, word, options) {
  if (root.find && !(options == null ? void 0 : options.compoundSeparator)) {
    const found2 = root.find(word, (options == null ? void 0 : options.matchCase) || false);
    if (found2) {
      if ((options == null ? void 0 : options.checkForbidden) && found2.forbidden === void 0) found2.forbidden = isForbiddenWord$1(root, word, root.forbidPrefix);
      return found2;
    }
    if (!root.hasCompoundWords) return notFound;
  }
  const { found, compoundUsed, caseMatched, forbidden } = _findWordNode$1(root, word, options);
  const result = {
    found,
    compoundUsed,
    caseMatched,
    forbidden
  };
  if ((options == null ? void 0 : options.checkForbidden) && forbidden === void 0) result.forbidden = isForbiddenWord$1(root, word, root.forbidPrefix);
  return result;
}
function _findWordNode$1(root, word, options) {
  var _a19, _b2, _c;
  const trieInfo = root.info;
  const matchCase2 = (options == null ? void 0 : options.matchCase) || false;
  const compoundMode = knownCompoundModes$1.get(options == null ? void 0 : options.compoundMode) || _defaultFindOptions$1.compoundMode;
  const compoundPrefix = compoundMode === "compound" ? (_a19 = trieInfo.compoundCharacter) != null ? _a19 : root.compoundFix : "";
  const ignoreCasePrefix = matchCase2 ? "" : (_b2 = trieInfo.stripCaseAndAccentsPrefix) != null ? _b2 : root.caseInsensitivePrefix;
  const mustCheckForbidden = (options == null ? void 0 : options.checkForbidden) === true;
  const checkForbidden = (_c = options == null ? void 0 : options.checkForbidden) != null ? _c : true;
  const compoundSeparator = (options == null ? void 0 : options.compoundSeparator) || "";
  function __findCompound() {
    const f = findCompoundWord$1(root, word, compoundPrefix, ignoreCasePrefix, compoundSeparator);
    if (f.found !== false && (mustCheckForbidden || f.compoundUsed && checkForbidden)) f.forbidden = isForbiddenWord$1(!f.caseMatched ? walk$2(root, root.caseInsensitivePrefix) : root, word, root.forbidPrefix);
    return f;
  }
  function __findExact() {
    const n = root.getNode ? root.getNode(word) : walk$2(root, word);
    return {
      found: isEndOfWordNode$1(n) && word,
      compoundUsed: false,
      forbidden: checkForbidden ? isForbiddenWord$1(root, word, root.forbidPrefix) : void 0,
      node: n,
      caseMatched: true
    };
  }
  switch (compoundMode) {
    case "none":
      return matchCase2 ? __findExact() : __findCompound();
    case "compound":
      return __findCompound();
    case "legacy":
      return findLegacyCompound$1(root, word, options);
  }
}
function findLegacyCompound$1(root, word, options) {
  var _a19;
  const roots = [root];
  if (!(options == null ? void 0 : options.matchCase)) roots.push(walk$2(root, root.caseInsensitivePrefix));
  return findLegacyCompoundNode$1(roots, word, (options == null ? void 0 : options.legacyMinCompoundLength) || defaultLegacyMinCompoundLength$2, (_a19 = options == null ? void 0 : options.compoundSeparator) != null ? _a19 : "+");
}
function findCompoundNode$1(root, word, compoundCharacter, ignoreCasePrefix, compoundSeparator) {
  var _a19;
  const stack = [{
    n: root,
    compoundPrefix: ignoreCasePrefix,
    cr: void 0,
    caseMatched: true,
    s: ""
  }];
  const compoundPrefix = compoundCharacter || ignoreCasePrefix;
  const possibleCompoundPrefix = ignoreCasePrefix && compoundCharacter ? ignoreCasePrefix + compoundCharacter : "";
  const nw = word.normalize();
  const w = [...nw];
  function determineRoot(s) {
    const prefix = s.compoundPrefix;
    let r = root;
    let i2;
    for (i2 = 0; i2 < prefix.length && r; ++i2) r = r.get(prefix[i2]);
    const caseMatched2 = s.caseMatched && prefix[0] !== ignoreCasePrefix;
    return {
      n: s.n,
      compoundPrefix: prefix === compoundPrefix ? possibleCompoundPrefix : "",
      cr: r,
      caseMatched: caseMatched2,
      s: prefix.endsWith(compoundCharacter) ? compoundSeparator : ""
    };
  }
  let compoundUsed = false;
  let caseMatched = true;
  let i = 0;
  let node;
  while (true) {
    const s = stack[i];
    const h = w[i++];
    const n = s.cr || s.n;
    const c = h && (n == null ? void 0 : n.get(h)) || void 0;
    if (c && i < word.length) {
      caseMatched = s.caseMatched;
      stack[i] = {
        n: c,
        compoundPrefix,
        cr: void 0,
        caseMatched,
        s: ""
      };
    } else if (!c || !c.eow) {
      node = node || c;
      while (--i > 0) {
        const s2 = stack[i];
        if (!s2.compoundPrefix || !((_a19 = s2.n) == null ? void 0 : _a19.hasChildren())) continue;
        if (s2.n.get(compoundCharacter)) break;
      }
      if (i >= 0 && stack[i].compoundPrefix) {
        compoundUsed = i > 0;
        const r = determineRoot(stack[i]);
        stack[i] = r;
        if (!r.cr) break;
        if (!i && !r.caseMatched && nw !== nw.toLowerCase()) break;
      } else break;
    } else {
      node = c;
      caseMatched = s.caseMatched;
      break;
    }
  }
  function joinCompoundWord() {
    return stack.map((s) => s.s).map((c, i2) => c + w[i2]).join("");
  }
  const f = i === word.length && word || false;
  return {
    found: f && (compoundSeparator ? joinCompoundWord() : f),
    compoundUsed,
    node,
    forbidden: void 0,
    caseMatched
  };
}
function findCompoundWord$1(root, word, compoundCharacter, ignoreCasePrefix, compoundSeparator) {
  const { found, compoundUsed, node, caseMatched } = findCompoundNode$1(root, word, compoundCharacter, ignoreCasePrefix, compoundSeparator);
  if (!node || !node.eow) return {
    found: false,
    compoundUsed,
    node,
    forbidden: void 0,
    caseMatched
  };
  return {
    found,
    compoundUsed,
    node,
    forbidden: void 0,
    caseMatched
  };
}
function findWordExact$1(root, word) {
  const r = root;
  if (r == null ? void 0 : r.findExact) return r.findExact(word);
  return isEndOfWordNode$1(walk$2(root, word));
}
function isEndOfWordNode$1(n) {
  return !!(n == null ? void 0 : n.eow);
}
function walk$2(root, word) {
  const w = [...word];
  let n = root;
  let i = 0;
  while (n && i < w.length) {
    const h = w[i++];
    n = n.get(h);
  }
  return n;
}
function findLegacyCompoundNode$1(roots, word, minCompoundLength, compoundSeparator) {
  var _a19, _b2;
  const root = roots[0];
  const numRoots = roots.length;
  const stack = [{
    n: root,
    usedRoots: 1,
    subLength: 0,
    isCompound: false,
    cr: void 0,
    caseMatched: true
  }];
  const w = word;
  const wLen = w.length;
  let compoundUsed = false;
  let caseMatched = true;
  let i = 0;
  let node;
  while (true) {
    const s = stack[i];
    const h = w[i++];
    const c = (_a19 = s.cr || s.n) == null ? void 0 : _a19.get(h);
    if (c && i < wLen) stack[i] = {
      n: c,
      usedRoots: 0,
      subLength: s.subLength + 1,
      isCompound: s.isCompound,
      cr: void 0,
      caseMatched: s.caseMatched
    };
    else if (!c || !c.eow || c.eow && s.subLength < minCompoundLength - 1) {
      while (--i > 0) {
        const s2 = stack[i];
        if (s2.usedRoots < numRoots && ((_b2 = s2.n) == null ? void 0 : _b2.eow) && (s2.subLength >= minCompoundLength || !s2.subLength) && wLen - i >= minCompoundLength) break;
      }
      if (i > 0 || stack[i].usedRoots < numRoots) {
        compoundUsed = i > 0;
        const s2 = stack[i];
        s2.cr = roots[s2.usedRoots++];
        s2.subLength = 0;
        s2.isCompound = compoundUsed;
        s2.caseMatched = s2.caseMatched && s2.usedRoots <= 1;
      } else break;
    } else {
      node = c;
      caseMatched = s.caseMatched;
      break;
    }
  }
  function extractWord() {
    if (!word || i < word.length) return false;
    const letters = [];
    let subLen = 0;
    for (let j = 0; j < i; ++j) {
      const { subLength } = stack[j];
      if (subLength < subLen) letters.push(compoundSeparator);
      letters.push(word[j]);
      subLen = subLength;
    }
    return letters.join("");
  }
  return {
    found: extractWord(),
    compoundUsed,
    node,
    forbidden: void 0,
    caseMatched
  };
}
function isForbiddenWord$1(root, word, forbiddenPrefix) {
  const r = root;
  if (r == null ? void 0 : r.isForbidden) return r.isForbidden(word);
  return findWordExact$1(root == null ? void 0 : root.get(forbiddenPrefix), word);
}
var createFindOptions$1 = memorizeLastCall(_createFindOptions$1);
function _createFindOptions$1(options) {
  var _a19, _b2, _c, _d, _e;
  if (!options) return _defaultFindOptions$1;
  const d = _defaultFindOptions$1;
  return {
    matchCase: (_a19 = options.matchCase) != null ? _a19 : d.matchCase,
    compoundMode: (_b2 = options.compoundMode) != null ? _b2 : d.compoundMode,
    legacyMinCompoundLength: (_c = options.legacyMinCompoundLength) != null ? _c : d.legacyMinCompoundLength,
    checkForbidden: (_d = options.checkForbidden) != null ? _d : d.checkForbidden,
    compoundSeparator: (_e = options.compoundSeparator) != null ? _e : d.compoundSeparator
  };
}
var JOIN_SEPARATOR = "+";
var WORD_SEPARATOR = " ";
var CompoundWordsMethodEnum = {
  NONE: 0,
  SEPARATE_WORDS: 1,
  JOIN_WORDS: 2
};
var CompoundWordsMethod = {
  ...CompoundWordsMethodEnum,
  0: "NONE",
  1: "SEPARATE_WORDS",
  2: "JOIN_WORDS"
};
function* compoundWalker$1(root, compoundingMethod) {
  var _a19;
  const empty = Object.freeze([]);
  const roots = {
    [CompoundWordsMethod.NONE]: empty,
    [CompoundWordsMethod.JOIN_WORDS]: [[JOIN_SEPARATOR, root]],
    [CompoundWordsMethod.SEPARATE_WORDS]: [[WORD_SEPARATOR, root]]
  };
  const rc = roots[compoundingMethod].length ? roots[compoundingMethod] : void 0;
  function children(n) {
    if (n.hasChildren()) {
      const entries = n.entries();
      const c = Array.isArray(entries) ? entries : [...entries];
      return n.eow && rc ? [...c, ...rc] : c;
    }
    if (n.eow) return roots[compoundingMethod];
    return empty;
  }
  let depth = 0;
  const stack = [];
  stack[depth] = {
    t: "",
    c: children(root),
    ci: 0
  };
  while (depth >= 0) {
    let s = stack[depth];
    let baseText = s.t;
    while (s.ci < s.c.length) {
      const [char, node] = s.c[s.ci++];
      const text = baseText + char;
      if ((_a19 = yield {
        text,
        node,
        depth
      }) != null ? _a19 : true) {
        depth++;
        baseText = text;
        stack[depth] = {
          t: text,
          c: children(node),
          ci: 0
        };
      }
      s = stack[depth];
    }
    depth -= 1;
  }
}
function* nodeWalker$1(root) {
  let depth = 0;
  const stack = [];
  const entries = root.entries();
  stack[depth] = {
    t: "",
    n: root,
    c: Array.isArray(entries) ? entries : [...entries],
    ci: 0
  };
  while (depth >= 0) {
    let s = stack[depth];
    let baseText = s.t;
    while (s.ci < s.c.length && s.n) {
      const idx2 = s.ci++;
      const [char, node] = s.c[idx2];
      const text = baseText + char;
      if ((yield {
        text,
        node,
        depth
      }) !== false) {
        depth++;
        baseText = text;
        const s2 = stack[depth];
        const entries2 = node.entries();
        const c = Array.isArray(entries2) ? entries2 : [...entries2];
        if (s2) {
          s2.t = text;
          s2.n = node;
          s2.c = c;
          s2.ci = 0;
        } else stack[depth] = {
          t: text,
          n: node,
          c,
          ci: 0
        };
      }
      s = stack[depth];
    }
    depth -= 1;
  }
}
function walker$1(root, compoundingMethod = CompoundWordsMethod.NONE) {
  return compoundingMethod === CompoundWordsMethod.NONE ? nodeWalker$1(root) : compoundWalker$1(root, compoundingMethod);
}
function walkerWords$1(root) {
  return walkerWordsITrie(root);
}
function* walkerWordsITrie(root) {
  let depth = 0;
  const stack = [];
  const entries = root.entries();
  stack[depth] = {
    t: "",
    n: root,
    c: Array.isArray(entries) ? entries : [...entries],
    ci: 0
  };
  while (depth >= 0) {
    let s = stack[depth];
    let baseText = s.t;
    while (s.ci < s.c.length && s.n) {
      const [char, node] = s.c[s.ci++];
      if (!node) continue;
      const text = baseText + char;
      if (node.eow) yield text;
      depth++;
      baseText = text;
      const entries2 = node.entries();
      const c = Array.isArray(entries2) ? entries2 : [...entries2];
      if (stack[depth]) {
        s = stack[depth];
        s.t = text;
        s.n = node;
        s.c = c;
        s.ci = 0;
      } else stack[depth] = {
        t: text,
        n: node,
        c,
        ci: 0
      };
      s = stack[depth];
    }
    depth -= 1;
  }
}
function iteratorTrieWords$1(node) {
  return walkerWords$1(node);
}
function findNode$1(node, word) {
  for (let i = 0; i < word.length; ++i) {
    const n = node.get(word[i]);
    if (!n) return void 0;
    node = n;
  }
  return node;
}
function countWords$1(root) {
  const visited = /* @__PURE__ */ new Map();
  function walk(n) {
    const nestedCount = visited.get(n.id);
    if (nestedCount !== void 0) return nestedCount;
    let cnt = n.eow ? 1 : 0;
    visited.set(n, cnt);
    for (const c of n.values()) cnt += walk(c);
    visited.set(n, cnt);
    return cnt;
  }
  return walk(root);
}
var debuggerIsAttached = false;
function isDebuggerAttached() {
  return debuggerIsAttached;
}
function trieRootToITrieRoot(root) {
  return ImplITrieRoot.toITrieNode(root);
}
var EmptyKeys = Object.freeze([]);
var EmptyValues = Object.freeze([]);
var EmptyEntries = Object.freeze([]);
var _ImplITrieNode_instances, findTrieNode_fn, _a4;
var ImplITrieNode = (_a4 = class {
  constructor(node) {
    __privateAdd(this, _ImplITrieNode_instances);
    __publicField(this, "id");
    __publicField(this, "_keys");
    __publicField(this, "node");
    this.node = node;
    this.id = node;
  }
  /** flag End of Word */
  get eow() {
    return !!this.node.f;
  }
  /** number of children */
  get size() {
    if (!this.node.c) return 0;
    return this.keys().length;
  }
  /** get keys to children */
  keys() {
    if (this._keys) return this._keys;
    const keys3 = this.node.c ? Object.keys(this.node.c) : EmptyKeys;
    this._keys = keys3;
    return keys3;
  }
  /** get the child nodes */
  values() {
    return !this.node.c ? EmptyValues : Object.values(this.node.c).map((n) => _a4.toITrieNode(n));
  }
  entries() {
    return !this.node.c ? EmptyEntries : Object.entries(this.node.c).map(([k, n]) => [k, _a4.toITrieNode(n)]);
  }
  /** get child ITrieNode */
  get(char) {
    var _a19;
    const n = (_a19 = this.node.c) == null ? void 0 : _a19[char];
    if (!n) return void 0;
    return _a4.toITrieNode(n);
  }
  getNode(chars) {
    return this.findNode(chars);
  }
  has(char) {
    const c = this.node.c;
    return c && char in c || false;
  }
  child(keyIdx) {
    const char = this.keys()[keyIdx];
    const n = char && this.get(char);
    if (!n) throw new Error("Index out of range.");
    return n;
  }
  hasChildren() {
    return !!this.node.c;
  }
  findNode(word) {
    const node = __privateMethod(this, _ImplITrieNode_instances, findTrieNode_fn).call(this, word);
    return node && _a4.toITrieNode(node);
  }
  findExact(word) {
    const node = __privateMethod(this, _ImplITrieNode_instances, findTrieNode_fn).call(this, word);
    return !!node && !!node.f;
  }
  static toITrieNode(node) {
    return new this(node);
  }
}, _ImplITrieNode_instances = new WeakSet(), findTrieNode_fn = function(word) {
  var _a19;
  let node = this.node;
  for (const char of word) {
    if (!node) return void 0;
    node = (_a19 = node.c) == null ? void 0 : _a19[char];
  }
  return node;
}, _a4);
var ImplITrieRoot = class extends ImplITrieNode {
  constructor(root) {
    super(root);
    __publicField(this, "info");
    __publicField(this, "hasForbiddenWords");
    __publicField(this, "hasCompoundWords");
    __publicField(this, "hasNonStrictWords");
    __publicField(this, "root");
    this.root = root;
    const { stripCaseAndAccentsPrefix, compoundCharacter, forbiddenWordPrefix, suggestionPrefix } = root;
    this.info = {
      stripCaseAndAccentsPrefix,
      compoundCharacter,
      forbiddenWordPrefix,
      suggestionPrefix
    };
    this.hasForbiddenWords = !!root.c[forbiddenWordPrefix];
    this.hasCompoundWords = !!root.c[compoundCharacter];
    this.hasNonStrictWords = !!root.c[stripCaseAndAccentsPrefix];
  }
  get eow() {
    return false;
  }
  resolveId(id) {
    return new ImplITrieNode(id);
  }
  get forbidPrefix() {
    return this.root.forbiddenWordPrefix;
  }
  get compoundFix() {
    return this.root.compoundCharacter;
  }
  get caseInsensitivePrefix() {
    return this.root.stripCaseAndAccentsPrefix;
  }
  get suggestionPrefix() {
    return this.root.suggestionPrefix;
  }
  static toITrieNode(node) {
    return new this(node);
  }
};
var defaultGenSuggestionOptions = {
  compoundMethod: CompoundWordsMethod.NONE,
  ignoreCase: true,
  changeLimit: 5
};
var defaultSuggestionOptions = {
  ...defaultGenSuggestionOptions,
  numSuggestions: 8,
  includeTies: true,
  get timeout() {
    return isDebuggerAttached() ? 1e6 : 1e3;
  }
};
var keyMapOfSuggestionOptionsStrict = {
  changeLimit: "changeLimit",
  compoundMethod: "compoundMethod",
  ignoreCase: "ignoreCase",
  compoundSeparator: "compoundSeparator",
  filter: "filter",
  includeTies: "includeTies",
  numSuggestions: "numSuggestions",
  timeout: "timeout",
  weightMap: "weightMap"
};
function createSuggestionOptions(...opts) {
  const options = { ...defaultSuggestionOptions };
  const keys3 = Object.keys(keyMapOfSuggestionOptionsStrict);
  for (const opt of opts) for (const key of keys3) assign(options, opt, key);
  return options;
}
function assign(dest, src, k) {
  var _a19;
  dest[k] = (_a19 = src[k]) != null ? _a19 : dest[k];
}
var PairingHeap = class {
  constructor(compare2) {
    __publicField(this, "_heap");
    __publicField(this, "_size", 0);
    __publicField(this, "compare");
    this.compare = compare2;
  }
  /** Add an item to the heap. */
  add(v) {
    this._heap = insert$1(this.compare, this._heap, v);
    ++this._size;
    return this;
  }
  /** take an item from the heap. */
  dequeue() {
    const n = this.next();
    if (n.done) return void 0;
    return n.value;
  }
  /** Add items to the heap */
  append(i) {
    for (const v of i) this.add(v);
    return this;
  }
  /** get the next value */
  next() {
    if (!this._heap) return {
      value: void 0,
      done: true
    };
    const value = this._heap.v;
    --this._size;
    this._heap = removeHead(this.compare, this._heap);
    return { value };
  }
  /** peek at the next value without removing it. */
  peek() {
    var _a19;
    return (_a19 = this._heap) == null ? void 0 : _a19.v;
  }
  [Symbol.iterator]() {
    return this;
  }
  /** alias of `size` */
  get length() {
    return this._size;
  }
  /** number of entries in the heap. */
  get size() {
    return this._size;
  }
};
function removeHead(compare2, heap) {
  if (!heap || !heap.c) return void 0;
  return mergeSiblings(compare2, heap.c);
}
function insert$1(compare2, heap, v) {
  const n = {
    v,
    s: void 0,
    c: void 0
  };
  if (!heap || compare2(v, heap.v) <= 0) {
    n.c = heap;
    return n;
  }
  n.s = heap.c;
  heap.c = n;
  return heap;
}
function merge(compare2, a, b) {
  if (compare2(a.v, b.v) <= 0) {
    a.s = void 0;
    b.s = a.c;
    a.c = b;
    return a;
  }
  b.s = void 0;
  a.s = b.c;
  b.c = a;
  return b;
}
function mergeSiblings(compare2, n) {
  if (!n.s) return n;
  const s = n.s;
  const ss = s.s;
  const m = merge(compare2, n, s);
  return ss ? merge(compare2, m, mergeSiblings(compare2, ss)) : m;
}
var DEFAULT_COMPOUNDED_WORD_SEPARATOR = "\u2219";
var opCosts = {
  baseCost: 100,
  swapCost: 75,
  duplicateLetterCost: 80,
  compound: 1,
  visuallySimilar: 1,
  firstLetterBias: 5,
  wordBreak: 99,
  wordLengthCostFactor: 0.5
};
var intl = new Intl.Collator("en", { sensitivity: "base" });
var compare$2 = intl.compare;
var visualLetterGroups = [
  forms("\u01CE\xE0\xE5\xC4\xC0A\xE3\xE2\xE1\u01DF\u1EB7\u1EAF\u1EA5\u0100\u0101\u0103\u0105a\xE4\xE6\u0250\u0251\u03B1\u0430\u1FB3") + "\u1FB3",
  forms("Bb\u1E03\u0432\u044A\u044C"),
  forms("\u010B\u010C\u010Dc\u0109\xE7C\xC7\u0107\u010A\u0421\u0441\u03C2"),
  forms("\u1E0E\u1E0B\u1E0F\u1E11\u010F\u0111\u1E0DDd"),
  forms("\u0113\xEB\xC8\xCA\xCB\u1EC1\xE9\xE8\u1EBF\u1EC7\u0115eE\u0112\u0117\u0119\u011B\xEA\u0259\u025B\u0451\u0401\u0435\u0292"),
  forms("f\u1E1FF\uFB00"),
  forms("\u0121\u0120\u011E\u01E7\u011D\u0123Gg\u0263"),
  forms("\u0127\u0126\u0125\u1E25Hh\u1E24\u021F\u043D"),
  forms("I\u012F\xEF\u0130\xCE\xCD\u012Bi\xCC\xEC\xED\xEE\u0131\u026A\u0268\u0457\u038A\u0399"),
  forms("jJ\u0135"),
  forms("\u0137Kk\u03BA\u043A\u045C"),
  forms("\u1E37\u0142\u013E\u013CLl\u013A\u1E36\u03AF\u03B9"),
  forms("M\u1E43\u1E41m"),
  forms("n\u0146\xD1N\u1E47\u0148\u0147\xF1\u0144\u014B\u045D\u0438\u0439"),
  forms("\xD2O\xF8\u022D\u014C\u014D\u0151\u1ECFo\xD6\xF2\u0231\u022F\xF3\xF4\xF5\xF6\u01A1\u0254\u03CC\u03B4\u043E"),
  forms("P\u1E57p\u0440\u0420\u03C1"),
  forms("Qq"),
  forms("\u0159R\u1E5Br\u0155\u0157\u0453\u0433\u044F"),
  forms("\u1E63\u0161\u0218\u1E62sS\u0160\u1E61\u015E\u015D\u015B\u0219\u0283\u03A3"),
  forms("t\u021B\u021A\u0165T\u1E6D\u1E6C\u1E6B"),
  forms("\xDC\xFC\xFB\u016A\u01B0\u016F\u016B\u0171\xFA\xDB\u016D\xD9\xF9u\u0173U"),
  forms("Vv\u03BD"),
  forms("\u0175wW\u1E83\u1E85\u1E81\u03C9\u0448"),
  forms("xX\u0445"),
  forms("\xFF\xFDY\u0177y\xDD\u1EF3\u0423\u045E\u0443"),
  forms("Z\u1E93\u017E\u017D\u017C\u017B\u017Az")
];
function forms(letters) {
  const n = letters.normalize("NFC").replaceAll(/\p{M}/gu, "");
  const na = n.normalize("NFD").replaceAll(/\p{M}/gu, "");
  return [...new Set(n + n.toLowerCase() + n.toUpperCase() + na + na.toLowerCase() + na.toUpperCase())].join("");
}
var visualLetterMaskMap = calcVisualLetterMasks(visualLetterGroups);
function calcVisualLetterMasks(groups) {
  const map2 = /* @__PURE__ */ Object.create(null);
  for (let i = 0; i < groups.length; ++i) {
    const m = 1 << i;
    const g = groups[i];
    for (const c of g) map2[c] = (map2[c] || 0) | m;
  }
  return map2;
}
function assert5(condition, message = "Assert Failed") {
  if (condition) return;
  throw new Error(message);
}
var matchPossibleWordSeparators = /[+]/g;
function createWeightMap(...defs) {
  const map2 = _createWeightMap();
  addDefsToWeightMap(map2, defs);
  return map2;
}
function addDefToWeightMap(map2, ...defs) {
  return addDefsToWeightMap(map2, defs);
}
function addAdjustment(map2, ...adjustments) {
  for (const adj of adjustments) map2.adjustments.set(adj.id, adj);
  return map2;
}
function addDefsToWeightMap(map2, defs) {
  function addSet(set, def) {
    addSetToTrieCost(map2.insDel, set, def.insDel, def.penalty);
    addSetToTrieTrieCost(map2.replace, set, def.replace, def.penalty);
    addSetToTrieTrieCost(map2.swap, set, def.swap, def.penalty);
  }
  for (const _def2 of defs) {
    const def = normalizeDef(_def2);
    splitMap$1(def).forEach((s) => addSet(s, def));
  }
  return map2;
}
function _createWeightMap() {
  return {
    insDel: {},
    replace: {},
    swap: {},
    adjustments: /* @__PURE__ */ new Map()
  };
}
function lowest(a, b) {
  if (a === void 0) return b;
  if (b === void 0) return a;
  return a <= b ? a : b;
}
function highest(a, b) {
  if (a === void 0) return b;
  if (b === void 0) return a;
  return a >= b ? a : b;
}
function normalize2(s) {
  const f = /* @__PURE__ */ new Set([s]);
  f.add(s.normalize("NFC"));
  f.add(s.normalize("NFD"));
  return f;
}
function* splitMapSubstringsIterable(map2) {
  let seq = "";
  let mode = 0;
  for (const char of map2) {
    if (mode && char === ")") {
      yield* normalize2(seq);
      mode = 0;
      continue;
    }
    if (mode) {
      seq += char;
      continue;
    }
    if (char === "(") {
      mode = 1;
      seq = "";
      continue;
    }
    yield* normalize2(char);
  }
}
function splitMapSubstrings(map2) {
  return [...splitMapSubstringsIterable(map2)];
}
function splitMap$1(def) {
  const { map: map2 } = def;
  return map2.split("|").map(splitMapSubstrings).filter((s) => s.length > 0);
}
function addToTrieCost(trie, str, cost, penalties) {
  if (!str) return;
  let t = trie;
  for (const c of str) {
    const n = t.n = t.n || /* @__PURE__ */ Object.create(null);
    t = n[c] = n[c] || /* @__PURE__ */ Object.create(null);
  }
  t.c = lowest(t.c, cost);
  t.p = highest(t.p, penalties);
}
function addToTrieTrieCost(trie, left, right, cost, penalties) {
  let t = trie;
  for (const c of left) {
    const n = t.n = t.n || /* @__PURE__ */ Object.create(null);
    t = n[c] = n[c] || /* @__PURE__ */ Object.create(null);
  }
  addToTrieCost(t.t = t.t || /* @__PURE__ */ Object.create(null), right, cost, penalties);
}
function addSetToTrieCost(trie, set, cost, penalties) {
  if (cost === void 0) return;
  for (const str of set) addToTrieCost(trie, str, cost, penalties);
}
function addSetToTrieTrieCost(trie, set, cost, penalties) {
  if (cost === void 0) return;
  for (const left of set) for (const right of set) {
    if (left === right) continue;
    addToTrieTrieCost(trie, left, right, cost, penalties);
  }
}
function* searchTrieNodes(trie, str, i) {
  const len = str.length;
  for (let n = trie.n; i < len && n; ) {
    const t = n[str[i]];
    if (!t) return;
    ++i;
    yield {
      i,
      t
    };
    n = t.n;
  }
}
function* findTrieCostPrefixes(trie, str, i) {
  for (const n of searchTrieNodes(trie, str, i)) {
    const { c, p } = n.t;
    if (c !== void 0) yield {
      i: n.i,
      c,
      p: p || 0
    };
  }
}
function* findTrieTrieCostPrefixes(trie, str, i) {
  for (const n of searchTrieNodes(trie, str, i)) {
    const t = n.t.t;
    if (t !== void 0) yield {
      i: n.i,
      t
    };
  }
}
function createWeightCostCalculator(weightMap) {
  return new _WeightCostCalculator(weightMap);
}
var _WeightCostCalculator = class {
  constructor(weightMap) {
    __publicField(this, "weightMap");
    this.weightMap = weightMap;
  }
  *calcInsDelCosts(pos) {
    const { a, ai, b, bi, c, p } = pos;
    for (const del of findTrieCostPrefixes(this.weightMap.insDel, a, ai)) yield {
      a,
      b,
      ai: del.i,
      bi,
      c: c + del.c,
      p: p + del.p
    };
    for (const ins of findTrieCostPrefixes(this.weightMap.insDel, b, bi)) yield {
      a,
      b,
      ai,
      bi: ins.i,
      c: c + ins.c,
      p: p + ins.p
    };
  }
  *calcReplaceCosts(pos) {
    const { a, ai, b, bi, c, p } = pos;
    for (const del of findTrieTrieCostPrefixes(this.weightMap.replace, a, ai)) for (const ins of findTrieCostPrefixes(del.t, b, bi)) yield {
      a,
      b,
      ai: del.i,
      bi: ins.i,
      c: c + ins.c,
      p: p + ins.p
    };
  }
  *calcSwapCosts(pos) {
    const { a, ai, b, bi, c, p } = pos;
    const swap = this.weightMap.swap;
    for (const left of findTrieTrieCostPrefixes(swap, a, ai)) for (const right of findTrieCostPrefixes(left.t, a, left.i)) {
      const sw = a.slice(left.i, right.i) + a.slice(ai, left.i);
      if (b.slice(bi).startsWith(sw)) {
        const len = sw.length;
        yield {
          a,
          b,
          ai: ai + len,
          bi: bi + len,
          c: c + right.c,
          p: p + right.p
        };
      }
    }
  }
  calcAdjustment(word) {
    let penalty = 0;
    for (const adj of this.weightMap.adjustments.values()) if (adj.regexp.global) for (const _m of word.matchAll(adj.regexp)) penalty += adj.penalty;
    else if (adj.regexp.test(word)) penalty += adj.penalty;
    return penalty;
  }
};
function normalizeDef(def) {
  const { map: map2, ...rest } = def;
  return {
    ...rest,
    map: normalizeMap(map2)
  };
}
function normalizeMap(map2) {
  return map2.replaceAll(matchPossibleWordSeparators, DEFAULT_COMPOUNDED_WORD_SEPARATOR);
}
function distanceAStarWeighted(wordA, wordB, map2, cost = 100) {
  const calc = createWeightCostCalculator(map2);
  const best = _distanceAStarWeightedEx(wordA, wordB, calc, cost);
  const penalty = calc.calcAdjustment(wordB);
  return best.c + best.p + penalty;
}
function _distanceAStarWeightedEx(wordA, wordB, map2, cost = 100) {
  const a = "^" + wordA + "$";
  const b = "^" + wordB + "$";
  const aN = a.length;
  const bN = b.length;
  const candidates = new CandidatePool(aN, bN);
  candidates.add({
    ai: 0,
    bi: 0,
    c: 0,
    p: 0,
    f: void 0
  });
  function opSub(n) {
    const { ai, bi, c, p } = n;
    if (ai < aN && bi < bN) {
      const cc = a[ai] === b[bi] ? c : c + cost;
      candidates.add({
        ai: ai + 1,
        bi: bi + 1,
        c: cc,
        p,
        f: n
      });
    }
  }
  function opIns(n) {
    const { ai, bi, c, p } = n;
    if (bi < bN) candidates.add({
      ai,
      bi: bi + 1,
      c: c + cost,
      p,
      f: n
    });
  }
  function opDel(n) {
    const { ai, bi, c, p } = n;
    if (ai < aN) candidates.add({
      ai: ai + 1,
      bi,
      c: c + cost,
      p,
      f: n
    });
  }
  function opSwap(n) {
    const { ai, bi, c, p } = n;
    if (a[ai] === b[bi + 1] && a[ai + 1] === b[bi]) candidates.add({
      ai: ai + 2,
      bi: bi + 2,
      c: c + cost,
      p,
      f: n
    });
  }
  function opMap2(n) {
    const { ai, bi, c, p } = n;
    const pos = {
      a,
      b,
      ai,
      bi,
      c,
      p
    };
    [
      map2.calcInsDelCosts(pos),
      map2.calcSwapCosts(pos),
      map2.calcReplaceCosts(pos)
    ].forEach((iter) => {
      for (const nn of iter) candidates.add({
        ...nn,
        f: n
      });
    });
  }
  let best;
  while (best = candidates.next()) {
    if (best.ai === aN && best.bi === bN) break;
    opSwap(best);
    opIns(best);
    opDel(best);
    opMap2(best);
    opSub(best);
  }
  assert5(best);
  return best;
}
var CandidatePool = class {
  constructor(aN, bN) {
    __publicField(this, "pool", new PairingHeap(compare$1));
    __publicField(this, "grid", []);
    __publicField(this, "aN");
    __publicField(this, "bN");
    this.aN = aN;
    this.bN = bN;
  }
  next() {
    let n;
    while (n = this.pool.dequeue()) if (!n.d) return n;
  }
  add(n) {
    const i = idx(n.ai, n.bi, this.bN);
    const g = this.grid[i];
    if (!g) {
      this.grid[i] = n;
      this.pool.add(n);
      return;
    }
    if (g.c <= n.c) return;
    g.d = true;
    this.grid[i] = n;
    this.pool.add(n);
  }
};
function idx(r, c, cols) {
  return r * cols + c;
}
function compare$1(a, b) {
  return a.c - b.c || b.ai + b.bi - a.ai - a.bi;
}
var initialRow = [...".".repeat(50)].map((_, i) => i);
Object.freeze(initialRow);
var defaultCost = 100;
function editDistanceWeighted(wordA, wordB, weights, editCost = defaultCost) {
  return distanceAStarWeighted(wordA, wordB, weights, editCost);
}
function startTimer() {
  const start = performance.now();
  return () => performance.now() - start;
}
function isDefined$1(a) {
  return a !== void 0;
}
function cleanCopy(t) {
  return clean$1({ ...t });
}
function clean$1(t) {
  for (const prop in t) if (t[prop] === void 0) delete t[prop];
  return t;
}
function unique(a) {
  return [...new Set(a)];
}
function regexQuote(text) {
  return text.replaceAll(/([[\]\-+(){},|*.\\])/g, "\\$1");
}
function replaceAllFactory(match2, replaceWithText) {
  const r = RegExp(regexQuote(match2), "g");
  return (text) => text.replace(r, replaceWithText);
}
var defaultMaxNumberSuggestions = 10;
var BASE_COST = 100;
var MAX_NUM_CHANGES = 5;
var MAX_ALLOWED_COST_SCALE = 1.03 * 0.5;
var collator = new Intl.Collator();
var regexSeparator = new RegExp(`[${regexQuote(WORD_SEPARATOR)}]`, "g");
var wordLengthCost = [
  0,
  50,
  25,
  5,
  0
];
var EXTRA_WORD_COST = 5;
var DEFAULT_COLLECTOR_TIMEOUT = 1e3;
var symStopProcessing = /* @__PURE__ */ Symbol("Collector Stop Processing");
function compSuggestionResults(a, b) {
  return (a.isPreferred && -1 || 0) - (b.isPreferred && -1 || 0) || a.cost - b.cost || a.word.length - b.word.length || collator.compare(a.word, b.word);
}
var defaultSuggestionCollectorOptions = Object.freeze({
  numSuggestions: defaultMaxNumberSuggestions,
  filter: () => true,
  changeLimit: MAX_NUM_CHANGES,
  includeTies: false,
  ignoreCase: true,
  timeout: DEFAULT_COLLECTOR_TIMEOUT,
  weightMap: void 0,
  compoundSeparator: "",
  compoundMethod: void 0
});
function suggestionCollector(wordToMatch, options) {
  const { filter: filter2 = () => true, changeLimit = MAX_NUM_CHANGES, includeTies = false, ignoreCase: ignoreCase2 = true, timeout = DEFAULT_COLLECTOR_TIMEOUT, weightMap, compoundSeparator = defaultSuggestionCollectorOptions.compoundSeparator } = options;
  const numSuggestions = Math.max(options.numSuggestions, 0) || 0;
  const numSugToHold = weightMap ? numSuggestions * 2 : numSuggestions;
  const sugs = /* @__PURE__ */ new Map();
  let maxCost = BASE_COST * Math.min(wordToMatch.length * MAX_ALLOWED_COST_SCALE, changeLimit);
  const useSeparator = compoundSeparator || (weightMap ? DEFAULT_COMPOUNDED_WORD_SEPARATOR : defaultSuggestionCollectorOptions.compoundSeparator);
  const fnCleanWord = !useSeparator || useSeparator === compoundSeparator ? (w) => w : replaceAllFactory(useSeparator, "");
  if (useSeparator && weightMap) addDefToWeightMap(weightMap, {
    map: useSeparator,
    insDel: 50
  });
  const genSuggestionOptions = clean$1({
    changeLimit,
    ignoreCase: ignoreCase2,
    compoundMethod: options.compoundMethod,
    compoundSeparator: useSeparator
  });
  let timeRemaining = timeout;
  function dropMax() {
    if (sugs.size < 2 || !numSuggestions) {
      sugs.clear();
      return;
    }
    const sorted = [...sugs.values()].sort(compSuggestionResults);
    let i = numSugToHold - 1;
    maxCost = sorted[i].cost;
    for (; i < sorted.length && sorted[i].cost <= maxCost; ++i) ;
    for (; i < sorted.length; ++i) sugs.delete(sorted[i].word);
  }
  function adjustCost(sug) {
    if (sug.isPreferred) return sug;
    const words = sug.word.split(regexSeparator);
    const extraCost = words.map((w) => wordLengthCost[w.length] || 0).reduce((a, b) => a + b, 0) + (words.length - 1) * EXTRA_WORD_COST;
    return {
      word: sug.word,
      cost: sug.cost + extraCost
    };
  }
  function collectSuggestion(suggestion) {
    const { word, cost, isPreferred } = adjustCost(suggestion);
    if (cost <= maxCost && filter2(suggestion.word, cost)) {
      const known = sugs.get(word);
      if (known) {
        known.cost = Math.min(known.cost, cost);
        known.isPreferred = known.isPreferred || isPreferred;
      } else {
        sugs.set(word, {
          word,
          cost,
          isPreferred
        });
        if (cost < maxCost && sugs.size > numSugToHold) dropMax();
      }
    }
    return maxCost;
  }
  function collect2(src, timeout2, filter3) {
    let stop = false;
    timeout2 = timeout2 != null ? timeout2 : timeRemaining;
    timeout2 = Math.min(timeout2, timeRemaining);
    if (timeout2 < 0) return;
    const timer = startTimer();
    let ir;
    while (!(ir = src.next(stop || maxCost)).done) {
      if (timer() > timeout2) stop = symStopProcessing;
      const { value } = ir;
      if (!value) continue;
      if (isSuggestionResult(value)) {
        if (!filter3 || filter3(value.word, value.cost)) collectSuggestion(value);
        continue;
      }
    }
    timeRemaining -= timer();
  }
  function cleanCompoundResult(sr) {
    const { word, cost } = sr;
    const cWord = fnCleanWord(word);
    if (cWord !== word) return {
      word: cWord,
      cost,
      compoundWord: word,
      isPreferred: void 0
    };
    return { ...sr };
  }
  function suggestions() {
    if (numSuggestions < 1 || !sugs.size) return [];
    const NF = "NFD";
    const nWordToMatch = wordToMatch.normalize(NF);
    const rawValues = [...sugs.values()];
    const sorted = (weightMap ? rawValues.map(({ word, cost, isPreferred }) => ({
      word,
      cost: isPreferred ? cost : editDistanceWeighted(nWordToMatch, word.normalize(NF), weightMap, 110),
      isPreferred
    })) : rawValues).sort(compSuggestionResults).map(cleanCompoundResult);
    let i = Math.min(sorted.length, numSuggestions) - 1;
    const limit = includeTies ? sorted.length : Math.min(sorted.length, numSuggestions);
    const iCost = sorted[i].cost;
    const maxCost2 = Math.min(iCost, weightMap ? changeLimit * BASE_COST - 1 : iCost);
    for (i = 1; i < limit && sorted[i].cost <= maxCost2; ++i) ;
    sorted.length = i;
    return sorted;
  }
  return {
    collect: collect2,
    add: function(suggestion) {
      collectSuggestion(suggestion);
      return this;
    },
    get suggestions() {
      return suggestions();
    },
    get maxCost() {
      return maxCost;
    },
    get word() {
      return wordToMatch;
    },
    get maxNumSuggestions() {
      return numSuggestions;
    },
    get changeLimit() {
      return changeLimit;
    },
    includesTies: includeTies,
    ignoreCase: ignoreCase2,
    symbolStopProcessing: symStopProcessing,
    genSuggestionOptions
  };
}
function impersonateCollector(collector, word) {
  const r = Object.create(collector);
  Object.defineProperty(r, "word", {
    value: word,
    writable: false
  });
  return r;
}
function isSuggestionResult(s) {
  const r = s;
  return !!r && typeof r === "object" && (r == null ? void 0 : r.cost) !== void 0 && r.word !== void 0;
}
function comparePath(a, b) {
  return a.c / (a.i + 1) - b.c / (b.i + 1) + (b.i - a.i);
}
function suggestAStar(trie, word, options = {}) {
  const opts = createSuggestionOptions(options);
  const collector = suggestionCollector(word, opts);
  collector.collect(getSuggestionsAStar(trie, word, opts));
  return collector.suggestions;
}
function* getSuggestionsAStar(trie, srcWord, options = {}) {
  const { compoundMethod, changeLimit, ignoreCase: ignoreCase2, weightMap } = createSuggestionOptions(options);
  const visMap = visualLetterMaskMap;
  const root = trie.getRoot();
  const rootIgnoreCase = ignoreCase2 && root.get(root.info.stripCaseAndAccentsPrefix) || void 0;
  const pathHeap = new PairingHeap(comparePath);
  const resultHeap = new PairingHeap(compareSuggestion);
  const rootPNode = {
    n: root,
    i: 0,
    c: 0,
    s: "",
    p: void 0,
    t: createCostTrie()
  };
  const BC = opCosts.baseCost;
  const VC = opCosts.visuallySimilar;
  const DL = opCosts.duplicateLetterCost;
  const wordSeparator = compoundMethod === CompoundWordsMethod.JOIN_WORDS ? JOIN_SEPARATOR : WORD_SEPARATOR;
  const sc = specialChars(trie.info);
  const comp = trie.info.compoundCharacter;
  const compRoot = root.get(comp);
  const compRootIgnoreCase = rootIgnoreCase && rootIgnoreCase.get(comp);
  const emitted = /* @__PURE__ */ Object.create(null);
  const debug2 = isDebuggerAttached();
  const srcLetters = [...srcWord];
  let limit = BC * Math.min(srcLetters.length * opCosts.wordLengthCostFactor, changeLimit);
  pathHeap.add(rootPNode);
  if (rootIgnoreCase) pathHeap.add({
    n: rootIgnoreCase,
    i: 0,
    c: 0,
    s: "",
    p: void 0,
    t: createCostTrie()
  });
  let best = pathHeap.dequeue();
  let maxSize = pathHeap.size;
  let suggestionsGenerated = 0;
  let nodesProcessed = 0;
  let nodesProcessedLimit = 1e3;
  let minGen = 1;
  while (best) {
    if (++nodesProcessed > nodesProcessedLimit) {
      nodesProcessedLimit += 1e3;
      if (suggestionsGenerated < minGen) break;
      minGen += suggestionsGenerated;
    }
    if (best.c > limit) {
      best = pathHeap.dequeue();
      maxSize = Math.max(maxSize, pathHeap.size);
      continue;
    }
    processPath(best);
    for (const sug of resultHeap) {
      ++suggestionsGenerated;
      if (sug.cost > limit) continue;
      if (sug.word in emitted && emitted[sug.word] <= sug.cost) continue;
      const action = yield sug;
      emitted[sug.word] = sug.cost;
      if (typeof action === "number") limit = Math.min(action, limit);
      if (typeof action === "symbol") return;
    }
    best = pathHeap.dequeue();
    maxSize = Math.max(maxSize, pathHeap.size);
  }
  return;
  function compareSuggestion(a, b) {
    const pa = a.isPreferred && 1 || 0;
    return (b.isPreferred && 1 || 0) - pa || a.cost - b.cost || Math.abs(a.word.charCodeAt(0) - srcWord.charCodeAt(0)) - Math.abs(b.word.charCodeAt(0) - srcWord.charCodeAt(0));
  }
  function processPath(p) {
    const len = srcLetters.length;
    if (p.n.eow && p.i === len) {
      const result = {
        word: pNodeToWord(p),
        cost: p.c
      };
      if (debug2) console.log("add possible suggestion: %o", {
        ...result,
        nodes: pNodeToDbgInfo(p).map(({ id, s, c, a }) => `${a}{${s || "\u2205"}} $${c}-> ${id} `).join("")
      });
      resultHeap.add(result);
    }
    calcEdges(p);
  }
  function calcEdges(p) {
    var _a19;
    const { n, i, t } = p;
    const s = srcLetters[i];
    const sg = visMap[s] || 0;
    const cost0 = p.c;
    const cost = cost0 + BC + (i ? 0 : opCosts.firstLetterBias);
    const costVis = cost0 + VC;
    const costLegacyCompound = cost0 + opCosts.wordBreak;
    const costCompound = cost0 + opCosts.compound;
    if (s) {
      const m = n.get(s);
      if (m) storePath(t, m, i + 1, cost0, s, p, "=", s);
      if (weightMap) processWeightMapEdges(p, weightMap);
      const ns = srcLetters[i + 1];
      if (s === ns && m) storePath(t, m, i + 2, cost0 + DL, s, p, "dd", s);
      storePath(t, n, i + 1, cost, "", p, "d", "");
      for (const [ss, node] of n.entries()) {
        if (ss === s || ss in sc) continue;
        const c = sg & (visMap[ss] || 0) ? costVis : cost;
        storePath(t, node, i + 1, c, ss, p, "r", ss);
      }
      if (n.eow && i && compoundMethod) storePath(t, root, i, costLegacyCompound, wordSeparator, p, "L", wordSeparator);
      if (ns) {
        const n2 = (_a19 = n.get(ns)) == null ? void 0 : _a19.get(s);
        if (n2) {
          const ss = ns + s;
          storePath(t, n2, i + 2, cost0 + opCosts.swapCost, ss, p, "s", ss);
        }
      }
    }
    if (compRoot && costCompound <= limit && n.get(comp)) {
      if (compRootIgnoreCase) storePath(t, compRootIgnoreCase, i, costCompound, "", p, "~+", "~+");
      storePath(t, compRoot, i, costCompound, "", p, "+", "+");
    }
    if (cost <= limit) for (const [char, node] of n.entries()) {
      if (char in sc) continue;
      storePath(t, node, i, cost, char, p, "i", char);
    }
  }
  function processWeightMapEdges(p, weightMap2) {
    delLetters(p, weightMap2, srcLetters, storePath);
    insLetters(p, weightMap2, srcLetters, storePath);
    repLetters(p, weightMap2, srcLetters, storePath);
  }
  function storePath(t, n, i, c, s, p, a, ss) {
    const tt = getCostTrie(t, ss);
    if (tt.c[i] <= c || c > limit) return void 0;
    tt.c[i] = c;
    pathHeap.add({
      n,
      i,
      c,
      s,
      p,
      t: tt,
      a
    });
  }
}
function delLetters(pNode, weightMap, letters, storePath) {
  const { t, n } = pNode;
  const trie = weightMap.insDel;
  let ii = pNode.i;
  const cost0 = pNode.c - pNode.i;
  const len = letters.length;
  for (let nn = trie.n; ii < len && nn; ) {
    const tt = nn[letters[ii]];
    if (!tt) return;
    ++ii;
    if (tt.c !== void 0) storePath(t, n, ii, cost0 + tt.c, "", pNode, "d", "");
    nn = tt.n;
  }
}
function insLetters(p, weightMap, _letters, storePath) {
  const { t, i, c, n } = p;
  const cost0 = c;
  searchTrieCostNodesMatchingTrie2(weightMap.insDel, n, (s, tc, n2) => {
    if (tc.c !== void 0) storePath(t, n2, i, cost0 + tc.c, s, p, "i", s);
  });
}
function repLetters(pNode, weightMap, letters, storePath) {
  const node = pNode.n;
  const pt = pNode.t;
  const cost0 = pNode.c;
  const len = letters.length;
  const trie = weightMap.replace;
  let i = pNode.i;
  for (let n = trie.n; i < len && n; ) {
    const t = n[letters[i]];
    if (!t) return;
    ++i;
    const tInsert = t.t;
    if (tInsert) searchTrieCostNodesMatchingTrie2(tInsert, node, (s, tt, n2) => {
      const c = tt.c;
      if (c === void 0) return;
      storePath(pt, n2, i, cost0 + c + (tt.p || 0), s, pNode, "r", s);
    });
    n = t.n;
  }
}
function createCostTrie() {
  return {
    c: [],
    t: /* @__PURE__ */ Object.create(null)
  };
}
function getCostTrie(t, s) {
  var _a19, _b2, _c, _d;
  if (s.length === 1) return (_b2 = (_a19 = t.t)[s]) != null ? _b2 : _a19[s] = createCostTrie();
  if (!s) return t;
  let tt = t;
  for (const c of s) tt = (_d = (_c = tt.t)[c]) != null ? _d : _c[c] = createCostTrie();
  return tt;
}
function pNodeToDbgInfo(p) {
  const parts = [];
  let n = p;
  while (n) {
    const id = formatNodeId(n.n.id);
    parts.push({
      id,
      s: n.s,
      c: n.c,
      a: n.a || ""
    });
    n = n.p;
  }
  parts.reverse();
  return parts;
}
function formatNodeId(id) {
  const s = id.toString(16).padStart(16, "0");
  const upper = s.slice(0, 8).replace(/^0+/, "").padStart(4, "0");
  const lower = s.slice(8).replace(/^0+/, "");
  return `${upper}${lower ? "." + lower : ""}`;
}
function pNodeToWord(p) {
  const parts = [];
  let n = p;
  while (n) {
    parts.push(n.s);
    n = n.p;
  }
  parts.reverse();
  return parts.join("");
}
function specialChars(options) {
  const charSet = /* @__PURE__ */ Object.create(null);
  for (const c of Object.values(options)) if (typeof c === "string") charSet[c] = true;
  return charSet;
}
function searchTrieCostNodesMatchingTrie2(trie, node, emit, s = "") {
  const n = trie.n;
  if (!n) return;
  for (const [key, c] of node.entries()) {
    const t = n[key];
    if (!t) continue;
    const pfx = s + key;
    emit(pfx, t, c);
    if (t.n) searchTrieCostNodesMatchingTrie2(t, c, emit, pfx);
  }
}
var defaultTrieInfoSettings = {
  forbiddenWordPrefix: "!",
  stripCaseAndAccentsPrefix: "~",
  compoundCharacter: "+",
  suggestionPrefix: ":"
};
var revMapDefaultTrieInfoSettings = {
  "!": "forbiddenWordPrefix",
  "~": "stripCaseAndAccentsPrefix",
  "+": "compoundCharacter",
  ":": "suggestionPrefix"
};
var defaultTrieCharacteristics = {
  hasForbiddenWords: "!",
  hasNonStrictWords: "~",
  hasCompoundWords: "+",
  hasPreferredSuggestions: ":"
};
var mapInfoToCharacteristics = {
  compoundCharacter: "hasCompoundWords",
  stripCaseAndAccentsPrefix: "hasNonStrictWords",
  forbiddenWordPrefix: "hasForbiddenWords",
  suggestionPrefix: "hasPreferredSuggestions"
};
var mapCharacteristicToInfo = {
  hasCompoundWords: "compoundCharacter",
  hasNonStrictWords: "stripCaseAndAccentsPrefix",
  hasForbiddenWords: "forbiddenWordPrefix",
  hasPreferredSuggestions: "suggestionPrefix"
};
var keysTrieCharacteristics = Object.keys(defaultTrieCharacteristics);
var keysTrieInfo = Object.keys(defaultTrieInfoSettings);
var revMapDefaultTrieCharacteristics = {
  "!": "hasForbiddenWords",
  "+": "hasCompoundWords",
  "~": "hasNonStrictWords",
  ":": "hasPreferredSuggestions"
};
function parseTrieInfoFlags(info) {
  const trieInfo = {};
  for (let i = 0; i < info.length; i += 2) {
    const k = info[i];
    const c = info[i + 1];
    if (!charInRevMapDefaultTrieInfoSettings(k) || !c) continue;
    const key = revMapDefaultTrieInfoSettings[k];
    trieInfo[key] = c;
  }
  return trieInfo;
}
function normalizeTrieInfo(info, defaultInfo = defaultTrieInfoSettings) {
  return {
    compoundCharacter: (info == null ? void 0 : info.compoundCharacter) || defaultInfo.compoundCharacter,
    stripCaseAndAccentsPrefix: (info == null ? void 0 : info.stripCaseAndAccentsPrefix) || defaultInfo.stripCaseAndAccentsPrefix,
    forbiddenWordPrefix: (info == null ? void 0 : info.forbiddenWordPrefix) || defaultInfo.forbiddenWordPrefix,
    suggestionPrefix: (info == null ? void 0 : info.suggestionPrefix) || defaultInfo.suggestionPrefix
  };
}
function extractTrieInfo(info) {
  return partialInfoToInfo(info);
}
function cvtTrieInfoToFlags(info) {
  let flags = "";
  for (const k of keysTrieInfo) {
    const c = info[k];
    if (!c) continue;
    assert5(c.length === 1, `Expected single character for trie info ${k}, got '${c}'`);
    const flagChar = defaultTrieInfoSettings[k];
    flags += flagChar + c;
  }
  return flags;
}
function charInRevMapDefaultTrieInfoSettings(c) {
  return c in revMapDefaultTrieInfoSettings;
}
function parseTrieCharacteristics(chars) {
  const characteristics = {};
  for (const c of chars) {
    if (!charInRevMapDefaultTrieCharacteristics(c)) continue;
    const key = revMapDefaultTrieCharacteristics[c];
    characteristics[key] = true;
  }
  return characteristics;
}
function mapTrieCharacteristics(characteristics, info) {
  let chars = "";
  for (const k of keysTrieCharacteristics) if (characteristics[k] === true) {
    const c = info[mapCharacteristicToInfo[k]] || "";
    chars += c;
  }
  return chars;
}
function cvtTrieCharacteristicsToFlags(characteristics) {
  return mapTrieCharacteristics(characteristics, defaultTrieInfoSettings);
}
function charInRevMapDefaultTrieCharacteristics(c) {
  return c in revMapDefaultTrieCharacteristics;
}
function mapTrieCharacteristicToInfoValues(char, info) {
  return keysTrieCharacteristics.map((k) => [k, char[k]]).filter((kvp) => kvp[1] === true).map(([k]) => mapCharacteristicToInfo[k]).map((k) => info[k]);
}
var _givenInfo, _givenCharacteristics, _srcInfo, _knownChars, _foundChars, _TrieInfoBuilder_instances, getCharacteristics_fn, getInfo_fn, _a5;
var TrieInfoBuilder = (_a5 = class {
  constructor(info, characteristics) {
    __privateAdd(this, _TrieInfoBuilder_instances);
    __privateAdd(this, _givenInfo);
    __privateAdd(this, _givenCharacteristics);
    __privateAdd(this, _srcInfo);
    __privateAdd(this, _knownChars);
    __privateAdd(this, _foundChars);
    __privateSet(this, _givenInfo, info);
    __privateSet(this, _srcInfo, normalizeTrieInfo(info));
    __privateSet(this, _knownChars, revTrieInfo(__privateGet(this, _srcInfo)));
    __privateSet(this, _givenCharacteristics, characteristics || {});
    __privateSet(this, _foundChars, new Set(mapTrieCharacteristicToInfoValues(__privateGet(this, _givenCharacteristics), __privateGet(this, _srcInfo))));
  }
  setInfo(info) {
    __privateSet(this, _givenInfo, info);
    __privateSet(this, _srcInfo, normalizeTrieInfo(info));
    __privateSet(this, _knownChars, revTrieInfo(__privateGet(this, _srcInfo)));
    __privateSet(this, _foundChars, new Set(mapTrieCharacteristicToInfoValues(__privateGet(this, _givenCharacteristics), __privateGet(this, _srcInfo))));
  }
  getActiveInfo() {
    return __privateGet(this, _srcInfo);
  }
  addWord(word) {
    if (word[0] in __privateGet(this, _knownChars)) __privateGet(this, _foundChars).add(word[0]);
  }
  build() {
    return {
      info: __privateMethod(this, _TrieInfoBuilder_instances, getInfo_fn).call(this),
      characteristics: __privateMethod(this, _TrieInfoBuilder_instances, getCharacteristics_fn).call(this)
    };
  }
}, _givenInfo = new WeakMap(), _givenCharacteristics = new WeakMap(), _srcInfo = new WeakMap(), _knownChars = new WeakMap(), _foundChars = new WeakMap(), _TrieInfoBuilder_instances = new WeakSet(), getCharacteristics_fn = function() {
  const characteristics = {};
  for (const char of __privateGet(this, _foundChars)) {
    const key = __privateGet(this, _knownChars)[char];
    if (!key) continue;
    const charToCharacteristic = mapInfoToCharacteristics[key];
    if (!charToCharacteristic) continue;
    characteristics[charToCharacteristic] = true;
  }
  return characteristics;
}, getInfo_fn = function() {
  const info = partialInfoToInfo(__privateGet(this, _givenInfo));
  for (const char of __privateGet(this, _foundChars)) {
    const key = __privateGet(this, _knownChars)[char];
    if (!key) continue;
    info[key] = __privateGet(this, _srcInfo)[key];
  }
  return info;
}, _a5);
function partialInfoToInfo(info) {
  if (!info) return {};
  return Object.fromEntries(keysTrieInfo.map((k) => [k, info[k]]).filter(([_k, v]) => !!v));
}
function revTrieInfo(info) {
  const rev = {};
  for (const k of keysTrieInfo) {
    const v = info[k];
    if (typeof v !== "string") continue;
    rev[v] = k;
  }
  return rev;
}
function endianness() {
  const uint32s = new Uint32Array([168496141]);
  return new Uint8Array(uint32s.buffer)[0] === 10 ? "BE" : "LE";
}
var isLittleEndian = endianness() === "LE";
var BytesSize = {
  uint8: 1,
  uint16: 2,
  uint32: 4,
  uint64: 8,
  string: 1
};
var _elements, _elementsByName, _offset, _textEncoder, _BinaryFormatBuilder_instances, addElement_fn, _a6;
var BinaryFormatBuilder = (_a6 = class {
  constructor() {
    __privateAdd(this, _BinaryFormatBuilder_instances);
    __privateAdd(this, _elements, []);
    __privateAdd(this, _elementsByName, /* @__PURE__ */ new Map());
    __privateAdd(this, _offset, 0);
    __privateAdd(this, _textEncoder, new TextEncoder());
  }
  addUint8(name, description, value) {
    const uValue = value === void 0 || typeof value === "number" ? new Uint8Array([value || 0]) : new Uint8Array(value);
    return this.addData(name, description, "value", uValue);
  }
  addUint16(name, description, value) {
    const uValue = value !== void 0 ? rawNumberToUint16Array(value) : rawNumberToUint16Array(0);
    return this.addData(name, description, "value", uValue);
  }
  addUint32(name, description, value) {
    const uValue = value !== void 0 ? rawNumberToUint32Array(value) : rawNumberToUint32Array(0);
    return this.addData(name, description, "value", uValue);
  }
  /**
  * A pointer to a uint32 array, it has two parts, the offset and the length.
  * @param name - name of pointer
  * @param description - the description of the field
  * @param overload - optional name of element to overload
  * @returns this
  */
  addUint32ArrayPtr(name, description, overload) {
    return this.addPointer(BytesSize.uint32, name, description, overload);
  }
  /**
  * A pointer to a uint16 array, it has two parts, the offset and the length.
  * @param name - name of pointer
  * @param description - the description of the field
  * @param overload - optional name of element to overload
  * @returns this
  */
  addUint16ArrayPtr(name, description, overload) {
    return this.addPointer(BytesSize.uint16, name, description, overload);
  }
  /**
  * A pointer to a uint8 array, it has two parts, the offset and the length.
  * @param name - name of pointer
  * @param description - the description of the field
  * @param overload - optional name of element to overload
  * @returns this
  */
  addUint8ArrayPtr(name, description, overload) {
    return this.addPointer(BytesSize.uint8, name, description, overload);
  }
  /**
  * A pointer to a string of UTF-8 bytes, it has two parts, the offset and the length.
  * @param name - name of pointer
  * @param description - the description of the field
  * @param overload - optional name of element to overload
  * @returns this
  */
  addStringPtr(name, description, overload) {
    return this.addPointer(BytesSize.string, name, description, overload);
  }
  /**
  * Add a pointer element.
  * @param byteSize - size of each element pointed to
  * @param name - name of the pointer
  * @param description - description of the pointer
  * @param overload - optional name of element to overload
  * @returns this
  */
  addPointer(byteSize, name, description, overload) {
    const alignment = 4;
    let offset = byteAlign(__privateGet(this, _offset), alignment);
    if (overload) {
      const existing = __privateGet(this, _elementsByName).get(overload);
      assert5(existing, `Overload target not found: ${overload}`);
      offset = byteAlign(existing.offset, alignment);
      assert5(existing.offset === offset, `Overload target offset mismatch: ${overload}`);
    }
    const element = {
      name,
      description,
      type: "ptr+size",
      alignment,
      offset,
      size: 8,
      value: void 0,
      byteSize,
      overload
    };
    __privateMethod(this, _BinaryFormatBuilder_instances, addElement_fn).call(this, element);
    return this;
  }
  addString(name, description, length) {
    const value = typeof length === "string" ? __privateGet(this, _textEncoder).encode(length) : new Uint8Array(length);
    this.addData(name, description, "value", value);
    return this;
  }
  addUint8Array(name, description, length) {
    const value = new Uint8Array(length);
    this.addData(name, description, "value", value);
    return this;
  }
  addData(name, description, formatType, data) {
    const byteSize = data.byteLength / data.length;
    assert5(isByteAlignment(byteSize), `Invalid byte size: ${byteSize} for field: ${name}`);
    const alignment = byteSize;
    const offset = byteAlign(__privateGet(this, _offset), byteSize);
    const value = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
    const size = value.byteLength;
    __privateMethod(this, _BinaryFormatBuilder_instances, addElement_fn).call(this, {
      name,
      description,
      type: formatType,
      alignment,
      offset,
      size,
      value,
      byteSize
    });
    return this;
  }
  build() {
    return new BinaryFormat([...__privateGet(this, _elements)]);
  }
}, _elements = new WeakMap(), _elementsByName = new WeakMap(), _offset = new WeakMap(), _textEncoder = new WeakMap(), _BinaryFormatBuilder_instances = new WeakSet(), addElement_fn = function(element) {
  assert5(!__privateGet(this, _elementsByName).has(element.name), `Duplicate element name: ${element.name}`);
  const expectedOffset = byteAlign(element.offset, element.alignment);
  assert5(element.offset === expectedOffset, `Element alignment mismatch for ${element.name} with alignment ${element.alignment}. Expected: ${expectedOffset}, Found: ${element.offset}`);
  __privateGet(this, _elementsByName).set(element.name, element);
  __privateGet(this, _elements).push(element);
  if (!element.overload) __privateSet(this, _offset, element.offset + element.size);
}, _a6);
var _fieldsByName, _offset2, _a7;
var BinaryFormat = (_a7 = class {
  constructor(elements) {
    __publicField(this, "elements");
    __privateAdd(this, _fieldsByName, /* @__PURE__ */ new Map());
    __privateAdd(this, _offset2);
    this.elements = elements;
    __privateSet(this, _fieldsByName, new Map(elements.map((el) => [el.name, el])));
    __privateSet(this, _offset2, Math.max(...elements.map((el) => el.offset + el.size), 0));
  }
  get size() {
    return __privateGet(this, _offset2);
  }
  getField(name) {
    return __privateGet(this, _fieldsByName).get(name);
  }
  toJSON() {
    return this.elements.map(formatElementToJSON);
  }
  toString() {
    const nameWidth = Math.max(4, ...this.elements.map((el) => el.name.length), 4);
    const offsetWidth = 8;
    const sizeWidth = 6;
    const typeWidth = Math.max(4, ...this.elements.map((el) => el.type.length), 4);
    const lines = [];
    addHeaderLines();
    this.elements.forEach(addElement);
    return lines.join("\n");
    function addHeaderLines() {
      const line = formatLine([
        "name",
        "offset",
        "size",
        "type",
        "mask",
        "description",
        "value"
      ]);
      lines.push("Binary Format:");
      lines.push(line);
      lines.push("-".repeat(line.length));
    }
    function addElement(e) {
      lines.push(formatLine([
        e.name,
        e.offset.toString(),
        e.size.toString(),
        e.type,
        e.byteSize.toString(2).padStart(4, "0"),
        e.description,
        e.value ? `${e.value}` : ""
      ]));
    }
    function formatLine([name, offset, size, type, mask, description, value]) {
      name = name.padEnd(nameWidth, " ");
      offset = offset.padStart(offsetWidth, " ");
      size = size.padStart(sizeWidth, " ");
      type = type.padEnd(typeWidth, " ");
      value = value ? `(${value})` : "";
      return `${name} ${offset} ${size} ${type} ${mask} ${description} ${value}`.trim();
    }
  }
}, _fieldsByName = new WeakMap(), _offset2 = new WeakMap(), _a7);
var _dataElementMap, _offset3, _endian, _useLE, _encoder, _dataByOffset, _BinaryDataBuilder_instances, populateDataElementMap_fn, setPtrData_fn, setPtr_fn, _a8;
var BinaryDataBuilder = (_a8 = class {
  constructor(format3, endian = endianness()) {
    __privateAdd(this, _BinaryDataBuilder_instances);
    __privateAdd(this, _dataElementMap, /* @__PURE__ */ new Map());
    __privateAdd(this, _offset3, 0);
    __privateAdd(this, _endian);
    __privateAdd(this, _useLE);
    __privateAdd(this, _encoder, new TextEncoder());
    __privateAdd(this, _dataByOffset, /* @__PURE__ */ new Map());
    __publicField(this, "format");
    this.format = format3;
    __privateSet(this, _offset3, format3.size);
    __privateSet(this, _endian, endian);
    __privateSet(this, _useLE, endian === "LE");
    __privateSet(this, _dataElementMap, /* @__PURE__ */ new Map());
    __privateMethod(this, _BinaryDataBuilder_instances, populateDataElementMap_fn).call(this);
  }
  setString(name, value) {
    const element = this.getDataElement(name);
    assert5(element, `Field not found: ${name}`);
    const formatElement = element.ref;
    assert5(formatElement, `Field Format not found: ${name}`);
    assert5(formatElement.byteSize === BytesSize.string, `Field is not a string: ${name}`);
    assert5(__privateGet(this, _encoder).encodeInto(value, element.data).read === value.length, `String too long for field ${name}: ${value}`);
    return this;
  }
  setUint32(name, value) {
    const element = this.getDataElement(name);
    assert5(element, `Field not found: ${name}`);
    const formatElement = element.ref;
    assert5(formatElement, `Field Format not found: ${name}`);
    assert5(formatElement.byteSize === BytesSize.uint32, `Field is not a uint32: ${name}`);
    const view = new DataView(element.data.buffer, element.data.byteOffset, element.data.byteLength);
    const useLittle = __privateGet(this, _endian) === "LE";
    view.setUint32(0, value, useLittle);
    return this;
  }
  setUint16(name, value) {
    const element = this.getDataElement(name);
    assert5(element, `Field not found: ${name}`);
    const formatElement = element.ref;
    assert5(formatElement, `Field Format not found: ${name}`);
    assert5(formatElement.byteSize === BytesSize.uint16, `Field is not a uint16: ${name}`);
    const view = new DataView(element.data.buffer, element.data.byteOffset, element.data.byteLength);
    const useLittle = __privateGet(this, _endian) === "LE";
    view.setUint16(0, value, useLittle);
    return this;
  }
  setUint8(name, value) {
    const element = this.getDataElement(name);
    assert5(element, `Field not found: ${name}`);
    const formatElement = element.ref;
    assert5(formatElement, `Field Format not found: ${name}`);
    assert5(formatElement.byteSize === BytesSize.uint8, `Field is not a uint8: ${name}`);
    element.data[0] = value;
    return this;
  }
  /**
  * Adjust the offset so it lands on the alignment boundary.
  * 1 = byte align
  * 2 = 16bit align
  * 4 = 32bit align
  * 8 = 64bit align
  * @param alignment - the byte alignment
  */
  alignTo(alignment) {
    const aMask = alignment - 1;
    __privateSet(this, _offset3, __privateGet(this, _offset3) + aMask & ~aMask);
  }
  /**
  * Append a data element to the binary data.
  * @param data - the data to add
  * @returns the DataElement added
  */
  addDataElement(data, alignment) {
    this.alignTo(alignment);
    const offset = __privateGet(this, _offset3);
    const name = `data_${offset}`;
    const size = data.byteLength;
    const de = {
      name,
      offset,
      size,
      data
    };
    __privateGet(this, _dataElementMap).set(de.name, de);
    __privateSet(this, _offset3, offset + size);
    return de;
  }
  /**
  * Append the data and set the pointer to it.
  * The Uint32Array  will be converted to the proper endianness if necessary.
  * @param name - name of the pointer field
  * @param data - the data to add
  * @param alignment - the alignment for the data, default 4
  * @returns this
  */
  setPtrUint32Array(name, data, alignment = 4) {
    return __privateMethod(this, _BinaryDataBuilder_instances, setPtrData_fn).call(this, name, convertUint32ArrayToUint8Array(data, __privateGet(this, _useLE)), alignment);
  }
  /**
  * Append the data and set the pointer to it.
  * The Uint16Array  will be converted to the proper endianness if necessary.
  * @param name - name of the pointer field
  * @param data - the data to add
  * @param alignment - the alignment for the data, default 2
  * @returns this
  */
  setPtrUint16Array(name, data, alignment = 2) {
    return __privateMethod(this, _BinaryDataBuilder_instances, setPtrData_fn).call(this, name, convertUint16ArrayToUint8Array(data, __privateGet(this, _useLE)), alignment);
  }
  /**
  * Append the data and set the pointer to it.
  * @param name - name of the pointer field
  * @param data - the data to add
  * @param alignment - the alignment for the data, default 1
  * @returns this
  */
  setPtrUint8Array(name, data, alignment = 1) {
    return __privateMethod(this, _BinaryDataBuilder_instances, setPtrData_fn).call(this, name, data, alignment);
  }
  /**
  * Append the string and set the pointer to it. It will be encoded as UTF-8.
  * Note: the alignment is 1. Use alignTo() if you need a different alignment.
  * @param name - name of the pointer field
  * @param str - the data to add
  * @returns this
  */
  setPtrString(name, str) {
    return __privateMethod(this, _BinaryDataBuilder_instances, setPtrData_fn).call(this, name, __privateGet(this, _encoder).encode(str), 1);
  }
  get offset() {
    return __privateGet(this, _offset3);
  }
  get endian() {
    return __privateGet(this, _endian);
  }
  getDataElement(name) {
    return __privateGet(this, _dataElementMap).get(name);
  }
  build() {
    const buffer = new Uint8Array(__privateGet(this, _offset3));
    for (const element of __privateGet(this, _dataElementMap).values()) buffer.set(element.data, element.offset);
    return buffer;
  }
}, _dataElementMap = new WeakMap(), _offset3 = new WeakMap(), _endian = new WeakMap(), _useLE = new WeakMap(), _encoder = new WeakMap(), _dataByOffset = new WeakMap(), _BinaryDataBuilder_instances = new WeakSet(), populateDataElementMap_fn = function() {
  for (const ref of this.format.elements) {
    const { name, offset, size } = ref;
    let data = __privateGet(this, _dataByOffset).get(offset);
    if (!data || data.byteLength < size) {
      data = new Uint8Array(size);
      __privateGet(this, _dataByOffset).set(offset, data);
    }
    if (ref.value) data.set(ref.value);
    const de = {
      name,
      offset,
      size,
      data,
      ref
    };
    __privateGet(this, _dataElementMap).set(de.name, de);
    __privateSet(this, _offset3, Math.max(__privateGet(this, _offset3), offset + size));
  }
}, setPtrData_fn = function(name, dataView, alignment) {
  const element = this.getDataElement(name);
  assert5(element, `Field not found: ${name}`);
  const formatElement = element.ref;
  assert5(formatElement, `Field Format not found: ${name}`);
  assert5(formatElement.type === "ptr+size", `Field is not a pointer: ${name}`);
  assert5(formatElement.byteSize === alignment, `Pointer byte size mismatch: ${name}`);
  const data = new Uint8Array(dataView.buffer, dataView.byteOffset, dataView.byteLength);
  const de = this.addDataElement(data, alignment);
  __privateMethod(this, _BinaryDataBuilder_instances, setPtr_fn).call(this, element, de.offset, de.size);
  return this;
}, setPtr_fn = function(element, dataOffset, dataLength) {
  assert5(element.data.byteLength >= 8, `Pointer data too small: ${element.name}`);
  const view = new DataView(element.data.buffer, element.data.byteOffset, element.data.byteLength);
  view.setUint32(0, dataOffset, __privateGet(this, _useLE));
  view.setUint32(4, dataLength, __privateGet(this, _useLE));
}, _a8);
function convertUint32ArrayEndiannessInPlace(data) {
  const view = new DataView(data.buffer, data.byteOffset, data.byteLength);
  const byteLength = data.length * 4;
  for (let i = 0; i < byteLength; i += 4) {
    const v = view.getUint32(i, true);
    view.setUint32(i, v, false);
  }
  return data;
}
function convertUint16ArrayEndiannessInPlace(data) {
  const view = new DataView(data.buffer, data.byteOffset, data.byteLength);
  const byteLength = data.length * 2;
  for (let i = 0; i < byteLength; i += 2) {
    const v = view.getUint16(i, true);
    view.setUint16(i, v, false);
  }
  return data;
}
function convertUint32ArrayToUint8Array(data, useLittle, isLE = isLittleEndian) {
  if (isLE === useLittle) return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
  const target = new Uint32Array(data.length);
  target.set(data);
  convertUint32ArrayEndiannessInPlace(target);
  return new Uint8Array(target.buffer, target.byteOffset, target.byteLength);
}
function convertUint16ArrayToUint8Array(data, useLittle, isLE = isLittleEndian) {
  if (isLE === useLittle) return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
  const target = new Uint16Array(data.length);
  target.set(data);
  convertUint16ArrayEndiannessInPlace(target);
  return new Uint8Array(target.buffer, target.byteOffset, target.byteLength);
}
function rawNumberToUint32Array(value) {
  return new Uint32Array([value]);
}
function rawNumberToUint16Array(value) {
  return new Uint16Array([value]);
}
var _decoder, _useLE2, _BinaryDataReader_instances, getPtrData_fn, _a9;
var BinaryDataReader = (_a9 = class {
  /**
  * Binary Data Reader
  * @param data - the raw binary data
  * @param format - the expected format
  * @param endian - the endian of the data (can be changed later)
  */
  constructor(data, format3, endian = endianness()) {
    __privateAdd(this, _BinaryDataReader_instances);
    __publicField(this, "data");
    __publicField(this, "format");
    __privateAdd(this, _decoder, new TextDecoder());
    __privateAdd(this, _useLE2);
    this.data = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
    this.format = format3;
    __privateSet(this, _useLE2, endian === "LE");
  }
  /**
  * Get a string from the data.
  * It will decode the string as UTF-8 from the following field types: 'string', 'ptrString', 'ptrUint8Array'.
  * @param name - name of the string field
  * @returns string value
  */
  getString(name) {
    const element = this.getDataElement(name);
    const formatElement = element.ref;
    assert5(formatElement.byteSize === BytesSize.string, `Field is not a string: ${name}`);
    if (formatElement.type === "value") return __privateGet(this, _decoder).decode(element.data);
    assert5(formatElement.type === "ptr+size", `Field is not a string: ${name}`);
    const strData = __privateMethod(this, _BinaryDataReader_instances, getPtrData_fn).call(this, element);
    return __privateGet(this, _decoder).decode(strData);
  }
  /**
  * Get a Uint32 from the data.
  * @param name - name of the Uint32 field
  * @returns number value
  */
  getUint32(name) {
    const element = this.getDataElement(name);
    const formatElement = element.ref;
    assert5(formatElement.type === "value" && formatElement.byteSize === BytesSize.uint32, `Field is not a uint32: ${name}`);
    return new DataView(element.data.buffer, element.data.byteOffset, element.data.byteLength).getUint32(0, __privateGet(this, _useLE2));
  }
  /**
  * Get a Uint16 from the data.
  * @param name - name of the Uint16 field
  * @returns number value
  */
  getUint16(name) {
    const element = this.getDataElement(name);
    const formatElement = element.ref;
    assert5(formatElement.type === "value" && formatElement.byteSize === BytesSize.uint16, `Field is not a uint16: ${name}`);
    return new DataView(element.data.buffer, element.data.byteOffset, element.data.byteLength).getUint16(0, __privateGet(this, _useLE2));
  }
  /**
  * Read a field as Uint16 starting at the given byte offset.
  * @param name - name of field
  * @param byteOffset - offset of in bytes from the beginning of the field
  * @returns the value read.
  */
  getAsUint16(name, byteOffset = 0) {
    const element = this.getDataElement(name);
    return new DataView(element.data.buffer, element.data.byteOffset, element.data.byteLength).getUint16(byteOffset, __privateGet(this, _useLE2));
  }
  /**
  * Get a Uint8 from the data.
  * @param name - name of the Uint8 field
  * @returns number value
  */
  getUint8(name) {
    const element = this.getDataElement(name);
    const formatElement = element.ref;
    assert5(formatElement.type === "value" && formatElement.byteSize === BytesSize.uint8, `Field is not a uint8: ${name}`);
    return element.data[0];
  }
  /**
  * Gets Uint32Array data from a pointer field.
  * Note: The returned Uint32Array may be a view of the underlying data.
  * If the endianness does not match, a copy will be made.
  * @param name - name of the field
  * @returns Uint32Array value
  */
  getPtrUint32Array(name) {
    const element = this.getDataElement(name);
    const ref = element.ref;
    assert5(ref.type === "ptr+size" && ref.byteSize === BytesSize.uint32, `Field is not a ptrUint32Array: ${name}`);
    const arrData = __privateMethod(this, _BinaryDataReader_instances, getPtrData_fn).call(this, element);
    const rawData32 = new Uint32Array(arrData.buffer, arrData.byteOffset, arrData.byteLength / ref.byteSize);
    if (isLittleEndian === __privateGet(this, _useLE2)) return rawData32;
    return convertUint32ArrayEndiannessInPlace(new Uint32Array(rawData32));
  }
  /**
  * Gets Uint16Array data from a pointer field.
  * Note: The returned Uint16Array may be a view of the underlying data.
  * If the endianness does not match, a copy will be made.
  * @param name - name of the field
  * @returns Uint16Array value
  */
  getPtrUint16Array(name) {
    const element = this.getDataElement(name);
    const ref = element.ref;
    assert5(ref.type === "ptr+size" && ref.byteSize === BytesSize.uint16, `Field is not a ptrUint16Array: ${name}`);
    const arrData = __privateMethod(this, _BinaryDataReader_instances, getPtrData_fn).call(this, element);
    const rawData16 = new Uint16Array(arrData.buffer, arrData.byteOffset, arrData.byteLength / ref.byteSize);
    if (isLittleEndian === __privateGet(this, _useLE2)) return rawData16;
    return convertUint16ArrayEndiannessInPlace(new Uint16Array(rawData16));
  }
  /**
  * Gets Uint8Array data from a pointer field.
  * Note: The returned Uint8Array is a view of the underlying data.
  * @param name - name of the field
  * @returns Uint8Array value
  */
  getPtrUint8Array(name) {
    const element = this.getDataElement(name);
    assert5(element.ref.type === "ptr+size", `Field is not a ptr+size: ${name}`);
    return __privateMethod(this, _BinaryDataReader_instances, getPtrData_fn).call(this, element);
  }
  /**
  * Gets string data from a pointer field.
  * @param name - name of the field
  * @returns string value
  */
  getPtrString(name) {
    const element = this.getDataElement(name);
    assert5(element.ref.type === "ptr+size", `Field is not a ptr+size: ${name}`);
    const strData = __privateMethod(this, _BinaryDataReader_instances, getPtrData_fn).call(this, element);
    return __privateGet(this, _decoder).decode(strData);
  }
  /**
  * Get the Element information by name
  * @param name - name of the field
  * @returns DataElementWithRef
  */
  getDataElement(name) {
    const element = this.format.getField(name);
    assert5(element, `Field not found: ${name}`);
    const data = this.data.subarray(element.offset, element.offset + element.size);
    return {
      name: element.name,
      offset: element.offset,
      size: element.size,
      data,
      ref: element
    };
  }
  set endian(endian) {
    __privateSet(this, _useLE2, endian === "LE");
  }
  get endian() {
    return __privateGet(this, _useLE2) ? "LE" : "BE";
  }
  reverseEndian() {
    __privateSet(this, _useLE2, !__privateGet(this, _useLE2));
  }
  /**
  * Get the raw bytes for a field.
  * @param name - name of the field
  * @returns the bytes or undefined
  */
  getUint8Array(name) {
    const element = this.getDataElement(name);
    if (!element) return void 0;
    return element.data;
  }
  /**
  * Get the FormatElement for a field.
  * @param name - name of the field
  * @returns the element or undefined
  */
  getField(name) {
    return this.format.getField(name);
  }
}, _decoder = new WeakMap(), _useLE2 = new WeakMap(), _BinaryDataReader_instances = new WeakSet(), getPtrData_fn = function(element) {
  const formatElement = element.ref;
  assert5(formatElement.type === "ptr+size", `Field is not a ptr+size: ${element.name} (${formatElement.type})`);
  const view = new DataView(element.data.buffer, element.data.byteOffset, element.data.byteLength);
  const offset = view.getUint32(0, __privateGet(this, _useLE2));
  const length = view.getUint32(4, __privateGet(this, _useLE2));
  return this.data.subarray(offset, offset + length);
}, _a9);
function formatElementToJSON(fe) {
  const { value } = fe;
  const v = value ? [...value] : void 0;
  return {
    ...fe,
    value: v
  };
}
function byteAlign(offset, alignment) {
  const aMask = alignment - 1;
  return offset + aMask & ~aMask;
}
function isByteAlignment(value) {
  return value === 1 || value === 2 || value === 4 || value === 8;
}
var GTrieNode = class {
  constructor(value, children) {
    __publicField(this, "children");
    __publicField(this, "value");
    this.value = value;
    this.children = children;
  }
};
var GTrie = class GTrie2 {
  constructor() {
    __publicField(this, "root");
    this.root = new GTrieNode();
  }
  /**
  *
  * @param keys - the path to the child node
  * @param value - the value to set / insert
  * @return the previous value if one existed
  */
  insert(keys3, value) {
    const node = this.insertNode(keys3);
    const prev = node.value;
    node.value = value;
    return prev;
  }
  /**
  * Insert nodes for the given keys into the trie.
  * Existing nodes are reused.
  * @param keys
  * @returns the final node inserted or found
  */
  insertNode(keys3) {
    let currentNode = this.root;
    for (const key of keys3) {
      let children = currentNode.children;
      if (!children) {
        children = /* @__PURE__ */ new Map();
        currentNode.children = children;
      }
      let child = children.get(key);
      if (!child) {
        child = new GTrieNode();
        children.set(key, child);
      }
      currentNode = child;
    }
    return currentNode;
  }
  findNode(keys3) {
    let currentNode = this.root;
    for (const key of keys3) {
      const children = currentNode.children;
      if (!children) return;
      const child = children.get(key);
      if (!child) return;
      currentNode = child;
    }
    return currentNode;
  }
  has(keys3) {
    var _a19;
    return ((_a19 = this.findNode(keys3)) == null ? void 0 : _a19.value) !== void 0;
  }
  hasNode(keys3) {
    return this.findNode(keys3) !== void 0;
  }
  get(keys3) {
    const node = this.findNode(keys3);
    return node ? node.value : void 0;
  }
  static fromEntries(entries) {
    const trie = new GTrie2();
    for (const [keys3, value] of entries) trie.insert(keys3, value);
    return trie;
  }
};
var symbolCSpell2 = /* @__PURE__ */ Symbol.for("cspell");
var globalThisCSpell2 = globalThis;
function _measurePerfStart2(name, enabled) {
  if (!enabled) return;
  performance.mark(name + "-start");
}
function _measurePerfEnd2(name, enabled) {
  if (!enabled) return;
  performance.mark(name + "-end");
  performance.measure(name, name + "-start", name + "-end");
}
function measurePerf2(name) {
  const enabled = isEnabledPerformanceMeasurements2();
  _measurePerfStart2(name, enabled);
  return makeDisposableFunction2(() => {
    _measurePerfEnd2(name, enabled);
  });
}
function makeDisposableFunction2(fn) {
  const disposableFn = fn;
  disposableFn[Symbol.dispose] = fn;
  disposableFn[Symbol.asyncDispose] = () => (fn(), Promise.resolve());
  return disposableFn;
}
function isEnabledPerformanceMeasurements2() {
  var _a19;
  return !!((_a19 = globalThisCSpell2[symbolCSpell2]) == null ? void 0 : _a19.enablePerformanceMeasurements);
}
var _index, _data2, _strLenBits, _strLenMask, _decoder2, _StringTable_instances, getBytesByIndexValue_fn, _a10;
var StringTable = (_a10 = class {
  /**
  *
  * @param index - the lookup index format: `offset|len` where the low bits are the length
  * @param utf8ByteData - the UTF-8 encoded byte data for all the strings
  * @param strLenBits - number of bits used to store the length of the string in the index entry
  */
  constructor(index, utf8ByteData, strLenBits) {
    __privateAdd(this, _StringTable_instances);
    __privateAdd(this, _index);
    __privateAdd(this, _data2);
    __privateAdd(this, _strLenBits);
    __privateAdd(this, _strLenMask);
    __privateAdd(this, _decoder2, new TextDecoder());
    __privateSet(this, _index, index);
    __privateSet(this, _data2, utf8ByteData);
    __privateSet(this, _strLenBits, strLenBits);
    __privateSet(this, _strLenMask, (1 << strLenBits) - 1);
  }
  get index() {
    return __privateGet(this, _index);
  }
  get charData() {
    return __privateGet(this, _data2);
  }
  get strLenBits() {
    return __privateGet(this, _strLenBits);
  }
  get length() {
    return __privateGet(this, _index).length;
  }
  getStringBytes(idx2) {
    if (idx2 < 0 || idx2 >= __privateGet(this, _index).length) return void 0;
    return __privateMethod(this, _StringTable_instances, getBytesByIndexValue_fn).call(this, __privateGet(this, _index)[idx2]);
  }
  getString(idx2) {
    const bytes = this.getStringBytes(idx2);
    if (!bytes) return void 0;
    return __privateGet(this, _decoder2).decode(bytes);
  }
  dataByteLength() {
    return __privateGet(this, _data2).byteLength;
  }
  bitInfo() {
    const strLenBits = this.strLenBits;
    const offsetBits = Math.ceil(Math.log2(this.charData.length + 1));
    return {
      strLenBits,
      offsetBits,
      minIndexBits: strLenBits + offsetBits
    };
  }
  values() {
    return [...__privateGet(this, _index)].map((v) => __privateMethod(this, _StringTable_instances, getBytesByIndexValue_fn).call(this, v));
  }
  toString() {
    return [...__privateGet(this, _index)].map((_, i) => this.getString(i) || "").join(", ");
  }
  toJSON() {
    return {
      index: [...__privateGet(this, _index)],
      data: [...__privateGet(this, _data2)],
      strLenBits: __privateGet(this, _strLenBits)
    };
  }
}, _index = new WeakMap(), _data2 = new WeakMap(), _strLenBits = new WeakMap(), _strLenMask = new WeakMap(), _decoder2 = new WeakMap(), _StringTable_instances = new WeakSet(), getBytesByIndexValue_fn = function(value) {
  const offset = value >>> __privateGet(this, _strLenBits);
  const length = value & __privateGet(this, _strLenMask);
  return __privateGet(this, _data2).subarray(offset, offset + length);
}, _a10);
var _data3, _encoder2, _lookupTrie, _locked, _maxStrLen, _StringTableBuilder_instances, build_fn, _a11;
var StringTableBuilder = (_a11 = class {
  constructor() {
    __privateAdd(this, _StringTableBuilder_instances);
    __privateAdd(this, _data3, []);
    __privateAdd(this, _encoder2, new TextEncoder());
    __privateAdd(this, _lookupTrie, new GTrie());
    __privateAdd(this, _locked, false);
    __privateAdd(this, _maxStrLen, 0);
  }
  addStringBytes(bytes) {
    assert5(!__privateGet(this, _locked), "StringTableBuilder is locked and cannot be modified.");
    const found = __privateGet(this, _lookupTrie).get(bytes);
    if (found !== void 0) return found;
    const idx2 = __privateGet(this, _data3).push(bytes) - 1;
    __privateGet(this, _lookupTrie).insert(bytes, idx2);
    __privateSet(this, _maxStrLen, Math.max(__privateGet(this, _maxStrLen), bytes.length));
    return idx2;
  }
  addString(str) {
    const bytes = __privateGet(this, _encoder2).encode(str);
    return this.addStringBytes(bytes);
  }
  getEntry(idx2) {
    return __privateGet(this, _data3)[idx2];
  }
  get length() {
    return __privateGet(this, _data3).length;
  }
  build() {
    const endPerf = measurePerf2("StringTableBuilder.build");
    const table = __privateMethod(this, _StringTableBuilder_instances, build_fn).call(this);
    endPerf();
    return table;
  }
  static fromStringTable(table) {
    const builder = new _a11();
    const values = table.values();
    const len = values.length;
    for (let i = 0; i < len; ++i) builder.addStringBytes(values[i]);
    return builder;
  }
}, _data3 = new WeakMap(), _encoder2 = new WeakMap(), _lookupTrie = new WeakMap(), _locked = new WeakMap(), _maxStrLen = new WeakMap(), _StringTableBuilder_instances = new WeakSet(), build_fn = function() {
  __privateSet(this, _locked, true);
  if (!__privateGet(this, _data3).length) return new StringTable([], new Uint8Array(0), 8);
  const sortedBySize = __privateGet(this, _data3).map((b, i) => ({
    b,
    i
  })).sort((a, b) => b.b.length - a.b.length);
  const byteValues = [];
  const strLenBits = Math.ceil(Math.log2(__privateGet(this, _maxStrLen) + 1));
  const strLenMask = (1 << strLenBits) - 1;
  const index = new Array(__privateGet(this, _data3).length);
  for (const { b, i } of sortedBySize) {
    let offset = findValues(b);
    if (offset < 0) offset = appendValues(b);
    const length = b.length;
    assert5(length <= strLenMask, `String length ${length} exceeds maximum of ${strLenMask}`);
    index[i] = offset << strLenBits | length;
  }
  return new StringTable(index, new Uint8Array(byteValues), strLenBits);
  function findValues(buf) {
    const bufLen = buf.length;
    const maxOffset = byteValues.length - bufLen;
    for (let i = 0; i <= maxOffset; i++) {
      let match2 = true;
      for (let j = 0; j < bufLen; j++) if (byteValues[i + j] !== buf[j]) {
        match2 = false;
        break;
      }
      if (match2) return i;
    }
    return -1;
  }
  function appendValues(buf) {
    const offset = byteValues.length;
    byteValues.push(...buf);
    return offset;
  }
}, _a11);
var bomCode = 21587;
function getStringTableBinaryFormat() {
  return new BinaryFormatBuilder().addUint8("indexBits", "The number of bits needed for each index entry", 32).addUint8("strLenBits", "The number of bits needed to store the max length of a string in the table.", 8).addUint16("bom", "The Byte Order Mark.", bomCode).addString("reserved", "Reserved for future use", 4).addUint32ArrayPtr("index32", "String index array of 32 bit entries").addUint16ArrayPtr("index16", "String index array of 16 bit entries", "index32").addUint8ArrayPtr("index", "String index array of 8 bit entries", "index32").addUint8ArrayPtr("data", "String byte data").build();
}
function encodeStringTableToBinary(table, endian) {
  const strLenBits = table.strLenBits;
  const minIndexBits = strLenBits + Math.ceil(Math.log2(table.charData.length + 1));
  const indexBits = minIndexBits <= 16 ? 16 : 32;
  assert5(minIndexBits <= indexBits, `Index bits ${indexBits} is too small for required bits ${minIndexBits}`);
  const builder = new BinaryDataBuilder(getStringTableBinaryFormat(), endian);
  builder.setUint8("indexBits", indexBits);
  builder.setUint8("strLenBits", strLenBits);
  builder.setUint16("bom", bomCode);
  if (indexBits === 16) builder.setPtrUint16Array("index16", toU16Array(table.index));
  else builder.setPtrUint32Array("index32", toU32Array(table.index));
  builder.setPtrUint8Array("data", table.charData);
  return builder.build();
}
function decodeStringTableFromBinary(data, endian) {
  if (!(data == null ? void 0 : data.length)) return new StringTable([], new Uint8Array(0), 8);
  const reader = new BinaryDataReader(data, getStringTableBinaryFormat(), endian);
  const indexBits = reader.getUint8("indexBits");
  const strLenBits = reader.getUint8("strLenBits");
  const bomStored = reader.getUint16("bom");
  assert5(!bomStored || bomStored === bomCode, "Endian mismatch");
  return new StringTable(indexBits === 16 ? reader.getPtrUint16Array("index16") : reader.getPtrUint32Array("index32"), reader.getPtrUint8Array("data"), strLenBits);
}
function toU16Array(data) {
  if (data instanceof Uint16Array) return data;
  return new Uint16Array(data);
}
function toU32Array(data) {
  if (data instanceof Uint32Array) return data;
  return new Uint32Array(data);
}
function expandCharacterSet(line, rangeChar = "-") {
  const charSet = /* @__PURE__ */ new Set();
  let mode = 0;
  let prev = "";
  for (const char of line) {
    if (mode) {
      expandRange(prev, char).forEach((a) => charSet.add(a));
      mode = 0;
    }
    if (char === rangeChar && prev) {
      mode = 1;
      continue;
    }
    charSet.add(char);
    prev = char;
  }
  if (mode) charSet.add(rangeChar);
  return charSet;
}
function expandRange(a, b) {
  const values = [];
  const end = b.codePointAt(0);
  const begin = a.codePointAt(0);
  if (!(begin && end)) return values;
  for (let i = begin; i <= end; ++i) values.push(String.fromCodePoint(i));
  return values;
}
function caseForms(letter, locale) {
  const forms2 = /* @__PURE__ */ new Set([letter]);
  function tryCases(s) {
    forms2.add(s.toLocaleLowerCase(locale));
    forms2.add(s.toLocaleUpperCase(locale));
  }
  tryCases(letter);
  [...forms2].forEach(tryCases);
  return [...forms2].filter((a) => !!a);
}
function accentForms(letter) {
  return /* @__PURE__ */ new Set([
    letter,
    letter.normalize("NFC"),
    letter.normalize("NFD")
  ]);
}
function stripAccents(characters) {
  return characters.normalize("NFD").replaceAll(/\p{M}/gu, "");
}
function stripNonAccents(characters) {
  return characters.normalize("NFD").replaceAll(/[^\p{M}]/gu, "");
}
function isValidUtf16Character(char) {
  const len = char.length;
  const code = char.charCodeAt(0) & 64512;
  return len === 1 && (code & 63488) !== 55296 || len === 2 && (code & 64512) === 55296 && (char.charCodeAt(1) & 64512) === 56320;
}
function assertValidUtf16Character(char) {
  if (!isValidUtf16Character(char)) {
    const len = char.length;
    const codes2 = toCharCodes(char.slice(0, 2)).map((c) => "0x" + ("0000" + c.toString(16)).slice(-4));
    let message;
    if (len === 1) message = `Invalid utf16 character, lone surrogate: ${codes2[0]}`;
    else if (len === 2) message = `Invalid utf16 character, not a valid surrogate pair: [${codes2.join(", ")}]`;
    else message = `Invalid utf16 character, must be a single character, found: ${len}`;
    throw new Error(message);
  }
}
function toCharCodes(s) {
  const values = [];
  for (let i = 0; i < s.length; ++i) values.push(s.charCodeAt(i));
  return values;
}
function encodeToUtf8_32(code) {
  if (code < 128) return code;
  if (code < 2048) return 49280 | (code & 1984) << 2 | code & 63;
  if (code < 65536) return 14712960 | (code & 61440) << 4 | (code & 4032) << 2 | code & 63;
  return 4034953344 + ((code & 1835008) << 6 | (code & 258048) << 4 | (code & 4032) << 2 | code & 63);
}
function encodeToUtf8_32Rev(code) {
  if (code < 128) return code;
  if (code < 2048) return 32960 | (code & 1984) >> 6 | (code & 63) << 8;
  if (code < 65536) return 8421600 | (code & 61440) >>> 12 | (code & 4032) << 2 | (code & 63) << 16;
  return 2155905264 + ((code & 1835008) >>> 18 | (code & 258048) >>> 4 | (code & 4032) << 10 | (code & 63) << 24);
}
var Utf8Accumulator = class Utf8Accumulator2 {
  constructor() {
    /**
    * Number of remaining continuation bytes expected for the current code point being decoded.
    */
    __publicField(this, "remaining", 0);
    /**
    * Partially decoded code point value being accumulated.
    */
    __publicField(this, "value", 0);
  }
  /**
  * Decode a single utf8 byte
  * @param byte
  * @returns a CodePoint if a full code point has been decoded, undefined if more bytes are needed, or 0xfffd on error.
  */
  decode(byte) {
    let remaining = this.remaining;
    if (byte & -256) return this.reset();
    if ((byte & 128) === 0) {
      if (remaining) return this.reset();
      return byte;
    }
    if (remaining) {
      if ((byte & 192) !== 128) return this.reset();
      let value = this.value;
      value = value << 6 | byte & 63;
      this.value = value;
      remaining -= 1;
      this.remaining = remaining;
      return remaining ? void 0 : value;
    }
    if ((byte & 224) === 192) {
      this.value = byte & 31;
      this.remaining = 1;
      return;
    }
    if ((byte & 240) === 224) {
      this.value = byte & 15;
      this.remaining = 2;
      return;
    }
    if ((byte & 248) === 240) {
      this.value = byte & 7;
      this.remaining = 3;
      return;
    }
    return this.reset();
  }
  get codePoint() {
    return this.remaining ? void 0 : this.value;
  }
  decodeBytesToString(bytes) {
    let value = "";
    const len = bytes.length;
    for (let i = 0; i < len; ++i) {
      const code = this.decode(bytes[i]);
      if (code) value += String.fromCodePoint(code);
    }
    return value;
  }
  reset() {
    this.remaining = 0;
    this.value = 0;
    return 65533;
  }
  clone(into = new Utf8Accumulator2()) {
    into.remaining = this.remaining;
    into.value = this.value;
    return into;
  }
  static isMultiByte(v) {
    return (v & 128) !== 0;
  }
  static isSingleByte(v) {
    return (v & 128) === 0;
  }
  static create() {
    return new this();
  }
};
function encodeTextToUtf8_32Rev(offset) {
  const text = offset.text;
  let code = text.charCodeAt(offset.i) & 65535;
  code = (code & 63488) === 55296 ? text.codePointAt(offset.i++) || 0 : code;
  offset.i++;
  if (code < 128) return code;
  if (code < 2048) return 32960 | (code & 1984) >> 6 | (code & 63) << 8;
  if (code < 65536) return 8421600 | (code & 61440) >>> 12 | (code & 4032) << 2 | (code & 63) << 16;
  return 2155905264 + ((code & 1835008) >>> 18 | (code & 258048) >>> 4 | (code & 4032) << 10 | (code & 63) << 24);
}
function encodeTextToUtf8Into(text, into, offset = 0) {
  const t = {
    text,
    i: 0
  };
  let i = offset;
  for (; t.i < text.length; ) {
    const code = encodeTextToUtf8_32Rev(t);
    for (let utf8_32Rev = code; utf8_32Rev !== 0; utf8_32Rev >>>= 8) into[i++] = utf8_32Rev & 255;
  }
  return i - offset;
}
function encodeTextToUtf8(text) {
  const into = new Array(text.length);
  encodeTextToUtf8Into(text, into);
  return into;
}
Object.freeze([0]);
var _charToUtf8SeqMap, _lastWord, _lastWordSeq, _multiByteChars, _a12;
var CharIndex = (_a12 = class {
  constructor(charIndex = /* @__PURE__ */ new Set()) {
    __privateAdd(this, _charToUtf8SeqMap);
    __privateAdd(this, _lastWord, "");
    __privateAdd(this, _lastWordSeq, []);
    __privateAdd(this, _multiByteChars);
    __publicField(this, "charIndex");
    this.charIndex = charIndex;
    __privateSet(this, _charToUtf8SeqMap, buildCharIndexSequenceMap(charIndex));
    __privateSet(this, _multiByteChars, [...__privateGet(this, _charToUtf8SeqMap).values()].some((c) => c.length > 1));
  }
  getCharUtf8Seq(c) {
    const found = __privateGet(this, _charToUtf8SeqMap).get(c);
    if (found) return found;
    const s = encodeTextToUtf8(c);
    __privateGet(this, _charToUtf8SeqMap).set(c, s);
    return s;
  }
  wordToUtf8Seq(word) {
    if (__privateGet(this, _lastWord) === word) return __privateGet(this, _lastWordSeq);
    const seq = encodeTextToUtf8(word);
    __privateSet(this, _lastWord, word);
    __privateSet(this, _lastWordSeq, seq);
    return seq;
  }
  indexContainsMultiByteChars() {
    return __privateGet(this, _multiByteChars);
  }
  get size() {
    return this.charIndex.size;
  }
  toJSON() {
    return { charIndex: [...this.charIndex].join("") };
  }
  static fromJSON(json) {
    return new _a12(new Set(json.charIndex));
  }
  static fromIterable(charIndex) {
    const charSet = /* @__PURE__ */ new Set();
    for (const s of charIndex) for (const c of s) charSet.add(c);
    return new _a12(charSet);
  }
}, _charToUtf8SeqMap = new WeakMap(), _lastWord = new WeakMap(), _lastWordSeq = new WeakMap(), _multiByteChars = new WeakMap(), _a12);
function buildCharIndexSequenceMap(charIndex) {
  const map2 = /* @__PURE__ */ new Map();
  for (const key of charIndex) map2.set(key, encodeTextToUtf8(key));
  return map2;
}
var _mapIdxToSeq, _a13;
var CharIndexBuilder = (_a13 = class {
  constructor() {
    __publicField(this, "charIndex", /* @__PURE__ */ new Set());
    __publicField(this, "charIndexMap", /* @__PURE__ */ new Map());
    __publicField(this, "charIndexSeqMap", /* @__PURE__ */ new Map());
    __privateAdd(this, _mapIdxToSeq, /* @__PURE__ */ new Map());
    this.getUtf8Value("");
  }
  getUtf8Value(c) {
    const found = this.charIndexMap.get(c);
    if (found !== void 0) return found;
    const nc = c.normalize("NFC");
    this.charIndex.add(nc);
    const utf8 = encodeToUtf8_32(nc.codePointAt(0) || 0);
    this.charIndexMap.set(c, utf8);
    this.charIndexMap.set(nc, utf8);
    this.charIndexMap.set(c.normalize("NFD"), utf8);
    return utf8;
  }
  utf8ValueToUtf8Seq(idx2) {
    const found = __privateGet(this, _mapIdxToSeq).get(idx2);
    if (found !== void 0) return found;
    const seq = splitUtf8(idx2);
    __privateGet(this, _mapIdxToSeq).set(idx2, seq);
    return seq;
  }
  charToUtf8Seq(c) {
    const idx2 = this.getUtf8Value(c);
    return this.utf8ValueToUtf8Seq(idx2);
  }
  wordToUtf8Seq(word) {
    const seq = new Array(word.length);
    let i = 0;
    for (const c of word) {
      const idx2 = this.getUtf8Value(c);
      const cSep = this.utf8ValueToUtf8Seq(idx2);
      if (typeof cSep === "number") {
        seq[i++] = cSep;
        continue;
      }
      for (const cIdx of cSep) seq[i++] = cIdx;
    }
    if (seq.length !== i) seq.length = i;
    return seq;
  }
  get size() {
    return this.charIndex.size;
  }
  build() {
    return new CharIndex(this.charIndex);
  }
}, _mapIdxToSeq = new WeakMap(), _a13);
function splitUtf8(utf8) {
  utf8 = utf8 < 0 ? 4294967296 + utf8 : utf8;
  if (utf8 <= 255) return [utf8];
  if (utf8 <= 65535) return [utf8 >> 8 & 255, utf8 & 255];
  if (utf8 <= 16777215) return [
    utf8 >> 16 & 255,
    utf8 >> 8 & 255,
    utf8 & 255
  ];
  return [
    utf8 >> 24 & 255,
    utf8 >> 16 & 255,
    utf8 >> 8 & 255,
    utf8 & 255
  ].filter((v) => v);
}
var NodeHeaderNumChildrenShift = 0;
var NodeHeaderEOWMask = 256;
var NodeHeaderPrefixMask = 1073741312;
var NodeHeaderPrefixShift = 9;
var NodeHeaderNumChildrenMask = 255;
var NodeMaskCharByte = 255;
var NodeChildIndexRefShift = 8;
var MAX_AUTO_ADD_TO_STRING_TABLE = 4;
function optimizeNodes(nodes) {
  const endPerf = measurePerf2("TrieBlob.optimizeNodes");
  const nodeHashMap = /* @__PURE__ */ new Map();
  const lockedNodes = /* @__PURE__ */ new WeakMap();
  const eowNode = nodes[1];
  getHashList(eowNode).push(eowNode);
  lockNode(eowNode, 1);
  walk(0);
  const n = compactNodes(nodes);
  endPerf();
  return n;
  function getHashList(node) {
    const hash = xorNode(node);
    let list = nodeHashMap.get(hash);
    if (list) return list;
    list = [];
    nodeHashMap.set(hash, list);
    return list;
  }
  function lockNode(node, index) {
    lockedNodes.set(node, index);
    return index;
  }
  function findMatchingLockedNode(hash, node) {
    const candidates = nodeHashMap.get(hash);
    if (!candidates) return void 0;
    return findMatchingNode(node, candidates);
  }
  function registerNode(nodeIdx, node) {
    if (!nodeIdx) return nodeIdx;
    const match2 = findMatchingLockedNode(xorNode(node), node);
    if (!match2) {
      getHashList(node).push(node);
      return lockNode(node, nodeIdx);
    }
    return lockNode(node, lockedNodes.get(match2) || 0);
  }
  function walk(nodeIdx) {
    const node = nodes[nodeIdx];
    if (lockedNodes.has(node)) return nodeIdx;
    const count2 = node.length - 1;
    for (let i = 1; i <= count2; ++i) {
      const entry = node[i];
      const childIdx = entry >> 8;
      const newChildIdx = walk(childIdx);
      if (newChildIdx !== childIdx) node[i] = entry & 255 | newChildIdx << 8;
    }
    return registerNode(nodeIdx, node);
  }
}
function xorNode(a) {
  let xor = 0;
  for (let i = 0; i < a.length; ++i) xor ^= a[i];
  return xor;
}
function findMatchingNode(node, candidates) {
  for (let i = candidates.length - 1; i >= 0; --i) {
    const candidate = candidates[i];
    if (compareNodes(node, candidate)) return candidate;
  }
}
function compareNodes(a, b) {
  if (a.length !== b.length) return false;
  let diff = 0;
  for (let i = 0; i < a.length && diff === 0; ++i) diff = a[i] - b[i];
  return !diff;
}
function compactNodes(nodes) {
  const nodeMap = /* @__PURE__ */ new Map();
  const compacted = [];
  nodeMap.set(0, 0);
  nodeMap.set(1, 1);
  compacted.push(nodes[0], nodes[1]);
  walk(0);
  return compacted;
  function walk(nodeIdx) {
    const found = nodeMap.get(nodeIdx);
    if (found) return found;
    const node = nodes[nodeIdx];
    const count2 = node.length - 1;
    for (let i = 1; i <= count2; ++i) {
      const entry = node[i];
      const newChildIdx = walk(entry >> 8);
      node[i] = entry & 255 | newChildIdx << 8;
    }
    if (!nodeIdx) return nodeIdx;
    const newIndex = compacted.push(node) - 1;
    nodeMap.set(nodeIdx, newIndex);
    return newIndex;
  }
}
function calculateByteSize(nodes) {
  let count2 = 0;
  for (let i = nodes.length - 1; i >= 0; --i) count2 += nodes[i].length;
  return count2 * 4;
}
function copyNodes(nodes) {
  const size = calculateByteSize(nodes);
  const dst = Array(nodes.length);
  const buffer = new ArrayBuffer(size);
  for (let i = 0, offset = 0; i < nodes.length; ++i) {
    const node = nodes[i];
    const nodeCopy = new Uint32Array(buffer, offset, node.length);
    nodeCopy.set(node);
    dst[i] = nodeCopy;
    offset += nodeCopy.byteLength;
  }
  return dst;
}
function copyNodesAndStringTable(src) {
  return {
    nodes: copyNodes(src.nodes),
    stringTableBuilder: StringTableBuilder.fromStringTable(src.stringTable)
  };
}
function optimizeNodesWithStringTable(src) {
  const endPerf = measurePerf2("TrieBlob.optimizeNodesWithStringTable");
  const { nodes, stringTableBuilder: builder } = copyNodesAndStringTable(src);
  const multipleNodeRefs = calcHasMultipleReferences(nodes);
  const multiStringRefs = /* @__PURE__ */ new Set([0]);
  if (!builder.length) builder.addString("");
  walkNodes(nodes, 0, { after: processNode });
  const r = {
    nodes: optimizeNodes(nodes),
    stringTable: builder.build()
  };
  endPerf();
  return r;
  function processNode(nodeIdx) {
    const node = nodes[nodeIdx];
    if (node.length !== 2) return;
    const header = node[0];
    if ((header & NodeHeaderEOWMask) !== 0) return;
    if (header & NodeHeaderPrefixMask) return;
    const childEntry = node[1];
    const charByte = childEntry & NodeMaskCharByte;
    const childIdx = childEntry >>> 8;
    if (multipleNodeRefs.has(childIdx)) return;
    const childNode = nodes[childIdx];
    const childHeader = childNode[0];
    const childPrefixIdx = (childHeader & NodeHeaderPrefixMask) >>> NodeHeaderPrefixShift;
    const childBytes = builder.getEntry(childPrefixIdx) || [];
    if (!multiStringRefs.has(childPrefixIdx)) {
      multiStringRefs.add(childPrefixIdx);
      if (childBytes.length >= MAX_AUTO_ADD_TO_STRING_TABLE) return;
    }
    const prefixBytes = [charByte, ...childBytes];
    const prefixIdx = builder.addStringBytes(prefixBytes);
    const newNode = Uint32Array.from(childNode);
    newNode[0] = prefixIdx << NodeHeaderPrefixShift | childHeader & ~NodeHeaderPrefixMask;
    nodes[nodeIdx] = newNode;
  }
}
function calcHasMultipleReferences(nodes) {
  const seen = /* @__PURE__ */ new Set();
  const multiple = /* @__PURE__ */ new Set();
  walkNodes(nodes, 0, { before: (nodeIdx) => {
    if (seen.has(nodeIdx)) {
      multiple.add(nodeIdx);
      return true;
    }
    seen.add(nodeIdx);
    return false;
  } });
  return multiple;
}
function walkNodes(nodes, nodeIdx, options) {
  const after = options.after || (() => void 0);
  const before = options.before || (() => void 0);
  function walk(nodeIdx2) {
    if (before(nodeIdx2)) return;
    const node = nodes[nodeIdx2];
    const count2 = node.length - 1;
    for (let i = 1; i <= count2; ++i) walk(node[i] >> 8);
    after(nodeIdx2);
  }
  walk(nodeIdx);
}
function resolveMap(map2, key, resolve2) {
  const r = map2.get(key);
  if (r !== void 0) return r;
  const v = resolve2(key);
  map2.set(key, v);
  return v;
}
var COMPOUND_FIX = "+";
var OPTIONAL_COMPOUND_FIX = "*";
var CASE_INSENSITIVE_PREFIX = "~";
var FORBID_PREFIX = "!";
var LINE_COMMENT = "#";
var IDENTITY_PREFIX = "=";
var SUGGESTION_PREFIX = ":";
var SUGGESTIONS_DISABLED = " ";
var defaultTrieInfo = Object.freeze({
  compoundCharacter: COMPOUND_FIX,
  forbiddenWordPrefix: FORBID_PREFIX,
  stripCaseAndAccentsPrefix: CASE_INSENSITIVE_PREFIX,
  suggestionPrefix: SUGGESTION_PREFIX
});
function mergeDefaults(value, defaultValue) {
  const result = { ...defaultValue };
  if (value) {
    for (const [k, v] of Object.entries(value)) if (k in result) result[k] = v != null ? v : result[k];
  }
  return result;
}
function mergeOptionalWithDefaults(...options) {
  return options.reduce((acc, opt) => mergeDefaults(opt, acc), defaultTrieInfo);
}
function matchEntirePrefix(text, prefix) {
  while (!prefix.done) {
    const byte = prefix.cur();
    const charVal = text.cur();
    if (text.done || byte !== charVal) return false;
    prefix.next();
    text.next();
  }
  return true;
}
function toUint8Array2(data) {
  return data instanceof Uint8Array ? data : new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
}
var headerSig = "TrieBlob";
var version = "00.01.00";
var endianSig = 67305985;
function getBinaryFormat() {
  return new BinaryFormatBuilder().addString("sig", 'Signature "TrieBlob"', headerSig).addUint32("endian", "Endianness signature", endianSig).addString("version", "Version string", version).addUint32ArrayPtr("nodes", "Pointer to nodes array").addString("reserved0", "Old Pointer to TrieInfo JSON string", 8).addString("trieInfo", "Pointer to TrieInfo JSON string", 16).addString("characteristics", "Available characteristic values", 8).addUint8ArrayPtr("stringTable", "Pointer to String Table data").addString("reserved", "Reserved space", 64).build();
}
function encodeTrieBlobToBTrie(blob) {
  const builder = new BinaryDataBuilder(getBinaryFormat());
  builder.setPtrUint32Array("nodes", blob.nodes);
  builder.setString("trieInfo", cvtTrieInfoToFlags(blob.info));
  builder.setString("characteristics", cvtTrieCharacteristicsToFlags(blob.characteristics));
  if (blob.stringTable.length) {
    const stringTableData = encodeStringTableToBinary(blob.stringTable, builder.endian);
    builder.setPtrUint8Array("stringTable", stringTableData);
  }
  return builder.build();
}
function decodeTrieBlobToBTrie(blob) {
  const reader = new BinaryDataReader(blob, getBinaryFormat());
  if (reader.getString("sig") !== headerSig) throw new ErrorDecodeTrieBlob("Invalid TrieBlob Header");
  if (reader.getUint32("endian") !== endianSig) {
    reader.reverseEndian();
    assert5(reader.getUint32("endian") === endianSig, "Invalid TrieBlob Header after endian conversion");
  }
  const fileVersion = reader.getString("version");
  if (fileVersion !== version) {
    console.warn(`Warning: TrieBlob version mismatch. Expected: ${version}, Found: ${fileVersion}`);
    assert5(fileVersion.startsWith(version.slice(0, 6)), "Unsupported TrieBlob version");
  }
  const nodes = reader.getPtrUint32Array("nodes");
  const info = parseTrieInfoFlags(reader.getString("trieInfo"));
  const characteristics = parseTrieCharacteristics(reader.getString("characteristics"));
  return {
    nodes,
    stringTable: decodeStringTableFromBinary(reader.getPtrUint8Array("stringTable"), reader.endian),
    info,
    characteristics
  };
}
var ErrorDecodeTrieBlob = class extends Error {
  constructor(message) {
    super(message);
  }
};
function isBTrieData(data) {
  const buf = toUint8Array2(data);
  if (buf.length < 8) return false;
  for (let i = 0; i < 8; i++) if (buf[i] !== headerSig.codePointAt(i)) return false;
  return true;
}
function trieBlobNodeRefToITrieNodeId(ref) {
  return (BigInt(ref.nodeIdx) << /* @__PURE__ */ BigInt("32")) + BigInt(ref.pfx);
}
function iTrieNodeIdToTrieBlobNodeRefParts(id) {
  assert5(typeof id === "bigint", "iTrieNodeIdToTrieBlobNodeRefParts: id must be a bigint");
  return {
    nodeIdx: Number(id >> /* @__PURE__ */ BigInt("32")) & 2147483647,
    pfx: Number(id & /* @__PURE__ */ BigInt("4294967295"))
  };
}
var EMPTY_KEYS = Object.freeze([]);
var EMPTY_NODES = Object.freeze([]);
var EMPTY_ENTRIES = Object.freeze([]);
var _TrieBlobINode_instances, getChildNodeRef_fn, getChildNode_fn, _a14;
var TrieBlobINode = (_a14 = class {
  constructor(trie, node) {
    __privateAdd(this, _TrieBlobINode_instances);
    __publicField(this, "id");
    __publicField(this, "node");
    __publicField(this, "eow");
    __publicField(this, "_keys");
    __publicField(this, "_hasChildren");
    __publicField(this, "_size");
    __publicField(this, "_nodesEntries");
    __publicField(this, "_entries");
    __publicField(this, "_values");
    __publicField(this, "charToIdx");
    __publicField(this, "trie");
    this.trie = trie;
    this.node = node;
    this.eow = trie.isEow(node);
    this.id = trieBlobNodeRefToITrieNodeId(node);
  }
  /** get keys to children */
  keys() {
    if (this._keys) return this._keys;
    if (!this.hasChildren) return EMPTY_KEYS;
    this._keys = this.getNodesEntries().map(([key]) => key);
    return this._keys;
  }
  values() {
    if (!this.hasChildren) return EMPTY_NODES;
    if (this._values) return this._values;
    this._values = this.entries().map(([, value]) => value);
    return this._values;
  }
  valueAt(keyIdx) {
    if (this._values) return this._values[keyIdx];
    return this.entryAt(keyIdx)[1];
  }
  entries() {
    if (this._entries) return this._entries;
    if (!this.hasChildren) return EMPTY_ENTRIES;
    this._entries = this.getNodesEntries().map(([key, value]) => [key, new _a14(this.trie, value)]);
    return this._entries;
  }
  entryAt(keyIdx) {
    if (this._entries) return this._entries[keyIdx];
    return this.entries()[keyIdx];
  }
  /** get child ITrieNode */
  get(char) {
    return __privateMethod(this, _TrieBlobINode_instances, getChildNode_fn).call(this, char);
  }
  has(char) {
    return this.trie.nodeGetChild(this.node, char) !== void 0;
  }
  hasChildren() {
    var _a19;
    return (_a19 = this._hasChildren) != null ? _a19 : this._hasChildren = this.trie.hasChildren(this.node);
  }
  child(keyIdx) {
    return this.valueAt(keyIdx);
  }
  getNode(word) {
    const n = this.trie.nodeFindNode(this.node, word);
    return n === void 0 ? void 0 : new _a14(this.trie, n);
  }
  findExact(word) {
    return this.trie.nodeFindExact(this.node, word);
  }
  getNodesEntries() {
    var _a19;
    return (_a19 = this._nodesEntries) != null ? _a19 : this._nodesEntries = this.trie.getChildEntries(this.node);
  }
  get size() {
    var _a19;
    return (_a19 = this._size) != null ? _a19 : this._size = this.getNodesEntries().length;
  }
}, _TrieBlobINode_instances = new WeakSet(), getChildNodeRef_fn = function(char) {
  return this.trie.nodeGetChild(this.node, char);
}, getChildNode_fn = function(char) {
  if (this.charToIdx) {
    const keyIdx = this.charToIdx[char];
    if (keyIdx === void 0) return void 0;
    return this.child(keyIdx);
  }
  const idx2 = __privateMethod(this, _TrieBlobINode_instances, getChildNodeRef_fn).call(this, char);
  if (idx2 === void 0) return void 0;
  return new _a14(this.trie, idx2);
}, _a14);
var TrieBlobIRoot = class extends TrieBlobINode {
  constructor(trie, nodeIdx) {
    super(trie, nodeIdx);
    __publicField(this, "find");
    __publicField(this, "isForbidden");
    __publicField(this, "hasForbiddenWords");
    __publicField(this, "hasCompoundWords");
    __publicField(this, "hasNonStrictWords");
    __publicField(this, "info");
    this.info = trie.info;
    this.find = trie.find;
    this.isForbidden = trie.isForbidden;
    this.hasForbiddenWords = trie.hasForbiddenWords;
    this.hasCompoundWords = trie.hasCompoundWords;
    this.hasNonStrictWords = trie.hasNonStrictWords;
  }
  resolveId(id) {
    return new TrieBlobINode(this.trie, this.trie.fromITrieNodeId(id));
  }
  get forbidPrefix() {
    return this.info.forbiddenWordPrefix;
  }
  get compoundFix() {
    return this.info.compoundCharacter;
  }
  get caseInsensitivePrefix() {
    return this.info.stripCaseAndAccentsPrefix;
  }
  get suggestionPrefix() {
    return this.info.suggestionPrefix;
  }
};
var TypedArrayCursor = class {
  constructor(array, i = 0, done) {
    __publicField(this, "array");
    __publicField(this, "i");
    __publicField(this, "done");
    __publicField(this, "length");
    this.array = array;
    this.i = i;
    this.length = array.length;
    this.done = (done != null ? done : i >= this.length ? true : void 0) || void 0;
  }
  cur() {
    return this.done ? void 0 : this.array[this.i];
  }
  next() {
    if (this.done) return void 0;
    const i = ++this.i;
    if (i >= this.array.length) {
      this.done = true;
      return;
    }
    return this.array[i];
  }
};
function createUint8ArrayCursor(array, i = 0) {
  return new TypedArrayCursor(array, i);
}
var Utf8CursorImpl = class {
  constructor(text, i = 0) {
    __publicField(this, "text");
    __publicField(this, "i");
    __publicField(this, "code");
    __publicField(this, "done");
    this.text = text;
    this.i = i < 0 ? i = text.length : i;
    this.code = 0;
    this.done = i < 0 || i >= text.length ? true : void 0;
    this.cur();
  }
  cur() {
    if (this.done) return 0;
    this.code || (this.code = encodeTextToUtf8_32Rev(this));
    return this.code & 255;
  }
  next() {
    if (this.done) return 0;
    this.code >>>= 8;
    this.code || (this.code = encodeTextToUtf8_32Rev(this));
    this.done = !this.code && this.i >= this.text.length;
    return this.code & 255;
  }
};
function createTextToUtf8Cursor(text, offset = 0) {
  return new Utf8CursorImpl(text, offset);
}
var _forbidIdx, _compoundIdx, _nonStrictIdx, _suggestIdx, _size, _iTrieRoot, _nodes8, _stringTable, _beAdj, _rootRef, _TrieBlob_instances, hasWord_fn, findNode_fn, walkWords_fn, walk_fn, getChildrenFromRef_fn, getNodePrefix_fn, cvtToRefPfx_fn, _a15;
var TrieBlob = (_a15 = class {
  constructor(nodes, stringTable, info) {
    __privateAdd(this, _TrieBlob_instances);
    __publicField(this, "info");
    __privateAdd(this, _forbidIdx);
    __privateAdd(this, _compoundIdx);
    __privateAdd(this, _nonStrictIdx);
    __privateAdd(this, _suggestIdx);
    __privateAdd(this, _size);
    __privateAdd(this, _iTrieRoot);
    /** the nodes data in 8 bits */
    __privateAdd(this, _nodes8);
    __privateAdd(this, _stringTable);
    __privateAdd(this, _beAdj, endianness() === "BE" ? 3 : 0);
    __privateAdd(this, _rootRef);
    __publicField(this, "wordToCharacters", (word) => [...word]);
    __publicField(this, "hasForbiddenWords");
    __publicField(this, "hasCompoundWords");
    __publicField(this, "hasNonStrictWords");
    __publicField(this, "nodes");
    __publicField(this, "NodeMaskNumChildren");
    __publicField(this, "NodeChildRefShift");
    __publicField(this, "hasPreferredSuggestions");
    this.nodes = nodes;
    __privateSet(this, _stringTable, stringTable);
    trieBlobSort(nodes);
    this.info = mergeOptionalWithDefaults(info);
    __privateSet(this, _rootRef, this.toRef(0));
    __privateSet(this, _nodes8, new Uint8Array(nodes.buffer, nodes.byteOffset + __privateGet(this, _beAdj)));
    __privateSet(this, _forbidIdx, __privateMethod(this, _TrieBlob_instances, findNode_fn).call(this, __privateGet(this, _rootRef), this.info.forbiddenWordPrefix));
    __privateSet(this, _compoundIdx, __privateMethod(this, _TrieBlob_instances, findNode_fn).call(this, __privateGet(this, _rootRef), this.info.compoundCharacter));
    __privateSet(this, _nonStrictIdx, __privateMethod(this, _TrieBlob_instances, findNode_fn).call(this, __privateGet(this, _rootRef), this.info.stripCaseAndAccentsPrefix));
    __privateSet(this, _suggestIdx, __privateMethod(this, _TrieBlob_instances, findNode_fn).call(this, __privateGet(this, _rootRef), this.info.suggestionPrefix));
    this.hasForbiddenWords = !!__privateGet(this, _forbidIdx);
    this.hasCompoundWords = !!__privateGet(this, _compoundIdx);
    this.hasNonStrictWords = !!__privateGet(this, _nonStrictIdx);
    this.NodeMaskNumChildren = NodeHeaderNumChildrenMask;
    this.NodeChildRefShift = NodeChildIndexRefShift;
    this.hasPreferredSuggestions = !!__privateGet(this, _suggestIdx);
  }
  has(word) {
    return __privateMethod(this, _TrieBlob_instances, hasWord_fn).call(this, this.rootRef, word);
  }
  isForbiddenWord(word) {
    return !!__privateGet(this, _forbidIdx) && __privateMethod(this, _TrieBlob_instances, hasWord_fn).call(this, __privateGet(this, _forbidIdx), word);
  }
  /**
  * Try to find the word in the trie. The word must be normalized.
  * If `strict` is `true` the case and accents must match.
  * Compound words are supported assuming that the compound character is in the trie.
  *
  * @param word - the word to find (normalized)
  * @param strict - if `true` the case and accents must match.
  */
  find(word, strict) {
    const found = __privateMethod(this, _TrieBlob_instances, hasWord_fn).call(this, this.rootRef, word);
    if (found || !this.hasCompoundWords) {
      if (found) return {
        found: word,
        compoundUsed: false,
        caseMatched: true,
        forbidden: void 0
      };
      if (strict || !__privateGet(this, _nonStrictIdx)) return {
        found: false,
        compoundUsed: false,
        caseMatched: false,
        forbidden: void 0
      };
      return {
        found: __privateMethod(this, _TrieBlob_instances, hasWord_fn).call(this, __privateGet(this, _nonStrictIdx), word) && word,
        compoundUsed: false,
        caseMatched: false,
        forbidden: void 0
      };
    }
  }
  getRoot() {
    var _a19;
    return (_a19 = __privateGet(this, _iTrieRoot)) != null ? _a19 : __privateSet(this, _iTrieRoot, this._getRoot());
  }
  _getRoot() {
    return new TrieBlobIRoot({
      info: this.info,
      nodes: this.nodes,
      nodeFindExact: __privateMethod(this, _TrieBlob_instances, hasWord_fn).bind(this),
      nodeGetChild: __privateMethod(this, _TrieBlob_instances, findNode_fn).bind(this),
      nodeFindNode: __privateMethod(this, _TrieBlob_instances, findNode_fn).bind(this),
      isEow: this.isRefEOW.bind(this),
      getChildEntries: __privateMethod(this, _TrieBlob_instances, getChildrenFromRef_fn).bind(this),
      hasChildren: this.hasChildren.bind(this),
      isForbidden: this.isForbiddenWord.bind(this),
      findExact: this.has.bind(this),
      find: this.find.bind(this),
      nodeToITrieNodeId: trieBlobNodeRefToITrieNodeId,
      fromITrieNodeId: iTrieNodeIdToTrieBlobNodeRefParts,
      hasCompoundWords: this.hasCompoundWords,
      hasForbiddenWords: this.hasForbiddenWords,
      hasNonStrictWords: this.hasNonStrictWords,
      hasPreferredSuggestions: this.hasPreferredSuggestions
    }, this.rootRef);
  }
  getNode(prefix) {
    return findNode$1(this.getRoot(), prefix);
  }
  get stringTable() {
    return __privateGet(this, _stringTable);
  }
  /**
  * get an iterable for all the words in the dictionary.
  * @param prefix - optional prefix to filter the words returned. The words will be prefixed with this value.
  */
  *words(prefix) {
    if (!prefix) {
      yield* __privateMethod(this, _TrieBlob_instances, walkWords_fn).call(this, this.rootRef);
      return;
    }
    const nodeIdx = __privateMethod(this, _TrieBlob_instances, findNode_fn).call(this, this.rootRef, prefix);
    if (!nodeIdx) return;
    for (const suffix of __privateMethod(this, _TrieBlob_instances, walkWords_fn).call(this, nodeIdx)) yield prefix + suffix;
  }
  get size() {
    if (__privateGet(this, _size)) return __privateGet(this, _size);
    const NodeMaskNumChildren = NodeHeaderNumChildrenMask;
    const nodes = this.nodes;
    let p = 0;
    let count2 = 0;
    while (p < nodes.length) {
      ++count2;
      p += (nodes[p] & NodeMaskNumChildren) + 1;
    }
    __privateSet(this, _size, count2);
    return count2;
  }
  toJSON() {
    return {
      options: this.info,
      nodes: nodesToJson(this.nodes)
    };
  }
  encodeToBTrie() {
    return this.encodeBin();
  }
  encodeBin() {
    return encodeTrieBlobToBTrie({
      nodes: this.nodes,
      stringTable: this.stringTable,
      info: this.info,
      characteristics: this
    });
  }
  static decodeBin(blob) {
    const info = decodeTrieBlobToBTrie(blob);
    return new _a15(info.nodes, info.stringTable, info.info);
  }
  getChildrenFromRef(ref) {
    return __privateMethod(this, _TrieBlob_instances, getChildrenFromRef_fn).call(this, __privateMethod(this, _TrieBlob_instances, cvtToRefPfx_fn).call(this, ref));
  }
  hasChildren(ref) {
    const node = this.nodes[ref.nodeIdx];
    const pfxV = node & NodeHeaderPrefixMask;
    const has = (node & NodeHeaderNumChildrenMask) !== 0;
    if (!pfxV) return has;
    if (isRefPfx(ref)) return ref.prefix ? true : has;
    ref = __privateMethod(this, _TrieBlob_instances, cvtToRefPfx_fn).call(this, ref);
    return ref.prefix ? true : has;
  }
  /**
  * Checks if a location is at an end-of-word node.
  * @param ref
  * @returns
  */
  isRefEOW(ref) {
    if (ref.prefix && ref.pfx < ref.prefix.length) return false;
    return !!(this.nodes[ref.nodeIdx] & NodeHeaderEOWMask);
  }
  toRef(nodeIdx, pfx = 0) {
    return __privateMethod(this, _TrieBlob_instances, cvtToRefPfx_fn).call(this, {
      nodeIdx,
      pfx
    });
  }
  get rootRef() {
    return __privateGet(this, _rootRef);
  }
  getNodeDebugInfo(ref) {
    const node = this.nodes[ref.nodeIdx];
    const isEOW = !!(node & NodeHeaderEOWMask);
    const count2 = node & NodeHeaderNumChildrenMask;
    const children = /* @__PURE__ */ new Map();
    for (let i = 1; i <= count2; ++i) {
      const entry = this.nodes[ref.nodeIdx + i];
      const c = entry & NodeMaskCharByte;
      const idx2 = entry >>> NodeChildIndexRefShift;
      children.set(charToHex(c), numberToHex(idx2) + " " + idx2);
    }
    return {
      ...ref,
      prefix: ref.prefix ? [...ref.prefix].map(charToHex).join(", ") : "",
      isEOW,
      count: count2,
      children
    };
  }
  static copyNodes(trie) {
    return new Uint32Array(trie.nodes);
  }
}, _forbidIdx = new WeakMap(), _compoundIdx = new WeakMap(), _nonStrictIdx = new WeakMap(), _suggestIdx = new WeakMap(), _size = new WeakMap(), _iTrieRoot = new WeakMap(), _nodes8 = new WeakMap(), _stringTable = new WeakMap(), _beAdj = new WeakMap(), _rootRef = new WeakMap(), _TrieBlob_instances = new WeakSet(), /**
* Check if the word is in the trie starting at the given node index.
*/
hasWord_fn = function(nodeRef, word) {
  const nodeIdxFound = __privateMethod(this, _TrieBlob_instances, findNode_fn).call(this, nodeRef, word);
  if (!nodeIdxFound) return false;
  return this.isRefEOW(nodeIdxFound);
}, /**
* Find the node index for the given Utf8 character sequence.
* @param nodeIdx - node index to start the search
* @param seq - the byte sequence of the character to look for
* @returns
*/
findNode_fn = function(nodeRef, text) {
  if (!nodeRef) return void 0;
  const _nodes = this.nodes;
  const _nodes82 = __privateGet(this, _nodes8);
  const pfxShift = NodeHeaderPrefixShift;
  let { nodeIdx, pfx, prefix } = nodeRef;
  const t = createTextToUtf8Cursor(text);
  for (; !t.done; t.next()) {
    const nodes = _nodes;
    const nodes8 = _nodes82;
    const node = nodes[nodeIdx];
    const prefixIdx = node >>> pfxShift;
    prefix || (prefix = prefixIdx ? __privateGet(this, _stringTable).getStringBytes(prefixIdx) : void 0);
    const pfxCursor = prefix && createUint8ArrayCursor(prefix, pfx);
    if (pfxCursor && !matchEntirePrefix(t, pfxCursor)) return t.done ? {
      nodeIdx,
      pfx: pfxCursor.i,
      prefix
    } : void 0;
    prefix = void 0;
    pfx = 0;
    const charVal = t.cur() & 255;
    const count2 = node & 255;
    const idx4 = nodeIdx << 2;
    if (count2 > 15) {
      const pEnd = idx4 + (count2 << 2);
      let i = idx4 + 4;
      let j = pEnd;
      while (j - i >= 4) {
        const m = i + j >> 1 & -4;
        if (nodes8[m] < charVal) i = m + 4;
        else j = m;
      }
      if (i > pEnd || nodes8[i] !== charVal) return void 0;
      nodeIdx = nodes[i >> 2] >>> 8;
    } else {
      let i = idx4 + count2 * 4;
      for (; i > idx4; i -= 4) if (nodes8[i] === charVal) break;
      if (i <= idx4) return void 0;
      nodeIdx = nodes[i >> 2] >>> 8;
    }
  }
  return {
    nodeIdx,
    pfx,
    prefix
  };
}, walkWords_fn = function* (rootRef) {
  const NodeMaskNumChildren = NodeHeaderNumChildrenMask;
  const NodeMaskEOW = NodeHeaderEOWMask;
  const NodeMaskChildCharIndex = NodeMaskCharByte;
  const NodeChildRefShift = NodeChildIndexRefShift;
  const nodeHeaderPrefixShift = NodeHeaderPrefixShift;
  const nodes = this.nodes;
  const st = __privateGet(this, _stringTable);
  const stack = [{
    nodeIdx: rootRef.nodeIdx,
    pfx: rootRef.pfx,
    pos: 0,
    word: "",
    acc: Utf8Accumulator.create()
  }];
  let depth = 0;
  while (depth >= 0) {
    const s = stack[depth];
    if (!s.pos) applyPrefixString(s);
    const { nodeIdx, pos, word, acc } = s;
    const node = nodes[nodeIdx];
    if (!pos && node & NodeMaskEOW) yield word;
    if (pos >= (node & NodeMaskNumChildren)) {
      --depth;
      continue;
    }
    const entry = nodes[nodeIdx + ++stack[depth].pos];
    const nAcc = acc.clone();
    const codePoint = nAcc.decode(entry & NodeMaskChildCharIndex);
    const letter = codePoint && String.fromCodePoint(codePoint) || "";
    ++depth;
    stack[depth] = {
      nodeIdx: entry >>> NodeChildRefShift,
      pos: 0,
      pfx: 0,
      word: word + letter,
      acc: nAcc
    };
  }
  function applyPrefixString(s) {
    const prefixIdx = nodes[s.nodeIdx] >>> nodeHeaderPrefixShift;
    const fullPrefix = prefixIdx ? st.getStringBytes(prefixIdx) : void 0;
    if (!fullPrefix || s.pfx >= fullPrefix.length) return;
    let prefix = fullPrefix;
    if (s.pfx) prefix = prefix.subarray(s.pfx);
    s.word += s.acc.decodeBytesToString(prefix);
    s.pfx = fullPrefix.length;
  }
}, walk_fn = function* (stack, depth = 0) {
  const MaskNumChildren = NodeHeaderNumChildrenMask;
  const NodeRefShift = NodeChildIndexRefShift;
  const CharMask = NodeMaskCharByte;
  const PrefixMask = NodeHeaderPrefixMask;
  const PrefixShift = NodeHeaderPrefixShift;
  const nodes = this.nodes;
  stack[0] || (stack[0] = {
    nodeIdx: 0,
    pfx: 0,
    pos: 0,
    prefix: void 0,
    bChar: 0
  });
  while (depth >= 0) {
    let s = stack[depth];
    const { nodeIdx, pos, pfx, prefix } = s;
    if (!pos) {
      if (!(yield depth)) {
        --depth;
        continue;
      }
    }
    if (prefix) {
      if (pos) {
        --depth;
        continue;
      }
      s.pos = 1;
      ++depth;
      stack[depth] || (stack[depth] = {
        nodeIdx: 0,
        pfx: 0,
        pos: 0,
        prefix: void 0,
        bChar: 0
      });
      s = stack[depth];
      s.nodeIdx = nodeIdx;
      s.pfx = pfx + 1;
      s.pos = 0;
      s.prefix = s.pfx < prefix.length ? prefix : void 0;
      s.bChar = prefix[pfx];
      continue;
    }
    if (pos >= (nodes[nodeIdx] & MaskNumChildren)) {
      --depth;
      continue;
    }
    const entry = nodes[nodeIdx + ++s.pos];
    const eNodeIdx = entry >>> NodeRefShift;
    ++depth;
    stack[depth] || (stack[depth] = {
      nodeIdx: 0,
      pfx: 0,
      pos: 0,
      prefix: void 0,
      bChar: 0
    });
    s = stack[depth];
    s.nodeIdx = eNodeIdx;
    s.pfx = 0;
    s.pos = 0;
    const pfxV = nodes[eNodeIdx] & PrefixMask;
    s.prefix = pfxV ? __privateGet(this, _stringTable).getStringBytes(pfxV >>> PrefixShift) : void 0;
    s.bChar = entry & CharMask;
  }
}, getChildrenFromRef_fn = function(ref) {
  const accStack = [Utf8Accumulator.create()];
  const stack = [{
    ...ref,
    pos: 0,
    bChar: 0
  }];
  const results = [];
  const iterable = __privateMethod(this, _TrieBlob_instances, walk_fn).call(this, stack);
  let deeper = false;
  for (let next = iterable.next(true); !next.done; next = iterable.next(deeper)) {
    const depth = next.value;
    if (depth <= 0) {
      if (!depth) {
        deeper = true;
        continue;
      }
      break;
    }
    const s = stack[depth];
    accStack[depth] = accStack[depth - 1].clone(accStack[depth]);
    const char = accStack[depth].decode(s.bChar);
    if (char) {
      deeper = false;
      results.push([String.fromCodePoint(char), {
        nodeIdx: s.nodeIdx,
        pfx: s.pfx,
        prefix: s.prefix
      }]);
      continue;
    }
    deeper = true;
  }
  return results;
}, getNodePrefix_fn = function(nodeIdx, pfx) {
  const pfxV = this.nodes[nodeIdx] & NodeHeaderPrefixMask;
  const prefix = pfxV ? __privateGet(this, _stringTable).getStringBytes(pfxV >>> NodeHeaderPrefixShift) : void 0;
  if (!prefix) return void 0;
  if (pfx >= prefix.length) return void 0;
  return prefix;
}, cvtToRefPfx_fn = function(ref) {
  if (isRefPfx(ref)) return ref;
  const refPfx = ref;
  refPfx.prefix = __privateMethod(this, _TrieBlob_instances, getNodePrefix_fn).call(this, ref.nodeIdx, ref.pfx);
  return refPfx;
}, _a15);
function nodesToJson(nodes) {
  function nodeElement(offset2) {
    const node = nodes[offset2];
    const numChildren = node & NodeHeaderNumChildrenMask;
    const eow = !!(node & NodeHeaderEOWMask);
    const children = [];
    for (let i = 1; i <= numChildren; ++i) children.push({
      c: ("00" + (nodes[offset2 + i] & NodeMaskCharByte).toString(16)).slice(-2),
      o: nodes[offset2 + i] >>> NodeChildIndexRefShift
    });
    return {
      id: offset2,
      eow,
      n: offset2 + numChildren + 1,
      c: children
    };
  }
  const elements = [];
  let offset = 0;
  while (offset < nodes.length) {
    const e = nodeElement(offset);
    elements.push(e);
    offset = e.n;
  }
  return elements;
}
function trieBlobSort(data) {
  const MaskNumChildren = NodeHeaderNumChildrenMask;
  const MaskChildCharIndex = NodeMaskCharByte;
  const limit = data.length;
  let idx2 = 0;
  let node = data[0];
  let nc = node & MaskNumChildren;
  for (; idx2 < limit; idx2 += nc + 1, node = data[idx2], nc = node & MaskNumChildren) {
    if (!nc) continue;
    const start = idx2 + 1;
    const end = start + nc;
    let last = 0;
    let i = start;
    for (; i < end; ++i) {
      const cIdx = data[i] & MaskChildCharIndex;
      if (last >= cIdx) break;
      last = cIdx;
    }
    if (i === end) continue;
    data.slice(start, end).sort((a, b) => (a & MaskChildCharIndex) - (b & MaskChildCharIndex)).forEach((v, i2) => data[start + i2] = v);
  }
}
function numberToHex(n) {
  const digits = n.toString(16).padStart(8, "0");
  return "0x" + digits.slice(0, 4) + "_" + digits.slice(4);
}
function charToHex(c) {
  return c.toString(16).padStart(2, "0") + " " + (c >= 32 && c <= 126 ? String.fromCodePoint(c) : ".");
}
function isRefPfx(ref) {
  return "prefix" in ref;
}
function sortNodes(nodes, mask) {
  const endPerf = measurePerf2("TrieBlobBuilder.sortNodes");
  for (let i = 0; i < nodes.length; ++i) {
    const node = nodes[i];
    if (node.length <= 2 || isSorted(node, mask, 1)) continue;
    sortSubArray(node, mask, 1);
  }
  endPerf();
  return nodes;
}
function sortSubArray(node, mask, startAt) {
  const compare2 = (a, b) => !a ? -1 : !b ? 1 : (a & mask) - (b & mask);
  if (node.subarray === void 0) {
    const header = node[0];
    node[0] = Number.MIN_SAFE_INTEGER;
    node.sort(compare2);
    node[0] = header;
    return;
  }
  node.subarray(startAt).sort(compare2);
}
function isSorted(node, mask, start, end) {
  if (node.length > 2) {
    const limit = end != null ? end : node.length;
    let last = -1;
    for (let j = start; j < limit; ++j) {
      const n = node[j] & mask;
      if (n < last) return false;
      last = n;
    }
  }
  return true;
}
function toTrieBlob(nodes, stringTable, info) {
  const endPerf = measurePerf2("TrieBlob.toTrieBlob");
  const nodeMaskChildCharIndex = NodeMaskCharByte;
  const nodeChildRefShift = NodeChildIndexRefShift;
  function calcNodeToIndex(nodes2) {
    let offset2 = 0;
    const idx2 = Array(nodes2.length + 1);
    for (let i = 0; i < nodes2.length; ++i) {
      idx2[i] = offset2;
      offset2 += nodes2[i].length;
    }
    idx2[nodes2.length] = offset2;
    return idx2;
  }
  const nodeToIndex = calcNodeToIndex(nodes);
  const nodeElementCount = nodeToIndex[nodeToIndex.length - 1];
  const binNodes = new Uint32Array(nodeElementCount);
  const lenShift = NodeHeaderNumChildrenShift;
  const refShift = NodeChildIndexRefShift;
  const NodeHeaderMask = ~NodeHeaderNumChildrenMask;
  let offset = 0;
  for (let i = 0; i < nodes.length; ++i) {
    const node = nodes[i];
    binNodes[offset++] = node.length - 1 << lenShift | node[0] & NodeHeaderMask;
    for (let j = 1; j < node.length; ++j) {
      const v = node[j];
      const nodeRef = v >>> nodeChildRefShift;
      const charIndex = v & nodeMaskChildCharIndex;
      binNodes[offset++] = nodeToIndex[nodeRef] << refShift | charIndex;
    }
  }
  const t = new TrieBlob(binNodes, stringTable, info);
  endPerf();
  return t;
}
var AUTO_OPTIMIZE_NODE_COUNT = 0;
var _infoBuilder, _TrieBlobBuilder_instances, insertWord_fn, assertNotReadonly_fn, _a16;
var TrieBlobBuilder = (_a16 = class {
  constructor(options, characteristics) {
    __privateAdd(this, _TrieBlobBuilder_instances);
    __publicField(this, "charIndex", new CharIndexBuilder());
    __publicField(this, "nodes");
    __publicField(this, "_readonly", false);
    __publicField(this, "IdxEOW");
    __publicField(this, "_cursor");
    __publicField(this, "_cursorId", 0);
    __publicField(this, "wordToCharacters", (word) => [...word]);
    __privateAdd(this, _infoBuilder);
    this.nodes = [[0], Object.freeze([NodeHeaderEOWMask])];
    this.IdxEOW = 1;
    __privateSet(this, _infoBuilder, new TrieInfoBuilder(options, characteristics));
  }
  setOptions(options) {
    __privateGet(this, _infoBuilder).setInfo(options);
    return __privateGet(this, _infoBuilder).getActiveInfo();
  }
  get options() {
    return __privateGet(this, _infoBuilder).getActiveInfo();
  }
  wordToUtf8Seq(word) {
    return this.charIndex.wordToUtf8Seq(word);
  }
  letterToUtf8Seq(letter) {
    return this.charIndex.charToUtf8Seq(letter);
  }
  insert(word) {
    __privateMethod(this, _TrieBlobBuilder_instances, assertNotReadonly_fn).call(this);
    if (typeof word === "string") return __privateMethod(this, _TrieBlobBuilder_instances, insertWord_fn).call(this, word);
    return this.insertWords(word);
  }
  getCursor() {
    var _a19;
    __privateMethod(this, _TrieBlobBuilder_instances, assertNotReadonly_fn).call(this);
    (_a19 = this._cursor) != null ? _a19 : this._cursor = this.createCursor(++this._cursorId);
    return this._cursor;
  }
  createCursor(id) {
    const endPerf = measurePerf2("TrieBlobBuilder.cursor");
    const nodeChildRefShift = NodeChildIndexRefShift;
    const NodeMaskEOW = NodeHeaderEOWMask;
    const LetterMask = NodeMaskCharByte;
    const refNodes = [0, 1];
    const lookupCharCode = createCharUtf8_32RevLookup();
    let disposed = false;
    const dispose = () => {
      if (disposed) return;
      endPerf();
      disposed = true;
      if (this._cursorId === id) this._cursor = void 0;
    };
    function childPos(node, letterIdx) {
      for (let i = 1; i < node.length; ++i) if ((node[i] & LetterMask) === letterIdx) return i;
      return 0;
    }
    assert5(this.nodes.length === 2);
    const eowNodeIndex = 1;
    const eowShifted = eowNodeIndex << nodeChildRefShift;
    const nodes = this.nodes;
    const stack = [{
      nodeIdx: 0,
      pos: 0,
      pDepth: -1
    }];
    let nodeIdx = 0;
    let depth = 0;
    const assertNotDisposed = () => {
      assert5(!disposed, "Cursor has been disposed");
      assert5(id === this._cursorId, "Cursor is no longer valid");
    };
    function insertChar(char) {
      assertNotDisposed();
      if (!nodes[nodeIdx]) refNodes.push(nodeIdx);
      const pDepth = depth;
      for (let encoded = lookupCharCode(char); encoded; encoded >>>= 8) insertCharByteCode(encoded & 255, pDepth);
    }
    function insertCharByteCode(byte, pDepth) {
      if (nodes[nodeIdx] && Object.isFrozen(nodes[nodeIdx])) {
        nodeIdx = nodes.push([...nodes[nodeIdx]]) - 1;
        const { pos: pos2, nodeIdx: pNodeIdx } = stack[depth];
        const pNode = nodes[pNodeIdx];
        pNode[pos2] = pNode[pos2] & LetterMask | nodeIdx << nodeChildRefShift;
      }
      const node = nodes[nodeIdx] || [0];
      nodes[nodeIdx] = node;
      const hasIdx = childPos(node, byte);
      const childIdx = hasIdx ? node[hasIdx] >>> nodeChildRefShift : nodes.length;
      const pos = hasIdx || node.push(childIdx << nodeChildRefShift | byte) - 1;
      ++depth;
      const s = stack[depth];
      if (s) {
        s.nodeIdx = nodeIdx;
        s.pos = pos;
        s.pDepth = pDepth;
      } else stack[depth] = {
        nodeIdx,
        pos,
        pDepth
      };
      nodeIdx = childIdx;
    }
    function markEOW() {
      assertNotDisposed();
      if (nodeIdx === eowNodeIndex) return;
      const node = nodes[nodeIdx];
      if (!node) {
        const { pos, nodeIdx: pNodeIdx } = stack[depth];
        const pNode = nodes[pNodeIdx];
        pNode[pos] = pNode[pos] & LetterMask | eowShifted;
      } else {
        nodes[nodeIdx] = node;
        node[0] |= NodeMaskEOW;
      }
      nodeIdx = eowNodeIndex;
    }
    function reference(refId) {
      assertNotDisposed();
      const refNodeIdx = refNodes[refId];
      assert5(refNodeIdx !== void 0);
      assert5(nodes[nodeIdx] === void 0);
      assert5(nodes[refNodeIdx]);
      Object.freeze(nodes[refNodeIdx]);
      const s = stack[depth];
      nodeIdx = s.nodeIdx;
      const pos = s.pos;
      const node = nodes[nodeIdx];
      node[pos] = refNodeIdx << nodeChildRefShift | node[pos] & LetterMask;
    }
    function backStep(num) {
      assertNotDisposed();
      if (!num) return;
      assert5(num <= depth && num > 0);
      for (let n = num; n > 0; --n) depth = stack[depth].pDepth;
      nodeIdx = stack[depth + 1].nodeIdx;
    }
    return {
      insertChar,
      markEOW,
      reference,
      backStep,
      dispose,
      [Symbol.dispose]: dispose
    };
  }
  /**
  * Insert multiple words. Performance is (~10%) better if the words are sorted.
  * @param words - words to insert
  * @returns this
  */
  insertWords(words) {
    for (const word of words) __privateMethod(this, _TrieBlobBuilder_instances, insertWord_fn).call(this, word);
    return this;
  }
  has(word) {
    const NodeMaskChildCharIndex = NodeMaskCharByte;
    const nodeChildRefShift = NodeChildIndexRefShift;
    const NodeMaskEOW = NodeHeaderEOWMask;
    const nodes = this.nodes;
    const charIndexes = this.wordToUtf8Seq(word);
    const len = charIndexes.length;
    let nodeIdx = 0;
    let node = nodes[nodeIdx];
    for (let p = 0; p < len; ++p, node = nodes[nodeIdx]) {
      const letterIdx = charIndexes[p];
      let i = node.length - 1;
      for (; i > 0; --i) if ((node[i] & NodeMaskChildCharIndex) === letterIdx) break;
      if (i < 1) return false;
      nodeIdx = node[i] >>> nodeChildRefShift;
    }
    return !!(node[0] & NodeMaskEOW);
  }
  isReadonly() {
    return this._readonly;
  }
  freeze() {
    this._readonly = true;
    return this;
  }
  copyNodes() {
    return this.nodes.map((n) => [...n]);
  }
  build(buildOptions) {
    var _a19, _b2;
    (_b2 = (_a19 = this._cursor) == null ? void 0 : _a19.dispose) == null ? void 0 : _b2.call(_a19);
    this._readonly = true;
    this.freeze();
    const endPerf = measurePerf2("TrieBlobBuilder.build");
    const { optimize, useStringTable } = buildOptions || {};
    const info = __privateGet(this, _infoBuilder).build();
    const bNodes = this.nodes;
    let sortedNodes = sortNodes(bNodes, NodeMaskCharByte);
    if (optimize != null ? optimize : sortNodes.length < AUTO_OPTIMIZE_NODE_COUNT) sortedNodes = optimizeNodes(sortedNodes);
    const stringTable = new StringTableBuilder().build();
    const r = useStringTable ? optimizeNodesWithStringTable({
      nodes: sortedNodes,
      stringTable
    }) : {
      nodes: sortedNodes,
      stringTable
    };
    const data = toTrieBlob(r.nodes, r.stringTable, normalizeTrieInfo(info.info));
    endPerf();
    return data;
  }
  toJSON() {
    return {
      options: this.options,
      nodes: this.nodes
    };
  }
  static fromWordList(words, options, buildOptions) {
    return new _a16(options).insert(words).build(buildOptions);
  }
  /**
  * Create a TrieBlob from a TrieRoot.
  *
  * This is equivalent to, but slightly faster because it avoids creating an ITrieNodes
  * ```ts
  * static fromTrieRoot(root: TrieRoot, optimize?: boolean): TrieBlob {
  *   return this.fromITrieRoot(trieRootToITrieRoot(root), optimize);
  * }
  * ```
  *
  * @param root - TrieRoot
  * @param buildOptions - optional build options
  * @returns TrieBlob
  */
  static fromTrieRoot(root, buildOptions) {
    const endPerf = measurePerf2("TrieBlobBuilder.fromTrieRoot");
    const NodeCharIndexMask = NodeMaskCharByte;
    const nodeChildRefShift = NodeChildIndexRefShift;
    const NodeMaskEOW = NodeHeaderEOWMask;
    const tf = new _a16(void 0, root);
    const IdxEOW = tf.IdxEOW;
    const known = /* @__PURE__ */ new Map([[root, 0]]);
    function resolveNode(n) {
      if (n.f && !n.c) return IdxEOW;
      const node = [n.f ? NodeMaskEOW : 0];
      return tf.nodes.push(node) - 1;
    }
    function walk(n) {
      const found = known.get(n);
      if (found) return found;
      const nodeIdx = resolveMap(known, n, resolveNode);
      const node = tf.nodes[nodeIdx];
      if (!n.c) return nodeIdx;
      const children = Object.entries(n.c);
      for (let p = 0; p < children.length; ++p) {
        const [char, childNode] = children[p];
        addCharToNode(node, char, childNode);
      }
      return nodeIdx;
    }
    function resolveChild(node, charIndex) {
      let i = 1;
      for (i = 1; i < node.length && (node[i] & NodeCharIndexMask) !== charIndex; ++i) ;
      return i;
    }
    function addCharToNode(node, char, n) {
      const indexSeq = tf.letterToUtf8Seq(char);
      assertValidUtf16Character(char);
      for (const idx2 of indexSeq.slice(0, -1)) {
        const pos = resolveChild(node, idx2);
        if (pos < node.length) node = tf.nodes[node[pos] >>> nodeChildRefShift];
        else {
          const next = [0];
          const nodeIdx = tf.nodes.push(next) - 1;
          node[pos] = nodeIdx << nodeChildRefShift | idx2;
          node = next;
        }
      }
      const letterIdx = indexSeq[indexSeq.length - 1];
      const i = node.push(letterIdx) - 1;
      node[i] = walk(n) << nodeChildRefShift | letterIdx;
    }
    walk(root);
    const result = tf.build(buildOptions);
    endPerf();
    return result;
  }
  /**
  * Create a TrieBlob from a TrieRoot.
  *
  * @param root - root node
  * @param buildOptions - optional build options
  * @returns TrieBlob
  */
  static fromITrieRoot(root, buildOptions) {
    const endPerf = measurePerf2("TrieBlobBuilder.fromITrieRoot");
    const NodeCharIndexMask = NodeMaskCharByte;
    const nodeChildRefShift = NodeChildIndexRefShift;
    const NodeMaskEOW = NodeHeaderEOWMask;
    const tf = new _a16(void 0, root);
    const IdxEOW = tf.IdxEOW;
    const known = /* @__PURE__ */ new Map([[root.id, 0]]);
    function resolveNode(n) {
      if (n.eow && !n.hasChildren()) return IdxEOW;
      const node = [n.eow ? NodeMaskEOW : 0];
      return tf.nodes.push(node) - 1;
    }
    function walk(n) {
      const found = known.get(n.id);
      if (found) return found;
      const nodeIdx = resolveMap(known, n.id, () => resolveNode(n));
      const node = tf.nodes[nodeIdx];
      if (!n.hasChildren()) return nodeIdx;
      const children = n.entries();
      for (const [char, childNode] of children) addCharToNode(node, char, childNode);
      return nodeIdx;
    }
    function resolveChild(node, charIndex) {
      let i = 1;
      for (i = 1; i < node.length && (node[i] & NodeCharIndexMask) !== charIndex; ++i) ;
      return i;
    }
    function addCharToNode(node, char, n) {
      const indexSeq = tf.letterToUtf8Seq(char);
      assertValidUtf16Character(char);
      for (const idx2 of indexSeq.slice(0, -1)) {
        const pos = resolveChild(node, idx2);
        if (pos < node.length) node = tf.nodes[node[pos] >>> nodeChildRefShift];
        else {
          const next = [0];
          const nodeIdx = tf.nodes.push(next) - 1;
          node[pos] = nodeIdx << nodeChildRefShift | idx2;
          node = next;
        }
      }
      const letterIdx = indexSeq[indexSeq.length - 1];
      const i = node.push(letterIdx) - 1;
      node[i] = walk(n) << nodeChildRefShift | letterIdx;
    }
    walk(root);
    const result = tf.build(buildOptions);
    endPerf();
    return result;
  }
}, _infoBuilder = new WeakMap(), _TrieBlobBuilder_instances = new WeakSet(), insertWord_fn = function(word) {
  word = word.trim();
  if (!word) return this;
  __privateGet(this, _infoBuilder).addWord(word);
  const NodeMaskChildCharIndex = NodeMaskCharByte;
  const nodeChildRefShift = NodeChildIndexRefShift;
  const NodeMaskEOW = NodeHeaderEOWMask;
  const IdxEOW = this.IdxEOW;
  const nodes = this.nodes;
  let nodeIdx = 0;
  const wLen = word.length;
  const bytes = [];
  for (const t = {
    text: word,
    i: 0
  }; t.i < wLen; ) {
    const isLastChar = t.i >= wLen - 1;
    for (let utf8Code = encodeTextToUtf8_32Rev(t); utf8Code; utf8Code >>>= 8) {
      const seq = utf8Code & 255;
      bytes.push(seq);
      const node = nodes[nodeIdx];
      let i = node.length - 1;
      for (; i > 0; --i) if ((node[i] & NodeMaskChildCharIndex) === seq) break;
      const isEow = isLastChar && utf8Code <= 255;
      if (i > 0) {
        nodeIdx = node[i] >>> nodeChildRefShift;
        if (nodeIdx === 1 && !isEow) {
          nodeIdx = this.nodes.push([NodeMaskEOW]) - 1;
          node[i] = nodeIdx << nodeChildRefShift | seq;
        }
        continue;
      }
      nodeIdx = isEow ? IdxEOW : this.nodes.push([0]) - 1;
      node.push(nodeIdx << nodeChildRefShift | seq);
    }
  }
  if (nodeIdx > 1) {
    const node = nodes[nodeIdx];
    node[0] |= NodeMaskEOW;
  }
  return this;
}, assertNotReadonly_fn = function() {
  assert5(!this.isReadonly(), "FastTrieBlobBuilder is readonly");
}, _a16);
function createCharUtf8_32RevLookup(maxSize = 256) {
  let size = 0;
  let map2 = /* @__PURE__ */ Object.create(null);
  return (char) => {
    let code = map2[char];
    if (!code) {
      size++;
      if (size >= maxSize) {
        size = 1;
        map2 = /* @__PURE__ */ Object.create(null);
      }
      code = encodeToUtf8_32Rev(char.codePointAt(0) || 0);
      map2[char] = code;
    }
    return code;
  };
}
function clean2(t) {
  const copy = { ...t };
  for (const key of Object.keys(copy)) if (copy[key] === void 0) delete copy[key];
  return copy;
}
var defaultLegacyMinCompoundLength$1 = 3;
var cvtFindWordOptions = memorizeLastCall(_cvtFindWordOptions);
function _cvtFindWordOptions(options) {
  return createFindOptions$1({
    matchCase: options == null ? void 0 : options.caseSensitive,
    checkForbidden: options == null ? void 0 : options.checkForbidden,
    compoundSeparator: options == null ? void 0 : options.compoundSeparator
  });
}
var _optionsCompound, _findOptionsT, _findOptionsF, _ITrieImpl_instances, hasLegacy_fn, _a17;
var ITrieImpl = (_a17 = class {
  constructor(data) {
    __privateAdd(this, _ITrieImpl_instances);
    __publicField(this, "_info");
    __publicField(this, "root");
    __publicField(this, "count");
    __publicField(this, "weightMap");
    __privateAdd(this, _optionsCompound, this.createFindOptions({ compoundMode: "compound" }));
    __privateAdd(this, _findOptionsT, {
      caseSensitive: true,
      checkForbidden: true
    });
    __privateAdd(this, _findOptionsF, {
      caseSensitive: false,
      checkForbidden: true
    });
    __publicField(this, "hasForbiddenWords");
    __publicField(this, "hasCompoundWords");
    __publicField(this, "hasNonStrictWords");
    __publicField(this, "data");
    this.data = data;
    this.root = data.getRoot();
    this._info = mergeOptionalWithDefaults(data.info);
    this.hasForbiddenWords = data.hasForbiddenWords;
    this.hasCompoundWords = data.hasCompoundWords;
    this.hasNonStrictWords = data.hasNonStrictWords;
  }
  /**
  * Number of words in the Trie, the first call to this method might be expensive.
  * Use `size` to get the number of nodes.
  */
  numWords() {
    var _a19;
    (_a19 = this.count) != null ? _a19 : this.count = countWords$1(this.root);
    return this.count;
  }
  isNumWordsKnown() {
    return this.count !== void 0;
  }
  get size() {
    return this.data.size;
  }
  get info() {
    return this._info;
  }
  /**
  * @param text - text to find in the Trie
  */
  find(text) {
    return findWordNode$1(this.data.getRoot(), text, __privateGet(this, _optionsCompound)).node;
  }
  /**
  * A case sensitive search for the word.
  * @param word - the word to search for.
  * @param minLegacyCompoundLength - minimum length of legacy compounds to consider.
  * @returns true if the word is found and not forbidden.
  */
  has(word, minLegacyCompoundLength) {
    if (minLegacyCompoundLength !== void 0) return __privateMethod(this, _ITrieImpl_instances, hasLegacy_fn).call(this, word, minLegacyCompoundLength);
    return this.hasWord(word, true);
  }
  /**
  * Determine if a word is in the dictionary.
  * @param word - the exact word to search for - must be normalized.
  * @param caseSensitive - false means also searching a dictionary where the words were normalized to lower case and accents removed.
  * @returns true if the word was found and is not forbidden.
  */
  hasWord(word, caseSensitive) {
    const options = caseSensitive ? __privateGet(this, _findOptionsT) : __privateGet(this, _findOptionsF);
    const r = this.findWord(word, options);
    return !r.forbidden && !!r.found;
  }
  findWord(word, options) {
    if (options == null ? void 0 : options.useLegacyWordCompounds) {
      const len = options.useLegacyWordCompounds !== true ? options.useLegacyWordCompounds : defaultLegacyMinCompoundLength$1;
      const findOptions = this.createFindOptions({
        legacyMinCompoundLength: len,
        matchCase: options.caseSensitive || false,
        compoundSeparator: void 0
      });
      return findLegacyCompound$1(this.root, word, findOptions);
    }
    return findWord$1(this.root, word, cvtFindWordOptions(options));
  }
  /**
  * Determine if a word is in the forbidden word list.
  * @param word the word to lookup.
  */
  isForbiddenWord(word) {
    return this.hasForbiddenWords && isForbiddenWord$1(this.root, word, this.info.forbiddenWordPrefix);
  }
  /**
  * Provides an ordered sequence of words with the prefix of text.
  */
  completeWord(text) {
    const n = this.find(text);
    const compoundChar = this.info.compoundCharacter;
    const subNodes = pipeSync(n ? iteratorTrieWords$1(n) : [], opFilterSync((w) => w[w.length - 1] !== compoundChar), opMapSync((suffix) => text + suffix));
    return pipeSync(n && n.eow ? [text] : [], opAppendSync(subNodes));
  }
  /**
  * Checks to see if there are preferred suggestions for the given text.
  * @param text
  */
  wordHasPreferredSuggestions(text) {
    return this.has(this.info.suggestionPrefix + text);
  }
  /**
  * Get preferred suggestions for the given text.
  * @param text - the exact word to search for.
  */
  getPreferredSuggestions(text) {
    const prefix = text + this.info.suggestionPrefix;
    return pipeSync(this.getAllPreferredSuggestions(prefix), opMapSync((s) => s.slice(prefix.length)));
  }
  /**
  * Get a list of all preferred suggestions in the trie.
  * They are returned in order and in the following format:
  * ```
  * <word1>:<suggestion1>
  * <word1>:<suggestion2>
  * <word2>:<suggestion1>
  * ```
  *
  * If `startingWith` is provided, only words that start with the prefix are returned.
  *
  * @param startingWith - optional prefix to filter the words returned.
  */
  getAllPreferredSuggestions(startingWith = "") {
    const regexpSugIndex = /:[0-9a-f]{1,2}:/;
    const sugPrefix = this.info.suggestionPrefix;
    return pipeSync(this.data.words(sugPrefix + startingWith), opMapSync((result) => result.slice(1).replace(regexpSugIndex, ":")), opFilterSync((w) => w.includes(":")));
  }
  /**
  * Checks to see if the trie contains preferred suggestions for any words.
  */
  get hasPreferredSuggestions() {
    return this.data.hasPreferredSuggestions;
  }
  /**
  * Suggest spellings for `text`.  The results are sorted by edit distance with changes near the beginning of a word having a greater impact.
  * @param text - the text to search for
  * @param maxNumSuggestions - the maximum number of suggestions to return.
  * @param compoundMethod - Use to control splitting words.
  * @param numChanges - the maximum number of changes allowed to text. This is an approximate value, since some changes cost less than others.
  *                      the lower the value, the faster results are returned. Values less than 4 are best.
  */
  suggest(text, options) {
    return this.suggestWithCost(text, options).map((a) => a.word);
  }
  /**
  * Suggest spellings for `text`.  The results are sorted by edit distance with changes near the beginning of a word having a greater impact.
  * The results include the word and adjusted edit cost.  This is useful for merging results from multiple tries.
  */
  suggestWithCost(text, options) {
    const sep2 = options.compoundSeparator;
    const weightMap = options.weightMap || this.weightMap;
    const adjWord = sep2 ? replaceAllFactory(sep2, "") : (a) => a;
    const optFilter = options.filter;
    const filter2 = optFilter ? (word, cost) => {
      const w = adjWord(word);
      return !this.isForbiddenWord(w) && optFilter(w, cost);
    } : (word) => !this.isForbiddenWord(adjWord(word));
    const opts = {
      ...options,
      filter: filter2,
      weightMap
    };
    return suggestAStar(this.data, text, opts);
  }
  /**
  * genSuggestions will generate suggestions and send them to `collector`. `collector` is responsible for returning the max acceptable cost.
  * Costs are measured in weighted changes. A cost of 100 is the same as 1 edit. Some edits are considered cheaper.
  * Returning a MaxCost < 0 will effectively cause the search for suggestions to stop.
  */
  genSuggestions(collector, compoundMethod) {
    const filter2 = (word) => !this.isForbiddenWord(word);
    const options = createSuggestionOptions(clean2({
      compoundMethod,
      ...collector.genSuggestionOptions
    }));
    const suggestions = getSuggestionsAStar(this.data, collector.word, options);
    collector.collect(suggestions, void 0, filter2);
  }
  /**
  * Returns an iterator that can be used to get all words in the trie. For some dictionaries, this can result in millions of words.
  * Note: this will not compound words automatically.
  * @param prefix - optional prefix to filter the words returned. The words will be prefixed with this value.
  */
  words(prefix) {
    return this.data.words(prefix);
  }
  /**
  * Allows iteration over the entire tree.
  * On the returned Iterator, calling .next(goDeeper: boolean), allows for controlling the depth.
  */
  iterate() {
    return walker$1(this.root);
  }
  static create(words, info) {
    const builder = new TrieBlobBuilder(info);
    builder.insert(words);
    return new _a17(builder.build());
  }
  createFindOptions(options) {
    return createFindOptions$1(options);
  }
}, _optionsCompound = new WeakMap(), _findOptionsT = new WeakMap(), _findOptionsF = new WeakMap(), _ITrieImpl_instances = new WeakSet(), hasLegacy_fn = function(word, minLegacyCompoundLength) {
  if (this.hasWord(word, false)) return true;
  if (minLegacyCompoundLength) {
    const f = this.findWord(word, {
      useLegacyWordCompounds: minLegacyCompoundLength,
      caseSensitive: false,
      checkForbidden: true
    });
    return !!f.found && !f.forbidden;
  }
  return false;
}, _a17);
function buildITrieFromWords(words, info = {}, buildOptions) {
  const endPerf = measurePerf2("buildITrieFromWords");
  try {
    const builder = new TrieBlobBuilder(info);
    builder.insert(words);
    return new ITrieImpl(builder.build(buildOptions));
  } finally {
    endPerf();
  }
}
var FLAG_WORD = 1;
function insert(word, root = {}) {
  const text = [...word];
  let node = root;
  for (let i = 0; i < text.length; ++i) {
    const head = text[i];
    const c = node.c || /* @__PURE__ */ Object.create(null);
    node.c = c;
    node = c[head] || {};
    c[head] = node;
  }
  node.f = (node.f || 0) | FLAG_WORD;
  return root;
}
function createTrieRoot(options) {
  return new CTrieRoot(options);
}
function createTrieRootFromList(words, options) {
  const root = createTrieRoot(options);
  for (const word of words) if (word.length) insert(word, root);
  return root;
}
function countNodes(root) {
  const seen = /* @__PURE__ */ new Set();
  function walk(n) {
    if (seen.has(n)) return;
    seen.add(n);
    if (n.c) Object.values(n.c).forEach((n2) => walk(n2));
  }
  walk(root);
  return seen.size;
}
function checkCircular(root) {
  const seen = /* @__PURE__ */ new Set();
  const inStack = /* @__PURE__ */ new Set();
  function walk(n) {
    if (seen.has(n)) return {
      isCircular: false,
      allSeen: true
    };
    if (inStack.has(n)) {
      const stack = [...inStack, n];
      return {
        isCircular: true,
        allSeen: false,
        ref: {
          stack,
          word: trieStackToWord(stack),
          pos: stack.indexOf(n)
        }
      };
    }
    inStack.add(n);
    let r = {
      isCircular: false,
      allSeen: true
    };
    if (n.c) r = Object.values(n.c).reduce((acc, n2) => {
      if (acc.isCircular) return acc;
      const r2 = walk(n2);
      r2.allSeen = r2.allSeen && acc.allSeen;
      return r2;
    }, r);
    if (r.allSeen) seen.add(n);
    inStack.delete(n);
    return r;
  }
  return walk(root);
}
function reverseMapTrieNode(node) {
  return node.c && new Map(Object.entries(node.c).map(([c, n]) => [n, c]));
}
function trieStackToWord(stack) {
  let word = "";
  let lastMap = reverseMapTrieNode(stack[0]);
  for (let i = 1; i < stack.length; ++i) {
    const n = stack[i];
    const char = lastMap == null ? void 0 : lastMap.get(n);
    if (char) word += char;
    lastMap = reverseMapTrieNode(n);
  }
  return word;
}
function isCircular(root) {
  return checkCircular(root).isCircular;
}
function trieNodeToRoot(node, options) {
  return CTrieRoot.createFrom(node, options);
}
var CTrieRoot = class CTrieRoot2 {
  constructor(options) {
    __publicField(this, "c");
    __publicField(this, "compoundCharacter");
    __publicField(this, "stripCaseAndAccentsPrefix");
    __publicField(this, "forbiddenWordPrefix");
    __publicField(this, "suggestionPrefix");
    const newOptions = mergeOptionalWithDefaults(options);
    this.c = /* @__PURE__ */ Object.create(null);
    this.compoundCharacter = newOptions.compoundCharacter;
    this.stripCaseAndAccentsPrefix = newOptions.stripCaseAndAccentsPrefix;
    this.forbiddenWordPrefix = newOptions.forbiddenWordPrefix;
    this.suggestionPrefix = newOptions.suggestionPrefix;
  }
  get hasForbiddenWords() {
    return !!this.c[this.forbiddenWordPrefix];
  }
  get hasCompoundWords() {
    return !!this.c[this.compoundCharacter];
  }
  get hasNonStrictWords() {
    return !!this.c[this.stripCaseAndAccentsPrefix];
  }
  get hasPreferredSuggestions() {
    return !!this.c[this.suggestionPrefix];
  }
  static createFrom(trie, options) {
    const root = new CTrieRoot2(options);
    root.c = trie.c || /* @__PURE__ */ Object.create(null);
    return root;
  }
};
function consolidate(root) {
  let count2 = 0;
  const signatures = /* @__PURE__ */ new Map();
  const cached = /* @__PURE__ */ new Map();
  const knownMap = /* @__PURE__ */ new Map();
  if (isCircular(root)) throw new Error("Trie is circular.");
  function signature(n) {
    return (n.f ? "*" : "") + (n.c ? JSON.stringify(Object.entries(n.c).map(([k, n2]) => [k, cached.get(n2)])) : "");
  }
  function findEow(n) {
    if (n.f && !n.c) return n;
    let r;
    if (n.c) for (const c of Object.values(n.c)) {
      r = findEow(c);
      if (r) break;
    }
    return r;
  }
  function compareMaps(a, b) {
    for (const e of a) if (b[e[0]] !== e[1]) return false;
    return a.length === b.size;
  }
  function deepCopy(n) {
    const k = knownMap.get(n);
    if (k) return k;
    const orig = n;
    if (n.c) {
      const children = Object.entries(n.c).map((c) => [c[0], deepCopy(c[1])]);
      if (!compareMaps(children, n.c)) n = {
        f: n.f,
        c: Object.fromEntries(children)
      };
    }
    const sig = signature(n);
    const ref = signatures.get(sig);
    if (ref) {
      knownMap.set(orig, ref);
      return ref;
    }
    Object.freeze(n);
    signatures.set(sig, n);
    cached.set(n, count2++);
    knownMap.set(orig, n);
    return n;
  }
  function process(n) {
    if (cached.has(n)) return n;
    if (Object.isFrozen(n)) return knownMap.get(n) || deepCopy(n);
    if (n.c) {
      const children = Object.entries(n.c).sort((a, b) => a[0] < b[0] ? -1 : 1).map(([k, n2]) => [k, process(n2)]);
      n.c = Object.fromEntries(children);
    }
    const sig = signature(n);
    const ref = signatures.get(sig);
    if (ref) return ref;
    signatures.set(sig, n);
    cached.set(n, count2++);
    return n;
  }
  const eow = findEow(root) || {
    f: FLAG_WORD,
    c: void 0
  };
  signatures.set(signature(eow), eow);
  cached.set(eow, count2++);
  return trieNodeToRoot(process(root), root);
}
function decodeBTrie(data) {
  return TrieBlob.decodeBin(data);
}
var _defaultFindOptions = {
  matchCase: false,
  compoundMode: "compound",
  forbidPrefix: FORBID_PREFIX,
  compoundFix: COMPOUND_FIX,
  caseInsensitivePrefix: CASE_INSENSITIVE_PREFIX,
  legacyMinCompoundLength: 3,
  compoundSeparator: void 0
};
var knownCompoundModes = new Map([
  "none",
  "compound",
  "legacy"
].map((a) => [a, a]));
function findWordExact(root, word) {
  return isEndOfWordNode(walk$1(root, word));
}
function isEndOfWordNode(n) {
  return (n == null ? void 0 : n.f) === FLAG_WORD;
}
function walk$1(root, word) {
  var _a19;
  const w = [...word];
  let n = root;
  let i = 0;
  while (n && i < w.length) {
    const h = w[i++];
    n = (_a19 = n.c) == null ? void 0 : _a19[h];
  }
  return n;
}
var createFindOptions = memorizeLastCall(_createFindOptions);
function _createFindOptions(options) {
  return mergeDefaults(options, _defaultFindOptions);
}
var TrieNodeTrie = class TrieNodeTrie2 {
  constructor(root) {
    __publicField(this, "_iTrieRoot");
    __publicField(this, "info");
    __publicField(this, "_size");
    __publicField(this, "hasForbiddenWords");
    __publicField(this, "hasCompoundWords");
    __publicField(this, "hasNonStrictWords");
    __publicField(this, "hasPreferredSuggestions");
    __publicField(this, "root");
    __publicField(this, "wordToCharacters", (word) => [...word]);
    this.root = root;
    this.info = mergeOptionalWithDefaults(root);
    this.hasForbiddenWords = root.hasForbiddenWords;
    this.hasCompoundWords = root.hasCompoundWords;
    this.hasNonStrictWords = root.hasNonStrictWords;
    this.hasPreferredSuggestions = root.hasPreferredSuggestions;
  }
  get iTrieRoot() {
    return this._iTrieRoot || (this._iTrieRoot = trieRootToITrieRoot(this.root));
  }
  getRoot() {
    return this.iTrieRoot;
  }
  getNode(prefix) {
    return findNode$1(this.getRoot(), prefix);
  }
  *words(prefix) {
    if (!prefix) {
      yield* iteratorTrieWords$1(this.getRoot());
      return;
    }
    const node = this.getNode(prefix);
    if (!node) return;
    if (node.eow) yield prefix;
    for (const suffix of iteratorTrieWords$1(node)) yield prefix + suffix;
  }
  has(word) {
    return findWordExact(this.root, word);
  }
  isForbiddenWord(word) {
    return findWordExact(this.root.c[this.root.forbiddenWordPrefix], word);
  }
  get size() {
    var _a19;
    return (_a19 = this._size) != null ? _a19 : this._size = countNodes(this.root);
  }
  static createFromWords(words, options) {
    return new TrieNodeTrie2(createTrieRootFromList(words, options));
  }
  static createFromWordsAndConsolidate(words, options) {
    return new TrieNodeTrie2(consolidate(createTrieRootFromList(words, options)));
  }
};
function* toIterableIterator$2(i) {
  yield* i;
}
function* filter$1(i, fnFilter) {
  for (const v of i) if (fnFilter(v)) yield v;
}
function* skip$1(i, n) {
  let a = 0;
  for (const t of i) {
    if (a >= n) yield t;
    a += 1;
  }
}
function* take$1(i, n) {
  let a = 0;
  if (n) for (const t of i) {
    if (a >= n) break;
    yield t;
    a += 1;
  }
}
function* concat$1(i, j) {
  yield* i;
  yield* j;
}
function* concatMap$1(i, fn) {
  for (const t of i) yield* fn(t);
}
function* combine$1(i, j, fnMap) {
  const jit = j[Symbol.iterator]();
  for (const r of i) {
    const s = jit.next().value;
    yield fnMap(r, s);
  }
}
function map$1(i, fnMap) {
  function* fn(i2, fnMap2) {
    for (const v of i2) yield fnMap2(v);
  }
  return fn(i, fnMap);
}
function* scan$1(i, fnReduce, initValue) {
  let index = 0;
  if (initValue === void 0) {
    index = 1;
    const iter = i[Symbol.iterator]();
    let r = iter.next();
    if (!r.done) yield r.value;
    initValue = r.value;
    i = makeIterable(iter);
  }
  let prevValue = initValue;
  for (const t of i) {
    const nextValue = fnReduce(prevValue, t, index);
    yield nextValue;
    prevValue = nextValue;
    index += 1;
  }
}
function all$1(i, fn) {
  for (const t of i) if (!fn(t)) return false;
  return true;
}
function any$1(i, fn) {
  for (const t of i) if (fn(t)) return true;
  return false;
}
function count$1(i) {
  return reduce$1(i, (p) => p + 1, 0);
}
function first$1(i, fn, defaultValue) {
  fn = fn || (() => true);
  for (const t of i) if (fn(t)) return t;
  return defaultValue;
}
function forEach$1(i, fn) {
  let index = 0;
  for (const t of i) {
    fn(t, index);
    index += 1;
  }
}
function max$1(i, selector = (t) => t) {
  return reduce$1(i, (p, c) => selector(c) > selector(p) ? c : p, void 0);
}
function min$1(i, selector = (t) => t) {
  return reduce$1(i, (p, c) => selector(c) < selector(p) ? c : p, void 0);
}
function reduce$1(i, fnReduce, initialValue) {
  const iter = makeIterable(i[Symbol.iterator]());
  let index = 0;
  if (initialValue === void 0) {
    index = 1;
    initialValue = iter.next().value;
  }
  let prevValue = initialValue;
  for (const t of iter) {
    prevValue = fnReduce(prevValue, t, index);
    index += 1;
  }
  return prevValue;
}
async function reduceAsync$1(i, fnReduce, initialValue) {
  const iter = makeIterable(i[Symbol.iterator]());
  let index = 0;
  if (initialValue === void 0) {
    index = 1;
    initialValue = iter.next().value;
  }
  let previousValue = await initialValue;
  for (const p of iter) {
    const t = await p;
    previousValue = await fnReduce(previousValue, t, index);
    index += 1;
  }
  return previousValue;
}
function makeIterable(i) {
  function* fromIterator(i2) {
    for (let r = i2.next(); !r.done; r = i2.next()) yield r.value;
  }
  function* fromIterable(i2) {
    yield* i2;
  }
  return isIterable(i) ? isIterableIterator(i) ? i : fromIterable(i) : fromIterator(i);
}
function isIterable(i) {
  return !!i[Symbol.iterator];
}
function isIterableIterator(i) {
  return typeof i.next == "function";
}
function filter(fnFilter) {
  return (i) => filter$1(i, fnFilter);
}
function skip2(n) {
  return (i) => skip$1(i, n);
}
function take(n) {
  return (i) => take$1(i, n);
}
function concat(j) {
  return (i) => concat$1(i, j);
}
function concatMap(fn) {
  return (i) => concatMap$1(i, fn);
}
function combine(fnMap, j) {
  return (i) => combine$1(i, j, fnMap);
}
function map(fnMap) {
  return (i) => map$1(i, fnMap);
}
function scan(fnReduce, initValue) {
  return (i) => scan$1(i, fnReduce, initValue);
}
function all(fn) {
  return (i) => all$1(i, fn);
}
function any(fn) {
  return (i) => any$1(i, fn);
}
function count() {
  return (i) => count$1(i);
}
function first(fn, defaultValue) {
  return (i) => first$1(i, fn, defaultValue);
}
function forEach(fn) {
  return (i) => forEach$1(i, fn);
}
function max(selector) {
  return (i) => max$1(i, selector);
}
function min(selector) {
  return (i) => min$1(i, selector);
}
function reduce(fnReduce, initialValue) {
  return (i) => reduce$1(i, fnReduce, initialValue);
}
function reduceAsync(fnReduceAsync, initialValue) {
  return (i) => reduceAsync$1(i, fnReduceAsync, initialValue);
}
function pipe(...fns) {
  return (i) => {
    for (const fn of fns) i = fn ? fn(i) : i;
    return i;
  };
}
var ImplSequence = class ImplSequence2 {
  constructor(i) {
    __publicField(this, "i");
    __publicField(this, "_iterator");
    this.i = i;
  }
  get iter() {
    return typeof this.i === "function" ? this.i() : this.i;
  }
  get iterator() {
    if (!this._iterator) this._iterator = this.iter[Symbol.iterator]();
    return this._iterator;
  }
  inject(fn) {
    const iter = this.i;
    return () => fn(typeof iter === "function" ? iter() : iter);
  }
  chain(fn) {
    return new ImplSequence2(this.inject(fn));
  }
  [Symbol.iterator]() {
    return this.iter[Symbol.iterator]();
  }
  next() {
    return this.iterator.next();
  }
  filter(fnFilter) {
    return this.chain(filter(fnFilter));
  }
  skip(n) {
    return this.chain(skip2(n));
  }
  take(n) {
    return this.chain(take(n));
  }
  concat(j) {
    return this.chain(concat(j));
  }
  concatMap(fn) {
    return this.chain(concatMap(fn));
  }
  combine(fn, j) {
    return this.chain(combine(fn, j));
  }
  map(fn) {
    return this.chain(map(fn));
  }
  scan(fnReduce, initValue) {
    return this.chain(scan(fnReduce, initValue));
  }
  pipe(...fns) {
    if (!fns.length) return this;
    return this.chain(pipe.apply(null, fns));
  }
  all(fnFilter) {
    return all(fnFilter)(this.iter);
  }
  any(fnFilter) {
    return any(fnFilter)(this.iter);
  }
  count() {
    return count()(this.iter);
  }
  first(fnFilter, defaultValue) {
    return first(fnFilter, defaultValue)(this.iter);
  }
  forEach(fn) {
    return forEach(fn)(this.iter);
  }
  max(fnSelector) {
    return max(fnSelector)(this.iter);
  }
  min(fnSelector) {
    return min(fnSelector)(this.iter);
  }
  reduce(fnReduce, initValue) {
    return reduce(fnReduce, initValue)(this.iter);
  }
  reduceAsync(fnReduceAsync, initialValue) {
    return reduceAsync(fnReduceAsync, initialValue)(this.iter);
  }
  reduceToSequence(fnReduce, initialValue) {
    return this.chain(reduce(fnReduce, initialValue));
  }
  toArray() {
    return [...this.iter];
  }
  toIterable() {
    return toIterableIterator$2(this.iter);
  }
};
function genSequence(i) {
  return new ImplSequence(i);
}
var EOW$3 = "*";
var DATA$4 = EOW$3;
function* toIterableIterator$1(iter) {
  yield* iter;
}
function importTrie$5(linesX) {
  let radix = 16;
  const comment = /^\s*#/;
  const iter = toIterableIterator$1(linesX);
  function parseHeaderRows(headerRows) {
    const header = headerRows.slice(0, 2).join("\n");
    const headerReg = /^TrieXv1\nbase=(\d+)$/;
    if (!headerReg.test(header)) throw new Error("Unknown file format");
    radix = Number.parseInt(header.replace(headerReg, "$1"), 10);
  }
  function readHeader(iter2) {
    const headerRows = [];
    while (true) {
      const next = iter2.next();
      if (next.done) break;
      const line = next.value.trim();
      if (!line || comment.test(line)) continue;
      if (line === DATA$4) break;
      headerRows.push(line);
    }
    parseHeaderRows(headerRows);
  }
  const regNotEscapedCommas = /(^|[^\\]),/g;
  const regUnescapeCommas = /__COMMA__/g;
  const regUnescape = /[\\](.)/g;
  const flagsWord = { f: FLAG_WORD };
  function splitLine2(line) {
    return line.replaceAll(regNotEscapedCommas, "$1__COMMA__").split(regUnescapeCommas).map((a) => a.replaceAll(regUnescape, "$1"));
  }
  function decodeLine2(line, nodes) {
    const isWord = line[0] === EOW$3;
    line = isWord ? line.slice(1) : line;
    const flags = isWord ? flagsWord : {};
    const children = splitLine2(line).filter((a) => !!a).map((a) => [a[0], Number.parseInt(a.slice(1) || "0", radix)]).map(([k, i]) => [k, nodes[i]]);
    return {
      ...children.length ? { c: Object.fromEntries(children) } : {},
      ...flags
    };
  }
  readHeader(iter);
  return trieNodeToRoot(genSequence([DATA$4]).concat(iter).map((a) => a.replace(/\r?\n/, "")).filter((a) => !!a).reduce((acc, line) => {
    const { lines, nodes } = acc;
    const root = decodeLine2(line, nodes);
    nodes[lines] = root;
    return {
      lines: lines + 1,
      root,
      nodes
    };
  }, {
    lines: 0,
    nodes: [],
    root: {}
  }).root, {});
}
var EOW$2 = "*";
var DATA$3 = "__DATA__";
function* toIterableIterator(iter) {
  yield* iter;
}
function importTrie$4(linesX) {
  let radix = 16;
  const comment = /^\s*#/;
  const iter = toIterableIterator(linesX);
  function parseHeaderRows(headerRows) {
    const header = headerRows.slice(0, 2).join("\n");
    const headerReg = /^TrieXv2\nbase=(\d+)$/;
    if (!headerReg.test(header)) throw new Error("Unknown file format");
    radix = Number.parseInt(header.replace(headerReg, "$1"), 10);
  }
  function readHeader(iter2) {
    const headerRows = [];
    while (true) {
      const next = iter2.next();
      if (next.done) break;
      const line = next.value.trim();
      if (!line || comment.test(line)) continue;
      if (line === DATA$3) break;
      headerRows.push(line);
    }
    parseHeaderRows(headerRows);
  }
  function parseLine(line, base) {
    const isWord = line[1] === EOW$2;
    const refOffset = isWord ? 2 : 1;
    const refs = line.slice(refOffset).split(",").filter((a) => !!a).map((r) => Number.parseInt(r, base));
    return {
      letter: line[0],
      isWord,
      refs
    };
  }
  const flagsWord = { f: FLAG_WORD };
  function decodeLine2(line, nodes) {
    const { letter, isWord, refs } = parseLine(line, radix);
    const flags = isWord ? flagsWord : {};
    const children = refs.map((r) => nodes[r]).sort((a, b) => a.s < b.s ? -1 : 1).map((n) => [n.s, n]);
    return {
      s: letter,
      ...children.length ? { c: Object.fromEntries(children) } : {},
      ...flags
    };
  }
  readHeader(iter);
  return trieNodeToRoot(genSequence(iter).map((a) => a.replace(/\r?\n/, "")).filter((a) => !!a).reduce((acc, line) => {
    const { nodes } = acc;
    const root = decodeLine2(line, nodes);
    nodes.push(root);
    return {
      root,
      nodes
    };
  }, {
    nodes: [],
    root: {
      s: "",
      c: /* @__PURE__ */ Object.create(null)
    }
  }).root, {});
}
var EOW$1 = "$";
var BACK = "<";
var EOL = "\n";
var LF = "\r";
var REF = "#";
var REF_REL = "@";
var EOR = ";";
var ESCAPE = "\\";
var REF_INDEX_BEGIN = "[";
var REF_INDEX_END = "]";
var INLINE_DATA_COMMENT_LINE = "/";
var specialCharacters$1 = stringToCharSet$2([
  EOW$1,
  BACK,
  EOL,
  REF,
  REF_REL,
  EOR,
  ESCAPE,
  LF,
  REF_INDEX_BEGIN,
  REF_INDEX_END,
  INLINE_DATA_COMMENT_LINE,
  ..."0123456789",
  ..."`~!@#$%^&*()_-+=[]{};:'\"<>,./?\\|"
].join(""));
var SPECIAL_CHARACTERS_MAP = [
  ["\n", "\\n"],
  ["\r", "\\r"],
  ["\\", "\\\\"]
];
var specialCharacterMap$2 = stringToCharMap(SPECIAL_CHARACTERS_MAP);
var characterMap$1 = stringToCharMap(SPECIAL_CHARACTERS_MAP.map((a) => [a[1], a[0]]));
var specialPrefix$1 = stringToCharSet$2("~!");
var DATA$2 = "__DATA__";
function importTrie$3(linesX) {
  linesX = typeof linesX === "string" ? linesX.split(/^/m) : linesX;
  let radix = 10;
  const comment = /^\s*#/;
  const iter = tapIterable(pipeSync(linesX, opConcatMapSync((a) => a.split(/^/m))));
  function parseHeaderRows(headerRows) {
    const header = headerRows.slice(0, 2).join("\n");
    const headerReg = /^TrieXv[34]\nbase=(\d+)$/;
    if (!headerReg.test(header)) throw new Error("Unknown file format");
    radix = Number.parseInt(header.replace(headerReg, "$1"), 10);
  }
  function readHeader(iter2) {
    const headerRows = [];
    for (const value of iter2) {
      const line = value.trim();
      if (!line || comment.test(line)) continue;
      if (line === DATA$2) break;
      headerRows.push(line);
    }
    parseHeaderRows(headerRows);
  }
  readHeader(iter);
  return parseStream$1(radix, iter);
}
var numbersSet = stringToCharSet$2("0123456789");
function parseStream$1(radix, iter) {
  const eow = Object.freeze({ f: 1 });
  let refIndex = [];
  const root = trieNodeToRoot({}, {});
  function parseReference(acc, s) {
    const isIndexRef = s === REF_REL;
    let ref = "";
    function parser(acc2, s2) {
      if (s2 === EOR || radix === 10 && !(s2 in numbersSet)) {
        const { root: root2, nodes: nodes2, stack } = acc2;
        const r = Number.parseInt(ref, radix);
        const top = stack[stack.length - 1];
        const p = stack[stack.length - 2].node;
        const n = isIndexRef ? refIndex[r] : r;
        p.c && (p.c[top.s] = nodes2[n]);
        const rr = {
          root: root2,
          nodes: nodes2,
          stack,
          parser: void 0
        };
        return s2 === EOR ? rr : parserMain(rr, s2);
      }
      ref = ref + s2;
      return acc2;
    }
    const { nodes } = acc;
    nodes.pop();
    return {
      ...acc,
      nodes,
      parser
    };
  }
  function parseEscapeCharacter(acc, _) {
    let prev = "";
    const parser = function(acc2, s) {
      if (prev) {
        s = characterMap$1[prev + s] || s;
        return parseCharacter({
          ...acc2,
          parser: void 0
        }, s);
      }
      if (s === ESCAPE) {
        prev = s;
        return acc2;
      }
      return parseCharacter({
        ...acc2,
        parser: void 0
      }, s);
    };
    return {
      ...acc,
      parser
    };
  }
  function parseComment(acc, s) {
    const endOfComment = s;
    let isEscaped = false;
    function parser(acc2, s2) {
      if (isEscaped) {
        isEscaped = false;
        return acc2;
      }
      if (s2 === ESCAPE) {
        isEscaped = true;
        return acc2;
      }
      if (s2 === endOfComment) return {
        ...acc2,
        parser: void 0
      };
      return acc2;
    }
    return {
      ...acc,
      parser
    };
  }
  function parseCharacter(acc, s) {
    var _a19;
    const parser = void 0;
    const { root: root2, nodes, stack } = acc;
    const node = stack[stack.length - 1].node;
    const c = (_a19 = node.c) != null ? _a19 : /* @__PURE__ */ Object.create(null);
    const n = {
      f: void 0,
      c: void 0,
      n: nodes.length
    };
    c[s] = n;
    node.c = c;
    stack.push({
      node: n,
      s
    });
    nodes.push(n);
    return {
      root: root2,
      nodes,
      stack,
      parser
    };
  }
  function parseEOW(acc, _) {
    const parser = parseBack;
    const { root: root2, nodes, stack } = acc;
    const top = stack[stack.length - 1];
    const node = top.node;
    node.f = FLAG_WORD;
    if (!node.c) {
      top.node = eow;
      const p = stack[stack.length - 2].node;
      p.c && (p.c[top.s] = eow);
      nodes.pop();
    }
    stack.pop();
    return {
      root: root2,
      nodes,
      stack,
      parser
    };
  }
  const charactersBack = stringToCharSet$2(BACK + "23456789");
  function parseBack(acc, s) {
    if (!(s in charactersBack)) return parserMain({
      ...acc,
      parser: void 0
    }, s);
    let n = s === BACK ? 1 : Number.parseInt(s, 10) - 1;
    const { stack } = acc;
    while (n-- > 0) stack.pop();
    return {
      ...acc,
      parser: parseBack
    };
  }
  function parseIgnore(acc, _) {
    return acc;
  }
  const parsers2 = createStringLookupMap([
    [EOW$1, parseEOW],
    [BACK, parseBack],
    [REF, parseReference],
    [REF_REL, parseReference],
    [ESCAPE, parseEscapeCharacter],
    [EOL, parseIgnore],
    [LF, parseIgnore],
    [INLINE_DATA_COMMENT_LINE, parseComment]
  ]);
  function parserMain(acc, s) {
    var _a19, _b2;
    return ((_b2 = (_a19 = acc.parser) != null ? _a19 : parsers2[s]) != null ? _b2 : parseCharacter)(acc, s);
  }
  const charsetSpaces = stringToCharSet$2(" \r\n	");
  function parseReferenceIndex(acc, s) {
    let json = "";
    function parserStart(acc2, s2) {
      if (s2 === REF_INDEX_BEGIN) {
        json = json + s2;
        return {
          ...acc2,
          parser
        };
      }
      if (s2 in charsetSpaces) return acc2;
      return parserMain({
        ...acc2,
        parser: void 0
      }, s2);
    }
    function parser(acc2, s2) {
      json = json + s2;
      if (s2 === REF_INDEX_END) {
        refIndex = json.replaceAll(/[\s[\]]/g, "").split(",").map((n) => Number.parseInt(n, radix));
        return {
          ...acc2,
          parser: void 0
        };
      }
      return acc2;
    }
    return parserStart({
      ...acc,
      parser: parserStart
    }, s);
  }
  reduceSync(pipeSync(iter, opConcatMapSync((a) => [...a])), parserMain, {
    nodes: [root],
    root,
    stack: [{
      node: root,
      s: ""
    }],
    parser: parseReferenceIndex
  });
  return root;
}
function stringToCharSet$2(values) {
  const set = /* @__PURE__ */ Object.create(null);
  const len = values.length;
  for (let i = 0; i < len; ++i) set[values[i]] = true;
  return set;
}
function stringToCharMap(values) {
  return createStringLookupMap(values);
}
function createStringLookupMap(values) {
  const map2 = /* @__PURE__ */ Object.create(null);
  const len = values.length;
  for (let i = 0; i < len; ++i) map2[values[i][0]] = values[i][1];
  return map2;
}
function tapIterable(iterable) {
  let lastValue;
  let iter;
  function getNext() {
    if (lastValue && lastValue.done) return { ...lastValue };
    iter = iter || iterable[Symbol.iterator]();
    lastValue = iter.next();
    return lastValue;
  }
  function* iterableFn() {
    let next;
    while (!(next = getNext()).done) yield next.value;
  }
  return { [Symbol.iterator]: iterableFn };
}
var EOW = Object.freeze({
  f: 1,
  k: true
});
var compare = new Intl.Collator().compare;
var specialCharacterMap$1 = /* @__PURE__ */ new Map([
  ["\n", "\\n"],
  ["\r", "\\r"],
  ["\\", "\\\\"]
]);
var characterMap = new Map([...specialCharacterMap$1].map((a) => [a[1], a[0]]));
var DATA$1 = "__DATA__";
function importTrieV3WithBuilder(builder, srcLines) {
  const timerStart = measurePerf2("importTrieV3");
  const dataLines = typeof srcLines === "string" ? srcLines.split("\n") : Array.isArray(srcLines) ? srcLines : [...srcLines];
  let radix = 16;
  const comment = /^\s*#/;
  function parseHeaderRows(headerRows) {
    const header = headerRows.slice(0, 2).join("\n");
    const headerReg = /^TrieXv3\nbase=(\d+)$/;
    if (!headerReg.test(header)) throw new Error("Unknown file format");
    radix = Number.parseInt(header.replace(headerReg, "$1"), 10);
  }
  function findStartOfData(data) {
    for (let i = 0; i < data.length; ++i) if (data[i].includes(DATA$1)) return i;
    return -1;
  }
  function readHeader(data) {
    const headerRows = [];
    for (const hLine of data) {
      const line = hLine.trim();
      if (!line || comment.test(line)) continue;
      if (line === DATA$1) break;
      headerRows.push(line);
    }
    parseHeaderRows(headerRows);
  }
  const startOfData = findStartOfData(dataLines);
  if (startOfData < 0) throw new Error("Unknown file format");
  readHeader(dataLines.slice(0, startOfData));
  let node = {
    cursor: builder.getCursor(),
    parser: void 0
  };
  const parser = parseStream(radix);
  const timerParse = measurePerf2("importTrieV3.parse");
  for (let i = startOfData + 1; i < dataLines.length; ++i) {
    const line = dataLines[i];
    for (const c of line) node = parser(node, c);
  }
  timerParse();
  timerStart();
  return builder.build();
}
function parseStream(radix) {
  function parseReference(acc, _) {
    let ref = "";
    function parser(acc2, s) {
      if (s === EOR) {
        const { cursor } = acc2;
        const r = Number.parseInt(ref, radix);
        cursor.reference(r + 1);
        acc2.parser = void 0;
        return acc2;
      }
      ref = ref + s;
      return acc2;
    }
    acc.parser = parser;
    return acc;
  }
  function parseEscapeCharacter(acc, _) {
    let prev = "";
    const parser = function(acc2, s) {
      if (prev) {
        s = characterMap.get(prev + s) || s;
        acc2.parser = void 0;
        return parseCharacter(acc2, s);
      }
      if (s === ESCAPE) {
        prev = s;
        return acc2;
      }
      acc2.parser = void 0;
      return parseCharacter(acc2, s);
    };
    acc.parser = parser;
    return acc;
  }
  function parseCharacter(acc, s) {
    acc.cursor.insertChar(s);
    acc.parser = void 0;
    return acc;
  }
  function parseEOW(acc, _) {
    acc.parser = parseBack;
    acc.cursor.markEOW();
    acc.cursor.backStep(1);
    return acc;
  }
  const charactersBack = stringToCharSet$1(BACK + "23456789");
  function parseBack(acc, s) {
    if (!(s in charactersBack)) {
      acc.parser = void 0;
      return parserMain(acc, s);
    }
    const n = s === BACK ? 1 : Number.parseInt(s, 10) - 1;
    acc.cursor.backStep(n);
    acc.parser = parseBack;
    return acc;
  }
  function parseIgnore(acc, _) {
    return acc;
  }
  const parsers2 = /* @__PURE__ */ new Map([
    [EOW$1, parseEOW],
    [BACK, parseBack],
    [REF, parseReference],
    [ESCAPE, parseEscapeCharacter],
    [EOL, parseIgnore],
    [LF, parseIgnore]
  ]);
  function parserMain(acc, s) {
    var _a19, _b2;
    return ((_b2 = (_a19 = acc.parser) != null ? _a19 : parsers2.get(s)) != null ? _b2 : parseCharacter)(acc, s);
  }
  return parserMain;
}
function stringToCharSet$1(values) {
  const set = /* @__PURE__ */ Object.create(null);
  const len = values.length;
  for (let i = 0; i < len; ++i) set[values[i]] = true;
  return set;
}
function importTrieV3AsTrieBlob(srcLines) {
  return importTrieV3WithBuilder(new TrieBlobBuilder(), srcLines);
}
function decodeTrieData(raw) {
  if (typeof raw === "string") return decodeStringFormat(raw);
  const data = toUint8Array2(raw);
  if (isBTrieData(data)) return decodeBTrie(data);
  return decodeStringFormat(new TextDecoder().decode(data));
}
function decodeStringFormat(data) {
  return importTrie$2(data);
}
var deserializers$1 = [
  (data) => new TrieNodeTrie(importTrie$5(data)),
  (data) => new TrieNodeTrie(importTrie$5(data)),
  (data) => new TrieNodeTrie(importTrie$4(data)),
  (data) => importTrieV3AsTrieBlob(data),
  (data) => new TrieNodeTrie(importTrie$3(data))
];
var headerReg$1 = /^\s*TrieXv(\d+)/m;
function importTrie$2(input) {
  const lines = Array.isArray(input) ? input : typeof input === "string" ? input.split("\n") : [...input];
  function parseHeaderRows(headerRows) {
    for (let i = 0; i < headerRows.length; ++i) {
      const match2 = headerRows[i].match(headerReg$1);
      if (match2) return Number.parseInt(match2[1], 10);
    }
    throw new Error("Unknown file format");
  }
  function readHeader(iter) {
    const headerRows = [];
    for (const entry of iter) {
      const line = entry.trim();
      headerRows.push(line);
      if (line === DATA$4 || line === DATA$3) break;
    }
    return headerRows;
  }
  const version2 = parseHeaderRows(readHeader(lines));
  const method = deserializers$1[version2];
  if (!method) throw new Error(`Unsupported version: ${version2}`);
  return method(lines);
}
function decodeTrie(raw) {
  const endPerf = measurePerf2("decodeTrie");
  const t = new ITrieImpl(decodeTrieData(raw));
  endPerf();
  return t;
}
var specialCharacters = stringToCharSet([
  EOW$1,
  BACK,
  EOL,
  REF,
  EOR,
  ESCAPE,
  LF,
  "0123456789",
  "`~!@#$%^&*()_-+=[]{};:'\"<>,./?\\|"
].join(""));
var specialPrefix = stringToCharSet("~!");
function stringToCharSet(values) {
  const set = /* @__PURE__ */ Object.create(null);
  const len = values.length;
  for (let i = 0; i < len; ++i) set[values[i]] = true;
  return set;
}
var codes = [
  ["af", "Afrikaans"],
  [
    "af-NA",
    "Afrikaans",
    "Namibia"
  ],
  [
    "af-ZA",
    "Afrikaans",
    "South Africa"
  ],
  ["ak", "Akan"],
  [
    "ak-GH",
    "Akan",
    "Ghana"
  ],
  ["am", "Amharic"],
  [
    "am-ET",
    "Amharic",
    "Ethiopia"
  ],
  ["ar", "Arabic"],
  ["ar-1", "Arabic"],
  [
    "ar-AE",
    "Arabic",
    "United Arab Emirates"
  ],
  [
    "ar-BH",
    "Arabic",
    "Bahrain"
  ],
  [
    "ar-DJ",
    "Arabic",
    "Djibouti"
  ],
  [
    "ar-DZ",
    "Arabic",
    "Algeria"
  ],
  [
    "ar-EG",
    "Arabic",
    "Egypt"
  ],
  ["ar-EH", "Arabic"],
  [
    "ar-ER",
    "Arabic",
    "Eritrea"
  ],
  [
    "ar-IL",
    "Arabic",
    "Israel"
  ],
  [
    "ar-IQ",
    "Arabic",
    "Iraq"
  ],
  [
    "ar-JO",
    "Arabic",
    "Jordan"
  ],
  [
    "ar-KM",
    "Arabic",
    "Comoros"
  ],
  [
    "ar-KW",
    "Arabic",
    "Kuwait"
  ],
  [
    "ar-LB",
    "Arabic",
    "Lebanon"
  ],
  [
    "ar-LY",
    "Arabic",
    "Libya"
  ],
  [
    "ar-MA",
    "Arabic",
    "Morocco"
  ],
  [
    "ar-MR",
    "Arabic",
    "Mauritania"
  ],
  [
    "ar-OM",
    "Arabic",
    "Oman"
  ],
  ["ar-PS", "Arabic"],
  [
    "ar-QA",
    "Arabic",
    "Qatar"
  ],
  [
    "ar-SA",
    "Arabic",
    "Saudi Arabia"
  ],
  [
    "ar-SD",
    "Arabic",
    "Sudan"
  ],
  [
    "ar-SO",
    "Arabic",
    "Somalia"
  ],
  ["ar-SS", "Arabic"],
  [
    "ar-SY",
    "Arabic",
    "Syria"
  ],
  [
    "ar-TD",
    "Arabic",
    "Chad"
  ],
  [
    "ar-TN",
    "Arabic",
    "Tunisia"
  ],
  [
    "ar-YE",
    "Arabic",
    "Yemen"
  ],
  ["as", "Assamese"],
  [
    "as-IN",
    "Assamese",
    "India"
  ],
  ["az", "Azerbaijani"],
  [
    "az-AZ",
    "Azerbaijani",
    "Azerbaijan"
  ],
  ["be", "Belarusian"],
  [
    "be-BY",
    "Belarusian",
    "Belarus"
  ],
  ["bg", "Bulgarian"],
  [
    "bg-BG",
    "Bulgarian",
    "Bulgaria"
  ],
  ["bm", "Bambara"],
  [
    "bm-ML",
    "Bambara",
    "Mali"
  ],
  ["bn", "Bengali"],
  [
    "bn-BD",
    "Bengali",
    "Bangladesh"
  ],
  [
    "bn-IN",
    "Bengali",
    "India"
  ],
  ["bo", "Tibetan"],
  [
    "bo-CN",
    "Tibetan",
    "China"
  ],
  [
    "bo-IN",
    "Tibetan",
    "India"
  ],
  ["br", "Breton"],
  [
    "br-FR",
    "Breton",
    "France"
  ],
  ["bs", "Bosnian"],
  [
    "bs-BA",
    "Bosnian",
    "Bosnia and Herzegovina"
  ],
  ["ca", "Catalan"],
  [
    "ca-AD",
    "Catalan",
    "Andorra"
  ],
  [
    "ca-ES",
    "Catalan",
    "Spain"
  ],
  [
    "ca-FR",
    "Catalan",
    "France"
  ],
  [
    "ca-IT",
    "Catalan",
    "Italy"
  ],
  ["ce", "Chechen"],
  [
    "ce-RU",
    "Chechen",
    "Russia"
  ],
  ["cs", "Czech"],
  [
    "cs-CZ",
    "Czech",
    "Czech Republic"
  ],
  ["cu", "Old Slavonic"],
  [
    "cu-RU",
    "Old Slavonic",
    "Russia"
  ],
  ["cy", "Welsh"],
  [
    "cy-GB",
    "Welsh",
    "United Kingdom"
  ],
  ["da", "Danish"],
  [
    "da-DK",
    "Danish",
    "Denmark"
  ],
  [
    "da-GL",
    "Danish",
    "Greenland"
  ],
  ["de", "German"],
  [
    "de-AT",
    "German",
    "Austria"
  ],
  [
    "de-BE",
    "German",
    "Belgium"
  ],
  [
    "de-CH",
    "German",
    "Switzerland"
  ],
  [
    "de-DE",
    "German",
    "Germany"
  ],
  [
    "de-IT",
    "German",
    "Italy"
  ],
  [
    "de-LI",
    "German",
    "Liechtenstein"
  ],
  [
    "de-LU",
    "German",
    "Luxembourg"
  ],
  ["dz", "Dzongkha"],
  [
    "dz-BT",
    "Dzongkha",
    "Bhutan"
  ],
  ["ee", "Ewe"],
  [
    "ee-GH",
    "Ewe",
    "Ghana"
  ],
  [
    "ee-TG",
    "Ewe",
    "Togo"
  ],
  [
    "el",
    "Greek",
    "Modern (1453-)"
  ],
  [
    "el-CY",
    "Greek",
    "Cyprus"
  ],
  [
    "el-GR",
    "Greek",
    "Greece"
  ],
  ["en", "English"],
  [
    "en-AG",
    "English",
    "Antigua and Barbuda"
  ],
  [
    "en-AI",
    "English",
    "Anguilla"
  ],
  [
    "en-AS",
    "English",
    "American Samoa"
  ],
  [
    "en-AT",
    "English",
    "Austria"
  ],
  [
    "en-AU",
    "English",
    "Australia"
  ],
  [
    "en-BB",
    "English",
    "Barbados"
  ],
  [
    "en-BE",
    "English",
    "Belgium"
  ],
  [
    "en-BI",
    "English",
    "Burundi"
  ],
  [
    "en-BM",
    "English",
    "Bermuda"
  ],
  [
    "en-BS",
    "English",
    "Bahamas"
  ],
  [
    "en-BW",
    "English",
    "Botswana"
  ],
  [
    "en-BZ",
    "English",
    "Belize"
  ],
  [
    "en-CA",
    "English",
    "Canada"
  ],
  [
    "en-CC",
    "English",
    "Cocos (Keeling) Islands"
  ],
  [
    "en-CH",
    "English",
    "Switzerland"
  ],
  [
    "en-CK",
    "English",
    "Cook Islands"
  ],
  [
    "en-CM",
    "English",
    "Cameroon"
  ],
  [
    "en-CX",
    "English",
    "Christmas Island"
  ],
  [
    "en-CY",
    "English",
    "Cyprus"
  ],
  [
    "en-DE",
    "English",
    "Germany"
  ],
  ["en-DG", "English"],
  [
    "en-DK",
    "English",
    "Denmark"
  ],
  [
    "en-DM",
    "English",
    "Dominica"
  ],
  [
    "en-ER",
    "English",
    "Eritrea"
  ],
  [
    "en-FI",
    "English",
    "Finland"
  ],
  [
    "en-FJ",
    "English",
    "Fiji"
  ],
  [
    "en-FK",
    "English",
    "Falkland Islands (Islas Malvinas)"
  ],
  [
    "en-FM",
    "English",
    "Micronesia"
  ],
  [
    "en-GB",
    "English",
    "United Kingdom"
  ],
  [
    "en-GD",
    "English",
    "Grenada"
  ],
  [
    "en-GG",
    "English",
    "Guernsey"
  ],
  [
    "en-GH",
    "English",
    "Ghana"
  ],
  [
    "en-GI",
    "English",
    "Gibraltar"
  ],
  [
    "en-GM",
    "English",
    "Gambia"
  ],
  [
    "en-GU",
    "English",
    "Guam"
  ],
  [
    "en-GY",
    "English",
    "Guyana"
  ],
  [
    "en-HK",
    "English",
    "Hong Kong"
  ],
  [
    "en-IE",
    "English",
    "Ireland"
  ],
  [
    "en-IL",
    "English",
    "Israel"
  ],
  [
    "en-IM",
    "English",
    "Isle of Man"
  ],
  [
    "en-IN",
    "English",
    "India"
  ],
  [
    "en-IO",
    "English",
    "British Indian Ocean Territory"
  ],
  [
    "en-JE",
    "English",
    "Jersey"
  ],
  [
    "en-JM",
    "English",
    "Jamaica"
  ],
  [
    "en-KE",
    "English",
    "Kenya"
  ],
  [
    "en-KI",
    "English",
    "Kiribati"
  ],
  [
    "en-KN",
    "English",
    "Saint Kitts and Nevis"
  ],
  [
    "en-KY",
    "English",
    "Cayman Islands"
  ],
  [
    "en-LC",
    "English",
    "Saint Lucia"
  ],
  [
    "en-LR",
    "English",
    "Liberia"
  ],
  [
    "en-LS",
    "English",
    "Lesotho"
  ],
  [
    "en-MG",
    "English",
    "Madagascar"
  ],
  [
    "en-MH",
    "English",
    "Marshall Islands"
  ],
  [
    "en-MO",
    "English",
    "Macau"
  ],
  [
    "en-MP",
    "English",
    "Northern Mariana Islands"
  ],
  [
    "en-MS",
    "English",
    "Montserrat"
  ],
  [
    "en-MT",
    "English",
    "Malta"
  ],
  [
    "en-MU",
    "English",
    "Mauritius"
  ],
  [
    "en-MW",
    "English",
    "Malawi"
  ],
  [
    "en-MY",
    "English",
    "Malaysia"
  ],
  [
    "en-NA",
    "English",
    "Namibia"
  ],
  [
    "en-NF",
    "English",
    "Norfolk Island"
  ],
  [
    "en-NG",
    "English",
    "Nigeria"
  ],
  [
    "en-NL",
    "English",
    "Netherlands"
  ],
  [
    "en-NR",
    "English",
    "Nauru"
  ],
  [
    "en-NU",
    "English",
    "Niue"
  ],
  [
    "en-NZ",
    "English",
    "New Zealand"
  ],
  [
    "en-PG",
    "English",
    "Papua New Guinea"
  ],
  [
    "en-PH",
    "English",
    "Philippines"
  ],
  [
    "en-PK",
    "English",
    "Pakistan"
  ],
  [
    "en-PN",
    "English",
    "Pitcairn Islands"
  ],
  [
    "en-PR",
    "English",
    "Puerto Rico"
  ],
  [
    "en-PW",
    "English",
    "Palau"
  ],
  [
    "en-RW",
    "English",
    "Rwanda"
  ],
  [
    "en-SB",
    "English",
    "Solomon Islands"
  ],
  [
    "en-SC",
    "English",
    "Seychelles"
  ],
  [
    "en-SD",
    "English",
    "Sudan"
  ],
  [
    "en-SE",
    "English",
    "Sweden"
  ],
  [
    "en-SG",
    "English",
    "Singapore"
  ],
  [
    "en-SH",
    "English",
    "Saint Helena"
  ],
  [
    "en-SI",
    "English",
    "Slovenia"
  ],
  [
    "en-SL",
    "English",
    "Sierra Leone"
  ],
  ["en-SS", "English"],
  ["en-SX", "English"],
  [
    "en-SZ",
    "English",
    "Swaziland"
  ],
  [
    "en-TC",
    "English",
    "Turks and Caicos Islands"
  ],
  [
    "en-TK",
    "English",
    "Tokelau"
  ],
  [
    "en-TO",
    "English",
    "Tonga"
  ],
  [
    "en-TT",
    "English",
    "Trinidad and Tobago"
  ],
  [
    "en-TV",
    "English",
    "Tuvalu"
  ],
  [
    "en-TZ",
    "English",
    "Tanzania"
  ],
  [
    "en-UG",
    "English",
    "Uganda"
  ],
  [
    "en-UM",
    "English",
    "Baker Island"
  ],
  [
    "en-US",
    "English",
    "United States"
  ],
  [
    "en-VC",
    "English",
    "Saint Vincent and the Grenadines"
  ],
  [
    "en-VG",
    "English",
    "British Virgin Islands"
  ],
  [
    "en-VI",
    "English",
    "U.S. Virgin Islands"
  ],
  [
    "en-VU",
    "English",
    "Vanuatu"
  ],
  [
    "en-WS",
    "English",
    "Samoa"
  ],
  [
    "en-ZA",
    "English",
    "South Africa"
  ],
  [
    "en-ZM",
    "English",
    "Zambia"
  ],
  [
    "en-ZW",
    "English",
    "Zimbabwe"
  ],
  ["eo", "Esperanto"],
  ["es", "Spanish"],
  [
    "es-AR",
    "Spanish",
    "Argentina"
  ],
  [
    "es-BO",
    "Spanish",
    "Bolivia"
  ],
  [
    "es-BR",
    "Spanish",
    "Brazil"
  ],
  [
    "es-BZ",
    "Spanish",
    "Belize"
  ],
  [
    "es-CL",
    "Spanish",
    "Chile"
  ],
  [
    "es-CO",
    "Spanish",
    "Colombia"
  ],
  [
    "es-CR",
    "Spanish",
    "Costa Rica"
  ],
  [
    "es-CU",
    "Spanish",
    "Cuba"
  ],
  [
    "es-DO",
    "Spanish",
    "Dominican Republic"
  ],
  ["es-EA", "Spanish"],
  [
    "es-EC",
    "Spanish",
    "Ecuador"
  ],
  [
    "es-ES",
    "Spanish",
    "Spain"
  ],
  [
    "es-GQ",
    "Spanish",
    "Equatorial Guinea"
  ],
  [
    "es-GT",
    "Spanish",
    "Guatemala"
  ],
  [
    "es-HN",
    "Spanish",
    "Honduras"
  ],
  ["es-IC", "Spanish"],
  [
    "es-MX",
    "Spanish",
    "Mexico"
  ],
  [
    "es-NI",
    "Spanish",
    "Nicaragua"
  ],
  [
    "es-PA",
    "Spanish",
    "Panama"
  ],
  [
    "es-PE",
    "Spanish",
    "Peru"
  ],
  [
    "es-PH",
    "Spanish",
    "Philippines"
  ],
  [
    "es-PR",
    "Spanish",
    "Puerto Rico"
  ],
  [
    "es-PY",
    "Spanish",
    "Paraguay"
  ],
  [
    "es-SV",
    "Spanish",
    "El Salvador"
  ],
  [
    "es-US",
    "Spanish",
    "United States"
  ],
  [
    "es-UY",
    "Spanish",
    "Uruguay"
  ],
  [
    "es-VE",
    "Spanish",
    "Venezuela"
  ],
  ["et", "Estonian"],
  [
    "et-EE",
    "Estonian",
    "Estonia"
  ],
  ["eu", "Basque"],
  [
    "eu-ES",
    "Basque",
    "Spain"
  ],
  ["fa", "Persian"],
  [
    "fa-AF",
    "Persian",
    "Afghanistan"
  ],
  [
    "fa-IR",
    "Persian",
    "Iran"
  ],
  ["ff", "Fulah"],
  [
    "ff-CM",
    "Fulah",
    "Cameroon"
  ],
  [
    "ff-GN",
    "Fulah",
    "Guinea"
  ],
  [
    "ff-MR",
    "Fulah",
    "Mauritania"
  ],
  [
    "ff-SN",
    "Fulah",
    "Senegal"
  ],
  ["fi", "Finnish"],
  [
    "fi-FI",
    "Finnish",
    "Finland"
  ],
  ["fo", "Faroese"],
  [
    "fo-DK",
    "Faroese",
    "Denmark"
  ],
  [
    "fo-FO",
    "Faroese",
    "Faroe Islands"
  ],
  ["fr", "French"],
  [
    "fr-BE",
    "French",
    "Belgium"
  ],
  [
    "fr-BF",
    "French",
    "Burkina Faso"
  ],
  [
    "fr-BI",
    "French",
    "Burundi"
  ],
  [
    "fr-BJ",
    "French",
    "Benin"
  ],
  ["fr-BL", "French"],
  [
    "fr-CA",
    "French",
    "Canada"
  ],
  [
    "fr-CD",
    "French",
    "Congo"
  ],
  [
    "fr-CF",
    "French",
    "Central African Republic"
  ],
  [
    "fr-CG",
    "French",
    "Congo"
  ],
  [
    "fr-CH",
    "French",
    "Switzerland"
  ],
  ["fr-CI", "French, Cote d'Ivoire (Ivory Coast)"],
  [
    "fr-CM",
    "French",
    "Cameroon"
  ],
  [
    "fr-DJ",
    "French",
    "Djibouti"
  ],
  [
    "fr-DZ",
    "French",
    "Algeria"
  ],
  [
    "fr-FR",
    "French",
    "France"
  ],
  [
    "fr-GA",
    "French",
    "Gabon"
  ],
  [
    "fr-GF",
    "French",
    "French Guiana"
  ],
  [
    "fr-GN",
    "French",
    "Guinea"
  ],
  [
    "fr-GP",
    "French",
    "Saint Barthelemy"
  ],
  [
    "fr-GQ",
    "French",
    "Equatorial Guinea"
  ],
  [
    "fr-HT",
    "French",
    "Haiti"
  ],
  [
    "fr-KM",
    "French",
    "Comoros"
  ],
  [
    "fr-LU",
    "French",
    "Luxembourg"
  ],
  [
    "fr-MA",
    "French",
    "Morocco"
  ],
  [
    "fr-MC",
    "French",
    "Monaco"
  ],
  ["fr-MF", "French"],
  [
    "fr-MG",
    "French",
    "Madagascar"
  ],
  [
    "fr-ML",
    "French",
    "Mali"
  ],
  [
    "fr-MQ",
    "French",
    "Martinique"
  ],
  [
    "fr-MR",
    "French",
    "Mauritania"
  ],
  [
    "fr-MU",
    "French",
    "Mauritius"
  ],
  [
    "fr-NC",
    "French",
    "New Caledonia"
  ],
  [
    "fr-NE",
    "French",
    "Niger"
  ],
  [
    "fr-PF",
    "French",
    "French Polynesia"
  ],
  [
    "fr-PM",
    "French",
    "Saint Pierre and Miquelon"
  ],
  [
    "fr-RE",
    "French",
    "Reunion"
  ],
  [
    "fr-RW",
    "French",
    "Rwanda"
  ],
  [
    "fr-SC",
    "French",
    "Seychelles"
  ],
  [
    "fr-SN",
    "French",
    "Senegal"
  ],
  [
    "fr-SY",
    "French",
    "Syria"
  ],
  [
    "fr-TD",
    "French",
    "Chad"
  ],
  [
    "fr-TG",
    "French",
    "Togo"
  ],
  [
    "fr-TN",
    "French",
    "Tunisia"
  ],
  [
    "fr-VU",
    "French",
    "Vanuatu"
  ],
  [
    "fr-WF",
    "French",
    "Wallis and Futuna"
  ],
  [
    "fr-YT",
    "French",
    "Mayotte"
  ],
  ["fy", "Western Frisian"],
  [
    "fy-NL",
    "Western Frisian",
    "Netherlands"
  ],
  ["ga", "Irish"],
  [
    "ga-IE",
    "Irish",
    "Ireland"
  ],
  ["gd", "Gaelic"],
  [
    "gd-GB",
    "Gaelic",
    "United Kingdom"
  ],
  ["gl", "Galician"],
  [
    "gl-ES",
    "Galician",
    "Spain"
  ],
  ["gu", "Gujarati"],
  [
    "gu-IN",
    "Gujarati",
    "India"
  ],
  ["gv", "Manx"],
  [
    "gv-IM",
    "Manx",
    "Isle of Man"
  ],
  ["ha", "Hausa"],
  [
    "ha-GH",
    "Hausa",
    "Ghana"
  ],
  [
    "ha-NE",
    "Hausa",
    "Niger"
  ],
  [
    "ha-NG",
    "Hausa",
    "Nigeria"
  ],
  ["he", "Hebrew"],
  [
    "he-IL",
    "Hebrew",
    "Israel"
  ],
  ["hi", "Hindi"],
  [
    "hi-IN",
    "Hindi",
    "India"
  ],
  ["hr", "Croatian"],
  [
    "hr-BA",
    "Croatian",
    "Bosnia and Herzegovina"
  ],
  [
    "hr-HR",
    "Croatian",
    "Croatia"
  ],
  ["hu", "Hungarian"],
  [
    "hu-HU",
    "Hungarian",
    "Hungary"
  ],
  ["hy", "Armenian"],
  [
    "hy-AM",
    "Armenian",
    "Armenia"
  ],
  ["id", "Indonesian"],
  [
    "id-ID",
    "Indonesian",
    "Indonesia"
  ],
  ["ig", "Igbo"],
  [
    "ig-NG",
    "Igbo",
    "Nigeria"
  ],
  ["ii", "Sichuan Yi"],
  [
    "ii-CN",
    "Sichuan Yi",
    "China"
  ],
  ["is", "Icelandic"],
  [
    "is-IS",
    "Icelandic",
    "Iceland"
  ],
  ["it", "Italian"],
  [
    "it-CH",
    "Italian",
    "Switzerland"
  ],
  [
    "it-IT",
    "Italian",
    "Italy"
  ],
  [
    "it-SM",
    "Italian",
    "San Marino"
  ],
  [
    "it-VA",
    "Italian",
    "Vatican City"
  ],
  ["ja", "Japanese"],
  [
    "ja-JP",
    "Japanese",
    "Japan"
  ],
  ["ka", "Georgian"],
  [
    "ka-GE",
    "Georgian",
    "Georgia"
  ],
  ["ki", "Kikuyu"],
  [
    "ki-KE",
    "Kikuyu",
    "Kenya"
  ],
  ["kk", "Kazakh"],
  [
    "kk-KZ",
    "Kazakh",
    "Kazakhstan"
  ],
  ["kl", "Kalaallisut"],
  [
    "kl-GL",
    "Kalaallisut",
    "Greenland"
  ],
  ["km", "Central Khmer"],
  [
    "km-KH",
    "Central Khmer",
    "Cambodia"
  ],
  ["kn", "Kannada"],
  [
    "kn-IN",
    "Kannada",
    "India"
  ],
  ["ko", "Korean"],
  [
    "ko-KP",
    "Korean",
    "Korea"
  ],
  [
    "ko-KR",
    "Korean",
    "Korea"
  ],
  ["ks", "Kashmiri"],
  [
    "ks-IN",
    "Kashmiri",
    "India"
  ],
  ["kw", "Cornish"],
  [
    "kw-GB",
    "Cornish",
    "United Kingdom"
  ],
  ["ky", "Kirghiz"],
  [
    "ky-KG",
    "Kirghiz",
    "Kyrgyzstan"
  ],
  ["lb", "Luxembourgish"],
  [
    "lb-LU",
    "Luxembourgish",
    "Luxembourg"
  ],
  ["lg", "Ganda"],
  [
    "lg-UG",
    "Ganda",
    "Uganda"
  ],
  ["ln", "Lingala"],
  [
    "ln-AO",
    "Lingala",
    "Angola"
  ],
  [
    "ln-CD",
    "Lingala",
    "Congo"
  ],
  [
    "ln-CF",
    "Lingala",
    "Central African Republic"
  ],
  [
    "ln-CG",
    "Lingala",
    "Congo"
  ],
  ["lo", "Lao"],
  [
    "lo-LA",
    "Lao",
    "Laos"
  ],
  ["lt", "Lithuanian"],
  [
    "lt-LT",
    "Lithuanian",
    "Lithuania"
  ],
  ["lu", "Luba-Katanga"],
  [
    "lu-CD",
    "Luba-Katanga",
    "Congo"
  ],
  ["lv", "Latvian"],
  [
    "lv-LV",
    "Latvian",
    "Latvia"
  ],
  ["mg", "Malagasy"],
  [
    "mg-MG",
    "Malagasy",
    "Madagascar"
  ],
  ["mk", "Macedonian"],
  [
    "mk-MK",
    "Macedonian",
    "Macedonia"
  ],
  ["ml", "Malayalam"],
  [
    "ml-IN",
    "Malayalam",
    "India"
  ],
  ["mn", "Mongolian"],
  [
    "mn-MN",
    "Mongolian",
    "Mongolia"
  ],
  ["mr", "Marathi"],
  [
    "mr-IN",
    "Marathi",
    "India"
  ],
  ["ms", "Malay"],
  [
    "ms-BN",
    "Malay",
    "Brunei"
  ],
  [
    "ms-MY",
    "Malay",
    "Malaysia"
  ],
  [
    "ms-SG",
    "Malay",
    "Singapore"
  ],
  ["mt", "Maltese"],
  [
    "mt-MT",
    "Maltese",
    "Malta"
  ],
  ["my", "Burmese"],
  [
    "my-MM",
    "Burmese",
    "Myanmar (Burma)"
  ],
  ["nb", "Bokm\xE5l Norwegian"],
  [
    "nb-NO",
    "Bokm\xE5l Norwegian",
    "Norway"
  ],
  [
    "nb-SJ",
    "Bokm\xE5l Norwegian",
    "Svalbard"
  ],
  ["nd", "Ndebele, North"],
  [
    "nd-ZW",
    "Ndebele, North",
    "Zimbabwe"
  ],
  ["ne", "Nepali"],
  [
    "ne-IN",
    "Nepali",
    "India"
  ],
  [
    "ne-NP",
    "Nepali",
    "Nepal"
  ],
  ["nl", "Dutch"],
  [
    "nl-AW",
    "Dutch",
    "Aruba"
  ],
  [
    "nl-BE",
    "Dutch",
    "Belgium"
  ],
  ["nl-BQ", "Dutch"],
  ["nl-CW", "Dutch"],
  [
    "nl-NL",
    "Dutch",
    "Netherlands"
  ],
  [
    "nl-SR",
    "Dutch",
    "Suriname"
  ],
  ["nl-SX", "Dutch"],
  ["nn", "Norwegian Nynorsk"],
  [
    "nn-NO",
    "Norwegian Nynorsk",
    "Norway"
  ],
  ["om", "Oromo"],
  [
    "om-ET",
    "Oromo",
    "Ethiopia"
  ],
  [
    "om-KE",
    "Oromo",
    "Kenya"
  ],
  ["or", "Oriya"],
  [
    "or-IN",
    "Oriya",
    "India"
  ],
  ["os", "Ossetian"],
  [
    "os-GE",
    "Ossetian",
    "Georgia"
  ],
  [
    "os-RU",
    "Ossetian",
    "Russia"
  ],
  ["pa", "Panjabi"],
  [
    "pa-IN",
    "Panjabi",
    "India"
  ],
  [
    "pa-PK",
    "Panjabi",
    "Pakistan"
  ],
  ["pl", "Polish"],
  [
    "pl-PL",
    "Polish",
    "Poland"
  ],
  ["ps", "Pushto"],
  [
    "ps-AF",
    "Pushto",
    "Afghanistan"
  ],
  ["pt", "Portuguese"],
  [
    "pt-AO",
    "Portuguese",
    "Angola"
  ],
  [
    "pt-BR",
    "Portuguese",
    "Brazil"
  ],
  [
    "pt-CH",
    "Portuguese",
    "Switzerland"
  ],
  [
    "pt-CV",
    "Portuguese",
    "Cape Verde"
  ],
  [
    "pt-GQ",
    "Portuguese",
    "Equatorial Guinea"
  ],
  [
    "pt-GW",
    "Portuguese",
    "Guinea-Bissau"
  ],
  [
    "pt-LU",
    "Portuguese",
    "Luxembourg"
  ],
  [
    "pt-MO",
    "Portuguese",
    "Macau"
  ],
  [
    "pt-MZ",
    "Portuguese",
    "Mozambique"
  ],
  [
    "pt-PT",
    "Portuguese",
    "Portugal"
  ],
  [
    "pt-ST",
    "Portuguese",
    "Sao Tome and Principe"
  ],
  [
    "pt-TL",
    "Portuguese",
    "Timor-Leste (East Timor)"
  ],
  ["qu", "Quechua"],
  [
    "qu-BO",
    "Quechua",
    "Bolivia"
  ],
  [
    "qu-EC",
    "Quechua",
    "Ecuador"
  ],
  [
    "qu-PE",
    "Quechua",
    "Peru"
  ],
  ["rm", "Romansh"],
  [
    "rm-CH",
    "Romansh",
    "Switzerland"
  ],
  ["rn", "Rundi"],
  [
    "rn-BI",
    "Rundi",
    "Burundi"
  ],
  ["ro", "Romanian"],
  [
    "ro-MD",
    "Romanian",
    "Moldova"
  ],
  [
    "ro-RO",
    "Romanian",
    "Romania"
  ],
  ["ru", "Russian"],
  [
    "ru-BY",
    "Russian",
    "Belarus"
  ],
  [
    "ru-KG",
    "Russian",
    "Kyrgyzstan"
  ],
  [
    "ru-KZ",
    "Russian",
    "Kazakhstan"
  ],
  [
    "ru-MD",
    "Russian",
    "Moldova"
  ],
  [
    "ru-RU",
    "Russian",
    "Russia"
  ],
  [
    "ru-UA",
    "Russian",
    "Ukraine"
  ],
  ["rw", "Kinyarwanda"],
  [
    "rw-RW",
    "Kinyarwanda",
    "Rwanda"
  ],
  ["se", "Northern Sami"],
  [
    "se-FI",
    "Northern Sami",
    "Finland"
  ],
  [
    "se-NO",
    "Northern Sami",
    "Norway"
  ],
  [
    "se-SE",
    "Northern Sami",
    "Sweden"
  ],
  ["sg", "Sango"],
  [
    "sg-CF",
    "Sango",
    "Central African Republic"
  ],
  ["si", "Sinhala"],
  [
    "si-LK",
    "Sinhala",
    "Sri Lanka"
  ],
  ["sk", "Slovak"],
  [
    "sk-SK",
    "Slovak",
    "Slovakia"
  ],
  ["sl", "Slovenian"],
  [
    "sl-SI",
    "Slovenian",
    "Slovenia"
  ],
  ["sn", "Shona"],
  [
    "sn-ZW",
    "Shona",
    "Zimbabwe"
  ],
  ["so", "Somali"],
  [
    "so-DJ",
    "Somali",
    "Djibouti"
  ],
  [
    "so-ET",
    "Somali",
    "Ethiopia"
  ],
  [
    "so-KE",
    "Somali",
    "Kenya"
  ],
  [
    "so-SO",
    "Somali",
    "Somalia"
  ],
  ["sq", "Albanian"],
  [
    "sq-AL",
    "Albanian",
    "Albania"
  ],
  [
    "sq-MK",
    "Albanian",
    "Macedonia"
  ],
  ["sq-XK", "Albanian"],
  ["sr", "Serbian"],
  [
    "sr-BA",
    "Serbian",
    "Bosnia and Herzegovina"
  ],
  [
    "sr-ME",
    "Serbian",
    "Montenegro"
  ],
  [
    "sr-RS",
    "Serbian",
    "Serbia"
  ],
  ["sr-XK", "Serbian"],
  ["sv", "Swedish"],
  [
    "sv-AX",
    "Swedish",
    "Aland"
  ],
  [
    "sv-FI",
    "Swedish",
    "Finland"
  ],
  [
    "sv-SE",
    "Swedish",
    "Sweden"
  ],
  ["sw", "Swahili"],
  [
    "sw-CD",
    "Swahili",
    "Congo"
  ],
  [
    "sw-KE",
    "Swahili",
    "Kenya"
  ],
  [
    "sw-TZ",
    "Swahili",
    "Tanzania"
  ],
  [
    "sw-UG",
    "Swahili",
    "Uganda"
  ],
  ["ta", "Tamil"],
  [
    "ta-IN",
    "Tamil",
    "India"
  ],
  [
    "ta-LK",
    "Tamil",
    "Sri Lanka"
  ],
  [
    "ta-MY",
    "Tamil",
    "Malaysia"
  ],
  [
    "ta-SG",
    "Tamil",
    "Singapore"
  ],
  ["te", "Telugu"],
  [
    "te-IN",
    "Telugu",
    "India"
  ],
  ["th", "Thai"],
  [
    "th-TH",
    "Thai",
    "Thailand"
  ],
  ["ti", "Tigrinya"],
  [
    "ti-ER",
    "Tigrinya",
    "Eritrea"
  ],
  [
    "ti-ET",
    "Tigrinya",
    "Ethiopia"
  ],
  ["tk", "Turkmen"],
  [
    "tk-TM",
    "Turkmen",
    "Turkmenistan"
  ],
  ["to", "Tonga (Tonga Islands)"],
  [
    "to-TO",
    "Tonga (Tonga Islands)",
    "Tonga"
  ],
  ["tr", "Turkish"],
  [
    "tr-CY",
    "Turkish",
    "Cyprus"
  ],
  [
    "tr-TR",
    "Turkish",
    "Turkey"
  ],
  ["ug", "Uighur"],
  [
    "ug-CN",
    "Uighur",
    "China"
  ],
  ["uk", "Ukrainian"],
  [
    "uk-UA",
    "Ukrainian",
    "Ukraine"
  ],
  ["ur", "Urdu"],
  [
    "ur-IN",
    "Urdu",
    "India"
  ],
  [
    "ur-PK",
    "Urdu",
    "Pakistan"
  ],
  ["uz", "Uzbek"],
  [
    "uz-AF",
    "Uzbek",
    "Afghanistan"
  ],
  [
    "uz-UZ",
    "Uzbek",
    "Uzbekistan"
  ],
  ["vi", "Vietnamese"],
  [
    "vi-VN",
    "Vietnamese",
    "Vietnam"
  ],
  ["vo", "Volap\xFCk"],
  ["yi", "Yiddish"],
  ["yi-1", "Yiddish"],
  ["yo", "Yoruba"],
  [
    "yo-BJ",
    "Yoruba",
    "Benin"
  ],
  [
    "yo-NG",
    "Yoruba",
    "Nigeria"
  ],
  ["zh", "Chinese"],
  [
    "zh-CN",
    "Chinese",
    "China"
  ],
  [
    "zh-HK",
    "Chinese",
    "Hong Kong"
  ],
  [
    "zh-MO",
    "Chinese",
    "Macau"
  ],
  [
    "zh-SG",
    "Chinese",
    "Singapore"
  ],
  [
    "zh-TW",
    "Chinese",
    "China"
  ],
  ["zu", "Zulu"],
  [
    "zu-ZA",
    "Zulu",
    "South Africa"
  ]
];
var codesByLocale;
var Locale = class {
  constructor(locale) {
    __publicField(this, "_raw");
    __publicField(this, "_locale");
    this._raw = locale;
    this._locale = normalizeLocale(locale);
  }
  get locale() {
    return this._locale;
  }
  localInfo() {
    return lookupLocaleInfo(this._locale);
  }
  isValid() {
    return isStandardLocale(this._locale);
  }
  toJSON() {
    return this.locale;
  }
  toString() {
    return this.locale;
  }
};
var regExTwoLetter = /^[a-z]{2}$/i;
var regExLocaleWithCountry = /^([a-z]{2})[_-]?([a-z]{2,3})$/i;
var regExValidLocale = /^([a-z]{2})(?:-([A-Z]{2,3}))?$/;
function normalizeLocale(locale) {
  locale = locale.trim();
  if (regExTwoLetter.test(locale)) return locale.toLowerCase();
  const m = locale.match(regExLocaleWithCountry);
  if (!m) return locale;
  return `${m[1].toLowerCase()}-${m[2].toUpperCase()}`;
}
function isStandardLocale(locale) {
  return regExValidLocale.test(locale);
}
function lookupLocaleInfo(locale) {
  codesByLocale = codesByLocale || buildLocaleLookup();
  return codesByLocale.get(locale);
}
function buildLocaleLookup() {
  const info = codes.map(([locale, language, country]) => ({
    locale,
    language,
    country
  }));
  return new Map(info.map((i) => [i.locale, i]));
}
function createLocale(locale) {
  return new Locale(locale);
}
function parseLocale(locales) {
  locales = typeof locales === "string" ? locales.split(",") : locales;
  return locales.map(createLocale);
}
var defaultEditCosts = {
  accentCosts: 1,
  baseCost: 100,
  capsCosts: 1,
  firstLetterPenalty: 4,
  nonAlphabetCosts: 110
};
var defaultHunspellCosts = {
  ...defaultEditCosts,
  ioConvertCost: 30,
  keyboardCost: 99,
  mapCost: 25,
  replaceCosts: 75,
  tryCharCost: 100
};
function mapHunspellCosts(costs = {}) {
  return {
    ...defaultHunspellCosts,
    ...cleanCopy(costs)
  };
}
function mapEditCosts(costs = {}) {
  return {
    ...defaultEditCosts,
    ...cleanCopy(costs)
  };
}
function joinLetters(letters) {
  return [...letters].map((a) => a.length > 1 || !a.length ? `(${a})` : a).join("");
}
function parseAlphabet(cs, locale, editCost) {
  const { cost, penalty } = cs;
  const alphabet = joinLetters([...pipeSync([...pipeSync(expandCharacterSet(cs.characters), opMapSync((c) => caseForms(c, locale).sort()))], opFlattenSync(), opMapSync((letter) => accentForms(letter)), opFlattenSync(), opUniqueSync())].sort());
  return [
    clean$1({
      map: alphabet,
      replace: cost,
      insDel: cost,
      swap: cost,
      penalty
    }),
    parseAlphabetCaps(cs.characters, locale, editCost),
    ...calcCostsForAccentedLetters(alphabet, locale, editCost)
  ];
}
function parseAlphabetCaps(alphabet, locale, editCost) {
  return {
    map: [...pipeSync(expandCharacterSet(alphabet), opMapSync((c) => caseForms(c, locale).sort()))].map((a) => joinLetters(a)).join("|"),
    replace: editCost.capsCosts
  };
}
function calcFirstCharacterReplaceDefs(alphabets, editCost) {
  return alphabets.map((cs) => calcFirstCharacterReplace(cs, editCost));
}
function calcFirstCharacterReplace(cs, editCost) {
  const mapOfFirstLetters = [...pipeSync(expandCharacterSet(cs.characters), opUniqueSync(), opMapSync((letter) => `(^${letter})`))].sort().join("") + "(^)";
  const penalty = editCost.firstLetterPenalty;
  return {
    map: mapOfFirstLetters,
    replace: cs.cost - penalty,
    penalty: penalty * 2
  };
}
function parseAccents(cs, _editCost) {
  const { cost, penalty } = cs;
  const accents = joinLetters([...pipeSync(expandCharacterSet(cs.characters), opMapSync((char) => stripNonAccents(char)))]);
  if (!accents) return void 0;
  return clean$1({
    map: accents,
    replace: cost,
    insDel: cost,
    penalty
  });
}
function calcCostsForAccentedLetters(simpleMap, locale, costs) {
  const charactersWithAccents = [...pipeSync(splitMap(simpleMap), opMapSync((char) => caseForms(char, locale)), opFlattenSync(), opMapSync((char) => [...accentForms(char)]), opFilterSync((forms2) => forms2.length > 1))];
  const replaceAccentMap = [...pipeSync(charactersWithAccents, opMapSync((forms2) => /* @__PURE__ */ new Set([...forms2, ...forms2.map((char) => stripAccents(char))])), opMapSync((forms2) => [...forms2].sort()), opFilterSync((forms2) => forms2.length > 1), opMapSync(joinLetters), opUniqueSync())].join("|");
  const cost = costs.accentCosts;
  const costToReplaceAccent = !replaceAccentMap ? [] : [{
    map: replaceAccentMap,
    replace: cost
  }];
  const normalizeMap2 = charactersWithAccents.map((a) => a.sort()).map(joinLetters).join("|");
  const costToNormalizeAccent = !normalizeMap2 ? [] : [{
    map: normalizeMap2,
    replace: 0
  }];
  return [...costToReplaceAccent, ...costToNormalizeAccent];
}
function* splitMap(map2) {
  let seq = "";
  let mode = 0;
  for (const char of map2) {
    if (mode && char === ")") {
      yield seq;
      mode = 0;
      continue;
    }
    if (mode) {
      seq += char;
      continue;
    }
    if (char === "(") {
      mode = 1;
      seq = "";
      continue;
    }
    yield char;
  }
}
function hunspellInformationToSuggestionCostDef(hunInfo, locales) {
  const costs = calcCosts(hunInfo.costs, locales);
  const operations = [
    affKey,
    affKeyCaps,
    affMap,
    affMapAccents,
    affMapCaps,
    affNoTry,
    affRepConv,
    affTry,
    affTryAccents,
    affTryFirstCharacterReplace
  ];
  function parseAff(aff, costs2) {
    const regSupportedAff = /^(?:MAP|KEY|TRY|NO-TRY|ICONV|OCONV|REP)\s/;
    const rejectAff = /^(?:MAP|KEY|TRY|ICONV|OCONV|REP)\s+\d+$/;
    return [...pipeSync(aff.split("\n").map((a) => a.replace(/#.*/, "")).map((a) => a.trim()).filter((a) => regSupportedAff.test(a)).filter((a) => !rejectAff.test(a)), opMapSync((line) => pipeSync(operations, opMapSync((fn) => fn(line, costs2)), opMapSync(asArrayOf), opFlattenSync())), opFlattenSync(), opFilterSync(isDefined$1))];
  }
  return parseAff(hunInfo.aff, costs);
}
function calcCosts(costs = {}, locale) {
  const useLocale = (locale == null ? void 0 : locale.length) ? locale.map((loc) => loc.locale) : void 0;
  return {
    ...mapHunspellCosts(costs),
    locale: useLocale
  };
}
var regExpMap = /^(?:MAP)\s+(\S+)$/;
function affMap(line, costs) {
  const m = line.match(regExpMap);
  if (!m) return void 0;
  const map2 = m[1];
  const cost = costs.mapCost;
  return {
    map: map2,
    replace: cost,
    swap: cost
  };
}
var regExpTry = /^(?:TRY)\s+(\S+)$/;
function affTry(line, costs) {
  const m = line.match(regExpTry);
  if (!m) return void 0;
  const cost = costs.tryCharCost;
  const characters = m[1];
  return parseAlphabet({
    characters,
    cost
  }, costs.locale, costs);
}
function affTryFirstCharacterReplace(line, costs) {
  const m = line.match(regExpTry);
  if (!m) return void 0;
  const characters = m[1];
  const cost = costs.tryCharCost;
  return calcFirstCharacterReplace({
    characters,
    cost
  }, costs);
}
var regExpNoTry = /^NO-TRY\s+(\S+)$/;
function affNoTry(line, costs) {
  const m = line.match(regExpNoTry);
  if (!m) return void 0;
  return {
    map: m[1],
    insDel: Math.max(costs.nonAlphabetCosts - costs.tryCharCost, 0),
    penalty: costs.nonAlphabetCosts + costs.tryCharCost
  };
}
var regExpRepConv = /^(?:REP|(?:I|O)CONV)\s+(\S+)\s+(\S+)$/;
function affRepConv(line, costs) {
  const m = line.match(regExpRepConv);
  if (!m) return void 0;
  const cost = line.startsWith("REP") ? costs.replaceCosts : costs.ioConvertCost;
  const from = m[1];
  let into = m[2];
  into = into.replace(/^0$/, "");
  if (from.startsWith("^") && !into.startsWith("^")) into = "^" + into;
  if (from.endsWith("$") && !into.endsWith("$")) into = into + "$";
  return {
    map: joinLetters([from, into]),
    replace: cost
  };
}
var regExpKey = /^(?:KEY)\s+(\S+)$/;
function affKey(line, costs) {
  const m = line.match(regExpKey);
  if (!m) return void 0;
  const kbd = m[1];
  const pairs = [...splitMap(kbd)].map(reducer((p, v) => ({
    a: p.b,
    b: v
  }), {
    a: "|",
    b: "|"
  })).filter((ab) => ab.a !== "|" && ab.b !== "|").map(({ a, b }) => joinLetters([a, b]));
  const pairsUpper = pairs.map((p) => p.toLocaleUpperCase(costs.locale));
  const map2 = unique([...pairs, ...pairsUpper]).join("|");
  const cost = costs.keyboardCost;
  return {
    map: map2,
    replace: cost,
    swap: cost
  };
}
function affKeyCaps(line, costs) {
  const m = line.match(regExpKey);
  if (!m) return void 0;
  return parseCaps(m[1], costs);
}
function affMapCaps(line, costs) {
  const m = line.match(regExpMap);
  if (!m) return void 0;
  return parseCaps(m[1], costs);
}
function affTryAccents(line, costs) {
  const m = line.match(regExpTry);
  if (!m) return void 0;
  return calcCostsForAccentedLetters(m[1], costs.locale, costs);
}
function affMapAccents(line, costs) {
  const m = line.match(regExpMap);
  if (!m) return void 0;
  return calcCostsForAccentedLetters(m[1], costs.locale, costs);
}
function parseCaps(value, costs) {
  const locale = costs.locale;
  const map2 = unique([...splitMap(value)].filter((a) => a !== "|").map((s) => caseForms(s, locale)).filter((forms2) => forms2.length > 1).map(joinLetters)).join("|");
  const cost = costs.capsCosts;
  if (!map2) return void 0;
  return {
    map: map2,
    replace: cost
  };
}
function reducer(fn, initialVal) {
  let acc = initialVal;
  return (val, i) => acc = fn(acc, val, i);
}
function asArrayOf(v) {
  return Array.isArray(v) ? v : [v];
}
function mapDictionaryInformation(dictInfo) {
  const _locale = dictInfo.locale;
  const locale = _locale ? parseLocale(_locale).filter((loc) => loc.isValid()) : void 0;
  const locales = locale == null ? void 0 : locale.map((loc) => loc.locale);
  const costs = mapEditCosts(dictInfo.costs);
  const defsEC = dictInfo.suggestionEditCosts || [];
  const defsHI = dictInfo.hunspellInformation ? hunspellInformationToSuggestionCostDef(dictInfo.hunspellInformation, locale) : [];
  return [
    ...defsEC,
    ...processAlphabet(dictInfo.alphabet, locales, costs),
    ...processAccents(dictInfo.accents, costs),
    ...defsHI
  ];
}
function processAlphabet(alphabet, locale, editCost) {
  const csAlphabet = toCharSets(alphabet, "a-zA-Z", editCost.baseCost);
  return [...pipeSync(csAlphabet, opMapSync((cs) => parseAlphabet(cs, locale, editCost)), opFlattenSync()), ...calcFirstCharacterReplaceDefs(csAlphabet, editCost)];
}
function toCharSets(cs, defaultValue, cost, penalty) {
  cs = cs != null ? cs : defaultValue;
  if (!cs) return [];
  if (typeof cs === "string") cs = [{
    characters: cs,
    cost
  }];
  if (penalty !== void 0) cs.forEach((cs2) => cs2.penalty = penalty);
  return cs;
}
function processAccents(accents, editCost) {
  return toCharSets(accents, "\u0300-\u0341", editCost.accentCosts).map((cs) => parseAccents(cs, editCost)).filter(isDefined$1);
}
function mapDictionaryInformationToAdjustment(dictInfo) {
  if (!dictInfo.adjustments) return [];
  return dictInfo.adjustments.map(mapAdjustment);
}
function mapAdjustment(adj) {
  const { id, regexp, penalty } = adj;
  return {
    id,
    regexp: new RegExp(regexp),
    penalty
  };
}
var defaultDefs = [{
  map: "1234567890-.",
  insDel: 1,
  penalty: 200
}];
var defaultAdjustments = [
  {
    id: "compound-case-change",
    regexp: /\p{Ll}\p{Lu}/gu,
    penalty: 1e3
  },
  {
    id: "short-compounds-1",
    regexp: /^[^]{0,2}(?=)|[^]{0,2}(?=|$)/gm,
    penalty: 100
  },
  {
    id: "short-compounds-3",
    regexp: /^[^]{3}(?=)|[^]{3}(?=|$)/gm,
    penalty: 50
  }
];
function mapDictionaryInformationToWeightMap(dictInfo) {
  const defs = [...mapDictionaryInformation(dictInfo), ...defaultDefs];
  const adjustments = mapDictionaryInformationToAdjustment(dictInfo);
  const map2 = createWeightMap(...defs);
  addAdjustment(map2, ...defaultAdjustments, ...adjustments);
  return map2;
}
var baseCost = opCosts.baseCost;
var postSwapCost = opCosts.swapCost - baseCost;
var mapSubCost = opCosts.visuallySimilar;
var maxCostScale = opCosts.wordLengthCostFactor;
var normalizeWord = (text) => text.normalize();
var normalizeWordForCaseInsensitive = (text) => {
  const t = text.toLowerCase();
  return [t, t.normalize("NFD").replaceAll(/\p{M}/gu, "")];
};
var BATCH_SIZE = 0;
var _defaultOptions = {
  commentCharacter: LINE_COMMENT,
  optionalCompoundCharacter: OPTIONAL_COMPOUND_FIX,
  compoundCharacter: COMPOUND_FIX,
  forbiddenPrefix: FORBID_PREFIX,
  caseInsensitivePrefix: CASE_INSENSITIVE_PREFIX,
  keepExactPrefix: IDENTITY_PREFIX,
  stripCaseAndAccents: true,
  stripCaseAndAccentsKeepDuplicate: false,
  stripCaseAndAccentsOnForbidden: false,
  split: false,
  splitKeepBoth: false,
  splitSeparator: /[\s,;]/g,
  keepOptionalCompoundCharacter: false,
  suggestionPrefix: SUGGESTION_PREFIX,
  disableSuggestionHandling: false,
  makeWordsForbidden: false
};
var defaultParseDictionaryOptions = Object.freeze(_defaultOptions);
var cSpellToolDirective = "cspell-dictionary:";
function createDictionaryLineParserMapper(options) {
  const _options = options || _defaultOptions;
  const { commentCharacter = _defaultOptions.commentCharacter, optionalCompoundCharacter: optionalCompound = _defaultOptions.optionalCompoundCharacter, compoundCharacter: compound = _defaultOptions.compoundCharacter, caseInsensitivePrefix: ignoreCase2 = _defaultOptions.caseInsensitivePrefix, forbiddenPrefix: forbidden = _defaultOptions.forbiddenPrefix, keepExactPrefix: keepCase = _defaultOptions.keepExactPrefix, splitSeparator = _defaultOptions.splitSeparator, splitKeepBoth = _defaultOptions.splitKeepBoth, stripCaseAndAccentsKeepDuplicate = _defaultOptions.stripCaseAndAccentsKeepDuplicate, stripCaseAndAccentsOnForbidden = _defaultOptions.stripCaseAndAccentsOnForbidden, keepOptionalCompoundCharacter = _defaultOptions.keepOptionalCompoundCharacter, makeWordsForbidden = _defaultOptions.makeWordsForbidden } = _options;
  let { stripCaseAndAccents = !makeWordsForbidden && _defaultOptions.stripCaseAndAccents, split: split2 = _defaultOptions.split, suggestionPrefix = _defaultOptions.suggestionPrefix } = _options;
  const disableSuggestionHandling = _options.disableSuggestionHandling || [
    "",
    " ",
    "	",
    "\0"
  ].includes(suggestionPrefix);
  if (disableSuggestionHandling) suggestionPrefix = SUGGESTIONS_DISABLED;
  function isString2(line) {
    return typeof line === "string";
  }
  function trim(line) {
    return line.trim();
  }
  function removeComments(line) {
    const idx2 = line.indexOf(commentCharacter);
    if (idx2 < 0) return line;
    const idxDirective = line.indexOf(cSpellToolDirective, idx2);
    if (idxDirective >= 0) {
      const flags = line.slice(idxDirective).split(/[\s,;]/g).map((s) => s.trim()).filter((a) => !!a);
      for (const flag of flags) switch (flag) {
        case "split":
          split2 = true;
          break;
        case "no-split":
          split2 = false;
          break;
        case "no-generate-alternatives":
          stripCaseAndAccents = false;
          break;
        case "generate-alternatives":
          stripCaseAndAccents = true;
          break;
      }
    }
    return line.slice(0, idx2).trim();
  }
  function filterEmptyLines(line) {
    return !!line;
  }
  function* mapOptionalPrefix(line) {
    if (line[0] === optionalCompound) {
      const t = line.slice(1);
      yield t;
      yield compound + t;
    } else yield line;
  }
  function* mapOptionalSuffix(line) {
    if (line.slice(-1) === optionalCompound) {
      const t = line.slice(0, -1);
      yield t;
      yield t + compound;
    } else yield line;
  }
  const doNotNormalizePrefix = /* @__PURE__ */ Object.create(null);
  [
    ignoreCase2,
    keepCase,
    '"'
  ].forEach((prefix) => doNotNormalizePrefix[prefix] = true);
  if (!stripCaseAndAccentsOnForbidden) doNotNormalizePrefix[forbidden] = true;
  function removeDoublePrefix(w) {
    return w.startsWith(ignoreCase2 + ignoreCase2) ? w.slice(1) : w;
  }
  function stripKeepCasePrefixAndQuotes(word) {
    word = word.replaceAll(/"(.*?)"/g, "$1");
    return word[0] === keepCase ? word.slice(1) : word;
  }
  function _normalize(word) {
    return normalizeWord(stripKeepCasePrefixAndQuotes(word));
  }
  function* handleForbiddenPrefix(words) {
    if (!makeWordsForbidden) {
      yield* words;
      return;
    }
    const f = forbidden;
    const ff = f + f;
    const sug = suggestionPrefix;
    for (const word of words) {
      if (word.startsWith(sug)) {
        yield word;
        continue;
      }
      yield (f + word).replaceAll(ff, "");
    }
  }
  function* mapNormalize(word) {
    const nWord = _normalize(word);
    const forms2 = /* @__PURE__ */ new Set();
    forms2.add(nWord);
    if (stripCaseAndAccents && !(word[0] in doNotNormalizePrefix)) for (const n of normalizeWordForCaseInsensitive(nWord)) (stripCaseAndAccentsKeepDuplicate || n !== nWord) && forms2.add(ignoreCase2 + n);
    yield* forms2;
  }
  function* splitWords2(lines) {
    for (const line of lines) {
      if (split2) {
        yield* splitLine(line.includes('"') ? line.replaceAll(/".*?"/g, (quoted) => " " + quoted.replaceAll(/(\s)/g, "\\$1") + " ") : line, splitSeparator).map((escaped) => escaped.replaceAll("\\", ""));
        if (!splitKeepBoth) continue;
      }
      yield line;
    }
  }
  function* splitLines(paragraphs) {
    for (const paragraph of paragraphs) yield* paragraph.split("\n");
  }
  function* handleSuggestions(lines) {
    if (disableSuggestionHandling) {
      yield* lines;
      return;
    }
    for (const line of lines) yield* handleSuggestion(line);
  }
  const r = /^\s*(?<prefix>[!:~]*)(?<word>.*?)(?:->|:([0-9a-f]{1,2}:)?)(?<suggestions>.*)$/;
  const suggestionSequence = /* @__PURE__ */ new Map();
  const knownSuggestions = /* @__PURE__ */ new Set();
  function addSuggestion(word, suggestion) {
    const p = suggestionPrefix;
    const pp = p + p;
    const n = suggestionSequence.get(word) || 0;
    const k = word + pp + suggestion;
    if (knownSuggestions.has(k)) return;
    knownSuggestions.add(k);
    suggestionSequence.set(word, n + 1);
    return k.replace(pp, p + n.toString(16) + p);
  }
  function* handleSuggestion(line) {
    const hasAltFormat = line.includes("->");
    if (!line.includes(":") && !hasAltFormat) {
      yield line;
      return;
    }
    const m = line.match(r);
    if (!m || !m.groups) {
      yield line;
      return;
    }
    const prefix = m.groups["prefix"] || "";
    const word = (m.groups["word"] || "").trim();
    const suggestions = (m.groups["suggestions"] || "").split(",").map((s) => s.trim()).filter((s) => !!s);
    if (!prefix.includes(":")) yield prefix + word;
    const ww = ":" + word;
    yield ww;
    for (let i = 0; i < suggestions.length; i++) {
      const sug = addSuggestion(ww, suggestions[i]);
      if (sug) yield sug;
    }
  }
  const mapCompounds = keepOptionalCompoundCharacter ? [] : [opConcatMapSync(mapOptionalPrefix), opConcatMapSync(mapOptionalSuffix)];
  const optionalOperators = [];
  if (options == null ? void 0 : options.sortBatchSize) optionalOperators.push(createBatchAndSortLines(options.sortBatchSize));
  return opCombineSync(opFilterSync(isString2), splitLines, opMapSync(removeComments), splitWords2, opMapSync(trim), opFilterSync(filterEmptyLines), handleSuggestions, ...mapCompounds, opConcatMapSync(mapNormalize), handleForbiddenPrefix, opMapSync(removeDoublePrefix), ...optionalOperators);
}
function parseDictionaryLines(lines, options) {
  return createDictionaryLineParserMapper(options)(typeof lines === "string" ? [lines] : lines);
}
function parseLinesToDictionary(lines, options) {
  const endPerf = measurePerf2("parseLinesToDictionary");
  const dictLines = parseDictionaryLines(lines, mergeOptions(_defaultOptions, options));
  const words = [...new Set(dictLines)].sort();
  const { optimize, useStringTable } = options || {};
  const t = buildITrieFromWords(words, trieInfoFromOptions(options), {
    optimize,
    useStringTable
  });
  endPerf();
  return t;
}
function parseDictionary(text, options) {
  return parseLinesToDictionary(typeof text === "string" ? text.split("\n") : text, options);
}
function trieInfoFromOptions(options) {
  var _a19;
  const info = extractTrieInfo(options);
  const sugPrefix = (_a19 = info.suggestionPrefix) != null ? _a19 : SUGGESTION_PREFIX;
  if ((options == null ? void 0 : options.disableSuggestionHandling) || sugPrefix !== SUGGESTION_PREFIX) info.suggestionPrefix = SUGGESTIONS_DISABLED;
  return info;
}
function mergeOptions(base, ...partials) {
  const opt = { ...base };
  for (const p of partials) {
    if (!p) continue;
    Object.assign(opt, p);
  }
  return opt;
}
var RegExpToEncode = /\\([\s,;])/g;
var RegExpDecode = /<<(%[\da-f]{2})>>/gi;
function encodeLine(line) {
  return line.replaceAll(RegExpToEncode, (_, v) => "<<" + encodeURIComponent(v) + ">>");
}
function decodeLine(line) {
  return line.replaceAll(RegExpDecode, (_, v) => "\\" + decodeURIComponent(v));
}
function splitLine(line, regExp) {
  return encodeLine(line).split(regExp).map((line2) => decodeLine(line2));
}
function createBatchAndSortLines(batchSize = BATCH_SIZE) {
  if (batchSize <= 1) return (s) => s;
  function* batchAndSortLines(lines) {
    const maxSize = batchSize;
    const batch = Array(maxSize);
    let i = 0;
    for (const line of lines) {
      batch[i++] = line;
      if (i >= maxSize) {
        batch.sort();
        yield* batch;
        i = 0;
      }
    }
    batch.length = i;
    batch.sort();
    yield* batch;
  }
  return batchAndSortLines;
}

// ../../node_modules/cspell-lib/dist/lib/util/resolveFile.js
init_shim();
var import_node_module = __toESM(require_empty(), 1);
var os = __toESM(require_browser2(), 1);
init_path_browserify_win32();
var import_node_url3 = __toESM(require_url(), 1);
var import_resolve_from = __toESM(require_resolve_from(), 1);

// ../../node_modules/cspell-lib/dist/lib/util/templates.js
init_shim();
function replaceTemplate(template, replacements) {
  const templateStart = "${";
  const tLen = templateStart.length;
  const templateEnd = "}";
  const parts = [];
  let lastPos = 0;
  let p = template.indexOf(templateStart, lastPos);
  if (p < 0)
    return template;
  while (p >= 0) {
    parts.push(template.substring(lastPos, p));
    lastPos = p;
    const end = template.indexOf(templateEnd, p);
    if (end < 0)
      break;
    const name = template.substring(p + tLen, end);
    if (name in replacements) {
      parts.push(replacements[name] || "");
    } else {
      parts.push(template.substring(p, end + 1));
    }
    lastPos = end + 1;
    p = template.indexOf(templateStart, lastPos);
  }
  parts.push(template.substring(lastPos));
  return parts.join("");
}
function envToTemplateVars(env) {
  const vars = {};
  for (const [key, value] of Object.entries(env)) {
    vars[`env:${key}`] = value || "";
  }
  return vars;
}

// ../../node_modules/cspell-lib/dist/lib/util/resolveFile.js
function patchFilename(filename, templateReplacements) {
  const defaultReplacements = {
    cwd: process_browser_default.cwd(),
    pathSeparator: sep,
    userHome: os.homedir()
  };
  filename = filename.replace(/^~(?=[/\\])/, defaultReplacements.userHome);
  filename = replaceTemplate(filename, { ...defaultReplacements, ...templateReplacements });
  return filename;
}
function resolveRelativeTo(filename, relativeTo, templateReplacements = envToTemplateVars(process_browser_default.env)) {
  if (filename instanceof URL)
    return filename;
  filename = patchFilename(filename, templateReplacements);
  const relativeToUrl = toFileUrl(relativeTo);
  return toFileURL(filename, relativeToUrl);
}

// ../../node_modules/cspell-lib/dist/lib/Settings/DictionaryReferenceCollection.js
init_shim();
function createDictionaryReferenceCollection(dictionaries) {
  return new _DictionaryReferenceCollection(dictionaries);
}
var _DictionaryReferenceCollection = class {
  constructor(dictionaries) {
    __publicField(this, "dictionaries");
    __publicField(this, "collection");
    this.dictionaries = dictionaries;
    this.collection = collect(dictionaries);
  }
  isEnabled(name) {
    const entry = this.collection[name];
    return entry === void 0 ? void 0 : !!(entry & 1);
  }
  isBlocked(name) {
    const entry = this.collection[name];
    return entry === void 0 ? void 0 : !(entry & 1);
  }
  enabled() {
    return this.dictionaryIds.filter((n) => this.isEnabled(n));
  }
  blocked() {
    return this.dictionaryIds.filter((n) => this.isBlocked(n));
  }
  get dictionaryIds() {
    return Object.keys(this.collection);
  }
};
function collect(dictionaries) {
  const refs = dictionaries.map(normalizeName).map(mapReference);
  const col = {};
  for (const ref of refs) {
    col[ref.name] = Math.max(ref.weight, col[ref.name] || 0);
  }
  return col;
}
function normalizeName(entry) {
  return entry.normalize().trim();
}
function mapReference(ref) {
  const name = ref.replace(/^!+/, "");
  const weight = ref.length - name.length + 1;
  return { name: name.trim(), weight };
}

// ../../node_modules/cspell-lib/dist/lib/Settings/internal/InternalDictionaryDef.js
init_shim();
function isDictionaryDefinitionInlineInternal(def) {
  if (def.path)
    return false;
  const defInline = def;
  return !!(defInline.words || defInline.flagWords || defInline.ignoreWords || defInline.suggestWords);
}
function isDictionaryFileDefinitionInternal(def) {
  return !!(def.path || def.file);
}

// ../../node_modules/cspell-lib/dist/lib/Settings/internal/DictionarySettings.js
function filterDictDefsToLoad(dictRefCol, defs) {
  const allActiveDefs = defs.filter(({ name }) => dictRefCol.isEnabled(name)).map(fixPath);
  return [...new Map(allActiveDefs.map((d) => [d.name, d])).values()];
}
function fixPath(def) {
  if (def instanceof _DictionaryDefinitionInternalWithSource) {
    return def;
  }
  const newPath = fixDicPath(def.path, def.file);
  const newBTriePath = def.btrie ? fixDicPath(def.btrie, def.file) : void 0;
  return {
    ...def,
    file: void 0,
    path: newPath,
    btrie: newBTriePath
  };
}
function fixDicPath(defPath, defFile) {
  const parts = [defPath || "", defFile || ""].filter((p) => !!p);
  return parts.length > 1 ? join(...parts) : parts[0] || "";
}
function mapDictDefsToInternal(defs, pathToSettingsFile) {
  return defs == null ? void 0 : defs.map((def) => mapDictDefToInternal(def, pathToSettingsFile));
}
var internalDefs = createAutoResolveWeakWeakCache();
function mapDictDefToInternal(def, pathToSettingsFile) {
  return internalDefs.get(def, (def2) => _mapDictDefToInternal(def2, pathToSettingsFile));
}
function _mapDictDefToInternal(def, pathToSettingsFile) {
  if (isDictionaryDefinitionWithSource(def)) {
    return def;
  }
  const source = pathToSettingsFile.href;
  if (isDictionaryDefinitionInlineInternal(def)) {
    return { ...def, __source: source };
  }
  return new _DictionaryDefinitionInternalWithSource(def, pathToSettingsFile);
}
function determineName(filename, options) {
  return options.name || basename2(filename);
}
function calcDictionaryDefsToLoad(settings) {
  const { dictionaries = [], dictionaryDefinitions = [], noSuggestDictionaries = [] } = settings;
  const colNoSug = createDictionaryReferenceCollection(noSuggestDictionaries);
  const colDicts = createDictionaryReferenceCollection([...dictionaries, ...colNoSug.enabled()]);
  const modDefs = dictionaryDefinitions.map((def) => {
    const enabled = colNoSug.isEnabled(def.name);
    if (enabled === void 0)
      return def;
    return { ...def, noSuggest: enabled };
  });
  return filterDictDefsToLoad(colDicts, modDefs);
}
function isDictionaryDefinitionWithSource(d) {
  return isDictionaryFileDefinitionInternalWithSource(d) || isDictionaryDefinitionInlineInternalWithSource(d);
}
function isDictionaryFileDefinitionInternalWithSource(def) {
  return def instanceof _DictionaryDefinitionInternalWithSource;
}
function isDictionaryDefinitionInlineInternalWithSource(def) {
  return isDictionaryDefinitionInlineInternal(def) && !!def.__source;
}
var _ddi, _def;
var _DictionaryDefinitionInternalWithSource = class {
  constructor(def, sourceURL) {
    __publicField(this, "sourceURL");
    __publicField(this, "_weightMap");
    __publicField(this, "name");
    __publicField(this, "path");
    __publicField(this, "addWords");
    __publicField(this, "description");
    __publicField(this, "dictionaryInformation");
    __publicField(this, "type");
    __publicField(this, "file");
    __publicField(this, "repMap");
    __publicField(this, "useCompounds");
    __publicField(this, "noSuggest");
    __publicField(this, "ignoreForbiddenWords");
    __publicField(this, "scope");
    __publicField(this, "__source");
    __privateAdd(this, _ddi);
    __privateAdd(this, _def);
    this.sourceURL = sourceURL;
    __privateSet(this, _def, def);
    this.__source = sourceURL.href;
    const defAll = def;
    const { path: relPath = "", file = "", btrie, addWords, description, dictionaryInformation, type, repMap, noSuggest, ignoreForbiddenWords, scope, supportNonStrictSearches, useCompounds } = defAll;
    const defaultPath = sourceURL;
    const filePath = fixDicPath(relPath, file);
    const name = determineName(filePath, def);
    const resolvedPath = toFilePathOrHref(resolveRelativeTo(filePath, defaultPath));
    let bTriePath = btrie ? fixDicPath(btrie, file) : void 0;
    bTriePath = bTriePath ? toFilePathOrHref(resolveRelativeTo(bTriePath, defaultPath)) : void 0;
    const ddi = {
      name,
      file: void 0,
      path: resolvedPath,
      btrie: bTriePath,
      addWords,
      description,
      dictionaryInformation,
      type,
      repMap,
      noSuggest,
      ignoreForbiddenWords,
      supportNonStrictSearches,
      scope,
      useCompounds
    };
    Object.assign(this, clean(ddi));
    __privateSet(this, _ddi, ddi);
    this.name = ddi.name;
    this.file = ddi.file;
    this.path = ddi.path;
    this._weightMap = this.dictionaryInformation ? mapDictionaryInformationToWeightMap(this.dictionaryInformation) : void 0;
  }
  get weightMap() {
    return this._weightMap;
  }
  toJSON() {
    return __privateGet(this, _ddi);
  }
  __getOriginalDefinition() {
    return __privateGet(this, _def);
  }
};
_ddi = new WeakMap();
_def = new WeakMap();

// ../../node_modules/cspell-lib/dist/lib/Settings/mergeList.js
init_shim();

// ../../node_modules/cspell-lib/dist/lib/Settings/mergeCache.js
init_shim();
var CalcLeftRightResultWeakCache = class {
  constructor() {
    __publicField(this, "map", new AutoResolveWeakCache());
    __publicField(this, "_toDispose");
    this._toDispose = onClearCache(() => {
      this.clear();
    });
  }
  get(left, right, calc) {
    const m = this.map.get(left, () => new AutoResolveWeakCache());
    return m.get(right, () => calc(left, right));
  }
  clear() {
    this.map.clear();
  }
  dispose() {
    var _a19;
    this.map.dispose();
    (_a19 = this._toDispose) == null ? void 0 : _a19.dispose();
    this._toDispose = void 0;
  }
  stats() {
    return this.map.stats();
  }
};

// ../../node_modules/cspell-lib/dist/lib/Settings/mergeList.js
var cacheMergeListUnique = new CalcLeftRightResultWeakCache();
var cacheMergeLists = new CalcLeftRightResultWeakCache();
function mergeListUnique(left, right) {
  if (!Array.isArray(left))
    return Array.isArray(right) ? right : void 0;
  if (!Array.isArray(right))
    return left;
  if (!right.length)
    return left;
  if (!left.length)
    return right;
  const result = cacheMergeListUnique.get(left, right, (left2, right2) => [.../* @__PURE__ */ new Set([...left2, ...right2])]);
  Object.freeze(left);
  Object.freeze(right);
  Object.freeze(result);
  return result;
}
function mergeList(left, right) {
  if (!Array.isArray(left))
    return Array.isArray(right) ? right : void 0;
  if (!Array.isArray(right))
    return left;
  if (!left.length)
    return right;
  if (!right.length)
    return left;
  const result = cacheMergeLists.get(left, right, (left2, right2) => [...left2, ...right2]);
  Object.freeze(left);
  Object.freeze(right);
  Object.freeze(result);
  return result;
}

// ../../node_modules/cspell-lib/dist/lib/Settings/patterns.js
init_shim();

// ../../node_modules/cspell-lib/dist/lib/util/textRegex.js
init_shim();
var regExSplitWords = /(\p{Ll}\p{M}?)(\p{Lu})/gu;
var regExSplitWords2 = /(\p{Lu}\p{M}?)((\p{Lu}\p{M}?)\p{Ll})/gu;
var regExpCamelCaseWordBreaksWithEnglishSuffix = /(?<=\p{Ll}\p{M}?)(?=\p{Lu})|(?<=\p{Lu}\p{M}?)(?=\p{Lu}\p{M}?\p{Ll})(?!\p{Lu}\p{M}?(?:s|ing|ies|es|ings|ed|ning)(?!\p{Ll}))/gu;
var regExWords = /\p{L}\p{M}?(?:(?:\\?['])?\p{L}\p{M}?)*/gu;
var regExWordsAndDigits = /[\p{L}\w'`.+-](?:(?:\\(?=[']))?[\p{L}\p{M}\w'`.+-])*/gu;
var regExIgnoreCharacters = /[\p{sc=Hiragana}\p{sc=Han}\p{sc=Katakana}\u30A0-\u30FF\p{sc=Hangul}]/gu;
var regExPossibleWordBreaks = /[-+_'`.\s]/g;
var regExMatchRegExParts = /^\s*\/([\s\S]*?)\/([gimuxy]*)\s*$/;
var regExEscapeCharacters = /(?<=\\)[anrvtbf]/gi;
var regExDanglingQuote = /(?<=(?:^|(?!\p{M})\P{L})(?:\p{L}\p{M}?)?)[']/gu;
var regExTrailingEndings = /(?<=(?:\p{Lu}\p{M}?){2})[']?(?:s|d|ings?|ies|e[ds]?|ning|th|nth)(?!\p{Ll})/gu;
var regExNumericLiteral = /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][-+]?\d+)?$/;
function stringToRegExp(pattern, defaultFlags = "gimu", forceFlags = "g") {
  if (pattern instanceof RegExp) {
    return pattern;
  }
  try {
    const [, pat, flag] = [
      ...pattern.match(regExMatchRegExParts) || ["", pattern.trim(), defaultFlags],
      forceFlags
    ];
    if (pat) {
      const regPattern = flag.includes("x") ? removeVerboseFromRegExp(pat) : pat;
      const flags = [...new Set(forceFlags + flag)].join("").replaceAll(/[^gimuy]/g, "");
      const regex = new RegExp(regPattern, flags);
      return regex;
    }
  } catch {
  }
  return void 0;
}
var SPACES = {
  " ": true,
  "\n": true,
  "\r": true,
  "	": true
};
function removeVerboseFromRegExp(pattern) {
  function escape2(acc) {
    const char = pattern[acc.idx];
    if (char !== "\\")
      return void 0;
    const next = pattern[++acc.idx];
    acc.idx++;
    if (next === "#") {
      acc.result += "#";
      return acc;
    }
    if (!(next in SPACES)) {
      acc.result += "\\" + next;
      return acc;
    }
    acc.result += next;
    if (next === "\r" && pattern[acc.idx] === "\n") {
      acc.result += "\n";
      acc.idx++;
    }
    return acc;
  }
  function braces(acc) {
    const char = pattern[acc.idx];
    if (char !== "[")
      return void 0;
    acc.result += char;
    acc.idx++;
    let escCount = 0;
    while (acc.idx < pattern.length) {
      const char2 = pattern[acc.idx];
      acc.result += char2;
      acc.idx++;
      if (char2 === "]" && !(escCount & 1))
        break;
      escCount = char2 === "\\" ? escCount + 1 : 0;
    }
    return acc;
  }
  function spaces2(acc) {
    const char = pattern[acc.idx];
    if (!(char in SPACES))
      return void 0;
    acc.idx++;
    return acc;
  }
  function comments(acc) {
    const char = pattern[acc.idx];
    if (char !== "#")
      return void 0;
    while (acc.idx < pattern.length && pattern[acc.idx] !== "\n") {
      acc.idx++;
    }
    return acc;
  }
  function copy(acc) {
    const char = pattern[acc.idx++];
    acc.result += char;
    return acc;
  }
  const reducers = [escape2, braces, spaces2, comments, copy];
  const result = { idx: 0, result: "" };
  while (result.idx < pattern.length) {
    for (const r of reducers) {
      if (r(result))
        break;
    }
  }
  return result.result;
}

// ../../node_modules/cspell-lib/dist/lib/Settings/patterns.js
var emptyRegExpList = [];
var emptyPatternDefinitions = [];
var cache = new CalcLeftRightResultWeakCache();
function resolvePatterns(regExpList = emptyRegExpList, patternDefinitions = emptyPatternDefinitions) {
  return cache.get(regExpList, patternDefinitions, _resolvePatterns);
}
function _resolvePatterns(regExpList, patternDefinitions) {
  const patternMap = new Map(patternDefinitions.map((def) => [def.name.toLowerCase(), def.pattern]));
  const resolved = /* @__PURE__ */ new Set();
  function resolvePattern(p) {
    if (resolved.has(p))
      return void 0;
    resolved.add(p);
    return patternMap.get(p.toString().toLowerCase()) || p;
  }
  function* flatten2(patterns) {
    for (const pattern of patterns) {
      if (Array.isArray(pattern)) {
        yield* flatten2(pattern.map(resolvePattern).filter(isDefined));
      } else {
        yield pattern;
      }
    }
  }
  const patternList = regExpList.map(resolvePattern).filter(isDefined);
  const result = [...flatten2(patternList)].map(toRegExp).filter(isDefined);
  Object.freeze(regExpList);
  Object.freeze(patternDefinitions);
  Object.freeze(result);
  return result;
}
function toRegExp(pattern) {
  return pattern instanceof RegExp ? new RegExp(pattern) : stringToRegExp(pattern, "gim", "g");
}

// ../../node_modules/cspell-lib/dist/lib/Settings/resolveCwd.js
init_shim();
var _lastPath, _lastUrl, _cwd, _cwdUrl;
var CwdUrlResolver = class {
  constructor() {
    __privateAdd(this, _lastPath);
    __privateAdd(this, _lastUrl);
    __privateAdd(this, _cwd);
    __privateAdd(this, _cwdUrl);
    __privateSet(this, _cwd, process_browser_default.cwd());
    __privateSet(this, _cwdUrl, toFileDirURL(__privateGet(this, _cwd)));
    __privateSet(this, _lastPath, __privateGet(this, _cwd));
    __privateSet(this, _lastUrl, __privateGet(this, _cwdUrl));
  }
  resolveUrl(path) {
    path = path || __privateGet(this, _cwd);
    if (path === __privateGet(this, _lastPath))
      return __privateGet(this, _lastUrl);
    if (path === __privateGet(this, _cwd))
      return __privateGet(this, _cwdUrl);
    __privateSet(this, _lastPath, path);
    __privateSet(this, _lastUrl, toFileURL(path));
    return __privateGet(this, _lastUrl);
  }
  reset(cwd = process_browser_default.cwd()) {
    __privateSet(this, _cwd, cwd);
    __privateSet(this, _cwdUrl, toFileDirURL(__privateGet(this, _cwd)));
  }
};
_lastPath = new WeakMap();
_lastUrl = new WeakMap();
_cwd = new WeakMap();
_cwdUrl = new WeakMap();

// ../../node_modules/cspell-lib/dist/lib/Settings/CSpellSettingsServer.js
var emptyWords = [];
Object.freeze(emptyWords);
var cachedMerges = new AutoResolveWeakCache();
var mergeCache = new AutoResolveWeakCache();
var cacheInternalSettings = new AutoResolveWeakCache();
var parserCache = new AutoResolveWeakCache();
var emptyParserMap = /* @__PURE__ */ new Map();
var cwdResolver = new CwdUrlResolver();
var envCSpellGlobRoot = process_browser_default.env[ENV_CSPELL_GLOB_ROOT];
onClearCache(() => {
  parserCache.clear();
  emptyParserMap.clear();
  cachedMerges.clear();
  mergeCache.clear();
  cacheInternalSettings.clear();
  cwdResolver.reset();
  envCSpellGlobRoot = process_browser_default.env[ENV_CSPELL_GLOB_ROOT];
});
function _mergeWordsCached(left, right) {
  const map2 = autoResolveWeak(cachedMerges, left, () => /* @__PURE__ */ new WeakMap());
  return autoResolveWeak(map2, right, () => [...left, ...right]);
}
function mergeWordsCached(left, right) {
  if (!Array.isArray(left) || !left.length) {
    return Array.isArray(right) ? right.length ? right : emptyWords : void 0;
  }
  if (!Array.isArray(right) || !right.length)
    return left;
  return _mergeWordsCached(left, right);
}
function mergeObjects(left, right) {
  if (!left || typeof left !== "object")
    return !right || typeof right !== "object" ? void 0 : right;
  if (!right || typeof right !== "object")
    return left;
  return { ...left, ...right };
}
function replaceIfNotEmpty(left = [], right = []) {
  const filtered = right.filter((a) => !!a);
  if (filtered.length) {
    return filtered;
  }
  return left;
}
function mergeSettings(left, ...settings) {
  const rawSettings = settings.filter(isDefined).reduce(merge2, toInternalSettings(left));
  return clean(rawSettings);
}
function isEmpty(obj) {
  return !obj || Object.keys(obj).length === 0;
}
function merge2(left, right) {
  const map2 = mergeCache.get(left, () => /* @__PURE__ */ new WeakMap());
  return autoResolveWeak(map2, right, () => _merge(left, right));
}
function _merge(left, right) {
  const _left = toInternalSettings(left);
  const _right = toInternalSettings(right);
  if (left === right) {
    return _left;
  }
  if (isEmpty(right)) {
    return _left;
  }
  if (isEmpty(left)) {
    return _right;
  }
  if (isLeftAncestorOfRight(_left, _right)) {
    return _right;
  }
  if (doesLeftHaveRightAncestor(_left, _right)) {
    return _left;
  }
  const includeRegExpList = takeRightOtherwiseLeft(_left.includeRegExpList, _right.includeRegExpList);
  const optionals = (includeRegExpList == null ? void 0 : includeRegExpList.length) ? { includeRegExpList } : {};
  const version2 = max2(_left.version, _right.version);
  const valuesToClear = {
    name: void 0,
    id: void 0,
    description: void 0,
    globRoot: void 0,
    import: void 0,
    __importRef: void 0
  };
  const settings = cleanCSpellSettingsInternal({
    ..._left,
    ..._right,
    ...optionals,
    ...valuesToClear,
    version: version2,
    words: mergeWordsCached(_left.words, _right.words),
    userWords: mergeWordsCached(_left.userWords, _right.userWords),
    flagWords: mergeWordsCached(_left.flagWords, _right.flagWords),
    ignoreWords: mergeWordsCached(_left.ignoreWords, _right.ignoreWords),
    suggestWords: mergeWordsCached(_left.suggestWords, _right.suggestWords),
    enabledLanguageIds: replaceIfNotEmpty(_left.enabledLanguageIds, _right.enabledLanguageIds),
    enableFiletypes: mergeList(_left.enableFiletypes, _right.enableFiletypes),
    enabledFileTypes: mergeObjects(_left.enabledFileTypes, _right.enabledFileTypes),
    ignoreRegExpList: mergeListUnique(_left.ignoreRegExpList, _right.ignoreRegExpList),
    patterns: mergeListUnique(_left.patterns, _right.patterns),
    dictionaryDefinitions: mergeListUnique(_left.dictionaryDefinitions, _right.dictionaryDefinitions),
    dictionaries: mergeListUnique(_left.dictionaries, _right.dictionaries),
    noSuggestDictionaries: mergeListUnique(_left.noSuggestDictionaries, _right.noSuggestDictionaries),
    languageSettings: mergeList(_left.languageSettings, _right.languageSettings),
    enabled: _right.enabled !== void 0 ? _right.enabled : _left.enabled,
    files: mergeListUnique(_left.files, _right.files),
    ignorePaths: versionBasedMergeList(_left.ignorePaths, _right.ignorePaths, version2),
    overrides: versionBasedMergeList(_left.overrides, _right.overrides, version2),
    features: mergeObjects(_left.features, _right.features),
    source: mergeSources(_left, _right),
    plugins: mergeList(_left.plugins, _right.plugins),
    __imports: mergeImportRefs(_left, _right)
  });
  return settings;
}
function versionBasedMergeList(left, right, version2) {
  if (version2 === configSettingsFileVersion0_1) {
    return takeRightOtherwiseLeft(left, right);
  }
  return mergeListUnique(left, right);
}
function isLeftAncestorOfRight(left, right) {
  return hasAncestor(right, left, 0);
}
function doesLeftHaveRightAncestor(left, right) {
  return hasAncestor(left, right, 1);
}
function hasAncestor(s, ancestor, side) {
  var _a19;
  const sources = (_a19 = s.source) == null ? void 0 : _a19.sources;
  if (!sources)
    return false;
  const i = side ? sources.length - 1 : 0;
  const src = sources[i];
  return src === ancestor || src && hasAncestor(src, ancestor, side) || false;
}
function takeRightOtherwiseLeft(left, right) {
  if (right == null ? void 0 : right.length) {
    return right;
  }
  return left || right;
}
function finalizeSettings(settings) {
  return _finalizeSettings(toInternalSettings(settings));
}
function _finalizeSettings(settings) {
  const finalized = {
    ...settings,
    finalized: true,
    ignoreRegExpList: resolvePatterns(settings.ignoreRegExpList, settings.patterns),
    includeRegExpList: resolvePatterns(settings.includeRegExpList, settings.patterns),
    parserFn: resolveParser(settings)
  };
  finalized.name = "Finalized " + (finalized.name || "");
  finalized.source = { name: settings.name || "src", sources: [settings] };
  return finalized;
}
function toInternalSettings(settings) {
  if (settings === void 0)
    return void 0;
  if (isCSpellSettingsInternal(settings))
    return settings;
  return cacheInternalSettings.get(settings, _toInternalSettings);
}
function _toInternalSettings(settings) {
  var _a19, _b2;
  const { dictionaryDefinitions: defs, ...rest } = settings;
  const dictionaryDefinitions = defs && mapDictDefsToInternal(defs, ((_a19 = settings.source) == null ? void 0 : _a19.filename) && toFileUrl((_b2 = settings.source) == null ? void 0 : _b2.filename) || resolveCwd());
  const setting = dictionaryDefinitions ? { ...rest, dictionaryDefinitions } : rest;
  return cleanCSpellSettingsInternal(setting);
}
function mergeSources(left, right) {
  return {
    name: "merged",
    sources: [left, right]
  };
}
function max2(a, b) {
  if (a === void 0 || a === null)
    return b;
  if (b === void 0 || b === null)
    return a;
  return a > b ? a : b;
}
function getSources(settings) {
  const visited = /* @__PURE__ */ new Set();
  const sources = [];
  function _walkSourcesTree(settings2) {
    var _a19, _b2;
    if (!settings2 || visited.has(settings2))
      return;
    visited.add(settings2);
    if (!((_b2 = (_a19 = settings2.source) == null ? void 0 : _a19.sources) == null ? void 0 : _b2.length)) {
      sources.push(settings2);
      return;
    }
    settings2.source.sources.forEach(_walkSourcesTree);
  }
  _walkSourcesTree(settings);
  return sources;
}
function mergeImportRefs(left, right = {}) {
  var _a19;
  const imports = new Map(left.__imports || []);
  if (left.__importRef) {
    imports.set(left.__importRef.filename, left.__importRef);
  }
  if (right.__importRef) {
    imports.set(right.__importRef.filename, right.__importRef);
  }
  const rightImports = ((_a19 = right.__imports) == null ? void 0 : _a19.values()) || [];
  for (const ref of rightImports) {
    imports.set(ref.filename, ref);
  }
  return imports.size ? imports : void 0;
}
function resolveCwd() {
  return cwdResolver.resolveUrl(envCSpellGlobRoot);
}
function resolveParser(settings) {
  if (!settings.parser)
    return void 0;
  if (typeof settings.parser === "function")
    return settings.parser;
  const parserName = settings.parser;
  (0, import_node_assert5.default)(typeof parserName === "string");
  const parsers2 = extractParsers(settings.plugins);
  const parser = parsers2.get(parserName);
  (0, import_node_assert5.default)(parser, `Parser "${parserName}" not found.`);
  return parser;
}
function* parsers(plugins) {
  for (const plugin of plugins) {
    if (!plugin.parsers)
      continue;
    for (const parser of plugin.parsers) {
      yield [parser.name, parser];
    }
  }
}
function mapPlugins(plugins) {
  return new Map(parsers(plugins));
}
function extractParsers(plugins) {
  if (!plugins || !plugins.length)
    return emptyParserMap;
  return parserCache.get(plugins, mapPlugins);
}

// ../../node_modules/cspell-lib/dist/lib/Settings/calcOverrideSettings.js
function calcOverrideSettings(settings, filename) {
  const _settings = toInternalSettings(settings);
  const overrides = _settings.overrides || [];
  const result = overrides.filter((override) => checkFilenameMatchesExcludeGlob(filename, override.filename)).reduce((settings2, override) => mergeSettings(settings2, override), _settings);
  return result;
}

// src/shims/cspell-settings-index-lite.js
var EMPTY_SETTINGS = Object.freeze({});
function extractImportErrors() {
  return [];
}
async function getDefaultSettings() {
  return EMPTY_SETTINGS;
}
async function getGlobalSettingsAsync() {
  return EMPTY_SETTINGS;
}
async function loadConfig() {
  return EMPTY_SETTINGS;
}
async function resolveConfigFileImports(configFile) {
  return (configFile == null ? void 0 : configFile.settings) || EMPTY_SETTINGS;
}
async function resolveSettingsImports(settings) {
  return settings;
}
async function searchForConfig() {
  return void 0;
}

// ../../node_modules/cspell-lib/dist/lib/Settings/TextDocumentSettings.js
init_shim();

// ../../node_modules/cspell-lib/dist/lib/Settings/InDocSettings.js
init_shim();

// ../../node_modules/@cspell/cspell-pipe/dist/sync/index.js
init_shim();

// ../../node_modules/@cspell/cspell-pipe/dist/operators/index.js
init_shim();

// ../../node_modules/@cspell/cspell-pipe/dist/operators/append.js
init_shim();
function opAppendSync2(...iterablesToAppend) {
  function* fnAppend(iter) {
    yield* iter;
    for (const i of iterablesToAppend) {
      yield* i;
    }
  }
  return fnAppend;
}

// ../../node_modules/@cspell/cspell-pipe/dist/operators/combine.js
init_shim();
function opCombineSync2(...fns) {
  function combine3(iter) {
    for (const fn of fns) {
      iter = fn(iter);
    }
    return iter;
  }
  return combine3;
}

// ../../node_modules/@cspell/cspell-pipe/dist/operators/concatMap.js
init_shim();
function opConcatMapSync2(mapFn) {
  function fnConcatMapSync(iterable) {
    function opConcatMapIterator() {
      const iter = iterable[Symbol.iterator]();
      let resultsIter = void 0;
      function nextConcatMap() {
        while (true) {
          if (resultsIter) {
            const { done: done2, value: value2 } = resultsIter.next();
            if (!done2) {
              return { value: value2 };
            }
            resultsIter = void 0;
          }
          const { done, value } = iter.next();
          if (done) {
            return { done, value: void 0 };
          }
          resultsIter = mapFn(value)[Symbol.iterator]();
        }
      }
      return {
        next: nextConcatMap
      };
    }
    return {
      [Symbol.iterator]: opConcatMapIterator
    };
  }
  return fnConcatMapSync;
}

// ../../node_modules/@cspell/cspell-pipe/dist/operators/filter.js
init_shim();
function opFilterSync2(filterFn) {
  function opFilterIterable(iterable) {
    function opFilterIterator() {
      const iter = iterable[Symbol.iterator]();
      function nextOpFilter() {
        while (true) {
          const { done, value } = iter.next();
          if (done)
            return { done, value: void 0 };
          if (filterFn(value))
            return { value };
        }
      }
      return {
        next: nextOpFilter
      };
    }
    return {
      [Symbol.iterator]: opFilterIterator
    };
  }
  return opFilterIterable;
}

// ../../node_modules/@cspell/cspell-pipe/dist/operators/flatten.js
init_shim();
function opFlattenSync2() {
  function* fn(iter) {
    for (const v of iter) {
      yield* v;
    }
  }
  return fn;
}

// ../../node_modules/@cspell/cspell-pipe/dist/operators/map.js
init_shim();
function opMapSync2(mapFn) {
  function opMapIterable(iterable) {
    function opMapIterator() {
      const iter = iterable[Symbol.iterator]();
      function nextOpMap() {
        const { done, value } = iter.next();
        if (done)
          return { done, value: void 0 };
        return { value: mapFn(value) };
      }
      return {
        next: nextOpMap
      };
    }
    return {
      [Symbol.iterator]: opMapIterator
    };
  }
  return opMapIterable;
}

// ../../node_modules/@cspell/cspell-pipe/dist/pipe.js
init_shim();
function pipeSync2(i, ...fns) {
  return opCombineSync2(...fns)(i);
}

// ../../node_modules/cspell-lib/dist/lib/SpellingDictionary/Dictionaries.js
init_shim();

// ../../node_modules/cspell-dictionary/dist/index.js
init_shim();

// ../../node_modules/cspell-dictionary/dist/SpellingDictionary/CachingDictionary.js
init_shim();

// ../../node_modules/cspell-dictionary/dist/util/AutoCache.js
init_shim();
var CACHE_SIZE = 100;
var Cache01 = class {
  constructor(maxSize) {
    __publicField(this, "maxSize");
    __publicField(this, "hits", 0);
    __publicField(this, "misses", 0);
    __publicField(this, "swaps", 0);
    this.maxSize = maxSize;
  }
};
var Cache01Map = class extends Cache01 {
  constructor(maxSize) {
    super(maxSize);
    __publicField(this, "count", 0);
    __publicField(this, "cache0", /* @__PURE__ */ new Map());
    __publicField(this, "cache1", /* @__PURE__ */ new Map());
  }
  get(key) {
    const cache0 = this.cache0;
    const cache1 = this.cache1;
    let found = cache0.get(key);
    if (found !== void 0) {
      ++this.hits;
      return found;
    }
    found = cache1.get(key);
    if (found !== void 0) {
      ++this.hits;
      ++this.count;
      cache0.set(key, found);
      return found;
    }
    ++this.misses;
    return void 0;
  }
  set(key, value) {
    if (this.count >= this.maxSize) {
      const c = this.cache1;
      this.cache1 = this.cache0;
      this.cache0 = c;
      c.clear();
      this.swaps++;
      this.count = 0;
    }
    ++this.count;
    this.cache0.set(key, value);
    return this;
  }
};
function createCache01(size) {
  return new Cache01Map(size);
}
function autoCache(fn, size = CACHE_SIZE) {
  const cache3 = createCache01(size);
  const ac = get;
  ac.hits = 0;
  ac.misses = 0;
  ac.swaps = 0;
  function get(k) {
    const f = cache3.get(k);
    if (f !== void 0) {
      ++ac.hits;
      return f;
    }
    const r = fn(k);
    cache3.set(k, r);
    ac.swaps = cache3.swaps;
    ++ac.misses;
    return r;
  }
  return ac;
}
function extractStats(ac) {
  const { hits, misses, swaps } = ac;
  return { hits, misses, swaps };
}

// ../../node_modules/cspell-dictionary/dist/SpellingDictionary/SpellingDictionaryMethods.js
init_shim();

// ../../node_modules/cspell-dictionary/dist/util/text.js
init_shim();
var regExAllUpper = /^(?:\p{Lu}\p{M}?)+$/u;
var regExAccents = /\p{M}/gu;
function isUpperCase(word) {
  return !!regExAllUpper.test(word);
}
function ucFirst(word) {
  return word.slice(0, 1).toUpperCase() + word.slice(1);
}
function removeAccents(text) {
  return text.normalize("NFD").replaceAll(regExAccents, "");
}
function removeUnboundAccents(text) {
  return text.replaceAll(regExAccents, "");
}

// ../../node_modules/cspell-dictionary/dist/SpellingDictionary/SpellingDictionaryMethods.js
var defaultNumSuggestions = 10;
function wordSearchForms(word, isDictionaryCaseSensitive, ignoreCase2) {
  const forms2 = /* @__PURE__ */ new Set();
  word = word.normalize("NFC");
  const wordLc = word.toLowerCase();
  if (ignoreCase2) {
    if (isDictionaryCaseSensitive) {
      forms2.add(wordLc);
    } else {
      forms2.add(wordLc);
      forms2.add(removeUnboundAccents(wordLc));
    }
  } else {
    if (isDictionaryCaseSensitive) {
      forms2.add(word);
      forms2.add(wordLc);
      if (isUpperCase(word)) {
        forms2.add(ucFirst(wordLc));
      }
    } else {
      forms2.add(wordLc);
      forms2.add(removeUnboundAccents(wordLc));
    }
  }
  return forms2;
}
function wordSuggestForms(word) {
  word = word.normalize("NFC");
  const forms2 = /* @__PURE__ */ new Set([word]);
  const wordLc = word.toLowerCase();
  forms2.add(wordLc);
  return forms2;
}
var DEFAULT_HAS_OPTIONS = Object.freeze({});
function hasOptionToSearchOption(opt) {
  return canonicalSearchOptions(!opt ? DEFAULT_HAS_OPTIONS : opt);
}
var canonicalSearchOptionsMap = /* @__PURE__ */ new Map();
var knownCanonicalOptions = /* @__PURE__ */ new WeakMap();
function canonicalSearchOptions(opt) {
  const known = knownCanonicalOptions.get(opt);
  if (known)
    return known;
  const { ignoreCase: ignoreCase2, useCompounds } = opt;
  const foundLevel1Map = canonicalSearchOptionsMap.get(ignoreCase2);
  const useLevel1Map = foundLevel1Map || /* @__PURE__ */ new Map();
  if (!foundLevel1Map) {
    canonicalSearchOptionsMap.set(ignoreCase2, useLevel1Map);
  }
  const foundCanOpts = useLevel1Map.get(useCompounds);
  const canOpts = foundCanOpts || Object.freeze({ ignoreCase: ignoreCase2, useCompounds });
  if (!foundCanOpts) {
    useLevel1Map.set(useCompounds, canOpts);
  }
  knownCanonicalOptions.set(opt, canOpts);
  return canOpts;
}
function createWeightMapFromDictionaryInformation(di) {
  return di ? mapDictionaryInformationToWeightMap(di) : void 0;
}

// ../../node_modules/cspell-dictionary/dist/SpellingDictionary/CachingDictionary.js
var dictionaryCounter = 0;
var DefaultAutoCacheSize = 1e3;
var logRequests = false;
var log = [];
var startTime2 = performance.now();
var _has;
var CachedDict = class {
  constructor(dict, options) {
    __publicField(this, "dict");
    __publicField(this, "options");
    __publicField(this, "name");
    __publicField(this, "id", ++dictionaryCounter);
    __publicField(this, "has");
    __privateAdd(this, _has);
    __publicField(this, "isNoSuggestWord", autoCache((word) => this.dict.isNoSuggestWord(word, this.options), DefaultAutoCacheSize));
    __publicField(this, "isForbidden", autoCache((word) => this.dict.isForbidden(word), DefaultAutoCacheSize));
    __publicField(this, "getPreferredSuggestions", autoCache((word) => {
      var _a19, _b2;
      return (_b2 = (_a19 = this.dict).getPreferredSuggestions) == null ? void 0 : _b2.call(_a19, word);
    }, DefaultAutoCacheSize));
    __publicField(this, "suggest", (word, suggestOptions) => this.dict.suggest(word, suggestOptions));
    this.dict = dict;
    this.options = options;
    this.name = dict.name;
    const has = autoCache((word) => this.dict.has(word, this.options), DefaultAutoCacheSize);
    const hasAndLog = (word) => {
      const time = performance.now() - startTime2;
      const misses = has.misses;
      const value = has(word);
      if (logRequests) {
        const miss = has.misses > misses;
        log.push({ time, method: "has", word, value, miss });
      }
      return value;
    };
    __privateSet(this, _has, has);
    this.has = logRequests ? hasAndLog : has;
  }
  stats() {
    return {
      name: this.name,
      id: this.id,
      has: extractStats(__privateGet(this, _has)),
      isNoSuggestWord: extractStats(this.isNoSuggestWord),
      isForbidden: extractStats(this.isForbidden),
      getPreferredSuggestions: extractStats(this.getPreferredSuggestions)
    };
  }
};
_has = new WeakMap();
var knownDicts = /* @__PURE__ */ new Map();
function createCachingDictionary(dict, options) {
  options = canonicalSearchOptions(options);
  let knownOptions = knownDicts.get(options);
  if (!knownOptions) {
    knownOptions = /* @__PURE__ */ new WeakMap();
    knownDicts.set(options, knownOptions);
  }
  const known = knownOptions.get(dict);
  if (known)
    return known;
  const cached = new CachedDict(dict, options);
  knownOptions.set(dict, cached);
  return cached;
}

// ../../node_modules/cspell-dictionary/dist/SpellingDictionary/index.js
init_shim();

// ../../node_modules/cspell-dictionary/dist/SpellingDictionary/createInlineSpellingDictionary.js
init_shim();

// ../../node_modules/cspell-dictionary/dist/util/AutoResolve.js
init_shim();
function autoResolveWeak2(map2, key, resolve2) {
  const found = map2.get(key);
  if (found !== void 0 || map2.has(key))
    return found;
  const value = resolve2(key);
  map2.set(key, value);
  return value;
}
var AutoResolveWeakCache2 = class {
  constructor() {
    __publicField(this, "map", /* @__PURE__ */ new WeakMap());
  }
  get(k, resolve2) {
    return resolve2 ? autoResolveWeak2(this.map, k, resolve2) : this.map.get(k);
  }
  has(k) {
    return this.map.has(k);
  }
  set(k, v) {
    this.map.set(k, v);
    return this;
  }
};
function createAutoResolveWeakCache2() {
  return new AutoResolveWeakCache2();
}

// ../../node_modules/cspell-dictionary/dist/util/util.js
init_shim();
function isDefined2(v) {
  return v !== void 0;
}

// ../../node_modules/cspell-dictionary/dist/SpellingDictionary/createSpellingDictionary.js
init_shim();
var import_node_url4 = __toESM(require_url(), 1);

// ../../node_modules/fast-equals/dist/es/index.mjs
init_shim();
var { getOwnPropertyNames, getOwnPropertySymbols } = Object;
var { hasOwnProperty } = Object.prototype;
function combineComparators(comparatorA, comparatorB) {
  return function isEqual(a, b, state) {
    return comparatorA(a, b, state) && comparatorB(a, b, state);
  };
}
function createIsCircular(areItemsEqual) {
  return function isCircular2(a, b, state) {
    if (!a || !b || typeof a !== "object" || typeof b !== "object") {
      return areItemsEqual(a, b, state);
    }
    const { cache: cache3 } = state;
    const cachedA = cache3.get(a);
    const cachedB = cache3.get(b);
    if (cachedA && cachedB) {
      return cachedA === b && cachedB === a;
    }
    cache3.set(a, b);
    cache3.set(b, a);
    const result = areItemsEqual(a, b, state);
    cache3.delete(a);
    cache3.delete(b);
    return result;
  };
}
function getStrictProperties(object) {
  return getOwnPropertyNames(object).concat(getOwnPropertySymbols(object));
}
var hasOwn = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  Object.hasOwn || ((object, property) => hasOwnProperty.call(object, property))
);
var PREACT_VNODE = "__v";
var PREACT_OWNER = "__o";
var REACT_OWNER = "_owner";
var { getOwnPropertyDescriptor, keys: keys2 } = Object;
var sameValueEqual = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  Object.is || function sameValueEqual2(a, b) {
    return a === b ? a !== 0 || 1 / a === 1 / b : a !== a && b !== b;
  }
);
function strictEqual(a, b) {
  return a === b;
}
function areArrayBuffersEqual(a, b) {
  return a.byteLength === b.byteLength && areTypedArraysEqual(new Uint8Array(a), new Uint8Array(b));
}
function areArraysEqual(a, b, state) {
  let index = a.length;
  if (b.length !== index) {
    return false;
  }
  while (index-- > 0) {
    if (!state.equals(a[index], b[index], index, index, a, b, state)) {
      return false;
    }
  }
  return true;
}
function areDataViewsEqual(a, b) {
  return a.byteLength === b.byteLength && areTypedArraysEqual(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength));
}
function areDatesEqual(a, b) {
  return sameValueEqual(a.getTime(), b.getTime());
}
function areErrorsEqual(a, b) {
  return a.name === b.name && a.message === b.message && a.cause === b.cause && a.stack === b.stack;
}
function areMapsEqual(a, b, state) {
  const size = a.size;
  if (size !== b.size) {
    return false;
  }
  if (!size) {
    return true;
  }
  const matchedIndices = new Array(size);
  const aIterable = a.entries();
  let aResult;
  let bResult;
  let index = 0;
  while (aResult = aIterable.next()) {
    if (aResult.done) {
      break;
    }
    const bIterable = b.entries();
    let hasMatch = false;
    let matchIndex = 0;
    while (bResult = bIterable.next()) {
      if (bResult.done) {
        break;
      }
      if (matchedIndices[matchIndex]) {
        matchIndex++;
        continue;
      }
      const aEntry = aResult.value;
      const bEntry = bResult.value;
      if (state.equals(aEntry[0], bEntry[0], index, matchIndex, a, b, state) && state.equals(aEntry[1], bEntry[1], aEntry[0], bEntry[0], a, b, state)) {
        hasMatch = matchedIndices[matchIndex] = true;
        break;
      }
      matchIndex++;
    }
    if (!hasMatch) {
      return false;
    }
    index++;
  }
  return true;
}
function areObjectsEqual(a, b, state) {
  const properties = keys2(a);
  let index = properties.length;
  if (keys2(b).length !== index) {
    return false;
  }
  while (index-- > 0) {
    if (!isPropertyEqual(a, b, state, properties[index])) {
      return false;
    }
  }
  return true;
}
function areObjectsEqualStrict(a, b, state) {
  const properties = getStrictProperties(a);
  let index = properties.length;
  if (getStrictProperties(b).length !== index) {
    return false;
  }
  let property;
  let descriptorA;
  let descriptorB;
  while (index-- > 0) {
    property = properties[index];
    if (!isPropertyEqual(a, b, state, property)) {
      return false;
    }
    descriptorA = getOwnPropertyDescriptor(a, property);
    descriptorB = getOwnPropertyDescriptor(b, property);
    if ((descriptorA || descriptorB) && (!descriptorA || !descriptorB || descriptorA.configurable !== descriptorB.configurable || descriptorA.enumerable !== descriptorB.enumerable || descriptorA.writable !== descriptorB.writable)) {
      return false;
    }
  }
  return true;
}
function arePrimitiveWrappersEqual(a, b) {
  return sameValueEqual(a.valueOf(), b.valueOf());
}
function areRegExpsEqual(a, b) {
  return a.source === b.source && a.flags === b.flags;
}
function areSetsEqual(a, b, state) {
  const size = a.size;
  if (size !== b.size) {
    return false;
  }
  if (!size) {
    return true;
  }
  const matchedIndices = new Array(size);
  const aIterable = a.values();
  let aResult;
  let bResult;
  while (aResult = aIterable.next()) {
    if (aResult.done) {
      break;
    }
    const bIterable = b.values();
    let hasMatch = false;
    let matchIndex = 0;
    while (bResult = bIterable.next()) {
      if (bResult.done) {
        break;
      }
      if (!matchedIndices[matchIndex] && state.equals(aResult.value, bResult.value, aResult.value, bResult.value, a, b, state)) {
        hasMatch = matchedIndices[matchIndex] = true;
        break;
      }
      matchIndex++;
    }
    if (!hasMatch) {
      return false;
    }
  }
  return true;
}
function areTypedArraysEqual(a, b) {
  let index = a.byteLength;
  if (b.byteLength !== index || a.byteOffset !== b.byteOffset) {
    return false;
  }
  while (index-- > 0) {
    if (a[index] !== b[index]) {
      return false;
    }
  }
  return true;
}
function areUrlsEqual(a, b) {
  return a.hostname === b.hostname && a.pathname === b.pathname && a.protocol === b.protocol && a.port === b.port && a.hash === b.hash && a.username === b.username && a.password === b.password;
}
function isPropertyEqual(a, b, state, property) {
  if ((property === REACT_OWNER || property === PREACT_OWNER || property === PREACT_VNODE) && (a.$$typeof || b.$$typeof)) {
    return true;
  }
  return hasOwn(b, property) && state.equals(a[property], b[property], property, property, a, b, state);
}
var toString = Object.prototype.toString;
function createEqualityComparator(config) {
  const supportedComparatorMap = createSupportedComparatorMap(config);
  const { areArraysEqual: areArraysEqual2, areDatesEqual: areDatesEqual2, areFunctionsEqual, areMapsEqual: areMapsEqual2, areNumbersEqual, areObjectsEqual: areObjectsEqual2, areRegExpsEqual: areRegExpsEqual2, areSetsEqual: areSetsEqual2, getUnsupportedCustomComparator } = config;
  return function comparator(a, b, state) {
    if (a === b) {
      return true;
    }
    if (a == null || b == null) {
      return false;
    }
    const type = typeof a;
    if (type !== typeof b) {
      return false;
    }
    if (type !== "object") {
      if (type === "number" || type === "bigint") {
        return areNumbersEqual(a, b, state);
      }
      if (type === "function") {
        return areFunctionsEqual(a, b, state);
      }
      return false;
    }
    const constructor = a.constructor;
    if (constructor !== b.constructor) {
      return false;
    }
    if (constructor === Object) {
      return areObjectsEqual2(a, b, state);
    }
    if (constructor === Array) {
      return areArraysEqual2(a, b, state);
    }
    if (constructor === Date) {
      return areDatesEqual2(a, b, state);
    }
    if (constructor === RegExp) {
      return areRegExpsEqual2(a, b, state);
    }
    if (constructor === Map) {
      return areMapsEqual2(a, b, state);
    }
    if (constructor === Set) {
      return areSetsEqual2(a, b, state);
    }
    if (constructor === Promise) {
      return false;
    }
    if (Array.isArray(a)) {
      return areArraysEqual2(a, b, state);
    }
    const tag = toString.call(a);
    const supportedComparator = supportedComparatorMap[tag];
    if (supportedComparator) {
      return supportedComparator(a, b, state);
    }
    const unsupportedCustomComparator = getUnsupportedCustomComparator && getUnsupportedCustomComparator(a, b, state, tag);
    if (unsupportedCustomComparator) {
      return unsupportedCustomComparator(a, b, state);
    }
    return false;
  };
}
function createEqualityComparatorConfig({ circular, createCustomConfig, strict }) {
  let config = {
    areArrayBuffersEqual,
    areArraysEqual: strict ? areObjectsEqualStrict : areArraysEqual,
    areDataViewsEqual,
    areDatesEqual,
    areErrorsEqual,
    areFunctionsEqual: strictEqual,
    areMapsEqual: strict ? combineComparators(areMapsEqual, areObjectsEqualStrict) : areMapsEqual,
    areNumbersEqual: sameValueEqual,
    areObjectsEqual: strict ? areObjectsEqualStrict : areObjectsEqual,
    arePrimitiveWrappersEqual,
    areRegExpsEqual,
    areSetsEqual: strict ? combineComparators(areSetsEqual, areObjectsEqualStrict) : areSetsEqual,
    areTypedArraysEqual: strict ? combineComparators(areTypedArraysEqual, areObjectsEqualStrict) : areTypedArraysEqual,
    areUrlsEqual,
    getUnsupportedCustomComparator: void 0
  };
  if (createCustomConfig) {
    config = Object.assign({}, config, createCustomConfig(config));
  }
  if (circular) {
    const areArraysEqual2 = createIsCircular(config.areArraysEqual);
    const areMapsEqual2 = createIsCircular(config.areMapsEqual);
    const areObjectsEqual2 = createIsCircular(config.areObjectsEqual);
    const areSetsEqual2 = createIsCircular(config.areSetsEqual);
    config = Object.assign({}, config, {
      areArraysEqual: areArraysEqual2,
      areMapsEqual: areMapsEqual2,
      areObjectsEqual: areObjectsEqual2,
      areSetsEqual: areSetsEqual2
    });
  }
  return config;
}
function createInternalEqualityComparator(compare2) {
  return function(a, b, _indexOrKeyA, _indexOrKeyB, _parentA, _parentB, state) {
    return compare2(a, b, state);
  };
}
function createIsEqual({ circular, comparator, createState, equals, strict }) {
  if (createState) {
    return function isEqual(a, b) {
      const { cache: cache3 = circular ? /* @__PURE__ */ new WeakMap() : void 0, meta } = createState();
      return comparator(a, b, {
        cache: cache3,
        equals,
        meta,
        strict
      });
    };
  }
  if (circular) {
    return function isEqual(a, b) {
      return comparator(a, b, {
        cache: /* @__PURE__ */ new WeakMap(),
        equals,
        meta: void 0,
        strict
      });
    };
  }
  const state = {
    cache: void 0,
    equals,
    meta: void 0,
    strict
  };
  return function isEqual(a, b) {
    return comparator(a, b, state);
  };
}
function createSupportedComparatorMap({ areArrayBuffersEqual: areArrayBuffersEqual2, areArraysEqual: areArraysEqual2, areDataViewsEqual: areDataViewsEqual2, areDatesEqual: areDatesEqual2, areErrorsEqual: areErrorsEqual2, areFunctionsEqual, areMapsEqual: areMapsEqual2, areNumbersEqual, areObjectsEqual: areObjectsEqual2, arePrimitiveWrappersEqual: arePrimitiveWrappersEqual2, areRegExpsEqual: areRegExpsEqual2, areSetsEqual: areSetsEqual2, areTypedArraysEqual: areTypedArraysEqual2, areUrlsEqual: areUrlsEqual2 }) {
  return {
    "[object Arguments]": areObjectsEqual2,
    "[object Array]": areArraysEqual2,
    "[object ArrayBuffer]": areArrayBuffersEqual2,
    "[object AsyncGeneratorFunction]": areFunctionsEqual,
    "[object BigInt]": areNumbersEqual,
    "[object BigInt64Array]": areTypedArraysEqual2,
    "[object BigUint64Array]": areTypedArraysEqual2,
    "[object Boolean]": arePrimitiveWrappersEqual2,
    "[object DataView]": areDataViewsEqual2,
    "[object Date]": areDatesEqual2,
    // If an error tag, it should be tested explicitly. Like RegExp, the properties are not
    // enumerable, and therefore will give false positives if tested like a standard object.
    "[object Error]": areErrorsEqual2,
    "[object Float16Array]": areTypedArraysEqual2,
    "[object Float32Array]": areTypedArraysEqual2,
    "[object Float64Array]": areTypedArraysEqual2,
    "[object Function]": areFunctionsEqual,
    "[object GeneratorFunction]": areFunctionsEqual,
    "[object Int8Array]": areTypedArraysEqual2,
    "[object Int16Array]": areTypedArraysEqual2,
    "[object Int32Array]": areTypedArraysEqual2,
    "[object Map]": areMapsEqual2,
    "[object Number]": arePrimitiveWrappersEqual2,
    "[object Object]": (a, b, state) => (
      // The exception for value comparison is custom `Promise`-like class instances. These should
      // be treated the same as standard `Promise` objects, which means strict equality, and if
      // it reaches this point then that strict equality comparison has already failed.
      typeof a.then !== "function" && typeof b.then !== "function" && areObjectsEqual2(a, b, state)
    ),
    // For RegExp, the properties are not enumerable, and therefore will give false positives if
    // tested like a standard object.
    "[object RegExp]": areRegExpsEqual2,
    "[object Set]": areSetsEqual2,
    "[object String]": arePrimitiveWrappersEqual2,
    "[object URL]": areUrlsEqual2,
    "[object Uint8Array]": areTypedArraysEqual2,
    "[object Uint8ClampedArray]": areTypedArraysEqual2,
    "[object Uint16Array]": areTypedArraysEqual2,
    "[object Uint32Array]": areTypedArraysEqual2
  };
}
var deepEqual = createCustomEqual();
var strictDeepEqual = createCustomEqual({ strict: true });
var circularDeepEqual = createCustomEqual({ circular: true });
var strictCircularDeepEqual = createCustomEqual({
  circular: true,
  strict: true
});
var shallowEqual = createCustomEqual({
  createInternalComparator: () => sameValueEqual
});
var strictShallowEqual = createCustomEqual({
  strict: true,
  createInternalComparator: () => sameValueEqual
});
var circularShallowEqual = createCustomEqual({
  circular: true,
  createInternalComparator: () => sameValueEqual
});
var strictCircularShallowEqual = createCustomEqual({
  circular: true,
  createInternalComparator: () => sameValueEqual,
  strict: true
});
function createCustomEqual(options = {}) {
  const { circular = false, createInternalComparator: createCustomInternalComparator, createState, strict = false } = options;
  const config = createEqualityComparatorConfig(options);
  const comparator = createEqualityComparator(config);
  const equals = createCustomInternalComparator ? createCustomInternalComparator(comparator) : createInternalEqualityComparator(comparator);
  return createIsEqual({ circular, comparator, createState, equals, strict });
}

// ../../node_modules/cspell-dictionary/dist/util/performance.js
init_shim();

// ../../node_modules/cspell-dictionary/dist/util/simpleCache.js
init_shim();
var SimpleWeakCache = class {
  constructor(size) {
    __publicField(this, "size");
    __publicField(this, "L0", /* @__PURE__ */ new WeakMap());
    __publicField(this, "L1", /* @__PURE__ */ new WeakMap());
    __publicField(this, "L2", /* @__PURE__ */ new WeakMap());
    __publicField(this, "sizeL0", 0);
    this.size = size;
  }
  has(key) {
    for (const c of this.caches()) {
      if (c.has(key))
        return true;
    }
    return false;
  }
  get(key) {
    for (const c of this.caches()) {
      const entry = c.get(key);
      if (entry) {
        if (c !== this.L0) {
          this._set(key, entry);
        }
        return entry.v;
      }
    }
    return void 0;
  }
  set(key, value) {
    this._set(key, { v: value });
  }
  _set(key, entry) {
    if (this.L0.has(key)) {
      this.L0.set(key, entry);
      return this;
    }
    if (this.sizeL0 >= this.size) {
      this.rotate();
    }
    this.sizeL0 += 1;
    this.L0.set(key, entry);
  }
  caches() {
    return [this.L0, this.L1, this.L2];
  }
  rotate() {
    this.L2 = this.L1;
    this.L1 = this.L0;
    this.L0 = /* @__PURE__ */ new WeakMap();
    this.sizeL0 = 0;
  }
};
var AutoWeakCache = class extends SimpleWeakCache {
  constructor(factory, size) {
    super(size);
    __publicField(this, "factory");
    this.factory = factory;
  }
  get(key) {
    const v = super.get(key);
    if (v !== void 0)
      return v;
    const val = this.factory(key);
    this.set(key, val);
    return val;
  }
};
var SimpleCache = class {
  constructor(size) {
    __publicField(this, "size");
    __publicField(this, "L0", /* @__PURE__ */ new Map());
    __publicField(this, "L1", /* @__PURE__ */ new Map());
    __publicField(this, "L2", /* @__PURE__ */ new Map());
    this.size = size;
  }
  has(key) {
    for (const c of this.caches()) {
      if (c.has(key))
        return true;
    }
    return false;
  }
  get(key) {
    for (const c of this.caches()) {
      const entry = c.get(key);
      if (entry) {
        if (c !== this.L0) {
          this._set(key, entry);
        }
        return entry.v;
      }
    }
    return void 0;
  }
  set(key, value) {
    this._set(key, { v: value });
  }
  _set(key, entry) {
    if (this.L0.has(key)) {
      this.L0.set(key, entry);
      return this;
    }
    if (this.L0.size >= this.size) {
      this.rotate();
    }
    this.L0.set(key, entry);
  }
  caches() {
    return [this.L0, this.L1, this.L2];
  }
  rotate() {
    this.L2 = this.L1;
    this.L1 = this.L0;
    this.L0 = /* @__PURE__ */ new Map();
  }
};

// ../../node_modules/cspell-dictionary/dist/SpellingDictionary/SpellingDictionary.js
init_shim();
var defaultOptions = Object.freeze({
  weightMap: void 0
});

// ../../node_modules/cspell-dictionary/dist/SpellingDictionary/SpellingDictionaryFromTrie.js
init_shim();

// ../../node_modules/cspell-dictionary/dist/util/clean.js
init_shim();
function clean3(src) {
  const r = src;
  for (const key of Object.keys(r)) {
    if (r[key] === void 0) {
      delete r[key];
    }
  }
  return r;
}

// ../../node_modules/cspell-dictionary/dist/util/repMap.js
init_shim();

// ../../node_modules/cspell-dictionary/dist/util/regexHelper.js
init_shim();
function escapeRegEx2(s) {
  return s.replaceAll(/[|\\{}()[\]^$+*?.]/g, "\\$&").replaceAll("-", "\\x2d");
}

// ../../node_modules/cspell-dictionary/dist/util/repMap.js
function createMapper(repMap, ignoreCharset) {
  if (!repMap && !ignoreCharset)
    return void 0;
  repMap = repMap || [];
  const charsetMap = charsetToRepMapRegEx(ignoreCharset);
  if (charsetMap) {
    repMap = [...repMap, ...charsetMap];
  }
  const filteredMap = repMap.filter(([match2, _]) => !!match2);
  if (!filteredMap.length) {
    return void 0;
  }
  const regEx = createMapperRegExp(repMap);
  const values = repMap.filter(([match2, _]) => !!match2).map(([_, into]) => into);
  function resolve2(m, ...matches) {
    const index = matches.findIndex((a) => !!a);
    return 0 <= index && index < values.length ? values[index] : m;
  }
  function fn(s) {
    return s.replace(regEx, resolve2);
  }
  return {
    test: regexpRemoveFlags(regEx, "gm"),
    fn
  };
}
function charsetToRepMapRegEx(charset, replaceWith = "") {
  if (!charset)
    return void 0;
  return charset.split("|").map((chars) => `[${chars.replaceAll(/[\][\\]/g, "\\$&")}]`).map((map2) => [map2, replaceWith]);
}
function charsetToRepMap(charset, replaceWith = "") {
  if (!charset)
    return void 0;
  return charset.split("|").flatMap((chars) => [...expandCharacterSet(chars)]).map((char) => [char, replaceWith]);
}
function expandReplaceMap(repMap) {
  return repMap.flatMap(([from, replaceWith]) => from.split("|").map((w) => [w, replaceWith]));
}
function createMapperRegExp(repMap) {
  const filteredMap = repMap.filter(([match2, _]) => !!match2);
  if (!filteredMap.length) {
    return /$^/;
  }
  const regExStr = filteredMap.map(([from, _]) => from).map((s) => {
    try {
      const r = /\(/.test(s) ? s.replaceAll(/\((?=.*\))/g, "(?:").replaceAll("(?:?", "(?") : s;
      new RegExp(r);
      s = r;
    } catch {
      return escapeRegEx2(s);
    }
    return s;
  }).map((s) => `(${s})`).join("|");
  const regEx = new RegExp(regExStr, "g");
  return regEx;
}
function createRepMapper(repMap, ignoreCharset) {
  if (!(repMap == null ? void 0 : repMap.length) && !ignoreCharset)
    return void 0;
  let tRepMap = repMap || [];
  const charsetMap = charsetToRepMapRegEx(ignoreCharset);
  if (charsetMap) {
    tRepMap = [...tRepMap, ...charsetMap];
  }
  const regEx = createMapperRegExp(tRepMap);
  const trie = createTrie(repMap, ignoreCharset);
  return {
    test: regexpRemoveFlags(regEx, "gm"),
    fn: (word) => {
      const edits = calcAllEdits(trie, word);
      return applyEdits(word, edits);
    }
  };
}
function applyEdits(word, edits) {
  if (!edits.length)
    return [word];
  const letterEdits = [];
  for (let i = 0; i < word.length; ++i) {
    letterEdits[i] = { edits: [{ b: i, e: i + 1, r: word[i] }], suffixes: [] };
  }
  letterEdits[word.length] = { edits: [], suffixes: [""] };
  for (const edit of edits) {
    const le = letterEdits[edit.b];
    le.edits.push(edit);
  }
  for (let i = word.length - 1; i >= 0; --i) {
    const le = letterEdits[i];
    const sfx = le.suffixes;
    for (const edit of le.edits) {
      const pfx = edit.r;
      const nSfx = letterEdits[edit.e].suffixes;
      for (const s of nSfx) {
        sfx.push(pfx + s);
      }
    }
  }
  const results = new Set(letterEdits[0].suffixes);
  return [...results];
}
function calcAllEdits(root, word) {
  const edits = [];
  function walk(node, b, e) {
    if (node.rep) {
      node.rep.forEach((r) => edits.push({ b, e, r }));
    }
    if (e === word.length || !node.children)
      return;
    const n = node.children[word[e]];
    if (!n)
      return;
    walk(n, b, e + 1);
  }
  for (let i = 0; i < word.length; ++i) {
    walk(root, i, i);
  }
  return edits;
}
function createTrie(repMap, ignoreCharset) {
  const combined = [repMap, charsetToRepMap(ignoreCharset)].filter(isDefined2).flat();
  const expanded = expandReplaceMap(combined);
  const trieRoot = /* @__PURE__ */ Object.create(null);
  expanded.forEach(([match2, replaceWith]) => addToTrie(trieRoot, match2, replaceWith));
  return trieRoot;
}
function addToTrie(node, match2, replaceWith) {
  while (match2) {
    const children = node.children || (node.children = /* @__PURE__ */ Object.create(null));
    const k = match2[0];
    const childNode = children[k] || (children[k] = /* @__PURE__ */ Object.create(null));
    node = childNode;
    match2 = match2.slice(1);
  }
  const s = new Set(node.rep || []);
  s.add(replaceWith);
  node.rep = [...s];
}
function regexpRemoveFlags(re, flagsToRemove) {
  const toRemove = new Set(flagsToRemove);
  const flags = [...re.flags].filter((f) => !toRemove.has(f)).join("");
  return new RegExp(re.source, flags);
}

// ../../node_modules/cspell-dictionary/dist/SpellingDictionary/defaults.js
init_shim();
var ignoreCase = true;
var isForbiddenIgnoreCaseAndAccents = false;

// ../../node_modules/cspell-dictionary/dist/SpellingDictionary/SpellingDictionaryFromTrie.js
var _ignoreForbiddenWords, _findWordOptionsCaseSensitive, _findWordOptionsNotCaseSensitive, _SpellingDictionaryFromTrie_instances, isForbidden_fn;
var SpellingDictionaryFromTrie = class {
  constructor(trie, name, options, source = "from trie", size) {
    __privateAdd(this, _SpellingDictionaryFromTrie_instances);
    __publicField(this, "trie");
    __publicField(this, "name");
    __publicField(this, "options");
    __publicField(this, "source");
    __publicField(this, "_size", 0);
    __publicField(this, "knownWords", /* @__PURE__ */ new Set());
    __publicField(this, "unknownWords", /* @__PURE__ */ new Set());
    __publicField(this, "mapWord");
    __publicField(this, "remapWord");
    __publicField(this, "repMapper");
    __publicField(this, "type", "SpellingDictionaryFromTrie");
    __publicField(this, "isDictionaryCaseSensitive");
    __publicField(this, "containsNoSuggestWords");
    __privateAdd(this, _ignoreForbiddenWords, false);
    __privateAdd(this, _findWordOptionsCaseSensitive, { caseSensitive: true });
    __privateAdd(this, _findWordOptionsNotCaseSensitive, { caseSensitive: false });
    __publicField(this, "weightMap");
    __publicField(this, "_find", (word, useCompounds, ignoreCase2, compoundSeparator) => this.findAnyForm(word, useCompounds, ignoreCase2, compoundSeparator));
    var _a19, _b2, _c;
    this.trie = trie;
    this.name = name;
    this.options = options;
    this.source = source;
    const mapWord = createMapper(options.repMap, (_a19 = options.dictionaryInformation) == null ? void 0 : _a19.ignore);
    const repMapper = createRepMapper(options.repMap, (_b2 = options.dictionaryInformation) == null ? void 0 : _b2.ignore);
    this.mapWord = mapWord == null ? void 0 : mapWord.fn;
    this.remapWord = repMapper == null ? void 0 : repMapper.fn;
    this.repMapper = repMapper;
    this.isDictionaryCaseSensitive = (_c = options.caseSensitive) != null ? _c : true;
    this.containsNoSuggestWords = options.noSuggest || false;
    this._size = size || 0;
    this.weightMap = options.weightMap || createWeightMapFromDictionaryInformation(options.dictionaryInformation);
    __privateSet(this, _ignoreForbiddenWords, !!options.ignoreForbiddenWords);
    if (__privateGet(this, _ignoreForbiddenWords)) {
      __privateGet(this, _findWordOptionsCaseSensitive).checkForbidden = true;
      __privateGet(this, _findWordOptionsNotCaseSensitive).checkForbidden = true;
    }
  }
  get size() {
    if (!this._size) {
      const i = this.trie.iterate();
      let deeper = true;
      let size = 0;
      for (let r = i.next(); !r.done; r = i.next(deeper)) {
        size += 1;
        deeper = r.value.text.length < 5;
      }
      this._size = size;
    }
    return this._size;
  }
  has(word, hasOptions) {
    const { useCompounds, ignoreCase: ignoreCase2 } = this.resolveOptions(hasOptions);
    const r = this._find(word, useCompounds, ignoreCase2, void 0);
    return r && !r.forbidden && !!r.found || false;
  }
  find(word, hasOptions) {
    const { useCompounds, ignoreCase: ignoreCase2 } = this.resolveOptions(hasOptions);
    const r = this._find(word, useCompounds, ignoreCase2, hasOptions == null ? void 0 : hasOptions.compoundSeparator);
    const { forbidden = __privateMethod(this, _SpellingDictionaryFromTrie_instances, isForbidden_fn).call(this, word) } = r || {};
    if (__privateGet(this, _ignoreForbiddenWords) && forbidden) {
      return void 0;
    }
    if (!r && !forbidden)
      return void 0;
    const { found = forbidden ? word : false } = r || {};
    const noSuggest = found !== false && this.containsNoSuggestWords;
    return { found, forbidden, noSuggest };
  }
  resolveOptions(hasOptions) {
    const { useCompounds = this.options.useCompounds, ignoreCase: ignoreCase2 = ignoreCase } = hasOptionToSearchOption(hasOptions);
    return { useCompounds, ignoreCase: ignoreCase2 };
  }
  findAnyForm(word, useCompounds, ignoreCase2, compoundSeparator) {
    const outerForms = outerWordForms(word, this.repMapper);
    for (const form of outerForms) {
      const r = this._findAnyForm(form, useCompounds, ignoreCase2, compoundSeparator);
      if (r)
        return r;
    }
    return void 0;
  }
  _findAnyForm(mWord, useCompounds, ignoreCase2, compoundSeparator) {
    let opts = ignoreCase2 ? __privateGet(this, _findWordOptionsNotCaseSensitive) : __privateGet(this, _findWordOptionsCaseSensitive);
    if (compoundSeparator) {
      opts = { ...opts, compoundSeparator };
    }
    const findResult = this.trie.findWord(mWord, opts);
    if (findResult.found !== false) {
      return findResult;
    }
    const forms2 = wordSearchForms(mWord, this.isDictionaryCaseSensitive, ignoreCase2);
    for (const w of forms2) {
      const findResult2 = this.trie.findWord(w, opts);
      if (findResult2.found !== false) {
        return findResult2;
      }
    }
    if (useCompounds) {
      const optsUseCompounds = { ...opts, useLegacyWordCompounds: useCompounds };
      for (const w of forms2) {
        const findResult2 = this.trie.findWord(w, optsUseCompounds);
        if (findResult2.found !== false) {
          return findResult2;
        }
      }
    }
    return void 0;
  }
  isNoSuggestWord(word, options) {
    return this.containsNoSuggestWords ? this.has(word, options) : false;
  }
  isForbidden(word, _ignoreCaseAndAccents) {
    return __privateGet(this, _ignoreForbiddenWords) ? false : __privateMethod(this, _SpellingDictionaryFromTrie_instances, isForbidden_fn).call(this, word, _ignoreCaseAndAccents);
  }
  suggest(word, suggestOptions = {}) {
    return this._suggest(word, suggestOptions);
  }
  _suggest(word, suggestOptions) {
    const { numSuggestions = defaultNumSuggestions, numChanges, includeTies, ignoreCase: ignoreCase2, timeout } = suggestOptions;
    function filter2(_word) {
      return true;
    }
    const collector = suggestionCollector(word, clean3({
      numSuggestions,
      filter: filter2,
      changeLimit: numChanges,
      includeTies,
      ignoreCase: ignoreCase2,
      timeout,
      weightMap: this.weightMap
    }));
    this.genSuggestions(collector, suggestOptions);
    return collector.suggestions.map((r) => ({ ...r, word: r.word }));
  }
  genSuggestions(collector, suggestOptions) {
    var _a19;
    if (this.options.noSuggest)
      return;
    const _compoundMethod = (_a19 = suggestOptions.compoundMethod) != null ? _a19 : this.options.useCompounds ? CompoundWordsMethod.JOIN_WORDS : CompoundWordsMethod.NONE;
    for (const w of wordSuggestForms(collector.word)) {
      this.trie.genSuggestions(impersonateCollector(collector, w), _compoundMethod);
    }
  }
  getPreferredSuggestions(word) {
    if (!this.trie.hasPreferredSuggestions)
      return [];
    const sugs = [...this.trie.getPreferredSuggestions(word)];
    return sugs.map((sug, i) => ({ word: sug, cost: i + 1, isPreferred: true }));
  }
  getErrors() {
    return [];
  }
};
_ignoreForbiddenWords = new WeakMap();
_findWordOptionsCaseSensitive = new WeakMap();
_findWordOptionsNotCaseSensitive = new WeakMap();
_SpellingDictionaryFromTrie_instances = new WeakSet();
isForbidden_fn = function(word, _ignoreCaseAndAccents) {
  return this.trie.isForbiddenWord(word);
};
function createSpellingDictionaryFromTrieFile(data, name, source, options) {
  const endPerf = measurePerf("createSpellingDictionaryFromTrieFile");
  const trie = decodeTrie(data);
  const d = new SpellingDictionaryFromTrie(trie, name, options, source);
  endPerf();
  return d;
}
var isAsciiRange = /^[\u0000-\u007F]*$/;
function* outerWordForms(word, repMapper) {
  const sent = /* @__PURE__ */ new Set();
  let w = word;
  const ww = w;
  yield w;
  if (!isAsciiRange.test(w)) {
    sent.add(w);
    w = word.normalize("NFC");
    if (w !== ww) {
      yield w;
      sent.add(w);
    }
    w = word.normalize("NFD");
    if (w !== ww && !sent.has(w)) {
      yield w;
      sent.add(w);
    }
  }
  if (!repMapper)
    return;
  const mapWord = repMapper.fn;
  if (!sent.size) {
    if (!repMapper.test.test(ww))
      return;
    for (const m of mapWord(ww)) {
      if (m !== ww && !sent.has(m)) {
        yield m;
        sent.add(m);
      }
    }
    return;
  }
  for (const f of sent) {
    for (const m of mapWord(f)) {
      if (m !== ww && !sent.has(m)) {
        yield m;
        sent.add(m);
      }
    }
  }
  return;
}

// ../../node_modules/cspell-dictionary/dist/SpellingDictionary/createSpellingDictionary.js
var cachedDictionaries = new AutoWeakCache(_createSpellingDictionary, 64);
var maxSetSize = 3;
var cachedParamsByWordList = new SimpleCache(64);
function createSpellingDictionary(wordList, name, source, options, disableSuggestionsHandling) {
  const params = [
    wordList,
    name,
    source.toString(),
    options,
    disableSuggestionsHandling
  ];
  if (!Array.isArray(wordList)) {
    return _createSpellingDictionary(params);
  }
  const cached = cachedParamsByWordList.get(name) || /* @__PURE__ */ new Set();
  for (const cachedParams of cached) {
    if (deepEqual(params, cachedParams)) {
      return cachedDictionaries.get(cachedParams);
    }
  }
  if (cached.size > maxSetSize)
    cached.clear();
  cached.add(params);
  cachedParamsByWordList.set(name, cached);
  return cachedDictionaries.get(params);
}
function _createSpellingDictionary(params) {
  var _a19;
  const n = "";
  const endPerf = measurePerf("createSpellingDictionary" + n);
  const [wordList, name, source, options, disableSuggestionHandling = false] = params;
  const parseOptions = { stripCaseAndAccents: (_a19 = options == null ? void 0 : options.supportNonStrictSearches) != null ? _a19 : true, disableSuggestionHandling };
  const words = parseDictionaryLines(wordList, parseOptions);
  const trie = buildITrieFromWords(words);
  const opts = { ...options || defaultOptions };
  if (opts.weightMap === void 0 && opts.dictionaryInformation) {
    opts.weightMap = createWeightMapFromDictionaryInformation(opts.dictionaryInformation);
  }
  const d = new SpellingDictionaryFromTrie(trie, name, opts, source);
  endPerf();
  return d;
}
function createFailedToLoadDictionary(name, sourceUrl, error, options) {
  const sourceHref = typeof sourceUrl === "string" ? sourceUrl : sourceUrl.href;
  const source = sourceHref.startsWith("file:") ? (0, import_node_url4.fileURLToPath)(sourceUrl) : sourceHref;
  options = options || {};
  return {
    name,
    source,
    type: "error",
    containsNoSuggestWords: false,
    has: () => false,
    find: () => void 0,
    isNoSuggestWord: () => false,
    isForbidden: () => false,
    suggest: () => [],
    mapWord: void 0,
    genSuggestions: () => {
      return;
    },
    size: 0,
    options,
    isDictionaryCaseSensitive: false,
    getErrors: () => [error]
  };
}

// ../../node_modules/cspell-dictionary/dist/SpellingDictionary/FlagWordsDictionary.js
init_shim();

// ../../node_modules/cspell-dictionary/dist/SpellingDictionary/TyposDictionary.js
init_shim();

// ../../node_modules/cspell-dictionary/dist/util/textMappers.js
init_shim();
function* mapperRemoveCaseAndAccents(words) {
  for (const word of words) {
    const lc = word.toLowerCase();
    yield lc;
    const woAccents = removeAccents(lc);
    if (lc !== woAccents)
      yield woAccents;
  }
}

// ../../node_modules/cspell-dictionary/dist/SpellingDictionary/Typos/index.js
init_shim();

// ../../node_modules/cspell-dictionary/dist/SpellingDictionary/Typos/typosParser.js
init_shim();

// ../../node_modules/cspell-dictionary/dist/SpellingDictionary/Typos/util.js
init_shim();
function normalizeTyposDefValue(value) {
  if (!value)
    return false;
  if (typeof value === "string")
    return value;
  const unique2 = [...new Set(value)];
  return unique2.length > 1 ? unique2 : unique2.length === 1 ? unique2[0] : false;
}
function mergeDefEntry(targetDef, key, value) {
  const curValue = targetDef[key];
  if (!curValue) {
    targetDef[key] = normalizeTyposDefValue(value);
    return targetDef;
  }
  if (!value)
    return targetDef;
  const newValue = Array.isArray(curValue) ? curValue : [curValue];
  if (Array.isArray(value)) {
    newValue.push(...value);
  } else {
    newValue.push(value);
  }
  targetDef[key] = normalizeTyposDefValue(newValue);
  return targetDef;
}
function mergeDef(targetDef, fromDef) {
  for (const key of Object.keys(fromDef)) {
    mergeDefEntry(targetDef, key, fromDef[key]);
  }
  return targetDef;
}
function appendToDef(def, entry) {
  if (!entry)
    return def;
  if (typeof entry === "string") {
    if (!def[entry]) {
      def[entry] = false;
    }
    return def;
  }
  if (Array.isArray(entry)) {
    const [key, ...sugs] = entry.map((s2) => s2.trim());
    if (!key)
      return def;
    const s = sugs.map((s2) => s2.trim()).filter((s2) => !!s2);
    return mergeDefEntry(def, key, s);
  }
  return mergeDef(def, entry);
}
function createTyposDef(entries) {
  const def = /* @__PURE__ */ Object.create(null);
  if (!entries)
    return def;
  for (const [key, value] of entries) {
    def[key] = isDefined3(value) ? value : false;
  }
  return def;
}
function extractAllSuggestions(typosDef) {
  const allSugs = pipeSync2(Object.values(typosDef), opFilterSync2(hasSuggestions), opConcatMapSync2((v) => Array.isArray(v) ? v : [v]));
  return new Set(allSugs);
}
function extractIgnoreValues(typosDef, ignorePrefix) {
  const pfxLen = ignorePrefix.length;
  return new Set(Object.keys(typosDef).filter((k) => k.startsWith(ignorePrefix)).map((k) => k.slice(pfxLen)));
}
function isDefined3(v) {
  return v !== void 0 && v !== null;
}
function isString(v) {
  return typeof v === "string";
}
function isArray(v) {
  return Array.isArray(v);
}
function hasSuggestions(v) {
  return isString(v) || isArray(v);
}
function assert7(condition, message = "Assert Failed") {
  if (condition)
    return;
  throw new Error(message);
}

// ../../node_modules/cspell-dictionary/dist/SpellingDictionary/Typos/typosParser.js
function assertString(v) {
  assert7(typeof v === "string", "A string was expected.");
  return true;
}
var suggestionsSeparator = /[,]/;
var typoEntrySeparator = /[\n;]/;
var sugFormatRegex = /^\s*(?:[!~:])*(?<word>.*?)(?<separator>(->|:([0-9a-f]{1,2}:)?))(?<sugs>.*)$/;
function normalize3(s) {
  return s.normalize();
}
function trimAndFilter(lines) {
  return lines.map((s) => s.trim()).filter((s) => !!s).map(normalize3);
}
function cleanSugs(rawSugs) {
  const sugs = trimAndFilter(rawSugs);
  return sugs.length === 1 ? sugs[0] : sugs.length ? sugs : false;
}
function splitSuggestionsValue(value) {
  return cleanSugs(value.split(suggestionsSeparator));
}
function sanitizeIntoTypoDef(dirtyDef) {
  if (!dirtyDef || typeof dirtyDef !== "object")
    return void 0;
  const def = createTyposDef();
  for (const [rawKey, value] of Object.entries(dirtyDef)) {
    const key = normalize3(rawKey.trim());
    if (!key)
      continue;
    if (typeof value === "string") {
      def[key] = splitSuggestionsValue(value);
      continue;
    }
    if (Array.isArray(value)) {
      const sugs = cleanSugs(value.filter(assertString));
      def[key] = sugs;
      continue;
    }
    assert7(value === false, "Unexpected suggestion type.");
    def[key] = false;
  }
  return def;
}
function processEntriesToTyposDef(entries) {
  const def = isIterable2(entries) ? reduceToTyposDef(entries) : entries;
  const result = sanitizeIntoTypoDef(def);
  assert7(result);
  return result;
}
function reduceToTyposDef(entries) {
  const def = createTyposDef();
  for (const entry of entries) {
    appendToDef(def, parseTyposLine(entry));
  }
  return def;
}
function parseTyposLine(line) {
  if (!line)
    return void 0;
  if (typeof line === "string") {
    const def = createTyposDef();
    for (const subEntry of splitIntoLines(line)) {
      const [left, right] = splitEntry(subEntry);
      const typo = left.trim();
      if (!right)
        return typo;
      const sugs = splitSuggestionsValue(right);
      def[typo] = sugs;
    }
    return def;
  }
  if (Array.isArray(line)) {
    const [key, ...sugs] = line.filter(assertString).map((s) => s.trim());
    if (!key)
      return void 0;
    return [key, ...sugs];
  }
  return sanitizeIntoTypoDef(line);
}
function splitIntoLines(content) {
  return trimAndFilter(normalize3(content).split(typoEntrySeparator));
}
function splitEntry(line) {
  const m = line.match(sugFormatRegex);
  if (!(m == null ? void 0 : m.groups)) {
    return [line.trim(), void 0];
  }
  return [m.groups.word.trim(), m.groups.sugs.trim()];
}
function isIterable2(v) {
  return Symbol.iterator in v;
}

// ../../node_modules/cspell-dictionary/dist/SpellingDictionary/TyposDictionary.js
var TyposDictionaryImpl = class {
  constructor(name, source, typosDef, ignoreList) {
    __publicField(this, "name");
    __publicField(this, "source");
    __publicField(this, "typosDef");
    __publicField(this, "containsNoSuggestWords");
    __publicField(this, "options", {});
    __publicField(this, "type", "typos");
    __publicField(this, "size");
    __publicField(this, "mapWord");
    __publicField(this, "ignoreWords");
    /**
     * Note: ignoreWordsLower is only suggestions with the case and accents removed.
     * The logic is that if someone explicity ignored an upper case version, it does not
     * mean that the lower case version is ok.
     */
    __publicField(this, "suggestions");
    __publicField(this, "suggestionsLower");
    __publicField(this, "explicitIgnoreWords");
    __publicField(this, "isDictionaryCaseSensitive", true);
    this.name = name;
    this.source = source;
    this.typosDef = typosDef;
    this.size = Object.keys(typosDef).length;
    this.explicitIgnoreWords = extractIgnoreValues(typosDef, "!");
    this.suggestions = extractAllSuggestions(typosDef);
    this.ignoreWords = new Set(pipeSync2(this.explicitIgnoreWords, opAppendSync2(ignoreList || [])));
    this.suggestionsLower = new Set(pipeSync2(this.suggestions, mapperRemoveCaseAndAccents));
    this.containsNoSuggestWords = this.ignoreWords.size > 0;
  }
  /**
   * A Forbidden word list does not "have" valid words.
   * Therefore it always returns false.
   * @param _word - the word
   * @param _options - options
   * @returns always false
   */
  has(_word, _options) {
    return false;
  }
  /** A more detailed search for a word, might take longer than `has` */
  find(word, options) {
    var _a19;
    const result = this._findForms(word, (_a19 = options == null ? void 0 : options.ignoreCase) != null ? _a19 : ignoreCase);
    if (result === false)
      return void 0;
    const { found, ignore } = result;
    return { found, forbidden: !ignore, noSuggest: ignore };
  }
  _findForms(word, ignoreCaseAndAccents) {
    const lcWord = word.toLowerCase();
    if (this.ignoreWords.has(word)) {
      return { found: word, ignore: true };
    }
    if (this.suggestions.has(word)) {
      return false;
    }
    if (ignoreCaseAndAccents) {
      if (this.suggestionsLower.has(lcWord)) {
        return false;
      }
      if (this.ignoreWords.has(lcWord)) {
        return { found: lcWord, ignore: true };
      }
    }
    if (word in this.typosDef)
      return { found: word, ignore: false };
    if (lcWord in this.typosDef)
      return { found: lcWord, ignore: false };
    return false;
  }
  isForbidden(word, ignoreCaseAndAccents = isForbiddenIgnoreCaseAndAccents) {
    const found = this._findForms(word, ignoreCaseAndAccents);
    return found !== false && !found.ignore;
  }
  isNoSuggestWord(word, options) {
    var _a19;
    const result = this.find(word, options);
    return (_a19 = result == null ? void 0 : result.noSuggest) != null ? _a19 : false;
  }
  /**
   * Determine if the word can appear in a list of suggestions.
   * @param word - word
   * @param ignoreCaseAndAccents - ignore case.
   * @returns true if a word is suggested, otherwise false.
   */
  isSuggestedWord(word, ignoreCaseAndAccents = isForbiddenIgnoreCaseAndAccents) {
    if (this.suggestions.has(word))
      return true;
    const lcWord = word.toLowerCase();
    return ignoreCaseAndAccents && (this.suggestions.has(lcWord) || this.suggestionsLower.has(lcWord));
  }
  suggest(word) {
    return this.getPreferredSuggestions(word);
  }
  _suggest(word) {
    if (this.ignoreWords.has(word))
      return [];
    if (!(word in this.typosDef))
      return void 0;
    const sug = this.typosDef[word];
    const isPreferred = true;
    if (!sug)
      return [];
    if (typeof sug === "string") {
      return [
        {
          word: sug,
          cost: 1,
          isPreferred
        }
      ];
    }
    return sug.map((word2, index) => ({ word: word2, cost: index + 1, isPreferred }));
  }
  genSuggestions(collector) {
    const sugs = this.suggest(collector.word);
    sugs.forEach((result) => collector.add(result));
  }
  getPreferredSuggestions(word) {
    return this._suggest(word) || this._suggest(word.toLowerCase()) || [];
  }
  getErrors() {
    return [];
  }
};
var createCache = createAutoResolveWeakCache2();
function createTyposDictionary(entries, name, source) {
  return createCache.get(entries, () => {
    const def = processEntriesToTyposDef(entries);
    return new TyposDictionaryImpl(name, source, def);
  });
}

// ../../node_modules/cspell-dictionary/dist/SpellingDictionary/FlagWordsDictionary.js
var FlagWordsDictionaryTrie = class extends SpellingDictionaryFromTrie {
  constructor(trie, name, source) {
    super(trie, name, defaultOptions, source);
    __publicField(this, "name");
    __publicField(this, "source");
    __publicField(this, "containsNoSuggestWords", false);
    __publicField(this, "options", {});
    __publicField(this, "isDictionaryCaseSensitive", true);
    this.name = name;
    this.source = source;
  }
  /**
   * A Forbidden word list does not "have" valid words.
   * Therefore it always returns false.
   * @param _word - the word
   * @param _options - options
   * @returns always false
   */
  has(_word, _options) {
    return false;
  }
  find(word, hasOptions) {
    const f = super.find(word, hasOptions);
    if (!f || !f.forbidden)
      return void 0;
    return f;
  }
  suggest() {
    return [];
  }
  genSuggestions() {
    return;
  }
  terms() {
    return this.trie.words();
  }
};
var FlagWordsDictionary = class {
  constructor(name, source, dictTypos, dictTrie) {
    __publicField(this, "name");
    __publicField(this, "source");
    __publicField(this, "dictTypos");
    __publicField(this, "dictTrie");
    __publicField(this, "containsNoSuggestWords", false);
    __publicField(this, "options", {});
    __publicField(this, "type", "flag-words");
    __publicField(this, "mapWord");
    __publicField(this, "isDictionaryCaseSensitive", true);
    this.name = name;
    this.source = source;
    this.dictTypos = dictTypos;
    this.dictTrie = dictTrie;
  }
  /**
   * A Forbidden word list does not "have" valid words.
   * Therefore it always returns false.
   * @param word - the word
   * @param options - options
   * @returns always false
   */
  has(word, options) {
    var _a19;
    return this.dictTypos.has(word, options) || ((_a19 = this.dictTrie) == null ? void 0 : _a19.has(word, options)) || false;
  }
  /** A more detailed search for a word, might take longer than `has` */
  find(word, options) {
    var _a19, _b2;
    const findTypos = this.dictTypos.find(word, options);
    if (findTypos)
      return findTypos;
    const ignoreCase2 = (_a19 = options == null ? void 0 : options.ignoreCase) != null ? _a19 : ignoreCase;
    if (this.dictTypos.isSuggestedWord(word, ignoreCase2))
      return void 0;
    return (_b2 = this.dictTrie) == null ? void 0 : _b2.find(word, options);
  }
  isForbidden(word, ignoreCaseAndAccents = isForbiddenIgnoreCaseAndAccents) {
    const findResult = this.find(word, { ignoreCase: ignoreCaseAndAccents });
    return (findResult == null ? void 0 : findResult.forbidden) || false;
  }
  isNoSuggestWord(word, options) {
    var _a19;
    return ((_a19 = this.dictTrie) == null ? void 0 : _a19.isNoSuggestWord(word, options)) || this.dictTypos.isNoSuggestWord(word, options);
  }
  suggest(word, suggestOptions = {}) {
    return this.dictTypos.suggest(word, suggestOptions);
  }
  getPreferredSuggestions(word) {
    return this.dictTypos.getPreferredSuggestions(word);
  }
  genSuggestions() {
    return;
  }
  get size() {
    var _a19;
    return this.dictTypos.size + (((_a19 = this.dictTrie) == null ? void 0 : _a19.size) || 0);
  }
  getErrors() {
    return [];
  }
  *terms() {
    if (this.dictTrie) {
      yield* this.dictTrie.terms();
      return;
    }
    return;
  }
};
var createCache2 = createAutoResolveWeakCache2();
function createFlagWordsDictionary(wordList, name, source) {
  return createCache2.get(wordList, () => {
    const testSpecialCharacters = /[~*+]/;
    const { t: specialWords, f: typoWords } = bisect(parseDictionaryLines(wordList, { stripCaseAndAccents: false }), (line) => testSpecialCharacters.test(line));
    const trie = parseDictionary(specialWords, { stripCaseAndAccents: false, makeWordsForbidden: true });
    const trieDict = new FlagWordsDictionaryTrie(trie, name, source);
    const typosDict = createTyposDictionary(typoWords, name, source);
    if (!specialWords.size)
      return typosDict;
    return new FlagWordsDictionary(name, source, typosDict, trieDict);
  });
}
function bisect(values, predicate) {
  const t = /* @__PURE__ */ new Set();
  const f = /* @__PURE__ */ new Set();
  for (const v of values) {
    if (predicate(v)) {
      t.add(v);
    } else {
      f.add(v);
    }
  }
  return { t, f };
}

// ../../node_modules/cspell-dictionary/dist/SpellingDictionary/IgnoreWordsDictionary.js
init_shim();
var NormalizeForm = "NFC";
var IgnoreWordsDictionary = class {
  constructor(name, source, words) {
    __publicField(this, "name");
    __publicField(this, "source");
    __publicField(this, "dict");
    __publicField(this, "dictNonStrict");
    __publicField(this, "containsNoSuggestWords", true);
    __publicField(this, "options", {});
    __publicField(this, "type", "ignore");
    __publicField(this, "mapWord");
    __publicField(this, "isDictionaryCaseSensitive", true);
    this.name = name;
    this.source = source;
    this.dict = new Set(words);
    this.dictNonStrict = new Set(pipeSync2(this.dict, opFilterSync2((w) => w.startsWith("~")), opMapSync2((w) => w.slice(1))));
  }
  /**
   * A Forbidden word list does not "have" valid words.
   * Therefore it always returns false.
   * @param _word - the word
   * @param _options - options
   * @returns always false
   */
  has(word, options) {
    var _a19;
    const nWord = word.normalize(NormalizeForm);
    if (this.dict.has(nWord))
      return true;
    const lcWord = nWord.toLowerCase();
    if (this.dict.has(lcWord))
      return true;
    const ignoreCase2 = (_a19 = options == null ? void 0 : options.ignoreCase) != null ? _a19 : ignoreCase;
    return ignoreCase2 && (this.dictNonStrict.has(nWord) || this.dictNonStrict.has(lcWord));
  }
  /** A more detailed search for a word, might take longer than `has` */
  find(word, options) {
    var _a19;
    const nWord = word.normalize(NormalizeForm);
    if (this.dict.has(nWord))
      return { found: nWord, forbidden: false, noSuggest: true };
    const lcWord = nWord.toLowerCase();
    if (this.dict.has(lcWord))
      return { found: lcWord, forbidden: false, noSuggest: true };
    const ignoreCase2 = (_a19 = options == null ? void 0 : options.ignoreCase) != null ? _a19 : ignoreCase;
    if (!ignoreCase2)
      return void 0;
    if (this.dictNonStrict.has(nWord))
      return { found: nWord, forbidden: false, noSuggest: true };
    return this.dictNonStrict.has(lcWord) && { found: lcWord, forbidden: false, noSuggest: true } || void 0;
  }
  isForbidden(_word, _ignoreCase) {
    return false;
  }
  isNoSuggestWord(word, options) {
    return this.has(word, options);
  }
  suggest() {
    return [];
  }
  genSuggestions() {
    return;
  }
  get size() {
    return this.dict.size;
  }
  getErrors() {
    return [];
  }
};
var createCache3 = createAutoResolveWeakCache2();
function createIgnoreWordsDictionary(wordList, name, source, options) {
  return createCache3.get(wordList, () => {
    var _a19;
    const testSpecialCharacters = /[*+]/;
    const parseOptions = { stripCaseAndAccents: (_a19 = options == null ? void 0 : options.supportNonStrictSearches) != null ? _a19 : true };
    const words = [...parseDictionaryLines(wordList, parseOptions)].map((w) => w.normalize(NormalizeForm));
    const hasSpecial = words.some((word) => testSpecialCharacters.test(word));
    if (hasSpecial) {
      return createSpellingDictionary(words, name, source, {
        caseSensitive: true,
        noSuggest: true,
        weightMap: void 0,
        supportNonStrictSearches: true
      });
    }
    return new IgnoreWordsDictionary(name, source, words);
  });
}

// ../../node_modules/cspell-dictionary/dist/SpellingDictionary/SpellingDictionaryCollection.js
init_shim();
var SpellingDictionaryCollectionImpl = class {
  constructor(dictionaries, name, source) {
    __publicField(this, "dictionaries");
    __publicField(this, "name");
    __publicField(this, "options", { weightMap: void 0 });
    __publicField(this, "mapWord");
    __publicField(this, "type", "SpellingDictionaryCollection");
    __publicField(this, "source");
    __publicField(this, "isDictionaryCaseSensitive");
    __publicField(this, "containsNoSuggestWords");
    __publicField(this, "_isNoSuggestWord", (word, options) => {
      if (!this.containsNoSuggestWords)
        return false;
      return !!isNoSuggestWordInAnyDictionary(this.dictionaries, word, options || {});
    });
    this.dictionaries = dictionaries;
    this.name = name;
    this.dictionaries = this.dictionaries.sort((a, b) => b.size - a.size);
    this.source = source || dictionaries.map((d) => d.name).join(", ");
    this.isDictionaryCaseSensitive = this.dictionaries.reduce((a, b) => a || b.isDictionaryCaseSensitive, false);
    this.containsNoSuggestWords = this.dictionaries.reduce((a, b) => a || b.containsNoSuggestWords, false);
  }
  has(word, hasOptions) {
    const options = hasOptionToSearchOption(hasOptions);
    return !!isWordInAnyDictionary(this.dictionaries, word, options) && !this.isForbidden(word);
  }
  find(word, hasOptions) {
    const options = hasOptionToSearchOption(hasOptions);
    return findInAnyDictionary(this.dictionaries, word, options);
  }
  isNoSuggestWord(word, options) {
    return this._isNoSuggestWord(word, options);
  }
  isForbidden(word, ignoreCaseAndAccents) {
    const ignoreCase2 = ignoreCaseAndAccents != null ? ignoreCaseAndAccents : isForbiddenIgnoreCaseAndAccents;
    return !!this._isForbiddenInDict(word, ignoreCase2) && !this.isNoSuggestWord(word, { ignoreCase: ignoreCase2 });
  }
  suggest(word, suggestOptions = {}) {
    return this._suggest(word, suggestOptions);
  }
  _suggest(word, suggestOptions) {
    const { numSuggestions = defaultNumSuggestions, numChanges, ignoreCase: ignoreCase2, includeTies, timeout } = suggestOptions;
    const prefixNoCase = CASE_INSENSITIVE_PREFIX;
    const filter2 = (word2, _cost) => {
      return (ignoreCase2 || word2[0] !== prefixNoCase) && !this.isForbidden(word2) && !this.isNoSuggestWord(word2, suggestOptions);
    };
    const collectorOptions = {
      numSuggestions,
      filter: filter2,
      changeLimit: numChanges,
      includeTies,
      ignoreCase: ignoreCase2,
      timeout
    };
    const collector = suggestionCollector(word, collectorOptions);
    this.genSuggestions(collector, suggestOptions);
    return collector.suggestions;
  }
  get size() {
    return this.dictionaries.reduce((a, b) => a + b.size, 0);
  }
  getPreferredSuggestions(word) {
    const sugs = this.dictionaries.flatMap((dict) => {
      var _a19;
      return (_a19 = dict.getPreferredSuggestions) == null ? void 0 : _a19.call(dict, word);
    }).filter(isDefined2);
    if (sugs.length <= 1)
      return sugs;
    const unique2 = /* @__PURE__ */ new Set();
    return sugs.filter((sug) => {
      if (unique2.has(sug.word))
        return false;
      unique2.add(sug.word);
      return true;
    });
  }
  genSuggestions(collector, suggestOptions) {
    const _suggestOptions = { ...suggestOptions };
    const { compoundMethod = CompoundWordsMethod.SEPARATE_WORDS } = suggestOptions;
    _suggestOptions.compoundMethod = this.options.useCompounds ? CompoundWordsMethod.JOIN_WORDS : compoundMethod;
    this.dictionaries.forEach((dict) => dict.genSuggestions(collector, _suggestOptions));
  }
  getErrors() {
    return this.dictionaries.reduce((errors, dict) => {
      var _a19;
      return [...errors, ...((_a19 = dict.getErrors) == null ? void 0 : _a19.call(dict)) || []];
    }, []);
  }
  _isForbiddenInDict(word, ignoreCase2) {
    return isWordForbiddenInAnyDictionary(this.dictionaries, word, ignoreCase2);
  }
};
function createCollection(dictionaries, name, source) {
  return new SpellingDictionaryCollectionImpl(dictionaries, name, source);
}
function isWordInAnyDictionary(dicts, word, options) {
  return dicts.find((dict) => dict.has(word, options));
}
function findInAnyDictionary(dicts, word, options) {
  const found = dicts.map((dict) => dict.find(word, options)).filter(isDefined2);
  if (!found.length)
    return void 0;
  return found.reduce((a, b) => ({
    found: a.forbidden ? a.found : b.forbidden ? b.found : a.found || b.found,
    forbidden: a.forbidden || b.forbidden,
    noSuggest: a.noSuggest || b.noSuggest
  }));
}
function isNoSuggestWordInAnyDictionary(dicts, word, options) {
  return dicts.find((dict) => dict.isNoSuggestWord(word, options));
}
function isWordForbiddenInAnyDictionary(dicts, word, ignoreCase2) {
  return dicts.find((dict) => dict.isForbidden(word, ignoreCase2));
}

// ../../node_modules/cspell-dictionary/dist/SpellingDictionary/SuggestDictionary.js
init_shim();
var SuggestDictionaryImpl = class {
  constructor(name, source, typosDef) {
    __publicField(this, "name");
    __publicField(this, "source");
    __publicField(this, "typosDef");
    __publicField(this, "containsNoSuggestWords", false);
    __publicField(this, "options", {});
    __publicField(this, "type", "suggest");
    __publicField(this, "size");
    __publicField(this, "mapWord");
    /**
     * Note: ignoreWordsLower is only suggestions with the case and accents removed.
     * The logic is that if someone explicity ignored an upper case version, it does not
     * mean that the lower case version is ok.
     */
    __publicField(this, "suggestions");
    __publicField(this, "suggestionsLower");
    __publicField(this, "isDictionaryCaseSensitive", true);
    this.name = name;
    this.source = source;
    this.typosDef = typosDef;
    this.size = Object.keys(typosDef).length;
    this.suggestions = extractAllSuggestions(typosDef);
    this.suggestionsLower = new Set(pipeSync2(this.suggestions, mapperRemoveCaseAndAccents));
  }
  /**
   * A Forbidden word list does not "have" valid words.
   * Therefore it always returns false.
   * @param _word - the word
   * @param _options - options
   * @returns always false
   */
  has(_word, _options) {
    return false;
  }
  /** A more detailed search for a word, might take longer than `has` */
  find(_word, _options) {
    return void 0;
  }
  isForbidden(_word, _ignoreCaseAndAccents) {
    return false;
  }
  isNoSuggestWord(_word, _options) {
    return false;
  }
  /**
   * Determine if the word can appear in a list of suggestions.
   * @param word - word
   * @param ignoreCaseAndAccents - ignore case.
   * @returns true if a word is suggested, otherwise false.
   */
  isSuggestedWord(word, ignoreCaseAndAccents = isForbiddenIgnoreCaseAndAccents) {
    if (this.suggestions.has(word))
      return true;
    if (!ignoreCaseAndAccents)
      return false;
    const lcWord = word.toLowerCase();
    return this.suggestions.has(lcWord) || this.suggestionsLower.has(lcWord);
  }
  suggest(word) {
    return this.getPreferredSuggestions(word);
  }
  _suggest(word) {
    if (!(word in this.typosDef))
      return void 0;
    const sug = this.typosDef[word];
    const isPreferred = true;
    if (!sug)
      return [];
    if (typeof sug === "string") {
      return [
        {
          word: sug,
          cost: 1,
          isPreferred
        }
      ];
    }
    return sug.map((word2, index) => ({ word: word2, cost: index + 1, isPreferred }));
  }
  getPreferredSuggestions(word) {
    return this._suggest(word) || this._suggest(word.toLowerCase()) || [];
  }
  genSuggestions(collector) {
    const sugs = this.suggest(collector.word);
    sugs.forEach((result) => collector.add(result));
  }
  getErrors() {
    return [];
  }
};
var createCache4 = createAutoResolveWeakCache2();
function createSuggestDictionary(entries, name, source) {
  return createCache4.get(entries, () => {
    const def = processEntriesToTyposDef(entries);
    return new SuggestDictionaryImpl(name, source, def);
  });
}

// ../../node_modules/cspell-dictionary/dist/SpellingDictionary/createInlineSpellingDictionary.js
var cache2 = createAutoResolveWeakCache2();
function createInlineSpellingDictionary(inlineDict, source) {
  return cache2.get(inlineDict, () => {
    const { words, flagWords, ignoreWords, suggestWords, name, supportNonStrictSearches } = inlineDict;
    const options = { supportNonStrictSearches };
    const dictSources = [
      words && createSpellingDictionary(words, name + "-words", source, inlineDict),
      flagWords && createFlagWordsDictionary(flagWords, name + "-flag-words", source),
      ignoreWords && createIgnoreWordsDictionary(ignoreWords, name + "-ignore-words", source, options),
      suggestWords && createSuggestDictionary(suggestWords, name + "-suggest", source)
    ].filter(isDefined2);
    return createCollection(dictSources, name, source);
  });
}

// ../../node_modules/cspell-lib/dist/lib/SpellingDictionary/DictionaryLoader.js
init_shim();

// ../../node_modules/cspell-lib/dist/lib/SpellingDictionary/DictionaryController/index.js
init_shim();

// ../../node_modules/cspell-lib/dist/lib/SpellingDictionary/DictionaryController/DictionaryLoader.js
init_shim();

// ../../node_modules/@cspell/strong-weak-map/dist/esm/index.js
init_shim();

// ../../node_modules/@cspell/strong-weak-map/dist/esm/StrongWeakMap.js
init_shim();
var _a18, _b;
var StrongWeakMap = class {
  constructor(init) {
    __publicField(this, "map");
    __publicField(this, _a18, "StrongWeakMap");
    this.map = new Map(init == null ? void 0 : init.map(([k, v]) => [k, new WeakRef(v)]));
  }
  clear() {
    this.map.clear();
  }
  /**
   * @returns true if an element in the Map existed and has been removed, or false if the element does not exist.
   */
  delete(key) {
    return this.map.delete(key);
  }
  /**
   * Executes a provided function once per each key/value pair in the Map, in insertion order.
   */
  forEach(callbackfn, thisArg) {
    if (thisArg) {
      callbackfn = callbackfn.bind(thisArg);
    }
    for (const [key, value] of this) {
      callbackfn(value, key, this);
    }
  }
  /**
   * Returns a specified element from the Map object. You will get a reference to the value object and any change made to that
   * object will effectively modify it inside the Map.
   * @returns Returns the element associated with the specified key.
   *   If no element is associated with the specified key, undefined is returned.
   */
  get(key) {
    const ref = this.map.get(key);
    if (!ref)
      return void 0;
    const value = ref.deref();
    if (!value) {
      this.map.delete(key);
      return void 0;
    }
    return value;
  }
  /**
   * Returns a specified element from the Map. If the element isn't found, the resolver function is called and the result is stored in the map and returned.
   */
  autoGet(key, resolver) {
    const found = this.get(key);
    if (found)
      return found;
    const created = resolver(key);
    this.set(key, created);
    return created;
  }
  /**
   * Note: has will cause the value object to live longer.
   * See: [WeakRef - JavaScript | MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef#notes_on_weakrefs)
   * @returns boolean indicating whether an element with the specified key exists or not.
   */
  has(key) {
    const value = this.get(key);
    return !!value;
  }
  /**
   * Adds a new element with a specified key and value to the Map. If an element with the same key already exists, the element will be updated.
   */
  set(key, value) {
    this.map.set(key, new WeakRef(value));
    return this;
  }
  /**
   * @returns the number of elements in the Map. Note: it is possible that some of the values have been dereferenced
   */
  get size() {
    return this.map.size;
  }
  /** Returns an iterable of entries in the map. */
  [(_b = Symbol.iterator, _a18 = Symbol.toStringTag, _b)]() {
    return this.entries();
  }
  /**
   * Returns an iterable of key, value pairs for every entry in the map.
   */
  *entries() {
    for (const key of this.map.keys()) {
      const value = this.get(key);
      if (!value)
        continue;
      yield [key, value];
    }
  }
  /**
   * Returns an iterable of keys in the map
   *
   * Note: It is possible that the value associated with the key was released.
   */
  keys() {
    return this.map.keys();
  }
  /**
   * Returns an iterable of values in the map
   */
  *values() {
    for (const [_, value] of this) {
      yield value;
    }
  }
  /**
   * Removes any keys that reference released objects.
   */
  cleanKeys() {
    const keysToDel = [];
    for (const [key, ref] of this.map.entries()) {
      if (!ref.deref()) {
        keysToDel.push(key);
      }
    }
    for (const key of keysToDel) {
      this.map.delete(key);
    }
    return this;
  }
};

// ../../node_modules/cspell-lib/dist/lib/util/simpleCache.js
init_shim();
var SimpleCache2 = class {
  constructor(size) {
    __publicField(this, "size");
    __publicField(this, "L0", /* @__PURE__ */ new Map());
    __publicField(this, "L1", /* @__PURE__ */ new Map());
    __publicField(this, "L2", /* @__PURE__ */ new Map());
    this.size = size;
  }
  has(key) {
    for (const c of this.caches()) {
      if (c.has(key))
        return true;
    }
    return false;
  }
  get(key) {
    for (const c of this.caches()) {
      const entry = c.get(key);
      if (entry) {
        if (c !== this.L0) {
          this._set(key, entry);
        }
        return entry.v;
      }
    }
    return void 0;
  }
  set(key, value) {
    this._set(key, { v: value });
  }
  delete(key) {
    let deleted = false;
    for (const c of this.caches()) {
      deleted = c.delete(key) || deleted;
    }
    return deleted;
  }
  _set(key, entry) {
    if (this.L0.has(key)) {
      this.L0.set(key, entry);
      return this;
    }
    if (this.L0.size >= this.size) {
      this.rotate();
    }
    this.L0.set(key, entry);
  }
  caches() {
    return [this.L0, this.L1, this.L2];
  }
  rotate() {
    const L2 = this.L2;
    this.L2 = this.L1;
    this.L1 = this.L0;
    this.L0 = L2;
    this.L0.clear();
  }
};
var AutoCache = class extends SimpleCache2 {
  constructor(factory, size) {
    super(size);
    __publicField(this, "factory");
    this.factory = factory;
  }
  get(key) {
    const v = super.get(key);
    if (v !== void 0)
      return v;
    const val = this.factory(key);
    this.set(key, val);
    return val;
  }
};

// ../../node_modules/cspell-lib/dist/lib/SpellingDictionary/SpellingDictionaryError.js
init_shim();
var SpellingDictionaryLoadError = class extends Error {
  constructor(uri, options, cause, message) {
    super(message);
    __publicField(this, "uri");
    __publicField(this, "options");
    __publicField(this, "cause");
    __publicField(this, "name");
    this.uri = uri;
    this.options = options;
    this.cause = cause;
    this.name = options.name;
  }
};

// ../../node_modules/cspell-lib/dist/lib/SpellingDictionary/DictionaryController/DictionaryLoader.js
var __addDisposableResource = function(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    env.stack.push({ value, dispose, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value;
};
var __disposeResources = /* @__PURE__ */ (function(SuppressedError2) {
  return function(env) {
    function fail(e) {
      env.error = env.hasError ? new SuppressedError2(e, env.error, "An error was suppressed during disposal.") : e;
      env.hasError = true;
    }
    var r, s = 0;
    function next() {
      while (r = env.stack.pop()) {
        try {
          if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
          if (r.dispose) {
            var result = r.dispose.call(r.value);
            if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
              fail(e);
              return next();
            });
          } else s |= 1;
        } catch (e) {
          fail(e);
        }
      }
      if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
      if (env.hasError) throw env.error;
    }
    return next();
  };
})(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
});
var MAX_AGE = 1e4;
var loaders = {
  S: loadSimpleWordList,
  C: legacyWordList,
  W: wordsPerLineWordList,
  T: loadTrie,
  default: loadSimpleWordList
};
var LoadingState;
(function(LoadingState2) {
  LoadingState2[LoadingState2["Loaded"] = 0] = "Loaded";
  LoadingState2[LoadingState2["Loading"] = 1] = "Loading";
})(LoadingState || (LoadingState = {}));
var DictionaryLoader = class {
  constructor(fs, keepAliveSize = 10) {
    __publicField(this, "fs");
    __publicField(this, "dictionaryCache", new StrongWeakMap());
    __publicField(this, "inlineDictionaryCache", new AutoResolveWeakCache());
    __publicField(this, "dictionaryCacheByDef", new AutoResolveWeakWeakCache());
    __publicField(this, "reader");
    /** The keepAliveCache is to hold onto the most recently loaded dictionaries. */
    __publicField(this, "keepAliveCache");
    this.fs = fs;
    this.reader = toReader(fs);
    this.keepAliveCache = new SimpleCache2(keepAliveSize);
  }
  loadDictionary(def) {
    if (isDictionaryDefinitionInlineInternal(def)) {
      return Promise.resolve(this.loadInlineDict(def));
    }
    if (isDictionaryFileDefinitionInternal(def)) {
      const { key, entry } = this.getCacheEntry(def);
      if (entry) {
        return entry.pending.then(([dictionary]) => dictionary);
      }
      const loadedEntry = this.loadEntry(def.btrie || def.path, def);
      this.setCacheEntry(key, loadedEntry, def);
      this.keepAliveCache.set(def, loadedEntry);
      return loadedEntry.pending.then(([dictionary]) => dictionary);
    }
    return Promise.resolve(this.loadSimpleDict(def));
  }
  /**
   * Check to see if any of the cached dictionaries have changed. If one has changed, reload it.
   * @param maxAge - Only check the dictionary if it has been at least `maxAge` ms since the last check.
   * @param now - optional timestamp representing now. (Mostly used in testing)
   */
  async refreshCacheEntries(maxAge = MAX_AGE, now = Date.now()) {
    await Promise.all([...this.dictionaryCache.values()].map((entry) => this.refreshEntry(entry, maxAge, now)));
  }
  getCacheEntry(def) {
    const defEntry = this.dictionaryCacheByDef.get(def);
    if (defEntry) {
      this.keepAliveCache.get(def);
      return defEntry;
    }
    const key = this.calcKey(def);
    const entry = this.dictionaryCache.get(key);
    if (entry) {
      entry.options = def;
      this.keepAliveCache.set(def, entry);
    }
    return { key, entry };
  }
  setCacheEntry(key, entry, def) {
    this.dictionaryCache.set(key, entry);
    this.dictionaryCacheByDef.set(def, { key, entry });
  }
  async refreshEntry(entry, maxAge, now) {
    if (now - entry.ts >= maxAge) {
      const sig = now + Math.random();
      entry.sig = sig;
      entry.ts = now;
      const pStat = this.getStat(entry.uri);
      const [newStat] = await Promise.all([pStat, entry.pending]);
      const hasChanged = !this.isEqual(newStat, entry.stat);
      const sigMatches = entry.sig === sig;
      if (sigMatches && hasChanged) {
        entry.loadingState = LoadingState.Loading;
        const key = this.calcKey(entry.options);
        const newEntry = this.loadEntry(entry.uri, entry.options);
        this.dictionaryCache.set(key, newEntry);
        this.dictionaryCacheByDef.set(entry.options, { key, entry: newEntry });
      }
    }
  }
  loadEntry(fileOrUri, options, now = Date.now()) {
    const url = toFileURL(fileOrUri);
    options = this.normalizeOptions(url, options);
    const pDictionary = load(this.reader, url, options).catch((e) => createFailedToLoadDictionary(options.name, fileOrUri, new SpellingDictionaryLoadError(url.href, options, e, "failed to load"), options));
    const pStat = this.getStat(url);
    const pending = Promise.all([pDictionary, pStat]);
    const sig = now + Math.random();
    const entry = {
      uri: url.href,
      options,
      ts: now,
      stat: void 0,
      dictionary: void 0,
      pending,
      loadingState: LoadingState.Loading,
      sig
    };
    pending.then(([dictionary, stat]) => {
      entry.stat = stat;
      entry.dictionary = dictionary;
      entry.loadingState = LoadingState.Loaded;
      return;
    }).catch(() => void 0);
    return entry;
  }
  getStat(uri) {
    return this.fs.stat(toFileURL(uri)).catch(toError2);
  }
  isEqual(a, b) {
    if (!b)
      return false;
    if (isError3(a)) {
      return isError3(b) && a.message === b.message && a.name === b.name;
    }
    return !isError3(b) && !compareStats(a, b);
  }
  normalizeOptions(uri, options) {
    if (options.name)
      return options;
    return { ...options, name: urlBasename(uri) };
  }
  loadInlineDict(def) {
    return this.inlineDictionaryCache.get(def, (def2) => createInlineSpellingDictionary(def2, def2.__source || "memory"));
  }
  loadSimpleDict(def) {
    return createInlineSpellingDictionary({ name: def.name, words: [] }, def.__source || "memory");
  }
  calcKey(def) {
    const path = def.path;
    const loaderType = determineType(toFileURL(path), def);
    const optValues = importantOptionKeys.map((k) => {
      var _a19;
      return ((_a19 = def[k]) == null ? void 0 : _a19.toString()) || "";
    });
    const parts = [path, loaderType, ...optValues];
    return parts.join("|");
  }
};
function toReader(fs) {
  function readResource(url) {
    return fs.readFile(url);
  }
  async function readText(url) {
    return (await readResource(url)).getText();
  }
  async function read(url) {
    return (await readResource(url)).getBytes();
  }
  return {
    read,
    readText,
    readLines: async (filename) => toLines(await readText(filename))
  };
}
var importantOptionKeys = ["name", "noSuggest", "useCompounds", "type"];
function isError3(e) {
  const err = e;
  return !!err.message;
}
function determineType(uri, opts) {
  const t = opts.type && opts.type in loaders && opts.type || "S";
  const defLoaderType = t;
  const defType = uri.pathname.endsWith(".trie.gz") ? "T" : defLoaderType;
  const regTrieTest = /\.b?trie\b/i;
  return regTrieTest.test(uri.pathname) ? "T" : defType;
}
async function load(reader, uri, options) {
  const type = determineType(uri, options);
  const loader2 = loaders[type] || loaders.default;
  return loader2(reader, uri, options);
}
async function legacyWordList(reader, filename, options) {
  const env_1 = { stack: [], error: void 0, hasError: false };
  try {
    const lines = await reader.readLines(filename);
    const _ = __addDisposableResource(env_1, measurePerf("legacyWords"), false);
    const words = pipeSync2(
      lines,
      // Remove comments
      opMapSync2((line) => line.replaceAll(/#.*/g, "")),
      // Split on everything else
      opConcatMapSync2((line) => line.split(/[^\w\p{L}\p{M}']+/gu)),
      opFilterSync2((word) => !!word)
    );
    return createSpellingDictionary(words, options.name, filename.toString(), options, true);
  } catch (e_1) {
    env_1.error = e_1;
    env_1.hasError = true;
  } finally {
    __disposeResources(env_1);
  }
}
async function wordsPerLineWordList(reader, filename, options) {
  const lines = await reader.readLines(filename);
  const words = pipeSync2(
    lines,
    // Remove comments
    opMapSync2((line) => line.replaceAll(/#.*/g, "")),
    // Split on everything else
    opConcatMapSync2((line) => line.split(/\s+/gu)),
    opFilterSync2((word) => !!word)
  );
  return createSpellingDictionary(words, options.name, filename.href, options, true);
}
async function loadSimpleWordList(reader, filename, options) {
  const env_2 = { stack: [], error: void 0, hasError: false };
  try {
    const lines = await reader.readLines(filename);
    const _ = __addDisposableResource(env_2, measurePerf("loadSimpleWordList"), false);
    return createSpellingDictionary(lines, options.name, filename.href, options);
  } catch (e_2) {
    env_2.error = e_2;
    env_2.hasError = true;
  } finally {
    __disposeResources(env_2);
  }
}
async function loadTrie(reader, filename, options) {
  const env_3 = { stack: [], error: void 0, hasError: false };
  try {
    const content = await reader.read(filename);
    const _ = __addDisposableResource(env_3, measurePerf("loadTrie"), false);
    return createSpellingDictionaryFromTrieFile(content, options.name, filename.href, options);
  } catch (e_3) {
    env_3.error = e_3;
    env_3.hasError = true;
  } finally {
    __disposeResources(env_3);
  }
}
function toLines(content) {
  return content.split(/\n|\r\n|\r/);
}

// ../../node_modules/cspell-lib/dist/lib/SpellingDictionary/DictionaryLoader.js
var loader;
function getDictionaryLoader(vfs) {
  if (loader)
    return loader;
  return loader = new DictionaryLoader(vfs || getFileSystem());
}
function loadDictionary(def) {
  return getDictionaryLoader().loadDictionary(def);
}
async function refreshCacheEntries(maxAge, now) {
  return getDictionaryLoader().refreshCacheEntries(maxAge, now);
}

// ../../node_modules/cspell-lib/dist/lib/SpellingDictionary/Dictionaries.js
function loadDictionaryDefs(defsToLoad) {
  return defsToLoad.map(loadDictionary);
}
function refreshDictionaryCache(maxAge) {
  return refreshCacheEntries(maxAge);
}
var emptyWords2 = Object.freeze([]);
async function getDictionaryInternal(settings) {
  const spellDictionaries = await Promise.all(loadDictionaryDefs(calcDictionaryDefsToLoad(settings)));
  return _getDictionaryInternal(settings, spellDictionaries);
}
var specialDictionaryNames = {
  words: "[words]",
  userWords: "[userWords]",
  flagWords: "[flagWords]",
  ignoreWords: "[ignoreWords]",
  suggestWords: "[suggestWords]"
};
var mapSpecialDictionaryNamesToSettings = new Map(Object.entries(specialDictionaryNames).map(([k, v]) => [v, k]));
function getInlineConfigDictionaries(settings) {
  const { words = emptyWords2, userWords = emptyWords2, flagWords = emptyWords2, ignoreWords = emptyWords2, suggestWords = emptyWords2 } = settings;
  const settingsWordsDictionary = createSpellingDictionary(words, specialDictionaryNames.words, "From Settings `words`", {
    caseSensitive: true,
    weightMap: void 0
  });
  const settingsUserWordsDictionary = userWords.length ? createSpellingDictionary(userWords, specialDictionaryNames.userWords, "From Settings `userWords`", {
    caseSensitive: true,
    weightMap: void 0
  }) : void 0;
  const ignoreWordsDictionary = createIgnoreWordsDictionary(ignoreWords, specialDictionaryNames.ignoreWords, "From Settings `ignoreWords`");
  const flagWordsDictionary = createFlagWordsDictionary(flagWords, specialDictionaryNames.flagWords, "From Settings `flagWords`");
  const suggestWordsDictionary = createSuggestDictionary(suggestWords, "[suggestWords]", "From Settings `suggestWords`");
  const dictionaries = [
    settingsWordsDictionary,
    settingsUserWordsDictionary,
    ignoreWordsDictionary,
    flagWordsDictionary,
    suggestWordsDictionary
  ].filter(isDefined);
  return dictionaries;
}
function _getDictionaryInternal(settings, spellDictionaries) {
  const dictionaries = [...spellDictionaries, ...getInlineConfigDictionaries(settings)];
  return createCollection(dictionaries, "dictionary collection");
}

// ../../node_modules/cspell-lib/dist/lib/SpellingDictionary/SpellingDictionary.js
init_shim();

// ../../node_modules/cspell-lib/dist/lib/util/text.js
init_shim();
function splitWordWithOffset(wo, regExpWordBreaks) {
  return splitWord(wo.text, regExpWordBreaks).map(scanMap((last, text) => ({ text, offset: last.offset + last.text.length }), {
    text: "",
    offset: wo.offset
  }));
}
function splitWord(word, regExpWordBreaks) {
  return word.split(new RegExp(regExpWordBreaks));
}
function match(reg, text) {
  if (!text)
    return [];
  reg = reg.global ? new RegExp(reg) : new RegExp(reg.source, reg.flags + "g");
  return text.matchAll(reg);
}
function matchToTextOffset(reg, t) {
  const text = t.text;
  const offset = t.offset;
  return pipeSync2(match(reg, text), opMapSync2((m) => ({ text: m[0], offset: offset + m.index })));
}
function extractWordsFromTextOffset(text) {
  const reg = new RegExp(regExWords);
  return matchToTextOffset(reg, cleanTextOffset(text));
}
function cleanText(text) {
  regExIgnoreCharacters.lastIndex = 0;
  if (!regExIgnoreCharacters.test(text))
    return text;
  regExIgnoreCharacters.lastIndex = 0;
  text = text.replace(regExIgnoreCharacters, (match2) => " ".repeat(match2.length));
  return text;
}
function cleanTextOffset(text) {
  regExIgnoreCharacters.lastIndex = 0;
  if (!regExIgnoreCharacters.test(text.text))
    return text;
  return {
    text: cleanText(text.text),
    offset: text.offset
  };
}
function extractPossibleWordsFromTextOffset(text) {
  const reg = new RegExp(regExWordsAndDigits);
  return matchToTextOffset(reg, text);
}
function extractText(textOffset, startPos, endPos) {
  const { text, offset: orig } = textOffset;
  const a = Math.max(startPos - orig, 0);
  const b = Math.max(endPos - orig, 0);
  return text.slice(a, b);
}

// ../../node_modules/cspell-lib/dist/lib/Settings/InDocSettings.js
var regExMatchRegEx = /\/.*\/[gimuy]*/;
var regExCSpellInDocDirective = /\b(?:spell-?checker|c?spell)::?(.*)/gi;
var regExCSpellDirectiveKey = /(?<=\b(?:spell-?checker|c?spell)::?)(?!:)(.*)/i;
var regExInFileSettings = [regExCSpellInDocDirective, /\b(LocalWords:?.*)/g];
var officialDirectives = [
  "enable",
  "disable",
  "disable-line",
  "disable-next",
  "disable-next-line",
  "word",
  "words",
  "ignore",
  "ignoreWord",
  "ignoreWords",
  "ignore-word",
  "ignore-words",
  "includeRegExp",
  "ignoreRegExp",
  "local",
  // Do not suggest.
  "locale",
  "language",
  "dictionaries",
  "dictionary",
  "forbid",
  "forbidWord",
  "forbid-word",
  "flag",
  "flagWord",
  "flag-word",
  "enableCompoundWords",
  "enableAllowCompoundWords",
  "disableCompoundWords",
  "disableAllowCompoundWords",
  "enableCaseSensitive",
  "disableCaseSensitive"
];
var noSuggestDirectives = /* @__PURE__ */ new Set(["local"]);
var preferredDirectives = [
  "enable",
  "disable",
  "disable-line",
  "disable-next-line",
  "words",
  "ignore",
  "forbid",
  "locale",
  "dictionary",
  "dictionaries",
  "enableCaseSensitive",
  "disableCaseSensitive"
];
var allDirectives = /* @__PURE__ */ new Set([...preferredDirectives, ...officialDirectives]);
var allDirectiveSuggestions = [
  ...pipeSync2(allDirectives, opMapSync2((word) => ({ word })))
];
var dictInDocSettings = createSpellingDictionary(allDirectives, "Directives", "Directive List", {
  supportNonStrictSearches: false
});
var EmptyWords = [];
Object.freeze(EmptyWords);
var staticInDocumentDictionaryName = `[in-document-dict]`;
function collectInDocumentDirectives(text) {
  const dirs = [...getPossibleInDocSettings(text)].flatMap((a) => associateDirectivesWithParsers(a));
  return dirs;
}
var baseInDocSettings = { id: "in-doc-settings" };
Object.freeze(baseInDocSettings);
function getInDocumentSettings(text) {
  const found = collectInDocumentDirectives(text);
  if (!found.length)
    return { ...baseInDocSettings };
  const collectedSettings = reducePossibleMatchesToSettings(found, { ...baseInDocSettings });
  const { words, flagWords, ignoreWords, suggestWords, dictionaries = [], dictionaryDefinitions = [], ...rest } = collectedSettings;
  const dict = (words || flagWords || ignoreWords || suggestWords) && clean({
    name: staticInDocumentDictionaryName,
    words,
    flagWords,
    ignoreWords,
    suggestWords
  });
  const dictSettings = dict ? {
    dictionaries: [...dictionaries, staticInDocumentDictionaryName],
    dictionaryDefinitions: [...dictionaryDefinitions, dict]
  } : clean({
    dictionaries: dictionaries.length ? dictionaries : void 0,
    dictionaryDefinitions: dictionaryDefinitions.length ? dictionaryDefinitions : void 0
  });
  const settings = {
    ...rest,
    ...dictSettings
  };
  return settings;
}
function validateInDocumentSettings(docText, _settings) {
  return pipeSync2(getPossibleInDocSettings(docText), opMapSync2(parseSettingMatchValidation), opFilterSync2(isDefined));
}
var settingParsers = [
  [/^(?:enable|disable)(?:allow)?CompoundWords\b(?!-)/i, parseCompoundWords, "CompoundWords"],
  [/^(?:enable|disable)CaseSensitive\b(?!-)/i, parseCaseSensitive, "CaseSensitive"],
  [/^enable\b(?!-)/i, parseEnable, "Enable"],
  [/^disable(-line|-next(-line)?)?\b(?!-)/i, parseDisable, "Disable"],
  [/^words?\b(?!-)/i, parseWords, "Words"],
  [/^ignore(?:-?words?)?\b(?!-)/i, parseIgnoreWords, "Ignore"],
  [/^(?:flag|forbid)(?:-?words?)?\b(?!-)/i, parseFlagWords, "Flag"],
  [/^ignore_?Reg_?Exp\s+.+$/i, parseIgnoreRegExp, "IgnoreRegExp"],
  [/^include_?Reg_?Exp\s+.+$/i, parseIncludeRegExp, "IncludeRegExp"],
  [/^locale?\b(?!-)/i, parseLocale2, "Locale"],
  [/^language\s\b(?!-)/i, parseLocale2, "Locale"],
  [/^dictionar(?:y|ies)\b(?!-)/i, parseDictionaries, "Dictionaries"],
  // cspell:disable-line
  [/^LocalWords:/, (acc, m) => reduceWordList(acc, m.replaceAll(/^LocalWords:?/gi, " "), "words"), "Words"]
];
var issueMessages = {
  unknownDirective: "Unknown CSpell directive"
};
function parseSettingMatchValidation(possibleMatch) {
  const { fullDirective, offset } = possibleMatch;
  regExCSpellDirectiveKey.lastIndex = 0;
  const directiveMatch = fullDirective.match(regExCSpellDirectiveKey);
  if (!directiveMatch)
    return void 0;
  const match2 = directiveMatch[1];
  const possibleSetting = match2.trim();
  if (!possibleSetting)
    return void 0;
  const start = offset + (directiveMatch.index || 0) + (match2.length - match2.trimStart().length);
  const text = possibleSetting.replace(/^([-\w]+)?.*/, "$1");
  const end = start + text.length;
  if (!text)
    return void 0;
  const matchingParsers = settingParsers.filter(([regex]) => regex.test(possibleSetting));
  if (matchingParsers.length > 0)
    return void 0;
  const dictSugs = dictInDocSettings.suggest(text, { ignoreCase: false }).map(({ word, isPreferred }) => isPreferred ? { word, isPreferred } : { word }).filter((a) => !noSuggestDirectives.has(a.word));
  const sugs = pipeSync2(dictSugs, opAppendSync2(allDirectiveSuggestions), filterUniqueSuggestions);
  const suggestionsEx = [...sugs].slice(0, 8);
  const suggestions = suggestionsEx.map((s) => s.word);
  const issue = {
    range: [start, end],
    text,
    message: issueMessages.unknownDirective,
    suggestions,
    suggestionsEx
  };
  return issue;
}
function* filterUniqueSuggestions(sugs) {
  const map2 = /* @__PURE__ */ new Map();
  for (const sug of sugs) {
    const existing = map2.get(sug.word);
    if (existing && sug.isPreferred) {
      existing.isPreferred = true;
    }
    yield sug;
  }
}
function associateDirectivesWithParsers(possibleMatch) {
  const { match: match2 } = possibleMatch;
  const possibleSetting = match2.trim();
  return settingParsers.filter(([regex]) => regex.test(possibleSetting)).map(([, fn, directive]) => ({ ...possibleMatch, directive, fn }));
}
function mergeDirectiveIntoSettings(settings, directive) {
  return directive.fn(settings, directive.match);
}
function reducePossibleMatchesToSettings(directives, settings) {
  for (const directive of directives) {
    settings = mergeDirectiveIntoSettings(settings, directive);
  }
  return settings;
}
function parseCompoundWords(acc, match2) {
  acc.allowCompoundWords = /enable/i.test(match2);
  return acc;
}
function parseCaseSensitive(acc, match2) {
  acc.caseSensitive = /enable/i.test(match2);
  return acc;
}
function splitWords(match2) {
  return match2.split(/[,\s;]+/g).slice(1).filter((a) => !!a);
}
function mergeList2(a, b) {
  if (!a)
    return b;
  if (!b)
    return a;
  return [...a, ...b];
}
function reduceWordList(acc, match2, key) {
  const words = splitWords(match2);
  if (words.length) {
    acc[key] = mergeList2(acc[key], words);
  }
  return acc;
}
function parseWords(acc, match2) {
  return reduceWordList(acc, match2, "words");
}
function parseLocale2(acc, match2) {
  const parts = match2.trim().split(/[\s,]+/);
  const language = parts.slice(1).join(",");
  if (language) {
    acc.language = language;
  }
  return acc;
}
function parseIgnoreWords(acc, match2) {
  return reduceWordList(acc, match2, "ignoreWords");
}
function parseFlagWords(acc, match2) {
  return reduceWordList(acc, match2, "flagWords");
}
function parseRegEx(match2) {
  const patterns = [match2.replace(/^[^\s]+\s+/, "")].map((a) => {
    regExMatchRegEx.lastIndex = 0;
    const m = a.match(regExMatchRegEx);
    if (m && m[0]) {
      return m[0];
    }
    return a.replace(/((?:[^\s]|\\ )+).*/, "$1");
  });
  return patterns;
}
function parseIgnoreRegExp(acc, match2) {
  const ignoreRegExpList = parseRegEx(match2);
  if (ignoreRegExpList.length) {
    acc.ignoreRegExpList = mergeList2(acc.ignoreRegExpList, ignoreRegExpList);
  }
  return acc;
}
function parseIncludeRegExp(acc, match2) {
  const includeRegExpList = parseRegEx(match2);
  if (includeRegExpList.length) {
    acc.includeRegExpList = mergeList2(acc.includeRegExpList, includeRegExpList);
  }
  return acc;
}
function parseDictionaries(acc, match2) {
  const dictionaries = match2.split(/[,\s]+/g).slice(1);
  if (dictionaries.length) {
    acc.dictionaries = mergeList2(acc.dictionaries, dictionaries);
  }
  return acc;
}
function getPossibleInDocSettings(text) {
  return pipeSync2(regExInFileSettings, opMapSync2((regexp) => match(regexp, text)), opFlattenSync2(), opMapSync2((match2) => ({ fullDirective: match2[0], offset: match2.index, match: match2[1].trim() })));
}
function parseEnable(acc, _match) {
  return acc;
}
function parseDisable(acc, _match) {
  return acc;
}

// ../../node_modules/cspell-lib/dist/lib/Settings/LanguageSettings.js
init_shim();
var defaultLocale = "en";
function localesToList(locales) {
  return stringToList(locales.replaceAll(/\s+/g, ","));
}
function stringToList(sList) {
  return sList.replaceAll(/[|;]/g, ",").split(",").map((s) => s.trim()).filter((s) => !!s);
}
function memoize(resolver) {
  const cache3 = createAutoResolveCache();
  return (k) => cache3.get(k, resolver);
}
var _normalizeLanguageId = memoize(__normalizeLanguageId);
function __normalizeLanguageId(langId) {
  const langIds = stringToList(langId);
  return new Set(langIds.map((a) => a.toLowerCase()));
}
function normalizeLanguageId(langId) {
  return _normalizeLanguageId(typeof langId === "string" ? langId : langId.join(","));
}
var _normalizeLocale = memoize(__normalizeLocale);
function __normalizeLocale(locale) {
  const locales = localesToList(locale);
  return new Set(locales.map((locale2) => locale2.toLowerCase().replaceAll(/[^a-z]/g, "")));
}
function normalizeLocale2(locale) {
  locale = typeof locale === "string" ? locale : locale.join(",");
  return _normalizeLocale(locale);
}
function normalizeLocaleIntl(locale) {
  const values = [...normalizeLocale2(locale)].map((locale2) => locale2.replace(/^([a-z]{2})-?([a-z]{2})$/, (_, lang, locale3) => locale3 ? `${lang}-${locale3.toUpperCase()}` : lang));
  return new Set(values);
}
function isLocaleInSet(locale, setOfLocals) {
  const locales = normalizeLocale2(locale);
  return doSetsIntersect(locales, setOfLocals);
}
var regExpValidIntlLocaleStrict = /^[a-z]{2}(-[A-Z]{2})?$/;
var regExpValidIntlLocale = new RegExp(regExpValidIntlLocaleStrict, "i");
function isValidLocaleIntlFormat(locale, strict = false) {
  if (typeof locale === "string")
    return strict ? regExpValidIntlLocaleStrict.test(locale) : regExpValidIntlLocale.test(locale);
  for (const item of locale) {
    if (!isValidLocaleIntlFormat(item, strict))
      return false;
  }
  return locale.length > 0;
}
var cacheCalcSettingsForLanguage = createAutoResolveWeakCache();
function calcSettingsForLanguage(languageSettings, languageId, locale) {
  return cacheCalcSettingsForLanguage.get(languageSettings, () => new AutoResolveCache()).get(languageId, () => new AutoResolveCache()).get(locale, () => _calcSettingsForLanguage(languageSettings, languageId, locale));
}
function _calcSettingsForLanguage(languageSettings, languageId, locale) {
  languageId = languageId.toLowerCase();
  const allowedLocals = normalizeLocale2(locale);
  const ls = languageSettings.filter((s) => doesLanguageSettingMatchLanguageId(s, languageId)).filter((s) => !s.locale || s.locale === "*" || isLocaleInSet(s.locale, allowedLocals)).map((langSetting) => {
    const { languageId: _languageId, locale: _locale, ...s } = langSetting;
    return s;
  }).reduce((langSetting, setting) => mergeSettings(langSetting, setting), {});
  ls.languageId = languageId;
  ls.locale = locale;
  return ls;
}
var cacheDoesLanguageSettingMatchLanguageId = createAutoResolveWeakCache();
function doesLanguageSettingMatchLanguageId(s, languageId) {
  return cacheDoesLanguageSettingMatchLanguageId.get(s, () => new AutoResolveCache()).get(languageId, () => _doesLanguageSettingMatchLanguageId(s, languageId));
}
function _doesLanguageSettingMatchLanguageId(s, languageId) {
  const languageSettingsLanguageIds = s.languageId;
  if (!languageSettingsLanguageIds || languageSettingsLanguageIds === "*")
    return true;
  const ids = normalizeLanguageId(languageSettingsLanguageIds);
  if (ids.has(languageId))
    return true;
  if (ids.has("!" + languageId))
    return false;
  const numExcludes = [...ids].filter((id) => id.startsWith("!")).length;
  return numExcludes === ids.size;
}
function calcUserSettingsForLanguage(settings, languageId) {
  const { languageSettings = [], language: locale = defaultLocale, allowCompoundWords, enabled } = settings;
  const langSettings = {
    allowCompoundWords,
    enabled,
    ...calcSettingsForLanguage(languageSettings, languageId, locale)
  };
  return mergeSettings(settings, langSettings);
}
function calcSettingsForLanguageId(baseSettings, languageId) {
  const langIds = ["*", ...normalizeLanguageId(languageId)];
  const langSettings = langIds.reduce((settings, languageId2) => {
    return calcUserSettingsForLanguage(settings, languageId2);
  }, baseSettings);
  return langSettings;
}

// ../../node_modules/cspell-lib/dist/lib/Settings/TextDocumentSettings.js
function combineTextAndLanguageSettings(settings, text, languageId) {
  if (!text) {
    return toInternalSettings(calcSettingsForLanguageId(settings, languageId));
  }
  const docSettings = extractSettingsFromText(text);
  const settingsForText = mergeSettings(settings, docSettings);
  const langSettings = calcSettingsForLanguageId(settingsForText, languageId);
  const final = mergeSettings(langSettings, docSettings);
  return final;
}
function extractSettingsFromText(text) {
  return getInDocumentSettings(text);
}

// ../../node_modules/cspell-lib/dist/lib/textValidation/determineTextDocumentSettings.js
async function determineTextDocumentSettings(doc, settings) {
  var _a19, _b2;
  const filename = uriToFilePath(doc.uri);
  const settingsWithDefaults = mergeSettings(await getDefaultSettings((_a19 = settings.loadDefaultConfiguration) != null ? _a19 : true), await getGlobalSettingsAsync(), settings);
  const fileSettings = calcOverrideSettings(settingsWithDefaults, filename);
  const languageIds2 = ((_b2 = fileSettings == null ? void 0 : fileSettings.languageId) == null ? void 0 : _b2.length) ? fileSettings.languageId : doc.languageId ? doc.languageId : getLanguageForFilename(filename);
  if (doc.locale) {
    fileSettings.language = doc.locale;
  }
  return combineTextAndLanguageSettings(fileSettings, doc.text, languageIds2);
}
function getLanguageForFilename(filename) {
  const basename4 = basename2(filename);
  return findMatchingFileTypes(basename4);
}

// ../../node_modules/cspell-lib/dist/lib/textValidation/index.js
init_shim();

// ../../node_modules/cspell-lib/dist/lib/textValidation/docValidator.js
init_shim();
var import_node_assert9 = __toESM(require_assert(), 1);

// ../../node_modules/@cspell/cspell-types/dist/index.mjs
init_shim();
var IssueType = /* @__PURE__ */ (function(IssueType2) {
  IssueType2[IssueType2["spelling"] = 0] = "spelling";
  IssueType2[IssueType2["directive"] = 1] = "directive";
  return IssueType2;
})({});
var unknownWordsChoices = {
  ReportAll: "report-all",
  ReportSimple: "report-simple",
  ReportCommonTypos: "report-common-typos",
  ReportFlagged: "report-flagged"
};
var defaultCSpellSettings = {
  ignoreRandomStrings: true,
  minRandomLength: 40
};

// ../../node_modules/cspell-lib/dist/lib/suggestions.js
init_shim();
var import_node_assert6 = __toESM(require_assert(), 1);

// ../../node_modules/cspell-lib/dist/lib/util/memoizeLastCall.js
init_shim();
function memoizeLastCall(fn) {
  let last;
  return (...p) => {
    if (last && isArrayEqual(last.args, p)) {
      return last.value;
    }
    const args = p;
    const value = fn(...args);
    last = { args, value };
    return value;
  };
}

// ../../node_modules/cspell-lib/dist/lib/suggestions.js
var emptySuggestionOptions = Object.freeze({});
var emptyCSpellSettings = Object.freeze({});
var memoizeSuggestions = memoizeLastCall(cacheSuggestionsForWord);
function cacheSuggestionsForWord(options, settings) {
  const cache3 = createAutoResolveCache();
  return (word) => cache3.get(word, (word2) => _suggestionsForWord(word2, options, settings));
}
async function _suggestionsForWord(word, options, settings) {
  var _a19;
  const { languageId, locale: language, includeDefaultConfig = true, dictionaries } = options;
  async function determineDictionaries(config2) {
    var _a20, _b2;
    const withLocale = mergeSettings(config2, clean({
      language: language || config2.language
      // dictionaries: dictionaries?.length ? dictionaries : config.dictionaries,
    }));
    const withLanguageId = calcSettingsForLanguageId(withLocale, (_a20 = languageId != null ? languageId : withLocale.languageId) != null ? _a20 : "plaintext");
    const settings2 = finalizeSettings(withLanguageId);
    settings2.dictionaries = (dictionaries == null ? void 0 : dictionaries.length) ? dictionaries : settings2.dictionaries || [];
    validateDictionaries(settings2, dictionaries);
    const dictionaryCollection2 = await getDictionaryInternal(settings2);
    settings2.dictionaries = ((_b2 = settings2.dictionaryDefinitions) == null ? void 0 : _b2.map((def) => def.name)) || [];
    const allDictionaryCollection2 = await getDictionaryInternal(settings2);
    return {
      dictionaryCollection: dictionaryCollection2,
      allDictionaryCollection: allDictionaryCollection2
    };
  }
  await refreshDictionaryCache();
  const config = includeDefaultConfig ? mergeSettings(await getDefaultSettings((_a19 = settings.loadDefaultConfiguration) != null ? _a19 : true), await getGlobalSettingsAsync(), settings) : settings;
  const { dictionaryCollection, allDictionaryCollection } = await determineDictionaries(config);
  return _suggestionsForWordAsync(word, options, settings, dictionaryCollection, allDictionaryCollection);
}
async function _suggestionsForWordAsync(word, options, settings, dictionaryCollection, allDictionaryCollection) {
  var _a19;
  const extendsDictionaryCollection = allDictionaryCollection || dictionaryCollection;
  const { locale: language, strict = true, numChanges = 4, numSuggestions = 8, includeTies = true, includeDefaultConfig = true } = options;
  const ignoreCase2 = !strict;
  const config = includeDefaultConfig ? mergeSettings(await getDefaultSettings((_a19 = settings.loadDefaultConfiguration) != null ? _a19 : true), await getGlobalSettingsAsync(), settings) : settings;
  const opts = { ignoreCase: ignoreCase2, numChanges, numSuggestions, includeTies };
  const suggestionsByDictionary = dictionaryCollection.dictionaries.flatMap((dict) => dict.suggest(word, opts).map((r) => ({ ...r, dictName: dict.name })));
  const locale = adjustLocale(language || config.language || void 0);
  const collator2 = Intl.Collator(locale);
  const combined = limitResults(combine2(suggestionsByDictionary.sort((a, b) => a.cost - b.cost || collator2.compare(a.word, b.word))), numSuggestions, includeTies);
  const sugsAdjusted = calcSuggestionAdjustedToToMatchCase(word, combined, locale, ignoreCase2, extendsDictionaryCollection);
  const allSugs = sugsAdjusted.map((sug) => {
    const found = extendsDictionaryCollection.find(sug.word);
    return {
      ...sug,
      forbidden: (found == null ? void 0 : found.forbidden) || false,
      noSuggest: (found == null ? void 0 : found.noSuggest) || false
    };
  });
  return {
    word,
    suggestions: limitResults(allSugs, numSuggestions, includeTies)
  };
}
function combine2(suggestions) {
  const words = /* @__PURE__ */ new Map();
  for (const sug of suggestions) {
    const { word, cost, dictName, ...rest } = sug;
    const f = words.get(word) || { word, cost, ...rest, dictionaries: [] };
    f.cost = Math.min(f.cost, cost);
    f.dictionaries.push(dictName);
    f.dictionaries.sort();
    words.set(word, f);
  }
  return [...words.values()];
}
function adjustLocale(locale) {
  if (!locale)
    return void 0;
  const locales = [...normalizeLocaleIntl(locale)].filter((locale2) => isValidLocaleIntlFormat(locale2));
  if (!locales.length)
    return void 0;
  if (locales.length === 1)
    return locales[0];
  return locales;
}
function calcSuggestionAdjustedToToMatchCase(originalWord, sugs, locale, ignoreCase2, dict) {
  locale = adjustLocale(locale);
  const knownSugs = new Set(sugs.map((sug) => sug.word));
  const matchStyle = { ...analyzeCase(originalWord), locale, ignoreCase: ignoreCase2 };
  return sugs.map((sug) => {
    const alt = matchCase(sug.word, !!sug.isPreferred, matchStyle);
    if (alt === sug.word || knownSugs.has(alt))
      return sug;
    const found = dict.find(alt);
    if (!found || !found.forbidden || !found.noSuggest) {
      knownSugs.add(alt);
      return { ...sug, wordAdjustedToMatchCase: alt };
    }
    return sug;
  });
}
function limitResults(suggestions, numSuggestions, includeTies) {
  var _a19;
  let cost = (_a19 = suggestions[0]) == null ? void 0 : _a19.cost;
  let i = 0;
  for (; i < suggestions.length; ++i) {
    if (i >= numSuggestions && (!includeTies || suggestions[i].cost > cost)) {
      break;
    }
    cost = suggestions[i].cost;
  }
  return suggestions.slice(0, i);
}
function validateDictionaries(settings, dictionaries) {
  var _a19;
  if (!(dictionaries == null ? void 0 : dictionaries.length))
    return;
  const knownDicts2 = new Set(((_a19 = settings.dictionaryDefinitions) == null ? void 0 : _a19.map((def) => def.name)) || []);
  for (const dict of dictionaries) {
    if (!knownDicts2.has(dict)) {
      throw new SuggestionError(`Unknown dictionary: "${dict}"`, "E_dictionary_unknown");
    }
  }
}
function matchCase(word, isPreferred, style) {
  const locale = style.locale;
  if (style.isMixedCaps) {
    return word;
  }
  if (hasCaps(word)) {
    if (style.isAllCaps)
      return word.toLocaleUpperCase(locale);
    if (!style.ignoreCase || style.hasCaps || isPreferred)
      return word;
    if (isTitleCase(word) || isAllCaps(word))
      return word.toLocaleLowerCase(locale);
    return word;
  }
  if (!style.hasCaps)
    return word;
  if (style.isAllCaps)
    return word.toLocaleUpperCase(locale);
  (0, import_node_assert6.default)(style.isTitleCase);
  return word.replace(/^\p{L}/u, (firstLetter) => firstLetter.toLocaleUpperCase(locale));
}
var regExpHasCaps = /\p{Lu}/u;
var regExpIsAllCaps = /^[\P{L}\p{Lu}]+$/u;
var regExpIsTitleCase = /^\p{Lu}[\P{L}\p{Ll}]+$/u;
function analyzeCase(word) {
  const hasCaps2 = regExpHasCaps.test(word);
  const isAllCaps2 = hasCaps2 && regExpIsAllCaps.test(word);
  const isTitleCase2 = hasCaps2 && !isAllCaps2 && regExpIsTitleCase.test(word);
  const isMixedCaps = hasCaps2 && !isAllCaps2 && !isTitleCase2;
  return { hasCaps: hasCaps2, isAllCaps: isAllCaps2, isMixedCaps, isTitleCase: isTitleCase2 };
}
function hasCaps(word) {
  return regExpHasCaps.test(word);
}
function isTitleCase(word) {
  return regExpIsTitleCase.test(word);
}
function isAllCaps(word) {
  return regExpIsAllCaps.test(word);
}
var SuggestionError = class extends Error {
  constructor(message, code) {
    super(message);
    __publicField(this, "code");
    this.code = code;
  }
};

// ../../node_modules/cspell-lib/dist/lib/textValidation/cleanValidationIssue.js
init_shim();
function cleanValidationIssue(issue) {
  const cleanIssue = {};
  cloneInto(issue, cleanIssue, ValidationIssueHandlers);
  return cleanIssue;
}
var ValidationIssueHandlers = {
  text: copy0,
  offset: copy0,
  message: copy0,
  line: copy1,
  length: copy0,
  issueType: copy0,
  hasPreferredSuggestions: copy0,
  hasSimpleSuggestions: copy0,
  isFlagged: copy0,
  isFound: copy0,
  suggestions: copy1,
  suggestionsEx: copy1
};

// ../../node_modules/cspell-lib/dist/lib/textValidation/defaultConstants.js
init_shim();
var defaultMaxNumberOfProblems = 200;
var defaultMaxDuplicateProblems = 5;
var defaultMinWordLength = 4;

// ../../node_modules/cspell-lib/dist/lib/textValidation/lineValidatorFactory.js
init_shim();
var import_node_assert8 = __toESM(require_assert(), 1);

// ../../node_modules/cspell-lib/dist/lib/Settings/RegExpPatterns.js
init_shim();
var regExRepeatedChar = /^(\w)\1{3,}$/i;

// ../../node_modules/cspell-lib/dist/lib/util/wordSplitter.js
init_shim();

// ../../node_modules/cspell-lib/dist/lib/util/PairingHeap.js
init_shim();
var PairingHeap2 = class {
  constructor(compare2) {
    __publicField(this, "compare");
    __publicField(this, "_heap");
    __publicField(this, "_size", 0);
    this.compare = compare2;
  }
  add(v) {
    this._heap = insert2(this.compare, this._heap, v);
    ++this._size;
    return this;
  }
  dequeue() {
    const n = this.next();
    if (n.done)
      return void 0;
    return n.value;
  }
  append(i) {
    for (const v of i) {
      this.add(v);
    }
    return this;
  }
  next() {
    if (!this._heap) {
      return { value: void 0, done: true };
    }
    const value = this._heap.v;
    --this._size;
    this._heap = removeHead2(this.compare, this._heap);
    return { value };
  }
  peek() {
    var _a19;
    return (_a19 = this._heap) == null ? void 0 : _a19.v;
  }
  [Symbol.iterator]() {
    return this;
  }
  get length() {
    return this._size;
  }
};
function removeHead2(compare2, heap) {
  if (!heap || !heap.c)
    return void 0;
  return mergeSiblings2(compare2, heap.c);
}
function insert2(compare2, heap, v) {
  const n = {
    v,
    s: void 0,
    c: void 0
  };
  if (!heap || compare2(v, heap.v) <= 0) {
    n.c = heap;
    return n;
  }
  n.s = heap.c;
  heap.c = n;
  return heap;
}
function merge3(compare2, a, b) {
  if (compare2(a.v, b.v) <= 0) {
    a.s = void 0;
    b.s = a.c;
    a.c = b;
    return a;
  }
  b.s = void 0;
  a.s = b.c;
  b.c = a;
  return b;
}
function mergeSiblings2(compare2, n) {
  if (!n.s)
    return n;
  const s = n.s;
  const ss = s.s;
  const m = merge3(compare2, n, s);
  return ss ? merge3(compare2, m, mergeSiblings2(compare2, ss)) : m;
}

// ../../node_modules/cspell-lib/dist/lib/util/regexHelper.js
init_shim();
function escapeRegEx3(s) {
  return s.replaceAll(/[|\\{}()[\]^$+*?.]/g, "\\$&").replaceAll("-", "\\x2d");
}

// ../../node_modules/cspell-lib/dist/lib/util/wordSplitter.js
var ignoreBreak = Object.freeze([]);
function split(line, offset, isValidWord, options = {}) {
  const relWordToSplit = findNextWordText({ text: line.text, offset: offset - line.offset });
  const lineOffset = line.offset;
  const requested = /* @__PURE__ */ new Map();
  const regExpIgnoreSegment = /^[-.+\d_eE'`\\\s]+$/;
  if (!relWordToSplit.text) {
    const text = rebaseTextOffset(relWordToSplit);
    return {
      line,
      offset,
      text,
      words: [],
      endOffset: text.offset + text.text.length
    };
  }
  const lineSegment = {
    line,
    relStart: relWordToSplit.offset,
    relEnd: relWordToSplit.offset + relWordToSplit.text.length
  };
  const possibleBreaks = generateWordBreaks(lineSegment, options);
  if (!possibleBreaks.length) {
    const text = rebaseTextOffset(relWordToSplit);
    return {
      line,
      offset,
      text,
      words: [{ ...text, isFound: isValidWord(text) }],
      endOffset: text.offset + text.text.length
    };
  }
  function rebaseTextOffset(relText) {
    return {
      ...relText,
      offset: relText.offset + lineOffset
    };
  }
  function has(word) {
    if (regExpIgnoreSegment.test(word.text)) {
      return true;
    }
    const i = word.offset;
    const j = word.text.length;
    let v = i + (j << 20);
    if (i < 1 << 20 && j < 1 << 11) {
      const b = requested.get(v);
      if (b !== void 0)
        return b;
    } else {
      v = -1;
    }
    const r = isValidWord(rebaseTextOffset(word));
    if (v >= 0) {
      requested.set(v, r);
    }
    return r;
  }
  possibleBreaks.push({
    offset: lineSegment.relEnd,
    breaks: [ignoreBreak]
  });
  const result = {
    line,
    offset,
    text: rebaseTextOffset(relWordToSplit),
    words: splitIntoWords(lineSegment, possibleBreaks, has).map(rebaseTextOffset),
    endOffset: lineOffset + lineSegment.relEnd
  };
  return result;
}
function findNextWordText({ text, offset }) {
  const reg = new RegExp(regExWordsAndDigits);
  reg.lastIndex = offset;
  const m = reg.exec(text);
  if (!m) {
    return {
      text: "",
      offset: offset + text.length
    };
  }
  if (regExNumericLiteral.test(m[0])) {
    return findNextWordText({ text, offset: offset + m[0].length });
  }
  return {
    text: m[0],
    offset: m.index
  };
}
function generateWordBreaks(line, options) {
  const camelBreaks = genWordBreakCamel(line);
  const symbolBreaks = genSymbolBreaks(line);
  const optionalBreaks = genOptionalWordBreaks(line, options.optionalWordBreakCharacters);
  return mergeSortedBreaks(...camelBreaks, ...symbolBreaks, ...optionalBreaks);
}
function offsetRegEx(reg, offset) {
  const r = new RegExp(reg);
  r.lastIndex = offset;
  return r;
}
function genWordBreakCamel(line) {
  const breaksCamel1 = [];
  const text = line.line.text.slice(0, line.relEnd);
  for (const m of text.matchAll(offsetRegEx(regExSplitWords, line.relStart))) {
    if (m.index === void 0)
      break;
    const i = m.index + m[1].length;
    breaksCamel1.push({
      offset: m.index,
      breaks: [[i, i], ignoreBreak]
    });
  }
  const breaksCamel2 = [];
  for (const m of text.matchAll(offsetRegEx(regExSplitWords2, line.relStart))) {
    if (m.index === void 0)
      break;
    const i = m.index + m[1].length;
    const j = i + m[3].length;
    breaksCamel2.push({
      offset: m.index,
      breaks: [[i, i], [j, j], ignoreBreak]
    });
  }
  return [breaksCamel1, breaksCamel2];
}
function calcBreaksForRegEx(line, reg, calcBreak) {
  const sb = [];
  const text = line.line.text.slice(0, line.relEnd);
  for (const m of text.matchAll(offsetRegEx(reg, line.relStart))) {
    const b = calcBreak(m);
    if (b) {
      sb.push(b);
    }
  }
  return sb;
}
function genOptionalWordBreaks(line, optionalBreakCharacters) {
  function calcBreaks(m) {
    const i = m.index;
    if (i === void 0)
      return;
    const j = i + m[0].length;
    return {
      offset: i,
      breaks: [
        [i, j],
        // Remove the characters
        ignoreBreak
      ]
    };
  }
  const breaks = [
    calcBreaksForRegEx(line, regExDanglingQuote, calcBreaks),
    calcBreaksForRegEx(line, regExTrailingEndings, calcBreaks)
  ];
  if (optionalBreakCharacters) {
    const regex = new RegExp(`[${escapeRegEx3(optionalBreakCharacters)}]`, "gu");
    breaks.push(calcBreaksForRegEx(line, regex, calcBreaks));
  }
  return breaks;
}
function genSymbolBreaks(line) {
  function calcBreaks(m) {
    const i = m.index;
    if (i === void 0)
      return;
    const j = i + m[0].length;
    return {
      offset: i,
      breaks: [
        [i, j],
        // Remove the characters
        [i, i],
        // keep characters with word to right
        [j, j],
        // keep characters with word to left
        ignoreBreak
      ]
    };
  }
  return [
    calcBreaksForRegEx(line, regExPossibleWordBreaks, calcBreaks),
    calcBreaksForRegEx(line, /\d+/g, calcBreaks),
    calcBreaksForRegEx(line, regExEscapeCharacters, calcBreaks)
  ];
}
function splitIntoWords(lineSeg, breaks, has) {
  var _a19;
  const maxIndex = lineSeg.relEnd;
  const maxAttempts = 1e3;
  const knownPathsByIndex = /* @__PURE__ */ new Map();
  function makeCandidates(p, i, bi, currentCost) {
    const len = maxIndex;
    while (bi < breaks.length && breaks[bi].offset < i) {
      bi += 1;
    }
    if (bi >= breaks.length) {
      return [];
    }
    const br = breaks[bi];
    function c(bp) {
      const d = bp.length < 2 ? len - i : (bp[0] - i) * 0.5 + len - bp[1];
      const ec = currentCost + d;
      return {
        p,
        i,
        bi,
        bp,
        c: currentCost,
        ec,
        text: void 0
      };
    }
    return br.breaks.map(c);
  }
  function checkTextOffset(text2, offset) {
    const valid = has({ text: text2, offset });
    return {
      text: text2,
      offset,
      isFound: valid
    };
  }
  function compare2(a, b) {
    return a.ec - b.ec || b.i - a.i;
  }
  function pathToWords(node) {
    const results = [];
    for (let p = node; p; p = p.n) {
      if (p.text) {
        results.push(p.text);
      }
    }
    return results;
  }
  function addToKnownPaths(candidate, path) {
    var _a20;
    for (let can = candidate; can !== void 0; can = can.p) {
      const t = can.text;
      const i = can.i;
      const cost = (!t || t.isFound ? 0 : t.text.length) + ((_a20 = path == null ? void 0 : path.c) != null ? _a20 : 0);
      const exitingPath = knownPathsByIndex.get(i);
      if (exitingPath && exitingPath.c <= cost) {
        return void 0;
      }
      const node = {
        n: path,
        i,
        c: cost,
        text: t
      };
      knownPathsByIndex.set(i, node);
      path = node;
    }
    return path;
  }
  let maxCost = lineSeg.relEnd - lineSeg.relStart;
  const candidates = new PairingHeap2(compare2);
  const text = lineSeg.line.text;
  candidates.append(makeCandidates(void 0, lineSeg.relStart, 0, 0));
  let attempts = 0;
  let bestPath;
  while (maxCost && candidates.length && attempts++ < maxAttempts) {
    const best = candidates.dequeue();
    if (!best || best.c >= maxCost) {
      continue;
    }
    if (best.bp.length) {
      const i = best.bp[0];
      const j = best.bp[1];
      const t = i > best.i ? checkTextOffset(text.slice(best.i, i), best.i) : void 0;
      const cost = !t || t.isFound ? 0 : t.text.length;
      const mc = maxIndex - j;
      best.c += cost;
      best.ec = best.c + mc;
      best.text = t;
      const possiblePath = knownPathsByIndex.get(j);
      if (possiblePath) {
        const f = addToKnownPaths(best, possiblePath);
        bestPath = !bestPath || f && f.c < bestPath.c ? f : bestPath;
      } else if (best.c < maxCost) {
        const c = makeCandidates(t ? best : best.p, j, best.bi + 1, best.c);
        candidates.append(c);
      }
    } else {
      const c = makeCandidates(best.p, best.i, best.bi + 1, best.c);
      candidates.append(c);
      if (!c.length) {
        const t = maxIndex > best.i ? checkTextOffset(text.slice(best.i, maxIndex), best.i) : void 0;
        const cost = !t || t.isFound ? 0 : t.text.length;
        best.c += cost;
        best.ec = best.c;
        best.text = t;
        const segText = t || ((_a19 = best.p) == null ? void 0 : _a19.text) || checkTextOffset("", best.i);
        const can = t ? { ...best, text: segText } : { ...best, ...best.p, text: segText };
        const f = addToKnownPaths(can, void 0);
        bestPath = !bestPath || f && f.c < bestPath.c ? f : bestPath;
      }
    }
    if (bestPath && bestPath.c < maxCost) {
      maxCost = bestPath.c;
    }
  }
  return pathToWords(bestPath);
}
function mergeSortedBreaks(...maps) {
  return maps.flat().sort((a, b) => a.offset - b.offset);
}

// ../../node_modules/cspell-lib/dist/lib/textValidation/isRandomString.js
init_shim();
var maxRadio = 0.5;
function isRandomString(s, maxNoiseToLengthRatio = maxRadio) {
  return scoreRandomString(s) >= maxNoiseToLengthRatio;
}
function scoreRandomString(s) {
  if (!s.length)
    return 0;
  const n = categorizeString(s);
  return n.length / s.length;
}
function categorizeString(s) {
  const n = s.replaceAll(/\d+/g, "0").replaceAll(/\p{Ll}\p{M}+/gu, "a").replaceAll(/\p{Lu}\p{M}+/gu, "A").replaceAll(/\p{Lu}?\p{Ll}+/gu, "1").replaceAll(/\p{Lu}+/gu, "2").replaceAll(/\p{M}/gu, "4").replaceAll("_", "").replaceAll(/[-_.']+/g, "3");
  return n;
}
var hexSequence = /(?:\b|(?<=[\W_]))[0-9a-fA-F][-0-9a-fA-F]*[0-9a-fA-F](?:\b|(?=[\W_]))/g;
var isLetter = /\p{L}/uy;
function isLetterAt(s, idx2) {
  isLetter.lastIndex = idx2;
  return isLetter.test(s);
}
var MIN_HEX_SEQUENCE_LENGTH = 4;
function extractHexSequences(s, minLength = MIN_HEX_SEQUENCE_LENGTH) {
  return [...s.matchAll(hexSequence)].filter((m) => m[0].length >= minLength && (m.index === 0 || !isLetterAt(s, m.index - 1)) && !isLetterAt(s, m.index + m[0].length)).map((m) => ({ text: m[0], offset: m.index }));
}

// ../../node_modules/cspell-lib/dist/lib/textValidation/isWordValid.js
init_shim();
function hasWordCheck(dict, word) {
  word = word.includes("\\") ? word.replaceAll("\\", "") : word;
  return dict.has(word);
}
function isWordValidWithEscapeRetry(dict, wo, line) {
  const firstTry = hasWordCheck(dict, wo.text);
  return firstTry || // Drop the first letter if it is preceded by a '\'.
  line.text[wo.offset - line.offset - 1] === "\\" && hasWordCheck(dict, wo.text.slice(1));
}

// ../../node_modules/cspell-lib/dist/lib/textValidation/parsedText.js
init_shim();

// ../../node_modules/cspell-lib/dist/lib/util/TextMap.js
init_shim();
var import_node_assert7 = __toESM(require_assert(), 1);
function extractTextMapRangeOrigin(textMap, extractRange) {
  const { text: srcTxt, range: srcRange, map: srcMap } = textMap;
  const [r0, r1] = srcRange;
  const startOrig = Math.min(Math.max(extractRange[0], r0), r1);
  const endOrig = Math.min(Math.max(extractRange[1], r0), r1);
  const a = startOrig - r0;
  const b = endOrig - r0;
  const range = [startOrig, endOrig];
  if (!srcMap || !srcMap.length || a === b) {
    const text2 = srcTxt.slice(a, b);
    return { text: text2, range };
  }
  (0, import_node_assert7.default)((srcMap.length & 1) === 0, "Map must be pairs of values.");
  const mapLen = srcMap.length;
  const mapEndSrc = srcMap[mapLen - 2];
  const mapEndDst = srcMap[mapLen - 1];
  const endDiff = srcTxt.length - mapEndDst;
  const head = !srcMap[0] && !srcMap[1] ? [] : [0, 0];
  const tail = [mapEndSrc + endDiff, mapEndDst + endDiff];
  const sMap = [...head, ...srcMap, ...tail];
  let idx2 = 0;
  for (; idx2 < sMap.length && a >= sMap[idx2]; idx2 += 2) {
  }
  const aIdx = idx2;
  idx2 -= 2;
  const a0 = a - sMap[idx2];
  const a1 = a0 + sMap[idx2 + 1];
  for (; idx2 < sMap.length && b > sMap[idx2]; idx2 += 2) {
  }
  const bIdx = idx2;
  const b0 = b - sMap[idx2];
  const b1 = b0 + sMap[idx2 + 1];
  const text = srcTxt.slice(a1, b1);
  if (bIdx === aIdx) {
    return { text, range };
  }
  const ab = [a0, a1];
  const map2 = sMap.slice(aIdx, bIdx + 2).map((v, i) => v - ab[i & 1]);
  return { text, range, map: map2 };
}

// ../../node_modules/cspell-lib/dist/lib/textValidation/parsedText.js
function mapRangeBackToOriginalPos(offRange, map2) {
  if (!map2 || !map2.length)
    return offRange;
  const [start, end] = offRange;
  let i = 0, j = 0, p = 1;
  while (p < map2.length && map2[p] < start) {
    i = map2[p - 1];
    j = map2[p];
    p += 2;
  }
  const iA = start - j + i;
  while (p < map2.length && map2[p] < end) {
    i = map2[p - 1];
    j = map2[p];
    p += 2;
  }
  const iB = end - j + i;
  return [iA, iB];
}
function createMappedTextSegmenter(includeRanges) {
  let rangePos = 0;
  function* segmenter(pText) {
    if (!includeRanges.length) {
      return;
    }
    const range = pText.range;
    const textEndPos = range[1];
    let textStartPos = range[0];
    while (rangePos && (rangePos >= includeRanges.length || includeRanges[rangePos].startPos > textStartPos)) {
      rangePos -= 1;
    }
    const cur = includeRanges[rangePos];
    if (textEndPos <= cur.endPos && textStartPos >= cur.startPos) {
      yield pText;
      return;
    }
    while (textStartPos < textEndPos) {
      while (includeRanges[rangePos] && includeRanges[rangePos].endPos <= textStartPos) {
        rangePos += 1;
      }
      if (!includeRanges[rangePos]) {
        break;
      }
      const { startPos, endPos } = includeRanges[rangePos];
      if (textEndPos < startPos) {
        break;
      }
      const a = Math.max(textStartPos, startPos);
      const b = Math.min(textEndPos, endPos);
      if (a !== b) {
        yield extractTextMapRangeOrigin(pText, [a, b]);
      }
      textStartPos = b;
    }
  }
  return segmenter;
}

// ../../node_modules/cspell-lib/dist/lib/textValidation/lineValidatorFactory.js
var MIN_HEX_SEQUENCE_LENGTH2 = 8;
function lineValidatorFactory(sDict, options) {
  const { minWordLength = defaultMinWordLength, flagWords = [], allowCompoundWords = false, ignoreCase: ignoreCase2 = true, ignoreRandomStrings = defaultCSpellSettings.ignoreRandomStrings, minRandomLength = defaultCSpellSettings.minRandomLength, unknownWords = unknownWordsChoices.ReportAll, numSuggestions } = options;
  const hasWordOptions = {
    ignoreCase: ignoreCase2,
    useCompounds: allowCompoundWords || void 0
    // let the dictionaries decide on useCompounds if allow is false
  };
  const dictCol = createCachingDictionary(sDict, hasWordOptions);
  const knownWords = /* @__PURE__ */ new Map();
  const setOfFlagWords = new Set(flagWords);
  const setOfKnownIssues = /* @__PURE__ */ new Map();
  const setOfKnownSuccessfulWords = /* @__PURE__ */ new Set();
  const rememberFilter = (fn2) => (v) => {
    const keep = fn2(v);
    if (!keep) {
      setOfKnownSuccessfulWords.add(v.text);
    }
    return keep;
  };
  const filterAlreadyChecked = (wo) => {
    return !setOfKnownSuccessfulWords.has(wo.text);
  };
  const hasDict = {
    has(word) {
      const info = getWordInfo(word);
      if (info.isFound !== void 0)
        return info.isFound;
      if (info.isFlagged)
        return true;
      if (info.isFlagged)
        return false;
      info.isFound = dictCol.has(word);
      return info.isFound;
    }
  };
  function calcIgnored(info) {
    var _a19;
    (_a19 = info.isIgnored) != null ? _a19 : info.isIgnored = dictCol.isNoSuggestWord(info.word);
    return info.isIgnored;
  }
  function calcFlagged(info) {
    if (info.isFlagged !== void 0)
      return info.isFlagged;
    const word = info.word;
    info.isFlagged = (setOfFlagWords.has(word) || setOfFlagWords.has(word.toLowerCase()) || dictCol.isForbidden(word)) && !calcIgnored(info);
    return info.isFlagged;
  }
  function isWordIgnored(word) {
    return calcIgnored(getWordInfo(word));
  }
  const cacheGetPreferredSuggestions = /* @__PURE__ */ new Map();
  function getPreferredSuggestions(word) {
    return autoResolve2(cacheGetPreferredSuggestions, word, () => dictCol.getPreferredSuggestions(word));
  }
  const cacheHasSimpleSuggestions = /* @__PURE__ */ new Map();
  function getSimpleSuggestions(word) {
    const numSug = numSuggestions != null ? numSuggestions : 5;
    return autoResolve2(cacheHasSimpleSuggestions, word, () => {
      const sugs = dictCol.suggest(word, {
        numSuggestions: 1,
        compoundMethod: 0,
        includeTies: true,
        // We want the top suggestions even if there are ties
        ignoreCase: ignoreCase2,
        timeout: 100,
        numChanges: 1.8
        // Only consider very simple changes (1 edit distance plus case changes)
      });
      if (sugs.length > numSug) {
        sugs.length = numSug;
      }
      return sugs;
    });
  }
  function isWordFlagged(wo) {
    return calcFlagged(getWordInfo(wo.text));
  }
  function annotateIsFlagged(word) {
    word.isFlagged = isWordFlagged(word);
    return word;
  }
  function annotateIssue(issue) {
    const sugs = getPreferredSuggestions(issue.text);
    if (!(sugs == null ? void 0 : sugs.length)) {
      issue.hasPreferredSuggestions = sugs !== void 0 ? false : void 0;
      if (unknownWords === unknownWordsChoices.ReportSimple) {
        const sug = getSimpleSuggestions(issue.text);
        issue.hasSimpleSuggestions = !!sug.length;
        if (sug.length) {
          issue.suggestionsEx = sug.map((s) => ({ ...s, isPreferred: !!s.isPreferred }));
        }
      }
      return issue;
    }
    issue.suggestionsEx = sugs;
    issue.hasPreferredSuggestions = true;
    issue.hasSimpleSuggestions = true;
    return issue;
  }
  const isFlaggedOrMinLength = (wo) => wo.text.length >= minWordLength || !!wo.isFlagged;
  const isFlaggedOrNotFound = rememberFilter((wo) => wo.isFlagged || !wo.isFound);
  const isNotRepeatingChar = rememberFilter((wo) => !regExRepeatedChar.test(wo.text));
  function checkWord(issue) {
    var _a19, _b2, _c;
    const info = getWordInfo(issue.text);
    if (info.fin) {
      const { isFlagged: isForbidden, isFound, isIgnored: isIgnored2 } = info;
      const isFlagged2 = (_a19 = issue.isFlagged) != null ? _a19 : !isIgnored2 && isForbidden;
      issue.isFlagged = isFlagged2;
      issue.isFound = isFlagged2 ? void 0 : isFound;
      return issue;
    }
    const isIgnored = calcIgnored(info);
    const isFlagged = (_b2 = issue.isFlagged) != null ? _b2 : calcFlagged(info);
    (_c = info.isFound) != null ? _c : info.isFound = isFlagged ? false : isIgnored || isWordValidWithEscapeRetry(hasDict, issue, issue.line);
    info.isFlagged = !!isFlagged;
    info.fin = true;
    issue.isFlagged = isFlagged;
    issue.isFound = isFlagged ? void 0 : info.isFound;
    return issue;
  }
  const regExUpperCaseWithTrailingCommonEnglishSuffix = /^([\p{Lu}\p{M}]{2,})[']?(?:s|ing|ies|es|ings|ize|ed|ning)$/u;
  const regExpIsLetter = /\p{L}/u;
  const fn = (lineSegment) => {
    const line = lineSegment.line;
    function isWordTooShort(word, ignoreSuffix = false) {
      if (word.text.length >= minWordLength * 2 || [...word.text].length >= minWordLength)
        return false;
      const offset = word.offset - line.offset;
      import_node_assert8.default.equal(line.text.slice(offset, offset + word.text.length), word.text);
      const prefix = [...line.text.slice(Math.max(0, offset - 2), offset)];
      const hasLetterPrefix = !!prefix.length && regExpIsLetter.test(prefix[prefix.length - 1]);
      if (hasLetterPrefix)
        return false;
      if (ignoreSuffix)
        return true;
      const suffix = [...line.text.slice(offset + word.text.length, offset + word.text.length + 2)];
      const hasLetterSuffix = !!suffix.length && regExpIsLetter.test(suffix[0]);
      return !hasLetterSuffix;
    }
    function splitterIsValid(word) {
      if (setOfKnownSuccessfulWords.has(word.text))
        return true;
      if (isWordFlagged(word))
        return false;
      if (isWordValidWithEscapeRetry(hasDict, word, lineSegment.line))
        return true;
      if (isWordTooShort(word))
        return true;
      return isAllCapsWithTrailingCommonEnglishSuffixOk(word);
    }
    function isAllCapsWithTrailingCommonEnglishSuffixOk(tWord) {
      if (!regExUpperCaseWithTrailingCommonEnglishSuffix.test(tWord.text))
        return false;
      const m = tWord.text.match(regExUpperCaseWithTrailingCommonEnglishSuffix);
      if (!m)
        return false;
      const offset = tWord.offset;
      const v = { offset, text: m[1], line };
      const check = checkWord(v);
      if (check.isFlagged)
        return false;
      if (check.isFound)
        return true;
      if (isWordTooShort(v, true))
        return true;
      return false;
    }
    function checkFullWord(vr) {
      if (vr.isFlagged) {
        return [vr];
      }
      if (isAllCapsWithTrailingCommonEnglishSuffixOk(vr))
        return [];
      if (isWordIgnored(vr.text) || checkWord(vr).isFound) {
        rememberFilter((_) => false)(vr);
        return [];
      }
      if (vr.isFlagged)
        return [vr];
      const codeWordResults = checkCamelCaseWord(vr);
      if (!codeWordResults.length) {
        rememberFilter((_) => false)(vr);
        return [];
      }
      return codeWordResults;
    }
    function checkCamelCaseWord(vr) {
      return _checkCamelCaseWord(vr, regExpCamelCaseWordBreaksWithEnglishSuffix);
    }
    function _checkCamelCaseWord(vr, regExpWordBreaks) {
      const codeWordResults = [];
      for (const wo of splitWordWithOffset(vr, regExpWordBreaks)) {
        if (setOfKnownSuccessfulWords.has(wo.text))
          continue;
        const issue = wo;
        issue.line = vr.line;
        issue.isFlagged = void 0;
        issue.isFound = void 0;
        annotateIsFlagged(issue);
        if (!isFlaggedOrMinLength(issue))
          continue;
        checkWord(issue);
        if (!isFlaggedOrNotFound(issue) || !isNotRepeatingChar(issue))
          continue;
        issue.text = extractText(lineSegment.segment, issue.offset, issue.offset + issue.text.length);
        codeWordResults.push(issue);
      }
      return codeWordResults;
    }
    function rebaseKnownIssues(possibleWord, known) {
      const { issues } = known;
      const adjOffset = possibleWord.offset - known.possibleWord.offset;
      return issues.map((issue) => {
        issue = { ...issue };
        issue.offset += adjOffset;
        issue.line = lineSegment.line;
        return issue;
      });
    }
    function checkForFlaggedWord(possibleWord) {
      if (isWordFlagged(possibleWord)) {
        const vr = {
          ...possibleWord,
          line: lineSegment.line,
          isFlagged: true
        };
        return vr;
      }
      if (possibleWord.text.endsWith(".") && possibleWord.text.length > 1) {
        const pw = { ...possibleWord, text: possibleWord.text.slice(0, -1) };
        if (isWordFlagged(pw)) {
          const vr = {
            ...pw,
            line: lineSegment.line,
            isFlagged: true
          };
          return vr;
        }
      }
      return void 0;
    }
    function checkPossibleWords(possibleWord) {
      const known = setOfKnownIssues.get(possibleWord.text);
      if (known) {
        if (!known.issues.length)
          return known.issues;
        const adjusted = rebaseKnownIssues(possibleWord, known);
        return adjusted;
      }
      const issues = _checkPossibleWords(possibleWord).map(annotateIssue);
      setOfKnownIssues.set(possibleWord.text, { possibleWord, issues });
      return issues;
    }
    function _checkPossibleWords(possibleWord) {
      const flagged = checkForFlaggedWord(possibleWord);
      if (flagged)
        return [flagged];
      let mismatches = [];
      for (const wo of extractWordsFromTextOffset(possibleWord)) {
        if (setOfKnownSuccessfulWords.has(wo.text))
          continue;
        const issue = wo;
        issue.line = lineSegment.line;
        annotateIsFlagged(issue);
        if (!isFlaggedOrMinLength(issue))
          continue;
        for (const w of checkFullWord(issue)) {
          mismatches.push(w);
        }
      }
      if (!mismatches.length)
        return mismatches;
      const hexSequences = !ignoreRandomStrings ? void 0 : extractHexSequences(possibleWord.text, MIN_HEX_SEQUENCE_LENGTH2).filter(
        // Only consider hex sequences that are all upper case or all lower case and contain a `-` or a digit.
        (w) => (w.text === w.text.toLowerCase() || w.text === w.text.toUpperCase()) && /[\d-]/.test(w.text)
      ).map((w) => (w.offset += possibleWord.offset, w));
      if (hexSequences == null ? void 0 : hexSequences.length) {
        mismatches = filterExcludedTextOffsets(mismatches, hexSequences);
      }
      if (mismatches.length) {
        const splitResult = split(lineSegment.segment, possibleWord.offset, splitterIsValid);
        const nonMatching = splitResult.words.filter((w) => !w.isFound).filter((w) => {
          const m = w.text.match(regExUpperCaseWithTrailingCommonEnglishSuffix);
          if (!m)
            return true;
          const v = checkWord({ ...w, text: m[1], line: lineSegment.line });
          return v.isFlagged || !v.isFound;
        });
        const filtered = filterExcludedTextOffsets(nonMatching.map((w) => ({ ...w, line: lineSegment.line })).map(annotateIsFlagged), hexSequences);
        if (filtered.length < mismatches.length) {
          return filtered;
        }
      }
      return mismatches;
    }
    function isNotRandom(textOff) {
      if (textOff.text.length < minRandomLength || !ignoreRandomStrings)
        return true;
      return !isRandomString(textOff.text);
    }
    const checkedPossibleWords = pipeSync2(extractPossibleWordsFromTextOffset(lineSegment.segment), opFilterSync2(isNotRandom), opFilterSync2(filterAlreadyChecked), opConcatMapSync2(checkPossibleWords));
    return checkedPossibleWords;
  };
  function getWordInfo(word) {
    const info = knownWords.get(word);
    if (info)
      return info;
    const result = { word, isFound: void 0, isFlagged: void 0, isIgnored: void 0, fin: false };
    knownWords.set(word, result);
    return result;
  }
  return { fn, dict: dictCol };
}
function textValidatorFactory(dict, options) {
  const lineValidator = lineValidatorFactory(dict, options);
  const lineValidatorFn = lineValidator.fn;
  function validate(pText) {
    const { text, range: srcRange, map: map2 } = pText;
    const srcOffset = srcRange[0];
    const segment = { text, offset: 0 };
    const lineSegment = { line: segment, segment };
    function mapBackToOriginSimple(vr) {
      const { text: text2, offset, isFlagged, isFound, suggestionsEx, hasPreferredSuggestions, hasSimpleSuggestions } = vr;
      const r = mapRangeBackToOriginalPos([offset, offset + text2.length], map2);
      const range = [r[0] + srcOffset, r[1] + srcOffset];
      return { text: text2, range, isFlagged, isFound, suggestionsEx, hasPreferredSuggestions, hasSimpleSuggestions };
    }
    return [...lineValidatorFn(lineSegment)].map(mapBackToOriginSimple);
  }
  return {
    validate,
    lineValidator
  };
}
function filterExcludedTextOffsets(issues, excluded) {
  if (!(excluded == null ? void 0 : excluded.length))
    return issues;
  const keep = [];
  let i = 0;
  let j = 0;
  for (i = 0; i < issues.length && j < excluded.length; i++) {
    const issue = issues[i];
    while (j < excluded.length && excluded[j].offset + excluded[j].text.length <= issue.offset) {
      j++;
    }
    if (j >= excluded.length) {
      break;
    }
    if (issue.isFlagged || issue.offset < excluded[j].offset) {
      keep.push(issue);
    }
  }
  if (i < issues.length) {
    keep.push(...issues.slice(i));
  }
  return keep;
}

// ../../node_modules/cspell-lib/dist/lib/textValidation/settingsToValidateOptions.js
init_shim();
function settingsToValidateOptions(settings) {
  var _a19;
  const opt = {
    ...settings,
    ignoreCase: !((_a19 = settings.caseSensitive) != null ? _a19 : false),
    ignoreRandomStrings: settings.ignoreRandomStrings,
    minRandomLength: settings.minRandomLength,
    unknownWords: settings.unknownWords || "report-all"
  };
  return opt;
}

// ../../node_modules/cspell-lib/dist/lib/textValidation/textValidator.js
init_shim();

// ../../node_modules/cspell-lib/dist/lib/util/TextRange.js
init_shim();
function toMatchRangeWithText(m) {
  const index = m.index || 0;
  const _text2 = m[0];
  return {
    startPos: index,
    endPos: index + _text2.length,
    text: _text2
  };
}
function findMatchingRanges(pattern, text) {
  if (pattern.source === ".*") {
    return [{ startPos: 0, endPos: text.length }];
  }
  const regex = new RegExp(pattern);
  if (!regex.global) {
    const m = text.match(regex);
    if (!m)
      return [];
    return [toMatchRangeWithText(m)];
  }
  return [...text.matchAll(regex)].map(toMatchRangeWithText);
}
function compareRanges(a, b) {
  return a.startPos - b.startPos || a.endPos - b.endPos;
}
function unionRanges(ranges) {
  const sortedRanges = sortMatchRangeArray(ranges);
  ranges = sortedRanges.values;
  if (!ranges.length)
    return sortedRanges;
  let i = 0;
  let j = 0;
  let { startPos, endPos } = ranges[i++];
  for (; i < ranges.length; ++i) {
    const r = ranges[i];
    if (r.startPos > endPos) {
      ranges[j++] = { startPos, endPos };
      startPos = r.startPos;
      endPos = r.endPos;
      continue;
    }
    endPos = Math.max(endPos, r.endPos);
  }
  if (startPos < endPos) {
    ranges[j++] = { startPos, endPos };
  }
  ranges.length = j;
  return sortedRanges;
}
function findMatchingRangesForPatterns(patterns, text) {
  const nested = patterns.map((pattern) => findMatchingRanges(pattern, text));
  return unionRanges(flatten(nested)).values;
}
function excludeRanges(includeRanges, excludeRanges2) {
  return _excludeRanges(sortMatchRangeArray(includeRanges), sortMatchRangeArray(excludeRanges2));
}
function _excludeRanges(sortedIncludeRanges, sortedExcludeRanges) {
  const includeRanges = sortedIncludeRanges.values;
  const excludeRanges2 = sortedExcludeRanges.values;
  if (!includeRanges.length)
    return includeRanges;
  if (!excludeRanges2.length) {
    return includeRanges;
  }
  const ranges = [];
  ranges.length = includeRanges.length + excludeRanges2.length + 1;
  let i = 0;
  let exIndex = 0;
  const limit = excludeRanges2.length;
  for (const incRange of includeRanges) {
    const endPos = incRange.endPos;
    let startPos = incRange.startPos;
    for (; exIndex < limit; ++exIndex) {
      const ex = excludeRanges2[exIndex];
      if (ex.startPos >= endPos)
        break;
      if (ex.endPos <= startPos)
        continue;
      if (ex.startPos > startPos) {
        ranges[i++] = { startPos, endPos: ex.startPos };
      }
      startPos = ex.endPos;
      if (startPos >= endPos)
        break;
    }
    if (startPos < endPos) {
      ranges[i++] = { startPos, endPos };
    }
  }
  ranges.length = i;
  return ranges;
}
function sortMatchRangeArray(values) {
  values.sort(compareRanges);
  return { values };
}
function flatten(data) {
  let size = 0;
  for (let i = data.length - 1; i >= 0; --i) {
    size += data[i].length;
  }
  const result = new Array(size);
  let k = 0;
  for (let i = 0; i < data.length; ++i) {
    const d = data[i];
    for (let j = 0; j < d.length; ++j) {
      result[k++] = d[j];
    }
  }
  return result;
}

// ../../node_modules/cspell-lib/dist/lib/textValidation/textValidator.js
function calcTextInclusionRanges(text, options) {
  const { ignoreRegExpList = [], includeRegExpList = [] } = options;
  const filteredIncludeList = includeRegExpList.filter((a) => !!a);
  const finalIncludeList = filteredIncludeList.length ? filteredIncludeList : [/.*/gim];
  const includeRanges = excludeRanges(findMatchingRangesForPatterns(finalIncludeList, text), findMatchingRangesForPatterns(ignoreRegExpList, text));
  return includeRanges;
}

// ../../node_modules/cspell-lib/dist/lib/textValidation/traceWord.js
init_shim();
function traceWord(word, dictCollection, config) {
  var _a19;
  const opts = {
    ignoreCase: (_a19 = config.ignoreCase) != null ? _a19 : true,
    useCompounds: config.allowCompoundWords || false,
    compoundSeparator: "\u2022"
  };
  const splits = split({ text: word, offset: 0 }, 0, checkWord);
  const wfSplits = splits.words.map((s) => ({ word: s.text, found: s.isFound }));
  const unique2 = uniqueFn((w) => w.word + "|" + w.found);
  const wsFound = { word, found: dictCollection.has(word, opts) };
  const wordSplits = wfSplits.some((s) => s.word === word) ? wfSplits : [wsFound, ...wfSplits];
  const traces = wordSplits.filter(unique2).map((s) => s.word).flatMap((word2) => dictCollection.dictionaries.map((dict) => ({ dict, word: word2 }))).map(({ dict, word: word2 }) => ({ dict, findResult: dict.find(word2, opts), word: word2 })).flatMap((r2) => unpackDictionaryFindResult(r2, config));
  const r = new CTraceResult(...traces);
  r.splits = wordSplits;
  return r;
  function checkWord(wo) {
    return dictCollection.has(wo.text, opts);
  }
}
function unpackDictionaryFindResult(found, config) {
  var _a19, _b2, _c, _d;
  const { word, dict, findResult } = found;
  const dictPreferred = getPreferred(dict, word);
  const baseResult = {
    word,
    found: !!(findResult == null ? void 0 : findResult.found),
    foundWord: (findResult == null ? void 0 : findResult.found) || void 0,
    forbidden: (findResult == null ? void 0 : findResult.forbidden) || false,
    noSuggest: (findResult == null ? void 0 : findResult.noSuggest) || false,
    dictName: dict.name,
    dictSource: dict.source,
    configSource: void 0,
    preferredSuggestions: dictPreferred,
    errors: normalizeErrors((_a19 = dict.getErrors) == null ? void 0 : _a19.call(dict))
  };
  const configFieldName = mapSpecialDictionaryNamesToSettings.get(dict.name);
  if (!(findResult == null ? void 0 : findResult.found) || !configFieldName || !config.source) {
    return [baseResult];
  }
  const opts = {
    ignoreCase: true,
    useCompounds: config.allowCompoundWords || false
  };
  const sources = getSources(config);
  const results = [];
  for (const src of sources) {
    if (!src[configFieldName] || !Array.isArray(src[configFieldName]) || !((_b2 = src[configFieldName]) == null ? void 0 : _b2.length) || !((_c = src.source) == null ? void 0 : _c.filename)) {
      continue;
    }
    const configSource = toFileUrl(src.source.filename).href;
    const cfg = { [configFieldName]: src[configFieldName] };
    const cfgDict = createCollection(getInlineConfigDictionaries(cfg), dict.name, configSource);
    const findResult2 = cfgDict.find(word, opts);
    const preferredSuggestions = getPreferred(cfgDict, word);
    if (!(findResult2 == null ? void 0 : findResult2.found) && !preferredSuggestions)
      continue;
    const result = {
      word,
      found: !!(findResult2 == null ? void 0 : findResult2.found),
      foundWord: (findResult2 == null ? void 0 : findResult2.found) || void 0,
      forbidden: (findResult2 == null ? void 0 : findResult2.forbidden) || false,
      noSuggest: (findResult2 == null ? void 0 : findResult2.noSuggest) || false,
      dictName: dict.name,
      dictSource: configSource,
      configSource,
      preferredSuggestions,
      errors: normalizeErrors((_d = dict.getErrors) == null ? void 0 : _d.call(dict))
    };
    results.push(result);
  }
  return results.length ? results : [baseResult];
}
function normalizeErrors(errors) {
  return (errors == null ? void 0 : errors.length) ? errors : void 0;
}
function getPreferred(dict, word) {
  var _a19;
  const sugs = (_a19 = dict.getPreferredSuggestions) == null ? void 0 : _a19.call(dict, word);
  const preferred = (sugs == null ? void 0 : sugs.length) ? sugs.filter((s) => s.isPreferred).map((s) => s.word) : void 0;
  return preferred;
}
var CTraceResult = class extends Array {
  constructor(...items) {
    super(...items);
    __publicField(this, "splits", []);
  }
};

// ../../node_modules/cspell-lib/dist/lib/textValidation/docValidator.js
var ERROR_NOT_PREPARED = "Validator Must be prepared before calling this function.";
var DocumentValidator = class _DocumentValidator {
  /**
   * @param doc - Document to validate
   * @param config - configuration to use (not finalized).
   */
  constructor(doc, options, settings) {
    __publicField(this, "settings");
    __publicField(this, "_document");
    __publicField(this, "_ready", false);
    __publicField(this, "errors", []);
    __publicField(this, "_prepared");
    __publicField(this, "_preparations");
    __publicField(this, "_preparationTime", -1);
    __publicField(this, "_suggestions", new AutoCache((text) => this.genSuggestions(text), 1e3));
    __publicField(this, "options");
    __publicField(this, "perfTiming", {});
    __publicField(this, "skipValidation");
    var _a19;
    this.settings = settings;
    this._document = doc;
    this.options = { ...options };
    const numSuggestions = (_a19 = this.options.numSuggestions) != null ? _a19 : settings.numSuggestions;
    if (numSuggestions !== void 0) {
      this.options.numSuggestions = numSuggestions;
    }
    this.skipValidation = !!options.skipValidation;
  }
  static async create(doc, options, settingsOrConfigFile) {
    const settings = satisfiesCSpellConfigFile(settingsOrConfigFile) ? await resolveConfigFileImports(settingsOrConfigFile) : settingsOrConfigFile;
    const validator = new _DocumentValidator(doc, options, settings);
    await validator.prepare();
    return validator;
  }
  get ready() {
    return this._ready;
  }
  prepare() {
    if (this._ready)
      return Promise.resolve();
    if (this._prepared)
      return this._prepared;
    this._prepared = this._prepareAsync();
    return this._prepared;
  }
  async _prepareAsync() {
    var _a19, _b2, _c;
    (0, import_node_assert9.default)(!this._ready);
    const timer = createPerfTimer("_prepareAsync");
    const { options, settings: rawSettings } = this;
    const resolveImportsRelativeTo = toFileURL(options.resolveImportsRelativeTo || toFileURL("./virtual.settings.json"));
    const settings = ((_a19 = rawSettings.import) == null ? void 0 : _a19.length) ? await resolveSettingsImports(rawSettings, resolveImportsRelativeTo) : rawSettings;
    const useSearchForConfig = !options.noConfigSearch && !settings.noConfigSearch || options.noConfigSearch === false;
    const pLocalConfig = options.configFile ? loadConfig(options.configFile, settings) : useSearchForConfig ? timePromise(this.perfTiming, "__searchForDocumentConfig", searchForDocumentConfig(this._document, settings, settings)) : void 0;
    if (pLocalConfig) {
      timePromise(this.perfTiming, "_loadConfig", pLocalConfig).catch(() => void 0);
    }
    const localConfig = await catchPromiseError(pLocalConfig, (e) => this.addPossibleError(e)) || {};
    extractImportErrors(localConfig).forEach((e) => this.addPossibleError(e.error));
    const config = mergeSettings(settings, localConfig);
    const docSettings = await timePromise(this.perfTiming, "_determineTextDocumentSettings", determineTextDocumentSettings(this._document, config));
    const dict = await timePromise(this.perfTiming, "_getDictionaryInternal", getDictionaryInternal(docSettings));
    const stopMeasure = measurePerf("DocumentValidator._prepareAsync");
    const recGlobMatcherTime = recordPerfTime(this.perfTiming, "_GlobMatcher");
    const matcher = getGlobMatcherForExcluding(localConfig == null ? void 0 : localConfig.ignorePaths);
    const uri = this._document.uri;
    recGlobMatcherTime();
    const recShouldCheckTime = recordPerfTime(this.perfTiming, "_shouldCheck");
    const shouldCheck = !matcher.match(uriToFilePath(uri)) && ((_b2 = docSettings.enabled) != null ? _b2 : true);
    recShouldCheckTime();
    const recFinalizeTime = recordPerfTime(this.perfTiming, "_finalizeSettings");
    const finalSettings = finalizeSettings(docSettings);
    const validateOptions = settingsToValidateOptions(finalSettings);
    const includeRanges = calcTextInclusionRanges(this._document.text, validateOptions);
    const segmenter = createMappedTextSegmenter(includeRanges);
    const textValidator = textValidatorFactory(dict, validateOptions);
    recFinalizeTime();
    this._preparations = {
      config,
      dictionary: dict,
      docSettings,
      finalSettings,
      shouldCheck,
      validateOptions,
      includeRanges,
      segmenter,
      textValidator,
      localConfig,
      localConfigFilepath: (_c = localConfig == null ? void 0 : localConfig.__importRef) == null ? void 0 : _c.filename
    };
    this._ready = true;
    this._preparationTime = timer.elapsed;
    this.perfTiming.prepTime = this._preparationTime;
    stopMeasure();
  }
  async _updatePrep() {
    var _a19;
    (0, import_node_assert9.default)(this._preparations, ERROR_NOT_PREPARED);
    const timer = createPerfTimer("_updatePrep");
    const prep = this._preparations;
    const docSettings = await determineTextDocumentSettings(this._document, prep.config);
    const dict = await getDictionaryInternal(docSettings);
    const stopMeasure = measurePerf("DocumentValidator._updatePrep");
    const shouldCheck = (_a19 = docSettings.enabled) != null ? _a19 : true;
    const finalSettings = finalizeSettings(docSettings);
    const validateOptions = settingsToValidateOptions(finalSettings);
    const includeRanges = calcTextInclusionRanges(this._document.text, validateOptions);
    const segmenter = createMappedTextSegmenter(includeRanges);
    const textValidator = textValidatorFactory(dict, validateOptions);
    this._preparations = {
      ...prep,
      dictionary: dict,
      docSettings,
      shouldCheck,
      validateOptions,
      includeRanges,
      segmenter,
      textValidator
    };
    this._preparationTime = timer.elapsed;
    stopMeasure();
  }
  /**
   * The amount of time in ms to prepare for validation.
   */
  get prepTime() {
    return this._preparationTime;
  }
  get validateDirectives() {
    var _a19, _b2, _c;
    return (_c = (_b2 = this.options.validateDirectives) != null ? _b2 : (_a19 = this._preparations) == null ? void 0 : _a19.config.validateDirectives) != null ? _c : false;
  }
  /**
   * Check a range of text for validation issues.
   * @param range - the range of text to check.
   * @param _text - the text to check. If not given, the text will be taken from the document.
   * @param scope - the scope to use for validation. If not given, the default scope will be used.
   * @returns the validation issues.
   */
  checkText(range, _text2, scope) {
    const text = this._document.text.slice(range[0], range[1]);
    scope = (Array.isArray(scope) ? scope.join(" ") : scope) || "";
    return this.check({ text, range, scope });
  }
  check(parsedText) {
    (0, import_node_assert9.default)(this._ready);
    (0, import_node_assert9.default)(this._preparations, ERROR_NOT_PREPARED);
    const { segmenter, textValidator } = this._preparations;
    const document2 = this._document;
    let line = void 0;
    function mapToIssue(issue) {
      const { range, text, isFlagged, isFound, suggestionsEx, hasPreferredSuggestions, hasSimpleSuggestions } = issue;
      const offset = range[0];
      const length = range[1] - range[0];
      (0, import_node_assert9.default)(!line || line.offset <= offset);
      if (!line || line.offset + line.text.length <= offset) {
        line = document2.lineAt(offset);
      }
      return {
        text,
        offset,
        line,
        length,
        isFlagged,
        isFound,
        suggestionsEx,
        hasPreferredSuggestions,
        hasSimpleSuggestions
      };
    }
    const issues = [...pipeSync2(segmenter(parsedText), opConcatMapSync2(textValidator.validate), opMapSync2(mapToIssue))];
    if (!this.options.generateSuggestions) {
      return issues.map((issue) => {
        if (!issue.suggestionsEx)
          return issue;
        const suggestionsEx = this.adjustSuggestions(issue.text, issue.suggestionsEx);
        const suggestions = suggestionsEx.map((s) => s.word);
        return { ...issue, suggestionsEx, suggestions };
      });
    }
    const withSugs = issues.map((t) => {
      const text = t.text;
      const suggestionsEx = this.getSuggestions(text);
      t.suggestionsEx = suggestionsEx;
      t.suggestions = suggestionsEx.map((s) => s.word);
      return t;
    });
    return withSugs;
  }
  /**
   * Check a Document for Validation Issues.
   * @param forceCheck - force a check even if the document would normally be excluded.
   * @returns the validation issues.
   */
  async checkDocumentAsync(forceCheck) {
    await this.prepare();
    return this.checkDocument(forceCheck);
  }
  /**
   * Check a Document for Validation Issues.
   *
   * Note: The validator must be prepared before calling this method.
   * @param forceCheck - force a check even if the document would normally be excluded.
   * @returns the validation issues.
   */
  checkDocument(forceCheck = false) {
    const timerDone = recordPerfTime(this.perfTiming, "checkDocument");
    try {
      if (this.skipValidation)
        return [];
      (0, import_node_assert9.default)(this._ready);
      (0, import_node_assert9.default)(this._preparations, ERROR_NOT_PREPARED);
      const spellingIssues = forceCheck || this.shouldCheckDocument() ? [...this._checkParsedText(this._parse())] : [];
      const directiveIssues = this.checkDocumentDirectives();
      const allIssues = [...spellingIssues, ...directiveIssues].map(cleanValidationIssue).sort((a, b) => a.offset - b.offset);
      return allIssues;
    } finally {
      timerDone();
    }
  }
  checkDocumentDirectives(forceCheck = false) {
    (0, import_node_assert9.default)(this._ready);
    (0, import_node_assert9.default)(this._preparations, ERROR_NOT_PREPARED);
    const validateDirectives = forceCheck || this.validateDirectives;
    if (!validateDirectives)
      return [];
    const document2 = this.document;
    const issueType = IssueType.directive;
    function toValidationIssue(dirIssue) {
      const { text, range, suggestions, suggestionsEx, message } = dirIssue;
      const offset = range[0];
      const pos = document2.positionAt(offset);
      const line = document2.getLine(pos.line);
      const issue = { text, offset, line, suggestions, suggestionsEx, message, issueType };
      return issue;
    }
    return [...validateInDocumentSettings(this.document.text, this._preparations.config)].map(toValidationIssue);
  }
  get document() {
    return this._document;
  }
  async updateDocumentText(text) {
    updateTextDocument(this._document, [{ text }]);
    await this._updatePrep();
  }
  /**
   * Get the calculated ranges of text that should be included in the spell checking.
   * @returns MatchRanges of text to include.
   */
  getCheckedTextRanges() {
    (0, import_node_assert9.default)(this._preparations, ERROR_NOT_PREPARED);
    return this._preparations.includeRanges;
  }
  traceWord(word) {
    (0, import_node_assert9.default)(this._preparations, ERROR_NOT_PREPARED);
    return traceWord(word, this._preparations.dictionary, this._preparations.config);
  }
  defaultParser() {
    return pipeSync2(this.document.getLines(), opMapSync2((line) => {
      const { text, offset } = line;
      const range = [offset, offset + text.length];
      return { text, range };
    }));
  }
  *_checkParsedText(parsedTexts) {
    (0, import_node_assert9.default)(this._preparations, ERROR_NOT_PREPARED);
    const { maxNumberOfProblems = defaultMaxNumberOfProblems, maxDuplicateProblems = defaultMaxDuplicateProblems } = this._preparations.validateOptions;
    let numProblems = 0;
    const mapOfProblems = /* @__PURE__ */ new Map();
    const stopMeasure = measurePerf("DocumentValidator._checkParsedText");
    for (const pText of parsedTexts) {
      for (const issue of this.check(pText)) {
        const { text } = issue;
        const n = (mapOfProblems.get(text) || 0) + 1;
        mapOfProblems.set(text, n);
        if (n > maxDuplicateProblems)
          continue;
        yield issue;
        if (++numProblems >= maxNumberOfProblems)
          return;
      }
    }
    stopMeasure();
  }
  addPossibleError(error) {
    if (!error)
      return;
    error = this.errors.push(toError2(error));
  }
  _parse() {
    (0, import_node_assert9.default)(this._preparations, ERROR_NOT_PREPARED);
    const parser = this._preparations.finalSettings.parserFn;
    if (typeof parser !== "object")
      return this.defaultParser();
    return parser.parse(this.document.text, toFilePathOrHref(documentUriToURL(this.document.uri))).parsedTexts;
  }
  getSuggestions(text) {
    return this._suggestions.get(text);
  }
  genSuggestions(text) {
    var _a19;
    (0, import_node_assert9.default)(this._preparations, ERROR_NOT_PREPARED);
    const settings = this._preparations.docSettings;
    const dict = this._preparations.dictionary;
    const sugOptions = {
      compoundMethod: 0,
      numSuggestions: this.options.numSuggestions,
      includeTies: false,
      ignoreCase: !((_a19 = settings.caseSensitive) != null ? _a19 : false),
      timeout: settings.suggestionsTimeout,
      numChanges: settings.suggestionNumChanges
    };
    const rawSuggestions = dict.suggest(text, sugOptions);
    return this.adjustSuggestions(text, rawSuggestions);
  }
  adjustSuggestions(text, rawSuggestions) {
    var _a19;
    (0, import_node_assert9.default)(this._preparations, ERROR_NOT_PREPARED);
    const settings = this._preparations.docSettings;
    const ignoreCase2 = !((_a19 = settings.caseSensitive) != null ? _a19 : false);
    const locale = this._preparations.config.language;
    const dict = this._preparations.dictionary;
    const sugsWithAlt = calcSuggestionAdjustedToToMatchCase(text, rawSuggestions.map(mapSug), locale, ignoreCase2, dict);
    return sugsWithAlt.map(sanitizeSuggestion);
  }
  getFinalizedDocSettings() {
    (0, import_node_assert9.default)(this._ready);
    (0, import_node_assert9.default)(this._preparations, ERROR_NOT_PREPARED);
    return this._preparations.docSettings;
  }
  getConfigErrors() {
    const settings = this.getFinalizedDocSettings();
    const errors = extractImportErrors(settings);
    return errors.length ? errors : void 0;
  }
  getDictionaryErrors() {
    (0, import_node_assert9.default)(this._ready);
    (0, import_node_assert9.default)(this._preparations, ERROR_NOT_PREPARED);
    const { dictionary } = this._preparations;
    const errors = dictionary.dictionaries.map((dict) => {
      var _a19;
      return [dict.name, (_a19 = dict.getErrors) == null ? void 0 : _a19.call(dict)];
    }).filter((entry) => entry[1] && entry[1].length > 0 || false);
    return errors.length ? new Map(errors) : void 0;
  }
  /**
   * Returns true if the final result of the configuration calculation results
   * in the document being enabled. Note: in some cases, checking the document
   * might still make sense, for example, the `@cspell/eslint-plugin` relies on
   * `eslint` configuration to make that determination.
   * @returns true if the document settings have resolved to be `enabled`
   */
  shouldCheckDocument() {
    (0, import_node_assert9.default)(this._preparations, ERROR_NOT_PREPARED);
    return this._preparations.shouldCheck;
  }
  /**
   * Internal `cspell-lib` use.
   */
  _getPreparations() {
    return this._preparations;
  }
};
function sanitizeSuggestion(sug) {
  const { word, isPreferred, wordAdjustedToMatchCase } = sug;
  if (isPreferred && wordAdjustedToMatchCase)
    return { word, wordAdjustedToMatchCase, isPreferred };
  if (isPreferred)
    return { word, isPreferred };
  if (wordAdjustedToMatchCase)
    return { word, wordAdjustedToMatchCase };
  return { word };
}
async function searchForDocumentConfig(document2, defaultConfig, pnpSettings) {
  const url = documentUriToURL(document2.uri);
  try {
    return await searchForConfig(url, pnpSettings).then((s) => s || defaultConfig);
  } catch (e) {
    if (url.protocol !== "file:")
      return defaultConfig;
    throw e;
  }
}
function mapSug(sug) {
  return { cost: 999, ...sug };
}
function recordPerfTime(timings, name) {
  const timer = createPerfTimer(name, (elapsed) => timings[name] = elapsed);
  return () => timer.end();
}
function timePromise(timings, name, p) {
  return p.finally(recordPerfTime(timings, name));
}

// ../../node_modules/cspell-lib/dist/lib/spellCheckFile.js
async function spellCheckDocument(document2, options, settingsOrConfigFile) {
  const settingsUsed = satisfiesCSpellConfigFile(settingsOrConfigFile) ? settingsOrConfigFile.settings : settingsOrConfigFile;
  if (isBinaryDoc(document2)) {
    return {
      document: document2,
      options,
      settingsUsed,
      localConfigFilepath: void 0,
      issues: [],
      checked: false,
      errors: void 0
    };
  }
  try {
    const timer = createPerfTimer("loadFile");
    const doc = await resolveDocument(document2).finally(() => timer.end());
    if (isBinaryDoc(doc)) {
      return {
        document: document2,
        options,
        settingsUsed,
        localConfigFilepath: void 0,
        issues: [],
        checked: false,
        errors: void 0
      };
    }
    const result = await spellCheckFullDocument(doc, options, settingsOrConfigFile);
    const perf = result.perf || {};
    perf.loadTimeMs = timer.elapsed;
    result.perf = perf;
    return result;
  } catch (e) {
    const errors = isError2(e) ? [e] : [];
    return {
      document: document2,
      options,
      settingsUsed,
      localConfigFilepath: void 0,
      issues: [],
      checked: false,
      errors
    };
  }
}
var memoizedCloneSettingsForExport = memoizeLastCall(cloneSettingsForExport);
async function spellCheckFullDocument(document2, options, settingsOrConfigFile) {
  const perf = {};
  const timer = createPerfTimer("spellCheckFullDocument", (elapsed) => perf.totalTimeMs = elapsed);
  const timerCheck = createPerfTimer("check", (elapsed) => perf.checkTimeMs = elapsed);
  const timerPrepare = createPerfTimer("prepare", (elapsed) => perf.prepareTimeMs = elapsed);
  const doc = documentToTextDocument(document2);
  const docValOptions = options;
  const docValidator = await DocumentValidator.create(doc, docValOptions, settingsOrConfigFile).finally(() => timerPrepare.end());
  Object.assign(perf, Object.fromEntries(Object.entries(docValidator.perfTiming).map(([k, v]) => ["_" + k, v])));
  const prep = docValidator._getPreparations();
  if (docValidator.errors.length) {
    const settingsUsed = (prep == null ? void 0 : prep.localConfig) || (satisfiesCSpellConfigFile(settingsOrConfigFile) ? settingsOrConfigFile.settings : settingsOrConfigFile);
    return {
      document: document2,
      options,
      settingsUsed,
      localConfigFilepath: prep == null ? void 0 : prep.localConfigFilepath,
      issues: [],
      checked: false,
      errors: docValidator.errors,
      configErrors: docValidator.getConfigErrors(),
      dictionaryErrors: docValidator.getDictionaryErrors(),
      perf
    };
  }
  timerCheck.start();
  const issues = docValidator.checkDocument();
  timerCheck.end();
  Object.assign(perf, Object.fromEntries(Object.entries(docValidator.perfTiming).map(([k, v]) => ["_" + k, v])));
  const result = {
    document: document2,
    options,
    settingsUsed: docValidator.getFinalizedDocSettings(),
    localConfigFilepath: prep == null ? void 0 : prep.localConfigFilepath,
    issues,
    checked: docValidator.shouldCheckDocument(),
    errors: void 0,
    configErrors: docValidator.getConfigErrors(),
    dictionaryErrors: docValidator.getDictionaryErrors(),
    perf
  };
  timer.end();
  return result;
}
export {
  spellCheckDocument
};
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

assert/build/internal/util/comparisons.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)

punycode/punycode.js:
  (*! https://mths.be/punycode v1.4.1 by @mathias *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
