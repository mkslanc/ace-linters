const fs = require("fs");
const path = require("path");
const { execFileSync } = require("child_process");
const { pathToFileURL } = require("url");
const { generateDtsBundle } = require("dts-bundle-generator");

/** @type import('dts-bundle-generator/config-schema').OutputOptions */
const commonOutputParams = {
    inlineDeclareGlobals: false,
    noBanner: true
};

const pkgRoot = __dirname;
const buildDir = path.resolve(pkgRoot, "build");
const tempDir = path.resolve(buildDir, ".dts-tmp");
const emittedDeclDir = path.resolve(tempDir, "emitted");
const dictAssetsSrcDir = path.resolve(pkgRoot, "src/lib/dicts");
const dictAssetsMetaSrcFile = path.resolve(pkgRoot, "src/lib/cspell-dict-assets.generated.js");
const dictAssetsOutDir = path.resolve(buildDir, "dicts");
const esmResolverOutFile = path.resolve(buildDir, "esm-dicts-resolver.js");
const esmResolverDtsOutFile = path.resolve(buildDir, "esm-dicts-resolver.d.ts");
const declarationFiles = ["ace-spell-check.d.ts", "service.d.ts", "ace-spell-check-converters.d.ts"];

function rewriteForBundling(source, sourceFileName) {
    let rewritten = source.replace(
        /from "ace-linters\/src\/services\/base-service"/g,
        'from "ace-linters/build/base-service"'
    );

    if (sourceFileName === "service.d.ts") {
        rewritten = rewritten.replace(
            /from "ace-linters\/src\/types\/language-service"/g,
            'from "ace-linters/build/ace-language-client"'
        );
    } else {
        rewritten = rewritten.replace(
            /from "ace-linters\/src\/types\/language-service"/g,
            'from "ace-linters/build/base-service"'
        );
    }

    return rewritten;
}

function emitDeclarations() {
    fs.mkdirSync(emittedDeclDir, { recursive: true });
    execFileSync(
        process.execPath,
        [
            require.resolve("typescript/bin/tsc"),
            "--project",
            path.resolve(pkgRoot, "tsconfig.json"),
            "--emitDeclarationOnly",
            "--declaration",
            "--declarationDir",
            emittedDeclDir
        ],
        { cwd: pkgRoot, stdio: "inherit" }
    );
}

function findDeclarationFile(typesDir, fileName) {
    const direct = path.resolve(typesDir, fileName);
    if (fs.existsSync(direct)) {
        return direct;
    }

    const stack = [typesDir];
    while (stack.length > 0) {
        const current = stack.pop();
        const entries = fs.readdirSync(current, { withFileTypes: true });
        for (const entry of entries) {
            const fullPath = path.resolve(current, entry.name);
            if (entry.isDirectory()) {
                stack.push(fullPath);
                continue;
            }
            if (entry.isFile() && entry.name === fileName) {
                return fullPath;
            }
        }
    }

    throw new Error(`Declaration file not found after emit: ${fileName}`);
}

function copyAndRewriteTypes(typesDir) {
    fs.mkdirSync(tempDir, { recursive: true });
    declarationFiles.forEach((fileName) => {
        const input = fs.readFileSync(findDeclarationFile(typesDir, fileName), "utf8");
        fs.writeFileSync(path.resolve(tempDir, fileName), rewriteForBundling(input, fileName), "utf8");
    });
}

function cleanupTempDir() {
    if (!fs.existsSync(tempDir)) {
        return;
    }
    try {
        fs.rmSync(tempDir, { recursive: true, force: true, maxRetries: 5, retryDelay: 100 });
    } catch (error) {
        if (!error || error.code !== "EPERM") {
            throw error;
        }
    }
}

function copyDictionaryAssets() {
    if (fs.existsSync(dictAssetsOutDir)) {
        fs.rmSync(dictAssetsOutDir, { recursive: true, force: true });
    }
    if (!fs.existsSync(dictAssetsSrcDir)) {
        return;
    }
    fs.cpSync(dictAssetsSrcDir, dictAssetsOutDir, { recursive: true });
}

async function generateEsmDictionaryResolver() {
    if (!fs.existsSync(dictAssetsMetaSrcFile)) {
        return;
    }

    const dictAssetsMetaUrl = pathToFileURL(dictAssetsMetaSrcFile).href;
    const manifestModule = await import(dictAssetsMetaUrl);
    const packageToAssetFile =
        manifestModule?.cspellDictAssetFileByPackage ||
        manifestModule?.default?.cspellDictAssetFileByPackage ||
        {};
    const entries = Object.entries(packageToAssetFile)
        .filter(([pkg, fileName]) => typeof pkg === "string" && typeof fileName === "string")
        .sort((a, b) => a[0].localeCompare(b[0]));

    const mapEntriesSource = entries
        .map(([packageName, fileName]) => `  ${JSON.stringify(packageName)}: new URL(${JSON.stringify(`./dicts/${fileName}`)}, import.meta.url).href`)
        .join(",\n");

    const source = `// This file is auto-generated by postbuild.js.
// Do not edit by hand.

const dictAssetUrlsByPackage = {
${mapEntriesSource}
};

const globalScope = typeof globalThis === "undefined" ? undefined : globalThis;
if (globalScope) {
  const prev = globalScope.__aceSpellCheckDictAssetUrls || {};
  globalScope.__aceSpellCheckDictAssetUrls = { ...prev, ...dictAssetUrlsByPackage };
}

export { dictAssetUrlsByPackage };
export default dictAssetUrlsByPackage;
`;
    const dtsSource = `export declare const dictAssetUrlsByPackage: Record<string, string>;
declare const _default: Record<string, string>;
export default _default;
`;

    fs.mkdirSync(buildDir, { recursive: true });
    fs.writeFileSync(esmResolverOutFile, source, "utf8");
    fs.writeFileSync(esmResolverDtsOutFile, dtsSource, "utf8");
}

function bundleDeclarations() {
    const entries = [
        {
            filePath: path.resolve(tempDir, "ace-spell-check.d.ts"),
            outFile: path.resolve(buildDir, "ace-spell-check.d.ts"),
            output: commonOutputParams,
            libraries: {
                inlinedLibraries: ["@cspell/cspell-types", "ace-linters"],
                importedLibraries: [
                    "vscode-languageserver-protocol",
                    "vscode-languageserver-textdocument"
                ]
            }
        }
    ];

    const bundles = generateDtsBundle(entries, {
        preferredConfigPath: path.resolve(pkgRoot, "tsconfig.json"),
        followSymlinks: false
    });

    fs.mkdirSync(buildDir, { recursive: true });
    bundles.forEach((bundle, index) => {
        fs.writeFileSync(entries[index].outFile, bundle);
    });
}

async function runPostbuild() {
    try {
        copyDictionaryAssets();
        await generateEsmDictionaryResolver();
        emitDeclarations();
        copyAndRewriteTypes(emittedDeclDir);
        bundleDeclarations();
    } finally {
        cleanupTempDir();
    }
}

runPostbuild().catch((error) => {
    console.error(error);
    process.exit(1);
});
