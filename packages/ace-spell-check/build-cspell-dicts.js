const fs = require("fs");
const path = require("path");
const { pathToFileURL } = require("url");
const { parse: parseJsonc } = require("jsonc-parser");

const pkgRoot = __dirname;
const cspellScopeDir = path.resolve(pkgRoot, "../../node_modules/@cspell");
const bundledDictConfigFile = path.resolve(
  pkgRoot,
  "../../node_modules/@cspell/cspell-bundled-dicts/cspell-default.config.js"
);
const outDir = path.resolve(pkgRoot, "src/lib");
const settingsOutFile = path.resolve(outDir, "cspell-settings.generated.js");
const vfsOutFile = path.resolve(outDir, "cspell-vfs.generated.js");

const isObject = (v) => !!v && typeof v === "object" && !Array.isArray(v);

function stableStringify(value) {
  if (Array.isArray(value)) {
    return `[${value.map(stableStringify).join(",")}]`;
  }
  if (isObject(value)) {
    const keys = Object.keys(value).sort();
    return `{${keys.map((k) => `${JSON.stringify(k)}:${stableStringify(value[k])}`).join(",")}}`;
  }
  return JSON.stringify(value);
}

function toJsLiteral(value, indent = 0) {
  const pad = " ".repeat(indent);
  const padIn = " ".repeat(indent + 2);

  if (value === null) return "null";
  if (value instanceof RegExp) return value.toString();
  if (Array.isArray(value)) {
    if (value.length === 0) return "[]";
    return `[\n${value.map((v) => `${padIn}${toJsLiteral(v, indent + 2)}`).join(",\n")}\n${pad}]`;
  }
  if (isObject(value)) {
    const entries = Object.entries(value).filter(([, v]) => v !== undefined);
    if (!entries.length) return "{}";
    const props = entries.map(([k, v]) => {
      const key = /^[A-Za-z_$][A-Za-z0-9_$]*$/.test(k) ? k : JSON.stringify(k);
      return `${padIn}${key}: ${toJsLiteral(v, indent + 2)}`;
    });
    return `{\n${props.join(",\n")}\n${pad}}`;
  }
  return JSON.stringify(value);
}

function resolveImportPath(importRef) {
  if (importRef.startsWith("@cspell/")) {
    return path.resolve(pkgRoot, "../../node_modules", importRef);
  }
  return path.resolve(path.dirname(bundledDictConfigFile), importRef);
}

function toVfsPath(packageName, relativeFilePath) {
  const cleaned = relativeFilePath
    .replace(/^[./\\]+/, "")
    .replace(/\\/g, "/");
  return `/__cspell_vfs/${packageName}/${cleaned}`;
}

function dedupeArray(items) {
  const seen = new Set();
  const out = [];
  for (const item of items) {
    const key = stableStringify(item);
    if (seen.has(key)) continue;
    seen.add(key);
    out.push(item);
  }
  return out;
}

async function loadDefaultBundledSettings() {
  const mod = await import(pathToFileURL(bundledDictConfigFile).href);
  return structuredClone(mod.default);
}

function listAllDictionaryExtensionFiles() {
  const dictPackageDirs = fs
    .readdirSync(cspellScopeDir, { withFileTypes: true })
    .filter((d) => d.isDirectory() && d.name.startsWith("dict-"))
    .map((d) => path.resolve(cspellScopeDir, d.name));

  return dictPackageDirs
    .map((pkgDir) => path.resolve(pkgDir, "cspell-ext.json"))
    .filter((extFile) => fs.existsSync(extFile));
}

function packageNameFromExtFile(extFile) {
  const parts = extFile.split(path.sep);
  const scopeIndex = parts.lastIndexOf("@cspell");
  if (scopeIndex >= 0 && parts[scopeIndex + 1]) {
    return `@cspell/${parts[scopeIndex + 1]}`;
  }
  return "unknown";
}

function mergeExtSettings(baseSettings, extSettings, extFile, dictDefByName, vfsByPath) {
  const packageName = packageNameFromExtFile(extFile);
  const dictionaries = extSettings.dictionaries || [];
  const dictionaryDefinitions = extSettings.dictionaryDefinitions || [];
  const languageSettings = extSettings.languageSettings || [];
  const words = extSettings.words || [];
  const flagWords = extSettings.flagWords || [];
  const suggestWords = extSettings.suggestWords || [];
  const ignoreWords = extSettings.ignoreWords || [];

  baseSettings.dictionaries.push(...dictionaries);
  baseSettings.languageSettings.push(...languageSettings);
  baseSettings.words.push(...words);
  baseSettings.flagWords.push(...flagWords);
  baseSettings.suggestWords.push(...suggestWords);
  baseSettings.ignoreWords.push(...ignoreWords);

  for (const definition of dictionaryDefinitions) {
    if (!definition || !definition.name || !definition.path) continue;
    const sourcePath = path.resolve(path.dirname(extFile), definition.path);
    if (!fs.existsSync(sourcePath)) continue;

    const vfsPath = toVfsPath(packageName, definition.path);
    const sourceBytes = fs.readFileSync(sourcePath);
    vfsByPath.set(vfsPath, sourceBytes.toString("base64"));

    dictDefByName.set(definition.name, {
      ...definition,
      path: vfsPath,
    });
    baseSettings.dictionaries.push(definition.name);
  }
}

function writeGeneratedSettings(settings) {
  const source = `// This file is auto-generated by build-cspell-dicts.js.
// Do not edit by hand.

export const cspellGeneratedSettings = ${toJsLiteral(settings, 0)};

export default cspellGeneratedSettings;
`;
  fs.writeFileSync(settingsOutFile, source, "utf8");
}

function writeGeneratedVfs(vfsByPath) {
  const entries = Array.from(vfsByPath.entries()).sort((a, b) => a[0].localeCompare(b[0]));
  const source = `// This file is auto-generated by build-cspell-dicts.js.
// Do not edit by hand.

export const cspellVfsEntries = ${JSON.stringify(entries)};
export const cspellVfsMap = new Map(cspellVfsEntries);

export default cspellVfsMap;
`;
  fs.writeFileSync(vfsOutFile, source, "utf8");
}

async function run() {
  fs.mkdirSync(outDir, { recursive: true });

  const defaultSettings = await loadDefaultBundledSettings();

  const settings = {
    ...defaultSettings,
    import: [],
    noConfigSearch: true,
    loadDefaultConfiguration: false,
    dictionaries: [...(defaultSettings.dictionaries || [])],
    dictionaryDefinitions: [...(defaultSettings.dictionaryDefinitions || [])],
    languageSettings: [...(defaultSettings.languageSettings || [])],
    words: [...(defaultSettings.words || [])],
    flagWords: [...(defaultSettings.flagWords || [])],
    suggestWords: [...(defaultSettings.suggestWords || [])],
    ignoreWords: [...(defaultSettings.ignoreWords || [])],
  };

  const dictDefByName = new Map(
    settings.dictionaryDefinitions
      .filter((d) => d && d.name)
      .map((d) => [d.name, d])
  );
  const vfsByPath = new Map();

  const importRefs = new Set(defaultSettings.import || []);
  for (const extFile of listAllDictionaryExtensionFiles()) {
    const pkgName = packageNameFromExtFile(extFile);
    importRefs.add(`${pkgName}/cspell-ext.json`);
  }

  for (const importRef of importRefs) {
    const importPath = resolveImportPath(importRef);
    if (!fs.existsSync(importPath)) continue;
    const extSettings = parseJsonc(fs.readFileSync(importPath, "utf8"));
    mergeExtSettings(settings, extSettings, importPath, dictDefByName, vfsByPath);
  }

  settings.dictionaryDefinitions = Array.from(dictDefByName.values()).sort((a, b) => a.name.localeCompare(b.name));
  settings.dictionaries = Array.from(new Set(settings.dictionaries)).sort((a, b) => a.localeCompare(b));
  settings.languageSettings = dedupeArray(settings.languageSettings);
  settings.words = Array.from(new Set(settings.words));
  settings.flagWords = Array.from(new Set(settings.flagWords));
  settings.suggestWords = Array.from(new Set(settings.suggestWords));
  settings.ignoreWords = Array.from(new Set(settings.ignoreWords));

  writeGeneratedSettings(settings);
  writeGeneratedVfs(vfsByPath);

  console.log(
    `Generated ${path.relative(pkgRoot, settingsOutFile)} and ${path.relative(pkgRoot, vfsOutFile)} ` +
    `(${settings.dictionaryDefinitions.length} dictionary definitions, ${vfsByPath.size} dictionary files).`
  );
}

run().catch((error) => {
  console.error(error);
  process.exit(1);
});
