var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../../node_modules/path-browserify/index.js
var require_path_browserify = __commonJS({
  "../../node_modules/path-browserify/index.js"(exports, module) {
    "use strict";
    function assertPath(path) {
      if (typeof path !== "string") {
        throw new TypeError("Path must be a string. Received " + JSON.stringify(path));
      }
    }
    function normalizeStringPosix(path, allowAboveRoot) {
      var res = "";
      var lastSegmentLength = 0;
      var lastSlash = -1;
      var dots = 0;
      var code;
      for (var i = 0; i <= path.length; ++i) {
        if (i < path.length)
          code = path.charCodeAt(i);
        else if (code === 47)
          break;
        else
          code = 47;
        if (code === 47) {
          if (lastSlash === i - 1 || dots === 1) {
          } else if (lastSlash !== i - 1 && dots === 2) {
            if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
              if (res.length > 2) {
                var lastSlashIndex = res.lastIndexOf("/");
                if (lastSlashIndex !== res.length - 1) {
                  if (lastSlashIndex === -1) {
                    res = "";
                    lastSegmentLength = 0;
                  } else {
                    res = res.slice(0, lastSlashIndex);
                    lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                  }
                  lastSlash = i;
                  dots = 0;
                  continue;
                }
              } else if (res.length === 2 || res.length === 1) {
                res = "";
                lastSegmentLength = 0;
                lastSlash = i;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              if (res.length > 0)
                res += "/..";
              else
                res = "..";
              lastSegmentLength = 2;
            }
          } else {
            if (res.length > 0)
              res += "/" + path.slice(lastSlash + 1, i);
            else
              res = path.slice(lastSlash + 1, i);
            lastSegmentLength = i - lastSlash - 1;
          }
          lastSlash = i;
          dots = 0;
        } else if (code === 46 && dots !== -1) {
          ++dots;
        } else {
          dots = -1;
        }
      }
      return res;
    }
    function _format(sep, pathObject) {
      var dir = pathObject.dir || pathObject.root;
      var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
      if (!dir) {
        return base;
      }
      if (dir === pathObject.root) {
        return dir + base;
      }
      return dir + sep + base;
    }
    var posix = {
      // path.resolve([from ...], to)
      resolve: function resolve() {
        var resolvedPath = "";
        var resolvedAbsolute = false;
        var cwd;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path;
          if (i >= 0)
            path = arguments[i];
          else {
            if (cwd === void 0)
              cwd = process.cwd();
            path = cwd;
          }
          assertPath(path);
          if (path.length === 0) {
            continue;
          }
          resolvedPath = path + "/" + resolvedPath;
          resolvedAbsolute = path.charCodeAt(0) === 47;
        }
        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
        if (resolvedAbsolute) {
          if (resolvedPath.length > 0)
            return "/" + resolvedPath;
          else
            return "/";
        } else if (resolvedPath.length > 0) {
          return resolvedPath;
        } else {
          return ".";
        }
      },
      normalize: function normalize(path) {
        assertPath(path);
        if (path.length === 0)
          return ".";
        var isAbsolute = path.charCodeAt(0) === 47;
        var trailingSeparator = path.charCodeAt(path.length - 1) === 47;
        path = normalizeStringPosix(path, !isAbsolute);
        if (path.length === 0 && !isAbsolute)
          path = ".";
        if (path.length > 0 && trailingSeparator)
          path += "/";
        if (isAbsolute)
          return "/" + path;
        return path;
      },
      isAbsolute: function isAbsolute(path) {
        assertPath(path);
        return path.length > 0 && path.charCodeAt(0) === 47;
      },
      join: function join() {
        if (arguments.length === 0)
          return ".";
        var joined;
        for (var i = 0; i < arguments.length; ++i) {
          var arg = arguments[i];
          assertPath(arg);
          if (arg.length > 0) {
            if (joined === void 0)
              joined = arg;
            else
              joined += "/" + arg;
          }
        }
        if (joined === void 0)
          return ".";
        return posix.normalize(joined);
      },
      relative: function relative(from, to) {
        assertPath(from);
        assertPath(to);
        if (from === to)
          return "";
        from = posix.resolve(from);
        to = posix.resolve(to);
        if (from === to)
          return "";
        var fromStart = 1;
        for (; fromStart < from.length; ++fromStart) {
          if (from.charCodeAt(fromStart) !== 47)
            break;
        }
        var fromEnd = from.length;
        var fromLen = fromEnd - fromStart;
        var toStart = 1;
        for (; toStart < to.length; ++toStart) {
          if (to.charCodeAt(toStart) !== 47)
            break;
        }
        var toEnd = to.length;
        var toLen = toEnd - toStart;
        var length = fromLen < toLen ? fromLen : toLen;
        var lastCommonSep = -1;
        var i = 0;
        for (; i <= length; ++i) {
          if (i === length) {
            if (toLen > length) {
              if (to.charCodeAt(toStart + i) === 47) {
                return to.slice(toStart + i + 1);
              } else if (i === 0) {
                return to.slice(toStart + i);
              }
            } else if (fromLen > length) {
              if (from.charCodeAt(fromStart + i) === 47) {
                lastCommonSep = i;
              } else if (i === 0) {
                lastCommonSep = 0;
              }
            }
            break;
          }
          var fromCode = from.charCodeAt(fromStart + i);
          var toCode = to.charCodeAt(toStart + i);
          if (fromCode !== toCode)
            break;
          else if (fromCode === 47)
            lastCommonSep = i;
        }
        var out = "";
        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
          if (i === fromEnd || from.charCodeAt(i) === 47) {
            if (out.length === 0)
              out += "..";
            else
              out += "/..";
          }
        }
        if (out.length > 0)
          return out + to.slice(toStart + lastCommonSep);
        else {
          toStart += lastCommonSep;
          if (to.charCodeAt(toStart) === 47)
            ++toStart;
          return to.slice(toStart);
        }
      },
      _makeLong: function _makeLong(path) {
        return path;
      },
      dirname: function dirname(path) {
        assertPath(path);
        if (path.length === 0)
          return ".";
        var code = path.charCodeAt(0);
        var hasRoot = code === 47;
        var end = -1;
        var matchedSlash = true;
        for (var i = path.length - 1; i >= 1; --i) {
          code = path.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              end = i;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1)
          return hasRoot ? "/" : ".";
        if (hasRoot && end === 1)
          return "//";
        return path.slice(0, end);
      },
      basename: function basename(path, ext) {
        if (ext !== void 0 && typeof ext !== "string")
          throw new TypeError('"ext" argument must be a string');
        assertPath(path);
        var start = 0;
        var end = -1;
        var matchedSlash = true;
        var i;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
          if (ext.length === path.length && ext === path)
            return "";
          var extIdx = ext.length - 1;
          var firstNonSlashEnd = -1;
          for (i = path.length - 1; i >= 0; --i) {
            var code = path.charCodeAt(i);
            if (code === 47) {
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i + 1;
              }
              if (extIdx >= 0) {
                if (code === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end)
            end = firstNonSlashEnd;
          else if (end === -1)
            end = path.length;
          return path.slice(start, end);
        } else {
          for (i = path.length - 1; i >= 0; --i) {
            if (path.charCodeAt(i) === 47) {
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
          }
          if (end === -1)
            return "";
          return path.slice(start, end);
        }
      },
      extname: function extname(path) {
        assertPath(path);
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var preDotState = 0;
        for (var i = path.length - 1; i >= 0; --i) {
          var code = path.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path.slice(startDot, end);
      },
      format: function format(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
          throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
        }
        return _format("/", pathObject);
      },
      parse: function parse(path) {
        assertPath(path);
        var ret = { root: "", dir: "", base: "", ext: "", name: "" };
        if (path.length === 0)
          return ret;
        var code = path.charCodeAt(0);
        var isAbsolute = code === 47;
        var start;
        if (isAbsolute) {
          ret.root = "/";
          start = 1;
        } else {
          start = 0;
        }
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var i = path.length - 1;
        var preDotState = 0;
        for (; i >= start; --i) {
          code = path.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          if (end !== -1) {
            if (startPart === 0 && isAbsolute)
              ret.base = ret.name = path.slice(1, end);
            else
              ret.base = ret.name = path.slice(startPart, end);
          }
        } else {
          if (startPart === 0 && isAbsolute) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
          } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
          }
          ret.ext = path.slice(startDot, end);
        }
        if (startPart > 0)
          ret.dir = path.slice(0, startPart - 1);
        else if (isAbsolute)
          ret.dir = "/";
        return ret;
      },
      sep: "/",
      delimiter: ":",
      win32: null,
      posix: null
    };
    posix.posix = posix;
    module.exports = posix;
  }
});

// ../../node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "../../node_modules/has-symbols/shams.js"(exports, module) {
    "use strict";
    module.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// ../../node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "../../node_modules/has-tostringtag/shams.js"(exports, module) {
    "use strict";
    var hasSymbols = require_shams();
    module.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});

// ../../node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "../../node_modules/has-symbols/index.js"(exports, module) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// ../../node_modules/has-proto/index.js
var require_has_proto = __commonJS({
  "../../node_modules/has-proto/index.js"(exports, module) {
    "use strict";
    var test = {
      foo: {}
    };
    var $Object = Object;
    module.exports = function hasProto() {
      return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
    };
  }
});

// ../../node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "../../node_modules/function-bind/implementation.js"(exports, module) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = "[object Function]";
    module.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice.call(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            args.concat(slice.call(arguments))
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        } else {
          return target.apply(
            that,
            args.concat(slice.call(arguments))
          );
        }
      };
      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs.push("$" + i);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// ../../node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "../../node_modules/function-bind/index.js"(exports, module) {
    "use strict";
    var implementation = require_implementation();
    module.exports = Function.prototype.bind || implementation;
  }
});

// ../../node_modules/has/src/index.js
var require_src = __commonJS({
  "../../node_modules/has/src/index.js"(exports, module) {
    "use strict";
    var bind = require_function_bind();
    module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
  }
});

// ../../node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "../../node_modules/get-intrinsic/index.js"(exports, module) {
    "use strict";
    var undefined2;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError = TypeError;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var hasProto = require_has_proto()();
    var getProto = Object.getPrototypeOf || (hasProto ? function(x) {
      return x.__proto__;
    } : null);
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_src();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var $exec = bind.call(Function.call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// ../../node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "../../node_modules/call-bind/index.js"(exports, module) {
    "use strict";
    var bind = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var $max = GetIntrinsic("%Math.max%");
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = null;
      }
    }
    module.exports = function callBind(originalFunction) {
      var func = $reflectApply(bind, $call, arguments);
      if ($gOPD && $defineProperty) {
        var desc = $gOPD(func, "length");
        if (desc.configurable) {
          $defineProperty(
            func,
            "length",
            { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
          );
        }
      }
      return func;
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module.exports, "apply", { value: applyBind });
    } else {
      module.exports.apply = applyBind;
    }
  }
});

// ../../node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "../../node_modules/call-bind/callBound.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// ../../node_modules/is-arguments/index.js
var require_is_arguments = __commonJS({
  "../../node_modules/is-arguments/index.js"(exports, module) {
    "use strict";
    var hasToStringTag = require_shams2()();
    var callBound = require_callBound();
    var $toString = callBound("Object.prototype.toString");
    var isStandardArguments = function isArguments(value) {
      if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
        return false;
      }
      return $toString(value) === "[object Arguments]";
    };
    var isLegacyArguments = function isArguments(value) {
      if (isStandardArguments(value)) {
        return true;
      }
      return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
    };
    var supportsStandardArguments = function() {
      return isStandardArguments(arguments);
    }();
    isStandardArguments.isLegacyArguments = isLegacyArguments;
    module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
  }
});

// ../../node_modules/is-generator-function/index.js
var require_is_generator_function = __commonJS({
  "../../node_modules/is-generator-function/index.js"(exports, module) {
    "use strict";
    var toStr = Object.prototype.toString;
    var fnToStr = Function.prototype.toString;
    var isFnRegex = /^\s*(?:function)?\*/;
    var hasToStringTag = require_shams2()();
    var getProto = Object.getPrototypeOf;
    var getGeneratorFunc = function() {
      if (!hasToStringTag) {
        return false;
      }
      try {
        return Function("return function*() {}")();
      } catch (e) {
      }
    };
    var GeneratorFunction;
    module.exports = function isGeneratorFunction(fn) {
      if (typeof fn !== "function") {
        return false;
      }
      if (isFnRegex.test(fnToStr.call(fn))) {
        return true;
      }
      if (!hasToStringTag) {
        var str = toStr.call(fn);
        return str === "[object GeneratorFunction]";
      }
      if (!getProto) {
        return false;
      }
      if (typeof GeneratorFunction === "undefined") {
        var generatorFunc = getGeneratorFunc();
        GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
      }
      return getProto(fn) === GeneratorFunction;
    };
  }
});

// ../../node_modules/is-callable/index.js
var require_is_callable = __commonJS({
  "../../node_modules/is-callable/index.js"(exports, module) {
    "use strict";
    var fnToStr = Function.prototype.toString;
    var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
    var badArrayLike;
    var isCallableMarker;
    if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
      try {
        badArrayLike = Object.defineProperty({}, "length", {
          get: function() {
            throw isCallableMarker;
          }
        });
        isCallableMarker = {};
        reflectApply(function() {
          throw 42;
        }, null, badArrayLike);
      } catch (_) {
        if (_ !== isCallableMarker) {
          reflectApply = null;
        }
      }
    } else {
      reflectApply = null;
    }
    var constructorRegex = /^\s*class\b/;
    var isES6ClassFn = function isES6ClassFunction(value) {
      try {
        var fnStr = fnToStr.call(value);
        return constructorRegex.test(fnStr);
      } catch (e) {
        return false;
      }
    };
    var tryFunctionObject = function tryFunctionToStr(value) {
      try {
        if (isES6ClassFn(value)) {
          return false;
        }
        fnToStr.call(value);
        return true;
      } catch (e) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var objectClass = "[object Object]";
    var fnClass = "[object Function]";
    var genClass = "[object GeneratorFunction]";
    var ddaClass = "[object HTMLAllCollection]";
    var ddaClass2 = "[object HTML document.all class]";
    var ddaClass3 = "[object HTMLCollection]";
    var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
    var isIE68 = !(0 in [,]);
    var isDDA = function isDocumentDotAll() {
      return false;
    };
    if (typeof document === "object") {
      all = document.all;
      if (toStr.call(all) === toStr.call(document.all)) {
        isDDA = function isDocumentDotAll(value) {
          if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
            try {
              var str = toStr.call(value);
              return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
            } catch (e) {
            }
          }
          return false;
        };
      }
    }
    var all;
    module.exports = reflectApply ? function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      try {
        reflectApply(value, null, badArrayLike);
      } catch (e) {
        if (e !== isCallableMarker) {
          return false;
        }
      }
      return !isES6ClassFn(value) && tryFunctionObject(value);
    } : function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      if (hasToStringTag) {
        return tryFunctionObject(value);
      }
      if (isES6ClassFn(value)) {
        return false;
      }
      var strClass = toStr.call(value);
      if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
        return false;
      }
      return tryFunctionObject(value);
    };
  }
});

// ../../node_modules/for-each/index.js
var require_for_each = __commonJS({
  "../../node_modules/for-each/index.js"(exports, module) {
    "use strict";
    var isCallable = require_is_callable();
    var toStr = Object.prototype.toString;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var forEachArray = function forEachArray2(array, iterator, receiver) {
      for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
          if (receiver == null) {
            iterator(array[i], i, array);
          } else {
            iterator.call(receiver, array[i], i, array);
          }
        }
      }
    };
    var forEachString = function forEachString2(string, iterator, receiver) {
      for (var i = 0, len = string.length; i < len; i++) {
        if (receiver == null) {
          iterator(string.charAt(i), i, string);
        } else {
          iterator.call(receiver, string.charAt(i), i, string);
        }
      }
    };
    var forEachObject = function forEachObject2(object, iterator, receiver) {
      for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
          if (receiver == null) {
            iterator(object[k], k, object);
          } else {
            iterator.call(receiver, object[k], k, object);
          }
        }
      }
    };
    var forEach = function forEach2(list, iterator, thisArg) {
      if (!isCallable(iterator)) {
        throw new TypeError("iterator must be a function");
      }
      var receiver;
      if (arguments.length >= 3) {
        receiver = thisArg;
      }
      if (toStr.call(list) === "[object Array]") {
        forEachArray(list, iterator, receiver);
      } else if (typeof list === "string") {
        forEachString(list, iterator, receiver);
      } else {
        forEachObject(list, iterator, receiver);
      }
    };
    module.exports = forEach;
  }
});

// ../../node_modules/available-typed-arrays/index.js
var require_available_typed_arrays = __commonJS({
  "../../node_modules/available-typed-arrays/index.js"(exports, module) {
    "use strict";
    var possibleNames = [
      "BigInt64Array",
      "BigUint64Array",
      "Float32Array",
      "Float64Array",
      "Int16Array",
      "Int32Array",
      "Int8Array",
      "Uint16Array",
      "Uint32Array",
      "Uint8Array",
      "Uint8ClampedArray"
    ];
    var g = typeof globalThis === "undefined" ? global : globalThis;
    module.exports = function availableTypedArrays() {
      var out = [];
      for (var i = 0; i < possibleNames.length; i++) {
        if (typeof g[possibleNames[i]] === "function") {
          out[out.length] = possibleNames[i];
        }
      }
      return out;
    };
  }
});

// ../../node_modules/gopd/index.js
var require_gopd = __commonJS({
  "../../node_modules/gopd/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module.exports = $gOPD;
  }
});

// ../../node_modules/which-typed-array/index.js
var require_which_typed_array = __commonJS({
  "../../node_modules/which-typed-array/index.js"(exports, module) {
    "use strict";
    var forEach = require_for_each();
    var availableTypedArrays = require_available_typed_arrays();
    var callBind = require_call_bind();
    var callBound = require_callBound();
    var gOPD = require_gopd();
    var $toString = callBound("Object.prototype.toString");
    var hasToStringTag = require_shams2()();
    var g = typeof globalThis === "undefined" ? global : globalThis;
    var typedArrays = availableTypedArrays();
    var $slice = callBound("String.prototype.slice");
    var getPrototypeOf = Object.getPrototypeOf;
    var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
      for (var i = 0; i < array.length; i += 1) {
        if (array[i] === value) {
          return i;
        }
      }
      return -1;
    };
    var cache = { __proto__: null };
    if (hasToStringTag && gOPD && getPrototypeOf) {
      forEach(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        if (Symbol.toStringTag in arr) {
          var proto = getPrototypeOf(arr);
          var descriptor = gOPD(proto, Symbol.toStringTag);
          if (!descriptor) {
            var superProto = getPrototypeOf(proto);
            descriptor = gOPD(superProto, Symbol.toStringTag);
          }
          cache["$" + typedArray] = callBind(descriptor.get);
        }
      });
    } else {
      forEach(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        cache["$" + typedArray] = callBind(arr.slice);
      });
    }
    var tryTypedArrays = function tryAllTypedArrays(value) {
      var found = false;
      forEach(cache, function(getter, typedArray) {
        if (!found) {
          try {
            if ("$" + getter(value) === typedArray) {
              found = $slice(typedArray, 1);
            }
          } catch (e) {
          }
        }
      });
      return found;
    };
    var trySlices = function tryAllSlices(value) {
      var found = false;
      forEach(cache, function(getter, name) {
        if (!found) {
          try {
            getter(value);
            found = $slice(name, 1);
          } catch (e) {
          }
        }
      });
      return found;
    };
    module.exports = function whichTypedArray(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      if (!hasToStringTag) {
        var tag = $slice($toString(value), 8, -1);
        if ($indexOf(typedArrays, tag) > -1) {
          return tag;
        }
        if (tag !== "Object") {
          return false;
        }
        return trySlices(value);
      }
      if (!gOPD) {
        return null;
      }
      return tryTypedArrays(value);
    };
  }
});

// ../../node_modules/is-typed-array/index.js
var require_is_typed_array = __commonJS({
  "../../node_modules/is-typed-array/index.js"(exports, module) {
    "use strict";
    var whichTypedArray = require_which_typed_array();
    module.exports = function isTypedArray(value) {
      return !!whichTypedArray(value);
    };
  }
});

// ../../node_modules/util/support/types.js
var require_types = __commonJS({
  "../../node_modules/util/support/types.js"(exports) {
    "use strict";
    var isArgumentsObject = require_is_arguments();
    var isGeneratorFunction = require_is_generator_function();
    var whichTypedArray = require_which_typed_array();
    var isTypedArray = require_is_typed_array();
    function uncurryThis(f) {
      return f.call.bind(f);
    }
    var BigIntSupported = typeof BigInt !== "undefined";
    var SymbolSupported = typeof Symbol !== "undefined";
    var ObjectToString = uncurryThis(Object.prototype.toString);
    var numberValue = uncurryThis(Number.prototype.valueOf);
    var stringValue = uncurryThis(String.prototype.valueOf);
    var booleanValue = uncurryThis(Boolean.prototype.valueOf);
    if (BigIntSupported) {
      bigIntValue = uncurryThis(BigInt.prototype.valueOf);
    }
    var bigIntValue;
    if (SymbolSupported) {
      symbolValue = uncurryThis(Symbol.prototype.valueOf);
    }
    var symbolValue;
    function checkBoxedPrimitive(value, prototypeValueOf) {
      if (typeof value !== "object") {
        return false;
      }
      try {
        prototypeValueOf(value);
        return true;
      } catch (e) {
        return false;
      }
    }
    exports.isArgumentsObject = isArgumentsObject;
    exports.isGeneratorFunction = isGeneratorFunction;
    exports.isTypedArray = isTypedArray;
    function isPromise(input) {
      return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
    }
    exports.isPromise = isPromise;
    function isArrayBufferView(value) {
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        return ArrayBuffer.isView(value);
      }
      return isTypedArray(value) || isDataView(value);
    }
    exports.isArrayBufferView = isArrayBufferView;
    function isUint8Array(value) {
      return whichTypedArray(value) === "Uint8Array";
    }
    exports.isUint8Array = isUint8Array;
    function isUint8ClampedArray(value) {
      return whichTypedArray(value) === "Uint8ClampedArray";
    }
    exports.isUint8ClampedArray = isUint8ClampedArray;
    function isUint16Array(value) {
      return whichTypedArray(value) === "Uint16Array";
    }
    exports.isUint16Array = isUint16Array;
    function isUint32Array(value) {
      return whichTypedArray(value) === "Uint32Array";
    }
    exports.isUint32Array = isUint32Array;
    function isInt8Array(value) {
      return whichTypedArray(value) === "Int8Array";
    }
    exports.isInt8Array = isInt8Array;
    function isInt16Array(value) {
      return whichTypedArray(value) === "Int16Array";
    }
    exports.isInt16Array = isInt16Array;
    function isInt32Array(value) {
      return whichTypedArray(value) === "Int32Array";
    }
    exports.isInt32Array = isInt32Array;
    function isFloat32Array(value) {
      return whichTypedArray(value) === "Float32Array";
    }
    exports.isFloat32Array = isFloat32Array;
    function isFloat64Array(value) {
      return whichTypedArray(value) === "Float64Array";
    }
    exports.isFloat64Array = isFloat64Array;
    function isBigInt64Array(value) {
      return whichTypedArray(value) === "BigInt64Array";
    }
    exports.isBigInt64Array = isBigInt64Array;
    function isBigUint64Array(value) {
      return whichTypedArray(value) === "BigUint64Array";
    }
    exports.isBigUint64Array = isBigUint64Array;
    function isMapToString(value) {
      return ObjectToString(value) === "[object Map]";
    }
    isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
    function isMap(value) {
      if (typeof Map === "undefined") {
        return false;
      }
      return isMapToString.working ? isMapToString(value) : value instanceof Map;
    }
    exports.isMap = isMap;
    function isSetToString(value) {
      return ObjectToString(value) === "[object Set]";
    }
    isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
    function isSet(value) {
      if (typeof Set === "undefined") {
        return false;
      }
      return isSetToString.working ? isSetToString(value) : value instanceof Set;
    }
    exports.isSet = isSet;
    function isWeakMapToString(value) {
      return ObjectToString(value) === "[object WeakMap]";
    }
    isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
    function isWeakMap(value) {
      if (typeof WeakMap === "undefined") {
        return false;
      }
      return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
    }
    exports.isWeakMap = isWeakMap;
    function isWeakSetToString(value) {
      return ObjectToString(value) === "[object WeakSet]";
    }
    isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
    function isWeakSet(value) {
      return isWeakSetToString(value);
    }
    exports.isWeakSet = isWeakSet;
    function isArrayBufferToString(value) {
      return ObjectToString(value) === "[object ArrayBuffer]";
    }
    isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
    function isArrayBuffer(value) {
      if (typeof ArrayBuffer === "undefined") {
        return false;
      }
      return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
    }
    exports.isArrayBuffer = isArrayBuffer;
    function isDataViewToString(value) {
      return ObjectToString(value) === "[object DataView]";
    }
    isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
    function isDataView(value) {
      if (typeof DataView === "undefined") {
        return false;
      }
      return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
    }
    exports.isDataView = isDataView;
    var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
    function isSharedArrayBufferToString(value) {
      return ObjectToString(value) === "[object SharedArrayBuffer]";
    }
    function isSharedArrayBuffer(value) {
      if (typeof SharedArrayBufferCopy === "undefined") {
        return false;
      }
      if (typeof isSharedArrayBufferToString.working === "undefined") {
        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
      }
      return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
    }
    exports.isSharedArrayBuffer = isSharedArrayBuffer;
    function isAsyncFunction(value) {
      return ObjectToString(value) === "[object AsyncFunction]";
    }
    exports.isAsyncFunction = isAsyncFunction;
    function isMapIterator(value) {
      return ObjectToString(value) === "[object Map Iterator]";
    }
    exports.isMapIterator = isMapIterator;
    function isSetIterator(value) {
      return ObjectToString(value) === "[object Set Iterator]";
    }
    exports.isSetIterator = isSetIterator;
    function isGeneratorObject(value) {
      return ObjectToString(value) === "[object Generator]";
    }
    exports.isGeneratorObject = isGeneratorObject;
    function isWebAssemblyCompiledModule(value) {
      return ObjectToString(value) === "[object WebAssembly.Module]";
    }
    exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
    function isNumberObject(value) {
      return checkBoxedPrimitive(value, numberValue);
    }
    exports.isNumberObject = isNumberObject;
    function isStringObject(value) {
      return checkBoxedPrimitive(value, stringValue);
    }
    exports.isStringObject = isStringObject;
    function isBooleanObject(value) {
      return checkBoxedPrimitive(value, booleanValue);
    }
    exports.isBooleanObject = isBooleanObject;
    function isBigIntObject(value) {
      return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
    }
    exports.isBigIntObject = isBigIntObject;
    function isSymbolObject(value) {
      return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
    }
    exports.isSymbolObject = isSymbolObject;
    function isBoxedPrimitive(value) {
      return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
    }
    exports.isBoxedPrimitive = isBoxedPrimitive;
    function isAnyArrayBuffer(value) {
      return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
    }
    exports.isAnyArrayBuffer = isAnyArrayBuffer;
    ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
      Object.defineProperty(exports, method, {
        enumerable: false,
        value: function() {
          throw new Error(method + " is not supported in userland");
        }
      });
    });
  }
});

// ../../node_modules/util/support/isBufferBrowser.js
var require_isBufferBrowser = __commonJS({
  "../../node_modules/util/support/isBufferBrowser.js"(exports, module) {
    module.exports = function isBuffer(arg) {
      return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
    };
  }
});

// ../../node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "../../node_modules/inherits/inherits_browser.js"(exports, module) {
    if (typeof Object.create === "function") {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// ../../node_modules/util/util.js
var require_util = __commonJS({
  "../../node_modules/util/util.js"(exports) {
    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
      var keys = Object.keys(obj);
      var descriptors = {};
      for (var i = 0; i < keys.length; i++) {
        descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
      }
      return descriptors;
    };
    var formatRegExp = /%[sdj%]/g;
    exports.format = function(f) {
      if (!isString(f)) {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect(arguments[i]));
        }
        return objects.join(" ");
      }
      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function(x2) {
        if (x2 === "%%")
          return "%";
        if (i >= len)
          return x2;
        switch (x2) {
          case "%s":
            return String(args[i++]);
          case "%d":
            return Number(args[i++]);
          case "%j":
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return "[Circular]";
            }
          default:
            return x2;
        }
      });
      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull(x) || !isObject(x)) {
          str += " " + x;
        } else {
          str += " " + inspect(x);
        }
      }
      return str;
    };
    exports.deprecate = function(fn, msg) {
      if (typeof process !== "undefined" && process.noDeprecation === true) {
        return fn;
      }
      if (typeof process === "undefined") {
        return function() {
          return exports.deprecate(fn, msg).apply(this, arguments);
        };
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process.throwDeprecation) {
            throw new Error(msg);
          } else if (process.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    };
    var debugs = {};
    var debugEnvRegex = /^$/;
    if (process.env.NODE_DEBUG) {
      debugEnv = process.env.NODE_DEBUG;
      debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
      debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
    }
    var debugEnv;
    exports.debuglog = function(set) {
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (debugEnvRegex.test(set)) {
          var pid = process.pid;
          debugs[set] = function() {
            var msg = exports.format.apply(exports, arguments);
            console.error("%s %d: %s", set, pid, msg);
          };
        } else {
          debugs[set] = function() {
          };
        }
      }
      return debugs[set];
    };
    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3)
        ctx.depth = arguments[2];
      if (arguments.length >= 4)
        ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        ctx.showHidden = opts;
      } else if (opts) {
        exports._extend(ctx, opts);
      }
      if (isUndefined(ctx.showHidden))
        ctx.showHidden = false;
      if (isUndefined(ctx.depth))
        ctx.depth = 2;
      if (isUndefined(ctx.colors))
        ctx.colors = false;
      if (isUndefined(ctx.customInspect))
        ctx.customInspect = true;
      if (ctx.colors)
        ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports.inspect = inspect;
    inspect.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      // "name": intentionally not styling
      "regexp": "red"
    };
    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];
      if (style) {
        return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash = {};
      array.forEach(function(val, idx) {
        hash[val] = true;
      });
      return hash;
    }
    function formatValue(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);
      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }
      if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
        return formatError(value);
      }
      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ": " + value.name : "";
          return ctx.stylize("[Function" + name + "]", "special");
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), "date");
        }
        if (isError(value)) {
          return formatError(value);
        }
      }
      var base = "", array = false, braces = ["{", "}"];
      if (isArray(value)) {
        array = true;
        braces = ["[", "]"];
      }
      if (isFunction(value)) {
        var n = value.name ? ": " + value.name : "";
        base = " [Function" + n + "]";
      }
      if (isRegExp(value)) {
        base = " " + RegExp.prototype.toString.call(value);
      }
      if (isDate(value)) {
        base = " " + Date.prototype.toUTCString.call(value);
      }
      if (isError(value)) {
        base = " " + formatError(value);
      }
      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        } else {
          return ctx.stylize("[Object]", "special");
        }
      }
      ctx.seen.push(value);
      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }
    function formatPrimitive(ctx, value) {
      if (isUndefined(value))
        return ctx.stylize("undefined", "undefined");
      if (isString(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, "string");
      }
      if (isNumber(value))
        return ctx.stylize("" + value, "number");
      if (isBoolean(value))
        return ctx.stylize("" + value, "boolean");
      if (isNull(value))
        return ctx.stylize("null", "null");
    }
    function formatError(value) {
      return "[" + Error.prototype.toString.call(value) + "]";
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            String(i),
            true
          ));
        } else {
          output.push("");
        }
      }
      keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            key,
            true
          ));
        }
      });
      return output;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize("[Getter/Setter]", "special");
        } else {
          str = ctx.stylize("[Getter]", "special");
        }
      } else {
        if (desc.set) {
          str = ctx.stylize("[Setter]", "special");
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name = "[" + key + "]";
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf("\n") > -1) {
            if (array) {
              str = str.split("\n").map(function(line) {
                return "  " + line;
              }).join("\n").slice(2);
            } else {
              str = "\n" + str.split("\n").map(function(line) {
                return "   " + line;
              }).join("\n");
            }
          }
        } else {
          str = ctx.stylize("[Circular]", "special");
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify("" + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.slice(1, -1);
          name = ctx.stylize(name, "name");
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, "string");
        }
      }
      return name + ": " + str;
    }
    function reduceToSingleString(output, base, braces) {
      var numLinesEst = 0;
      var length = output.reduce(function(prev, cur) {
        numLinesEst++;
        if (cur.indexOf("\n") >= 0)
          numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      if (length > 60) {
        return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
      }
      return braces[0] + base + " " + output.join(", ") + " " + braces[1];
    }
    exports.types = require_types();
    function isArray(ar) {
      return Array.isArray(ar);
    }
    exports.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re) {
      return isObject(re) && objectToString(re) === "[object RegExp]";
    }
    exports.isRegExp = isRegExp;
    exports.types.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports.isObject = isObject;
    function isDate(d) {
      return isObject(d) && objectToString(d) === "[object Date]";
    }
    exports.isDate = isDate;
    exports.types.isDate = isDate;
    function isError(e) {
      return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
    }
    exports.isError = isError;
    exports.types.isNativeError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports.isPrimitive = isPrimitive;
    exports.isBuffer = require_isBufferBrowser();
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    function pad(n) {
      return n < 10 ? "0" + n.toString(10) : n.toString(10);
    }
    var months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function timestamp() {
      var d = /* @__PURE__ */ new Date();
      var time = [
        pad(d.getHours()),
        pad(d.getMinutes()),
        pad(d.getSeconds())
      ].join(":");
      return [d.getDate(), months[d.getMonth()], time].join(" ");
    }
    exports.log = function() {
      console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments));
    };
    exports.inherits = require_inherits_browser();
    exports._extend = function(origin, add) {
      if (!add || !isObject(add))
        return origin;
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    };
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
    exports.promisify = function promisify(original) {
      if (typeof original !== "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn = original[kCustomPromisifiedSymbol];
        if (typeof fn !== "function") {
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        }
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
        return fn;
      }
      function fn() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function(resolve, reject) {
          promiseResolve = resolve;
          promiseReject = reject;
        });
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        args.push(function(err, value) {
          if (err) {
            promiseReject(err);
          } else {
            promiseResolve(value);
          }
        });
        try {
          original.apply(this, args);
        } catch (err) {
          promiseReject(err);
        }
        return promise;
      }
      Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
      if (kCustomPromisifiedSymbol)
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
      return Object.defineProperties(
        fn,
        getOwnPropertyDescriptors(original)
      );
    };
    exports.promisify.custom = kCustomPromisifiedSymbol;
    function callbackifyOnRejected(reason, cb) {
      if (!reason) {
        var newReason = new Error("Promise was rejected with a falsy value");
        newReason.reason = reason;
        reason = newReason;
      }
      return cb(reason);
    }
    function callbackify(original) {
      if (typeof original !== "function") {
        throw new TypeError('The "original" argument must be of type Function');
      }
      function callbackified() {
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        var maybeCb = args.pop();
        if (typeof maybeCb !== "function") {
          throw new TypeError("The last argument must be of type Function");
        }
        var self2 = this;
        var cb = function() {
          return maybeCb.apply(self2, arguments);
        };
        original.apply(this, args).then(
          function(ret) {
            process.nextTick(cb.bind(null, null, ret));
          },
          function(rej) {
            process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
          }
        );
      }
      Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
      Object.defineProperties(
        callbackified,
        getOwnPropertyDescriptors(original)
      );
      return callbackified;
    }
    exports.callbackify = callbackify;
  }
});

// ../../node_modules/assert/build/internal/errors.js
var require_errors = __commonJS({
  "../../node_modules/assert/build/internal/errors.js"(exports, module) {
    "use strict";
    function _typeof(obj) {
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var codes = {};
    var assert;
    var util;
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      var NodeError = /* @__PURE__ */ function(_Base) {
        _inherits(NodeError2, _Base);
        function NodeError2(arg1, arg2, arg3) {
          var _this;
          _classCallCheck(this, NodeError2);
          _this = _possibleConstructorReturn(this, _getPrototypeOf(NodeError2).call(this, getMessage(arg1, arg2, arg3)));
          _this.code = code;
          return _this;
        }
        return NodeError2;
      }(Base);
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i) {
          return String(i);
        });
        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      if (assert === void 0)
        assert = require_assert();
      assert(typeof name === "string", "'name' must be a string");
      var determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      var msg;
      if (endsWith(name, " argument")) {
        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      } else {
        var type = includes(name, ".") ? "property" : "argument";
        msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      }
      msg += ". Received type ".concat(_typeof(actual));
      return msg;
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_VALUE", function(name, value) {
      var reason = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "is invalid";
      if (util === void 0)
        util = require_util();
      var inspected = util.inspect(value);
      if (inspected.length > 128) {
        inspected = "".concat(inspected.slice(0, 128), "...");
      }
      return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
    }, TypeError, RangeError);
    createErrorType("ERR_INVALID_RETURN_VALUE", function(input, name, value) {
      var type;
      if (value && value.constructor && value.constructor.name) {
        type = "instance of ".concat(value.constructor.name);
      } else {
        type = "type ".concat(_typeof(value));
      }
      return "Expected ".concat(input, ' to be returned from the "').concat(name, '"') + " function but got ".concat(type, ".");
    }, TypeError);
    createErrorType("ERR_MISSING_ARGS", function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (assert === void 0)
        assert = require_assert();
      assert(args.length > 0, "At least one arg needs to be specified");
      var msg = "The ";
      var len = args.length;
      args = args.map(function(a) {
        return '"'.concat(a, '"');
      });
      switch (len) {
        case 1:
          msg += "".concat(args[0], " argument");
          break;
        case 2:
          msg += "".concat(args[0], " and ").concat(args[1], " arguments");
          break;
        default:
          msg += args.slice(0, len - 1).join(", ");
          msg += ", and ".concat(args[len - 1], " arguments");
          break;
      }
      return "".concat(msg, " must be specified");
    }, TypeError);
    module.exports.codes = codes;
  }
});

// ../../node_modules/assert/build/internal/assert/assertion_error.js
var require_assertion_error = __commonJS({
  "../../node_modules/assert/build/internal/assert/assertion_error.js"(exports, module) {
    "use strict";
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
          ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
          }));
        }
        ownKeys.forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2))
          return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
        return _setPrototypeOf(Wrapper, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    function isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _construct(Parent, args, Class) {
      if (isNativeReflectConstruct()) {
        _construct = Reflect.construct;
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [null];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2)
            _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _typeof(obj) {
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    var _require = require_util();
    var inspect = _require.inspect;
    var _require2 = require_errors();
    var ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE;
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function repeat(str, count) {
      count = Math.floor(count);
      if (str.length == 0 || count == 0)
        return "";
      var maxCount = str.length * count;
      count = Math.floor(Math.log(count) / Math.log(2));
      while (count) {
        str += str;
        count--;
      }
      str += str.substring(0, maxCount - str.length);
      return str;
    }
    var blue = "";
    var green = "";
    var red = "";
    var white = "";
    var kReadableOperator = {
      deepStrictEqual: "Expected values to be strictly deep-equal:",
      strictEqual: "Expected values to be strictly equal:",
      strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
      deepEqual: "Expected values to be loosely deep-equal:",
      equal: "Expected values to be loosely equal:",
      notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
      notStrictEqual: 'Expected "actual" to be strictly unequal to:',
      notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
      notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
      notEqual: 'Expected "actual" to be loosely unequal to:',
      notIdentical: "Values identical but not reference-equal:"
    };
    var kMaxShortLength = 10;
    function copyError(source) {
      var keys = Object.keys(source);
      var target = Object.create(Object.getPrototypeOf(source));
      keys.forEach(function(key) {
        target[key] = source[key];
      });
      Object.defineProperty(target, "message", {
        value: source.message
      });
      return target;
    }
    function inspectValue(val) {
      return inspect(val, {
        compact: false,
        customInspect: false,
        depth: 1e3,
        maxArrayLength: Infinity,
        // Assert compares only enumerable properties (with a few exceptions).
        showHidden: false,
        // Having a long line as error is better than wrapping the line for
        // comparison for now.
        // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
        // have meta information about the inspected properties (i.e., know where
        // in what line the property starts and ends).
        breakLength: Infinity,
        // Assert does not detect proxies currently.
        showProxy: false,
        sorted: true,
        // Inspect getters as we also check them when comparing entries.
        getters: true
      });
    }
    function createErrDiff(actual, expected, operator) {
      var other = "";
      var res = "";
      var lastPos = 0;
      var end = "";
      var skipped = false;
      var actualInspected = inspectValue(actual);
      var actualLines = actualInspected.split("\n");
      var expectedLines = inspectValue(expected).split("\n");
      var i = 0;
      var indicator = "";
      if (operator === "strictEqual" && _typeof(actual) === "object" && _typeof(expected) === "object" && actual !== null && expected !== null) {
        operator = "strictEqualObject";
      }
      if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
        var inputLength = actualLines[0].length + expectedLines[0].length;
        if (inputLength <= kMaxShortLength) {
          if ((_typeof(actual) !== "object" || actual === null) && (_typeof(expected) !== "object" || expected === null) && (actual !== 0 || expected !== 0)) {
            return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
          }
        } else if (operator !== "strictEqualObject") {
          var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;
          if (inputLength < maxLength) {
            while (actualLines[0][i] === expectedLines[0][i]) {
              i++;
            }
            if (i > 2) {
              indicator = "\n  ".concat(repeat(" ", i), "^");
              i = 0;
            }
          }
        }
      }
      var a = actualLines[actualLines.length - 1];
      var b = expectedLines[expectedLines.length - 1];
      while (a === b) {
        if (i++ < 2) {
          end = "\n  ".concat(a).concat(end);
        } else {
          other = a;
        }
        actualLines.pop();
        expectedLines.pop();
        if (actualLines.length === 0 || expectedLines.length === 0)
          break;
        a = actualLines[actualLines.length - 1];
        b = expectedLines[expectedLines.length - 1];
      }
      var maxLines = Math.max(actualLines.length, expectedLines.length);
      if (maxLines === 0) {
        var _actualLines = actualInspected.split("\n");
        if (_actualLines.length > 30) {
          _actualLines[26] = "".concat(blue, "...").concat(white);
          while (_actualLines.length > 27) {
            _actualLines.pop();
          }
        }
        return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join("\n"), "\n");
      }
      if (i > 3) {
        end = "\n".concat(blue, "...").concat(white).concat(end);
        skipped = true;
      }
      if (other !== "") {
        end = "\n  ".concat(other).concat(end);
        other = "";
      }
      var printedLines = 0;
      var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
      var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");
      for (i = 0; i < maxLines; i++) {
        var cur = i - lastPos;
        if (actualLines.length < i + 1) {
          if (cur > 1 && i > 2) {
            if (cur > 4) {
              res += "\n".concat(blue, "...").concat(white);
              skipped = true;
            } else if (cur > 3) {
              res += "\n  ".concat(expectedLines[i - 2]);
              printedLines++;
            }
            res += "\n  ".concat(expectedLines[i - 1]);
            printedLines++;
          }
          lastPos = i;
          other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
          printedLines++;
        } else if (expectedLines.length < i + 1) {
          if (cur > 1 && i > 2) {
            if (cur > 4) {
              res += "\n".concat(blue, "...").concat(white);
              skipped = true;
            } else if (cur > 3) {
              res += "\n  ".concat(actualLines[i - 2]);
              printedLines++;
            }
            res += "\n  ".concat(actualLines[i - 1]);
            printedLines++;
          }
          lastPos = i;
          res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
          printedLines++;
        } else {
          var expectedLine = expectedLines[i];
          var actualLine = actualLines[i];
          var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ",") || actualLine.slice(0, -1) !== expectedLine);
          if (divergingLines && endsWith(expectedLine, ",") && expectedLine.slice(0, -1) === actualLine) {
            divergingLines = false;
            actualLine += ",";
          }
          if (divergingLines) {
            if (cur > 1 && i > 2) {
              if (cur > 4) {
                res += "\n".concat(blue, "...").concat(white);
                skipped = true;
              } else if (cur > 3) {
                res += "\n  ".concat(actualLines[i - 2]);
                printedLines++;
              }
              res += "\n  ".concat(actualLines[i - 1]);
              printedLines++;
            }
            lastPos = i;
            res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
            other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
            printedLines += 2;
          } else {
            res += other;
            other = "";
            if (cur === 1 || i === 0) {
              res += "\n  ".concat(actualLine);
              printedLines++;
            }
          }
        }
        if (printedLines > 20 && i < maxLines - 2) {
          return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
        }
      }
      return "".concat(msg).concat(skipped ? skippedMsg : "", "\n").concat(res).concat(other).concat(end).concat(indicator);
    }
    var AssertionError = /* @__PURE__ */ function(_Error) {
      _inherits(AssertionError2, _Error);
      function AssertionError2(options) {
        var _this;
        _classCallCheck(this, AssertionError2);
        if (_typeof(options) !== "object" || options === null) {
          throw new ERR_INVALID_ARG_TYPE("options", "Object", options);
        }
        var message = options.message, operator = options.operator, stackStartFn = options.stackStartFn;
        var actual = options.actual, expected = options.expected;
        var limit = Error.stackTraceLimit;
        Error.stackTraceLimit = 0;
        if (message != null) {
          _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError2).call(this, String(message)));
        } else {
          if (process.stderr && process.stderr.isTTY) {
            if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {
              blue = "\x1B[34m";
              green = "\x1B[32m";
              white = "\x1B[39m";
              red = "\x1B[31m";
            } else {
              blue = "";
              green = "";
              white = "";
              red = "";
            }
          }
          if (_typeof(actual) === "object" && actual !== null && _typeof(expected) === "object" && expected !== null && "stack" in actual && actual instanceof Error && "stack" in expected && expected instanceof Error) {
            actual = copyError(actual);
            expected = copyError(expected);
          }
          if (operator === "deepStrictEqual" || operator === "strictEqual") {
            _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError2).call(this, createErrDiff(actual, expected, operator)));
          } else if (operator === "notDeepStrictEqual" || operator === "notStrictEqual") {
            var base = kReadableOperator[operator];
            var res = inspectValue(actual).split("\n");
            if (operator === "notStrictEqual" && _typeof(actual) === "object" && actual !== null) {
              base = kReadableOperator.notStrictEqualObject;
            }
            if (res.length > 30) {
              res[26] = "".concat(blue, "...").concat(white);
              while (res.length > 27) {
                res.pop();
              }
            }
            if (res.length === 1) {
              _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError2).call(this, "".concat(base, " ").concat(res[0])));
            } else {
              _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError2).call(this, "".concat(base, "\n\n").concat(res.join("\n"), "\n")));
            }
          } else {
            var _res = inspectValue(actual);
            var other = "";
            var knownOperators = kReadableOperator[operator];
            if (operator === "notDeepEqual" || operator === "notEqual") {
              _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);
              if (_res.length > 1024) {
                _res = "".concat(_res.slice(0, 1021), "...");
              }
            } else {
              other = "".concat(inspectValue(expected));
              if (_res.length > 512) {
                _res = "".concat(_res.slice(0, 509), "...");
              }
              if (other.length > 512) {
                other = "".concat(other.slice(0, 509), "...");
              }
              if (operator === "deepEqual" || operator === "equal") {
                _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
              } else {
                other = " ".concat(operator, " ").concat(other);
              }
            }
            _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError2).call(this, "".concat(_res).concat(other)));
          }
        }
        Error.stackTraceLimit = limit;
        _this.generatedMessage = !message;
        Object.defineProperty(_assertThisInitialized(_this), "name", {
          value: "AssertionError [ERR_ASSERTION]",
          enumerable: false,
          writable: true,
          configurable: true
        });
        _this.code = "ERR_ASSERTION";
        _this.actual = actual;
        _this.expected = expected;
        _this.operator = operator;
        if (Error.captureStackTrace) {
          Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
        }
        _this.stack;
        _this.name = "AssertionError";
        return _possibleConstructorReturn(_this);
      }
      _createClass(AssertionError2, [{
        key: "toString",
        value: function toString() {
          return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
        }
      }, {
        key: inspect.custom,
        value: function value(recurseTimes, ctx) {
          return inspect(this, _objectSpread({}, ctx, {
            customInspect: false,
            depth: 0
          }));
        }
      }]);
      return AssertionError2;
    }(_wrapNativeSuper(Error));
    module.exports = AssertionError;
  }
});

// ../../node_modules/es6-object-assign/index.js
var require_es6_object_assign = __commonJS({
  "../../node_modules/es6-object-assign/index.js"(exports, module) {
    "use strict";
    function assign(target, firstSource) {
      if (target === void 0 || target === null) {
        throw new TypeError("Cannot convert first argument to object");
      }
      var to = Object(target);
      for (var i = 1; i < arguments.length; i++) {
        var nextSource = arguments[i];
        if (nextSource === void 0 || nextSource === null) {
          continue;
        }
        var keysArray = Object.keys(Object(nextSource));
        for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
          var nextKey = keysArray[nextIndex];
          var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
          if (desc !== void 0 && desc.enumerable) {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
      return to;
    }
    function polyfill() {
      if (!Object.assign) {
        Object.defineProperty(Object, "assign", {
          enumerable: false,
          configurable: true,
          writable: true,
          value: assign
        });
      }
    }
    module.exports = {
      assign,
      polyfill
    };
  }
});

// ../../node_modules/object-keys/isArguments.js
var require_isArguments = __commonJS({
  "../../node_modules/object-keys/isArguments.js"(exports, module) {
    "use strict";
    var toStr = Object.prototype.toString;
    module.exports = function isArguments(value) {
      var str = toStr.call(value);
      var isArgs = str === "[object Arguments]";
      if (!isArgs) {
        isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
      }
      return isArgs;
    };
  }
});

// ../../node_modules/object-keys/implementation.js
var require_implementation2 = __commonJS({
  "../../node_modules/object-keys/implementation.js"(exports, module) {
    "use strict";
    var keysShim;
    if (!Object.keys) {
      has = Object.prototype.hasOwnProperty;
      toStr = Object.prototype.toString;
      isArgs = require_isArguments();
      isEnumerable = Object.prototype.propertyIsEnumerable;
      hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
      hasProtoEnumBug = isEnumerable.call(function() {
      }, "prototype");
      dontEnums = [
        "toString",
        "toLocaleString",
        "valueOf",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "constructor"
      ];
      equalsConstructorPrototype = function(o) {
        var ctor = o.constructor;
        return ctor && ctor.prototype === o;
      };
      excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true
      };
      hasAutomationEqualityBug = function() {
        if (typeof window === "undefined") {
          return false;
        }
        for (var k in window) {
          try {
            if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
              try {
                equalsConstructorPrototype(window[k]);
              } catch (e) {
                return true;
              }
            }
          } catch (e) {
            return true;
          }
        }
        return false;
      }();
      equalsConstructorPrototypeIfNotBuggy = function(o) {
        if (typeof window === "undefined" || !hasAutomationEqualityBug) {
          return equalsConstructorPrototype(o);
        }
        try {
          return equalsConstructorPrototype(o);
        } catch (e) {
          return false;
        }
      };
      keysShim = function keys(object) {
        var isObject = object !== null && typeof object === "object";
        var isFunction = toStr.call(object) === "[object Function]";
        var isArguments = isArgs(object);
        var isString = isObject && toStr.call(object) === "[object String]";
        var theKeys = [];
        if (!isObject && !isFunction && !isArguments) {
          throw new TypeError("Object.keys called on a non-object");
        }
        var skipProto = hasProtoEnumBug && isFunction;
        if (isString && object.length > 0 && !has.call(object, 0)) {
          for (var i = 0; i < object.length; ++i) {
            theKeys.push(String(i));
          }
        }
        if (isArguments && object.length > 0) {
          for (var j = 0; j < object.length; ++j) {
            theKeys.push(String(j));
          }
        } else {
          for (var name in object) {
            if (!(skipProto && name === "prototype") && has.call(object, name)) {
              theKeys.push(String(name));
            }
          }
        }
        if (hasDontEnumBug) {
          var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
          for (var k = 0; k < dontEnums.length; ++k) {
            if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) {
              theKeys.push(dontEnums[k]);
            }
          }
        }
        return theKeys;
      };
    }
    var has;
    var toStr;
    var isArgs;
    var isEnumerable;
    var hasDontEnumBug;
    var hasProtoEnumBug;
    var dontEnums;
    var equalsConstructorPrototype;
    var excludedKeys;
    var hasAutomationEqualityBug;
    var equalsConstructorPrototypeIfNotBuggy;
    module.exports = keysShim;
  }
});

// ../../node_modules/object-keys/index.js
var require_object_keys = __commonJS({
  "../../node_modules/object-keys/index.js"(exports, module) {
    "use strict";
    var slice = Array.prototype.slice;
    var isArgs = require_isArguments();
    var origKeys = Object.keys;
    var keysShim = origKeys ? function keys(o) {
      return origKeys(o);
    } : require_implementation2();
    var originalKeys = Object.keys;
    keysShim.shim = function shimObjectKeys() {
      if (Object.keys) {
        var keysWorksWithArguments = function() {
          var args = Object.keys(arguments);
          return args && args.length === arguments.length;
        }(1, 2);
        if (!keysWorksWithArguments) {
          Object.keys = function keys(object) {
            if (isArgs(object)) {
              return originalKeys(slice.call(object));
            }
            return originalKeys(object);
          };
        }
      } else {
        Object.keys = keysShim;
      }
      return Object.keys || keysShim;
    };
    module.exports = keysShim;
  }
});

// ../../node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "../../node_modules/has-property-descriptors/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
          return true;
        } catch (e) {
          return false;
        }
      }
      return false;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!hasPropertyDescriptors()) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e) {
        return true;
      }
    };
    module.exports = hasPropertyDescriptors;
  }
});

// ../../node_modules/define-properties/index.js
var require_define_properties = __commonJS({
  "../../node_modules/define-properties/index.js"(exports, module) {
    "use strict";
    var keys = require_object_keys();
    var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
    var toStr = Object.prototype.toString;
    var concat = Array.prototype.concat;
    var origDefineProperty = Object.defineProperty;
    var isFunction = function(fn) {
      return typeof fn === "function" && toStr.call(fn) === "[object Function]";
    };
    var hasPropertyDescriptors = require_has_property_descriptors()();
    var supportsDescriptors = origDefineProperty && hasPropertyDescriptors;
    var defineProperty = function(object, name, value, predicate) {
      if (name in object) {
        if (predicate === true) {
          if (object[name] === value) {
            return;
          }
        } else if (!isFunction(predicate) || !predicate()) {
          return;
        }
      }
      if (supportsDescriptors) {
        origDefineProperty(object, name, {
          configurable: true,
          enumerable: false,
          value,
          writable: true
        });
      } else {
        object[name] = value;
      }
    };
    var defineProperties = function(object, map) {
      var predicates = arguments.length > 2 ? arguments[2] : {};
      var props = keys(map);
      if (hasSymbols) {
        props = concat.call(props, Object.getOwnPropertySymbols(map));
      }
      for (var i = 0; i < props.length; i += 1) {
        defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
      }
    };
    defineProperties.supportsDescriptors = !!supportsDescriptors;
    module.exports = defineProperties;
  }
});

// ../../node_modules/object-is/implementation.js
var require_implementation3 = __commonJS({
  "../../node_modules/object-is/implementation.js"(exports, module) {
    "use strict";
    var numberIsNaN = function(value) {
      return value !== value;
    };
    module.exports = function is(a, b) {
      if (a === 0 && b === 0) {
        return 1 / a === 1 / b;
      }
      if (a === b) {
        return true;
      }
      if (numberIsNaN(a) && numberIsNaN(b)) {
        return true;
      }
      return false;
    };
  }
});

// ../../node_modules/object-is/polyfill.js
var require_polyfill = __commonJS({
  "../../node_modules/object-is/polyfill.js"(exports, module) {
    "use strict";
    var implementation = require_implementation3();
    module.exports = function getPolyfill() {
      return typeof Object.is === "function" ? Object.is : implementation;
    };
  }
});

// ../../node_modules/object-is/shim.js
var require_shim = __commonJS({
  "../../node_modules/object-is/shim.js"(exports, module) {
    "use strict";
    var getPolyfill = require_polyfill();
    var define2 = require_define_properties();
    module.exports = function shimObjectIs() {
      var polyfill = getPolyfill();
      define2(Object, { is: polyfill }, {
        is: function testObjectIs() {
          return Object.is !== polyfill;
        }
      });
      return polyfill;
    };
  }
});

// ../../node_modules/object-is/index.js
var require_object_is = __commonJS({
  "../../node_modules/object-is/index.js"(exports, module) {
    "use strict";
    var define2 = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation3();
    var getPolyfill = require_polyfill();
    var shim = require_shim();
    var polyfill = callBind(getPolyfill(), Object);
    define2(polyfill, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = polyfill;
  }
});

// ../../node_modules/is-nan/implementation.js
var require_implementation4 = __commonJS({
  "../../node_modules/is-nan/implementation.js"(exports, module) {
    "use strict";
    module.exports = function isNaN2(value) {
      return value !== value;
    };
  }
});

// ../../node_modules/is-nan/polyfill.js
var require_polyfill2 = __commonJS({
  "../../node_modules/is-nan/polyfill.js"(exports, module) {
    "use strict";
    var implementation = require_implementation4();
    module.exports = function getPolyfill() {
      if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a")) {
        return Number.isNaN;
      }
      return implementation;
    };
  }
});

// ../../node_modules/is-nan/shim.js
var require_shim2 = __commonJS({
  "../../node_modules/is-nan/shim.js"(exports, module) {
    "use strict";
    var define2 = require_define_properties();
    var getPolyfill = require_polyfill2();
    module.exports = function shimNumberIsNaN() {
      var polyfill = getPolyfill();
      define2(Number, { isNaN: polyfill }, {
        isNaN: function testIsNaN() {
          return Number.isNaN !== polyfill;
        }
      });
      return polyfill;
    };
  }
});

// ../../node_modules/is-nan/index.js
var require_is_nan = __commonJS({
  "../../node_modules/is-nan/index.js"(exports, module) {
    "use strict";
    var callBind = require_call_bind();
    var define2 = require_define_properties();
    var implementation = require_implementation4();
    var getPolyfill = require_polyfill2();
    var shim = require_shim2();
    var polyfill = callBind(getPolyfill(), Number);
    define2(polyfill, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = polyfill;
  }
});

// ../../node_modules/assert/build/internal/util/comparisons.js
var require_comparisons = __commonJS({
  "../../node_modules/assert/build/internal/util/comparisons.js"(exports, module) {
    "use strict";
    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
    function _iterableToArrayLimit(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = void 0;
      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    function _typeof(obj) {
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    var regexFlagsSupported = /a/g.flags !== void 0;
    var arrayFromSet = function arrayFromSet2(set) {
      var array = [];
      set.forEach(function(value) {
        return array.push(value);
      });
      return array;
    };
    var arrayFromMap = function arrayFromMap2(map) {
      var array = [];
      map.forEach(function(value, key) {
        return array.push([key, value]);
      });
      return array;
    };
    var objectIs = Object.is ? Object.is : require_object_is();
    var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
      return [];
    };
    var numberIsNaN = Number.isNaN ? Number.isNaN : require_is_nan();
    function uncurryThis(f) {
      return f.call.bind(f);
    }
    var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
    var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
    var objectToString = uncurryThis(Object.prototype.toString);
    var _require$types = require_util().types;
    var isAnyArrayBuffer = _require$types.isAnyArrayBuffer;
    var isArrayBufferView = _require$types.isArrayBufferView;
    var isDate = _require$types.isDate;
    var isMap = _require$types.isMap;
    var isRegExp = _require$types.isRegExp;
    var isSet = _require$types.isSet;
    var isNativeError = _require$types.isNativeError;
    var isBoxedPrimitive = _require$types.isBoxedPrimitive;
    var isNumberObject = _require$types.isNumberObject;
    var isStringObject = _require$types.isStringObject;
    var isBooleanObject = _require$types.isBooleanObject;
    var isBigIntObject = _require$types.isBigIntObject;
    var isSymbolObject = _require$types.isSymbolObject;
    var isFloat32Array = _require$types.isFloat32Array;
    var isFloat64Array = _require$types.isFloat64Array;
    function isNonIndex(key) {
      if (key.length === 0 || key.length > 10)
        return true;
      for (var i = 0; i < key.length; i++) {
        var code = key.charCodeAt(i);
        if (code < 48 || code > 57)
          return true;
      }
      return key.length === 10 && key >= Math.pow(2, 32);
    }
    function getOwnNonIndexProperties(value) {
      return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
    }
    function compare(a, b) {
      if (a === b) {
        return 0;
      }
      var x = a.length;
      var y = b.length;
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y) {
        return -1;
      }
      if (y < x) {
        return 1;
      }
      return 0;
    }
    var ONLY_ENUMERABLE = void 0;
    var kStrict = true;
    var kLoose = false;
    var kNoIterator = 0;
    var kIsArray = 1;
    var kIsSet = 2;
    var kIsMap = 3;
    function areSimilarRegExps(a, b) {
      return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
    }
    function areSimilarFloatArrays(a, b) {
      if (a.byteLength !== b.byteLength) {
        return false;
      }
      for (var offset = 0; offset < a.byteLength; offset++) {
        if (a[offset] !== b[offset]) {
          return false;
        }
      }
      return true;
    }
    function areSimilarTypedArrays(a, b) {
      if (a.byteLength !== b.byteLength) {
        return false;
      }
      return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
    }
    function areEqualArrayBuffers(buf1, buf2) {
      return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
    }
    function isEqualBoxedPrimitive(val1, val2) {
      if (isNumberObject(val1)) {
        return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
      }
      if (isStringObject(val1)) {
        return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
      }
      if (isBooleanObject(val1)) {
        return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
      }
      if (isBigIntObject(val1)) {
        return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
      }
      return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
    }
    function innerDeepEqual(val1, val2, strict, memos) {
      if (val1 === val2) {
        if (val1 !== 0)
          return true;
        return strict ? objectIs(val1, val2) : true;
      }
      if (strict) {
        if (_typeof(val1) !== "object") {
          return typeof val1 === "number" && numberIsNaN(val1) && numberIsNaN(val2);
        }
        if (_typeof(val2) !== "object" || val1 === null || val2 === null) {
          return false;
        }
        if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
          return false;
        }
      } else {
        if (val1 === null || _typeof(val1) !== "object") {
          if (val2 === null || _typeof(val2) !== "object") {
            return val1 == val2;
          }
          return false;
        }
        if (val2 === null || _typeof(val2) !== "object") {
          return false;
        }
      }
      var val1Tag = objectToString(val1);
      var val2Tag = objectToString(val2);
      if (val1Tag !== val2Tag) {
        return false;
      }
      if (Array.isArray(val1)) {
        if (val1.length !== val2.length) {
          return false;
        }
        var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
        var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
        if (keys1.length !== keys2.length) {
          return false;
        }
        return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
      }
      if (val1Tag === "[object Object]") {
        if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {
          return false;
        }
      }
      if (isDate(val1)) {
        if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
          return false;
        }
      } else if (isRegExp(val1)) {
        if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {
          return false;
        }
      } else if (isNativeError(val1) || val1 instanceof Error) {
        if (val1.message !== val2.message || val1.name !== val2.name) {
          return false;
        }
      } else if (isArrayBufferView(val1)) {
        if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
          if (!areSimilarFloatArrays(val1, val2)) {
            return false;
          }
        } else if (!areSimilarTypedArrays(val1, val2)) {
          return false;
        }
        var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
        var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
        if (_keys.length !== _keys2.length) {
          return false;
        }
        return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
      } else if (isSet(val1)) {
        if (!isSet(val2) || val1.size !== val2.size) {
          return false;
        }
        return keyCheck(val1, val2, strict, memos, kIsSet);
      } else if (isMap(val1)) {
        if (!isMap(val2) || val1.size !== val2.size) {
          return false;
        }
        return keyCheck(val1, val2, strict, memos, kIsMap);
      } else if (isAnyArrayBuffer(val1)) {
        if (!areEqualArrayBuffers(val1, val2)) {
          return false;
        }
      } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
        return false;
      }
      return keyCheck(val1, val2, strict, memos, kNoIterator);
    }
    function getEnumerables(val, keys) {
      return keys.filter(function(k) {
        return propertyIsEnumerable(val, k);
      });
    }
    function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
      if (arguments.length === 5) {
        aKeys = Object.keys(val1);
        var bKeys = Object.keys(val2);
        if (aKeys.length !== bKeys.length) {
          return false;
        }
      }
      var i = 0;
      for (; i < aKeys.length; i++) {
        if (!hasOwnProperty(val2, aKeys[i])) {
          return false;
        }
      }
      if (strict && arguments.length === 5) {
        var symbolKeysA = objectGetOwnPropertySymbols(val1);
        if (symbolKeysA.length !== 0) {
          var count = 0;
          for (i = 0; i < symbolKeysA.length; i++) {
            var key = symbolKeysA[i];
            if (propertyIsEnumerable(val1, key)) {
              if (!propertyIsEnumerable(val2, key)) {
                return false;
              }
              aKeys.push(key);
              count++;
            } else if (propertyIsEnumerable(val2, key)) {
              return false;
            }
          }
          var symbolKeysB = objectGetOwnPropertySymbols(val2);
          if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
            return false;
          }
        } else {
          var _symbolKeysB = objectGetOwnPropertySymbols(val2);
          if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
            return false;
          }
        }
      }
      if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
        return true;
      }
      if (memos === void 0) {
        memos = {
          val1: /* @__PURE__ */ new Map(),
          val2: /* @__PURE__ */ new Map(),
          position: 0
        };
      } else {
        var val2MemoA = memos.val1.get(val1);
        if (val2MemoA !== void 0) {
          var val2MemoB = memos.val2.get(val2);
          if (val2MemoB !== void 0) {
            return val2MemoA === val2MemoB;
          }
        }
        memos.position++;
      }
      memos.val1.set(val1, memos.position);
      memos.val2.set(val2, memos.position);
      var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
      memos.val1.delete(val1);
      memos.val2.delete(val2);
      return areEq;
    }
    function setHasEqualElement(set, val1, strict, memo) {
      var setValues = arrayFromSet(set);
      for (var i = 0; i < setValues.length; i++) {
        var val2 = setValues[i];
        if (innerDeepEqual(val1, val2, strict, memo)) {
          set.delete(val2);
          return true;
        }
      }
      return false;
    }
    function findLooseMatchingPrimitives(prim) {
      switch (_typeof(prim)) {
        case "undefined":
          return null;
        case "object":
          return void 0;
        case "symbol":
          return false;
        case "string":
          prim = +prim;
        case "number":
          if (numberIsNaN(prim)) {
            return false;
          }
      }
      return true;
    }
    function setMightHaveLoosePrim(a, b, prim) {
      var altValue = findLooseMatchingPrimitives(prim);
      if (altValue != null)
        return altValue;
      return b.has(altValue) && !a.has(altValue);
    }
    function mapMightHaveLoosePrim(a, b, prim, item, memo) {
      var altValue = findLooseMatchingPrimitives(prim);
      if (altValue != null) {
        return altValue;
      }
      var curB = b.get(altValue);
      if (curB === void 0 && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
        return false;
      }
      return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
    }
    function setEquiv(a, b, strict, memo) {
      var set = null;
      var aValues = arrayFromSet(a);
      for (var i = 0; i < aValues.length; i++) {
        var val = aValues[i];
        if (_typeof(val) === "object" && val !== null) {
          if (set === null) {
            set = /* @__PURE__ */ new Set();
          }
          set.add(val);
        } else if (!b.has(val)) {
          if (strict)
            return false;
          if (!setMightHaveLoosePrim(a, b, val)) {
            return false;
          }
          if (set === null) {
            set = /* @__PURE__ */ new Set();
          }
          set.add(val);
        }
      }
      if (set !== null) {
        var bValues = arrayFromSet(b);
        for (var _i = 0; _i < bValues.length; _i++) {
          var _val = bValues[_i];
          if (_typeof(_val) === "object" && _val !== null) {
            if (!setHasEqualElement(set, _val, strict, memo))
              return false;
          } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {
            return false;
          }
        }
        return set.size === 0;
      }
      return true;
    }
    function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
      var setValues = arrayFromSet(set);
      for (var i = 0; i < setValues.length; i++) {
        var key2 = setValues[i];
        if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {
          set.delete(key2);
          return true;
        }
      }
      return false;
    }
    function mapEquiv(a, b, strict, memo) {
      var set = null;
      var aEntries = arrayFromMap(a);
      for (var i = 0; i < aEntries.length; i++) {
        var _aEntries$i = _slicedToArray(aEntries[i], 2), key = _aEntries$i[0], item1 = _aEntries$i[1];
        if (_typeof(key) === "object" && key !== null) {
          if (set === null) {
            set = /* @__PURE__ */ new Set();
          }
          set.add(key);
        } else {
          var item2 = b.get(key);
          if (item2 === void 0 && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {
            if (strict)
              return false;
            if (!mapMightHaveLoosePrim(a, b, key, item1, memo))
              return false;
            if (set === null) {
              set = /* @__PURE__ */ new Set();
            }
            set.add(key);
          }
        }
      }
      if (set !== null) {
        var bEntries = arrayFromMap(b);
        for (var _i2 = 0; _i2 < bEntries.length; _i2++) {
          var _bEntries$_i = _slicedToArray(bEntries[_i2], 2), key = _bEntries$_i[0], item = _bEntries$_i[1];
          if (_typeof(key) === "object" && key !== null) {
            if (!mapHasEqualEntry(set, a, key, item, strict, memo))
              return false;
          } else if (!strict && (!a.has(key) || !innerDeepEqual(a.get(key), item, false, memo)) && !mapHasEqualEntry(set, a, key, item, false, memo)) {
            return false;
          }
        }
        return set.size === 0;
      }
      return true;
    }
    function objEquiv(a, b, strict, keys, memos, iterationType) {
      var i = 0;
      if (iterationType === kIsSet) {
        if (!setEquiv(a, b, strict, memos)) {
          return false;
        }
      } else if (iterationType === kIsMap) {
        if (!mapEquiv(a, b, strict, memos)) {
          return false;
        }
      } else if (iterationType === kIsArray) {
        for (; i < a.length; i++) {
          if (hasOwnProperty(a, i)) {
            if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {
              return false;
            }
          } else if (hasOwnProperty(b, i)) {
            return false;
          } else {
            var keysA = Object.keys(a);
            for (; i < keysA.length; i++) {
              var key = keysA[i];
              if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {
                return false;
              }
            }
            if (keysA.length !== Object.keys(b).length) {
              return false;
            }
            return true;
          }
        }
      }
      for (i = 0; i < keys.length; i++) {
        var _key = keys[i];
        if (!innerDeepEqual(a[_key], b[_key], strict, memos)) {
          return false;
        }
      }
      return true;
    }
    function isDeepEqual(val1, val2) {
      return innerDeepEqual(val1, val2, kLoose);
    }
    function isDeepStrictEqual(val1, val2) {
      return innerDeepEqual(val1, val2, kStrict);
    }
    module.exports = {
      isDeepEqual,
      isDeepStrictEqual
    };
  }
});

// ../../node_modules/assert/build/assert.js
var require_assert = __commonJS({
  "../../node_modules/assert/build/assert.js"(exports, module) {
    "use strict";
    function _typeof(obj) {
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var _require = require_errors();
    var _require$codes = _require.codes;
    var ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE;
    var ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var AssertionError = require_assertion_error();
    var _require2 = require_util();
    var inspect = _require2.inspect;
    var _require$types = require_util().types;
    var isPromise = _require$types.isPromise;
    var isRegExp = _require$types.isRegExp;
    var objectAssign = Object.assign ? Object.assign : require_es6_object_assign().assign;
    var objectIs = Object.is ? Object.is : require_object_is();
    var isDeepEqual;
    var isDeepStrictEqual;
    function lazyLoadComparison() {
      var comparison = require_comparisons();
      isDeepEqual = comparison.isDeepEqual;
      isDeepStrictEqual = comparison.isDeepStrictEqual;
    }
    var warned = false;
    var assert = module.exports = ok;
    var NO_EXCEPTION_SENTINEL = {};
    function innerFail(obj) {
      if (obj.message instanceof Error)
        throw obj.message;
      throw new AssertionError(obj);
    }
    function fail(actual, expected, message, operator, stackStartFn) {
      var argsLen = arguments.length;
      var internalMessage;
      if (argsLen === 0) {
        internalMessage = "Failed";
      } else if (argsLen === 1) {
        message = actual;
        actual = void 0;
      } else {
        if (warned === false) {
          warned = true;
          var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);
          warn("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
        }
        if (argsLen === 2)
          operator = "!=";
      }
      if (message instanceof Error)
        throw message;
      var errArgs = {
        actual,
        expected,
        operator: operator === void 0 ? "fail" : operator,
        stackStartFn: stackStartFn || fail
      };
      if (message !== void 0) {
        errArgs.message = message;
      }
      var err = new AssertionError(errArgs);
      if (internalMessage) {
        err.message = internalMessage;
        err.generatedMessage = true;
      }
      throw err;
    }
    assert.fail = fail;
    assert.AssertionError = AssertionError;
    function innerOk(fn, argLen, value, message) {
      if (!value) {
        var generatedMessage = false;
        if (argLen === 0) {
          generatedMessage = true;
          message = "No value argument passed to `assert.ok()`";
        } else if (message instanceof Error) {
          throw message;
        }
        var err = new AssertionError({
          actual: value,
          expected: true,
          message,
          operator: "==",
          stackStartFn: fn
        });
        err.generatedMessage = generatedMessage;
        throw err;
      }
    }
    function ok() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      innerOk.apply(void 0, [ok, args.length].concat(args));
    }
    assert.ok = ok;
    assert.equal = function equal(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (actual != expected) {
        innerFail({
          actual,
          expected,
          message,
          operator: "==",
          stackStartFn: equal
        });
      }
    };
    assert.notEqual = function notEqual(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (actual == expected) {
        innerFail({
          actual,
          expected,
          message,
          operator: "!=",
          stackStartFn: notEqual
        });
      }
    };
    assert.deepEqual = function deepEqual(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (isDeepEqual === void 0)
        lazyLoadComparison();
      if (!isDeepEqual(actual, expected)) {
        innerFail({
          actual,
          expected,
          message,
          operator: "deepEqual",
          stackStartFn: deepEqual
        });
      }
    };
    assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (isDeepEqual === void 0)
        lazyLoadComparison();
      if (isDeepEqual(actual, expected)) {
        innerFail({
          actual,
          expected,
          message,
          operator: "notDeepEqual",
          stackStartFn: notDeepEqual
        });
      }
    };
    assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (isDeepEqual === void 0)
        lazyLoadComparison();
      if (!isDeepStrictEqual(actual, expected)) {
        innerFail({
          actual,
          expected,
          message,
          operator: "deepStrictEqual",
          stackStartFn: deepStrictEqual
        });
      }
    };
    assert.notDeepStrictEqual = notDeepStrictEqual;
    function notDeepStrictEqual(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (isDeepEqual === void 0)
        lazyLoadComparison();
      if (isDeepStrictEqual(actual, expected)) {
        innerFail({
          actual,
          expected,
          message,
          operator: "notDeepStrictEqual",
          stackStartFn: notDeepStrictEqual
        });
      }
    }
    assert.strictEqual = function strictEqual(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (!objectIs(actual, expected)) {
        innerFail({
          actual,
          expected,
          message,
          operator: "strictEqual",
          stackStartFn: strictEqual
        });
      }
    };
    assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
      if (arguments.length < 2) {
        throw new ERR_MISSING_ARGS("actual", "expected");
      }
      if (objectIs(actual, expected)) {
        innerFail({
          actual,
          expected,
          message,
          operator: "notStrictEqual",
          stackStartFn: notStrictEqual
        });
      }
    };
    var Comparison = function Comparison2(obj, keys, actual) {
      var _this = this;
      _classCallCheck(this, Comparison2);
      keys.forEach(function(key) {
        if (key in obj) {
          if (actual !== void 0 && typeof actual[key] === "string" && isRegExp(obj[key]) && obj[key].test(actual[key])) {
            _this[key] = actual[key];
          } else {
            _this[key] = obj[key];
          }
        }
      });
    };
    function compareExceptionKey(actual, expected, key, message, keys, fn) {
      if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
        if (!message) {
          var a = new Comparison(actual, keys);
          var b = new Comparison(expected, keys, actual);
          var err = new AssertionError({
            actual: a,
            expected: b,
            operator: "deepStrictEqual",
            stackStartFn: fn
          });
          err.actual = actual;
          err.expected = expected;
          err.operator = fn.name;
          throw err;
        }
        innerFail({
          actual,
          expected,
          message,
          operator: fn.name,
          stackStartFn: fn
        });
      }
    }
    function expectedException(actual, expected, msg, fn) {
      if (typeof expected !== "function") {
        if (isRegExp(expected))
          return expected.test(actual);
        if (arguments.length === 2) {
          throw new ERR_INVALID_ARG_TYPE("expected", ["Function", "RegExp"], expected);
        }
        if (_typeof(actual) !== "object" || actual === null) {
          var err = new AssertionError({
            actual,
            expected,
            message: msg,
            operator: "deepStrictEqual",
            stackStartFn: fn
          });
          err.operator = fn.name;
          throw err;
        }
        var keys = Object.keys(expected);
        if (expected instanceof Error) {
          keys.push("name", "message");
        } else if (keys.length === 0) {
          throw new ERR_INVALID_ARG_VALUE("error", expected, "may not be an empty object");
        }
        if (isDeepEqual === void 0)
          lazyLoadComparison();
        keys.forEach(function(key) {
          if (typeof actual[key] === "string" && isRegExp(expected[key]) && expected[key].test(actual[key])) {
            return;
          }
          compareExceptionKey(actual, expected, key, msg, keys, fn);
        });
        return true;
      }
      if (expected.prototype !== void 0 && actual instanceof expected) {
        return true;
      }
      if (Error.isPrototypeOf(expected)) {
        return false;
      }
      return expected.call({}, actual) === true;
    }
    function getActual(fn) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", "Function", fn);
      }
      try {
        fn();
      } catch (e) {
        return e;
      }
      return NO_EXCEPTION_SENTINEL;
    }
    function checkIsPromise(obj) {
      return isPromise(obj) || obj !== null && _typeof(obj) === "object" && typeof obj.then === "function" && typeof obj.catch === "function";
    }
    function waitForActual(promiseFn) {
      return Promise.resolve().then(function() {
        var resultPromise;
        if (typeof promiseFn === "function") {
          resultPromise = promiseFn();
          if (!checkIsPromise(resultPromise)) {
            throw new ERR_INVALID_RETURN_VALUE("instance of Promise", "promiseFn", resultPromise);
          }
        } else if (checkIsPromise(promiseFn)) {
          resultPromise = promiseFn;
        } else {
          throw new ERR_INVALID_ARG_TYPE("promiseFn", ["Function", "Promise"], promiseFn);
        }
        return Promise.resolve().then(function() {
          return resultPromise;
        }).then(function() {
          return NO_EXCEPTION_SENTINEL;
        }).catch(function(e) {
          return e;
        });
      });
    }
    function expectsError(stackStartFn, actual, error, message) {
      if (typeof error === "string") {
        if (arguments.length === 4) {
          throw new ERR_INVALID_ARG_TYPE("error", ["Object", "Error", "Function", "RegExp"], error);
        }
        if (_typeof(actual) === "object" && actual !== null) {
          if (actual.message === error) {
            throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error message "'.concat(actual.message, '" is identical to the message.'));
          }
        } else if (actual === error) {
          throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error "'.concat(actual, '" is identical to the message.'));
        }
        message = error;
        error = void 0;
      } else if (error != null && _typeof(error) !== "object" && typeof error !== "function") {
        throw new ERR_INVALID_ARG_TYPE("error", ["Object", "Error", "Function", "RegExp"], error);
      }
      if (actual === NO_EXCEPTION_SENTINEL) {
        var details = "";
        if (error && error.name) {
          details += " (".concat(error.name, ")");
        }
        details += message ? ": ".concat(message) : ".";
        var fnType = stackStartFn.name === "rejects" ? "rejection" : "exception";
        innerFail({
          actual: void 0,
          expected: error,
          operator: stackStartFn.name,
          message: "Missing expected ".concat(fnType).concat(details),
          stackStartFn
        });
      }
      if (error && !expectedException(actual, error, message, stackStartFn)) {
        throw actual;
      }
    }
    function expectsNoError(stackStartFn, actual, error, message) {
      if (actual === NO_EXCEPTION_SENTINEL)
        return;
      if (typeof error === "string") {
        message = error;
        error = void 0;
      }
      if (!error || expectedException(actual, error)) {
        var details = message ? ": ".concat(message) : ".";
        var fnType = stackStartFn.name === "doesNotReject" ? "rejection" : "exception";
        innerFail({
          actual,
          expected: error,
          operator: stackStartFn.name,
          message: "Got unwanted ".concat(fnType).concat(details, "\n") + 'Actual message: "'.concat(actual && actual.message, '"'),
          stackStartFn
        });
      }
      throw actual;
    }
    assert.throws = function throws(promiseFn) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      expectsError.apply(void 0, [throws, getActual(promiseFn)].concat(args));
    };
    assert.rejects = function rejects(promiseFn) {
      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }
      return waitForActual(promiseFn).then(function(result) {
        return expectsError.apply(void 0, [rejects, result].concat(args));
      });
    };
    assert.doesNotThrow = function doesNotThrow(fn) {
      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        args[_key4 - 1] = arguments[_key4];
      }
      expectsNoError.apply(void 0, [doesNotThrow, getActual(fn)].concat(args));
    };
    assert.doesNotReject = function doesNotReject(fn) {
      for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
        args[_key5 - 1] = arguments[_key5];
      }
      return waitForActual(fn).then(function(result) {
        return expectsNoError.apply(void 0, [doesNotReject, result].concat(args));
      });
    };
    assert.ifError = function ifError(err) {
      if (err !== null && err !== void 0) {
        var message = "ifError got unwanted exception: ";
        if (_typeof(err) === "object" && typeof err.message === "string") {
          if (err.message.length === 0 && err.constructor) {
            message += err.constructor.name;
          } else {
            message += err.message;
          }
        } else {
          message += inspect(err);
        }
        var newErr = new AssertionError({
          actual: err,
          expected: null,
          operator: "ifError",
          message,
          stackStartFn: ifError
        });
        var origStack = err.stack;
        if (typeof origStack === "string") {
          var tmp2 = origStack.split("\n");
          tmp2.shift();
          var tmp1 = newErr.stack.split("\n");
          for (var i = 0; i < tmp2.length; i++) {
            var pos = tmp1.indexOf(tmp2[i]);
            if (pos !== -1) {
              tmp1 = tmp1.slice(0, pos);
              break;
            }
          }
          newErr.stack = "".concat(tmp1.join("\n"), "\n").concat(tmp2.join("\n"));
        }
        throw newErr;
      }
    };
    function strict() {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }
      innerOk.apply(void 0, [strict, args.length].concat(args));
    }
    assert.strict = objectAssign(strict, assert, {
      equal: assert.strictEqual,
      deepEqual: assert.deepStrictEqual,
      notEqual: assert.notStrictEqual,
      notDeepEqual: assert.notDeepStrictEqual
    });
    assert.strict.strict = assert.strict;
  }
});

// ../../node_modules/eslint/node_modules/estraverse/estraverse.js
var require_estraverse = __commonJS({
  "../../node_modules/eslint/node_modules/estraverse/estraverse.js"(exports) {
    (function clone(exports2) {
      "use strict";
      var Syntax, VisitorOption, VisitorKeys, BREAK, SKIP, REMOVE;
      function deepCopy(obj) {
        var ret = {}, key, val;
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            val = obj[key];
            if (typeof val === "object" && val !== null) {
              ret[key] = deepCopy(val);
            } else {
              ret[key] = val;
            }
          }
        }
        return ret;
      }
      function upperBound(array, func) {
        var diff, len, i, current;
        len = array.length;
        i = 0;
        while (len) {
          diff = len >>> 1;
          current = i + diff;
          if (func(array[current])) {
            len = diff;
          } else {
            i = current + 1;
            len -= diff + 1;
          }
        }
        return i;
      }
      Syntax = {
        AssignmentExpression: "AssignmentExpression",
        AssignmentPattern: "AssignmentPattern",
        ArrayExpression: "ArrayExpression",
        ArrayPattern: "ArrayPattern",
        ArrowFunctionExpression: "ArrowFunctionExpression",
        AwaitExpression: "AwaitExpression",
        // CAUTION: It's deferred to ES7.
        BlockStatement: "BlockStatement",
        BinaryExpression: "BinaryExpression",
        BreakStatement: "BreakStatement",
        CallExpression: "CallExpression",
        CatchClause: "CatchClause",
        ChainExpression: "ChainExpression",
        ClassBody: "ClassBody",
        ClassDeclaration: "ClassDeclaration",
        ClassExpression: "ClassExpression",
        ComprehensionBlock: "ComprehensionBlock",
        // CAUTION: It's deferred to ES7.
        ComprehensionExpression: "ComprehensionExpression",
        // CAUTION: It's deferred to ES7.
        ConditionalExpression: "ConditionalExpression",
        ContinueStatement: "ContinueStatement",
        DebuggerStatement: "DebuggerStatement",
        DirectiveStatement: "DirectiveStatement",
        DoWhileStatement: "DoWhileStatement",
        EmptyStatement: "EmptyStatement",
        ExportAllDeclaration: "ExportAllDeclaration",
        ExportDefaultDeclaration: "ExportDefaultDeclaration",
        ExportNamedDeclaration: "ExportNamedDeclaration",
        ExportSpecifier: "ExportSpecifier",
        ExpressionStatement: "ExpressionStatement",
        ForStatement: "ForStatement",
        ForInStatement: "ForInStatement",
        ForOfStatement: "ForOfStatement",
        FunctionDeclaration: "FunctionDeclaration",
        FunctionExpression: "FunctionExpression",
        GeneratorExpression: "GeneratorExpression",
        // CAUTION: It's deferred to ES7.
        Identifier: "Identifier",
        IfStatement: "IfStatement",
        ImportExpression: "ImportExpression",
        ImportDeclaration: "ImportDeclaration",
        ImportDefaultSpecifier: "ImportDefaultSpecifier",
        ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
        ImportSpecifier: "ImportSpecifier",
        Literal: "Literal",
        LabeledStatement: "LabeledStatement",
        LogicalExpression: "LogicalExpression",
        MemberExpression: "MemberExpression",
        MetaProperty: "MetaProperty",
        MethodDefinition: "MethodDefinition",
        ModuleSpecifier: "ModuleSpecifier",
        NewExpression: "NewExpression",
        ObjectExpression: "ObjectExpression",
        ObjectPattern: "ObjectPattern",
        PrivateIdentifier: "PrivateIdentifier",
        Program: "Program",
        Property: "Property",
        PropertyDefinition: "PropertyDefinition",
        RestElement: "RestElement",
        ReturnStatement: "ReturnStatement",
        SequenceExpression: "SequenceExpression",
        SpreadElement: "SpreadElement",
        Super: "Super",
        SwitchStatement: "SwitchStatement",
        SwitchCase: "SwitchCase",
        TaggedTemplateExpression: "TaggedTemplateExpression",
        TemplateElement: "TemplateElement",
        TemplateLiteral: "TemplateLiteral",
        ThisExpression: "ThisExpression",
        ThrowStatement: "ThrowStatement",
        TryStatement: "TryStatement",
        UnaryExpression: "UnaryExpression",
        UpdateExpression: "UpdateExpression",
        VariableDeclaration: "VariableDeclaration",
        VariableDeclarator: "VariableDeclarator",
        WhileStatement: "WhileStatement",
        WithStatement: "WithStatement",
        YieldExpression: "YieldExpression"
      };
      VisitorKeys = {
        AssignmentExpression: ["left", "right"],
        AssignmentPattern: ["left", "right"],
        ArrayExpression: ["elements"],
        ArrayPattern: ["elements"],
        ArrowFunctionExpression: ["params", "body"],
        AwaitExpression: ["argument"],
        // CAUTION: It's deferred to ES7.
        BlockStatement: ["body"],
        BinaryExpression: ["left", "right"],
        BreakStatement: ["label"],
        CallExpression: ["callee", "arguments"],
        CatchClause: ["param", "body"],
        ChainExpression: ["expression"],
        ClassBody: ["body"],
        ClassDeclaration: ["id", "superClass", "body"],
        ClassExpression: ["id", "superClass", "body"],
        ComprehensionBlock: ["left", "right"],
        // CAUTION: It's deferred to ES7.
        ComprehensionExpression: ["blocks", "filter", "body"],
        // CAUTION: It's deferred to ES7.
        ConditionalExpression: ["test", "consequent", "alternate"],
        ContinueStatement: ["label"],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: ["body", "test"],
        EmptyStatement: [],
        ExportAllDeclaration: ["source"],
        ExportDefaultDeclaration: ["declaration"],
        ExportNamedDeclaration: ["declaration", "specifiers", "source"],
        ExportSpecifier: ["exported", "local"],
        ExpressionStatement: ["expression"],
        ForStatement: ["init", "test", "update", "body"],
        ForInStatement: ["left", "right", "body"],
        ForOfStatement: ["left", "right", "body"],
        FunctionDeclaration: ["id", "params", "body"],
        FunctionExpression: ["id", "params", "body"],
        GeneratorExpression: ["blocks", "filter", "body"],
        // CAUTION: It's deferred to ES7.
        Identifier: [],
        IfStatement: ["test", "consequent", "alternate"],
        ImportExpression: ["source"],
        ImportDeclaration: ["specifiers", "source"],
        ImportDefaultSpecifier: ["local"],
        ImportNamespaceSpecifier: ["local"],
        ImportSpecifier: ["imported", "local"],
        Literal: [],
        LabeledStatement: ["label", "body"],
        LogicalExpression: ["left", "right"],
        MemberExpression: ["object", "property"],
        MetaProperty: ["meta", "property"],
        MethodDefinition: ["key", "value"],
        ModuleSpecifier: [],
        NewExpression: ["callee", "arguments"],
        ObjectExpression: ["properties"],
        ObjectPattern: ["properties"],
        PrivateIdentifier: [],
        Program: ["body"],
        Property: ["key", "value"],
        PropertyDefinition: ["key", "value"],
        RestElement: ["argument"],
        ReturnStatement: ["argument"],
        SequenceExpression: ["expressions"],
        SpreadElement: ["argument"],
        Super: [],
        SwitchStatement: ["discriminant", "cases"],
        SwitchCase: ["test", "consequent"],
        TaggedTemplateExpression: ["tag", "quasi"],
        TemplateElement: [],
        TemplateLiteral: ["quasis", "expressions"],
        ThisExpression: [],
        ThrowStatement: ["argument"],
        TryStatement: ["block", "handler", "finalizer"],
        UnaryExpression: ["argument"],
        UpdateExpression: ["argument"],
        VariableDeclaration: ["declarations"],
        VariableDeclarator: ["id", "init"],
        WhileStatement: ["test", "body"],
        WithStatement: ["object", "body"],
        YieldExpression: ["argument"]
      };
      BREAK = {};
      SKIP = {};
      REMOVE = {};
      VisitorOption = {
        Break: BREAK,
        Skip: SKIP,
        Remove: REMOVE
      };
      function Reference(parent, key) {
        this.parent = parent;
        this.key = key;
      }
      Reference.prototype.replace = function replace2(node) {
        this.parent[this.key] = node;
      };
      Reference.prototype.remove = function remove() {
        if (Array.isArray(this.parent)) {
          this.parent.splice(this.key, 1);
          return true;
        } else {
          this.replace(null);
          return false;
        }
      };
      function Element(node, path, wrap, ref) {
        this.node = node;
        this.path = path;
        this.wrap = wrap;
        this.ref = ref;
      }
      function Controller() {
      }
      Controller.prototype.path = function path() {
        var i, iz, j, jz, result, element;
        function addToPath(result2, path2) {
          if (Array.isArray(path2)) {
            for (j = 0, jz = path2.length; j < jz; ++j) {
              result2.push(path2[j]);
            }
          } else {
            result2.push(path2);
          }
        }
        if (!this.__current.path) {
          return null;
        }
        result = [];
        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
          element = this.__leavelist[i];
          addToPath(result, element.path);
        }
        addToPath(result, this.__current.path);
        return result;
      };
      Controller.prototype.type = function() {
        var node = this.current();
        return node.type || this.__current.wrap;
      };
      Controller.prototype.parents = function parents() {
        var i, iz, result;
        result = [];
        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
          result.push(this.__leavelist[i].node);
        }
        return result;
      };
      Controller.prototype.current = function current() {
        return this.__current.node;
      };
      Controller.prototype.__execute = function __execute(callback, element) {
        var previous, result;
        result = void 0;
        previous = this.__current;
        this.__current = element;
        this.__state = null;
        if (callback) {
          result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
        }
        this.__current = previous;
        return result;
      };
      Controller.prototype.notify = function notify(flag) {
        this.__state = flag;
      };
      Controller.prototype.skip = function() {
        this.notify(SKIP);
      };
      Controller.prototype["break"] = function() {
        this.notify(BREAK);
      };
      Controller.prototype.remove = function() {
        this.notify(REMOVE);
      };
      Controller.prototype.__initialize = function(root, visitor) {
        this.visitor = visitor;
        this.root = root;
        this.__worklist = [];
        this.__leavelist = [];
        this.__current = null;
        this.__state = null;
        this.__fallback = null;
        if (visitor.fallback === "iteration") {
          this.__fallback = Object.keys;
        } else if (typeof visitor.fallback === "function") {
          this.__fallback = visitor.fallback;
        }
        this.__keys = VisitorKeys;
        if (visitor.keys) {
          this.__keys = Object.assign(Object.create(this.__keys), visitor.keys);
        }
      };
      function isNode(node) {
        if (node == null) {
          return false;
        }
        return typeof node === "object" && typeof node.type === "string";
      }
      function isProperty(nodeType, key) {
        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && "properties" === key;
      }
      function candidateExistsInLeaveList(leavelist, candidate) {
        for (var i = leavelist.length - 1; i >= 0; --i) {
          if (leavelist[i].node === candidate) {
            return true;
          }
        }
        return false;
      }
      Controller.prototype.traverse = function traverse2(root, visitor) {
        var worklist, leavelist, element, node, nodeType, ret, key, current, current2, candidates, candidate, sentinel;
        this.__initialize(root, visitor);
        sentinel = {};
        worklist = this.__worklist;
        leavelist = this.__leavelist;
        worklist.push(new Element(root, null, null, null));
        leavelist.push(new Element(null, null, null, null));
        while (worklist.length) {
          element = worklist.pop();
          if (element === sentinel) {
            element = leavelist.pop();
            ret = this.__execute(visitor.leave, element);
            if (this.__state === BREAK || ret === BREAK) {
              return;
            }
            continue;
          }
          if (element.node) {
            ret = this.__execute(visitor.enter, element);
            if (this.__state === BREAK || ret === BREAK) {
              return;
            }
            worklist.push(sentinel);
            leavelist.push(element);
            if (this.__state === SKIP || ret === SKIP) {
              continue;
            }
            node = element.node;
            nodeType = node.type || element.wrap;
            candidates = this.__keys[nodeType];
            if (!candidates) {
              if (this.__fallback) {
                candidates = this.__fallback(node);
              } else {
                throw new Error("Unknown node type " + nodeType + ".");
              }
            }
            current = candidates.length;
            while ((current -= 1) >= 0) {
              key = candidates[current];
              candidate = node[key];
              if (!candidate) {
                continue;
              }
              if (Array.isArray(candidate)) {
                current2 = candidate.length;
                while ((current2 -= 1) >= 0) {
                  if (!candidate[current2]) {
                    continue;
                  }
                  if (candidateExistsInLeaveList(leavelist, candidate[current2])) {
                    continue;
                  }
                  if (isProperty(nodeType, candidates[current])) {
                    element = new Element(candidate[current2], [key, current2], "Property", null);
                  } else if (isNode(candidate[current2])) {
                    element = new Element(candidate[current2], [key, current2], null, null);
                  } else {
                    continue;
                  }
                  worklist.push(element);
                }
              } else if (isNode(candidate)) {
                if (candidateExistsInLeaveList(leavelist, candidate)) {
                  continue;
                }
                worklist.push(new Element(candidate, key, null, null));
              }
            }
          }
        }
      };
      Controller.prototype.replace = function replace2(root, visitor) {
        var worklist, leavelist, node, nodeType, target, element, current, current2, candidates, candidate, sentinel, outer, key;
        function removeElem(element2) {
          var i, key2, nextElem, parent;
          if (element2.ref.remove()) {
            key2 = element2.ref.key;
            parent = element2.ref.parent;
            i = worklist.length;
            while (i--) {
              nextElem = worklist[i];
              if (nextElem.ref && nextElem.ref.parent === parent) {
                if (nextElem.ref.key < key2) {
                  break;
                }
                --nextElem.ref.key;
              }
            }
          }
        }
        this.__initialize(root, visitor);
        sentinel = {};
        worklist = this.__worklist;
        leavelist = this.__leavelist;
        outer = {
          root
        };
        element = new Element(root, null, null, new Reference(outer, "root"));
        worklist.push(element);
        leavelist.push(element);
        while (worklist.length) {
          element = worklist.pop();
          if (element === sentinel) {
            element = leavelist.pop();
            target = this.__execute(visitor.leave, element);
            if (target !== void 0 && target !== BREAK && target !== SKIP && target !== REMOVE) {
              element.ref.replace(target);
            }
            if (this.__state === REMOVE || target === REMOVE) {
              removeElem(element);
            }
            if (this.__state === BREAK || target === BREAK) {
              return outer.root;
            }
            continue;
          }
          target = this.__execute(visitor.enter, element);
          if (target !== void 0 && target !== BREAK && target !== SKIP && target !== REMOVE) {
            element.ref.replace(target);
            element.node = target;
          }
          if (this.__state === REMOVE || target === REMOVE) {
            removeElem(element);
            element.node = null;
          }
          if (this.__state === BREAK || target === BREAK) {
            return outer.root;
          }
          node = element.node;
          if (!node) {
            continue;
          }
          worklist.push(sentinel);
          leavelist.push(element);
          if (this.__state === SKIP || target === SKIP) {
            continue;
          }
          nodeType = node.type || element.wrap;
          candidates = this.__keys[nodeType];
          if (!candidates) {
            if (this.__fallback) {
              candidates = this.__fallback(node);
            } else {
              throw new Error("Unknown node type " + nodeType + ".");
            }
          }
          current = candidates.length;
          while ((current -= 1) >= 0) {
            key = candidates[current];
            candidate = node[key];
            if (!candidate) {
              continue;
            }
            if (Array.isArray(candidate)) {
              current2 = candidate.length;
              while ((current2 -= 1) >= 0) {
                if (!candidate[current2]) {
                  continue;
                }
                if (isProperty(nodeType, candidates[current])) {
                  element = new Element(candidate[current2], [key, current2], "Property", new Reference(candidate, current2));
                } else if (isNode(candidate[current2])) {
                  element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
                } else {
                  continue;
                }
                worklist.push(element);
              }
            } else if (isNode(candidate)) {
              worklist.push(new Element(candidate, key, null, new Reference(node, key)));
            }
          }
        }
        return outer.root;
      };
      function traverse(root, visitor) {
        var controller = new Controller();
        return controller.traverse(root, visitor);
      }
      function replace(root, visitor) {
        var controller = new Controller();
        return controller.replace(root, visitor);
      }
      function extendCommentRange(comment, tokens) {
        var target;
        target = upperBound(tokens, function search(token) {
          return token.range[0] > comment.range[0];
        });
        comment.extendedRange = [comment.range[0], comment.range[1]];
        if (target !== tokens.length) {
          comment.extendedRange[1] = tokens[target].range[0];
        }
        target -= 1;
        if (target >= 0) {
          comment.extendedRange[0] = tokens[target].range[1];
        }
        return comment;
      }
      function attachComments(tree, providedComments, tokens) {
        var comments = [], comment, len, i, cursor;
        if (!tree.range) {
          throw new Error("attachComments needs range information");
        }
        if (!tokens.length) {
          if (providedComments.length) {
            for (i = 0, len = providedComments.length; i < len; i += 1) {
              comment = deepCopy(providedComments[i]);
              comment.extendedRange = [0, tree.range[0]];
              comments.push(comment);
            }
            tree.leadingComments = comments;
          }
          return tree;
        }
        for (i = 0, len = providedComments.length; i < len; i += 1) {
          comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
        }
        cursor = 0;
        traverse(tree, {
          enter: function(node) {
            var comment2;
            while (cursor < comments.length) {
              comment2 = comments[cursor];
              if (comment2.extendedRange[1] > node.range[0]) {
                break;
              }
              if (comment2.extendedRange[1] === node.range[0]) {
                if (!node.leadingComments) {
                  node.leadingComments = [];
                }
                node.leadingComments.push(comment2);
                comments.splice(cursor, 1);
              } else {
                cursor += 1;
              }
            }
            if (cursor === comments.length) {
              return VisitorOption.Break;
            }
            if (comments[cursor].extendedRange[0] > node.range[1]) {
              return VisitorOption.Skip;
            }
          }
        });
        cursor = 0;
        traverse(tree, {
          leave: function(node) {
            var comment2;
            while (cursor < comments.length) {
              comment2 = comments[cursor];
              if (node.range[1] < comment2.extendedRange[0]) {
                break;
              }
              if (node.range[1] === comment2.extendedRange[0]) {
                if (!node.trailingComments) {
                  node.trailingComments = [];
                }
                node.trailingComments.push(comment2);
                comments.splice(cursor, 1);
              } else {
                cursor += 1;
              }
            }
            if (cursor === comments.length) {
              return VisitorOption.Break;
            }
            if (comments[cursor].extendedRange[0] > node.range[1]) {
              return VisitorOption.Skip;
            }
          }
        });
        return tree;
      }
      exports2.Syntax = Syntax;
      exports2.traverse = traverse;
      exports2.replace = replace;
      exports2.attachComments = attachComments;
      exports2.VisitorKeys = VisitorKeys;
      exports2.VisitorOption = VisitorOption;
      exports2.Controller = Controller;
      exports2.cloneEnvironment = function() {
        return clone({});
      };
      return exports2;
    })(exports);
  }
});

// ../../node_modules/esrecurse/node_modules/estraverse/estraverse.js
var require_estraverse2 = __commonJS({
  "../../node_modules/esrecurse/node_modules/estraverse/estraverse.js"(exports) {
    (function clone(exports2) {
      "use strict";
      var Syntax, VisitorOption, VisitorKeys, BREAK, SKIP, REMOVE;
      function deepCopy(obj) {
        var ret = {}, key, val;
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            val = obj[key];
            if (typeof val === "object" && val !== null) {
              ret[key] = deepCopy(val);
            } else {
              ret[key] = val;
            }
          }
        }
        return ret;
      }
      function upperBound(array, func) {
        var diff, len, i, current;
        len = array.length;
        i = 0;
        while (len) {
          diff = len >>> 1;
          current = i + diff;
          if (func(array[current])) {
            len = diff;
          } else {
            i = current + 1;
            len -= diff + 1;
          }
        }
        return i;
      }
      Syntax = {
        AssignmentExpression: "AssignmentExpression",
        AssignmentPattern: "AssignmentPattern",
        ArrayExpression: "ArrayExpression",
        ArrayPattern: "ArrayPattern",
        ArrowFunctionExpression: "ArrowFunctionExpression",
        AwaitExpression: "AwaitExpression",
        // CAUTION: It's deferred to ES7.
        BlockStatement: "BlockStatement",
        BinaryExpression: "BinaryExpression",
        BreakStatement: "BreakStatement",
        CallExpression: "CallExpression",
        CatchClause: "CatchClause",
        ChainExpression: "ChainExpression",
        ClassBody: "ClassBody",
        ClassDeclaration: "ClassDeclaration",
        ClassExpression: "ClassExpression",
        ComprehensionBlock: "ComprehensionBlock",
        // CAUTION: It's deferred to ES7.
        ComprehensionExpression: "ComprehensionExpression",
        // CAUTION: It's deferred to ES7.
        ConditionalExpression: "ConditionalExpression",
        ContinueStatement: "ContinueStatement",
        DebuggerStatement: "DebuggerStatement",
        DirectiveStatement: "DirectiveStatement",
        DoWhileStatement: "DoWhileStatement",
        EmptyStatement: "EmptyStatement",
        ExportAllDeclaration: "ExportAllDeclaration",
        ExportDefaultDeclaration: "ExportDefaultDeclaration",
        ExportNamedDeclaration: "ExportNamedDeclaration",
        ExportSpecifier: "ExportSpecifier",
        ExpressionStatement: "ExpressionStatement",
        ForStatement: "ForStatement",
        ForInStatement: "ForInStatement",
        ForOfStatement: "ForOfStatement",
        FunctionDeclaration: "FunctionDeclaration",
        FunctionExpression: "FunctionExpression",
        GeneratorExpression: "GeneratorExpression",
        // CAUTION: It's deferred to ES7.
        Identifier: "Identifier",
        IfStatement: "IfStatement",
        ImportExpression: "ImportExpression",
        ImportDeclaration: "ImportDeclaration",
        ImportDefaultSpecifier: "ImportDefaultSpecifier",
        ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
        ImportSpecifier: "ImportSpecifier",
        Literal: "Literal",
        LabeledStatement: "LabeledStatement",
        LogicalExpression: "LogicalExpression",
        MemberExpression: "MemberExpression",
        MetaProperty: "MetaProperty",
        MethodDefinition: "MethodDefinition",
        ModuleSpecifier: "ModuleSpecifier",
        NewExpression: "NewExpression",
        ObjectExpression: "ObjectExpression",
        ObjectPattern: "ObjectPattern",
        PrivateIdentifier: "PrivateIdentifier",
        Program: "Program",
        Property: "Property",
        PropertyDefinition: "PropertyDefinition",
        RestElement: "RestElement",
        ReturnStatement: "ReturnStatement",
        SequenceExpression: "SequenceExpression",
        SpreadElement: "SpreadElement",
        Super: "Super",
        SwitchStatement: "SwitchStatement",
        SwitchCase: "SwitchCase",
        TaggedTemplateExpression: "TaggedTemplateExpression",
        TemplateElement: "TemplateElement",
        TemplateLiteral: "TemplateLiteral",
        ThisExpression: "ThisExpression",
        ThrowStatement: "ThrowStatement",
        TryStatement: "TryStatement",
        UnaryExpression: "UnaryExpression",
        UpdateExpression: "UpdateExpression",
        VariableDeclaration: "VariableDeclaration",
        VariableDeclarator: "VariableDeclarator",
        WhileStatement: "WhileStatement",
        WithStatement: "WithStatement",
        YieldExpression: "YieldExpression"
      };
      VisitorKeys = {
        AssignmentExpression: ["left", "right"],
        AssignmentPattern: ["left", "right"],
        ArrayExpression: ["elements"],
        ArrayPattern: ["elements"],
        ArrowFunctionExpression: ["params", "body"],
        AwaitExpression: ["argument"],
        // CAUTION: It's deferred to ES7.
        BlockStatement: ["body"],
        BinaryExpression: ["left", "right"],
        BreakStatement: ["label"],
        CallExpression: ["callee", "arguments"],
        CatchClause: ["param", "body"],
        ChainExpression: ["expression"],
        ClassBody: ["body"],
        ClassDeclaration: ["id", "superClass", "body"],
        ClassExpression: ["id", "superClass", "body"],
        ComprehensionBlock: ["left", "right"],
        // CAUTION: It's deferred to ES7.
        ComprehensionExpression: ["blocks", "filter", "body"],
        // CAUTION: It's deferred to ES7.
        ConditionalExpression: ["test", "consequent", "alternate"],
        ContinueStatement: ["label"],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: ["body", "test"],
        EmptyStatement: [],
        ExportAllDeclaration: ["source"],
        ExportDefaultDeclaration: ["declaration"],
        ExportNamedDeclaration: ["declaration", "specifiers", "source"],
        ExportSpecifier: ["exported", "local"],
        ExpressionStatement: ["expression"],
        ForStatement: ["init", "test", "update", "body"],
        ForInStatement: ["left", "right", "body"],
        ForOfStatement: ["left", "right", "body"],
        FunctionDeclaration: ["id", "params", "body"],
        FunctionExpression: ["id", "params", "body"],
        GeneratorExpression: ["blocks", "filter", "body"],
        // CAUTION: It's deferred to ES7.
        Identifier: [],
        IfStatement: ["test", "consequent", "alternate"],
        ImportExpression: ["source"],
        ImportDeclaration: ["specifiers", "source"],
        ImportDefaultSpecifier: ["local"],
        ImportNamespaceSpecifier: ["local"],
        ImportSpecifier: ["imported", "local"],
        Literal: [],
        LabeledStatement: ["label", "body"],
        LogicalExpression: ["left", "right"],
        MemberExpression: ["object", "property"],
        MetaProperty: ["meta", "property"],
        MethodDefinition: ["key", "value"],
        ModuleSpecifier: [],
        NewExpression: ["callee", "arguments"],
        ObjectExpression: ["properties"],
        ObjectPattern: ["properties"],
        PrivateIdentifier: [],
        Program: ["body"],
        Property: ["key", "value"],
        PropertyDefinition: ["key", "value"],
        RestElement: ["argument"],
        ReturnStatement: ["argument"],
        SequenceExpression: ["expressions"],
        SpreadElement: ["argument"],
        Super: [],
        SwitchStatement: ["discriminant", "cases"],
        SwitchCase: ["test", "consequent"],
        TaggedTemplateExpression: ["tag", "quasi"],
        TemplateElement: [],
        TemplateLiteral: ["quasis", "expressions"],
        ThisExpression: [],
        ThrowStatement: ["argument"],
        TryStatement: ["block", "handler", "finalizer"],
        UnaryExpression: ["argument"],
        UpdateExpression: ["argument"],
        VariableDeclaration: ["declarations"],
        VariableDeclarator: ["id", "init"],
        WhileStatement: ["test", "body"],
        WithStatement: ["object", "body"],
        YieldExpression: ["argument"]
      };
      BREAK = {};
      SKIP = {};
      REMOVE = {};
      VisitorOption = {
        Break: BREAK,
        Skip: SKIP,
        Remove: REMOVE
      };
      function Reference(parent, key) {
        this.parent = parent;
        this.key = key;
      }
      Reference.prototype.replace = function replace2(node) {
        this.parent[this.key] = node;
      };
      Reference.prototype.remove = function remove() {
        if (Array.isArray(this.parent)) {
          this.parent.splice(this.key, 1);
          return true;
        } else {
          this.replace(null);
          return false;
        }
      };
      function Element(node, path, wrap, ref) {
        this.node = node;
        this.path = path;
        this.wrap = wrap;
        this.ref = ref;
      }
      function Controller() {
      }
      Controller.prototype.path = function path() {
        var i, iz, j, jz, result, element;
        function addToPath(result2, path2) {
          if (Array.isArray(path2)) {
            for (j = 0, jz = path2.length; j < jz; ++j) {
              result2.push(path2[j]);
            }
          } else {
            result2.push(path2);
          }
        }
        if (!this.__current.path) {
          return null;
        }
        result = [];
        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
          element = this.__leavelist[i];
          addToPath(result, element.path);
        }
        addToPath(result, this.__current.path);
        return result;
      };
      Controller.prototype.type = function() {
        var node = this.current();
        return node.type || this.__current.wrap;
      };
      Controller.prototype.parents = function parents() {
        var i, iz, result;
        result = [];
        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
          result.push(this.__leavelist[i].node);
        }
        return result;
      };
      Controller.prototype.current = function current() {
        return this.__current.node;
      };
      Controller.prototype.__execute = function __execute(callback, element) {
        var previous, result;
        result = void 0;
        previous = this.__current;
        this.__current = element;
        this.__state = null;
        if (callback) {
          result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
        }
        this.__current = previous;
        return result;
      };
      Controller.prototype.notify = function notify(flag) {
        this.__state = flag;
      };
      Controller.prototype.skip = function() {
        this.notify(SKIP);
      };
      Controller.prototype["break"] = function() {
        this.notify(BREAK);
      };
      Controller.prototype.remove = function() {
        this.notify(REMOVE);
      };
      Controller.prototype.__initialize = function(root, visitor) {
        this.visitor = visitor;
        this.root = root;
        this.__worklist = [];
        this.__leavelist = [];
        this.__current = null;
        this.__state = null;
        this.__fallback = null;
        if (visitor.fallback === "iteration") {
          this.__fallback = Object.keys;
        } else if (typeof visitor.fallback === "function") {
          this.__fallback = visitor.fallback;
        }
        this.__keys = VisitorKeys;
        if (visitor.keys) {
          this.__keys = Object.assign(Object.create(this.__keys), visitor.keys);
        }
      };
      function isNode(node) {
        if (node == null) {
          return false;
        }
        return typeof node === "object" && typeof node.type === "string";
      }
      function isProperty(nodeType, key) {
        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && "properties" === key;
      }
      function candidateExistsInLeaveList(leavelist, candidate) {
        for (var i = leavelist.length - 1; i >= 0; --i) {
          if (leavelist[i].node === candidate) {
            return true;
          }
        }
        return false;
      }
      Controller.prototype.traverse = function traverse2(root, visitor) {
        var worklist, leavelist, element, node, nodeType, ret, key, current, current2, candidates, candidate, sentinel;
        this.__initialize(root, visitor);
        sentinel = {};
        worklist = this.__worklist;
        leavelist = this.__leavelist;
        worklist.push(new Element(root, null, null, null));
        leavelist.push(new Element(null, null, null, null));
        while (worklist.length) {
          element = worklist.pop();
          if (element === sentinel) {
            element = leavelist.pop();
            ret = this.__execute(visitor.leave, element);
            if (this.__state === BREAK || ret === BREAK) {
              return;
            }
            continue;
          }
          if (element.node) {
            ret = this.__execute(visitor.enter, element);
            if (this.__state === BREAK || ret === BREAK) {
              return;
            }
            worklist.push(sentinel);
            leavelist.push(element);
            if (this.__state === SKIP || ret === SKIP) {
              continue;
            }
            node = element.node;
            nodeType = node.type || element.wrap;
            candidates = this.__keys[nodeType];
            if (!candidates) {
              if (this.__fallback) {
                candidates = this.__fallback(node);
              } else {
                throw new Error("Unknown node type " + nodeType + ".");
              }
            }
            current = candidates.length;
            while ((current -= 1) >= 0) {
              key = candidates[current];
              candidate = node[key];
              if (!candidate) {
                continue;
              }
              if (Array.isArray(candidate)) {
                current2 = candidate.length;
                while ((current2 -= 1) >= 0) {
                  if (!candidate[current2]) {
                    continue;
                  }
                  if (candidateExistsInLeaveList(leavelist, candidate[current2])) {
                    continue;
                  }
                  if (isProperty(nodeType, candidates[current])) {
                    element = new Element(candidate[current2], [key, current2], "Property", null);
                  } else if (isNode(candidate[current2])) {
                    element = new Element(candidate[current2], [key, current2], null, null);
                  } else {
                    continue;
                  }
                  worklist.push(element);
                }
              } else if (isNode(candidate)) {
                if (candidateExistsInLeaveList(leavelist, candidate)) {
                  continue;
                }
                worklist.push(new Element(candidate, key, null, null));
              }
            }
          }
        }
      };
      Controller.prototype.replace = function replace2(root, visitor) {
        var worklist, leavelist, node, nodeType, target, element, current, current2, candidates, candidate, sentinel, outer, key;
        function removeElem(element2) {
          var i, key2, nextElem, parent;
          if (element2.ref.remove()) {
            key2 = element2.ref.key;
            parent = element2.ref.parent;
            i = worklist.length;
            while (i--) {
              nextElem = worklist[i];
              if (nextElem.ref && nextElem.ref.parent === parent) {
                if (nextElem.ref.key < key2) {
                  break;
                }
                --nextElem.ref.key;
              }
            }
          }
        }
        this.__initialize(root, visitor);
        sentinel = {};
        worklist = this.__worklist;
        leavelist = this.__leavelist;
        outer = {
          root
        };
        element = new Element(root, null, null, new Reference(outer, "root"));
        worklist.push(element);
        leavelist.push(element);
        while (worklist.length) {
          element = worklist.pop();
          if (element === sentinel) {
            element = leavelist.pop();
            target = this.__execute(visitor.leave, element);
            if (target !== void 0 && target !== BREAK && target !== SKIP && target !== REMOVE) {
              element.ref.replace(target);
            }
            if (this.__state === REMOVE || target === REMOVE) {
              removeElem(element);
            }
            if (this.__state === BREAK || target === BREAK) {
              return outer.root;
            }
            continue;
          }
          target = this.__execute(visitor.enter, element);
          if (target !== void 0 && target !== BREAK && target !== SKIP && target !== REMOVE) {
            element.ref.replace(target);
            element.node = target;
          }
          if (this.__state === REMOVE || target === REMOVE) {
            removeElem(element);
            element.node = null;
          }
          if (this.__state === BREAK || target === BREAK) {
            return outer.root;
          }
          node = element.node;
          if (!node) {
            continue;
          }
          worklist.push(sentinel);
          leavelist.push(element);
          if (this.__state === SKIP || target === SKIP) {
            continue;
          }
          nodeType = node.type || element.wrap;
          candidates = this.__keys[nodeType];
          if (!candidates) {
            if (this.__fallback) {
              candidates = this.__fallback(node);
            } else {
              throw new Error("Unknown node type " + nodeType + ".");
            }
          }
          current = candidates.length;
          while ((current -= 1) >= 0) {
            key = candidates[current];
            candidate = node[key];
            if (!candidate) {
              continue;
            }
            if (Array.isArray(candidate)) {
              current2 = candidate.length;
              while ((current2 -= 1) >= 0) {
                if (!candidate[current2]) {
                  continue;
                }
                if (isProperty(nodeType, candidates[current])) {
                  element = new Element(candidate[current2], [key, current2], "Property", new Reference(candidate, current2));
                } else if (isNode(candidate[current2])) {
                  element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
                } else {
                  continue;
                }
                worklist.push(element);
              }
            } else if (isNode(candidate)) {
              worklist.push(new Element(candidate, key, null, new Reference(node, key)));
            }
          }
        }
        return outer.root;
      };
      function traverse(root, visitor) {
        var controller = new Controller();
        return controller.traverse(root, visitor);
      }
      function replace(root, visitor) {
        var controller = new Controller();
        return controller.replace(root, visitor);
      }
      function extendCommentRange(comment, tokens) {
        var target;
        target = upperBound(tokens, function search(token) {
          return token.range[0] > comment.range[0];
        });
        comment.extendedRange = [comment.range[0], comment.range[1]];
        if (target !== tokens.length) {
          comment.extendedRange[1] = tokens[target].range[0];
        }
        target -= 1;
        if (target >= 0) {
          comment.extendedRange[0] = tokens[target].range[1];
        }
        return comment;
      }
      function attachComments(tree, providedComments, tokens) {
        var comments = [], comment, len, i, cursor;
        if (!tree.range) {
          throw new Error("attachComments needs range information");
        }
        if (!tokens.length) {
          if (providedComments.length) {
            for (i = 0, len = providedComments.length; i < len; i += 1) {
              comment = deepCopy(providedComments[i]);
              comment.extendedRange = [0, tree.range[0]];
              comments.push(comment);
            }
            tree.leadingComments = comments;
          }
          return tree;
        }
        for (i = 0, len = providedComments.length; i < len; i += 1) {
          comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
        }
        cursor = 0;
        traverse(tree, {
          enter: function(node) {
            var comment2;
            while (cursor < comments.length) {
              comment2 = comments[cursor];
              if (comment2.extendedRange[1] > node.range[0]) {
                break;
              }
              if (comment2.extendedRange[1] === node.range[0]) {
                if (!node.leadingComments) {
                  node.leadingComments = [];
                }
                node.leadingComments.push(comment2);
                comments.splice(cursor, 1);
              } else {
                cursor += 1;
              }
            }
            if (cursor === comments.length) {
              return VisitorOption.Break;
            }
            if (comments[cursor].extendedRange[0] > node.range[1]) {
              return VisitorOption.Skip;
            }
          }
        });
        cursor = 0;
        traverse(tree, {
          leave: function(node) {
            var comment2;
            while (cursor < comments.length) {
              comment2 = comments[cursor];
              if (node.range[1] < comment2.extendedRange[0]) {
                break;
              }
              if (node.range[1] === comment2.extendedRange[0]) {
                if (!node.trailingComments) {
                  node.trailingComments = [];
                }
                node.trailingComments.push(comment2);
                comments.splice(cursor, 1);
              } else {
                cursor += 1;
              }
            }
            if (cursor === comments.length) {
              return VisitorOption.Break;
            }
            if (comments[cursor].extendedRange[0] > node.range[1]) {
              return VisitorOption.Skip;
            }
          }
        });
        return tree;
      }
      exports2.Syntax = Syntax;
      exports2.traverse = traverse;
      exports2.replace = replace;
      exports2.attachComments = attachComments;
      exports2.VisitorKeys = VisitorKeys;
      exports2.VisitorOption = VisitorOption;
      exports2.Controller = Controller;
      exports2.cloneEnvironment = function() {
        return clone({});
      };
      return exports2;
    })(exports);
  }
});

// ../../node_modules/esrecurse/package.json
var require_package = __commonJS({
  "../../node_modules/esrecurse/package.json"(exports, module) {
    module.exports = {
      name: "esrecurse",
      description: "ECMAScript AST recursive visitor",
      homepage: "https://github.com/estools/esrecurse",
      main: "esrecurse.js",
      version: "4.3.0",
      engines: {
        node: ">=4.0"
      },
      maintainers: [
        {
          name: "Yusuke Suzuki",
          email: "utatane.tea@gmail.com",
          web: "https://github.com/Constellation"
        }
      ],
      repository: {
        type: "git",
        url: "https://github.com/estools/esrecurse.git"
      },
      dependencies: {
        estraverse: "^5.2.0"
      },
      devDependencies: {
        "babel-cli": "^6.24.1",
        "babel-eslint": "^7.2.3",
        "babel-preset-es2015": "^6.24.1",
        "babel-register": "^6.24.1",
        chai: "^4.0.2",
        esprima: "^4.0.0",
        gulp: "^3.9.0",
        "gulp-bump": "^2.7.0",
        "gulp-eslint": "^4.0.0",
        "gulp-filter": "^5.0.0",
        "gulp-git": "^2.4.1",
        "gulp-mocha": "^4.3.1",
        "gulp-tag-version": "^1.2.1",
        jsdoc: "^3.3.0-alpha10",
        minimist: "^1.1.0"
      },
      license: "BSD-2-Clause",
      scripts: {
        test: "gulp travis",
        "unit-test": "gulp test",
        lint: "gulp lint"
      },
      babel: {
        presets: [
          "es2015"
        ]
      }
    };
  }
});

// ../../node_modules/esrecurse/esrecurse.js
var require_esrecurse = __commonJS({
  "../../node_modules/esrecurse/esrecurse.js"(exports) {
    (function() {
      "use strict";
      var estraverse = require_estraverse2();
      function isNode(node) {
        if (node == null) {
          return false;
        }
        return typeof node === "object" && typeof node.type === "string";
      }
      function isProperty(nodeType, key) {
        return (nodeType === estraverse.Syntax.ObjectExpression || nodeType === estraverse.Syntax.ObjectPattern) && key === "properties";
      }
      function Visitor(visitor, options) {
        options = options || {};
        this.__visitor = visitor || this;
        this.__childVisitorKeys = options.childVisitorKeys ? Object.assign({}, estraverse.VisitorKeys, options.childVisitorKeys) : estraverse.VisitorKeys;
        if (options.fallback === "iteration") {
          this.__fallback = Object.keys;
        } else if (typeof options.fallback === "function") {
          this.__fallback = options.fallback;
        }
      }
      Visitor.prototype.visitChildren = function(node) {
        var type, children, i, iz, j, jz, child;
        if (node == null) {
          return;
        }
        type = node.type || estraverse.Syntax.Property;
        children = this.__childVisitorKeys[type];
        if (!children) {
          if (this.__fallback) {
            children = this.__fallback(node);
          } else {
            throw new Error("Unknown node type " + type + ".");
          }
        }
        for (i = 0, iz = children.length; i < iz; ++i) {
          child = node[children[i]];
          if (child) {
            if (Array.isArray(child)) {
              for (j = 0, jz = child.length; j < jz; ++j) {
                if (child[j]) {
                  if (isNode(child[j]) || isProperty(type, children[i])) {
                    this.visit(child[j]);
                  }
                }
              }
            } else if (isNode(child)) {
              this.visit(child);
            }
          }
        }
      };
      Visitor.prototype.visit = function(node) {
        var type;
        if (node == null) {
          return;
        }
        type = node.type || estraverse.Syntax.Property;
        if (this.__visitor[type]) {
          this.__visitor[type].call(this, node);
          return;
        }
        this.visitChildren(node);
      };
      exports.version = require_package().version;
      exports.Visitor = Visitor;
      exports.visit = function(node, visitor, options) {
        var v = new Visitor(visitor, options);
        v.visit(node);
      };
    })();
  }
});

// ../../node_modules/eslint/node_modules/eslint-scope/dist/eslint-scope.cjs
var require_eslint_scope = __commonJS({
  "../../node_modules/eslint/node_modules/eslint-scope/dist/eslint-scope.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var assert = require_assert();
    var estraverse = require_estraverse();
    var esrecurse = require_esrecurse();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var assert__default = /* @__PURE__ */ _interopDefaultLegacy(assert);
    var estraverse__default = /* @__PURE__ */ _interopDefaultLegacy(estraverse);
    var esrecurse__default = /* @__PURE__ */ _interopDefaultLegacy(esrecurse);
    var READ = 1;
    var WRITE = 2;
    var RW = READ | WRITE;
    var Reference = class {
      constructor(ident, scope, flag, writeExpr, maybeImplicitGlobal, partial, init) {
        this.identifier = ident;
        this.from = scope;
        this.tainted = false;
        this.resolved = null;
        this.flag = flag;
        if (this.isWrite()) {
          this.writeExpr = writeExpr;
          this.partial = partial;
          this.init = init;
        }
        this.__maybeImplicitGlobal = maybeImplicitGlobal;
      }
      /**
       * Whether the reference is static.
       * @function Reference#isStatic
       * @returns {boolean} static
       */
      isStatic() {
        return !this.tainted && this.resolved && this.resolved.scope.isStatic();
      }
      /**
       * Whether the reference is writeable.
       * @function Reference#isWrite
       * @returns {boolean} write
       */
      isWrite() {
        return !!(this.flag & Reference.WRITE);
      }
      /**
       * Whether the reference is readable.
       * @function Reference#isRead
       * @returns {boolean} read
       */
      isRead() {
        return !!(this.flag & Reference.READ);
      }
      /**
       * Whether the reference is read-only.
       * @function Reference#isReadOnly
       * @returns {boolean} read only
       */
      isReadOnly() {
        return this.flag === Reference.READ;
      }
      /**
       * Whether the reference is write-only.
       * @function Reference#isWriteOnly
       * @returns {boolean} write only
       */
      isWriteOnly() {
        return this.flag === Reference.WRITE;
      }
      /**
       * Whether the reference is read-write.
       * @function Reference#isReadWrite
       * @returns {boolean} read write
       */
      isReadWrite() {
        return this.flag === Reference.RW;
      }
    };
    Reference.READ = READ;
    Reference.WRITE = WRITE;
    Reference.RW = RW;
    var Variable = class {
      constructor(name, scope) {
        this.name = name;
        this.identifiers = [];
        this.references = [];
        this.defs = [];
        this.tainted = false;
        this.stack = true;
        this.scope = scope;
      }
    };
    Variable.CatchClause = "CatchClause";
    Variable.Parameter = "Parameter";
    Variable.FunctionName = "FunctionName";
    Variable.ClassName = "ClassName";
    Variable.Variable = "Variable";
    Variable.ImportBinding = "ImportBinding";
    Variable.ImplicitGlobalVariable = "ImplicitGlobalVariable";
    var Definition = class {
      constructor(type, name, node, parent, index, kind) {
        this.type = type;
        this.name = name;
        this.node = node;
        this.parent = parent;
        this.index = index;
        this.kind = kind;
      }
    };
    var ParameterDefinition = class extends Definition {
      constructor(name, node, index, rest) {
        super(Variable.Parameter, name, node, null, index, null);
        this.rest = rest;
      }
    };
    var { Syntax: Syntax$2 } = estraverse__default["default"];
    function isStrictScope(scope, block, isMethodDefinition, useDirective) {
      let body;
      if (scope.upper && scope.upper.isStrict) {
        return true;
      }
      if (isMethodDefinition) {
        return true;
      }
      if (scope.type === "class" || scope.type === "module") {
        return true;
      }
      if (scope.type === "block" || scope.type === "switch") {
        return false;
      }
      if (scope.type === "function") {
        if (block.type === Syntax$2.ArrowFunctionExpression && block.body.type !== Syntax$2.BlockStatement) {
          return false;
        }
        if (block.type === Syntax$2.Program) {
          body = block;
        } else {
          body = block.body;
        }
        if (!body) {
          return false;
        }
      } else if (scope.type === "global") {
        body = block;
      } else {
        return false;
      }
      if (useDirective) {
        for (let i = 0, iz = body.body.length; i < iz; ++i) {
          const stmt = body.body[i];
          if (stmt.type !== Syntax$2.DirectiveStatement) {
            break;
          }
          if (stmt.raw === '"use strict"' || stmt.raw === "'use strict'") {
            return true;
          }
        }
      } else {
        for (let i = 0, iz = body.body.length; i < iz; ++i) {
          const stmt = body.body[i];
          if (stmt.type !== Syntax$2.ExpressionStatement) {
            break;
          }
          const expr = stmt.expression;
          if (expr.type !== Syntax$2.Literal || typeof expr.value !== "string") {
            break;
          }
          if (expr.raw !== null && expr.raw !== void 0) {
            if (expr.raw === '"use strict"' || expr.raw === "'use strict'") {
              return true;
            }
          } else {
            if (expr.value === "use strict") {
              return true;
            }
          }
        }
      }
      return false;
    }
    function registerScope(scopeManager, scope) {
      scopeManager.scopes.push(scope);
      const scopes = scopeManager.__nodeToScope.get(scope.block);
      if (scopes) {
        scopes.push(scope);
      } else {
        scopeManager.__nodeToScope.set(scope.block, [scope]);
      }
    }
    function shouldBeStatically(def) {
      return def.type === Variable.ClassName || def.type === Variable.Variable && def.parent.kind !== "var";
    }
    var Scope = class {
      constructor(scopeManager, type, upperScope, block, isMethodDefinition) {
        this.type = type;
        this.set = /* @__PURE__ */ new Map();
        this.taints = /* @__PURE__ */ new Map();
        this.dynamic = this.type === "global" || this.type === "with";
        this.block = block;
        this.through = [];
        this.variables = [];
        this.references = [];
        this.variableScope = this.type === "global" || this.type === "module" || this.type === "function" || this.type === "class-field-initializer" || this.type === "class-static-block" ? this : upperScope.variableScope;
        this.functionExpressionScope = false;
        this.directCallToEvalScope = false;
        this.thisFound = false;
        this.__left = [];
        this.upper = upperScope;
        this.isStrict = scopeManager.isStrictModeSupported() ? isStrictScope(this, block, isMethodDefinition, scopeManager.__useDirective()) : false;
        this.childScopes = [];
        if (this.upper) {
          this.upper.childScopes.push(this);
        }
        this.__declaredVariables = scopeManager.__declaredVariables;
        registerScope(scopeManager, this);
      }
      __shouldStaticallyClose(scopeManager) {
        return !this.dynamic || scopeManager.__isOptimistic();
      }
      __shouldStaticallyCloseForGlobal(ref) {
        const name = ref.identifier.name;
        if (!this.set.has(name)) {
          return false;
        }
        const variable = this.set.get(name);
        const defs = variable.defs;
        return defs.length > 0 && defs.every(shouldBeStatically);
      }
      __staticCloseRef(ref) {
        if (!this.__resolve(ref)) {
          this.__delegateToUpperScope(ref);
        }
      }
      __dynamicCloseRef(ref) {
        let current = this;
        do {
          current.through.push(ref);
          current = current.upper;
        } while (current);
      }
      __globalCloseRef(ref) {
        if (this.__shouldStaticallyCloseForGlobal(ref)) {
          this.__staticCloseRef(ref);
        } else {
          this.__dynamicCloseRef(ref);
        }
      }
      __close(scopeManager) {
        let closeRef;
        if (this.__shouldStaticallyClose(scopeManager)) {
          closeRef = this.__staticCloseRef;
        } else if (this.type !== "global") {
          closeRef = this.__dynamicCloseRef;
        } else {
          closeRef = this.__globalCloseRef;
        }
        for (let i = 0, iz = this.__left.length; i < iz; ++i) {
          const ref = this.__left[i];
          closeRef.call(this, ref);
        }
        this.__left = null;
        return this.upper;
      }
      // To override by function scopes.
      // References in default parameters isn't resolved to variables which are in their function body.
      __isValidResolution(ref, variable) {
        return true;
      }
      __resolve(ref) {
        const name = ref.identifier.name;
        if (!this.set.has(name)) {
          return false;
        }
        const variable = this.set.get(name);
        if (!this.__isValidResolution(ref, variable)) {
          return false;
        }
        variable.references.push(ref);
        variable.stack = variable.stack && ref.from.variableScope === this.variableScope;
        if (ref.tainted) {
          variable.tainted = true;
          this.taints.set(variable.name, true);
        }
        ref.resolved = variable;
        return true;
      }
      __delegateToUpperScope(ref) {
        if (this.upper) {
          this.upper.__left.push(ref);
        }
        this.through.push(ref);
      }
      __addDeclaredVariablesOfNode(variable, node) {
        if (node === null || node === void 0) {
          return;
        }
        let variables = this.__declaredVariables.get(node);
        if (variables === null || variables === void 0) {
          variables = [];
          this.__declaredVariables.set(node, variables);
        }
        if (variables.indexOf(variable) === -1) {
          variables.push(variable);
        }
      }
      __defineGeneric(name, set, variables, node, def) {
        let variable;
        variable = set.get(name);
        if (!variable) {
          variable = new Variable(name, this);
          set.set(name, variable);
          variables.push(variable);
        }
        if (def) {
          variable.defs.push(def);
          this.__addDeclaredVariablesOfNode(variable, def.node);
          this.__addDeclaredVariablesOfNode(variable, def.parent);
        }
        if (node) {
          variable.identifiers.push(node);
        }
      }
      __define(node, def) {
        if (node && node.type === Syntax$2.Identifier) {
          this.__defineGeneric(
            node.name,
            this.set,
            this.variables,
            node,
            def
          );
        }
      }
      __referencing(node, assign, writeExpr, maybeImplicitGlobal, partial, init) {
        if (!node || node.type !== Syntax$2.Identifier) {
          return;
        }
        if (node.name === "super") {
          return;
        }
        const ref = new Reference(node, this, assign || Reference.READ, writeExpr, maybeImplicitGlobal, !!partial, !!init);
        this.references.push(ref);
        this.__left.push(ref);
      }
      __detectEval() {
        let current = this;
        this.directCallToEvalScope = true;
        do {
          current.dynamic = true;
          current = current.upper;
        } while (current);
      }
      __detectThis() {
        this.thisFound = true;
      }
      __isClosed() {
        return this.__left === null;
      }
      /**
       * returns resolved {Reference}
       * @function Scope#resolve
       * @param {Espree.Identifier} ident identifier to be resolved.
       * @returns {Reference} reference
       */
      resolve(ident) {
        let ref, i, iz;
        assert__default["default"](this.__isClosed(), "Scope should be closed.");
        assert__default["default"](ident.type === Syntax$2.Identifier, "Target should be identifier.");
        for (i = 0, iz = this.references.length; i < iz; ++i) {
          ref = this.references[i];
          if (ref.identifier === ident) {
            return ref;
          }
        }
        return null;
      }
      /**
       * returns this scope is static
       * @function Scope#isStatic
       * @returns {boolean} static
       */
      isStatic() {
        return !this.dynamic;
      }
      /**
       * returns this scope has materialized arguments
       * @function Scope#isArgumentsMaterialized
       * @returns {boolean} arguemnts materialized
       */
      isArgumentsMaterialized() {
        return true;
      }
      /**
       * returns this scope has materialized `this` reference
       * @function Scope#isThisMaterialized
       * @returns {boolean} this materialized
       */
      isThisMaterialized() {
        return true;
      }
      isUsedName(name) {
        if (this.set.has(name)) {
          return true;
        }
        for (let i = 0, iz = this.through.length; i < iz; ++i) {
          if (this.through[i].identifier.name === name) {
            return true;
          }
        }
        return false;
      }
    };
    var GlobalScope = class extends Scope {
      constructor(scopeManager, block) {
        super(scopeManager, "global", null, block, false);
        this.implicit = {
          set: /* @__PURE__ */ new Map(),
          variables: [],
          /**
           * List of {@link Reference}s that are left to be resolved (i.e. which
           * need to be linked to the variable they refer to).
           * @member {Reference[]} Scope#implicit#left
           */
          left: []
        };
      }
      __close(scopeManager) {
        const implicit = [];
        for (let i = 0, iz = this.__left.length; i < iz; ++i) {
          const ref = this.__left[i];
          if (ref.__maybeImplicitGlobal && !this.set.has(ref.identifier.name)) {
            implicit.push(ref.__maybeImplicitGlobal);
          }
        }
        for (let i = 0, iz = implicit.length; i < iz; ++i) {
          const info = implicit[i];
          this.__defineImplicit(
            info.pattern,
            new Definition(
              Variable.ImplicitGlobalVariable,
              info.pattern,
              info.node,
              null,
              null,
              null
            )
          );
        }
        this.implicit.left = this.__left;
        return super.__close(scopeManager);
      }
      __defineImplicit(node, def) {
        if (node && node.type === Syntax$2.Identifier) {
          this.__defineGeneric(
            node.name,
            this.implicit.set,
            this.implicit.variables,
            node,
            def
          );
        }
      }
    };
    var ModuleScope = class extends Scope {
      constructor(scopeManager, upperScope, block) {
        super(scopeManager, "module", upperScope, block, false);
      }
    };
    var FunctionExpressionNameScope = class extends Scope {
      constructor(scopeManager, upperScope, block) {
        super(scopeManager, "function-expression-name", upperScope, block, false);
        this.__define(
          block.id,
          new Definition(
            Variable.FunctionName,
            block.id,
            block,
            null,
            null,
            null
          )
        );
        this.functionExpressionScope = true;
      }
    };
    var CatchScope = class extends Scope {
      constructor(scopeManager, upperScope, block) {
        super(scopeManager, "catch", upperScope, block, false);
      }
    };
    var WithScope = class extends Scope {
      constructor(scopeManager, upperScope, block) {
        super(scopeManager, "with", upperScope, block, false);
      }
      __close(scopeManager) {
        if (this.__shouldStaticallyClose(scopeManager)) {
          return super.__close(scopeManager);
        }
        for (let i = 0, iz = this.__left.length; i < iz; ++i) {
          const ref = this.__left[i];
          ref.tainted = true;
          this.__delegateToUpperScope(ref);
        }
        this.__left = null;
        return this.upper;
      }
    };
    var BlockScope = class extends Scope {
      constructor(scopeManager, upperScope, block) {
        super(scopeManager, "block", upperScope, block, false);
      }
    };
    var SwitchScope = class extends Scope {
      constructor(scopeManager, upperScope, block) {
        super(scopeManager, "switch", upperScope, block, false);
      }
    };
    var FunctionScope = class extends Scope {
      constructor(scopeManager, upperScope, block, isMethodDefinition) {
        super(scopeManager, "function", upperScope, block, isMethodDefinition);
        if (this.block.type !== Syntax$2.ArrowFunctionExpression) {
          this.__defineArguments();
        }
      }
      isArgumentsMaterialized() {
        if (this.block.type === Syntax$2.ArrowFunctionExpression) {
          return false;
        }
        if (!this.isStatic()) {
          return true;
        }
        const variable = this.set.get("arguments");
        assert__default["default"](variable, "Always have arguments variable.");
        return variable.tainted || variable.references.length !== 0;
      }
      isThisMaterialized() {
        if (!this.isStatic()) {
          return true;
        }
        return this.thisFound;
      }
      __defineArguments() {
        this.__defineGeneric(
          "arguments",
          this.set,
          this.variables,
          null,
          null
        );
        this.taints.set("arguments", true);
      }
      // References in default parameters isn't resolved to variables which are in their function body.
      //     const x = 1
      //     function f(a = x) { // This `x` is resolved to the `x` in the outer scope.
      //         const x = 2
      //         console.log(a)
      //     }
      __isValidResolution(ref, variable) {
        if (this.block.type === "Program") {
          return true;
        }
        const bodyStart = this.block.body.range[0];
        return !(variable.scope === this && ref.identifier.range[0] < bodyStart && // the reference is in the parameter part.
        variable.defs.every((d) => d.name.range[0] >= bodyStart));
      }
    };
    var ForScope = class extends Scope {
      constructor(scopeManager, upperScope, block) {
        super(scopeManager, "for", upperScope, block, false);
      }
    };
    var ClassScope = class extends Scope {
      constructor(scopeManager, upperScope, block) {
        super(scopeManager, "class", upperScope, block, false);
      }
    };
    var ClassFieldInitializerScope = class extends Scope {
      constructor(scopeManager, upperScope, block) {
        super(scopeManager, "class-field-initializer", upperScope, block, true);
      }
    };
    var ClassStaticBlockScope = class extends Scope {
      constructor(scopeManager, upperScope, block) {
        super(scopeManager, "class-static-block", upperScope, block, true);
      }
    };
    var ScopeManager = class {
      constructor(options) {
        this.scopes = [];
        this.globalScope = null;
        this.__nodeToScope = /* @__PURE__ */ new WeakMap();
        this.__currentScope = null;
        this.__options = options;
        this.__declaredVariables = /* @__PURE__ */ new WeakMap();
      }
      __useDirective() {
        return this.__options.directive;
      }
      __isOptimistic() {
        return this.__options.optimistic;
      }
      __ignoreEval() {
        return this.__options.ignoreEval;
      }
      isGlobalReturn() {
        return this.__options.nodejsScope || this.__options.sourceType === "commonjs";
      }
      isModule() {
        return this.__options.sourceType === "module";
      }
      isImpliedStrict() {
        return this.__options.impliedStrict;
      }
      isStrictModeSupported() {
        return this.__options.ecmaVersion >= 5;
      }
      // Returns appropriate scope for this node.
      __get(node) {
        return this.__nodeToScope.get(node);
      }
      /**
       * Get variables that are declared by the node.
       *
       * "are declared by the node" means the node is same as `Variable.defs[].node` or `Variable.defs[].parent`.
       * If the node declares nothing, this method returns an empty array.
       * CAUTION: This API is experimental. See https://github.com/estools/escope/pull/69 for more details.
       * @param {Espree.Node} node a node to get.
       * @returns {Variable[]} variables that declared by the node.
       */
      getDeclaredVariables(node) {
        return this.__declaredVariables.get(node) || [];
      }
      /**
       * acquire scope from node.
       * @function ScopeManager#acquire
       * @param {Espree.Node} node node for the acquired scope.
       * @param {?boolean} [inner=false] look up the most inner scope, default value is false.
       * @returns {Scope?} Scope from node
       */
      acquire(node, inner) {
        function predicate(testScope) {
          if (testScope.type === "function" && testScope.functionExpressionScope) {
            return false;
          }
          return true;
        }
        const scopes = this.__get(node);
        if (!scopes || scopes.length === 0) {
          return null;
        }
        if (scopes.length === 1) {
          return scopes[0];
        }
        if (inner) {
          for (let i = scopes.length - 1; i >= 0; --i) {
            const scope = scopes[i];
            if (predicate(scope)) {
              return scope;
            }
          }
        } else {
          for (let i = 0, iz = scopes.length; i < iz; ++i) {
            const scope = scopes[i];
            if (predicate(scope)) {
              return scope;
            }
          }
        }
        return null;
      }
      /**
       * acquire all scopes from node.
       * @function ScopeManager#acquireAll
       * @param {Espree.Node} node node for the acquired scope.
       * @returns {Scopes?} Scope array
       */
      acquireAll(node) {
        return this.__get(node);
      }
      /**
       * release the node.
       * @function ScopeManager#release
       * @param {Espree.Node} node releasing node.
       * @param {?boolean} [inner=false] look up the most inner scope, default value is false.
       * @returns {Scope?} upper scope for the node.
       */
      release(node, inner) {
        const scopes = this.__get(node);
        if (scopes && scopes.length) {
          const scope = scopes[0].upper;
          if (!scope) {
            return null;
          }
          return this.acquire(scope.block, inner);
        }
        return null;
      }
      attach() {
      }
      // eslint-disable-line class-methods-use-this
      detach() {
      }
      // eslint-disable-line class-methods-use-this
      __nestScope(scope) {
        if (scope instanceof GlobalScope) {
          assert__default["default"](this.__currentScope === null);
          this.globalScope = scope;
        }
        this.__currentScope = scope;
        return scope;
      }
      __nestGlobalScope(node) {
        return this.__nestScope(new GlobalScope(this, node));
      }
      __nestBlockScope(node) {
        return this.__nestScope(new BlockScope(this, this.__currentScope, node));
      }
      __nestFunctionScope(node, isMethodDefinition) {
        return this.__nestScope(new FunctionScope(this, this.__currentScope, node, isMethodDefinition));
      }
      __nestForScope(node) {
        return this.__nestScope(new ForScope(this, this.__currentScope, node));
      }
      __nestCatchScope(node) {
        return this.__nestScope(new CatchScope(this, this.__currentScope, node));
      }
      __nestWithScope(node) {
        return this.__nestScope(new WithScope(this, this.__currentScope, node));
      }
      __nestClassScope(node) {
        return this.__nestScope(new ClassScope(this, this.__currentScope, node));
      }
      __nestClassFieldInitializerScope(node) {
        return this.__nestScope(new ClassFieldInitializerScope(this, this.__currentScope, node));
      }
      __nestClassStaticBlockScope(node) {
        return this.__nestScope(new ClassStaticBlockScope(this, this.__currentScope, node));
      }
      __nestSwitchScope(node) {
        return this.__nestScope(new SwitchScope(this, this.__currentScope, node));
      }
      __nestModuleScope(node) {
        return this.__nestScope(new ModuleScope(this, this.__currentScope, node));
      }
      __nestFunctionExpressionNameScope(node) {
        return this.__nestScope(new FunctionExpressionNameScope(this, this.__currentScope, node));
      }
      __isES6() {
        return this.__options.ecmaVersion >= 6;
      }
    };
    var { Syntax: Syntax$1 } = estraverse__default["default"];
    function getLast(xs) {
      return xs[xs.length - 1] || null;
    }
    var PatternVisitor = class extends esrecurse__default["default"].Visitor {
      static isPattern(node) {
        const nodeType = node.type;
        return nodeType === Syntax$1.Identifier || nodeType === Syntax$1.ObjectPattern || nodeType === Syntax$1.ArrayPattern || nodeType === Syntax$1.SpreadElement || nodeType === Syntax$1.RestElement || nodeType === Syntax$1.AssignmentPattern;
      }
      constructor(options, rootPattern, callback) {
        super(null, options);
        this.rootPattern = rootPattern;
        this.callback = callback;
        this.assignments = [];
        this.rightHandNodes = [];
        this.restElements = [];
      }
      Identifier(pattern) {
        const lastRestElement = getLast(this.restElements);
        this.callback(pattern, {
          topLevel: pattern === this.rootPattern,
          rest: lastRestElement !== null && lastRestElement !== void 0 && lastRestElement.argument === pattern,
          assignments: this.assignments
        });
      }
      Property(property) {
        if (property.computed) {
          this.rightHandNodes.push(property.key);
        }
        this.visit(property.value);
      }
      ArrayPattern(pattern) {
        for (let i = 0, iz = pattern.elements.length; i < iz; ++i) {
          const element = pattern.elements[i];
          this.visit(element);
        }
      }
      AssignmentPattern(pattern) {
        this.assignments.push(pattern);
        this.visit(pattern.left);
        this.rightHandNodes.push(pattern.right);
        this.assignments.pop();
      }
      RestElement(pattern) {
        this.restElements.push(pattern);
        this.visit(pattern.argument);
        this.restElements.pop();
      }
      MemberExpression(node) {
        if (node.computed) {
          this.rightHandNodes.push(node.property);
        }
        this.rightHandNodes.push(node.object);
      }
      //
      // ForInStatement.left and AssignmentExpression.left are LeftHandSideExpression.
      // By spec, LeftHandSideExpression is Pattern or MemberExpression.
      //   (see also: https://github.com/estree/estree/pull/20#issuecomment-74584758)
      // But espree 2.0 parses to ArrayExpression, ObjectExpression, etc...
      //
      SpreadElement(node) {
        this.visit(node.argument);
      }
      ArrayExpression(node) {
        node.elements.forEach(this.visit, this);
      }
      AssignmentExpression(node) {
        this.assignments.push(node);
        this.visit(node.left);
        this.rightHandNodes.push(node.right);
        this.assignments.pop();
      }
      CallExpression(node) {
        node.arguments.forEach((a) => {
          this.rightHandNodes.push(a);
        });
        this.visit(node.callee);
      }
    };
    var { Syntax } = estraverse__default["default"];
    function traverseIdentifierInPattern(options, rootPattern, referencer, callback) {
      const visitor = new PatternVisitor(options, rootPattern, callback);
      visitor.visit(rootPattern);
      if (referencer !== null && referencer !== void 0) {
        visitor.rightHandNodes.forEach(referencer.visit, referencer);
      }
    }
    var Importer = class extends esrecurse__default["default"].Visitor {
      constructor(declaration, referencer) {
        super(null, referencer.options);
        this.declaration = declaration;
        this.referencer = referencer;
      }
      visitImport(id, specifier) {
        this.referencer.visitPattern(id, (pattern) => {
          this.referencer.currentScope().__define(
            pattern,
            new Definition(
              Variable.ImportBinding,
              pattern,
              specifier,
              this.declaration,
              null,
              null
            )
          );
        });
      }
      ImportNamespaceSpecifier(node) {
        const local = node.local || node.id;
        if (local) {
          this.visitImport(local, node);
        }
      }
      ImportDefaultSpecifier(node) {
        const local = node.local || node.id;
        this.visitImport(local, node);
      }
      ImportSpecifier(node) {
        const local = node.local || node.id;
        if (node.name) {
          this.visitImport(node.name, node);
        } else {
          this.visitImport(local, node);
        }
      }
    };
    var Referencer = class extends esrecurse__default["default"].Visitor {
      constructor(options, scopeManager) {
        super(null, options);
        this.options = options;
        this.scopeManager = scopeManager;
        this.parent = null;
        this.isInnerMethodDefinition = false;
      }
      currentScope() {
        return this.scopeManager.__currentScope;
      }
      close(node) {
        while (this.currentScope() && node === this.currentScope().block) {
          this.scopeManager.__currentScope = this.currentScope().__close(this.scopeManager);
        }
      }
      pushInnerMethodDefinition(isInnerMethodDefinition) {
        const previous = this.isInnerMethodDefinition;
        this.isInnerMethodDefinition = isInnerMethodDefinition;
        return previous;
      }
      popInnerMethodDefinition(isInnerMethodDefinition) {
        this.isInnerMethodDefinition = isInnerMethodDefinition;
      }
      referencingDefaultValue(pattern, assignments, maybeImplicitGlobal, init) {
        const scope = this.currentScope();
        assignments.forEach((assignment) => {
          scope.__referencing(
            pattern,
            Reference.WRITE,
            assignment.right,
            maybeImplicitGlobal,
            pattern !== assignment.left,
            init
          );
        });
      }
      visitPattern(node, options, callback) {
        let visitPatternOptions = options;
        let visitPatternCallback = callback;
        if (typeof options === "function") {
          visitPatternCallback = options;
          visitPatternOptions = { processRightHandNodes: false };
        }
        traverseIdentifierInPattern(
          this.options,
          node,
          visitPatternOptions.processRightHandNodes ? this : null,
          visitPatternCallback
        );
      }
      visitFunction(node) {
        let i, iz;
        if (node.type === Syntax.FunctionDeclaration) {
          this.currentScope().__define(
            node.id,
            new Definition(
              Variable.FunctionName,
              node.id,
              node,
              null,
              null,
              null
            )
          );
        }
        if (node.type === Syntax.FunctionExpression && node.id) {
          this.scopeManager.__nestFunctionExpressionNameScope(node);
        }
        this.scopeManager.__nestFunctionScope(node, this.isInnerMethodDefinition);
        const that = this;
        function visitPatternCallback(pattern, info) {
          that.currentScope().__define(
            pattern,
            new ParameterDefinition(
              pattern,
              node,
              i,
              info.rest
            )
          );
          that.referencingDefaultValue(pattern, info.assignments, null, true);
        }
        for (i = 0, iz = node.params.length; i < iz; ++i) {
          this.visitPattern(node.params[i], { processRightHandNodes: true }, visitPatternCallback);
        }
        if (node.rest) {
          this.visitPattern({
            type: "RestElement",
            argument: node.rest
          }, (pattern) => {
            this.currentScope().__define(
              pattern,
              new ParameterDefinition(
                pattern,
                node,
                node.params.length,
                true
              )
            );
          });
        }
        if (node.body) {
          if (node.body.type === Syntax.BlockStatement) {
            this.visitChildren(node.body);
          } else {
            this.visit(node.body);
          }
        }
        this.close(node);
      }
      visitClass(node) {
        if (node.type === Syntax.ClassDeclaration) {
          this.currentScope().__define(
            node.id,
            new Definition(
              Variable.ClassName,
              node.id,
              node,
              null,
              null,
              null
            )
          );
        }
        this.visit(node.superClass);
        this.scopeManager.__nestClassScope(node);
        if (node.id) {
          this.currentScope().__define(
            node.id,
            new Definition(
              Variable.ClassName,
              node.id,
              node
            )
          );
        }
        this.visit(node.body);
        this.close(node);
      }
      visitProperty(node) {
        let previous;
        if (node.computed) {
          this.visit(node.key);
        }
        const isMethodDefinition = node.type === Syntax.MethodDefinition;
        if (isMethodDefinition) {
          previous = this.pushInnerMethodDefinition(true);
        }
        this.visit(node.value);
        if (isMethodDefinition) {
          this.popInnerMethodDefinition(previous);
        }
      }
      visitForIn(node) {
        if (node.left.type === Syntax.VariableDeclaration && node.left.kind !== "var") {
          this.scopeManager.__nestForScope(node);
        }
        if (node.left.type === Syntax.VariableDeclaration) {
          this.visit(node.left);
          this.visitPattern(node.left.declarations[0].id, (pattern) => {
            this.currentScope().__referencing(pattern, Reference.WRITE, node.right, null, true, true);
          });
        } else {
          this.visitPattern(node.left, { processRightHandNodes: true }, (pattern, info) => {
            let maybeImplicitGlobal = null;
            if (!this.currentScope().isStrict) {
              maybeImplicitGlobal = {
                pattern,
                node
              };
            }
            this.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, false);
            this.currentScope().__referencing(pattern, Reference.WRITE, node.right, maybeImplicitGlobal, true, false);
          });
        }
        this.visit(node.right);
        this.visit(node.body);
        this.close(node);
      }
      visitVariableDeclaration(variableTargetScope, type, node, index) {
        const decl = node.declarations[index];
        const init = decl.init;
        this.visitPattern(decl.id, { processRightHandNodes: true }, (pattern, info) => {
          variableTargetScope.__define(
            pattern,
            new Definition(
              type,
              pattern,
              decl,
              node,
              index,
              node.kind
            )
          );
          this.referencingDefaultValue(pattern, info.assignments, null, true);
          if (init) {
            this.currentScope().__referencing(pattern, Reference.WRITE, init, null, !info.topLevel, true);
          }
        });
      }
      AssignmentExpression(node) {
        if (PatternVisitor.isPattern(node.left)) {
          if (node.operator === "=") {
            this.visitPattern(node.left, { processRightHandNodes: true }, (pattern, info) => {
              let maybeImplicitGlobal = null;
              if (!this.currentScope().isStrict) {
                maybeImplicitGlobal = {
                  pattern,
                  node
                };
              }
              this.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, false);
              this.currentScope().__referencing(pattern, Reference.WRITE, node.right, maybeImplicitGlobal, !info.topLevel, false);
            });
          } else {
            this.currentScope().__referencing(node.left, Reference.RW, node.right);
          }
        } else {
          this.visit(node.left);
        }
        this.visit(node.right);
      }
      CatchClause(node) {
        this.scopeManager.__nestCatchScope(node);
        this.visitPattern(node.param, { processRightHandNodes: true }, (pattern, info) => {
          this.currentScope().__define(
            pattern,
            new Definition(
              Variable.CatchClause,
              node.param,
              node,
              null,
              null,
              null
            )
          );
          this.referencingDefaultValue(pattern, info.assignments, null, true);
        });
        this.visit(node.body);
        this.close(node);
      }
      Program(node) {
        this.scopeManager.__nestGlobalScope(node);
        if (this.scopeManager.isGlobalReturn()) {
          this.currentScope().isStrict = false;
          this.scopeManager.__nestFunctionScope(node, false);
        }
        if (this.scopeManager.__isES6() && this.scopeManager.isModule()) {
          this.scopeManager.__nestModuleScope(node);
        }
        if (this.scopeManager.isStrictModeSupported() && this.scopeManager.isImpliedStrict()) {
          this.currentScope().isStrict = true;
        }
        this.visitChildren(node);
        this.close(node);
      }
      Identifier(node) {
        this.currentScope().__referencing(node);
      }
      // eslint-disable-next-line class-methods-use-this
      PrivateIdentifier() {
      }
      UpdateExpression(node) {
        if (PatternVisitor.isPattern(node.argument)) {
          this.currentScope().__referencing(node.argument, Reference.RW, null);
        } else {
          this.visitChildren(node);
        }
      }
      MemberExpression(node) {
        this.visit(node.object);
        if (node.computed) {
          this.visit(node.property);
        }
      }
      Property(node) {
        this.visitProperty(node);
      }
      PropertyDefinition(node) {
        const { computed, key, value } = node;
        if (computed) {
          this.visit(key);
        }
        if (value) {
          this.scopeManager.__nestClassFieldInitializerScope(value);
          this.visit(value);
          this.close(value);
        }
      }
      StaticBlock(node) {
        this.scopeManager.__nestClassStaticBlockScope(node);
        this.visitChildren(node);
        this.close(node);
      }
      MethodDefinition(node) {
        this.visitProperty(node);
      }
      BreakStatement() {
      }
      // eslint-disable-line class-methods-use-this
      ContinueStatement() {
      }
      // eslint-disable-line class-methods-use-this
      LabeledStatement(node) {
        this.visit(node.body);
      }
      ForStatement(node) {
        if (node.init && node.init.type === Syntax.VariableDeclaration && node.init.kind !== "var") {
          this.scopeManager.__nestForScope(node);
        }
        this.visitChildren(node);
        this.close(node);
      }
      ClassExpression(node) {
        this.visitClass(node);
      }
      ClassDeclaration(node) {
        this.visitClass(node);
      }
      CallExpression(node) {
        if (!this.scopeManager.__ignoreEval() && node.callee.type === Syntax.Identifier && node.callee.name === "eval") {
          this.currentScope().variableScope.__detectEval();
        }
        this.visitChildren(node);
      }
      BlockStatement(node) {
        if (this.scopeManager.__isES6()) {
          this.scopeManager.__nestBlockScope(node);
        }
        this.visitChildren(node);
        this.close(node);
      }
      ThisExpression() {
        this.currentScope().variableScope.__detectThis();
      }
      WithStatement(node) {
        this.visit(node.object);
        this.scopeManager.__nestWithScope(node);
        this.visit(node.body);
        this.close(node);
      }
      VariableDeclaration(node) {
        const variableTargetScope = node.kind === "var" ? this.currentScope().variableScope : this.currentScope();
        for (let i = 0, iz = node.declarations.length; i < iz; ++i) {
          const decl = node.declarations[i];
          this.visitVariableDeclaration(variableTargetScope, Variable.Variable, node, i);
          if (decl.init) {
            this.visit(decl.init);
          }
        }
      }
      // sec 13.11.8
      SwitchStatement(node) {
        this.visit(node.discriminant);
        if (this.scopeManager.__isES6()) {
          this.scopeManager.__nestSwitchScope(node);
        }
        for (let i = 0, iz = node.cases.length; i < iz; ++i) {
          this.visit(node.cases[i]);
        }
        this.close(node);
      }
      FunctionDeclaration(node) {
        this.visitFunction(node);
      }
      FunctionExpression(node) {
        this.visitFunction(node);
      }
      ForOfStatement(node) {
        this.visitForIn(node);
      }
      ForInStatement(node) {
        this.visitForIn(node);
      }
      ArrowFunctionExpression(node) {
        this.visitFunction(node);
      }
      ImportDeclaration(node) {
        assert__default["default"](this.scopeManager.__isES6() && this.scopeManager.isModule(), "ImportDeclaration should appear when the mode is ES6 and in the module context.");
        const importer = new Importer(node, this);
        importer.visit(node);
      }
      visitExportDeclaration(node) {
        if (node.source) {
          return;
        }
        if (node.declaration) {
          this.visit(node.declaration);
          return;
        }
        this.visitChildren(node);
      }
      // TODO: ExportDeclaration doesn't exist. for bc?
      ExportDeclaration(node) {
        this.visitExportDeclaration(node);
      }
      ExportAllDeclaration(node) {
        this.visitExportDeclaration(node);
      }
      ExportDefaultDeclaration(node) {
        this.visitExportDeclaration(node);
      }
      ExportNamedDeclaration(node) {
        this.visitExportDeclaration(node);
      }
      ExportSpecifier(node) {
        const local = node.id || node.local;
        this.visit(local);
      }
      MetaProperty() {
      }
    };
    var version = "7.2.1";
    function defaultOptions() {
      return {
        optimistic: false,
        directive: false,
        nodejsScope: false,
        impliedStrict: false,
        sourceType: "script",
        // one of ['script', 'module', 'commonjs']
        ecmaVersion: 5,
        childVisitorKeys: null,
        fallback: "iteration"
      };
    }
    function updateDeeply(target, override) {
      function isHashObject(value) {
        return typeof value === "object" && value instanceof Object && !(value instanceof Array) && !(value instanceof RegExp);
      }
      for (const key in override) {
        if (Object.prototype.hasOwnProperty.call(override, key)) {
          const val = override[key];
          if (isHashObject(val)) {
            if (isHashObject(target[key])) {
              updateDeeply(target[key], val);
            } else {
              target[key] = updateDeeply({}, val);
            }
          } else {
            target[key] = val;
          }
        }
      }
      return target;
    }
    function analyze(tree, providedOptions) {
      const options = updateDeeply(defaultOptions(), providedOptions);
      const scopeManager = new ScopeManager(options);
      const referencer = new Referencer(options, scopeManager);
      referencer.visit(tree);
      assert__default["default"](scopeManager.__currentScope === null, "currentScope should be null.");
      return scopeManager;
    }
    exports.Definition = Definition;
    exports.PatternVisitor = PatternVisitor;
    exports.Reference = Reference;
    exports.Referencer = Referencer;
    exports.Scope = Scope;
    exports.ScopeManager = ScopeManager;
    exports.Variable = Variable;
    exports.analyze = analyze;
    exports.version = version;
  }
});

// ../../node_modules/eslint-visitor-keys/dist/eslint-visitor-keys.cjs
var require_eslint_visitor_keys = __commonJS({
  "../../node_modules/eslint-visitor-keys/dist/eslint-visitor-keys.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var KEYS = {
      ArrayExpression: [
        "elements"
      ],
      ArrayPattern: [
        "elements"
      ],
      ArrowFunctionExpression: [
        "params",
        "body"
      ],
      AssignmentExpression: [
        "left",
        "right"
      ],
      AssignmentPattern: [
        "left",
        "right"
      ],
      AwaitExpression: [
        "argument"
      ],
      BinaryExpression: [
        "left",
        "right"
      ],
      BlockStatement: [
        "body"
      ],
      BreakStatement: [
        "label"
      ],
      CallExpression: [
        "callee",
        "arguments"
      ],
      CatchClause: [
        "param",
        "body"
      ],
      ChainExpression: [
        "expression"
      ],
      ClassBody: [
        "body"
      ],
      ClassDeclaration: [
        "id",
        "superClass",
        "body"
      ],
      ClassExpression: [
        "id",
        "superClass",
        "body"
      ],
      ConditionalExpression: [
        "test",
        "consequent",
        "alternate"
      ],
      ContinueStatement: [
        "label"
      ],
      DebuggerStatement: [],
      DoWhileStatement: [
        "body",
        "test"
      ],
      EmptyStatement: [],
      ExperimentalRestProperty: [
        "argument"
      ],
      ExperimentalSpreadProperty: [
        "argument"
      ],
      ExportAllDeclaration: [
        "exported",
        "source"
      ],
      ExportDefaultDeclaration: [
        "declaration"
      ],
      ExportNamedDeclaration: [
        "declaration",
        "specifiers",
        "source"
      ],
      ExportSpecifier: [
        "exported",
        "local"
      ],
      ExpressionStatement: [
        "expression"
      ],
      ForInStatement: [
        "left",
        "right",
        "body"
      ],
      ForOfStatement: [
        "left",
        "right",
        "body"
      ],
      ForStatement: [
        "init",
        "test",
        "update",
        "body"
      ],
      FunctionDeclaration: [
        "id",
        "params",
        "body"
      ],
      FunctionExpression: [
        "id",
        "params",
        "body"
      ],
      Identifier: [],
      IfStatement: [
        "test",
        "consequent",
        "alternate"
      ],
      ImportDeclaration: [
        "specifiers",
        "source"
      ],
      ImportDefaultSpecifier: [
        "local"
      ],
      ImportExpression: [
        "source"
      ],
      ImportNamespaceSpecifier: [
        "local"
      ],
      ImportSpecifier: [
        "imported",
        "local"
      ],
      JSXAttribute: [
        "name",
        "value"
      ],
      JSXClosingElement: [
        "name"
      ],
      JSXClosingFragment: [],
      JSXElement: [
        "openingElement",
        "children",
        "closingElement"
      ],
      JSXEmptyExpression: [],
      JSXExpressionContainer: [
        "expression"
      ],
      JSXFragment: [
        "openingFragment",
        "children",
        "closingFragment"
      ],
      JSXIdentifier: [],
      JSXMemberExpression: [
        "object",
        "property"
      ],
      JSXNamespacedName: [
        "namespace",
        "name"
      ],
      JSXOpeningElement: [
        "name",
        "attributes"
      ],
      JSXOpeningFragment: [],
      JSXSpreadAttribute: [
        "argument"
      ],
      JSXSpreadChild: [
        "expression"
      ],
      JSXText: [],
      LabeledStatement: [
        "label",
        "body"
      ],
      Literal: [],
      LogicalExpression: [
        "left",
        "right"
      ],
      MemberExpression: [
        "object",
        "property"
      ],
      MetaProperty: [
        "meta",
        "property"
      ],
      MethodDefinition: [
        "key",
        "value"
      ],
      NewExpression: [
        "callee",
        "arguments"
      ],
      ObjectExpression: [
        "properties"
      ],
      ObjectPattern: [
        "properties"
      ],
      PrivateIdentifier: [],
      Program: [
        "body"
      ],
      Property: [
        "key",
        "value"
      ],
      PropertyDefinition: [
        "key",
        "value"
      ],
      RestElement: [
        "argument"
      ],
      ReturnStatement: [
        "argument"
      ],
      SequenceExpression: [
        "expressions"
      ],
      SpreadElement: [
        "argument"
      ],
      StaticBlock: [
        "body"
      ],
      Super: [],
      SwitchCase: [
        "test",
        "consequent"
      ],
      SwitchStatement: [
        "discriminant",
        "cases"
      ],
      TaggedTemplateExpression: [
        "tag",
        "quasi"
      ],
      TemplateElement: [],
      TemplateLiteral: [
        "quasis",
        "expressions"
      ],
      ThisExpression: [],
      ThrowStatement: [
        "argument"
      ],
      TryStatement: [
        "block",
        "handler",
        "finalizer"
      ],
      UnaryExpression: [
        "argument"
      ],
      UpdateExpression: [
        "argument"
      ],
      VariableDeclaration: [
        "declarations"
      ],
      VariableDeclarator: [
        "id",
        "init"
      ],
      WhileStatement: [
        "test",
        "body"
      ],
      WithStatement: [
        "object",
        "body"
      ],
      YieldExpression: [
        "argument"
      ]
    };
    var NODE_TYPES = Object.keys(KEYS);
    for (const type of NODE_TYPES) {
      Object.freeze(KEYS[type]);
    }
    Object.freeze(KEYS);
    var KEY_BLACKLIST = /* @__PURE__ */ new Set([
      "parent",
      "leadingComments",
      "trailingComments"
    ]);
    function filterKey(key) {
      return !KEY_BLACKLIST.has(key) && key[0] !== "_";
    }
    function getKeys(node) {
      return Object.keys(node).filter(filterKey);
    }
    function unionWith(additionalKeys) {
      const retv = (
        /** @type {{
            [type: string]: ReadonlyArray<string>
        }} */
        Object.assign({}, KEYS)
      );
      for (const type of Object.keys(additionalKeys)) {
        if (Object.prototype.hasOwnProperty.call(retv, type)) {
          const keys = new Set(additionalKeys[type]);
          for (const key of retv[type]) {
            keys.add(key);
          }
          retv[type] = Object.freeze(Array.from(keys));
        } else {
          retv[type] = Object.freeze(Array.from(additionalKeys[type]));
        }
      }
      return Object.freeze(retv);
    }
    exports.KEYS = KEYS;
    exports.getKeys = getKeys;
    exports.unionWith = unionWith;
  }
});

// ../../node_modules/acorn/dist/acorn.js
var require_acorn = __commonJS({
  "../../node_modules/acorn/dist/acorn.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.acorn = {}));
    })(exports, function(exports2) {
      "use strict";
      var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
      var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191];
      var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
      var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
      var reservedWords = {
        3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
        5: "class enum extends super const export import",
        6: "enum",
        strict: "implements interface let package private protected public static yield",
        strictBind: "eval arguments"
      };
      var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
      var keywords$1 = {
        5: ecma5AndLessKeywords,
        "5module": ecma5AndLessKeywords + " export import",
        6: ecma5AndLessKeywords + " const class extends export import super"
      };
      var keywordRelationalOperator = /^in(stanceof)?$/;
      var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
      var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
      function isInAstralSet(code, set) {
        var pos = 65536;
        for (var i2 = 0; i2 < set.length; i2 += 2) {
          pos += set[i2];
          if (pos > code) {
            return false;
          }
          pos += set[i2 + 1];
          if (pos >= code) {
            return true;
          }
        }
        return false;
      }
      function isIdentifierStart(code, astral) {
        if (code < 65) {
          return code === 36;
        }
        if (code < 91) {
          return true;
        }
        if (code < 97) {
          return code === 95;
        }
        if (code < 123) {
          return true;
        }
        if (code <= 65535) {
          return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
        }
        if (astral === false) {
          return false;
        }
        return isInAstralSet(code, astralIdentifierStartCodes);
      }
      function isIdentifierChar(code, astral) {
        if (code < 48) {
          return code === 36;
        }
        if (code < 58) {
          return true;
        }
        if (code < 65) {
          return false;
        }
        if (code < 91) {
          return true;
        }
        if (code < 97) {
          return code === 95;
        }
        if (code < 123) {
          return true;
        }
        if (code <= 65535) {
          return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
        }
        if (astral === false) {
          return false;
        }
        return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
      }
      var TokenType = function TokenType2(label, conf) {
        if (conf === void 0)
          conf = {};
        this.label = label;
        this.keyword = conf.keyword;
        this.beforeExpr = !!conf.beforeExpr;
        this.startsExpr = !!conf.startsExpr;
        this.isLoop = !!conf.isLoop;
        this.isAssign = !!conf.isAssign;
        this.prefix = !!conf.prefix;
        this.postfix = !!conf.postfix;
        this.binop = conf.binop || null;
        this.updateContext = null;
      };
      function binop(name, prec) {
        return new TokenType(name, { beforeExpr: true, binop: prec });
      }
      var beforeExpr = { beforeExpr: true }, startsExpr = { startsExpr: true };
      var keywords = {};
      function kw(name, options) {
        if (options === void 0)
          options = {};
        options.keyword = name;
        return keywords[name] = new TokenType(name, options);
      }
      var types$1 = {
        num: new TokenType("num", startsExpr),
        regexp: new TokenType("regexp", startsExpr),
        string: new TokenType("string", startsExpr),
        name: new TokenType("name", startsExpr),
        privateId: new TokenType("privateId", startsExpr),
        eof: new TokenType("eof"),
        // Punctuation token types.
        bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
        bracketR: new TokenType("]"),
        braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
        braceR: new TokenType("}"),
        parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
        parenR: new TokenType(")"),
        comma: new TokenType(",", beforeExpr),
        semi: new TokenType(";", beforeExpr),
        colon: new TokenType(":", beforeExpr),
        dot: new TokenType("."),
        question: new TokenType("?", beforeExpr),
        questionDot: new TokenType("?."),
        arrow: new TokenType("=>", beforeExpr),
        template: new TokenType("template"),
        invalidTemplate: new TokenType("invalidTemplate"),
        ellipsis: new TokenType("...", beforeExpr),
        backQuote: new TokenType("`", startsExpr),
        dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
        // Operators. These carry several kinds of properties to help the
        // parser use them properly (the presence of these properties is
        // what categorizes them as operators).
        //
        // `binop`, when present, specifies that this operator is a binary
        // operator, and will refer to its precedence.
        //
        // `prefix` and `postfix` mark the operator as a prefix or postfix
        // unary operator.
        //
        // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
        // binary operators with a very low precedence, that should result
        // in AssignmentExpression nodes.
        eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
        assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
        incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
        prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
        logicalOR: binop("||", 1),
        logicalAND: binop("&&", 2),
        bitwiseOR: binop("|", 3),
        bitwiseXOR: binop("^", 4),
        bitwiseAND: binop("&", 5),
        equality: binop("==/!=/===/!==", 6),
        relational: binop("</>/<=/>=", 7),
        bitShift: binop("<</>>/>>>", 8),
        plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
        modulo: binop("%", 10),
        star: binop("*", 10),
        slash: binop("/", 10),
        starstar: new TokenType("**", { beforeExpr: true }),
        coalesce: binop("??", 1),
        // Keyword token types.
        _break: kw("break"),
        _case: kw("case", beforeExpr),
        _catch: kw("catch"),
        _continue: kw("continue"),
        _debugger: kw("debugger"),
        _default: kw("default", beforeExpr),
        _do: kw("do", { isLoop: true, beforeExpr: true }),
        _else: kw("else", beforeExpr),
        _finally: kw("finally"),
        _for: kw("for", { isLoop: true }),
        _function: kw("function", startsExpr),
        _if: kw("if"),
        _return: kw("return", beforeExpr),
        _switch: kw("switch"),
        _throw: kw("throw", beforeExpr),
        _try: kw("try"),
        _var: kw("var"),
        _const: kw("const"),
        _while: kw("while", { isLoop: true }),
        _with: kw("with"),
        _new: kw("new", { beforeExpr: true, startsExpr: true }),
        _this: kw("this", startsExpr),
        _super: kw("super", startsExpr),
        _class: kw("class", startsExpr),
        _extends: kw("extends", beforeExpr),
        _export: kw("export"),
        _import: kw("import", startsExpr),
        _null: kw("null", startsExpr),
        _true: kw("true", startsExpr),
        _false: kw("false", startsExpr),
        _in: kw("in", { beforeExpr: true, binop: 7 }),
        _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
        _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
        _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
        _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
      };
      var lineBreak = /\r\n?|\n|\u2028|\u2029/;
      var lineBreakG = new RegExp(lineBreak.source, "g");
      function isNewLine(code) {
        return code === 10 || code === 13 || code === 8232 || code === 8233;
      }
      function nextLineBreak(code, from, end) {
        if (end === void 0)
          end = code.length;
        for (var i2 = from; i2 < end; i2++) {
          var next = code.charCodeAt(i2);
          if (isNewLine(next)) {
            return i2 < end - 1 && next === 13 && code.charCodeAt(i2 + 1) === 10 ? i2 + 2 : i2 + 1;
          }
        }
        return -1;
      }
      var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
      var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
      var ref = Object.prototype;
      var hasOwnProperty = ref.hasOwnProperty;
      var toString = ref.toString;
      var hasOwn = Object.hasOwn || function(obj, propName) {
        return hasOwnProperty.call(obj, propName);
      };
      var isArray = Array.isArray || function(obj) {
        return toString.call(obj) === "[object Array]";
      };
      function wordsRegexp(words) {
        return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$");
      }
      function codePointToString(code) {
        if (code <= 65535) {
          return String.fromCharCode(code);
        }
        code -= 65536;
        return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
      }
      var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
      var Position = function Position2(line, col) {
        this.line = line;
        this.column = col;
      };
      Position.prototype.offset = function offset(n) {
        return new Position(this.line, this.column + n);
      };
      var SourceLocation = function SourceLocation2(p, start, end) {
        this.start = start;
        this.end = end;
        if (p.sourceFile !== null) {
          this.source = p.sourceFile;
        }
      };
      function getLineInfo(input, offset) {
        for (var line = 1, cur = 0; ; ) {
          var nextBreak = nextLineBreak(input, cur, offset);
          if (nextBreak < 0) {
            return new Position(line, offset - cur);
          }
          ++line;
          cur = nextBreak;
        }
      }
      var defaultOptions = {
        // `ecmaVersion` indicates the ECMAScript version to parse. Must be
        // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
        // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
        // (the latest version the library supports). This influences
        // support for strict mode, the set of reserved words, and support
        // for new syntax features.
        ecmaVersion: null,
        // `sourceType` indicates the mode the code should be parsed in.
        // Can be either `"script"` or `"module"`. This influences global
        // strict mode and parsing of `import` and `export` declarations.
        sourceType: "script",
        // `onInsertedSemicolon` can be a callback that will be called
        // when a semicolon is automatically inserted. It will be passed
        // the position of the comma as an offset, and if `locations` is
        // enabled, it is given the location as a `{line, column}` object
        // as second argument.
        onInsertedSemicolon: null,
        // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
        // trailing commas.
        onTrailingComma: null,
        // By default, reserved words are only enforced if ecmaVersion >= 5.
        // Set `allowReserved` to a boolean value to explicitly turn this on
        // an off. When this option has the value "never", reserved words
        // and keywords can also not be used as property names.
        allowReserved: null,
        // When enabled, a return at the top level is not considered an
        // error.
        allowReturnOutsideFunction: false,
        // When enabled, import/export statements are not constrained to
        // appearing at the top of the program, and an import.meta expression
        // in a script isn't considered an error.
        allowImportExportEverywhere: false,
        // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
        // When enabled, await identifiers are allowed to appear at the top-level scope,
        // but they are still not allowed in non-async functions.
        allowAwaitOutsideFunction: null,
        // When enabled, super identifiers are not constrained to
        // appearing in methods and do not raise an error when they appear elsewhere.
        allowSuperOutsideMethod: null,
        // When enabled, hashbang directive in the beginning of file is
        // allowed and treated as a line comment. Enabled by default when
        // `ecmaVersion` >= 2023.
        allowHashBang: false,
        // By default, the parser will verify that private properties are
        // only used in places where they are valid and have been declared.
        // Set this to false to turn such checks off.
        checkPrivateFields: true,
        // When `locations` is on, `loc` properties holding objects with
        // `start` and `end` properties in `{line, column}` form (with
        // line being 1-based and column 0-based) will be attached to the
        // nodes.
        locations: false,
        // A function can be passed as `onToken` option, which will
        // cause Acorn to call that function with object in the same
        // format as tokens returned from `tokenizer().getToken()`. Note
        // that you are not allowed to call the parser from the
        // callbackthat will corrupt its internal state.
        onToken: null,
        // A function can be passed as `onComment` option, which will
        // cause Acorn to call that function with `(block, text, start,
        // end)` parameters whenever a comment is skipped. `block` is a
        // boolean indicating whether this is a block (`/* */`) comment,
        // `text` is the content of the comment, and `start` and `end` are
        // character offsets that denote the start and end of the comment.
        // When the `locations` option is on, two more parameters are
        // passed, the full `{line, column}` locations of the start and
        // end of the comments. Note that you are not allowed to call the
        // parser from the callbackthat will corrupt its internal state.
        onComment: null,
        // Nodes have their start and end characters offsets recorded in
        // `start` and `end` properties (directly on the node, rather than
        // the `loc` object, which holds line/column data. To also add a
        // [semi-standardized][range] `range` property holding a `[start,
        // end]` array with the same numbers, set the `ranges` option to
        // `true`.
        //
        // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
        ranges: false,
        // It is possible to parse multiple files into a single AST by
        // passing the tree produced by parsing the first file as
        // `program` option in subsequent parses. This will add the
        // toplevel forms of the parsed file to the `Program` (top) node
        // of an existing parse tree.
        program: null,
        // When `locations` is on, you can pass this to record the source
        // file in every node's `loc` object.
        sourceFile: null,
        // This value, if given, is stored in every node, whether
        // `locations` is on or off.
        directSourceFile: null,
        // When enabled, parenthesized expressions are represented by
        // (non-standard) ParenthesizedExpression nodes
        preserveParens: false
      };
      var warnedAboutEcmaVersion = false;
      function getOptions(opts) {
        var options = {};
        for (var opt in defaultOptions) {
          options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
        }
        if (options.ecmaVersion === "latest") {
          options.ecmaVersion = 1e8;
        } else if (options.ecmaVersion == null) {
          if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
            warnedAboutEcmaVersion = true;
            console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
          }
          options.ecmaVersion = 11;
        } else if (options.ecmaVersion >= 2015) {
          options.ecmaVersion -= 2009;
        }
        if (options.allowReserved == null) {
          options.allowReserved = options.ecmaVersion < 5;
        }
        if (!opts || opts.allowHashBang == null) {
          options.allowHashBang = options.ecmaVersion >= 14;
        }
        if (isArray(options.onToken)) {
          var tokens = options.onToken;
          options.onToken = function(token) {
            return tokens.push(token);
          };
        }
        if (isArray(options.onComment)) {
          options.onComment = pushComment(options, options.onComment);
        }
        return options;
      }
      function pushComment(options, array) {
        return function(block, text, start, end, startLoc, endLoc) {
          var comment = {
            type: block ? "Block" : "Line",
            value: text,
            start,
            end
          };
          if (options.locations) {
            comment.loc = new SourceLocation(this, startLoc, endLoc);
          }
          if (options.ranges) {
            comment.range = [start, end];
          }
          array.push(comment);
        };
      }
      var SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128, SCOPE_CLASS_STATIC_BLOCK = 256, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
      function functionFlags(async, generator) {
        return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
      }
      var BIND_NONE = 0, BIND_VAR = 1, BIND_LEXICAL = 2, BIND_FUNCTION = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE = 5;
      var Parser = function Parser2(options, input, startPos) {
        this.options = options = getOptions(options);
        this.sourceFile = options.sourceFile;
        this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
        var reserved = "";
        if (options.allowReserved !== true) {
          reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
          if (options.sourceType === "module") {
            reserved += " await";
          }
        }
        this.reservedWords = wordsRegexp(reserved);
        var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
        this.reservedWordsStrict = wordsRegexp(reservedStrict);
        this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
        this.input = String(input);
        this.containsEsc = false;
        if (startPos) {
          this.pos = startPos;
          this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
          this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
        } else {
          this.pos = this.lineStart = 0;
          this.curLine = 1;
        }
        this.type = types$1.eof;
        this.value = null;
        this.start = this.end = this.pos;
        this.startLoc = this.endLoc = this.curPosition();
        this.lastTokEndLoc = this.lastTokStartLoc = null;
        this.lastTokStart = this.lastTokEnd = this.pos;
        this.context = this.initialContext();
        this.exprAllowed = true;
        this.inModule = options.sourceType === "module";
        this.strict = this.inModule || this.strictDirective(this.pos);
        this.potentialArrowAt = -1;
        this.potentialArrowInForAwait = false;
        this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
        this.labels = [];
        this.undefinedExports = /* @__PURE__ */ Object.create(null);
        if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
          this.skipLineComment(2);
        }
        this.scopeStack = [];
        this.enterScope(SCOPE_TOP);
        this.regexpState = null;
        this.privateNameStack = [];
      };
      var prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
      Parser.prototype.parse = function parse2() {
        var node = this.options.program || this.startNode();
        this.nextToken();
        return this.parseTopLevel(node);
      };
      prototypeAccessors.inFunction.get = function() {
        return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
      };
      prototypeAccessors.inGenerator.get = function() {
        return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;
      };
      prototypeAccessors.inAsync.get = function() {
        return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;
      };
      prototypeAccessors.canAwait.get = function() {
        for (var i2 = this.scopeStack.length - 1; i2 >= 0; i2--) {
          var scope = this.scopeStack[i2];
          if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) {
            return false;
          }
          if (scope.flags & SCOPE_FUNCTION) {
            return (scope.flags & SCOPE_ASYNC) > 0;
          }
        }
        return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
      };
      prototypeAccessors.allowSuper.get = function() {
        var ref2 = this.currentThisScope();
        var flags = ref2.flags;
        var inClassFieldInit = ref2.inClassFieldInit;
        return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
      };
      prototypeAccessors.allowDirectSuper.get = function() {
        return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
      };
      prototypeAccessors.treatFunctionsAsVar.get = function() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      };
      prototypeAccessors.allowNewDotTarget.get = function() {
        var ref2 = this.currentThisScope();
        var flags = ref2.flags;
        var inClassFieldInit = ref2.inClassFieldInit;
        return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit;
      };
      prototypeAccessors.inClassStaticBlock.get = function() {
        return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
      };
      Parser.extend = function extend() {
        var plugins = [], len = arguments.length;
        while (len--)
          plugins[len] = arguments[len];
        var cls = this;
        for (var i2 = 0; i2 < plugins.length; i2++) {
          cls = plugins[i2](cls);
        }
        return cls;
      };
      Parser.parse = function parse2(input, options) {
        return new this(options, input).parse();
      };
      Parser.parseExpressionAt = function parseExpressionAt2(input, pos, options) {
        var parser = new this(options, input, pos);
        parser.nextToken();
        return parser.parseExpression();
      };
      Parser.tokenizer = function tokenizer2(input, options) {
        return new this(options, input);
      };
      Object.defineProperties(Parser.prototype, prototypeAccessors);
      var pp$9 = Parser.prototype;
      var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
      pp$9.strictDirective = function(start) {
        if (this.options.ecmaVersion < 5) {
          return false;
        }
        for (; ; ) {
          skipWhiteSpace.lastIndex = start;
          start += skipWhiteSpace.exec(this.input)[0].length;
          var match = literal.exec(this.input.slice(start));
          if (!match) {
            return false;
          }
          if ((match[1] || match[2]) === "use strict") {
            skipWhiteSpace.lastIndex = start + match[0].length;
            var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
            var next = this.input.charAt(end);
            return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
          }
          start += match[0].length;
          skipWhiteSpace.lastIndex = start;
          start += skipWhiteSpace.exec(this.input)[0].length;
          if (this.input[start] === ";") {
            start++;
          }
        }
      };
      pp$9.eat = function(type) {
        if (this.type === type) {
          this.next();
          return true;
        } else {
          return false;
        }
      };
      pp$9.isContextual = function(name) {
        return this.type === types$1.name && this.value === name && !this.containsEsc;
      };
      pp$9.eatContextual = function(name) {
        if (!this.isContextual(name)) {
          return false;
        }
        this.next();
        return true;
      };
      pp$9.expectContextual = function(name) {
        if (!this.eatContextual(name)) {
          this.unexpected();
        }
      };
      pp$9.canInsertSemicolon = function() {
        return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
      };
      pp$9.insertSemicolon = function() {
        if (this.canInsertSemicolon()) {
          if (this.options.onInsertedSemicolon) {
            this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
          }
          return true;
        }
      };
      pp$9.semicolon = function() {
        if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
          this.unexpected();
        }
      };
      pp$9.afterTrailingComma = function(tokType, notNext) {
        if (this.type === tokType) {
          if (this.options.onTrailingComma) {
            this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
          }
          if (!notNext) {
            this.next();
          }
          return true;
        }
      };
      pp$9.expect = function(type) {
        this.eat(type) || this.unexpected();
      };
      pp$9.unexpected = function(pos) {
        this.raise(pos != null ? pos : this.start, "Unexpected token");
      };
      var DestructuringErrors = function DestructuringErrors2() {
        this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
      };
      pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
        if (!refDestructuringErrors) {
          return;
        }
        if (refDestructuringErrors.trailingComma > -1) {
          this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
        }
        var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
        if (parens > -1) {
          this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
        }
      };
      pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
        if (!refDestructuringErrors) {
          return false;
        }
        var shorthandAssign = refDestructuringErrors.shorthandAssign;
        var doubleProto = refDestructuringErrors.doubleProto;
        if (!andThrow) {
          return shorthandAssign >= 0 || doubleProto >= 0;
        }
        if (shorthandAssign >= 0) {
          this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
        }
        if (doubleProto >= 0) {
          this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
        }
      };
      pp$9.checkYieldAwaitInDefaultParams = function() {
        if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
          this.raise(this.yieldPos, "Yield expression cannot be a default value");
        }
        if (this.awaitPos) {
          this.raise(this.awaitPos, "Await expression cannot be a default value");
        }
      };
      pp$9.isSimpleAssignTarget = function(expr) {
        if (expr.type === "ParenthesizedExpression") {
          return this.isSimpleAssignTarget(expr.expression);
        }
        return expr.type === "Identifier" || expr.type === "MemberExpression";
      };
      var pp$8 = Parser.prototype;
      pp$8.parseTopLevel = function(node) {
        var exports3 = /* @__PURE__ */ Object.create(null);
        if (!node.body) {
          node.body = [];
        }
        while (this.type !== types$1.eof) {
          var stmt = this.parseStatement(null, true, exports3);
          node.body.push(stmt);
        }
        if (this.inModule) {
          for (var i2 = 0, list2 = Object.keys(this.undefinedExports); i2 < list2.length; i2 += 1) {
            var name = list2[i2];
            this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
          }
        }
        this.adaptDirectivePrologue(node.body);
        this.next();
        node.sourceType = this.options.sourceType;
        return this.finishNode(node, "Program");
      };
      var loopLabel = { kind: "loop" }, switchLabel = { kind: "switch" };
      pp$8.isLet = function(context) {
        if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
          return false;
        }
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 91 || nextCh === 92) {
          return true;
        }
        if (context) {
          return false;
        }
        if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
          return true;
        }
        if (isIdentifierStart(nextCh, true)) {
          var pos = next + 1;
          while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) {
            ++pos;
          }
          if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
            return true;
          }
          var ident = this.input.slice(next, pos);
          if (!keywordRelationalOperator.test(ident)) {
            return true;
          }
        }
        return false;
      };
      pp$8.isAsyncFunction = function() {
        if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
          return false;
        }
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, after;
        return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
      };
      pp$8.parseStatement = function(context, topLevel, exports3) {
        var starttype = this.type, node = this.startNode(), kind;
        if (this.isLet(context)) {
          starttype = types$1._var;
          kind = "let";
        }
        switch (starttype) {
          case types$1._break:
          case types$1._continue:
            return this.parseBreakContinueStatement(node, starttype.keyword);
          case types$1._debugger:
            return this.parseDebuggerStatement(node);
          case types$1._do:
            return this.parseDoStatement(node);
          case types$1._for:
            return this.parseForStatement(node);
          case types$1._function:
            if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
              this.unexpected();
            }
            return this.parseFunctionStatement(node, false, !context);
          case types$1._class:
            if (context) {
              this.unexpected();
            }
            return this.parseClass(node, true);
          case types$1._if:
            return this.parseIfStatement(node);
          case types$1._return:
            return this.parseReturnStatement(node);
          case types$1._switch:
            return this.parseSwitchStatement(node);
          case types$1._throw:
            return this.parseThrowStatement(node);
          case types$1._try:
            return this.parseTryStatement(node);
          case types$1._const:
          case types$1._var:
            kind = kind || this.value;
            if (context && kind !== "var") {
              this.unexpected();
            }
            return this.parseVarStatement(node, kind);
          case types$1._while:
            return this.parseWhileStatement(node);
          case types$1._with:
            return this.parseWithStatement(node);
          case types$1.braceL:
            return this.parseBlock(true, node);
          case types$1.semi:
            return this.parseEmptyStatement(node);
          case types$1._export:
          case types$1._import:
            if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
              skipWhiteSpace.lastIndex = this.pos;
              var skip = skipWhiteSpace.exec(this.input);
              var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
              if (nextCh === 40 || nextCh === 46) {
                return this.parseExpressionStatement(node, this.parseExpression());
              }
            }
            if (!this.options.allowImportExportEverywhere) {
              if (!topLevel) {
                this.raise(this.start, "'import' and 'export' may only appear at the top level");
              }
              if (!this.inModule) {
                this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
              }
            }
            return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports3);
          default:
            if (this.isAsyncFunction()) {
              if (context) {
                this.unexpected();
              }
              this.next();
              return this.parseFunctionStatement(node, true, !context);
            }
            var maybeName = this.value, expr = this.parseExpression();
            if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
              return this.parseLabeledStatement(node, maybeName, expr, context);
            } else {
              return this.parseExpressionStatement(node, expr);
            }
        }
      };
      pp$8.parseBreakContinueStatement = function(node, keyword) {
        var isBreak = keyword === "break";
        this.next();
        if (this.eat(types$1.semi) || this.insertSemicolon()) {
          node.label = null;
        } else if (this.type !== types$1.name) {
          this.unexpected();
        } else {
          node.label = this.parseIdent();
          this.semicolon();
        }
        var i2 = 0;
        for (; i2 < this.labels.length; ++i2) {
          var lab = this.labels[i2];
          if (node.label == null || lab.name === node.label.name) {
            if (lab.kind != null && (isBreak || lab.kind === "loop")) {
              break;
            }
            if (node.label && isBreak) {
              break;
            }
          }
        }
        if (i2 === this.labels.length) {
          this.raise(node.start, "Unsyntactic " + keyword);
        }
        return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
      };
      pp$8.parseDebuggerStatement = function(node) {
        this.next();
        this.semicolon();
        return this.finishNode(node, "DebuggerStatement");
      };
      pp$8.parseDoStatement = function(node) {
        this.next();
        this.labels.push(loopLabel);
        node.body = this.parseStatement("do");
        this.labels.pop();
        this.expect(types$1._while);
        node.test = this.parseParenExpression();
        if (this.options.ecmaVersion >= 6) {
          this.eat(types$1.semi);
        } else {
          this.semicolon();
        }
        return this.finishNode(node, "DoWhileStatement");
      };
      pp$8.parseForStatement = function(node) {
        this.next();
        var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
        this.labels.push(loopLabel);
        this.enterScope(0);
        this.expect(types$1.parenL);
        if (this.type === types$1.semi) {
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, null);
        }
        var isLet = this.isLet();
        if (this.type === types$1._var || this.type === types$1._const || isLet) {
          var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
          this.next();
          this.parseVar(init$1, true, kind);
          this.finishNode(init$1, "VariableDeclaration");
          if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
            if (this.options.ecmaVersion >= 9) {
              if (this.type === types$1._in) {
                if (awaitAt > -1) {
                  this.unexpected(awaitAt);
                }
              } else {
                node.await = awaitAt > -1;
              }
            }
            return this.parseForIn(node, init$1);
          }
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, init$1);
        }
        var startsWithLet = this.isContextual("let"), isForOf = false;
        var refDestructuringErrors = new DestructuringErrors();
        var init = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
        if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
          if (this.options.ecmaVersion >= 9) {
            if (this.type === types$1._in) {
              if (awaitAt > -1) {
                this.unexpected(awaitAt);
              }
            } else {
              node.await = awaitAt > -1;
            }
          }
          if (startsWithLet && isForOf) {
            this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
          }
          this.toAssignable(init, false, refDestructuringErrors);
          this.checkLValPattern(init);
          return this.parseForIn(node, init);
        } else {
          this.checkExpressionErrors(refDestructuringErrors, true);
        }
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node, init);
      };
      pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
        this.next();
        return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
      };
      pp$8.parseIfStatement = function(node) {
        this.next();
        node.test = this.parseParenExpression();
        node.consequent = this.parseStatement("if");
        node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
        return this.finishNode(node, "IfStatement");
      };
      pp$8.parseReturnStatement = function(node) {
        if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
          this.raise(this.start, "'return' outside of function");
        }
        this.next();
        if (this.eat(types$1.semi) || this.insertSemicolon()) {
          node.argument = null;
        } else {
          node.argument = this.parseExpression();
          this.semicolon();
        }
        return this.finishNode(node, "ReturnStatement");
      };
      pp$8.parseSwitchStatement = function(node) {
        this.next();
        node.discriminant = this.parseParenExpression();
        node.cases = [];
        this.expect(types$1.braceL);
        this.labels.push(switchLabel);
        this.enterScope(0);
        var cur;
        for (var sawDefault = false; this.type !== types$1.braceR; ) {
          if (this.type === types$1._case || this.type === types$1._default) {
            var isCase = this.type === types$1._case;
            if (cur) {
              this.finishNode(cur, "SwitchCase");
            }
            node.cases.push(cur = this.startNode());
            cur.consequent = [];
            this.next();
            if (isCase) {
              cur.test = this.parseExpression();
            } else {
              if (sawDefault) {
                this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
              }
              sawDefault = true;
              cur.test = null;
            }
            this.expect(types$1.colon);
          } else {
            if (!cur) {
              this.unexpected();
            }
            cur.consequent.push(this.parseStatement(null));
          }
        }
        this.exitScope();
        if (cur) {
          this.finishNode(cur, "SwitchCase");
        }
        this.next();
        this.labels.pop();
        return this.finishNode(node, "SwitchStatement");
      };
      pp$8.parseThrowStatement = function(node) {
        this.next();
        if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
          this.raise(this.lastTokEnd, "Illegal newline after throw");
        }
        node.argument = this.parseExpression();
        this.semicolon();
        return this.finishNode(node, "ThrowStatement");
      };
      var empty$1 = [];
      pp$8.parseCatchClauseParam = function() {
        var param = this.parseBindingAtom();
        var simple = param.type === "Identifier";
        this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
        this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
        this.expect(types$1.parenR);
        return param;
      };
      pp$8.parseTryStatement = function(node) {
        this.next();
        node.block = this.parseBlock();
        node.handler = null;
        if (this.type === types$1._catch) {
          var clause = this.startNode();
          this.next();
          if (this.eat(types$1.parenL)) {
            clause.param = this.parseCatchClauseParam();
          } else {
            if (this.options.ecmaVersion < 10) {
              this.unexpected();
            }
            clause.param = null;
            this.enterScope(0);
          }
          clause.body = this.parseBlock(false);
          this.exitScope();
          node.handler = this.finishNode(clause, "CatchClause");
        }
        node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
        if (!node.handler && !node.finalizer) {
          this.raise(node.start, "Missing catch or finally clause");
        }
        return this.finishNode(node, "TryStatement");
      };
      pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {
        this.next();
        this.parseVar(node, false, kind, allowMissingInitializer);
        this.semicolon();
        return this.finishNode(node, "VariableDeclaration");
      };
      pp$8.parseWhileStatement = function(node) {
        this.next();
        node.test = this.parseParenExpression();
        this.labels.push(loopLabel);
        node.body = this.parseStatement("while");
        this.labels.pop();
        return this.finishNode(node, "WhileStatement");
      };
      pp$8.parseWithStatement = function(node) {
        if (this.strict) {
          this.raise(this.start, "'with' in strict mode");
        }
        this.next();
        node.object = this.parseParenExpression();
        node.body = this.parseStatement("with");
        return this.finishNode(node, "WithStatement");
      };
      pp$8.parseEmptyStatement = function(node) {
        this.next();
        return this.finishNode(node, "EmptyStatement");
      };
      pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
        for (var i$1 = 0, list2 = this.labels; i$1 < list2.length; i$1 += 1) {
          var label = list2[i$1];
          if (label.name === maybeName) {
            this.raise(expr.start, "Label '" + maybeName + "' is already declared");
          }
        }
        var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
        for (var i2 = this.labels.length - 1; i2 >= 0; i2--) {
          var label$1 = this.labels[i2];
          if (label$1.statementStart === node.start) {
            label$1.statementStart = this.start;
            label$1.kind = kind;
          } else {
            break;
          }
        }
        this.labels.push({ name: maybeName, kind, statementStart: this.start });
        node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
        this.labels.pop();
        node.label = expr;
        return this.finishNode(node, "LabeledStatement");
      };
      pp$8.parseExpressionStatement = function(node, expr) {
        node.expression = expr;
        this.semicolon();
        return this.finishNode(node, "ExpressionStatement");
      };
      pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
        if (createNewLexicalScope === void 0)
          createNewLexicalScope = true;
        if (node === void 0)
          node = this.startNode();
        node.body = [];
        this.expect(types$1.braceL);
        if (createNewLexicalScope) {
          this.enterScope(0);
        }
        while (this.type !== types$1.braceR) {
          var stmt = this.parseStatement(null);
          node.body.push(stmt);
        }
        if (exitStrict) {
          this.strict = false;
        }
        this.next();
        if (createNewLexicalScope) {
          this.exitScope();
        }
        return this.finishNode(node, "BlockStatement");
      };
      pp$8.parseFor = function(node, init) {
        node.init = init;
        this.expect(types$1.semi);
        node.test = this.type === types$1.semi ? null : this.parseExpression();
        this.expect(types$1.semi);
        node.update = this.type === types$1.parenR ? null : this.parseExpression();
        this.expect(types$1.parenR);
        node.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node, "ForStatement");
      };
      pp$8.parseForIn = function(node, init) {
        var isForIn = this.type === types$1._in;
        this.next();
        if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
          this.raise(
            init.start,
            (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
          );
        }
        node.left = init;
        node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
        this.expect(types$1.parenR);
        node.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
      };
      pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {
        node.declarations = [];
        node.kind = kind;
        for (; ; ) {
          var decl = this.startNode();
          this.parseVarId(decl, kind);
          if (this.eat(types$1.eq)) {
            decl.init = this.parseMaybeAssign(isFor);
          } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
            this.unexpected();
          } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
            this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
          } else {
            decl.init = null;
          }
          node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
          if (!this.eat(types$1.comma)) {
            break;
          }
        }
        return node;
      };
      pp$8.parseVarId = function(decl, kind) {
        decl.id = this.parseBindingAtom();
        this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
      };
      var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;
      pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
        this.initFunction(node);
        if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
          if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
            this.unexpected();
          }
          node.generator = this.eat(types$1.star);
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        if (statement & FUNC_STATEMENT) {
          node.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
          if (node.id && !(statement & FUNC_HANGING_STATEMENT)) {
            this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
          }
        }
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags(node.async, node.generator));
        if (!(statement & FUNC_STATEMENT)) {
          node.id = this.type === types$1.name ? this.parseIdent() : null;
        }
        this.parseFunctionParams(node);
        this.parseFunctionBody(node, allowExpressionBody, false, forInit);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
      };
      pp$8.parseFunctionParams = function(node) {
        this.expect(types$1.parenL);
        node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
      };
      pp$8.parseClass = function(node, isStatement) {
        this.next();
        var oldStrict = this.strict;
        this.strict = true;
        this.parseClassId(node, isStatement);
        this.parseClassSuper(node);
        var privateNameMap = this.enterClassBody();
        var classBody = this.startNode();
        var hadConstructor = false;
        classBody.body = [];
        this.expect(types$1.braceL);
        while (this.type !== types$1.braceR) {
          var element = this.parseClassElement(node.superClass !== null);
          if (element) {
            classBody.body.push(element);
            if (element.type === "MethodDefinition" && element.kind === "constructor") {
              if (hadConstructor) {
                this.raiseRecoverable(element.start, "Duplicate constructor in the same class");
              }
              hadConstructor = true;
            } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
              this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared");
            }
          }
        }
        this.strict = oldStrict;
        this.next();
        node.body = this.finishNode(classBody, "ClassBody");
        this.exitClassBody();
        return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
      };
      pp$8.parseClassElement = function(constructorAllowsSuper) {
        if (this.eat(types$1.semi)) {
          return null;
        }
        var ecmaVersion2 = this.options.ecmaVersion;
        var node = this.startNode();
        var keyName = "";
        var isGenerator = false;
        var isAsync = false;
        var kind = "method";
        var isStatic = false;
        if (this.eatContextual("static")) {
          if (ecmaVersion2 >= 13 && this.eat(types$1.braceL)) {
            this.parseClassStaticBlock(node);
            return node;
          }
          if (this.isClassElementNameStart() || this.type === types$1.star) {
            isStatic = true;
          } else {
            keyName = "static";
          }
        }
        node.static = isStatic;
        if (!keyName && ecmaVersion2 >= 8 && this.eatContextual("async")) {
          if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
            isAsync = true;
          } else {
            keyName = "async";
          }
        }
        if (!keyName && (ecmaVersion2 >= 9 || !isAsync) && this.eat(types$1.star)) {
          isGenerator = true;
        }
        if (!keyName && !isAsync && !isGenerator) {
          var lastValue = this.value;
          if (this.eatContextual("get") || this.eatContextual("set")) {
            if (this.isClassElementNameStart()) {
              kind = lastValue;
            } else {
              keyName = lastValue;
            }
          }
        }
        if (keyName) {
          node.computed = false;
          node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
          node.key.name = keyName;
          this.finishNode(node.key, "Identifier");
        } else {
          this.parseClassElementName(node);
        }
        if (ecmaVersion2 < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
          var isConstructor = !node.static && checkKeyName(node, "constructor");
          var allowsDirectSuper = isConstructor && constructorAllowsSuper;
          if (isConstructor && kind !== "method") {
            this.raise(node.key.start, "Constructor can't have get/set modifier");
          }
          node.kind = isConstructor ? "constructor" : kind;
          this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
        } else {
          this.parseClassField(node);
        }
        return node;
      };
      pp$8.isClassElementNameStart = function() {
        return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
      };
      pp$8.parseClassElementName = function(element) {
        if (this.type === types$1.privateId) {
          if (this.value === "constructor") {
            this.raise(this.start, "Classes can't have an element named '#constructor'");
          }
          element.computed = false;
          element.key = this.parsePrivateIdent();
        } else {
          this.parsePropertyName(element);
        }
      };
      pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
        var key = method.key;
        if (method.kind === "constructor") {
          if (isGenerator) {
            this.raise(key.start, "Constructor can't be a generator");
          }
          if (isAsync) {
            this.raise(key.start, "Constructor can't be an async method");
          }
        } else if (method.static && checkKeyName(method, "prototype")) {
          this.raise(key.start, "Classes may not have a static property named prototype");
        }
        var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
        if (method.kind === "get" && value.params.length !== 0) {
          this.raiseRecoverable(value.start, "getter should have no params");
        }
        if (method.kind === "set" && value.params.length !== 1) {
          this.raiseRecoverable(value.start, "setter should have exactly one param");
        }
        if (method.kind === "set" && value.params[0].type === "RestElement") {
          this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
        }
        return this.finishNode(method, "MethodDefinition");
      };
      pp$8.parseClassField = function(field) {
        if (checkKeyName(field, "constructor")) {
          this.raise(field.key.start, "Classes can't have a field named 'constructor'");
        } else if (field.static && checkKeyName(field, "prototype")) {
          this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
        }
        if (this.eat(types$1.eq)) {
          var scope = this.currentThisScope();
          var inClassFieldInit = scope.inClassFieldInit;
          scope.inClassFieldInit = true;
          field.value = this.parseMaybeAssign();
          scope.inClassFieldInit = inClassFieldInit;
        } else {
          field.value = null;
        }
        this.semicolon();
        return this.finishNode(field, "PropertyDefinition");
      };
      pp$8.parseClassStaticBlock = function(node) {
        node.body = [];
        var oldLabels = this.labels;
        this.labels = [];
        this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
        while (this.type !== types$1.braceR) {
          var stmt = this.parseStatement(null);
          node.body.push(stmt);
        }
        this.next();
        this.exitScope();
        this.labels = oldLabels;
        return this.finishNode(node, "StaticBlock");
      };
      pp$8.parseClassId = function(node, isStatement) {
        if (this.type === types$1.name) {
          node.id = this.parseIdent();
          if (isStatement) {
            this.checkLValSimple(node.id, BIND_LEXICAL, false);
          }
        } else {
          if (isStatement === true) {
            this.unexpected();
          }
          node.id = null;
        }
      };
      pp$8.parseClassSuper = function(node) {
        node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
      };
      pp$8.enterClassBody = function() {
        var element = { declared: /* @__PURE__ */ Object.create(null), used: [] };
        this.privateNameStack.push(element);
        return element.declared;
      };
      pp$8.exitClassBody = function() {
        var ref2 = this.privateNameStack.pop();
        var declared = ref2.declared;
        var used = ref2.used;
        if (!this.options.checkPrivateFields) {
          return;
        }
        var len = this.privateNameStack.length;
        var parent = len === 0 ? null : this.privateNameStack[len - 1];
        for (var i2 = 0; i2 < used.length; ++i2) {
          var id = used[i2];
          if (!hasOwn(declared, id.name)) {
            if (parent) {
              parent.used.push(id);
            } else {
              this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
            }
          }
        }
      };
      function isPrivateNameConflicted(privateNameMap, element) {
        var name = element.key.name;
        var curr = privateNameMap[name];
        var next = "true";
        if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
          next = (element.static ? "s" : "i") + element.kind;
        }
        if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
          privateNameMap[name] = "true";
          return false;
        } else if (!curr) {
          privateNameMap[name] = next;
          return false;
        } else {
          return true;
        }
      }
      function checkKeyName(node, name) {
        var computed = node.computed;
        var key = node.key;
        return !computed && (key.type === "Identifier" && key.name === name || key.type === "Literal" && key.value === name);
      }
      pp$8.parseExportAllDeclaration = function(node, exports3) {
        if (this.options.ecmaVersion >= 11) {
          if (this.eatContextual("as")) {
            node.exported = this.parseModuleExportName();
            this.checkExport(exports3, node.exported, this.lastTokStart);
          } else {
            node.exported = null;
          }
        }
        this.expectContextual("from");
        if (this.type !== types$1.string) {
          this.unexpected();
        }
        node.source = this.parseExprAtom();
        this.semicolon();
        return this.finishNode(node, "ExportAllDeclaration");
      };
      pp$8.parseExport = function(node, exports3) {
        this.next();
        if (this.eat(types$1.star)) {
          return this.parseExportAllDeclaration(node, exports3);
        }
        if (this.eat(types$1._default)) {
          this.checkExport(exports3, "default", this.lastTokStart);
          node.declaration = this.parseExportDefaultDeclaration();
          return this.finishNode(node, "ExportDefaultDeclaration");
        }
        if (this.shouldParseExportStatement()) {
          node.declaration = this.parseExportDeclaration(node);
          if (node.declaration.type === "VariableDeclaration") {
            this.checkVariableExport(exports3, node.declaration.declarations);
          } else {
            this.checkExport(exports3, node.declaration.id, node.declaration.id.start);
          }
          node.specifiers = [];
          node.source = null;
        } else {
          node.declaration = null;
          node.specifiers = this.parseExportSpecifiers(exports3);
          if (this.eatContextual("from")) {
            if (this.type !== types$1.string) {
              this.unexpected();
            }
            node.source = this.parseExprAtom();
          } else {
            for (var i2 = 0, list2 = node.specifiers; i2 < list2.length; i2 += 1) {
              var spec = list2[i2];
              this.checkUnreserved(spec.local);
              this.checkLocalExport(spec.local);
              if (spec.local.type === "Literal") {
                this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
              }
            }
            node.source = null;
          }
          this.semicolon();
        }
        return this.finishNode(node, "ExportNamedDeclaration");
      };
      pp$8.parseExportDeclaration = function(node) {
        return this.parseStatement(null);
      };
      pp$8.parseExportDefaultDeclaration = function() {
        var isAsync;
        if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
          var fNode = this.startNode();
          this.next();
          if (isAsync) {
            this.next();
          }
          return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
        } else if (this.type === types$1._class) {
          var cNode = this.startNode();
          return this.parseClass(cNode, "nullableID");
        } else {
          var declaration = this.parseMaybeAssign();
          this.semicolon();
          return declaration;
        }
      };
      pp$8.checkExport = function(exports3, name, pos) {
        if (!exports3) {
          return;
        }
        if (typeof name !== "string") {
          name = name.type === "Identifier" ? name.name : name.value;
        }
        if (hasOwn(exports3, name)) {
          this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
        }
        exports3[name] = true;
      };
      pp$8.checkPatternExport = function(exports3, pat) {
        var type = pat.type;
        if (type === "Identifier") {
          this.checkExport(exports3, pat, pat.start);
        } else if (type === "ObjectPattern") {
          for (var i2 = 0, list2 = pat.properties; i2 < list2.length; i2 += 1) {
            var prop = list2[i2];
            this.checkPatternExport(exports3, prop);
          }
        } else if (type === "ArrayPattern") {
          for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
            var elt = list$1[i$1];
            if (elt) {
              this.checkPatternExport(exports3, elt);
            }
          }
        } else if (type === "Property") {
          this.checkPatternExport(exports3, pat.value);
        } else if (type === "AssignmentPattern") {
          this.checkPatternExport(exports3, pat.left);
        } else if (type === "RestElement") {
          this.checkPatternExport(exports3, pat.argument);
        } else if (type === "ParenthesizedExpression") {
          this.checkPatternExport(exports3, pat.expression);
        }
      };
      pp$8.checkVariableExport = function(exports3, decls) {
        if (!exports3) {
          return;
        }
        for (var i2 = 0, list2 = decls; i2 < list2.length; i2 += 1) {
          var decl = list2[i2];
          this.checkPatternExport(exports3, decl.id);
        }
      };
      pp$8.shouldParseExportStatement = function() {
        return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
      };
      pp$8.parseExportSpecifier = function(exports3) {
        var node = this.startNode();
        node.local = this.parseModuleExportName();
        node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
        this.checkExport(
          exports3,
          node.exported,
          node.exported.start
        );
        return this.finishNode(node, "ExportSpecifier");
      };
      pp$8.parseExportSpecifiers = function(exports3) {
        var nodes = [], first = true;
        this.expect(types$1.braceL);
        while (!this.eat(types$1.braceR)) {
          if (!first) {
            this.expect(types$1.comma);
            if (this.afterTrailingComma(types$1.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          nodes.push(this.parseExportSpecifier(exports3));
        }
        return nodes;
      };
      pp$8.parseImport = function(node) {
        this.next();
        if (this.type === types$1.string) {
          node.specifiers = empty$1;
          node.source = this.parseExprAtom();
        } else {
          node.specifiers = this.parseImportSpecifiers();
          this.expectContextual("from");
          node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
        }
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      };
      pp$8.parseImportSpecifier = function() {
        var node = this.startNode();
        node.imported = this.parseModuleExportName();
        if (this.eatContextual("as")) {
          node.local = this.parseIdent();
        } else {
          this.checkUnreserved(node.imported);
          node.local = node.imported;
        }
        this.checkLValSimple(node.local, BIND_LEXICAL);
        return this.finishNode(node, "ImportSpecifier");
      };
      pp$8.parseImportDefaultSpecifier = function() {
        var node = this.startNode();
        node.local = this.parseIdent();
        this.checkLValSimple(node.local, BIND_LEXICAL);
        return this.finishNode(node, "ImportDefaultSpecifier");
      };
      pp$8.parseImportNamespaceSpecifier = function() {
        var node = this.startNode();
        this.next();
        this.expectContextual("as");
        node.local = this.parseIdent();
        this.checkLValSimple(node.local, BIND_LEXICAL);
        return this.finishNode(node, "ImportNamespaceSpecifier");
      };
      pp$8.parseImportSpecifiers = function() {
        var nodes = [], first = true;
        if (this.type === types$1.name) {
          nodes.push(this.parseImportDefaultSpecifier());
          if (!this.eat(types$1.comma)) {
            return nodes;
          }
        }
        if (this.type === types$1.star) {
          nodes.push(this.parseImportNamespaceSpecifier());
          return nodes;
        }
        this.expect(types$1.braceL);
        while (!this.eat(types$1.braceR)) {
          if (!first) {
            this.expect(types$1.comma);
            if (this.afterTrailingComma(types$1.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          nodes.push(this.parseImportSpecifier());
        }
        return nodes;
      };
      pp$8.parseModuleExportName = function() {
        if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
          var stringLiteral = this.parseLiteral(this.value);
          if (loneSurrogate.test(stringLiteral.value)) {
            this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
          }
          return stringLiteral;
        }
        return this.parseIdent(true);
      };
      pp$8.adaptDirectivePrologue = function(statements) {
        for (var i2 = 0; i2 < statements.length && this.isDirectiveCandidate(statements[i2]); ++i2) {
          statements[i2].directive = statements[i2].expression.raw.slice(1, -1);
        }
      };
      pp$8.isDirectiveCandidate = function(statement) {
        return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && // Reject parenthesized strings.
        (this.input[statement.start] === '"' || this.input[statement.start] === "'");
      };
      var pp$7 = Parser.prototype;
      pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 6 && node) {
          switch (node.type) {
            case "Identifier":
              if (this.inAsync && node.name === "await") {
                this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
              }
              break;
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
              break;
            case "ObjectExpression":
              node.type = "ObjectPattern";
              if (refDestructuringErrors) {
                this.checkPatternErrors(refDestructuringErrors, true);
              }
              for (var i2 = 0, list2 = node.properties; i2 < list2.length; i2 += 1) {
                var prop = list2[i2];
                this.toAssignable(prop, isBinding);
                if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
                  this.raise(prop.argument.start, "Unexpected token");
                }
              }
              break;
            case "Property":
              if (node.kind !== "init") {
                this.raise(node.key.start, "Object pattern can't contain getter or setter");
              }
              this.toAssignable(node.value, isBinding);
              break;
            case "ArrayExpression":
              node.type = "ArrayPattern";
              if (refDestructuringErrors) {
                this.checkPatternErrors(refDestructuringErrors, true);
              }
              this.toAssignableList(node.elements, isBinding);
              break;
            case "SpreadElement":
              node.type = "RestElement";
              this.toAssignable(node.argument, isBinding);
              if (node.argument.type === "AssignmentPattern") {
                this.raise(node.argument.start, "Rest elements cannot have a default value");
              }
              break;
            case "AssignmentExpression":
              if (node.operator !== "=") {
                this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
              }
              node.type = "AssignmentPattern";
              delete node.operator;
              this.toAssignable(node.left, isBinding);
              break;
            case "ParenthesizedExpression":
              this.toAssignable(node.expression, isBinding, refDestructuringErrors);
              break;
            case "ChainExpression":
              this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
              break;
            case "MemberExpression":
              if (!isBinding) {
                break;
              }
            default:
              this.raise(node.start, "Assigning to rvalue");
          }
        } else if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        return node;
      };
      pp$7.toAssignableList = function(exprList, isBinding) {
        var end = exprList.length;
        for (var i2 = 0; i2 < end; i2++) {
          var elt = exprList[i2];
          if (elt) {
            this.toAssignable(elt, isBinding);
          }
        }
        if (end) {
          var last = exprList[end - 1];
          if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
            this.unexpected(last.argument.start);
          }
        }
        return exprList;
      };
      pp$7.parseSpread = function(refDestructuringErrors) {
        var node = this.startNode();
        this.next();
        node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
        return this.finishNode(node, "SpreadElement");
      };
      pp$7.parseRestBinding = function() {
        var node = this.startNode();
        this.next();
        if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
          this.unexpected();
        }
        node.argument = this.parseBindingAtom();
        return this.finishNode(node, "RestElement");
      };
      pp$7.parseBindingAtom = function() {
        if (this.options.ecmaVersion >= 6) {
          switch (this.type) {
            case types$1.bracketL:
              var node = this.startNode();
              this.next();
              node.elements = this.parseBindingList(types$1.bracketR, true, true);
              return this.finishNode(node, "ArrayPattern");
            case types$1.braceL:
              return this.parseObj(true);
          }
        }
        return this.parseIdent();
      };
      pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {
        var elts = [], first = true;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(types$1.comma);
          }
          if (allowEmpty && this.type === types$1.comma) {
            elts.push(null);
          } else if (allowTrailingComma && this.afterTrailingComma(close)) {
            break;
          } else if (this.type === types$1.ellipsis) {
            var rest = this.parseRestBinding();
            this.parseBindingListItem(rest);
            elts.push(rest);
            if (this.type === types$1.comma) {
              this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
            }
            this.expect(close);
            break;
          } else {
            elts.push(this.parseAssignableListItem(allowModifiers));
          }
        }
        return elts;
      };
      pp$7.parseAssignableListItem = function(allowModifiers) {
        var elem = this.parseMaybeDefault(this.start, this.startLoc);
        this.parseBindingListItem(elem);
        return elem;
      };
      pp$7.parseBindingListItem = function(param) {
        return param;
      };
      pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
        left = left || this.parseBindingAtom();
        if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
          return left;
        }
        var node = this.startNodeAt(startPos, startLoc);
        node.left = left;
        node.right = this.parseMaybeAssign();
        return this.finishNode(node, "AssignmentPattern");
      };
      pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0)
          bindingType = BIND_NONE;
        var isBind = bindingType !== BIND_NONE;
        switch (expr.type) {
          case "Identifier":
            if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
              this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
            }
            if (isBind) {
              if (bindingType === BIND_LEXICAL && expr.name === "let") {
                this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
              }
              if (checkClashes) {
                if (hasOwn(checkClashes, expr.name)) {
                  this.raiseRecoverable(expr.start, "Argument name clash");
                }
                checkClashes[expr.name] = true;
              }
              if (bindingType !== BIND_OUTSIDE) {
                this.declareName(expr.name, bindingType, expr.start);
              }
            }
            break;
          case "ChainExpression":
            this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
            break;
          case "MemberExpression":
            if (isBind) {
              this.raiseRecoverable(expr.start, "Binding member expression");
            }
            break;
          case "ParenthesizedExpression":
            if (isBind) {
              this.raiseRecoverable(expr.start, "Binding parenthesized expression");
            }
            return this.checkLValSimple(expr.expression, bindingType, checkClashes);
          default:
            this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
        }
      };
      pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0)
          bindingType = BIND_NONE;
        switch (expr.type) {
          case "ObjectPattern":
            for (var i2 = 0, list2 = expr.properties; i2 < list2.length; i2 += 1) {
              var prop = list2[i2];
              this.checkLValInnerPattern(prop, bindingType, checkClashes);
            }
            break;
          case "ArrayPattern":
            for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
              var elem = list$1[i$1];
              if (elem) {
                this.checkLValInnerPattern(elem, bindingType, checkClashes);
              }
            }
            break;
          default:
            this.checkLValSimple(expr, bindingType, checkClashes);
        }
      };
      pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0)
          bindingType = BIND_NONE;
        switch (expr.type) {
          case "Property":
            this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
            break;
          case "AssignmentPattern":
            this.checkLValPattern(expr.left, bindingType, checkClashes);
            break;
          case "RestElement":
            this.checkLValPattern(expr.argument, bindingType, checkClashes);
            break;
          default:
            this.checkLValPattern(expr, bindingType, checkClashes);
        }
      };
      var TokContext = function TokContext2(token, isExpr, preserveSpace, override, generator) {
        this.token = token;
        this.isExpr = !!isExpr;
        this.preserveSpace = !!preserveSpace;
        this.override = override;
        this.generator = !!generator;
      };
      var types = {
        b_stat: new TokContext("{", false),
        b_expr: new TokContext("{", true),
        b_tmpl: new TokContext("${", false),
        p_stat: new TokContext("(", false),
        p_expr: new TokContext("(", true),
        q_tmpl: new TokContext("`", true, true, function(p) {
          return p.tryReadTemplateToken();
        }),
        f_stat: new TokContext("function", false),
        f_expr: new TokContext("function", true),
        f_expr_gen: new TokContext("function", true, false, null, true),
        f_gen: new TokContext("function", false, false, null, true)
      };
      var pp$6 = Parser.prototype;
      pp$6.initialContext = function() {
        return [types.b_stat];
      };
      pp$6.curContext = function() {
        return this.context[this.context.length - 1];
      };
      pp$6.braceIsBlock = function(prevType) {
        var parent = this.curContext();
        if (parent === types.f_expr || parent === types.f_stat) {
          return true;
        }
        if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {
          return !parent.isExpr;
        }
        if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
          return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
        }
        if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
          return true;
        }
        if (prevType === types$1.braceL) {
          return parent === types.b_stat;
        }
        if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
          return false;
        }
        return !this.exprAllowed;
      };
      pp$6.inGeneratorContext = function() {
        for (var i2 = this.context.length - 1; i2 >= 1; i2--) {
          var context = this.context[i2];
          if (context.token === "function") {
            return context.generator;
          }
        }
        return false;
      };
      pp$6.updateContext = function(prevType) {
        var update, type = this.type;
        if (type.keyword && prevType === types$1.dot) {
          this.exprAllowed = false;
        } else if (update = type.updateContext) {
          update.call(this, prevType);
        } else {
          this.exprAllowed = type.beforeExpr;
        }
      };
      pp$6.overrideContext = function(tokenCtx) {
        if (this.curContext() !== tokenCtx) {
          this.context[this.context.length - 1] = tokenCtx;
        }
      };
      types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
        if (this.context.length === 1) {
          this.exprAllowed = true;
          return;
        }
        var out = this.context.pop();
        if (out === types.b_stat && this.curContext().token === "function") {
          out = this.context.pop();
        }
        this.exprAllowed = !out.isExpr;
      };
      types$1.braceL.updateContext = function(prevType) {
        this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
        this.exprAllowed = true;
      };
      types$1.dollarBraceL.updateContext = function() {
        this.context.push(types.b_tmpl);
        this.exprAllowed = true;
      };
      types$1.parenL.updateContext = function(prevType) {
        var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
        this.context.push(statementParens ? types.p_stat : types.p_expr);
        this.exprAllowed = true;
      };
      types$1.incDec.updateContext = function() {
      };
      types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
        if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {
          this.context.push(types.f_expr);
        } else {
          this.context.push(types.f_stat);
        }
        this.exprAllowed = false;
      };
      types$1.backQuote.updateContext = function() {
        if (this.curContext() === types.q_tmpl) {
          this.context.pop();
        } else {
          this.context.push(types.q_tmpl);
        }
        this.exprAllowed = false;
      };
      types$1.star.updateContext = function(prevType) {
        if (prevType === types$1._function) {
          var index = this.context.length - 1;
          if (this.context[index] === types.f_expr) {
            this.context[index] = types.f_expr_gen;
          } else {
            this.context[index] = types.f_gen;
          }
        }
        this.exprAllowed = true;
      };
      types$1.name.updateContext = function(prevType) {
        var allowed = false;
        if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
          if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
            allowed = true;
          }
        }
        this.exprAllowed = allowed;
      };
      var pp$5 = Parser.prototype;
      pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
          return;
        }
        if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
          return;
        }
        var key = prop.key;
        var name;
        switch (key.type) {
          case "Identifier":
            name = key.name;
            break;
          case "Literal":
            name = String(key.value);
            break;
          default:
            return;
        }
        var kind = prop.kind;
        if (this.options.ecmaVersion >= 6) {
          if (name === "__proto__" && kind === "init") {
            if (propHash.proto) {
              if (refDestructuringErrors) {
                if (refDestructuringErrors.doubleProto < 0) {
                  refDestructuringErrors.doubleProto = key.start;
                }
              } else {
                this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
              }
            }
            propHash.proto = true;
          }
          return;
        }
        name = "$" + name;
        var other = propHash[name];
        if (other) {
          var redefinition;
          if (kind === "init") {
            redefinition = this.strict && other.init || other.get || other.set;
          } else {
            redefinition = other.init || other[kind];
          }
          if (redefinition) {
            this.raiseRecoverable(key.start, "Redefinition of property");
          }
        } else {
          other = propHash[name] = {
            init: false,
            get: false,
            set: false
          };
        }
        other[kind] = true;
      };
      pp$5.parseExpression = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
        if (this.type === types$1.comma) {
          var node = this.startNodeAt(startPos, startLoc);
          node.expressions = [expr];
          while (this.eat(types$1.comma)) {
            node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
          }
          return this.finishNode(node, "SequenceExpression");
        }
        return expr;
      };
      pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
        if (this.isContextual("yield")) {
          if (this.inGenerator) {
            return this.parseYield(forInit);
          } else {
            this.exprAllowed = false;
          }
        }
        var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
        if (refDestructuringErrors) {
          oldParenAssign = refDestructuringErrors.parenthesizedAssign;
          oldTrailingComma = refDestructuringErrors.trailingComma;
          oldDoubleProto = refDestructuringErrors.doubleProto;
          refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
        } else {
          refDestructuringErrors = new DestructuringErrors();
          ownDestructuringErrors = true;
        }
        var startPos = this.start, startLoc = this.startLoc;
        if (this.type === types$1.parenL || this.type === types$1.name) {
          this.potentialArrowAt = this.start;
          this.potentialArrowInForAwait = forInit === "await";
        }
        var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
        if (afterLeftParse) {
          left = afterLeftParse.call(this, left, startPos, startLoc);
        }
        if (this.type.isAssign) {
          var node = this.startNodeAt(startPos, startLoc);
          node.operator = this.value;
          if (this.type === types$1.eq) {
            left = this.toAssignable(left, false, refDestructuringErrors);
          }
          if (!ownDestructuringErrors) {
            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
          }
          if (refDestructuringErrors.shorthandAssign >= left.start) {
            refDestructuringErrors.shorthandAssign = -1;
          }
          if (this.type === types$1.eq) {
            this.checkLValPattern(left);
          } else {
            this.checkLValSimple(left);
          }
          node.left = left;
          this.next();
          node.right = this.parseMaybeAssign(forInit);
          if (oldDoubleProto > -1) {
            refDestructuringErrors.doubleProto = oldDoubleProto;
          }
          return this.finishNode(node, "AssignmentExpression");
        } else {
          if (ownDestructuringErrors) {
            this.checkExpressionErrors(refDestructuringErrors, true);
          }
        }
        if (oldParenAssign > -1) {
          refDestructuringErrors.parenthesizedAssign = oldParenAssign;
        }
        if (oldTrailingComma > -1) {
          refDestructuringErrors.trailingComma = oldTrailingComma;
        }
        return left;
      };
      pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprOps(forInit, refDestructuringErrors);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        if (this.eat(types$1.question)) {
          var node = this.startNodeAt(startPos, startLoc);
          node.test = expr;
          node.consequent = this.parseMaybeAssign();
          this.expect(types$1.colon);
          node.alternate = this.parseMaybeAssign(forInit);
          return this.finishNode(node, "ConditionalExpression");
        }
        return expr;
      };
      pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
      };
      pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
        var prec = this.type.binop;
        if (prec != null && (!forInit || this.type !== types$1._in)) {
          if (prec > minPrec) {
            var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
            var coalesce = this.type === types$1.coalesce;
            if (coalesce) {
              prec = types$1.logicalAND.binop;
            }
            var op = this.value;
            this.next();
            var startPos = this.start, startLoc = this.startLoc;
            var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
            var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
            if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
              this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
            }
            return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
          }
        }
        return left;
      };
      pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
        if (right.type === "PrivateIdentifier") {
          this.raise(right.start, "Private identifier can only be left side of binary expression");
        }
        var node = this.startNodeAt(startPos, startLoc);
        node.left = left;
        node.operator = op;
        node.right = right;
        return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
      };
      pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
        var startPos = this.start, startLoc = this.startLoc, expr;
        if (this.isContextual("await") && this.canAwait) {
          expr = this.parseAwait(forInit);
          sawUnary = true;
        } else if (this.type.prefix) {
          var node = this.startNode(), update = this.type === types$1.incDec;
          node.operator = this.value;
          node.prefix = true;
          this.next();
          node.argument = this.parseMaybeUnary(null, true, update, forInit);
          this.checkExpressionErrors(refDestructuringErrors, true);
          if (update) {
            this.checkLValSimple(node.argument);
          } else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") {
            this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
          } else if (node.operator === "delete" && isPrivateFieldAccess(node.argument)) {
            this.raiseRecoverable(node.start, "Private fields can not be deleted");
          } else {
            sawUnary = true;
          }
          expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
        } else if (!sawUnary && this.type === types$1.privateId) {
          if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {
            this.unexpected();
          }
          expr = this.parsePrivateIdent();
          if (this.type !== types$1._in) {
            this.unexpected();
          }
        } else {
          expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
          if (this.checkExpressionErrors(refDestructuringErrors)) {
            return expr;
          }
          while (this.type.postfix && !this.canInsertSemicolon()) {
            var node$1 = this.startNodeAt(startPos, startLoc);
            node$1.operator = this.value;
            node$1.prefix = false;
            node$1.argument = expr;
            this.checkLValSimple(expr);
            this.next();
            expr = this.finishNode(node$1, "UpdateExpression");
          }
        }
        if (!incDec && this.eat(types$1.starstar)) {
          if (sawUnary) {
            this.unexpected(this.lastTokStart);
          } else {
            return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
          }
        } else {
          return expr;
        }
      };
      function isPrivateFieldAccess(node) {
        return node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" || node.type === "ChainExpression" && isPrivateFieldAccess(node.expression);
      }
      pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprAtom(refDestructuringErrors, forInit);
        if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
          return expr;
        }
        var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
        if (refDestructuringErrors && result.type === "MemberExpression") {
          if (refDestructuringErrors.parenthesizedAssign >= result.start) {
            refDestructuringErrors.parenthesizedAssign = -1;
          }
          if (refDestructuringErrors.parenthesizedBind >= result.start) {
            refDestructuringErrors.parenthesizedBind = -1;
          }
          if (refDestructuringErrors.trailingComma >= result.start) {
            refDestructuringErrors.trailingComma = -1;
          }
        }
        return result;
      };
      pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
        var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
        var optionalChained = false;
        while (true) {
          var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
          if (element.optional) {
            optionalChained = true;
          }
          if (element === base || element.type === "ArrowFunctionExpression") {
            if (optionalChained) {
              var chainNode = this.startNodeAt(startPos, startLoc);
              chainNode.expression = element;
              element = this.finishNode(chainNode, "ChainExpression");
            }
            return element;
          }
          base = element;
        }
      };
      pp$5.shouldParseAsyncArrow = function() {
        return !this.canInsertSemicolon() && this.eat(types$1.arrow);
      };
      pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
      };
      pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
        var optionalSupported = this.options.ecmaVersion >= 11;
        var optional = optionalSupported && this.eat(types$1.questionDot);
        if (noCalls && optional) {
          this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
        }
        var computed = this.eat(types$1.bracketL);
        if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
          var node = this.startNodeAt(startPos, startLoc);
          node.object = base;
          if (computed) {
            node.property = this.parseExpression();
            this.expect(types$1.bracketR);
          } else if (this.type === types$1.privateId && base.type !== "Super") {
            node.property = this.parsePrivateIdent();
          } else {
            node.property = this.parseIdent(this.options.allowReserved !== "never");
          }
          node.computed = !!computed;
          if (optionalSupported) {
            node.optional = optional;
          }
          base = this.finishNode(node, "MemberExpression");
        } else if (!noCalls && this.eat(types$1.parenL)) {
          var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
          this.yieldPos = 0;
          this.awaitPos = 0;
          this.awaitIdentPos = 0;
          var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
          if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            if (this.awaitIdentPos > 0) {
              this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
            }
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            this.awaitIdentPos = oldAwaitIdentPos;
            return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
          }
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
          var node$1 = this.startNodeAt(startPos, startLoc);
          node$1.callee = base;
          node$1.arguments = exprList;
          if (optionalSupported) {
            node$1.optional = optional;
          }
          base = this.finishNode(node$1, "CallExpression");
        } else if (this.type === types$1.backQuote) {
          if (optional || optionalChained) {
            this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
          }
          var node$2 = this.startNodeAt(startPos, startLoc);
          node$2.tag = base;
          node$2.quasi = this.parseTemplate({ isTagged: true });
          base = this.finishNode(node$2, "TaggedTemplateExpression");
        }
        return base;
      };
      pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
        if (this.type === types$1.slash) {
          this.readRegexp();
        }
        var node, canBeArrow = this.potentialArrowAt === this.start;
        switch (this.type) {
          case types$1._super:
            if (!this.allowSuper) {
              this.raise(this.start, "'super' keyword outside a method");
            }
            node = this.startNode();
            this.next();
            if (this.type === types$1.parenL && !this.allowDirectSuper) {
              this.raise(node.start, "super() call outside constructor of a subclass");
            }
            if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
              this.unexpected();
            }
            return this.finishNode(node, "Super");
          case types$1._this:
            node = this.startNode();
            this.next();
            return this.finishNode(node, "ThisExpression");
          case types$1.name:
            var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
            var id = this.parseIdent(false);
            if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
              this.overrideContext(types.f_expr);
              return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
            }
            if (canBeArrow && !this.canInsertSemicolon()) {
              if (this.eat(types$1.arrow)) {
                return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
              }
              if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
                id = this.parseIdent(false);
                if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
                  this.unexpected();
                }
                return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
              }
            }
            return id;
          case types$1.regexp:
            var value = this.value;
            node = this.parseLiteral(value.value);
            node.regex = { pattern: value.pattern, flags: value.flags };
            return node;
          case types$1.num:
          case types$1.string:
            return this.parseLiteral(this.value);
          case types$1._null:
          case types$1._true:
          case types$1._false:
            node = this.startNode();
            node.value = this.type === types$1._null ? null : this.type === types$1._true;
            node.raw = this.type.keyword;
            this.next();
            return this.finishNode(node, "Literal");
          case types$1.parenL:
            var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
            if (refDestructuringErrors) {
              if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
                refDestructuringErrors.parenthesizedAssign = start;
              }
              if (refDestructuringErrors.parenthesizedBind < 0) {
                refDestructuringErrors.parenthesizedBind = start;
              }
            }
            return expr;
          case types$1.bracketL:
            node = this.startNode();
            this.next();
            node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
            return this.finishNode(node, "ArrayExpression");
          case types$1.braceL:
            this.overrideContext(types.b_expr);
            return this.parseObj(false, refDestructuringErrors);
          case types$1._function:
            node = this.startNode();
            this.next();
            return this.parseFunction(node, 0);
          case types$1._class:
            return this.parseClass(this.startNode(), false);
          case types$1._new:
            return this.parseNew();
          case types$1.backQuote:
            return this.parseTemplate();
          case types$1._import:
            if (this.options.ecmaVersion >= 11) {
              return this.parseExprImport(forNew);
            } else {
              return this.unexpected();
            }
          default:
            return this.parseExprAtomDefault();
        }
      };
      pp$5.parseExprAtomDefault = function() {
        this.unexpected();
      };
      pp$5.parseExprImport = function(forNew) {
        var node = this.startNode();
        if (this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword import");
        }
        var meta = this.parseIdent(true);
        if (this.type === types$1.parenL && !forNew) {
          return this.parseDynamicImport(node);
        } else if (this.type === types$1.dot) {
          node.meta = meta;
          return this.parseImportMeta(node);
        } else {
          this.unexpected();
        }
      };
      pp$5.parseDynamicImport = function(node) {
        this.next();
        node.source = this.parseMaybeAssign();
        if (!this.eat(types$1.parenR)) {
          var errorPos = this.start;
          if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
            this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
          } else {
            this.unexpected(errorPos);
          }
        }
        return this.finishNode(node, "ImportExpression");
      };
      pp$5.parseImportMeta = function(node) {
        this.next();
        var containsEsc = this.containsEsc;
        node.property = this.parseIdent(true);
        if (node.property.name !== "meta") {
          this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
        }
        if (containsEsc) {
          this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
        }
        if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
          this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
        }
        return this.finishNode(node, "MetaProperty");
      };
      pp$5.parseLiteral = function(value) {
        var node = this.startNode();
        node.value = value;
        node.raw = this.input.slice(this.start, this.end);
        if (node.raw.charCodeAt(node.raw.length - 1) === 110) {
          node.bigint = node.raw.slice(0, -1).replace(/_/g, "");
        }
        this.next();
        return this.finishNode(node, "Literal");
      };
      pp$5.parseParenExpression = function() {
        this.expect(types$1.parenL);
        var val = this.parseExpression();
        this.expect(types$1.parenR);
        return val;
      };
      pp$5.shouldParseArrow = function(exprList) {
        return !this.canInsertSemicolon();
      };
      pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
        var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
        if (this.options.ecmaVersion >= 6) {
          this.next();
          var innerStartPos = this.start, innerStartLoc = this.startLoc;
          var exprList = [], first = true, lastIsComma = false;
          var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
          this.yieldPos = 0;
          this.awaitPos = 0;
          while (this.type !== types$1.parenR) {
            first ? first = false : this.expect(types$1.comma);
            if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
              lastIsComma = true;
              break;
            } else if (this.type === types$1.ellipsis) {
              spreadStart = this.start;
              exprList.push(this.parseParenItem(this.parseRestBinding()));
              if (this.type === types$1.comma) {
                this.raiseRecoverable(
                  this.start,
                  "Comma is not permitted after the rest element"
                );
              }
              break;
            } else {
              exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
            }
          }
          var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
          this.expect(types$1.parenR);
          if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
          }
          if (!exprList.length || lastIsComma) {
            this.unexpected(this.lastTokStart);
          }
          if (spreadStart) {
            this.unexpected(spreadStart);
          }
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          if (exprList.length > 1) {
            val = this.startNodeAt(innerStartPos, innerStartLoc);
            val.expressions = exprList;
            this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
          } else {
            val = exprList[0];
          }
        } else {
          val = this.parseParenExpression();
        }
        if (this.options.preserveParens) {
          var par = this.startNodeAt(startPos, startLoc);
          par.expression = val;
          return this.finishNode(par, "ParenthesizedExpression");
        } else {
          return val;
        }
      };
      pp$5.parseParenItem = function(item) {
        return item;
      };
      pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
      };
      var empty = [];
      pp$5.parseNew = function() {
        if (this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword new");
        }
        var node = this.startNode();
        var meta = this.parseIdent(true);
        if (this.options.ecmaVersion >= 6 && this.eat(types$1.dot)) {
          node.meta = meta;
          var containsEsc = this.containsEsc;
          node.property = this.parseIdent(true);
          if (node.property.name !== "target") {
            this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
          }
          if (containsEsc) {
            this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
          }
          if (!this.allowNewDotTarget) {
            this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block");
          }
          return this.finishNode(node, "MetaProperty");
        }
        var startPos = this.start, startLoc = this.startLoc;
        node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
        if (this.eat(types$1.parenL)) {
          node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
        } else {
          node.arguments = empty;
        }
        return this.finishNode(node, "NewExpression");
      };
      pp$5.parseTemplateElement = function(ref2) {
        var isTagged = ref2.isTagged;
        var elem = this.startNode();
        if (this.type === types$1.invalidTemplate) {
          if (!isTagged) {
            this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
          }
          elem.value = {
            raw: this.value,
            cooked: null
          };
        } else {
          elem.value = {
            raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
            cooked: this.value
          };
        }
        this.next();
        elem.tail = this.type === types$1.backQuote;
        return this.finishNode(elem, "TemplateElement");
      };
      pp$5.parseTemplate = function(ref2) {
        if (ref2 === void 0)
          ref2 = {};
        var isTagged = ref2.isTagged;
        if (isTagged === void 0)
          isTagged = false;
        var node = this.startNode();
        this.next();
        node.expressions = [];
        var curElt = this.parseTemplateElement({ isTagged });
        node.quasis = [curElt];
        while (!curElt.tail) {
          if (this.type === types$1.eof) {
            this.raise(this.pos, "Unterminated template literal");
          }
          this.expect(types$1.dollarBraceL);
          node.expressions.push(this.parseExpression());
          this.expect(types$1.braceR);
          node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
        }
        this.next();
        return this.finishNode(node, "TemplateLiteral");
      };
      pp$5.isAsyncProp = function(prop) {
        return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
      };
      pp$5.parseObj = function(isPattern, refDestructuringErrors) {
        var node = this.startNode(), first = true, propHash = {};
        node.properties = [];
        this.next();
        while (!this.eat(types$1.braceR)) {
          if (!first) {
            this.expect(types$1.comma);
            if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          var prop = this.parseProperty(isPattern, refDestructuringErrors);
          if (!isPattern) {
            this.checkPropClash(prop, propHash, refDestructuringErrors);
          }
          node.properties.push(prop);
        }
        return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
      };
      pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
        var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
        if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
          if (isPattern) {
            prop.argument = this.parseIdent(false);
            if (this.type === types$1.comma) {
              this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
            }
            return this.finishNode(prop, "RestElement");
          }
          prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
          if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
            refDestructuringErrors.trailingComma = this.start;
          }
          return this.finishNode(prop, "SpreadElement");
        }
        if (this.options.ecmaVersion >= 6) {
          prop.method = false;
          prop.shorthand = false;
          if (isPattern || refDestructuringErrors) {
            startPos = this.start;
            startLoc = this.startLoc;
          }
          if (!isPattern) {
            isGenerator = this.eat(types$1.star);
          }
        }
        var containsEsc = this.containsEsc;
        this.parsePropertyName(prop);
        if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
          isAsync = true;
          isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
          this.parsePropertyName(prop);
        } else {
          isAsync = false;
        }
        this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
        return this.finishNode(prop, "Property");
      };
      pp$5.parseGetterSetter = function(prop) {
        prop.kind = prop.key.name;
        this.parsePropertyName(prop);
        prop.value = this.parseMethod(false);
        var paramCount = prop.kind === "get" ? 0 : 1;
        if (prop.value.params.length !== paramCount) {
          var start = prop.value.start;
          if (prop.kind === "get") {
            this.raiseRecoverable(start, "getter should have no params");
          } else {
            this.raiseRecoverable(start, "setter should have exactly one param");
          }
        } else {
          if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
            this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
          }
        }
      };
      pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
        if ((isGenerator || isAsync) && this.type === types$1.colon) {
          this.unexpected();
        }
        if (this.eat(types$1.colon)) {
          prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
          prop.kind = "init";
        } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
          if (isPattern) {
            this.unexpected();
          }
          prop.kind = "init";
          prop.method = true;
          prop.value = this.parseMethod(isGenerator, isAsync);
        } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
          if (isGenerator || isAsync) {
            this.unexpected();
          }
          this.parseGetterSetter(prop);
        } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
          if (isGenerator || isAsync) {
            this.unexpected();
          }
          this.checkUnreserved(prop.key);
          if (prop.key.name === "await" && !this.awaitIdentPos) {
            this.awaitIdentPos = startPos;
          }
          prop.kind = "init";
          if (isPattern) {
            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
          } else if (this.type === types$1.eq && refDestructuringErrors) {
            if (refDestructuringErrors.shorthandAssign < 0) {
              refDestructuringErrors.shorthandAssign = this.start;
            }
            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
          } else {
            prop.value = this.copyNode(prop.key);
          }
          prop.shorthand = true;
        } else {
          this.unexpected();
        }
      };
      pp$5.parsePropertyName = function(prop) {
        if (this.options.ecmaVersion >= 6) {
          if (this.eat(types$1.bracketL)) {
            prop.computed = true;
            prop.key = this.parseMaybeAssign();
            this.expect(types$1.bracketR);
            return prop.key;
          } else {
            prop.computed = false;
          }
        }
        return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
      };
      pp$5.initFunction = function(node) {
        node.id = null;
        if (this.options.ecmaVersion >= 6) {
          node.generator = node.expression = false;
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = false;
        }
      };
      pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
        var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.initFunction(node);
        if (this.options.ecmaVersion >= 6) {
          node.generator = isGenerator;
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
        this.expect(types$1.parenL);
        node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
        this.parseFunctionBody(node, false, true, false);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, "FunctionExpression");
      };
      pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
        this.initFunction(node);
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        node.params = this.toAssignableList(params, true);
        this.parseFunctionBody(node, true, false, forInit);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, "ArrowFunctionExpression");
      };
      pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
        var isExpression = isArrowFunction && this.type !== types$1.braceL;
        var oldStrict = this.strict, useStrict = false;
        if (isExpression) {
          node.body = this.parseMaybeAssign(forInit);
          node.expression = true;
          this.checkParams(node, false);
        } else {
          var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
          if (!oldStrict || nonSimple) {
            useStrict = this.strictDirective(this.end);
            if (useStrict && nonSimple) {
              this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
            }
          }
          var oldLabels = this.labels;
          this.labels = [];
          if (useStrict) {
            this.strict = true;
          }
          this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
          if (this.strict && node.id) {
            this.checkLValSimple(node.id, BIND_OUTSIDE);
          }
          node.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
          node.expression = false;
          this.adaptDirectivePrologue(node.body.body);
          this.labels = oldLabels;
        }
        this.exitScope();
      };
      pp$5.isSimpleParamList = function(params) {
        for (var i2 = 0, list2 = params; i2 < list2.length; i2 += 1) {
          var param = list2[i2];
          if (param.type !== "Identifier") {
            return false;
          }
        }
        return true;
      };
      pp$5.checkParams = function(node, allowDuplicates) {
        var nameHash = /* @__PURE__ */ Object.create(null);
        for (var i2 = 0, list2 = node.params; i2 < list2.length; i2 += 1) {
          var param = list2[i2];
          this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
        }
      };
      pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
        var elts = [], first = true;
        while (!this.eat(close)) {
          if (!first) {
            this.expect(types$1.comma);
            if (allowTrailingComma && this.afterTrailingComma(close)) {
              break;
            }
          } else {
            first = false;
          }
          var elt = void 0;
          if (allowEmpty && this.type === types$1.comma) {
            elt = null;
          } else if (this.type === types$1.ellipsis) {
            elt = this.parseSpread(refDestructuringErrors);
            if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
              refDestructuringErrors.trailingComma = this.start;
            }
          } else {
            elt = this.parseMaybeAssign(false, refDestructuringErrors);
          }
          elts.push(elt);
        }
        return elts;
      };
      pp$5.checkUnreserved = function(ref2) {
        var start = ref2.start;
        var end = ref2.end;
        var name = ref2.name;
        if (this.inGenerator && name === "yield") {
          this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
        }
        if (this.inAsync && name === "await") {
          this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
        }
        if (this.currentThisScope().inClassFieldInit && name === "arguments") {
          this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
        }
        if (this.inClassStaticBlock && (name === "arguments" || name === "await")) {
          this.raise(start, "Cannot use " + name + " in class static initialization block");
        }
        if (this.keywords.test(name)) {
          this.raise(start, "Unexpected keyword '" + name + "'");
        }
        if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
          return;
        }
        var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
        if (re.test(name)) {
          if (!this.inAsync && name === "await") {
            this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
          }
          this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
        }
      };
      pp$5.parseIdent = function(liberal) {
        var node = this.parseIdentNode();
        this.next(!!liberal);
        this.finishNode(node, "Identifier");
        if (!liberal) {
          this.checkUnreserved(node);
          if (node.name === "await" && !this.awaitIdentPos) {
            this.awaitIdentPos = node.start;
          }
        }
        return node;
      };
      pp$5.parseIdentNode = function() {
        var node = this.startNode();
        if (this.type === types$1.name) {
          node.name = this.value;
        } else if (this.type.keyword) {
          node.name = this.type.keyword;
          if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
            this.context.pop();
          }
        } else {
          this.unexpected();
        }
        return node;
      };
      pp$5.parsePrivateIdent = function() {
        var node = this.startNode();
        if (this.type === types$1.privateId) {
          node.name = this.value;
        } else {
          this.unexpected();
        }
        this.next();
        this.finishNode(node, "PrivateIdentifier");
        if (this.options.checkPrivateFields) {
          if (this.privateNameStack.length === 0) {
            this.raise(node.start, "Private field '#" + node.name + "' must be declared in an enclosing class");
          } else {
            this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
          }
        }
        return node;
      };
      pp$5.parseYield = function(forInit) {
        if (!this.yieldPos) {
          this.yieldPos = this.start;
        }
        var node = this.startNode();
        this.next();
        if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
          node.delegate = false;
          node.argument = null;
        } else {
          node.delegate = this.eat(types$1.star);
          node.argument = this.parseMaybeAssign(forInit);
        }
        return this.finishNode(node, "YieldExpression");
      };
      pp$5.parseAwait = function(forInit) {
        if (!this.awaitPos) {
          this.awaitPos = this.start;
        }
        var node = this.startNode();
        this.next();
        node.argument = this.parseMaybeUnary(null, true, false, forInit);
        return this.finishNode(node, "AwaitExpression");
      };
      var pp$4 = Parser.prototype;
      pp$4.raise = function(pos, message) {
        var loc = getLineInfo(this.input, pos);
        message += " (" + loc.line + ":" + loc.column + ")";
        var err = new SyntaxError(message);
        err.pos = pos;
        err.loc = loc;
        err.raisedAt = this.pos;
        throw err;
      };
      pp$4.raiseRecoverable = pp$4.raise;
      pp$4.curPosition = function() {
        if (this.options.locations) {
          return new Position(this.curLine, this.pos - this.lineStart);
        }
      };
      var pp$3 = Parser.prototype;
      var Scope = function Scope2(flags) {
        this.flags = flags;
        this.var = [];
        this.lexical = [];
        this.functions = [];
        this.inClassFieldInit = false;
      };
      pp$3.enterScope = function(flags) {
        this.scopeStack.push(new Scope(flags));
      };
      pp$3.exitScope = function() {
        this.scopeStack.pop();
      };
      pp$3.treatFunctionsAsVarInScope = function(scope) {
        return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
      };
      pp$3.declareName = function(name, bindingType, pos) {
        var redeclared = false;
        if (bindingType === BIND_LEXICAL) {
          var scope = this.currentScope();
          redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
          scope.lexical.push(name);
          if (this.inModule && scope.flags & SCOPE_TOP) {
            delete this.undefinedExports[name];
          }
        } else if (bindingType === BIND_SIMPLE_CATCH) {
          var scope$1 = this.currentScope();
          scope$1.lexical.push(name);
        } else if (bindingType === BIND_FUNCTION) {
          var scope$2 = this.currentScope();
          if (this.treatFunctionsAsVar) {
            redeclared = scope$2.lexical.indexOf(name) > -1;
          } else {
            redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
          }
          scope$2.functions.push(name);
        } else {
          for (var i2 = this.scopeStack.length - 1; i2 >= 0; --i2) {
            var scope$3 = this.scopeStack[i2];
            if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
              redeclared = true;
              break;
            }
            scope$3.var.push(name);
            if (this.inModule && scope$3.flags & SCOPE_TOP) {
              delete this.undefinedExports[name];
            }
            if (scope$3.flags & SCOPE_VAR) {
              break;
            }
          }
        }
        if (redeclared) {
          this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
        }
      };
      pp$3.checkLocalExport = function(id) {
        if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
          this.undefinedExports[id.name] = id;
        }
      };
      pp$3.currentScope = function() {
        return this.scopeStack[this.scopeStack.length - 1];
      };
      pp$3.currentVarScope = function() {
        for (var i2 = this.scopeStack.length - 1; ; i2--) {
          var scope = this.scopeStack[i2];
          if (scope.flags & SCOPE_VAR) {
            return scope;
          }
        }
      };
      pp$3.currentThisScope = function() {
        for (var i2 = this.scopeStack.length - 1; ; i2--) {
          var scope = this.scopeStack[i2];
          if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) {
            return scope;
          }
        }
      };
      var Node = function Node2(parser, pos, loc) {
        this.type = "";
        this.start = pos;
        this.end = 0;
        if (parser.options.locations) {
          this.loc = new SourceLocation(parser, loc);
        }
        if (parser.options.directSourceFile) {
          this.sourceFile = parser.options.directSourceFile;
        }
        if (parser.options.ranges) {
          this.range = [pos, 0];
        }
      };
      var pp$2 = Parser.prototype;
      pp$2.startNode = function() {
        return new Node(this, this.start, this.startLoc);
      };
      pp$2.startNodeAt = function(pos, loc) {
        return new Node(this, pos, loc);
      };
      function finishNodeAt(node, type, pos, loc) {
        node.type = type;
        node.end = pos;
        if (this.options.locations) {
          node.loc.end = loc;
        }
        if (this.options.ranges) {
          node.range[1] = pos;
        }
        return node;
      }
      pp$2.finishNode = function(node, type) {
        return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
      };
      pp$2.finishNodeAt = function(node, type, pos, loc) {
        return finishNodeAt.call(this, node, type, pos, loc);
      };
      pp$2.copyNode = function(node) {
        var newNode = new Node(this, node.start, this.startLoc);
        for (var prop in node) {
          newNode[prop] = node[prop];
        }
        return newNode;
      };
      var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
      var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
      var ecma11BinaryProperties = ecma10BinaryProperties;
      var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
      var ecma13BinaryProperties = ecma12BinaryProperties;
      var ecma14BinaryProperties = ecma13BinaryProperties;
      var unicodeBinaryProperties = {
        9: ecma9BinaryProperties,
        10: ecma10BinaryProperties,
        11: ecma11BinaryProperties,
        12: ecma12BinaryProperties,
        13: ecma13BinaryProperties,
        14: ecma14BinaryProperties
      };
      var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
      var unicodeBinaryPropertiesOfStrings = {
        9: "",
        10: "",
        11: "",
        12: "",
        13: "",
        14: ecma14BinaryPropertiesOfStrings
      };
      var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
      var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
      var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
      var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
      var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
      var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
      var ecma14ScriptValues = ecma13ScriptValues + " Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz";
      var unicodeScriptValues = {
        9: ecma9ScriptValues,
        10: ecma10ScriptValues,
        11: ecma11ScriptValues,
        12: ecma12ScriptValues,
        13: ecma13ScriptValues,
        14: ecma14ScriptValues
      };
      var data = {};
      function buildUnicodeData(ecmaVersion2) {
        var d = data[ecmaVersion2] = {
          binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion2] + " " + unicodeGeneralCategoryValues),
          binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion2]),
          nonBinary: {
            General_Category: wordsRegexp(unicodeGeneralCategoryValues),
            Script: wordsRegexp(unicodeScriptValues[ecmaVersion2])
          }
        };
        d.nonBinary.Script_Extensions = d.nonBinary.Script;
        d.nonBinary.gc = d.nonBinary.General_Category;
        d.nonBinary.sc = d.nonBinary.Script;
        d.nonBinary.scx = d.nonBinary.Script_Extensions;
      }
      for (var i = 0, list = [9, 10, 11, 12, 13, 14]; i < list.length; i += 1) {
        var ecmaVersion = list[i];
        buildUnicodeData(ecmaVersion);
      }
      var pp$1 = Parser.prototype;
      var RegExpValidationState = function RegExpValidationState2(parser) {
        this.parser = parser;
        this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
        this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
        this.source = "";
        this.flags = "";
        this.start = 0;
        this.switchU = false;
        this.switchV = false;
        this.switchN = false;
        this.pos = 0;
        this.lastIntValue = 0;
        this.lastStringValue = "";
        this.lastAssertionIsQuantifiable = false;
        this.numCapturingParens = 0;
        this.maxBackReference = 0;
        this.groupNames = [];
        this.backReferenceNames = [];
      };
      RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
        var unicodeSets = flags.indexOf("v") !== -1;
        var unicode = flags.indexOf("u") !== -1;
        this.start = start | 0;
        this.source = pattern + "";
        this.flags = flags;
        if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
          this.switchU = true;
          this.switchV = true;
          this.switchN = true;
        } else {
          this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
          this.switchV = false;
          this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
        }
      };
      RegExpValidationState.prototype.raise = function raise(message) {
        this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
      };
      RegExpValidationState.prototype.at = function at(i2, forceU) {
        if (forceU === void 0)
          forceU = false;
        var s = this.source;
        var l = s.length;
        if (i2 >= l) {
          return -1;
        }
        var c = s.charCodeAt(i2);
        if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i2 + 1 >= l) {
          return c;
        }
        var next = s.charCodeAt(i2 + 1);
        return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
      };
      RegExpValidationState.prototype.nextIndex = function nextIndex(i2, forceU) {
        if (forceU === void 0)
          forceU = false;
        var s = this.source;
        var l = s.length;
        if (i2 >= l) {
          return l;
        }
        var c = s.charCodeAt(i2), next;
        if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i2 + 1 >= l || (next = s.charCodeAt(i2 + 1)) < 56320 || next > 57343) {
          return i2 + 1;
        }
        return i2 + 2;
      };
      RegExpValidationState.prototype.current = function current(forceU) {
        if (forceU === void 0)
          forceU = false;
        return this.at(this.pos, forceU);
      };
      RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
        if (forceU === void 0)
          forceU = false;
        return this.at(this.nextIndex(this.pos, forceU), forceU);
      };
      RegExpValidationState.prototype.advance = function advance(forceU) {
        if (forceU === void 0)
          forceU = false;
        this.pos = this.nextIndex(this.pos, forceU);
      };
      RegExpValidationState.prototype.eat = function eat(ch, forceU) {
        if (forceU === void 0)
          forceU = false;
        if (this.current(forceU) === ch) {
          this.advance(forceU);
          return true;
        }
        return false;
      };
      RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {
        if (forceU === void 0)
          forceU = false;
        var pos = this.pos;
        for (var i2 = 0, list2 = chs; i2 < list2.length; i2 += 1) {
          var ch = list2[i2];
          var current = this.at(pos, forceU);
          if (current === -1 || current !== ch) {
            return false;
          }
          pos = this.nextIndex(pos, forceU);
        }
        this.pos = pos;
        return true;
      };
      pp$1.validateRegExpFlags = function(state) {
        var validFlags = state.validFlags;
        var flags = state.flags;
        var u = false;
        var v = false;
        for (var i2 = 0; i2 < flags.length; i2++) {
          var flag = flags.charAt(i2);
          if (validFlags.indexOf(flag) === -1) {
            this.raise(state.start, "Invalid regular expression flag");
          }
          if (flags.indexOf(flag, i2 + 1) > -1) {
            this.raise(state.start, "Duplicate regular expression flag");
          }
          if (flag === "u") {
            u = true;
          }
          if (flag === "v") {
            v = true;
          }
        }
        if (this.options.ecmaVersion >= 15 && u && v) {
          this.raise(state.start, "Invalid regular expression flag");
        }
      };
      pp$1.validateRegExpPattern = function(state) {
        this.regexp_pattern(state);
        if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
          state.switchN = true;
          this.regexp_pattern(state);
        }
      };
      pp$1.regexp_pattern = function(state) {
        state.pos = 0;
        state.lastIntValue = 0;
        state.lastStringValue = "";
        state.lastAssertionIsQuantifiable = false;
        state.numCapturingParens = 0;
        state.maxBackReference = 0;
        state.groupNames.length = 0;
        state.backReferenceNames.length = 0;
        this.regexp_disjunction(state);
        if (state.pos !== state.source.length) {
          if (state.eat(
            41
            /* ) */
          )) {
            state.raise("Unmatched ')'");
          }
          if (state.eat(
            93
            /* ] */
          ) || state.eat(
            125
            /* } */
          )) {
            state.raise("Lone quantifier brackets");
          }
        }
        if (state.maxBackReference > state.numCapturingParens) {
          state.raise("Invalid escape");
        }
        for (var i2 = 0, list2 = state.backReferenceNames; i2 < list2.length; i2 += 1) {
          var name = list2[i2];
          if (state.groupNames.indexOf(name) === -1) {
            state.raise("Invalid named capture referenced");
          }
        }
      };
      pp$1.regexp_disjunction = function(state) {
        this.regexp_alternative(state);
        while (state.eat(
          124
          /* | */
        )) {
          this.regexp_alternative(state);
        }
        if (this.regexp_eatQuantifier(state, true)) {
          state.raise("Nothing to repeat");
        }
        if (state.eat(
          123
          /* { */
        )) {
          state.raise("Lone quantifier brackets");
        }
      };
      pp$1.regexp_alternative = function(state) {
        while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
        }
      };
      pp$1.regexp_eatTerm = function(state) {
        if (this.regexp_eatAssertion(state)) {
          if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
            if (state.switchU) {
              state.raise("Invalid quantifier");
            }
          }
          return true;
        }
        if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
          this.regexp_eatQuantifier(state);
          return true;
        }
        return false;
      };
      pp$1.regexp_eatAssertion = function(state) {
        var start = state.pos;
        state.lastAssertionIsQuantifiable = false;
        if (state.eat(
          94
          /* ^ */
        ) || state.eat(
          36
          /* $ */
        )) {
          return true;
        }
        if (state.eat(
          92
          /* \ */
        )) {
          if (state.eat(
            66
            /* B */
          ) || state.eat(
            98
            /* b */
          )) {
            return true;
          }
          state.pos = start;
        }
        if (state.eat(
          40
          /* ( */
        ) && state.eat(
          63
          /* ? */
        )) {
          var lookbehind = false;
          if (this.options.ecmaVersion >= 9) {
            lookbehind = state.eat(
              60
              /* < */
            );
          }
          if (state.eat(
            61
            /* = */
          ) || state.eat(
            33
            /* ! */
          )) {
            this.regexp_disjunction(state);
            if (!state.eat(
              41
              /* ) */
            )) {
              state.raise("Unterminated group");
            }
            state.lastAssertionIsQuantifiable = !lookbehind;
            return true;
          }
        }
        state.pos = start;
        return false;
      };
      pp$1.regexp_eatQuantifier = function(state, noError) {
        if (noError === void 0)
          noError = false;
        if (this.regexp_eatQuantifierPrefix(state, noError)) {
          state.eat(
            63
            /* ? */
          );
          return true;
        }
        return false;
      };
      pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
        return state.eat(
          42
          /* * */
        ) || state.eat(
          43
          /* + */
        ) || state.eat(
          63
          /* ? */
        ) || this.regexp_eatBracedQuantifier(state, noError);
      };
      pp$1.regexp_eatBracedQuantifier = function(state, noError) {
        var start = state.pos;
        if (state.eat(
          123
          /* { */
        )) {
          var min = 0, max = -1;
          if (this.regexp_eatDecimalDigits(state)) {
            min = state.lastIntValue;
            if (state.eat(
              44
              /* , */
            ) && this.regexp_eatDecimalDigits(state)) {
              max = state.lastIntValue;
            }
            if (state.eat(
              125
              /* } */
            )) {
              if (max !== -1 && max < min && !noError) {
                state.raise("numbers out of order in {} quantifier");
              }
              return true;
            }
          }
          if (state.switchU && !noError) {
            state.raise("Incomplete quantifier");
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatAtom = function(state) {
        return this.regexp_eatPatternCharacters(state) || state.eat(
          46
          /* . */
        ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
      };
      pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
        var start = state.pos;
        if (state.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatAtomEscape(state)) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatUncapturingGroup = function(state) {
        var start = state.pos;
        if (state.eat(
          40
          /* ( */
        )) {
          if (state.eat(
            63
            /* ? */
          ) && state.eat(
            58
            /* : */
          )) {
            this.regexp_disjunction(state);
            if (state.eat(
              41
              /* ) */
            )) {
              return true;
            }
            state.raise("Unterminated group");
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatCapturingGroup = function(state) {
        if (state.eat(
          40
          /* ( */
        )) {
          if (this.options.ecmaVersion >= 9) {
            this.regexp_groupSpecifier(state);
          } else if (state.current() === 63) {
            state.raise("Invalid group");
          }
          this.regexp_disjunction(state);
          if (state.eat(
            41
            /* ) */
          )) {
            state.numCapturingParens += 1;
            return true;
          }
          state.raise("Unterminated group");
        }
        return false;
      };
      pp$1.regexp_eatExtendedAtom = function(state) {
        return state.eat(
          46
          /* . */
        ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
      };
      pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
        if (this.regexp_eatBracedQuantifier(state, true)) {
          state.raise("Nothing to repeat");
        }
        return false;
      };
      pp$1.regexp_eatSyntaxCharacter = function(state) {
        var ch = state.current();
        if (isSyntaxCharacter(ch)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      function isSyntaxCharacter(ch) {
        return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
      }
      pp$1.regexp_eatPatternCharacters = function(state) {
        var start = state.pos;
        var ch = 0;
        while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
          state.advance();
        }
        return state.pos !== start;
      };
      pp$1.regexp_eatExtendedPatternCharacter = function(state) {
        var ch = state.current();
        if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_groupSpecifier = function(state) {
        if (state.eat(
          63
          /* ? */
        )) {
          if (this.regexp_eatGroupName(state)) {
            if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
              state.raise("Duplicate capture group name");
            }
            state.groupNames.push(state.lastStringValue);
            return;
          }
          state.raise("Invalid group");
        }
      };
      pp$1.regexp_eatGroupName = function(state) {
        state.lastStringValue = "";
        if (state.eat(
          60
          /* < */
        )) {
          if (this.regexp_eatRegExpIdentifierName(state) && state.eat(
            62
            /* > */
          )) {
            return true;
          }
          state.raise("Invalid capture group name");
        }
        return false;
      };
      pp$1.regexp_eatRegExpIdentifierName = function(state) {
        state.lastStringValue = "";
        if (this.regexp_eatRegExpIdentifierStart(state)) {
          state.lastStringValue += codePointToString(state.lastIntValue);
          while (this.regexp_eatRegExpIdentifierPart(state)) {
            state.lastStringValue += codePointToString(state.lastIntValue);
          }
          return true;
        }
        return false;
      };
      pp$1.regexp_eatRegExpIdentifierStart = function(state) {
        var start = state.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state.current(forceU);
        state.advance(forceU);
        if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
          ch = state.lastIntValue;
        }
        if (isRegExpIdentifierStart(ch)) {
          state.lastIntValue = ch;
          return true;
        }
        state.pos = start;
        return false;
      };
      function isRegExpIdentifierStart(ch) {
        return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
      }
      pp$1.regexp_eatRegExpIdentifierPart = function(state) {
        var start = state.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state.current(forceU);
        state.advance(forceU);
        if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
          ch = state.lastIntValue;
        }
        if (isRegExpIdentifierPart(ch)) {
          state.lastIntValue = ch;
          return true;
        }
        state.pos = start;
        return false;
      };
      function isRegExpIdentifierPart(ch) {
        return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
      }
      pp$1.regexp_eatAtomEscape = function(state) {
        if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
          return true;
        }
        if (state.switchU) {
          if (state.current() === 99) {
            state.raise("Invalid unicode escape");
          }
          state.raise("Invalid escape");
        }
        return false;
      };
      pp$1.regexp_eatBackReference = function(state) {
        var start = state.pos;
        if (this.regexp_eatDecimalEscape(state)) {
          var n = state.lastIntValue;
          if (state.switchU) {
            if (n > state.maxBackReference) {
              state.maxBackReference = n;
            }
            return true;
          }
          if (n <= state.numCapturingParens) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatKGroupName = function(state) {
        if (state.eat(
          107
          /* k */
        )) {
          if (this.regexp_eatGroupName(state)) {
            state.backReferenceNames.push(state.lastStringValue);
            return true;
          }
          state.raise("Invalid named reference");
        }
        return false;
      };
      pp$1.regexp_eatCharacterEscape = function(state) {
        return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
      };
      pp$1.regexp_eatCControlLetter = function(state) {
        var start = state.pos;
        if (state.eat(
          99
          /* c */
        )) {
          if (this.regexp_eatControlLetter(state)) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatZero = function(state) {
        if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
          state.lastIntValue = 0;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatControlEscape = function(state) {
        var ch = state.current();
        if (ch === 116) {
          state.lastIntValue = 9;
          state.advance();
          return true;
        }
        if (ch === 110) {
          state.lastIntValue = 10;
          state.advance();
          return true;
        }
        if (ch === 118) {
          state.lastIntValue = 11;
          state.advance();
          return true;
        }
        if (ch === 102) {
          state.lastIntValue = 12;
          state.advance();
          return true;
        }
        if (ch === 114) {
          state.lastIntValue = 13;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatControlLetter = function(state) {
        var ch = state.current();
        if (isControlLetter(ch)) {
          state.lastIntValue = ch % 32;
          state.advance();
          return true;
        }
        return false;
      };
      function isControlLetter(ch) {
        return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
      }
      pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
        if (forceU === void 0)
          forceU = false;
        var start = state.pos;
        var switchU = forceU || state.switchU;
        if (state.eat(
          117
          /* u */
        )) {
          if (this.regexp_eatFixedHexDigits(state, 4)) {
            var lead = state.lastIntValue;
            if (switchU && lead >= 55296 && lead <= 56319) {
              var leadSurrogateEnd = state.pos;
              if (state.eat(
                92
                /* \ */
              ) && state.eat(
                117
                /* u */
              ) && this.regexp_eatFixedHexDigits(state, 4)) {
                var trail = state.lastIntValue;
                if (trail >= 56320 && trail <= 57343) {
                  state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
                  return true;
                }
              }
              state.pos = leadSurrogateEnd;
              state.lastIntValue = lead;
            }
            return true;
          }
          if (switchU && state.eat(
            123
            /* { */
          ) && this.regexp_eatHexDigits(state) && state.eat(
            125
            /* } */
          ) && isValidUnicode(state.lastIntValue)) {
            return true;
          }
          if (switchU) {
            state.raise("Invalid unicode escape");
          }
          state.pos = start;
        }
        return false;
      };
      function isValidUnicode(ch) {
        return ch >= 0 && ch <= 1114111;
      }
      pp$1.regexp_eatIdentityEscape = function(state) {
        if (state.switchU) {
          if (this.regexp_eatSyntaxCharacter(state)) {
            return true;
          }
          if (state.eat(
            47
            /* / */
          )) {
            state.lastIntValue = 47;
            return true;
          }
          return false;
        }
        var ch = state.current();
        if (ch !== 99 && (!state.switchN || ch !== 107)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatDecimalEscape = function(state) {
        state.lastIntValue = 0;
        var ch = state.current();
        if (ch >= 49 && ch <= 57) {
          do {
            state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
            state.advance();
          } while ((ch = state.current()) >= 48 && ch <= 57);
          return true;
        }
        return false;
      };
      var CharSetNone = 0;
      var CharSetOk = 1;
      var CharSetString = 2;
      pp$1.regexp_eatCharacterClassEscape = function(state) {
        var ch = state.current();
        if (isCharacterClassEscape(ch)) {
          state.lastIntValue = -1;
          state.advance();
          return CharSetOk;
        }
        var negate = false;
        if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 80) || ch === 112)) {
          state.lastIntValue = -1;
          state.advance();
          var result;
          if (state.eat(
            123
            /* { */
          ) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(
            125
            /* } */
          )) {
            if (negate && result === CharSetString) {
              state.raise("Invalid property name");
            }
            return result;
          }
          state.raise("Invalid property name");
        }
        return CharSetNone;
      };
      function isCharacterClassEscape(ch) {
        return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
      }
      pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
        var start = state.pos;
        if (this.regexp_eatUnicodePropertyName(state) && state.eat(
          61
          /* = */
        )) {
          var name = state.lastStringValue;
          if (this.regexp_eatUnicodePropertyValue(state)) {
            var value = state.lastStringValue;
            this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
            return CharSetOk;
          }
        }
        state.pos = start;
        if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
          var nameOrValue = state.lastStringValue;
          return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
        }
        return CharSetNone;
      };
      pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
        if (!hasOwn(state.unicodeProperties.nonBinary, name)) {
          state.raise("Invalid property name");
        }
        if (!state.unicodeProperties.nonBinary[name].test(value)) {
          state.raise("Invalid property value");
        }
      };
      pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
        if (state.unicodeProperties.binary.test(nameOrValue)) {
          return CharSetOk;
        }
        if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {
          return CharSetString;
        }
        state.raise("Invalid property name");
      };
      pp$1.regexp_eatUnicodePropertyName = function(state) {
        var ch = 0;
        state.lastStringValue = "";
        while (isUnicodePropertyNameCharacter(ch = state.current())) {
          state.lastStringValue += codePointToString(ch);
          state.advance();
        }
        return state.lastStringValue !== "";
      };
      function isUnicodePropertyNameCharacter(ch) {
        return isControlLetter(ch) || ch === 95;
      }
      pp$1.regexp_eatUnicodePropertyValue = function(state) {
        var ch = 0;
        state.lastStringValue = "";
        while (isUnicodePropertyValueCharacter(ch = state.current())) {
          state.lastStringValue += codePointToString(ch);
          state.advance();
        }
        return state.lastStringValue !== "";
      };
      function isUnicodePropertyValueCharacter(ch) {
        return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
      }
      pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
        return this.regexp_eatUnicodePropertyValue(state);
      };
      pp$1.regexp_eatCharacterClass = function(state) {
        if (state.eat(
          91
          /* [ */
        )) {
          var negate = state.eat(
            94
            /* ^ */
          );
          var result = this.regexp_classContents(state);
          if (!state.eat(
            93
            /* ] */
          )) {
            state.raise("Unterminated character class");
          }
          if (negate && result === CharSetString) {
            state.raise("Negated character class may contain strings");
          }
          return true;
        }
        return false;
      };
      pp$1.regexp_classContents = function(state) {
        if (state.current() === 93) {
          return CharSetOk;
        }
        if (state.switchV) {
          return this.regexp_classSetExpression(state);
        }
        this.regexp_nonEmptyClassRanges(state);
        return CharSetOk;
      };
      pp$1.regexp_nonEmptyClassRanges = function(state) {
        while (this.regexp_eatClassAtom(state)) {
          var left = state.lastIntValue;
          if (state.eat(
            45
            /* - */
          ) && this.regexp_eatClassAtom(state)) {
            var right = state.lastIntValue;
            if (state.switchU && (left === -1 || right === -1)) {
              state.raise("Invalid character class");
            }
            if (left !== -1 && right !== -1 && left > right) {
              state.raise("Range out of order in character class");
            }
          }
        }
      };
      pp$1.regexp_eatClassAtom = function(state) {
        var start = state.pos;
        if (state.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatClassEscape(state)) {
            return true;
          }
          if (state.switchU) {
            var ch$1 = state.current();
            if (ch$1 === 99 || isOctalDigit(ch$1)) {
              state.raise("Invalid class escape");
            }
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        var ch = state.current();
        if (ch !== 93) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatClassEscape = function(state) {
        var start = state.pos;
        if (state.eat(
          98
          /* b */
        )) {
          state.lastIntValue = 8;
          return true;
        }
        if (state.switchU && state.eat(
          45
          /* - */
        )) {
          state.lastIntValue = 45;
          return true;
        }
        if (!state.switchU && state.eat(
          99
          /* c */
        )) {
          if (this.regexp_eatClassControlLetter(state)) {
            return true;
          }
          state.pos = start;
        }
        return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
      };
      pp$1.regexp_classSetExpression = function(state) {
        var result = CharSetOk, subResult;
        if (this.regexp_eatClassSetRange(state))
          ;
        else if (subResult = this.regexp_eatClassSetOperand(state)) {
          if (subResult === CharSetString) {
            result = CharSetString;
          }
          var start = state.pos;
          while (state.eatChars(
            [38, 38]
            /* && */
          )) {
            if (state.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state))) {
              if (subResult !== CharSetString) {
                result = CharSetOk;
              }
              continue;
            }
            state.raise("Invalid character in character class");
          }
          if (start !== state.pos) {
            return result;
          }
          while (state.eatChars(
            [45, 45]
            /* -- */
          )) {
            if (this.regexp_eatClassSetOperand(state)) {
              continue;
            }
            state.raise("Invalid character in character class");
          }
          if (start !== state.pos) {
            return result;
          }
        } else {
          state.raise("Invalid character in character class");
        }
        for (; ; ) {
          if (this.regexp_eatClassSetRange(state)) {
            continue;
          }
          subResult = this.regexp_eatClassSetOperand(state);
          if (!subResult) {
            return result;
          }
          if (subResult === CharSetString) {
            result = CharSetString;
          }
        }
      };
      pp$1.regexp_eatClassSetRange = function(state) {
        var start = state.pos;
        if (this.regexp_eatClassSetCharacter(state)) {
          var left = state.lastIntValue;
          if (state.eat(
            45
            /* - */
          ) && this.regexp_eatClassSetCharacter(state)) {
            var right = state.lastIntValue;
            if (left !== -1 && right !== -1 && left > right) {
              state.raise("Range out of order in character class");
            }
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatClassSetOperand = function(state) {
        if (this.regexp_eatClassSetCharacter(state)) {
          return CharSetOk;
        }
        return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
      };
      pp$1.regexp_eatNestedClass = function(state) {
        var start = state.pos;
        if (state.eat(
          91
          /* [ */
        )) {
          var negate = state.eat(
            94
            /* ^ */
          );
          var result = this.regexp_classContents(state);
          if (state.eat(
            93
            /* ] */
          )) {
            if (negate && result === CharSetString) {
              state.raise("Negated character class may contain strings");
            }
            return result;
          }
          state.pos = start;
        }
        if (state.eat(
          92
          /* \ */
        )) {
          var result$1 = this.regexp_eatCharacterClassEscape(state);
          if (result$1) {
            return result$1;
          }
          state.pos = start;
        }
        return null;
      };
      pp$1.regexp_eatClassStringDisjunction = function(state) {
        var start = state.pos;
        if (state.eatChars(
          [92, 113]
          /* \q */
        )) {
          if (state.eat(
            123
            /* { */
          )) {
            var result = this.regexp_classStringDisjunctionContents(state);
            if (state.eat(
              125
              /* } */
            )) {
              return result;
            }
          } else {
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        return null;
      };
      pp$1.regexp_classStringDisjunctionContents = function(state) {
        var result = this.regexp_classString(state);
        while (state.eat(
          124
          /* | */
        )) {
          if (this.regexp_classString(state) === CharSetString) {
            result = CharSetString;
          }
        }
        return result;
      };
      pp$1.regexp_classString = function(state) {
        var count = 0;
        while (this.regexp_eatClassSetCharacter(state)) {
          count++;
        }
        return count === 1 ? CharSetOk : CharSetString;
      };
      pp$1.regexp_eatClassSetCharacter = function(state) {
        var start = state.pos;
        if (state.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {
            return true;
          }
          if (state.eat(
            98
            /* b */
          )) {
            state.lastIntValue = 8;
            return true;
          }
          state.pos = start;
          return false;
        }
        var ch = state.current();
        if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) {
          return false;
        }
        if (isClassSetSyntaxCharacter(ch)) {
          return false;
        }
        state.advance();
        state.lastIntValue = ch;
        return true;
      };
      function isClassSetReservedDoublePunctuatorCharacter(ch) {
        return ch === 33 || ch >= 35 && ch <= 38 || ch >= 42 && ch <= 44 || ch === 46 || ch >= 58 && ch <= 64 || ch === 94 || ch === 96 || ch === 126;
      }
      function isClassSetSyntaxCharacter(ch) {
        return ch === 40 || ch === 41 || ch === 45 || ch === 47 || ch >= 91 && ch <= 93 || ch >= 123 && ch <= 125;
      }
      pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
        var ch = state.current();
        if (isClassSetReservedPunctuator(ch)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      function isClassSetReservedPunctuator(ch) {
        return ch === 33 || ch === 35 || ch === 37 || ch === 38 || ch === 44 || ch === 45 || ch >= 58 && ch <= 62 || ch === 64 || ch === 96 || ch === 126;
      }
      pp$1.regexp_eatClassControlLetter = function(state) {
        var ch = state.current();
        if (isDecimalDigit(ch) || ch === 95) {
          state.lastIntValue = ch % 32;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatHexEscapeSequence = function(state) {
        var start = state.pos;
        if (state.eat(
          120
          /* x */
        )) {
          if (this.regexp_eatFixedHexDigits(state, 2)) {
            return true;
          }
          if (state.switchU) {
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatDecimalDigits = function(state) {
        var start = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while (isDecimalDigit(ch = state.current())) {
          state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
          state.advance();
        }
        return state.pos !== start;
      };
      function isDecimalDigit(ch) {
        return ch >= 48 && ch <= 57;
      }
      pp$1.regexp_eatHexDigits = function(state) {
        var start = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while (isHexDigit(ch = state.current())) {
          state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
          state.advance();
        }
        return state.pos !== start;
      };
      function isHexDigit(ch) {
        return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
      }
      function hexToInt(ch) {
        if (ch >= 65 && ch <= 70) {
          return 10 + (ch - 65);
        }
        if (ch >= 97 && ch <= 102) {
          return 10 + (ch - 97);
        }
        return ch - 48;
      }
      pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
        if (this.regexp_eatOctalDigit(state)) {
          var n1 = state.lastIntValue;
          if (this.regexp_eatOctalDigit(state)) {
            var n2 = state.lastIntValue;
            if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
              state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
            } else {
              state.lastIntValue = n1 * 8 + n2;
            }
          } else {
            state.lastIntValue = n1;
          }
          return true;
        }
        return false;
      };
      pp$1.regexp_eatOctalDigit = function(state) {
        var ch = state.current();
        if (isOctalDigit(ch)) {
          state.lastIntValue = ch - 48;
          state.advance();
          return true;
        }
        state.lastIntValue = 0;
        return false;
      };
      function isOctalDigit(ch) {
        return ch >= 48 && ch <= 55;
      }
      pp$1.regexp_eatFixedHexDigits = function(state, length) {
        var start = state.pos;
        state.lastIntValue = 0;
        for (var i2 = 0; i2 < length; ++i2) {
          var ch = state.current();
          if (!isHexDigit(ch)) {
            state.pos = start;
            return false;
          }
          state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
          state.advance();
        }
        return true;
      };
      var Token = function Token2(p) {
        this.type = p.type;
        this.value = p.value;
        this.start = p.start;
        this.end = p.end;
        if (p.options.locations) {
          this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
        }
        if (p.options.ranges) {
          this.range = [p.start, p.end];
        }
      };
      var pp = Parser.prototype;
      pp.next = function(ignoreEscapeSequenceInKeyword) {
        if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
        }
        if (this.options.onToken) {
          this.options.onToken(new Token(this));
        }
        this.lastTokEnd = this.end;
        this.lastTokStart = this.start;
        this.lastTokEndLoc = this.endLoc;
        this.lastTokStartLoc = this.startLoc;
        this.nextToken();
      };
      pp.getToken = function() {
        this.next();
        return new Token(this);
      };
      if (typeof Symbol !== "undefined") {
        pp[Symbol.iterator] = function() {
          var this$1$1 = this;
          return {
            next: function() {
              var token = this$1$1.getToken();
              return {
                done: token.type === types$1.eof,
                value: token
              };
            }
          };
        };
      }
      pp.nextToken = function() {
        var curContext = this.curContext();
        if (!curContext || !curContext.preserveSpace) {
          this.skipSpace();
        }
        this.start = this.pos;
        if (this.options.locations) {
          this.startLoc = this.curPosition();
        }
        if (this.pos >= this.input.length) {
          return this.finishToken(types$1.eof);
        }
        if (curContext.override) {
          return curContext.override(this);
        } else {
          this.readToken(this.fullCharCodeAtPos());
        }
      };
      pp.readToken = function(code) {
        if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92) {
          return this.readWord();
        }
        return this.getTokenFromCode(code);
      };
      pp.fullCharCodeAtPos = function() {
        var code = this.input.charCodeAt(this.pos);
        if (code <= 55295 || code >= 56320) {
          return code;
        }
        var next = this.input.charCodeAt(this.pos + 1);
        return next <= 56319 || next >= 57344 ? code : (code << 10) + next - 56613888;
      };
      pp.skipBlockComment = function() {
        var startLoc = this.options.onComment && this.curPosition();
        var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
        if (end === -1) {
          this.raise(this.pos - 2, "Unterminated comment");
        }
        this.pos = end + 2;
        if (this.options.locations) {
          for (var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1; ) {
            ++this.curLine;
            pos = this.lineStart = nextBreak;
          }
        }
        if (this.options.onComment) {
          this.options.onComment(
            true,
            this.input.slice(start + 2, end),
            start,
            this.pos,
            startLoc,
            this.curPosition()
          );
        }
      };
      pp.skipLineComment = function(startSkip) {
        var start = this.pos;
        var startLoc = this.options.onComment && this.curPosition();
        var ch = this.input.charCodeAt(this.pos += startSkip);
        while (this.pos < this.input.length && !isNewLine(ch)) {
          ch = this.input.charCodeAt(++this.pos);
        }
        if (this.options.onComment) {
          this.options.onComment(
            false,
            this.input.slice(start + startSkip, this.pos),
            start,
            this.pos,
            startLoc,
            this.curPosition()
          );
        }
      };
      pp.skipSpace = function() {
        loop:
          while (this.pos < this.input.length) {
            var ch = this.input.charCodeAt(this.pos);
            switch (ch) {
              case 32:
              case 160:
                ++this.pos;
                break;
              case 13:
                if (this.input.charCodeAt(this.pos + 1) === 10) {
                  ++this.pos;
                }
              case 10:
              case 8232:
              case 8233:
                ++this.pos;
                if (this.options.locations) {
                  ++this.curLine;
                  this.lineStart = this.pos;
                }
                break;
              case 47:
                switch (this.input.charCodeAt(this.pos + 1)) {
                  case 42:
                    this.skipBlockComment();
                    break;
                  case 47:
                    this.skipLineComment(2);
                    break;
                  default:
                    break loop;
                }
                break;
              default:
                if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
                  ++this.pos;
                } else {
                  break loop;
                }
            }
          }
      };
      pp.finishToken = function(type, val) {
        this.end = this.pos;
        if (this.options.locations) {
          this.endLoc = this.curPosition();
        }
        var prevType = this.type;
        this.type = type;
        this.value = val;
        this.updateContext(prevType);
      };
      pp.readToken_dot = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next >= 48 && next <= 57) {
          return this.readNumber(true);
        }
        var next2 = this.input.charCodeAt(this.pos + 2);
        if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
          this.pos += 3;
          return this.finishToken(types$1.ellipsis);
        } else {
          ++this.pos;
          return this.finishToken(types$1.dot);
        }
      };
      pp.readToken_slash = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (this.exprAllowed) {
          ++this.pos;
          return this.readRegexp();
        }
        if (next === 61) {
          return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(types$1.slash, 1);
      };
      pp.readToken_mult_modulo_exp = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        var tokentype = code === 42 ? types$1.star : types$1.modulo;
        if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
          ++size;
          tokentype = types$1.starstar;
          next = this.input.charCodeAt(this.pos + 2);
        }
        if (next === 61) {
          return this.finishOp(types$1.assign, size + 1);
        }
        return this.finishOp(tokentype, size);
      };
      pp.readToken_pipe_amp = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code) {
          if (this.options.ecmaVersion >= 12) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 === 61) {
              return this.finishOp(types$1.assign, 3);
            }
          }
          return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
        }
        if (next === 61) {
          return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
      };
      pp.readToken_caret = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) {
          return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(types$1.bitwiseXOR, 1);
      };
      pp.readToken_plus_min = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code) {
          if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
            this.skipLineComment(3);
            this.skipSpace();
            return this.nextToken();
          }
          return this.finishOp(types$1.incDec, 2);
        }
        if (next === 61) {
          return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(types$1.plusMin, 1);
      };
      pp.readToken_lt_gt = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        if (next === code) {
          size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
          if (this.input.charCodeAt(this.pos + size) === 61) {
            return this.finishOp(types$1.assign, size + 1);
          }
          return this.finishOp(types$1.bitShift, size);
        }
        if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
          this.skipLineComment(4);
          this.skipSpace();
          return this.nextToken();
        }
        if (next === 61) {
          size = 2;
        }
        return this.finishOp(types$1.relational, size);
      };
      pp.readToken_eq_excl = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) {
          return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
        }
        if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
          this.pos += 2;
          return this.finishToken(types$1.arrow);
        }
        return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);
      };
      pp.readToken_question = function() {
        var ecmaVersion2 = this.options.ecmaVersion;
        if (ecmaVersion2 >= 11) {
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 46) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 < 48 || next2 > 57) {
              return this.finishOp(types$1.questionDot, 2);
            }
          }
          if (next === 63) {
            if (ecmaVersion2 >= 12) {
              var next2$1 = this.input.charCodeAt(this.pos + 2);
              if (next2$1 === 61) {
                return this.finishOp(types$1.assign, 3);
              }
            }
            return this.finishOp(types$1.coalesce, 2);
          }
        }
        return this.finishOp(types$1.question, 1);
      };
      pp.readToken_numberSign = function() {
        var ecmaVersion2 = this.options.ecmaVersion;
        var code = 35;
        if (ecmaVersion2 >= 13) {
          ++this.pos;
          code = this.fullCharCodeAtPos();
          if (isIdentifierStart(code, true) || code === 92) {
            return this.finishToken(types$1.privateId, this.readWord1());
          }
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
      };
      pp.getTokenFromCode = function(code) {
        switch (code) {
          case 46:
            return this.readToken_dot();
          case 40:
            ++this.pos;
            return this.finishToken(types$1.parenL);
          case 41:
            ++this.pos;
            return this.finishToken(types$1.parenR);
          case 59:
            ++this.pos;
            return this.finishToken(types$1.semi);
          case 44:
            ++this.pos;
            return this.finishToken(types$1.comma);
          case 91:
            ++this.pos;
            return this.finishToken(types$1.bracketL);
          case 93:
            ++this.pos;
            return this.finishToken(types$1.bracketR);
          case 123:
            ++this.pos;
            return this.finishToken(types$1.braceL);
          case 125:
            ++this.pos;
            return this.finishToken(types$1.braceR);
          case 58:
            ++this.pos;
            return this.finishToken(types$1.colon);
          case 96:
            if (this.options.ecmaVersion < 6) {
              break;
            }
            ++this.pos;
            return this.finishToken(types$1.backQuote);
          case 48:
            var next = this.input.charCodeAt(this.pos + 1);
            if (next === 120 || next === 88) {
              return this.readRadixNumber(16);
            }
            if (this.options.ecmaVersion >= 6) {
              if (next === 111 || next === 79) {
                return this.readRadixNumber(8);
              }
              if (next === 98 || next === 66) {
                return this.readRadixNumber(2);
              }
            }
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            return this.readNumber(false);
          case 34:
          case 39:
            return this.readString(code);
          case 47:
            return this.readToken_slash();
          case 37:
          case 42:
            return this.readToken_mult_modulo_exp(code);
          case 124:
          case 38:
            return this.readToken_pipe_amp(code);
          case 94:
            return this.readToken_caret();
          case 43:
          case 45:
            return this.readToken_plus_min(code);
          case 60:
          case 62:
            return this.readToken_lt_gt(code);
          case 61:
          case 33:
            return this.readToken_eq_excl(code);
          case 63:
            return this.readToken_question();
          case 126:
            return this.finishOp(types$1.prefix, 1);
          case 35:
            return this.readToken_numberSign();
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
      };
      pp.finishOp = function(type, size) {
        var str = this.input.slice(this.pos, this.pos + size);
        this.pos += size;
        return this.finishToken(type, str);
      };
      pp.readRegexp = function() {
        var escaped, inClass, start = this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(start, "Unterminated regular expression");
          }
          var ch = this.input.charAt(this.pos);
          if (lineBreak.test(ch)) {
            this.raise(start, "Unterminated regular expression");
          }
          if (!escaped) {
            if (ch === "[") {
              inClass = true;
            } else if (ch === "]" && inClass) {
              inClass = false;
            } else if (ch === "/" && !inClass) {
              break;
            }
            escaped = ch === "\\";
          } else {
            escaped = false;
          }
          ++this.pos;
        }
        var pattern = this.input.slice(start, this.pos);
        ++this.pos;
        var flagsStart = this.pos;
        var flags = this.readWord1();
        if (this.containsEsc) {
          this.unexpected(flagsStart);
        }
        var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
        state.reset(start, pattern, flags);
        this.validateRegExpFlags(state);
        this.validateRegExpPattern(state);
        var value = null;
        try {
          value = new RegExp(pattern, flags);
        } catch (e) {
        }
        return this.finishToken(types$1.regexp, { pattern, flags, value });
      };
      pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
        var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
        var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
        var start = this.pos, total = 0, lastCode = 0;
        for (var i2 = 0, e = len == null ? Infinity : len; i2 < e; ++i2, ++this.pos) {
          var code = this.input.charCodeAt(this.pos), val = void 0;
          if (allowSeparators && code === 95) {
            if (isLegacyOctalNumericLiteral) {
              this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
            }
            if (lastCode === 95) {
              this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
            }
            if (i2 === 0) {
              this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
            }
            lastCode = code;
            continue;
          }
          if (code >= 97) {
            val = code - 97 + 10;
          } else if (code >= 65) {
            val = code - 65 + 10;
          } else if (code >= 48 && code <= 57) {
            val = code - 48;
          } else {
            val = Infinity;
          }
          if (val >= radix) {
            break;
          }
          lastCode = code;
          total = total * radix + val;
        }
        if (allowSeparators && lastCode === 95) {
          this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
        }
        if (this.pos === start || len != null && this.pos - start !== len) {
          return null;
        }
        return total;
      };
      function stringToNumber(str, isLegacyOctalNumericLiteral) {
        if (isLegacyOctalNumericLiteral) {
          return parseInt(str, 8);
        }
        return parseFloat(str.replace(/_/g, ""));
      }
      function stringToBigInt(str) {
        if (typeof BigInt !== "function") {
          return null;
        }
        return BigInt(str.replace(/_/g, ""));
      }
      pp.readRadixNumber = function(radix) {
        var start = this.pos;
        this.pos += 2;
        var val = this.readInt(radix);
        if (val == null) {
          this.raise(this.start + 2, "Expected number in radix " + radix);
        }
        if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
          val = stringToBigInt(this.input.slice(start, this.pos));
          ++this.pos;
        } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        return this.finishToken(types$1.num, val);
      };
      pp.readNumber = function(startsWithDot) {
        var start = this.pos;
        if (!startsWithDot && this.readInt(10, void 0, true) === null) {
          this.raise(start, "Invalid number");
        }
        var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
        if (octal && this.strict) {
          this.raise(start, "Invalid number");
        }
        var next = this.input.charCodeAt(this.pos);
        if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
          var val$1 = stringToBigInt(this.input.slice(start, this.pos));
          ++this.pos;
          if (isIdentifierStart(this.fullCharCodeAtPos())) {
            this.raise(this.pos, "Identifier directly after number");
          }
          return this.finishToken(types$1.num, val$1);
        }
        if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
          octal = false;
        }
        if (next === 46 && !octal) {
          ++this.pos;
          this.readInt(10);
          next = this.input.charCodeAt(this.pos);
        }
        if ((next === 69 || next === 101) && !octal) {
          next = this.input.charCodeAt(++this.pos);
          if (next === 43 || next === 45) {
            ++this.pos;
          }
          if (this.readInt(10) === null) {
            this.raise(start, "Invalid number");
          }
        }
        if (isIdentifierStart(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        var val = stringToNumber(this.input.slice(start, this.pos), octal);
        return this.finishToken(types$1.num, val);
      };
      pp.readCodePoint = function() {
        var ch = this.input.charCodeAt(this.pos), code;
        if (ch === 123) {
          if (this.options.ecmaVersion < 6) {
            this.unexpected();
          }
          var codePos = ++this.pos;
          code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
          ++this.pos;
          if (code > 1114111) {
            this.invalidStringToken(codePos, "Code point out of bounds");
          }
        } else {
          code = this.readHexChar(4);
        }
        return code;
      };
      pp.readString = function(quote) {
        var out = "", chunkStart = ++this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(this.start, "Unterminated string constant");
          }
          var ch = this.input.charCodeAt(this.pos);
          if (ch === quote) {
            break;
          }
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(false);
            chunkStart = this.pos;
          } else if (ch === 8232 || ch === 8233) {
            if (this.options.ecmaVersion < 10) {
              this.raise(this.start, "Unterminated string constant");
            }
            ++this.pos;
            if (this.options.locations) {
              this.curLine++;
              this.lineStart = this.pos;
            }
          } else {
            if (isNewLine(ch)) {
              this.raise(this.start, "Unterminated string constant");
            }
            ++this.pos;
          }
        }
        out += this.input.slice(chunkStart, this.pos++);
        return this.finishToken(types$1.string, out);
      };
      var INVALID_TEMPLATE_ESCAPE_ERROR = {};
      pp.tryReadTemplateToken = function() {
        this.inTemplateElement = true;
        try {
          this.readTmplToken();
        } catch (err) {
          if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
            this.readInvalidTemplateToken();
          } else {
            throw err;
          }
        }
        this.inTemplateElement = false;
      };
      pp.invalidStringToken = function(position, message) {
        if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
          throw INVALID_TEMPLATE_ESCAPE_ERROR;
        } else {
          this.raise(position, message);
        }
      };
      pp.readTmplToken = function() {
        var out = "", chunkStart = this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(this.start, "Unterminated template");
          }
          var ch = this.input.charCodeAt(this.pos);
          if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
            if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
              if (ch === 36) {
                this.pos += 2;
                return this.finishToken(types$1.dollarBraceL);
              } else {
                ++this.pos;
                return this.finishToken(types$1.backQuote);
              }
            }
            out += this.input.slice(chunkStart, this.pos);
            return this.finishToken(types$1.template, out);
          }
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(true);
            chunkStart = this.pos;
          } else if (isNewLine(ch)) {
            out += this.input.slice(chunkStart, this.pos);
            ++this.pos;
            switch (ch) {
              case 13:
                if (this.input.charCodeAt(this.pos) === 10) {
                  ++this.pos;
                }
              case 10:
                out += "\n";
                break;
              default:
                out += String.fromCharCode(ch);
                break;
            }
            if (this.options.locations) {
              ++this.curLine;
              this.lineStart = this.pos;
            }
            chunkStart = this.pos;
          } else {
            ++this.pos;
          }
        }
      };
      pp.readInvalidTemplateToken = function() {
        for (; this.pos < this.input.length; this.pos++) {
          switch (this.input[this.pos]) {
            case "\\":
              ++this.pos;
              break;
            case "$":
              if (this.input[this.pos + 1] !== "{") {
                break;
              }
            case "`":
              return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
          }
        }
        this.raise(this.start, "Unterminated template");
      };
      pp.readEscapedChar = function(inTemplate) {
        var ch = this.input.charCodeAt(++this.pos);
        ++this.pos;
        switch (ch) {
          case 110:
            return "\n";
          case 114:
            return "\r";
          case 120:
            return String.fromCharCode(this.readHexChar(2));
          case 117:
            return codePointToString(this.readCodePoint());
          case 116:
            return "	";
          case 98:
            return "\b";
          case 118:
            return "\v";
          case 102:
            return "\f";
          case 13:
            if (this.input.charCodeAt(this.pos) === 10) {
              ++this.pos;
            }
          case 10:
            if (this.options.locations) {
              this.lineStart = this.pos;
              ++this.curLine;
            }
            return "";
          case 56:
          case 57:
            if (this.strict) {
              this.invalidStringToken(
                this.pos - 1,
                "Invalid escape sequence"
              );
            }
            if (inTemplate) {
              var codePos = this.pos - 1;
              this.invalidStringToken(
                codePos,
                "Invalid escape sequence in template string"
              );
            }
          default:
            if (ch >= 48 && ch <= 55) {
              var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
              var octal = parseInt(octalStr, 8);
              if (octal > 255) {
                octalStr = octalStr.slice(0, -1);
                octal = parseInt(octalStr, 8);
              }
              this.pos += octalStr.length - 1;
              ch = this.input.charCodeAt(this.pos);
              if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
                this.invalidStringToken(
                  this.pos - 1 - octalStr.length,
                  inTemplate ? "Octal literal in template string" : "Octal literal in strict mode"
                );
              }
              return String.fromCharCode(octal);
            }
            if (isNewLine(ch)) {
              return "";
            }
            return String.fromCharCode(ch);
        }
      };
      pp.readHexChar = function(len) {
        var codePos = this.pos;
        var n = this.readInt(16, len);
        if (n === null) {
          this.invalidStringToken(codePos, "Bad character escape sequence");
        }
        return n;
      };
      pp.readWord1 = function() {
        this.containsEsc = false;
        var word = "", first = true, chunkStart = this.pos;
        var astral = this.options.ecmaVersion >= 6;
        while (this.pos < this.input.length) {
          var ch = this.fullCharCodeAtPos();
          if (isIdentifierChar(ch, astral)) {
            this.pos += ch <= 65535 ? 1 : 2;
          } else if (ch === 92) {
            this.containsEsc = true;
            word += this.input.slice(chunkStart, this.pos);
            var escStart = this.pos;
            if (this.input.charCodeAt(++this.pos) !== 117) {
              this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
            }
            ++this.pos;
            var esc = this.readCodePoint();
            if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
              this.invalidStringToken(escStart, "Invalid Unicode escape");
            }
            word += codePointToString(esc);
            chunkStart = this.pos;
          } else {
            break;
          }
          first = false;
        }
        return word + this.input.slice(chunkStart, this.pos);
      };
      pp.readWord = function() {
        var word = this.readWord1();
        var type = types$1.name;
        if (this.keywords.test(word)) {
          type = keywords[word];
        }
        return this.finishToken(type, word);
      };
      var version = "8.10.0";
      Parser.acorn = {
        Parser,
        version,
        defaultOptions,
        Position,
        SourceLocation,
        getLineInfo,
        Node,
        TokenType,
        tokTypes: types$1,
        keywordTypes: keywords,
        TokContext,
        tokContexts: types,
        isIdentifierChar,
        isIdentifierStart,
        Token,
        isNewLine,
        lineBreak,
        lineBreakG,
        nonASCIIwhitespace
      };
      function parse(input, options) {
        return Parser.parse(input, options);
      }
      function parseExpressionAt(input, pos, options) {
        return Parser.parseExpressionAt(input, pos, options);
      }
      function tokenizer(input, options) {
        return Parser.tokenizer(input, options);
      }
      exports2.Node = Node;
      exports2.Parser = Parser;
      exports2.Position = Position;
      exports2.SourceLocation = SourceLocation;
      exports2.TokContext = TokContext;
      exports2.Token = Token;
      exports2.TokenType = TokenType;
      exports2.defaultOptions = defaultOptions;
      exports2.getLineInfo = getLineInfo;
      exports2.isIdentifierChar = isIdentifierChar;
      exports2.isIdentifierStart = isIdentifierStart;
      exports2.isNewLine = isNewLine;
      exports2.keywordTypes = keywords;
      exports2.lineBreak = lineBreak;
      exports2.lineBreakG = lineBreakG;
      exports2.nonASCIIwhitespace = nonASCIIwhitespace;
      exports2.parse = parse;
      exports2.parseExpressionAt = parseExpressionAt;
      exports2.tokContexts = types;
      exports2.tokTypes = types$1;
      exports2.tokenizer = tokenizer;
      exports2.version = version;
    });
  }
});

// ../../node_modules/acorn-jsx/xhtml.js
var require_xhtml = __commonJS({
  "../../node_modules/acorn-jsx/xhtml.js"(exports, module) {
    module.exports = {
      quot: '"',
      amp: "&",
      apos: "'",
      lt: "<",
      gt: ">",
      nbsp: "\xA0",
      iexcl: "\xA1",
      cent: "\xA2",
      pound: "\xA3",
      curren: "\xA4",
      yen: "\xA5",
      brvbar: "\xA6",
      sect: "\xA7",
      uml: "\xA8",
      copy: "\xA9",
      ordf: "\xAA",
      laquo: "\xAB",
      not: "\xAC",
      shy: "\xAD",
      reg: "\xAE",
      macr: "\xAF",
      deg: "\xB0",
      plusmn: "\xB1",
      sup2: "\xB2",
      sup3: "\xB3",
      acute: "\xB4",
      micro: "\xB5",
      para: "\xB6",
      middot: "\xB7",
      cedil: "\xB8",
      sup1: "\xB9",
      ordm: "\xBA",
      raquo: "\xBB",
      frac14: "\xBC",
      frac12: "\xBD",
      frac34: "\xBE",
      iquest: "\xBF",
      Agrave: "\xC0",
      Aacute: "\xC1",
      Acirc: "\xC2",
      Atilde: "\xC3",
      Auml: "\xC4",
      Aring: "\xC5",
      AElig: "\xC6",
      Ccedil: "\xC7",
      Egrave: "\xC8",
      Eacute: "\xC9",
      Ecirc: "\xCA",
      Euml: "\xCB",
      Igrave: "\xCC",
      Iacute: "\xCD",
      Icirc: "\xCE",
      Iuml: "\xCF",
      ETH: "\xD0",
      Ntilde: "\xD1",
      Ograve: "\xD2",
      Oacute: "\xD3",
      Ocirc: "\xD4",
      Otilde: "\xD5",
      Ouml: "\xD6",
      times: "\xD7",
      Oslash: "\xD8",
      Ugrave: "\xD9",
      Uacute: "\xDA",
      Ucirc: "\xDB",
      Uuml: "\xDC",
      Yacute: "\xDD",
      THORN: "\xDE",
      szlig: "\xDF",
      agrave: "\xE0",
      aacute: "\xE1",
      acirc: "\xE2",
      atilde: "\xE3",
      auml: "\xE4",
      aring: "\xE5",
      aelig: "\xE6",
      ccedil: "\xE7",
      egrave: "\xE8",
      eacute: "\xE9",
      ecirc: "\xEA",
      euml: "\xEB",
      igrave: "\xEC",
      iacute: "\xED",
      icirc: "\xEE",
      iuml: "\xEF",
      eth: "\xF0",
      ntilde: "\xF1",
      ograve: "\xF2",
      oacute: "\xF3",
      ocirc: "\xF4",
      otilde: "\xF5",
      ouml: "\xF6",
      divide: "\xF7",
      oslash: "\xF8",
      ugrave: "\xF9",
      uacute: "\xFA",
      ucirc: "\xFB",
      uuml: "\xFC",
      yacute: "\xFD",
      thorn: "\xFE",
      yuml: "\xFF",
      OElig: "\u0152",
      oelig: "\u0153",
      Scaron: "\u0160",
      scaron: "\u0161",
      Yuml: "\u0178",
      fnof: "\u0192",
      circ: "\u02C6",
      tilde: "\u02DC",
      Alpha: "\u0391",
      Beta: "\u0392",
      Gamma: "\u0393",
      Delta: "\u0394",
      Epsilon: "\u0395",
      Zeta: "\u0396",
      Eta: "\u0397",
      Theta: "\u0398",
      Iota: "\u0399",
      Kappa: "\u039A",
      Lambda: "\u039B",
      Mu: "\u039C",
      Nu: "\u039D",
      Xi: "\u039E",
      Omicron: "\u039F",
      Pi: "\u03A0",
      Rho: "\u03A1",
      Sigma: "\u03A3",
      Tau: "\u03A4",
      Upsilon: "\u03A5",
      Phi: "\u03A6",
      Chi: "\u03A7",
      Psi: "\u03A8",
      Omega: "\u03A9",
      alpha: "\u03B1",
      beta: "\u03B2",
      gamma: "\u03B3",
      delta: "\u03B4",
      epsilon: "\u03B5",
      zeta: "\u03B6",
      eta: "\u03B7",
      theta: "\u03B8",
      iota: "\u03B9",
      kappa: "\u03BA",
      lambda: "\u03BB",
      mu: "\u03BC",
      nu: "\u03BD",
      xi: "\u03BE",
      omicron: "\u03BF",
      pi: "\u03C0",
      rho: "\u03C1",
      sigmaf: "\u03C2",
      sigma: "\u03C3",
      tau: "\u03C4",
      upsilon: "\u03C5",
      phi: "\u03C6",
      chi: "\u03C7",
      psi: "\u03C8",
      omega: "\u03C9",
      thetasym: "\u03D1",
      upsih: "\u03D2",
      piv: "\u03D6",
      ensp: "\u2002",
      emsp: "\u2003",
      thinsp: "\u2009",
      zwnj: "\u200C",
      zwj: "\u200D",
      lrm: "\u200E",
      rlm: "\u200F",
      ndash: "\u2013",
      mdash: "\u2014",
      lsquo: "\u2018",
      rsquo: "\u2019",
      sbquo: "\u201A",
      ldquo: "\u201C",
      rdquo: "\u201D",
      bdquo: "\u201E",
      dagger: "\u2020",
      Dagger: "\u2021",
      bull: "\u2022",
      hellip: "\u2026",
      permil: "\u2030",
      prime: "\u2032",
      Prime: "\u2033",
      lsaquo: "\u2039",
      rsaquo: "\u203A",
      oline: "\u203E",
      frasl: "\u2044",
      euro: "\u20AC",
      image: "\u2111",
      weierp: "\u2118",
      real: "\u211C",
      trade: "\u2122",
      alefsym: "\u2135",
      larr: "\u2190",
      uarr: "\u2191",
      rarr: "\u2192",
      darr: "\u2193",
      harr: "\u2194",
      crarr: "\u21B5",
      lArr: "\u21D0",
      uArr: "\u21D1",
      rArr: "\u21D2",
      dArr: "\u21D3",
      hArr: "\u21D4",
      forall: "\u2200",
      part: "\u2202",
      exist: "\u2203",
      empty: "\u2205",
      nabla: "\u2207",
      isin: "\u2208",
      notin: "\u2209",
      ni: "\u220B",
      prod: "\u220F",
      sum: "\u2211",
      minus: "\u2212",
      lowast: "\u2217",
      radic: "\u221A",
      prop: "\u221D",
      infin: "\u221E",
      ang: "\u2220",
      and: "\u2227",
      or: "\u2228",
      cap: "\u2229",
      cup: "\u222A",
      "int": "\u222B",
      there4: "\u2234",
      sim: "\u223C",
      cong: "\u2245",
      asymp: "\u2248",
      ne: "\u2260",
      equiv: "\u2261",
      le: "\u2264",
      ge: "\u2265",
      sub: "\u2282",
      sup: "\u2283",
      nsub: "\u2284",
      sube: "\u2286",
      supe: "\u2287",
      oplus: "\u2295",
      otimes: "\u2297",
      perp: "\u22A5",
      sdot: "\u22C5",
      lceil: "\u2308",
      rceil: "\u2309",
      lfloor: "\u230A",
      rfloor: "\u230B",
      lang: "\u2329",
      rang: "\u232A",
      loz: "\u25CA",
      spades: "\u2660",
      clubs: "\u2663",
      hearts: "\u2665",
      diams: "\u2666"
    };
  }
});

// ../../node_modules/acorn-jsx/index.js
var require_acorn_jsx = __commonJS({
  "../../node_modules/acorn-jsx/index.js"(exports, module) {
    "use strict";
    var XHTMLEntities = require_xhtml();
    var hexNumber = /^[\da-fA-F]+$/;
    var decimalNumber = /^\d+$/;
    var acornJsxMap = /* @__PURE__ */ new WeakMap();
    function getJsxTokens(acorn) {
      acorn = acorn.Parser.acorn || acorn;
      let acornJsx = acornJsxMap.get(acorn);
      if (!acornJsx) {
        const tt = acorn.tokTypes;
        const TokContext = acorn.TokContext;
        const TokenType = acorn.TokenType;
        const tc_oTag = new TokContext("<tag", false);
        const tc_cTag = new TokContext("</tag", false);
        const tc_expr = new TokContext("<tag>...</tag>", true, true);
        const tokContexts = {
          tc_oTag,
          tc_cTag,
          tc_expr
        };
        const tokTypes = {
          jsxName: new TokenType("jsxName"),
          jsxText: new TokenType("jsxText", { beforeExpr: true }),
          jsxTagStart: new TokenType("jsxTagStart", { startsExpr: true }),
          jsxTagEnd: new TokenType("jsxTagEnd")
        };
        tokTypes.jsxTagStart.updateContext = function() {
          this.context.push(tc_expr);
          this.context.push(tc_oTag);
          this.exprAllowed = false;
        };
        tokTypes.jsxTagEnd.updateContext = function(prevType) {
          let out = this.context.pop();
          if (out === tc_oTag && prevType === tt.slash || out === tc_cTag) {
            this.context.pop();
            this.exprAllowed = this.curContext() === tc_expr;
          } else {
            this.exprAllowed = true;
          }
        };
        acornJsx = { tokContexts, tokTypes };
        acornJsxMap.set(acorn, acornJsx);
      }
      return acornJsx;
    }
    function getQualifiedJSXName(object) {
      if (!object)
        return object;
      if (object.type === "JSXIdentifier")
        return object.name;
      if (object.type === "JSXNamespacedName")
        return object.namespace.name + ":" + object.name.name;
      if (object.type === "JSXMemberExpression")
        return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
    }
    module.exports = function(options) {
      options = options || {};
      return function(Parser) {
        return plugin({
          allowNamespaces: options.allowNamespaces !== false,
          allowNamespacedObjects: !!options.allowNamespacedObjects
        }, Parser);
      };
    };
    Object.defineProperty(module.exports, "tokTypes", {
      get: function get_tokTypes() {
        return getJsxTokens(require_acorn()).tokTypes;
      },
      configurable: true,
      enumerable: true
    });
    function plugin(options, Parser) {
      const acorn = Parser.acorn || require_acorn();
      const acornJsx = getJsxTokens(acorn);
      const tt = acorn.tokTypes;
      const tok = acornJsx.tokTypes;
      const tokContexts = acorn.tokContexts;
      const tc_oTag = acornJsx.tokContexts.tc_oTag;
      const tc_cTag = acornJsx.tokContexts.tc_cTag;
      const tc_expr = acornJsx.tokContexts.tc_expr;
      const isNewLine = acorn.isNewLine;
      const isIdentifierStart = acorn.isIdentifierStart;
      const isIdentifierChar = acorn.isIdentifierChar;
      return class extends Parser {
        // Expose actual `tokTypes` and `tokContexts` to other plugins.
        static get acornJsx() {
          return acornJsx;
        }
        // Reads inline JSX contents token.
        jsx_readToken() {
          let out = "", chunkStart = this.pos;
          for (; ; ) {
            if (this.pos >= this.input.length)
              this.raise(this.start, "Unterminated JSX contents");
            let ch = this.input.charCodeAt(this.pos);
            switch (ch) {
              case 60:
              case 123:
                if (this.pos === this.start) {
                  if (ch === 60 && this.exprAllowed) {
                    ++this.pos;
                    return this.finishToken(tok.jsxTagStart);
                  }
                  return this.getTokenFromCode(ch);
                }
                out += this.input.slice(chunkStart, this.pos);
                return this.finishToken(tok.jsxText, out);
              case 38:
                out += this.input.slice(chunkStart, this.pos);
                out += this.jsx_readEntity();
                chunkStart = this.pos;
                break;
              case 62:
              case 125:
                this.raise(
                  this.pos,
                  "Unexpected token `" + this.input[this.pos] + "`. Did you mean `" + (ch === 62 ? "&gt;" : "&rbrace;") + '` or `{"' + this.input[this.pos] + '"}`?'
                );
              default:
                if (isNewLine(ch)) {
                  out += this.input.slice(chunkStart, this.pos);
                  out += this.jsx_readNewLine(true);
                  chunkStart = this.pos;
                } else {
                  ++this.pos;
                }
            }
          }
        }
        jsx_readNewLine(normalizeCRLF) {
          let ch = this.input.charCodeAt(this.pos);
          let out;
          ++this.pos;
          if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
            out = normalizeCRLF ? "\n" : "\r\n";
          } else {
            out = String.fromCharCode(ch);
          }
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
          return out;
        }
        jsx_readString(quote) {
          let out = "", chunkStart = ++this.pos;
          for (; ; ) {
            if (this.pos >= this.input.length)
              this.raise(this.start, "Unterminated string constant");
            let ch = this.input.charCodeAt(this.pos);
            if (ch === quote)
              break;
            if (ch === 38) {
              out += this.input.slice(chunkStart, this.pos);
              out += this.jsx_readEntity();
              chunkStart = this.pos;
            } else if (isNewLine(ch)) {
              out += this.input.slice(chunkStart, this.pos);
              out += this.jsx_readNewLine(false);
              chunkStart = this.pos;
            } else {
              ++this.pos;
            }
          }
          out += this.input.slice(chunkStart, this.pos++);
          return this.finishToken(tt.string, out);
        }
        jsx_readEntity() {
          let str = "", count = 0, entity;
          let ch = this.input[this.pos];
          if (ch !== "&")
            this.raise(this.pos, "Entity must start with an ampersand");
          let startPos = ++this.pos;
          while (this.pos < this.input.length && count++ < 10) {
            ch = this.input[this.pos++];
            if (ch === ";") {
              if (str[0] === "#") {
                if (str[1] === "x") {
                  str = str.substr(2);
                  if (hexNumber.test(str))
                    entity = String.fromCharCode(parseInt(str, 16));
                } else {
                  str = str.substr(1);
                  if (decimalNumber.test(str))
                    entity = String.fromCharCode(parseInt(str, 10));
                }
              } else {
                entity = XHTMLEntities[str];
              }
              break;
            }
            str += ch;
          }
          if (!entity) {
            this.pos = startPos;
            return "&";
          }
          return entity;
        }
        // Read a JSX identifier (valid tag or attribute name).
        //
        // Optimized version since JSX identifiers can't contain
        // escape characters and so can be read as single slice.
        // Also assumes that first character was already checked
        // by isIdentifierStart in readToken.
        jsx_readWord() {
          let ch, start = this.pos;
          do {
            ch = this.input.charCodeAt(++this.pos);
          } while (isIdentifierChar(ch) || ch === 45);
          return this.finishToken(tok.jsxName, this.input.slice(start, this.pos));
        }
        // Parse next token as JSX identifier
        jsx_parseIdentifier() {
          let node = this.startNode();
          if (this.type === tok.jsxName)
            node.name = this.value;
          else if (this.type.keyword)
            node.name = this.type.keyword;
          else
            this.unexpected();
          this.next();
          return this.finishNode(node, "JSXIdentifier");
        }
        // Parse namespaced identifier.
        jsx_parseNamespacedName() {
          let startPos = this.start, startLoc = this.startLoc;
          let name = this.jsx_parseIdentifier();
          if (!options.allowNamespaces || !this.eat(tt.colon))
            return name;
          var node = this.startNodeAt(startPos, startLoc);
          node.namespace = name;
          node.name = this.jsx_parseIdentifier();
          return this.finishNode(node, "JSXNamespacedName");
        }
        // Parses element name in any form - namespaced, member
        // or single identifier.
        jsx_parseElementName() {
          if (this.type === tok.jsxTagEnd)
            return "";
          let startPos = this.start, startLoc = this.startLoc;
          let node = this.jsx_parseNamespacedName();
          if (this.type === tt.dot && node.type === "JSXNamespacedName" && !options.allowNamespacedObjects) {
            this.unexpected();
          }
          while (this.eat(tt.dot)) {
            let newNode = this.startNodeAt(startPos, startLoc);
            newNode.object = node;
            newNode.property = this.jsx_parseIdentifier();
            node = this.finishNode(newNode, "JSXMemberExpression");
          }
          return node;
        }
        // Parses any type of JSX attribute value.
        jsx_parseAttributeValue() {
          switch (this.type) {
            case tt.braceL:
              let node = this.jsx_parseExpressionContainer();
              if (node.expression.type === "JSXEmptyExpression")
                this.raise(node.start, "JSX attributes must only be assigned a non-empty expression");
              return node;
            case tok.jsxTagStart:
            case tt.string:
              return this.parseExprAtom();
            default:
              this.raise(this.start, "JSX value should be either an expression or a quoted JSX text");
          }
        }
        // JSXEmptyExpression is unique type since it doesn't actually parse anything,
        // and so it should start at the end of last read token (left brace) and finish
        // at the beginning of the next one (right brace).
        jsx_parseEmptyExpression() {
          let node = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);
          return this.finishNodeAt(node, "JSXEmptyExpression", this.start, this.startLoc);
        }
        // Parses JSX expression enclosed into curly brackets.
        jsx_parseExpressionContainer() {
          let node = this.startNode();
          this.next();
          node.expression = this.type === tt.braceR ? this.jsx_parseEmptyExpression() : this.parseExpression();
          this.expect(tt.braceR);
          return this.finishNode(node, "JSXExpressionContainer");
        }
        // Parses following JSX attribute name-value pair.
        jsx_parseAttribute() {
          let node = this.startNode();
          if (this.eat(tt.braceL)) {
            this.expect(tt.ellipsis);
            node.argument = this.parseMaybeAssign();
            this.expect(tt.braceR);
            return this.finishNode(node, "JSXSpreadAttribute");
          }
          node.name = this.jsx_parseNamespacedName();
          node.value = this.eat(tt.eq) ? this.jsx_parseAttributeValue() : null;
          return this.finishNode(node, "JSXAttribute");
        }
        // Parses JSX opening tag starting after '<'.
        jsx_parseOpeningElementAt(startPos, startLoc) {
          let node = this.startNodeAt(startPos, startLoc);
          node.attributes = [];
          let nodeName = this.jsx_parseElementName();
          if (nodeName)
            node.name = nodeName;
          while (this.type !== tt.slash && this.type !== tok.jsxTagEnd)
            node.attributes.push(this.jsx_parseAttribute());
          node.selfClosing = this.eat(tt.slash);
          this.expect(tok.jsxTagEnd);
          return this.finishNode(node, nodeName ? "JSXOpeningElement" : "JSXOpeningFragment");
        }
        // Parses JSX closing tag starting after '</'.
        jsx_parseClosingElementAt(startPos, startLoc) {
          let node = this.startNodeAt(startPos, startLoc);
          let nodeName = this.jsx_parseElementName();
          if (nodeName)
            node.name = nodeName;
          this.expect(tok.jsxTagEnd);
          return this.finishNode(node, nodeName ? "JSXClosingElement" : "JSXClosingFragment");
        }
        // Parses entire JSX element, including it's opening tag
        // (starting after '<'), attributes, contents and closing tag.
        jsx_parseElementAt(startPos, startLoc) {
          let node = this.startNodeAt(startPos, startLoc);
          let children = [];
          let openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);
          let closingElement = null;
          if (!openingElement.selfClosing) {
            contents:
              for (; ; ) {
                switch (this.type) {
                  case tok.jsxTagStart:
                    startPos = this.start;
                    startLoc = this.startLoc;
                    this.next();
                    if (this.eat(tt.slash)) {
                      closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);
                      break contents;
                    }
                    children.push(this.jsx_parseElementAt(startPos, startLoc));
                    break;
                  case tok.jsxText:
                    children.push(this.parseExprAtom());
                    break;
                  case tt.braceL:
                    children.push(this.jsx_parseExpressionContainer());
                    break;
                  default:
                    this.unexpected();
                }
              }
            if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
              this.raise(
                closingElement.start,
                "Expected corresponding JSX closing tag for <" + getQualifiedJSXName(openingElement.name) + ">"
              );
            }
          }
          let fragmentOrElement = openingElement.name ? "Element" : "Fragment";
          node["opening" + fragmentOrElement] = openingElement;
          node["closing" + fragmentOrElement] = closingElement;
          node.children = children;
          if (this.type === tt.relational && this.value === "<") {
            this.raise(this.start, "Adjacent JSX elements must be wrapped in an enclosing tag");
          }
          return this.finishNode(node, "JSX" + fragmentOrElement);
        }
        // Parse JSX text
        jsx_parseText() {
          let node = this.parseLiteral(this.value);
          node.type = "JSXText";
          return node;
        }
        // Parses entire JSX element from current position.
        jsx_parseElement() {
          let startPos = this.start, startLoc = this.startLoc;
          this.next();
          return this.jsx_parseElementAt(startPos, startLoc);
        }
        parseExprAtom(refShortHandDefaultPos) {
          if (this.type === tok.jsxText)
            return this.jsx_parseText();
          else if (this.type === tok.jsxTagStart)
            return this.jsx_parseElement();
          else
            return super.parseExprAtom(refShortHandDefaultPos);
        }
        readToken(code) {
          let context = this.curContext();
          if (context === tc_expr)
            return this.jsx_readToken();
          if (context === tc_oTag || context === tc_cTag) {
            if (isIdentifierStart(code))
              return this.jsx_readWord();
            if (code == 62) {
              ++this.pos;
              return this.finishToken(tok.jsxTagEnd);
            }
            if ((code === 34 || code === 39) && context == tc_oTag)
              return this.jsx_readString(code);
          }
          if (code === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33) {
            ++this.pos;
            return this.finishToken(tok.jsxTagStart);
          }
          return super.readToken(code);
        }
        updateContext(prevType) {
          if (this.type == tt.braceL) {
            var curContext = this.curContext();
            if (curContext == tc_oTag)
              this.context.push(tokContexts.b_expr);
            else if (curContext == tc_expr)
              this.context.push(tokContexts.b_tmpl);
            else
              super.updateContext(prevType);
            this.exprAllowed = true;
          } else if (this.type === tt.slash && prevType === tok.jsxTagStart) {
            this.context.length -= 2;
            this.context.push(tc_cTag);
            this.exprAllowed = false;
          } else {
            return super.updateContext(prevType);
          }
        }
      };
    }
  }
});

// ../../node_modules/espree/dist/espree.cjs
var require_espree = __commonJS({
  "../../node_modules/espree/dist/espree.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var acorn = require_acorn();
    var jsx = require_acorn_jsx();
    var visitorKeys = require_eslint_visitor_keys();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var acorn__namespace = /* @__PURE__ */ _interopNamespace(acorn);
    var jsx__default = /* @__PURE__ */ _interopDefaultLegacy(jsx);
    var visitorKeys__namespace = /* @__PURE__ */ _interopNamespace(visitorKeys);
    var Token = {
      Boolean: "Boolean",
      EOF: "<end>",
      Identifier: "Identifier",
      PrivateIdentifier: "PrivateIdentifier",
      Keyword: "Keyword",
      Null: "Null",
      Numeric: "Numeric",
      Punctuator: "Punctuator",
      String: "String",
      RegularExpression: "RegularExpression",
      Template: "Template",
      JSXIdentifier: "JSXIdentifier",
      JSXText: "JSXText"
    };
    function convertTemplatePart(tokens, code) {
      const firstToken = tokens[0], lastTemplateToken = tokens[tokens.length - 1];
      const token = {
        type: Token.Template,
        value: code.slice(firstToken.start, lastTemplateToken.end)
      };
      if (firstToken.loc) {
        token.loc = {
          start: firstToken.loc.start,
          end: lastTemplateToken.loc.end
        };
      }
      if (firstToken.range) {
        token.start = firstToken.range[0];
        token.end = lastTemplateToken.range[1];
        token.range = [token.start, token.end];
      }
      return token;
    }
    function TokenTranslator(acornTokTypes, code) {
      this._acornTokTypes = acornTokTypes;
      this._tokens = [];
      this._curlyBrace = null;
      this._code = code;
    }
    TokenTranslator.prototype = {
      constructor: TokenTranslator,
      /**
       * Translates a single Esprima token to a single Acorn token. This may be
       * inaccurate due to how templates are handled differently in Esprima and
       * Acorn, but should be accurate for all other tokens.
       * @param {AcornToken} token The Acorn token to translate.
       * @param {Object} extra Espree extra object.
       * @returns {EsprimaToken} The Esprima version of the token.
       */
      translate(token, extra) {
        const type = token.type, tt = this._acornTokTypes;
        if (type === tt.name) {
          token.type = Token.Identifier;
          if (token.value === "static") {
            token.type = Token.Keyword;
          }
          if (extra.ecmaVersion > 5 && (token.value === "yield" || token.value === "let")) {
            token.type = Token.Keyword;
          }
        } else if (type === tt.privateId) {
          token.type = Token.PrivateIdentifier;
        } else if (type === tt.semi || type === tt.comma || type === tt.parenL || type === tt.parenR || type === tt.braceL || type === tt.braceR || type === tt.dot || type === tt.bracketL || type === tt.colon || type === tt.question || type === tt.bracketR || type === tt.ellipsis || type === tt.arrow || type === tt.jsxTagStart || type === tt.incDec || type === tt.starstar || type === tt.jsxTagEnd || type === tt.prefix || type === tt.questionDot || type.binop && !type.keyword || type.isAssign) {
          token.type = Token.Punctuator;
          token.value = this._code.slice(token.start, token.end);
        } else if (type === tt.jsxName) {
          token.type = Token.JSXIdentifier;
        } else if (type.label === "jsxText" || type === tt.jsxAttrValueToken) {
          token.type = Token.JSXText;
        } else if (type.keyword) {
          if (type.keyword === "true" || type.keyword === "false") {
            token.type = Token.Boolean;
          } else if (type.keyword === "null") {
            token.type = Token.Null;
          } else {
            token.type = Token.Keyword;
          }
        } else if (type === tt.num) {
          token.type = Token.Numeric;
          token.value = this._code.slice(token.start, token.end);
        } else if (type === tt.string) {
          if (extra.jsxAttrValueToken) {
            extra.jsxAttrValueToken = false;
            token.type = Token.JSXText;
          } else {
            token.type = Token.String;
          }
          token.value = this._code.slice(token.start, token.end);
        } else if (type === tt.regexp) {
          token.type = Token.RegularExpression;
          const value = token.value;
          token.regex = {
            flags: value.flags,
            pattern: value.pattern
          };
          token.value = `/${value.pattern}/${value.flags}`;
        }
        return token;
      },
      /**
       * Function to call during Acorn's onToken handler.
       * @param {AcornToken} token The Acorn token.
       * @param {Object} extra The Espree extra object.
       * @returns {void}
       */
      onToken(token, extra) {
        const tt = this._acornTokTypes, tokens = extra.tokens, templateTokens = this._tokens;
        const translateTemplateTokens = () => {
          tokens.push(convertTemplatePart(this._tokens, this._code));
          this._tokens = [];
        };
        if (token.type === tt.eof) {
          if (this._curlyBrace) {
            tokens.push(this.translate(this._curlyBrace, extra));
          }
          return;
        }
        if (token.type === tt.backQuote) {
          if (this._curlyBrace) {
            tokens.push(this.translate(this._curlyBrace, extra));
            this._curlyBrace = null;
          }
          templateTokens.push(token);
          if (templateTokens.length > 1) {
            translateTemplateTokens();
          }
          return;
        }
        if (token.type === tt.dollarBraceL) {
          templateTokens.push(token);
          translateTemplateTokens();
          return;
        }
        if (token.type === tt.braceR) {
          if (this._curlyBrace) {
            tokens.push(this.translate(this._curlyBrace, extra));
          }
          this._curlyBrace = token;
          return;
        }
        if (token.type === tt.template || token.type === tt.invalidTemplate) {
          if (this._curlyBrace) {
            templateTokens.push(this._curlyBrace);
            this._curlyBrace = null;
          }
          templateTokens.push(token);
          return;
        }
        if (this._curlyBrace) {
          tokens.push(this.translate(this._curlyBrace, extra));
          this._curlyBrace = null;
        }
        tokens.push(this.translate(token, extra));
      }
    };
    var SUPPORTED_VERSIONS = [
      3,
      5,
      6,
      // 2015
      7,
      // 2016
      8,
      // 2017
      9,
      // 2018
      10,
      // 2019
      11,
      // 2020
      12,
      // 2021
      13,
      // 2022
      14,
      // 2023
      15
      // 2024
    ];
    function getLatestEcmaVersion() {
      return SUPPORTED_VERSIONS[SUPPORTED_VERSIONS.length - 1];
    }
    function getSupportedEcmaVersions() {
      return [...SUPPORTED_VERSIONS];
    }
    function normalizeEcmaVersion(ecmaVersion = 5) {
      let version2 = ecmaVersion === "latest" ? getLatestEcmaVersion() : ecmaVersion;
      if (typeof version2 !== "number") {
        throw new Error(`ecmaVersion must be a number or "latest". Received value of type ${typeof ecmaVersion} instead.`);
      }
      if (version2 >= 2015) {
        version2 -= 2009;
      }
      if (!SUPPORTED_VERSIONS.includes(version2)) {
        throw new Error("Invalid ecmaVersion.");
      }
      return version2;
    }
    function normalizeSourceType(sourceType = "script") {
      if (sourceType === "script" || sourceType === "module") {
        return sourceType;
      }
      if (sourceType === "commonjs") {
        return "script";
      }
      throw new Error("Invalid sourceType.");
    }
    function normalizeOptions(options) {
      const ecmaVersion = normalizeEcmaVersion(options.ecmaVersion);
      const sourceType = normalizeSourceType(options.sourceType);
      const ranges = options.range === true;
      const locations = options.loc === true;
      if (ecmaVersion !== 3 && options.allowReserved) {
        throw new Error("`allowReserved` is only supported when ecmaVersion is 3");
      }
      if (typeof options.allowReserved !== "undefined" && typeof options.allowReserved !== "boolean") {
        throw new Error("`allowReserved`, when present, must be `true` or `false`");
      }
      const allowReserved = ecmaVersion === 3 ? options.allowReserved || "never" : false;
      const ecmaFeatures = options.ecmaFeatures || {};
      const allowReturnOutsideFunction = options.sourceType === "commonjs" || Boolean(ecmaFeatures.globalReturn);
      if (sourceType === "module" && ecmaVersion < 6) {
        throw new Error("sourceType 'module' is not supported when ecmaVersion < 2015. Consider adding `{ ecmaVersion: 2015 }` to the parser options.");
      }
      return Object.assign({}, options, {
        ecmaVersion,
        sourceType,
        ranges,
        locations,
        allowReserved,
        allowReturnOutsideFunction
      });
    }
    var STATE = Symbol("espree's internal state");
    var ESPRIMA_FINISH_NODE = Symbol("espree's esprimaFinishNode");
    function convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc, code) {
      let type;
      if (block) {
        type = "Block";
      } else if (code.slice(start, start + 2) === "#!") {
        type = "Hashbang";
      } else {
        type = "Line";
      }
      const comment = {
        type,
        value: text
      };
      if (typeof start === "number") {
        comment.start = start;
        comment.end = end;
        comment.range = [start, end];
      }
      if (typeof startLoc === "object") {
        comment.loc = {
          start: startLoc,
          end: endLoc
        };
      }
      return comment;
    }
    var espree = () => (Parser) => {
      const tokTypes = Object.assign({}, Parser.acorn.tokTypes);
      if (Parser.acornJsx) {
        Object.assign(tokTypes, Parser.acornJsx.tokTypes);
      }
      return class Espree extends Parser {
        constructor(opts, code) {
          if (typeof opts !== "object" || opts === null) {
            opts = {};
          }
          if (typeof code !== "string" && !(code instanceof String)) {
            code = String(code);
          }
          const originalSourceType = opts.sourceType;
          const options = normalizeOptions(opts);
          const ecmaFeatures = options.ecmaFeatures || {};
          const tokenTranslator = options.tokens === true ? new TokenTranslator(tokTypes, code) : null;
          const state = {
            originalSourceType: originalSourceType || options.sourceType,
            tokens: tokenTranslator ? [] : null,
            comments: options.comment === true ? [] : null,
            impliedStrict: ecmaFeatures.impliedStrict === true && options.ecmaVersion >= 5,
            ecmaVersion: options.ecmaVersion,
            jsxAttrValueToken: false,
            lastToken: null,
            templateElements: []
          };
          super({
            // do not use spread, because we don't want to pass any unknown options to acorn
            ecmaVersion: options.ecmaVersion,
            sourceType: options.sourceType,
            ranges: options.ranges,
            locations: options.locations,
            allowReserved: options.allowReserved,
            // Truthy value is true for backward compatibility.
            allowReturnOutsideFunction: options.allowReturnOutsideFunction,
            // Collect tokens
            onToken(token) {
              if (tokenTranslator) {
                tokenTranslator.onToken(token, state);
              }
              if (token.type !== tokTypes.eof) {
                state.lastToken = token;
              }
            },
            // Collect comments
            onComment(block, text, start, end, startLoc, endLoc) {
              if (state.comments) {
                const comment = convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc, code);
                state.comments.push(comment);
              }
            }
          }, code);
          this[STATE] = state;
        }
        tokenize() {
          do {
            this.next();
          } while (this.type !== tokTypes.eof);
          this.next();
          const extra = this[STATE];
          const tokens = extra.tokens;
          if (extra.comments) {
            tokens.comments = extra.comments;
          }
          return tokens;
        }
        finishNode(...args) {
          const result = super.finishNode(...args);
          return this[ESPRIMA_FINISH_NODE](result);
        }
        finishNodeAt(...args) {
          const result = super.finishNodeAt(...args);
          return this[ESPRIMA_FINISH_NODE](result);
        }
        parse() {
          const extra = this[STATE];
          const program = super.parse();
          program.sourceType = extra.originalSourceType;
          if (extra.comments) {
            program.comments = extra.comments;
          }
          if (extra.tokens) {
            program.tokens = extra.tokens;
          }
          if (program.body.length) {
            const [firstNode] = program.body;
            if (program.range) {
              program.range[0] = firstNode.range[0];
            }
            if (program.loc) {
              program.loc.start = firstNode.loc.start;
            }
            program.start = firstNode.start;
          }
          if (extra.lastToken) {
            if (program.range) {
              program.range[1] = extra.lastToken.range[1];
            }
            if (program.loc) {
              program.loc.end = extra.lastToken.loc.end;
            }
            program.end = extra.lastToken.end;
          }
          this[STATE].templateElements.forEach((templateElement) => {
            const startOffset = -1;
            const endOffset = templateElement.tail ? 1 : 2;
            templateElement.start += startOffset;
            templateElement.end += endOffset;
            if (templateElement.range) {
              templateElement.range[0] += startOffset;
              templateElement.range[1] += endOffset;
            }
            if (templateElement.loc) {
              templateElement.loc.start.column += startOffset;
              templateElement.loc.end.column += endOffset;
            }
          });
          return program;
        }
        parseTopLevel(node) {
          if (this[STATE].impliedStrict) {
            this.strict = true;
          }
          return super.parseTopLevel(node);
        }
        /**
         * Overwrites the default raise method to throw Esprima-style errors.
         * @param {int} pos The position of the error.
         * @param {string} message The error message.
         * @throws {SyntaxError} A syntax error.
         * @returns {void}
         */
        raise(pos, message) {
          const loc = Parser.acorn.getLineInfo(this.input, pos);
          const err = new SyntaxError(message);
          err.index = pos;
          err.lineNumber = loc.line;
          err.column = loc.column + 1;
          throw err;
        }
        /**
         * Overwrites the default raise method to throw Esprima-style errors.
         * @param {int} pos The position of the error.
         * @param {string} message The error message.
         * @throws {SyntaxError} A syntax error.
         * @returns {void}
         */
        raiseRecoverable(pos, message) {
          this.raise(pos, message);
        }
        /**
         * Overwrites the default unexpected method to throw Esprima-style errors.
         * @param {int} pos The position of the error.
         * @throws {SyntaxError} A syntax error.
         * @returns {void}
         */
        unexpected(pos) {
          let message = "Unexpected token";
          if (pos !== null && pos !== void 0) {
            this.pos = pos;
            if (this.options.locations) {
              while (this.pos < this.lineStart) {
                this.lineStart = this.input.lastIndexOf("\n", this.lineStart - 2) + 1;
                --this.curLine;
              }
            }
            this.nextToken();
          }
          if (this.end > this.start) {
            message += ` ${this.input.slice(this.start, this.end)}`;
          }
          this.raise(this.start, message);
        }
        /*
        * Esprima-FB represents JSX strings as tokens called "JSXText", but Acorn-JSX
        * uses regular tt.string without any distinction between this and regular JS
        * strings. As such, we intercept an attempt to read a JSX string and set a flag
        * on extra so that when tokens are converted, the next token will be switched
        * to JSXText via onToken.
        */
        jsx_readString(quote) {
          const result = super.jsx_readString(quote);
          if (this.type === tokTypes.string) {
            this[STATE].jsxAttrValueToken = true;
          }
          return result;
        }
        /**
         * Performs last-minute Esprima-specific compatibility checks and fixes.
         * @param {ASTNode} result The node to check.
         * @returns {ASTNode} The finished node.
         */
        [ESPRIMA_FINISH_NODE](result) {
          if (result.type === "TemplateElement") {
            this[STATE].templateElements.push(result);
          }
          if (result.type.includes("Function") && !result.generator) {
            result.generator = false;
          }
          return result;
        }
      };
    };
    var version$1 = "9.6.1";
    var parsers = {
      _regular: null,
      _jsx: null,
      get regular() {
        if (this._regular === null) {
          this._regular = acorn__namespace.Parser.extend(espree());
        }
        return this._regular;
      },
      get jsx() {
        if (this._jsx === null) {
          this._jsx = acorn__namespace.Parser.extend(jsx__default["default"](), espree());
        }
        return this._jsx;
      },
      get(options) {
        const useJsx = Boolean(
          options && options.ecmaFeatures && options.ecmaFeatures.jsx
        );
        return useJsx ? this.jsx : this.regular;
      }
    };
    function tokenize(code, options) {
      const Parser = parsers.get(options);
      if (!options || options.tokens !== true) {
        options = Object.assign({}, options, { tokens: true });
      }
      return new Parser(options, code).tokenize();
    }
    function parse(code, options) {
      const Parser = parsers.get(options);
      return new Parser(options, code).parse();
    }
    var version = version$1;
    var name = "espree";
    var VisitorKeys = function() {
      return visitorKeys__namespace.KEYS;
    }();
    var Syntax = function() {
      let key, types = {};
      if (typeof Object.create === "function") {
        types = /* @__PURE__ */ Object.create(null);
      }
      for (key in VisitorKeys) {
        if (Object.hasOwnProperty.call(VisitorKeys, key)) {
          types[key] = key;
        }
      }
      if (typeof Object.freeze === "function") {
        Object.freeze(types);
      }
      return types;
    }();
    var latestEcmaVersion = getLatestEcmaVersion();
    var supportedEcmaVersions = getSupportedEcmaVersions();
    exports.Syntax = Syntax;
    exports.VisitorKeys = VisitorKeys;
    exports.latestEcmaVersion = latestEcmaVersion;
    exports.name = name;
    exports.parse = parse;
    exports.supportedEcmaVersions = supportedEcmaVersions;
    exports.tokenize = tokenize;
    exports.version = version;
  }
});

// ../../node_modules/lodash.merge/index.js
var require_lodash = __commonJS({
  "../../node_modules/lodash.merge/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var HOT_COUNT = 800;
    var HOT_SPAN = 16;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var asyncTag = "[object AsyncFunction]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var nullTag = "[object Null]";
    var objectTag = "[object Object]";
    var proxyTag = "[object Proxy]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var undefinedTag = "[object Undefined]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var nativeObjectToString = objectProto.toString;
    var objectCtorString = funcToString.call(Object);
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectCreate = Object.create;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var nativeMax = Math.max;
    var nativeNow = Date.now;
    var Map2 = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    var baseCreate = function() {
      function object() {
      }
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignMergeValue(object, key, value) {
      if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    var baseFor = createBaseFor();
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack());
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string),
        "writable": true
      });
    };
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function overRest(func, start, transform) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }
    function safeGet(object, key) {
      if (key === "constructor" && typeof object[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object[key];
    }
    var setToString = shortOut(baseSetToString);
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });
    function constant(value) {
      return function() {
        return value;
      };
    }
    function identity(value) {
      return value;
    }
    function stubFalse() {
      return false;
    }
    module.exports = merge;
  }
});

// ../../node_modules/eslint/package.json
var require_package2 = __commonJS({
  "../../node_modules/eslint/package.json"(exports, module) {
    module.exports = {
      name: "eslint",
      version: "8.45.0",
      author: "Nicholas C. Zakas <nicholas+npm@nczconsulting.com>",
      description: "An AST-based pattern checker for JavaScript.",
      bin: {
        eslint: "./bin/eslint.js"
      },
      main: "./lib/api.js",
      exports: {
        "./package.json": "./package.json",
        ".": "./lib/api.js",
        "./use-at-your-own-risk": "./lib/unsupported-api.js"
      },
      scripts: {
        "build:docs:update-links": "node tools/fetch-docs-links.js",
        "build:site": "node Makefile.js gensite",
        "build:webpack": "node Makefile.js webpack",
        "build:readme": "node tools/update-readme.js",
        lint: "node Makefile.js lint",
        "lint:docs:js": "node Makefile.js lintDocsJS",
        "lint:fix": "node Makefile.js lint -- fix",
        "lint:fix:docs:js": "node Makefile.js lintDocsJS -- fix",
        "release:generate:alpha": "node Makefile.js generatePrerelease -- alpha",
        "release:generate:beta": "node Makefile.js generatePrerelease -- beta",
        "release:generate:latest": "node Makefile.js generateRelease",
        "release:generate:rc": "node Makefile.js generatePrerelease -- rc",
        "release:publish": "node Makefile.js publishRelease",
        test: "node Makefile.js test",
        "test:cli": "mocha",
        "test:fuzz": "node Makefile.js fuzz",
        "test:performance": "node Makefile.js perf"
      },
      gitHooks: {
        "pre-commit": "lint-staged"
      },
      "lint-staged": {
        "*.js": "eslint --fix",
        "*.md": "markdownlint --fix",
        "lib/rules/*.js": [
          "node tools/update-eslint-all.js",
          "git add packages/js/src/configs/eslint-all.js"
        ],
        "docs/src/rules/*.md": [
          "node tools/fetch-docs-links.js",
          "git add docs/src/_data/further_reading_links.json"
        ],
        "docs/**/*.svg": "npx svgo -r --multipass"
      },
      files: [
        "LICENSE",
        "README.md",
        "bin",
        "conf",
        "lib",
        "messages"
      ],
      repository: "eslint/eslint",
      funding: "https://opencollective.com/eslint",
      homepage: "https://eslint.org",
      bugs: "https://github.com/eslint/eslint/issues/",
      dependencies: {
        "@eslint-community/eslint-utils": "^4.2.0",
        "@eslint-community/regexpp": "^4.4.0",
        "@eslint/eslintrc": "^2.1.0",
        "@eslint/js": "8.44.0",
        "@humanwhocodes/config-array": "^0.11.10",
        "@humanwhocodes/module-importer": "^1.0.1",
        "@nodelib/fs.walk": "^1.2.8",
        ajv: "^6.10.0",
        chalk: "^4.0.0",
        "cross-spawn": "^7.0.2",
        debug: "^4.3.2",
        doctrine: "^3.0.0",
        "escape-string-regexp": "^4.0.0",
        "eslint-scope": "^7.2.0",
        "eslint-visitor-keys": "^3.4.1",
        espree: "^9.6.0",
        esquery: "^1.4.2",
        esutils: "^2.0.2",
        "fast-deep-equal": "^3.1.3",
        "file-entry-cache": "^6.0.1",
        "find-up": "^5.0.0",
        "glob-parent": "^6.0.2",
        globals: "^13.19.0",
        graphemer: "^1.4.0",
        ignore: "^5.2.0",
        imurmurhash: "^0.1.4",
        "is-glob": "^4.0.0",
        "is-path-inside": "^3.0.3",
        "js-yaml": "^4.1.0",
        "json-stable-stringify-without-jsonify": "^1.0.1",
        levn: "^0.4.1",
        "lodash.merge": "^4.6.2",
        minimatch: "^3.1.2",
        "natural-compare": "^1.4.0",
        optionator: "^0.9.3",
        "strip-ansi": "^6.0.1",
        "text-table": "^0.2.0"
      },
      devDependencies: {
        "@babel/core": "^7.4.3",
        "@babel/preset-env": "^7.4.3",
        "babel-loader": "^8.0.5",
        c8: "^7.12.0",
        chai: "^4.0.1",
        cheerio: "^0.22.0",
        "common-tags": "^1.8.0",
        "core-js": "^3.1.3",
        ejs: "^3.0.2",
        eslint: "file:.",
        "eslint-config-eslint": "file:packages/eslint-config-eslint",
        "eslint-plugin-eslint-comments": "^3.2.0",
        "eslint-plugin-eslint-plugin": "^5.1.0",
        "eslint-plugin-internal-rules": "file:tools/internal-rules",
        "eslint-plugin-jsdoc": "^46.2.5",
        "eslint-plugin-n": "^16.0.0",
        "eslint-plugin-unicorn": "^42.0.0",
        "eslint-release": "^3.2.0",
        eslump: "^3.0.0",
        esprima: "^4.0.1",
        "fast-glob": "^3.2.11",
        "fs-teardown": "^0.1.3",
        glob: "^7.1.6",
        got: "^11.8.3",
        "gray-matter": "^4.0.3",
        karma: "^6.1.1",
        "karma-chrome-launcher": "^3.1.0",
        "karma-mocha": "^2.0.1",
        "karma-mocha-reporter": "^2.2.5",
        "karma-webpack": "^5.0.0",
        "lint-staged": "^11.0.0",
        "load-perf": "^0.2.0",
        markdownlint: "^0.25.1",
        "markdownlint-cli": "^0.31.1",
        marked: "^4.0.8",
        memfs: "^3.0.1",
        metascraper: "^5.25.7",
        "metascraper-description": "^5.25.7",
        "metascraper-image": "^5.29.3",
        "metascraper-logo": "^5.25.7",
        "metascraper-logo-favicon": "^5.25.7",
        "metascraper-title": "^5.25.7",
        mocha: "^8.3.2",
        "mocha-junit-reporter": "^2.0.0",
        "node-polyfill-webpack-plugin": "^1.0.3",
        "npm-license": "^0.3.3",
        pirates: "^4.0.5",
        progress: "^2.0.3",
        proxyquire: "^2.0.1",
        puppeteer: "^13.7.0",
        recast: "^0.20.4",
        "regenerator-runtime": "^0.13.2",
        semver: "^7.5.3",
        shelljs: "^0.8.2",
        sinon: "^11.0.0",
        webpack: "^5.23.0",
        "webpack-cli": "^4.5.0",
        yorkie: "^2.0.0"
      },
      keywords: [
        "ast",
        "lint",
        "javascript",
        "ecmascript",
        "espree"
      ],
      license: "MIT",
      engines: {
        node: "^12.22.0 || ^14.17.0 || >=16.0.0"
      }
    };
  }
});

// ../../node_modules/eslint/lib/shared/ast-utils.js
var require_ast_utils = __commonJS({
  "../../node_modules/eslint/lib/shared/ast-utils.js"(exports, module) {
    "use strict";
    var breakableTypePattern = /^(?:(?:Do)?While|For(?:In|Of)?|Switch)Statement$/u;
    var lineBreakPattern = /\r\n|[\r\n\u2028\u2029]/u;
    var shebangPattern = /^#!([^\r\n]+)/u;
    function createGlobalLinebreakMatcher() {
      return new RegExp(lineBreakPattern.source, "gu");
    }
    module.exports = {
      breakableTypePattern,
      lineBreakPattern,
      createGlobalLinebreakMatcher,
      shebangPattern
    };
  }
});

// ../../node_modules/eslint/lib/shared/directives.js
var require_directives = __commonJS({
  "../../node_modules/eslint/lib/shared/directives.js"(exports, module) {
    "use strict";
    var directivesPattern = /^(eslint(?:-env|-enable|-disable(?:(?:-next)?-line)?)?|exported|globals?)(?:\s|$)/u;
    module.exports = {
      directivesPattern
    };
  }
});

// ../../node_modules/uri-js/dist/es5/uri.all.js
var require_uri_all = __commonJS({
  "../../node_modules/uri-js/dist/es5/uri.all.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.URI = global2.URI || {});
    })(exports, function(exports2) {
      "use strict";
      function merge() {
        for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
          sets[_key] = arguments[_key];
        }
        if (sets.length > 1) {
          sets[0] = sets[0].slice(0, -1);
          var xl = sets.length - 1;
          for (var x = 1; x < xl; ++x) {
            sets[x] = sets[x].slice(1, -1);
          }
          sets[xl] = sets[xl].slice(1);
          return sets.join("");
        } else {
          return sets[0];
        }
      }
      function subexp(str) {
        return "(?:" + str + ")";
      }
      function typeOf(o) {
        return o === void 0 ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
      }
      function toUpperCase(str) {
        return str.toUpperCase();
      }
      function toArray(obj) {
        return obj !== void 0 && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
      }
      function assign(target, source) {
        var obj = target;
        if (source) {
          for (var key in source) {
            obj[key] = source[key];
          }
        }
        return obj;
      }
      function buildExps(isIRI2) {
        var ALPHA$$ = "[A-Za-z]", CR$ = "[\\x0D]", DIGIT$$ = "[0-9]", DQUOTE$$ = "[\\x22]", HEXDIG$$2 = merge(DIGIT$$, "[A-Fa-f]"), LF$$ = "[\\x0A]", SP$$ = "[\\x20]", PCT_ENCODED$2 = subexp(subexp("%[EFef]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%" + HEXDIG$$2 + HEXDIG$$2)), GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI2 ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", IPRIVATE$$ = isIRI2 ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$2 = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"), USERINFO$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]")) + "*"), DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$), DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$2 + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$2 + "|" + PCT_ENCODED$2) + "+"), IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$), IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + ZONEID$), IPVFUTURE$ = subexp("[vV]" + HEXDIG$$2 + "+\\." + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]") + "+"), IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"), REG_NAME$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$)) + "*"), HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")|" + REG_NAME$), PORT$ = subexp(DIGIT$$ + "*"), AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"), PCHAR$ = subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@]")), SEGMENT$ = subexp(PCHAR$ + "*"), SEGMENT_NZ$ = subexp(PCHAR$ + "+"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\@]")) + "+"), PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"), PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"), PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), PATH_EMPTY$ = "(?!" + PCHAR$ + ")", PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*"), FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"), HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$), ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"), GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$", SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
        return {
          NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
          NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
          NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
          ESCAPE: new RegExp(merge("[^]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          UNRESERVED: new RegExp(UNRESERVED$$2, "g"),
          OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$2, RESERVED$$), "g"),
          PCT_ENCODED: new RegExp(PCT_ENCODED$2, "g"),
          IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
          IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
          //RFC 6874, with relaxed parsing rules
        };
      }
      var URI_PROTOCOL = buildExps(false);
      var IRI_PROTOCOL = buildExps(true);
      var slicedToArray = function() {
        function sliceIterator(arr, i) {
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = void 0;
          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i && _arr.length === i)
                break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"])
                _i["return"]();
            } finally {
              if (_d)
                throw _e;
            }
          }
          return _arr;
        }
        return function(arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();
      var toConsumableArray = function(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++)
            arr2[i] = arr[i];
          return arr2;
        } else {
          return Array.from(arr);
        }
      };
      var maxInt = 2147483647;
      var base = 36;
      var tMin = 1;
      var tMax = 26;
      var skew = 38;
      var damp = 700;
      var initialBias = 72;
      var initialN = 128;
      var delimiter = "-";
      var regexPunycode = /^xn--/;
      var regexNonASCII = /[^\0-\x7E]/;
      var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
      var errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      };
      var baseMinusTMin = base - tMin;
      var floor = Math.floor;
      var stringFromCharCode = String.fromCharCode;
      function error$1(type) {
        throw new RangeError(errors[type]);
      }
      function map(array, fn) {
        var result = [];
        var length = array.length;
        while (length--) {
          result[length] = fn(array[length]);
        }
        return result;
      }
      function mapDomain(string, fn) {
        var parts = string.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string = parts[1];
        }
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map(labels, fn).join(".");
        return result + encoded;
      }
      function ucs2decode(string) {
        var output = [];
        var counter = 0;
        var length = string.length;
        while (counter < length) {
          var value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            var extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      var ucs2encode = function ucs2encode2(array) {
        return String.fromCodePoint.apply(String, toConsumableArray(array));
      };
      var basicToDigit = function basicToDigit2(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      };
      var digitToBasic = function digitToBasic2(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      };
      var adapt = function adapt2(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (
          ;
          /* no initialization */
          delta > baseMinusTMin * tMax >> 1;
          k += base
        ) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      };
      var decode = function decode2(input) {
        var output = [];
        var inputLength = input.length;
        var i = 0;
        var n = initialN;
        var bias = initialBias;
        var basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (var j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 128) {
            error$1("not-basic");
          }
          output.push(input.charCodeAt(j));
        }
        for (var index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          var oldi = i;
          for (
            var w = 1, k = base;
            ;
            /* no condition */
            k += base
          ) {
            if (index >= inputLength) {
              error$1("invalid-input");
            }
            var digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base || digit > floor((maxInt - i) / w)) {
              error$1("overflow");
            }
            i += digit * w;
            var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t) {
              break;
            }
            var baseMinusT = base - t;
            if (w > floor(maxInt / baseMinusT)) {
              error$1("overflow");
            }
            w *= baseMinusT;
          }
          var out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor(i / out) > maxInt - n) {
            error$1("overflow");
          }
          n += floor(i / out);
          i %= out;
          output.splice(i++, 0, n);
        }
        return String.fromCodePoint.apply(String, output);
      };
      var encode = function encode2(input) {
        var output = [];
        input = ucs2decode(input);
        var inputLength = input.length;
        var n = initialN;
        var delta = 0;
        var bias = initialBias;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = void 0;
        try {
          for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _currentValue2 = _step.value;
            if (_currentValue2 < 128) {
              output.push(stringFromCharCode(_currentValue2));
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        var basicLength = output.length;
        var handledCPCount = basicLength;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          var m = maxInt;
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = void 0;
          try {
            for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var currentValue = _step2.value;
              if (currentValue >= n && currentValue < m) {
                m = currentValue;
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
          var handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error$1("overflow");
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = void 0;
          try {
            for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var _currentValue = _step3.value;
              if (_currentValue < n && ++delta > maxInt) {
                error$1("overflow");
              }
              if (_currentValue == n) {
                var q = delta;
                for (
                  var k = base;
                  ;
                  /* no condition */
                  k += base
                ) {
                  var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                  if (q < t) {
                    break;
                  }
                  var qMinusT = q - t;
                  var baseMinusT = base - t;
                  output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                  q = floor(qMinusT / baseMinusT);
                }
                output.push(stringFromCharCode(digitToBasic(q, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
          ++delta;
          ++n;
        }
        return output.join("");
      };
      var toUnicode = function toUnicode2(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
      };
      var toASCII = function toASCII2(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
        });
      };
      var punycode = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        "version": "2.1.0",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode,
        "encode": encode,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      var SCHEMES = {};
      function pctEncChar(chr) {
        var c = chr.charCodeAt(0);
        var e = void 0;
        if (c < 16)
          e = "%0" + c.toString(16).toUpperCase();
        else if (c < 128)
          e = "%" + c.toString(16).toUpperCase();
        else if (c < 2048)
          e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        else
          e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        return e;
      }
      function pctDecChars(str) {
        var newStr = "";
        var i = 0;
        var il = str.length;
        while (i < il) {
          var c = parseInt(str.substr(i + 1, 2), 16);
          if (c < 128) {
            newStr += String.fromCharCode(c);
            i += 3;
          } else if (c >= 194 && c < 224) {
            if (il - i >= 6) {
              var c2 = parseInt(str.substr(i + 4, 2), 16);
              newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
            } else {
              newStr += str.substr(i, 6);
            }
            i += 6;
          } else if (c >= 224) {
            if (il - i >= 9) {
              var _c = parseInt(str.substr(i + 4, 2), 16);
              var c3 = parseInt(str.substr(i + 7, 2), 16);
              newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
            } else {
              newStr += str.substr(i, 9);
            }
            i += 9;
          } else {
            newStr += str.substr(i, 3);
            i += 3;
          }
        }
        return newStr;
      }
      function _normalizeComponentEncoding(components, protocol) {
        function decodeUnreserved2(str) {
          var decStr = pctDecChars(str);
          return !decStr.match(protocol.UNRESERVED) ? str : decStr;
        }
        if (components.scheme)
          components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_SCHEME, "");
        if (components.userinfo !== void 0)
          components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.host !== void 0)
          components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.path !== void 0)
          components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.query !== void 0)
          components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.fragment !== void 0)
          components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        return components;
      }
      function _stripLeadingZeros(str) {
        return str.replace(/^0*(.*)/, "$1") || "0";
      }
      function _normalizeIPv4(host, protocol) {
        var matches = host.match(protocol.IPV4ADDRESS) || [];
        var _matches = slicedToArray(matches, 2), address = _matches[1];
        if (address) {
          return address.split(".").map(_stripLeadingZeros).join(".");
        } else {
          return host;
        }
      }
      function _normalizeIPv6(host, protocol) {
        var matches = host.match(protocol.IPV6ADDRESS) || [];
        var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
        if (address) {
          var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
          var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
          var lastFields = last.split(":").map(_stripLeadingZeros);
          var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
          var fieldCount = isLastFieldIPv4Address ? 7 : 8;
          var lastFieldsStart = lastFields.length - fieldCount;
          var fields = Array(fieldCount);
          for (var x = 0; x < fieldCount; ++x) {
            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
          }
          if (isLastFieldIPv4Address) {
            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
          }
          var allZeroFields = fields.reduce(function(acc, field, index) {
            if (!field || field === "0") {
              var lastLongest = acc[acc.length - 1];
              if (lastLongest && lastLongest.index + lastLongest.length === index) {
                lastLongest.length++;
              } else {
                acc.push({ index, length: 1 });
              }
            }
            return acc;
          }, []);
          var longestZeroFields = allZeroFields.sort(function(a, b) {
            return b.length - a.length;
          })[0];
          var newHost = void 0;
          if (longestZeroFields && longestZeroFields.length > 1) {
            var newFirst = fields.slice(0, longestZeroFields.index);
            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
            newHost = newFirst.join(":") + "::" + newLast.join(":");
          } else {
            newHost = fields.join(":");
          }
          if (zone) {
            newHost += "%" + zone;
          }
          return newHost;
        } else {
          return host;
        }
      }
      var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
      var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === void 0;
      function parse(uriString) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var components = {};
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        if (options.reference === "suffix")
          uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
        var matches = uriString.match(URI_PARSE);
        if (matches) {
          if (NO_MATCH_IS_UNDEFINED) {
            components.scheme = matches[1];
            components.userinfo = matches[3];
            components.host = matches[4];
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = matches[7];
            components.fragment = matches[8];
            if (isNaN(components.port)) {
              components.port = matches[5];
            }
          } else {
            components.scheme = matches[1] || void 0;
            components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : void 0;
            components.host = uriString.indexOf("//") !== -1 ? matches[4] : void 0;
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = uriString.indexOf("?") !== -1 ? matches[7] : void 0;
            components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : void 0;
            if (isNaN(components.port)) {
              components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : void 0;
            }
          }
          if (components.host) {
            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
          }
          if (components.scheme === void 0 && components.userinfo === void 0 && components.host === void 0 && components.port === void 0 && !components.path && components.query === void 0) {
            components.reference = "same-document";
          } else if (components.scheme === void 0) {
            components.reference = "relative";
          } else if (components.fragment === void 0) {
            components.reference = "absolute";
          } else {
            components.reference = "uri";
          }
          if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
            components.error = components.error || "URI is not a " + options.reference + " reference.";
          }
          var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
          if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
              try {
                components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
              } catch (e) {
                components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
              }
            }
            _normalizeComponentEncoding(components, URI_PROTOCOL);
          } else {
            _normalizeComponentEncoding(components, protocol);
          }
          if (schemeHandler && schemeHandler.parse) {
            schemeHandler.parse(components, options);
          }
        } else {
          components.error = components.error || "URI can not be parsed.";
        }
        return components;
      }
      function _recomposeAuthority(components, options) {
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        if (components.userinfo !== void 0) {
          uriTokens.push(components.userinfo);
          uriTokens.push("@");
        }
        if (components.host !== void 0) {
          uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {
            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
          }));
        }
        if (typeof components.port === "number" || typeof components.port === "string") {
          uriTokens.push(":");
          uriTokens.push(String(components.port));
        }
        return uriTokens.length ? uriTokens.join("") : void 0;
      }
      var RDS1 = /^\.\.?\//;
      var RDS2 = /^\/\.(\/|$)/;
      var RDS3 = /^\/\.\.(\/|$)/;
      var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
      function removeDotSegments(input) {
        var output = [];
        while (input.length) {
          if (input.match(RDS1)) {
            input = input.replace(RDS1, "");
          } else if (input.match(RDS2)) {
            input = input.replace(RDS2, "/");
          } else if (input.match(RDS3)) {
            input = input.replace(RDS3, "/");
            output.pop();
          } else if (input === "." || input === "..") {
            input = "";
          } else {
            var im = input.match(RDS5);
            if (im) {
              var s = im[0];
              input = input.slice(s.length);
              output.push(s);
            } else {
              throw new Error("Unexpected dot segment condition");
            }
          }
        }
        return output.join("");
      }
      function serialize(components) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        if (schemeHandler && schemeHandler.serialize)
          schemeHandler.serialize(components, options);
        if (components.host) {
          if (protocol.IPV6ADDRESS.test(components.host)) {
          } else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
            try {
              components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
            } catch (e) {
              components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
            }
          }
        }
        _normalizeComponentEncoding(components, protocol);
        if (options.reference !== "suffix" && components.scheme) {
          uriTokens.push(components.scheme);
          uriTokens.push(":");
        }
        var authority = _recomposeAuthority(components, options);
        if (authority !== void 0) {
          if (options.reference !== "suffix") {
            uriTokens.push("//");
          }
          uriTokens.push(authority);
          if (components.path && components.path.charAt(0) !== "/") {
            uriTokens.push("/");
          }
        }
        if (components.path !== void 0) {
          var s = components.path;
          if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
            s = removeDotSegments(s);
          }
          if (authority === void 0) {
            s = s.replace(/^\/\//, "/%2F");
          }
          uriTokens.push(s);
        }
        if (components.query !== void 0) {
          uriTokens.push("?");
          uriTokens.push(components.query);
        }
        if (components.fragment !== void 0) {
          uriTokens.push("#");
          uriTokens.push(components.fragment);
        }
        return uriTokens.join("");
      }
      function resolveComponents(base2, relative) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var skipNormalization = arguments[3];
        var target = {};
        if (!skipNormalization) {
          base2 = parse(serialize(base2, options), options);
          relative = parse(serialize(relative, options), options);
        }
        options = options || {};
        if (!options.tolerant && relative.scheme) {
          target.scheme = relative.scheme;
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
          } else {
            if (!relative.path) {
              target.path = base2.path;
              if (relative.query !== void 0) {
                target.query = relative.query;
              } else {
                target.query = base2.query;
              }
            } else {
              if (relative.path.charAt(0) === "/") {
                target.path = removeDotSegments(relative.path);
              } else {
                if ((base2.userinfo !== void 0 || base2.host !== void 0 || base2.port !== void 0) && !base2.path) {
                  target.path = "/" + relative.path;
                } else if (!base2.path) {
                  target.path = relative.path;
                } else {
                  target.path = base2.path.slice(0, base2.path.lastIndexOf("/") + 1) + relative.path;
                }
                target.path = removeDotSegments(target.path);
              }
              target.query = relative.query;
            }
            target.userinfo = base2.userinfo;
            target.host = base2.host;
            target.port = base2.port;
          }
          target.scheme = base2.scheme;
        }
        target.fragment = relative.fragment;
        return target;
      }
      function resolve(baseURI, relativeURI, options) {
        var schemelessOptions = assign({ scheme: "null" }, options);
        return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
      }
      function normalize(uri, options) {
        if (typeof uri === "string") {
          uri = serialize(parse(uri, options), options);
        } else if (typeOf(uri) === "object") {
          uri = parse(serialize(uri, options), options);
        }
        return uri;
      }
      function equal(uriA, uriB, options) {
        if (typeof uriA === "string") {
          uriA = serialize(parse(uriA, options), options);
        } else if (typeOf(uriA) === "object") {
          uriA = serialize(uriA, options);
        }
        if (typeof uriB === "string") {
          uriB = serialize(parse(uriB, options), options);
        } else if (typeOf(uriB) === "object") {
          uriB = serialize(uriB, options);
        }
        return uriA === uriB;
      }
      function escapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
      }
      function unescapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
      }
      var handler = {
        scheme: "http",
        domainHost: true,
        parse: function parse2(components, options) {
          if (!components.host) {
            components.error = components.error || "HTTP URIs must have a host.";
          }
          return components;
        },
        serialize: function serialize2(components, options) {
          var secure = String(components.scheme).toLowerCase() === "https";
          if (components.port === (secure ? 443 : 80) || components.port === "") {
            components.port = void 0;
          }
          if (!components.path) {
            components.path = "/";
          }
          return components;
        }
      };
      var handler$1 = {
        scheme: "https",
        domainHost: handler.domainHost,
        parse: handler.parse,
        serialize: handler.serialize
      };
      function isSecure(wsComponents) {
        return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
      }
      var handler$2 = {
        scheme: "ws",
        domainHost: true,
        parse: function parse2(components, options) {
          var wsComponents = components;
          wsComponents.secure = isSecure(wsComponents);
          wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
          wsComponents.path = void 0;
          wsComponents.query = void 0;
          return wsComponents;
        },
        serialize: function serialize2(wsComponents, options) {
          if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
            wsComponents.port = void 0;
          }
          if (typeof wsComponents.secure === "boolean") {
            wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
            wsComponents.secure = void 0;
          }
          if (wsComponents.resourceName) {
            var _wsComponents$resourc = wsComponents.resourceName.split("?"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
            wsComponents.path = path && path !== "/" ? path : void 0;
            wsComponents.query = query;
            wsComponents.resourceName = void 0;
          }
          wsComponents.fragment = void 0;
          return wsComponents;
        }
      };
      var handler$3 = {
        scheme: "wss",
        domainHost: handler$2.domainHost,
        parse: handler$2.parse,
        serialize: handler$2.serialize
      };
      var O = {};
      var isIRI = true;
      var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") + "]";
      var HEXDIG$$ = "[0-9A-Fa-f]";
      var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$));
      var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
      var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
      var VCHAR$$ = merge(QTEXT$$, '[\\"\\\\]');
      var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
      var UNRESERVED = new RegExp(UNRESERVED$$, "g");
      var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
      var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
      var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
      var NOT_HFVALUE = NOT_HFNAME;
      function decodeUnreserved(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(UNRESERVED) ? str : decStr;
      }
      var handler$4 = {
        scheme: "mailto",
        parse: function parse$$1(components, options) {
          var mailtoComponents = components;
          var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
          mailtoComponents.path = void 0;
          if (mailtoComponents.query) {
            var unknownHeaders = false;
            var headers = {};
            var hfields = mailtoComponents.query.split("&");
            for (var x = 0, xl = hfields.length; x < xl; ++x) {
              var hfield = hfields[x].split("=");
              switch (hfield[0]) {
                case "to":
                  var toAddrs = hfield[1].split(",");
                  for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                    to.push(toAddrs[_x]);
                  }
                  break;
                case "subject":
                  mailtoComponents.subject = unescapeComponent(hfield[1], options);
                  break;
                case "body":
                  mailtoComponents.body = unescapeComponent(hfield[1], options);
                  break;
                default:
                  unknownHeaders = true;
                  headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                  break;
              }
            }
            if (unknownHeaders)
              mailtoComponents.headers = headers;
          }
          mailtoComponents.query = void 0;
          for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
            var addr = to[_x2].split("@");
            addr[0] = unescapeComponent(addr[0]);
            if (!options.unicodeSupport) {
              try {
                addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
              } catch (e) {
                mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
              }
            } else {
              addr[1] = unescapeComponent(addr[1], options).toLowerCase();
            }
            to[_x2] = addr.join("@");
          }
          return mailtoComponents;
        },
        serialize: function serialize$$1(mailtoComponents, options) {
          var components = mailtoComponents;
          var to = toArray(mailtoComponents.to);
          if (to) {
            for (var x = 0, xl = to.length; x < xl; ++x) {
              var toAddr = String(to[x]);
              var atIdx = toAddr.lastIndexOf("@");
              var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
              var domain = toAddr.slice(atIdx + 1);
              try {
                domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
              } catch (e) {
                components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
              }
              to[x] = localPart + "@" + domain;
            }
            components.path = to.join(",");
          }
          var headers = mailtoComponents.headers = mailtoComponents.headers || {};
          if (mailtoComponents.subject)
            headers["subject"] = mailtoComponents.subject;
          if (mailtoComponents.body)
            headers["body"] = mailtoComponents.body;
          var fields = [];
          for (var name in headers) {
            if (headers[name] !== O[name]) {
              fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
            }
          }
          if (fields.length) {
            components.query = fields.join("&");
          }
          return components;
        }
      };
      var URN_PARSE = /^([^\:]+)\:(.*)/;
      var handler$5 = {
        scheme: "urn",
        parse: function parse$$1(components, options) {
          var matches = components.path && components.path.match(URN_PARSE);
          var urnComponents = components;
          if (matches) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = matches[1].toLowerCase();
            var nss = matches[2];
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            urnComponents.nid = nid;
            urnComponents.nss = nss;
            urnComponents.path = void 0;
            if (schemeHandler) {
              urnComponents = schemeHandler.parse(urnComponents, options);
            }
          } else {
            urnComponents.error = urnComponents.error || "URN can not be parsed.";
          }
          return urnComponents;
        },
        serialize: function serialize$$1(urnComponents, options) {
          var scheme = options.scheme || urnComponents.scheme || "urn";
          var nid = urnComponents.nid;
          var urnScheme = scheme + ":" + (options.nid || nid);
          var schemeHandler = SCHEMES[urnScheme];
          if (schemeHandler) {
            urnComponents = schemeHandler.serialize(urnComponents, options);
          }
          var uriComponents = urnComponents;
          var nss = urnComponents.nss;
          uriComponents.path = (nid || options.nid) + ":" + nss;
          return uriComponents;
        }
      };
      var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
      var handler$6 = {
        scheme: "urn:uuid",
        parse: function parse2(urnComponents, options) {
          var uuidComponents = urnComponents;
          uuidComponents.uuid = uuidComponents.nss;
          uuidComponents.nss = void 0;
          if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
          }
          return uuidComponents;
        },
        serialize: function serialize2(uuidComponents, options) {
          var urnComponents = uuidComponents;
          urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
          return urnComponents;
        }
      };
      SCHEMES[handler.scheme] = handler;
      SCHEMES[handler$1.scheme] = handler$1;
      SCHEMES[handler$2.scheme] = handler$2;
      SCHEMES[handler$3.scheme] = handler$3;
      SCHEMES[handler$4.scheme] = handler$4;
      SCHEMES[handler$5.scheme] = handler$5;
      SCHEMES[handler$6.scheme] = handler$6;
      exports2.SCHEMES = SCHEMES;
      exports2.pctEncChar = pctEncChar;
      exports2.pctDecChars = pctDecChars;
      exports2.parse = parse;
      exports2.removeDotSegments = removeDotSegments;
      exports2.serialize = serialize;
      exports2.resolveComponents = resolveComponents;
      exports2.resolve = resolve;
      exports2.normalize = normalize;
      exports2.equal = equal;
      exports2.escapeComponent = escapeComponent;
      exports2.unescapeComponent = unescapeComponent;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// ../../node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "../../node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    module.exports = function equal(a, b) {
      if (a === b)
        return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor)
          return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i]))
              return false;
          return true;
        }
        if (a.constructor === RegExp)
          return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf)
          return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString)
          return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length)
          return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
            return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b[key]))
            return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// ../../node_modules/ajv/lib/compile/ucs2length.js
var require_ucs2length = __commonJS({
  "../../node_modules/ajv/lib/compile/ucs2length.js"(exports, module) {
    "use strict";
    module.exports = function ucs2length(str) {
      var length = 0, len = str.length, pos = 0, value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str.charCodeAt(pos);
          if ((value & 64512) == 56320)
            pos++;
        }
      }
      return length;
    };
  }
});

// ../../node_modules/ajv/lib/compile/util.js
var require_util2 = __commonJS({
  "../../node_modules/ajv/lib/compile/util.js"(exports, module) {
    "use strict";
    module.exports = {
      copy,
      checkDataType,
      checkDataTypes,
      coerceToTypes,
      toHash,
      getProperty,
      escapeQuotes,
      equal: require_fast_deep_equal(),
      ucs2length: require_ucs2length(),
      varOccurences,
      varReplace,
      schemaHasRules,
      schemaHasRulesExcept,
      schemaUnknownRules,
      toQuotedString,
      getPathExpr,
      getPath,
      getData,
      unescapeFragment,
      unescapeJsonPointer,
      escapeFragment,
      escapeJsonPointer
    };
    function copy(o, to) {
      to = to || {};
      for (var key in o)
        to[key] = o[key];
      return to;
    }
    function checkDataType(dataType, data, strictNumbers, negate) {
      var EQUAL = negate ? " !== " : " === ", AND = negate ? " || " : " && ", OK = negate ? "!" : "", NOT = negate ? "" : "!";
      switch (dataType) {
        case "null":
          return data + EQUAL + "null";
        case "array":
          return OK + "Array.isArray(" + data + ")";
        case "object":
          return "(" + OK + data + AND + "typeof " + data + EQUAL + '"object"' + AND + NOT + "Array.isArray(" + data + "))";
        case "integer":
          return "(typeof " + data + EQUAL + '"number"' + AND + NOT + "(" + data + " % 1)" + AND + data + EQUAL + data + (strictNumbers ? AND + OK + "isFinite(" + data + ")" : "") + ")";
        case "number":
          return "(typeof " + data + EQUAL + '"' + dataType + '"' + (strictNumbers ? AND + OK + "isFinite(" + data + ")" : "") + ")";
        default:
          return "typeof " + data + EQUAL + '"' + dataType + '"';
      }
    }
    function checkDataTypes(dataTypes, data, strictNumbers) {
      switch (dataTypes.length) {
        case 1:
          return checkDataType(dataTypes[0], data, strictNumbers, true);
        default:
          var code = "";
          var types = toHash(dataTypes);
          if (types.array && types.object) {
            code = types.null ? "(" : "(!" + data + " || ";
            code += "typeof " + data + ' !== "object")';
            delete types.null;
            delete types.array;
            delete types.object;
          }
          if (types.number)
            delete types.integer;
          for (var t in types)
            code += (code ? " && " : "") + checkDataType(t, data, strictNumbers, true);
          return code;
      }
    }
    var COERCE_TO_TYPES = toHash(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(optionCoerceTypes, dataTypes) {
      if (Array.isArray(dataTypes)) {
        var types = [];
        for (var i = 0; i < dataTypes.length; i++) {
          var t = dataTypes[i];
          if (COERCE_TO_TYPES[t])
            types[types.length] = t;
          else if (optionCoerceTypes === "array" && t === "array")
            types[types.length] = t;
        }
        if (types.length)
          return types;
      } else if (COERCE_TO_TYPES[dataTypes]) {
        return [dataTypes];
      } else if (optionCoerceTypes === "array" && dataTypes === "array") {
        return ["array"];
      }
    }
    function toHash(arr) {
      var hash = {};
      for (var i = 0; i < arr.length; i++)
        hash[arr[i]] = true;
      return hash;
    }
    var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var SINGLE_QUOTE = /'|\\/g;
    function getProperty(key) {
      return typeof key == "number" ? "[" + key + "]" : IDENTIFIER.test(key) ? "." + key : "['" + escapeQuotes(key) + "']";
    }
    function escapeQuotes(str) {
      return str.replace(SINGLE_QUOTE, "\\$&").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\f/g, "\\f").replace(/\t/g, "\\t");
    }
    function varOccurences(str, dataVar) {
      dataVar += "[^0-9]";
      var matches = str.match(new RegExp(dataVar, "g"));
      return matches ? matches.length : 0;
    }
    function varReplace(str, dataVar, expr) {
      dataVar += "([^0-9])";
      expr = expr.replace(/\$/g, "$$$$");
      return str.replace(new RegExp(dataVar, "g"), expr + "$1");
    }
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean")
        return !schema;
      for (var key in schema)
        if (rules[key])
          return true;
    }
    function schemaHasRulesExcept(schema, rules, exceptKeyword) {
      if (typeof schema == "boolean")
        return !schema && exceptKeyword != "not";
      for (var key in schema)
        if (key != exceptKeyword && rules[key])
          return true;
    }
    function schemaUnknownRules(schema, rules) {
      if (typeof schema == "boolean")
        return;
      for (var key in schema)
        if (!rules[key])
          return key;
    }
    function toQuotedString(str) {
      return "'" + escapeQuotes(str) + "'";
    }
    function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
      var path = jsonPointers ? "'/' + " + expr + (isNumber ? "" : ".replace(/~/g, '~0').replace(/\\//g, '~1')") : isNumber ? "'[' + " + expr + " + ']'" : "'[\\'' + " + expr + " + '\\']'";
      return joinPaths(currentPath, path);
    }
    function getPath(currentPath, prop, jsonPointers) {
      var path = jsonPointers ? toQuotedString("/" + escapeJsonPointer(prop)) : toQuotedString(getProperty(prop));
      return joinPaths(currentPath, path);
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, lvl, paths) {
      var up, jsonPointer, data, matches;
      if ($data === "")
        return "rootData";
      if ($data[0] == "/") {
        if (!JSON_POINTER.test($data))
          throw new Error("Invalid JSON-pointer: " + $data);
        jsonPointer = $data;
        data = "rootData";
      } else {
        matches = $data.match(RELATIVE_JSON_POINTER);
        if (!matches)
          throw new Error("Invalid JSON-pointer: " + $data);
        up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer == "#") {
          if (up >= lvl)
            throw new Error("Cannot access property/index " + up + " levels up, current level is " + lvl);
          return paths[lvl - up];
        }
        if (up > lvl)
          throw new Error("Cannot access data " + up + " levels up, current level is " + lvl);
        data = "data" + (lvl - up || "");
        if (!jsonPointer)
          return data;
      }
      var expr = data;
      var segments = jsonPointer.split("/");
      for (var i = 0; i < segments.length; i++) {
        var segment = segments[i];
        if (segment) {
          data += getProperty(unescapeJsonPointer(segment));
          expr += " && " + data;
        }
      }
      return expr;
    }
    function joinPaths(a, b) {
      if (a == '""')
        return b;
      return (a + " + " + b).replace(/([^\\])' \+ '/g, "$1");
    }
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    function escapeJsonPointer(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
  }
});

// ../../node_modules/ajv/lib/compile/schema_obj.js
var require_schema_obj = __commonJS({
  "../../node_modules/ajv/lib/compile/schema_obj.js"(exports, module) {
    "use strict";
    var util = require_util2();
    module.exports = SchemaObject;
    function SchemaObject(obj) {
      util.copy(obj, this);
    }
  }
});

// ../../node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "../../node_modules/json-schema-traverse/index.js"(exports, module) {
    "use strict";
    var traverse = module.exports = function(schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema, "", schema);
    };
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse.propsKeywords = {
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            }
          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
            _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// ../../node_modules/ajv/lib/compile/resolve.js
var require_resolve = __commonJS({
  "../../node_modules/ajv/lib/compile/resolve.js"(exports, module) {
    "use strict";
    var URI = require_uri_all();
    var equal = require_fast_deep_equal();
    var util = require_util2();
    var SchemaObject = require_schema_obj();
    var traverse = require_json_schema_traverse();
    module.exports = resolve;
    resolve.normalizeId = normalizeId;
    resolve.fullPath = getFullPath;
    resolve.url = resolveUrl;
    resolve.ids = resolveIds;
    resolve.inlineRef = inlineRef;
    resolve.schema = resolveSchema;
    function resolve(compile, root, ref) {
      var refVal = this._refs[ref];
      if (typeof refVal == "string") {
        if (this._refs[refVal])
          refVal = this._refs[refVal];
        else
          return resolve.call(this, compile, root, refVal);
      }
      refVal = refVal || this._schemas[ref];
      if (refVal instanceof SchemaObject) {
        return inlineRef(refVal.schema, this._opts.inlineRefs) ? refVal.schema : refVal.validate || this._compile(refVal);
      }
      var res = resolveSchema.call(this, root, ref);
      var schema, v, baseId;
      if (res) {
        schema = res.schema;
        root = res.root;
        baseId = res.baseId;
      }
      if (schema instanceof SchemaObject) {
        v = schema.validate || compile.call(this, schema.schema, root, void 0, baseId);
      } else if (schema !== void 0) {
        v = inlineRef(schema, this._opts.inlineRefs) ? schema : compile.call(this, schema, root, void 0, baseId);
      }
      return v;
    }
    function resolveSchema(root, ref) {
      var p = URI.parse(ref), refPath = _getFullPath(p), baseId = getFullPath(this._getId(root.schema));
      if (Object.keys(root.schema).length === 0 || refPath !== baseId) {
        var id = normalizeId(refPath);
        var refVal = this._refs[id];
        if (typeof refVal == "string") {
          return resolveRecursive.call(this, root, refVal, p);
        } else if (refVal instanceof SchemaObject) {
          if (!refVal.validate)
            this._compile(refVal);
          root = refVal;
        } else {
          refVal = this._schemas[id];
          if (refVal instanceof SchemaObject) {
            if (!refVal.validate)
              this._compile(refVal);
            if (id == normalizeId(ref))
              return { schema: refVal, root, baseId };
            root = refVal;
          } else {
            return;
          }
        }
        if (!root.schema)
          return;
        baseId = getFullPath(this._getId(root.schema));
      }
      return getJsonPointer.call(this, p, baseId, root.schema, root);
    }
    function resolveRecursive(root, ref, parsedRef) {
      var res = resolveSchema.call(this, root, ref);
      if (res) {
        var schema = res.schema;
        var baseId = res.baseId;
        root = res.root;
        var id = this._getId(schema);
        if (id)
          baseId = resolveUrl(baseId, id);
        return getJsonPointer.call(this, parsedRef, baseId, schema, root);
      }
    }
    var PREVENT_SCOPE_CHANGE = util.toHash(["properties", "patternProperties", "enum", "dependencies", "definitions"]);
    function getJsonPointer(parsedRef, baseId, schema, root) {
      parsedRef.fragment = parsedRef.fragment || "";
      if (parsedRef.fragment.slice(0, 1) != "/")
        return;
      var parts = parsedRef.fragment.split("/");
      for (var i = 1; i < parts.length; i++) {
        var part = parts[i];
        if (part) {
          part = util.unescapeFragment(part);
          schema = schema[part];
          if (schema === void 0)
            break;
          var id;
          if (!PREVENT_SCOPE_CHANGE[part]) {
            id = this._getId(schema);
            if (id)
              baseId = resolveUrl(baseId, id);
            if (schema.$ref) {
              var $ref = resolveUrl(baseId, schema.$ref);
              var res = resolveSchema.call(this, root, $ref);
              if (res) {
                schema = res.schema;
                root = res.root;
                baseId = res.baseId;
              }
            }
          }
        }
      }
      if (schema !== void 0 && schema !== root.schema)
        return { schema, root, baseId };
    }
    var SIMPLE_INLINED = util.toHash([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum"
    ]);
    function inlineRef(schema, limit) {
      if (limit === false)
        return false;
      if (limit === void 0 || limit === true)
        return checkNoRef(schema);
      else if (limit)
        return countKeys(schema) <= limit;
    }
    function checkNoRef(schema) {
      var item;
      if (Array.isArray(schema)) {
        for (var i = 0; i < schema.length; i++) {
          item = schema[i];
          if (typeof item == "object" && !checkNoRef(item))
            return false;
        }
      } else {
        for (var key in schema) {
          if (key == "$ref")
            return false;
          item = schema[key];
          if (typeof item == "object" && !checkNoRef(item))
            return false;
        }
      }
      return true;
    }
    function countKeys(schema) {
      var count = 0, item;
      if (Array.isArray(schema)) {
        for (var i = 0; i < schema.length; i++) {
          item = schema[i];
          if (typeof item == "object")
            count += countKeys(item);
          if (count == Infinity)
            return Infinity;
        }
      } else {
        for (var key in schema) {
          if (key == "$ref")
            return Infinity;
          if (SIMPLE_INLINED[key]) {
            count++;
          } else {
            item = schema[key];
            if (typeof item == "object")
              count += countKeys(item) + 1;
            if (count == Infinity)
              return Infinity;
          }
        }
      }
      return count;
    }
    function getFullPath(id, normalize) {
      if (normalize !== false)
        id = normalizeId(id);
      var p = URI.parse(id);
      return _getFullPath(p);
    }
    function _getFullPath(p) {
      return URI.serialize(p).split("#")[0] + "#";
    }
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    function resolveUrl(baseId, id) {
      id = normalizeId(id);
      return URI.resolve(baseId, id);
    }
    function resolveIds(schema) {
      var schemaId = normalizeId(this._getId(schema));
      var baseIds = { "": schemaId };
      var fullPaths = { "": getFullPath(schemaId, false) };
      var localRefs = {};
      var self2 = this;
      traverse(schema, { allKeys: true }, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
        if (jsonPtr === "")
          return;
        var id = self2._getId(sch);
        var baseId = baseIds[parentJsonPtr];
        var fullPath = fullPaths[parentJsonPtr] + "/" + parentKeyword;
        if (keyIndex !== void 0)
          fullPath += "/" + (typeof keyIndex == "number" ? keyIndex : util.escapeFragment(keyIndex));
        if (typeof id == "string") {
          id = baseId = normalizeId(baseId ? URI.resolve(baseId, id) : id);
          var refVal = self2._refs[id];
          if (typeof refVal == "string")
            refVal = self2._refs[refVal];
          if (refVal && refVal.schema) {
            if (!equal(sch, refVal.schema))
              throw new Error('id "' + id + '" resolves to more than one schema');
          } else if (id != normalizeId(fullPath)) {
            if (id[0] == "#") {
              if (localRefs[id] && !equal(sch, localRefs[id]))
                throw new Error('id "' + id + '" resolves to more than one schema');
              localRefs[id] = sch;
            } else {
              self2._refs[id] = fullPath;
            }
          }
        }
        baseIds[jsonPtr] = baseId;
        fullPaths[jsonPtr] = fullPath;
      });
      return localRefs;
    }
  }
});

// ../../node_modules/ajv/lib/compile/error_classes.js
var require_error_classes = __commonJS({
  "../../node_modules/ajv/lib/compile/error_classes.js"(exports, module) {
    "use strict";
    var resolve = require_resolve();
    module.exports = {
      Validation: errorSubclass(ValidationError),
      MissingRef: errorSubclass(MissingRefError)
    };
    function ValidationError(errors) {
      this.message = "validation failed";
      this.errors = errors;
      this.ajv = this.validation = true;
    }
    MissingRefError.message = function(baseId, ref) {
      return "can't resolve reference " + ref + " from id " + baseId;
    };
    function MissingRefError(baseId, ref, message) {
      this.message = message || MissingRefError.message(baseId, ref);
      this.missingRef = resolve.url(baseId, ref);
      this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));
    }
    function errorSubclass(Subclass) {
      Subclass.prototype = Object.create(Error.prototype);
      Subclass.prototype.constructor = Subclass;
      return Subclass;
    }
  }
});

// ../../node_modules/fast-json-stable-stringify/index.js
var require_fast_json_stable_stringify = __commonJS({
  "../../node_modules/fast-json-stable-stringify/index.js"(exports, module) {
    "use strict";
    module.exports = function(data, opts) {
      if (!opts)
        opts = {};
      if (typeof opts === "function")
        opts = { cmp: opts };
      var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
      var cmp = opts.cmp && function(f) {
        return function(node) {
          return function(a, b) {
            var aobj = { key: a, value: node[a] };
            var bobj = { key: b, value: node[b] };
            return f(aobj, bobj);
          };
        };
      }(opts.cmp);
      var seen = [];
      return function stringify(node) {
        if (node && node.toJSON && typeof node.toJSON === "function") {
          node = node.toJSON();
        }
        if (node === void 0)
          return;
        if (typeof node == "number")
          return isFinite(node) ? "" + node : "null";
        if (typeof node !== "object")
          return JSON.stringify(node);
        var i, out;
        if (Array.isArray(node)) {
          out = "[";
          for (i = 0; i < node.length; i++) {
            if (i)
              out += ",";
            out += stringify(node[i]) || "null";
          }
          return out + "]";
        }
        if (node === null)
          return "null";
        if (seen.indexOf(node) !== -1) {
          if (cycles)
            return JSON.stringify("__cycle__");
          throw new TypeError("Converting circular structure to JSON");
        }
        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = "";
        for (i = 0; i < keys.length; i++) {
          var key = keys[i];
          var value = stringify(node[key]);
          if (!value)
            continue;
          if (out)
            out += ",";
          out += JSON.stringify(key) + ":" + value;
        }
        seen.splice(seenIndex, 1);
        return "{" + out + "}";
      }(data);
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/validate.js
var require_validate = __commonJS({
  "../../node_modules/ajv/lib/dotjs/validate.js"(exports, module) {
    "use strict";
    module.exports = function generate_validate(it, $keyword, $ruleType) {
      var out = "";
      var $async = it.schema.$async === true, $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, "$ref"), $id = it.self._getId(it.schema);
      if (it.opts.strictKeywords) {
        var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);
        if ($unknownKwd) {
          var $keywordsMsg = "unknown keyword: " + $unknownKwd;
          if (it.opts.strictKeywords === "log")
            it.logger.warn($keywordsMsg);
          else
            throw new Error($keywordsMsg);
        }
      }
      if (it.isTop) {
        out += " var validate = ";
        if ($async) {
          it.async = true;
          out += "async ";
        }
        out += "function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ";
        if ($id && (it.opts.sourceCode || it.opts.processCode)) {
          out += " " + ("/*# sourceURL=" + $id + " */") + " ";
        }
      }
      if (typeof it.schema == "boolean" || !($refKeywords || it.schema.$ref)) {
        var $keyword = "false schema";
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $errorKeyword;
        var $data = "data" + ($dataLvl || "");
        var $valid = "valid" + $lvl;
        if (it.schema === false) {
          if (it.isTop) {
            $breakOnError = true;
          } else {
            out += " var " + $valid + " = false; ";
          }
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: '" + ($errorKeyword || "false schema") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
            if (it.opts.messages !== false) {
              out += " , message: 'boolean schema is false' ";
            }
            if (it.opts.verbose) {
              out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
        } else {
          if (it.isTop) {
            if ($async) {
              out += " return data; ";
            } else {
              out += " validate.errors = null; return true; ";
            }
          } else {
            out += " var " + $valid + " = true; ";
          }
        }
        if (it.isTop) {
          out += " }; return validate; ";
        }
        return out;
      }
      if (it.isTop) {
        var $top = it.isTop, $lvl = it.level = 0, $dataLvl = it.dataLevel = 0, $data = "data";
        it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
        it.baseId = it.baseId || it.rootId;
        delete it.isTop;
        it.dataPathArr = [""];
        if (it.schema.default !== void 0 && it.opts.useDefaults && it.opts.strictDefaults) {
          var $defaultMsg = "default is ignored in the schema root";
          if (it.opts.strictDefaults === "log")
            it.logger.warn($defaultMsg);
          else
            throw new Error($defaultMsg);
        }
        out += " var vErrors = null; ";
        out += " var errors = 0;     ";
        out += " if (rootData === undefined) rootData = data; ";
      } else {
        var $lvl = it.level, $dataLvl = it.dataLevel, $data = "data" + ($dataLvl || "");
        if ($id)
          it.baseId = it.resolve.url(it.baseId, $id);
        if ($async && !it.async)
          throw new Error("async schema in sync schema");
        out += " var errs_" + $lvl + " = errors;";
      }
      var $valid = "valid" + $lvl, $breakOnError = !it.opts.allErrors, $closingBraces1 = "", $closingBraces2 = "";
      var $errorKeyword;
      var $typeSchema = it.schema.type, $typeIsArray = Array.isArray($typeSchema);
      if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {
        if ($typeIsArray) {
          if ($typeSchema.indexOf("null") == -1)
            $typeSchema = $typeSchema.concat("null");
        } else if ($typeSchema != "null") {
          $typeSchema = [$typeSchema, "null"];
          $typeIsArray = true;
        }
      }
      if ($typeIsArray && $typeSchema.length == 1) {
        $typeSchema = $typeSchema[0];
        $typeIsArray = false;
      }
      if (it.schema.$ref && $refKeywords) {
        if (it.opts.extendRefs == "fail") {
          throw new Error('$ref: validation keywords used in schema at path "' + it.errSchemaPath + '" (see option extendRefs)');
        } else if (it.opts.extendRefs !== true) {
          $refKeywords = false;
          it.logger.warn('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
        }
      }
      if (it.schema.$comment && it.opts.$comment) {
        out += " " + it.RULES.all.$comment.code(it, "$comment");
      }
      if ($typeSchema) {
        if (it.opts.coerceTypes) {
          var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
        }
        var $rulesGroup = it.RULES.types[$typeSchema];
        if ($coerceToTypes || $typeIsArray || $rulesGroup === true || $rulesGroup && !$shouldUseGroup($rulesGroup)) {
          var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type";
          var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type", $method = $typeIsArray ? "checkDataTypes" : "checkDataType";
          out += " if (" + it.util[$method]($typeSchema, $data, it.opts.strictNumbers, true) + ") { ";
          if ($coerceToTypes) {
            var $dataType = "dataType" + $lvl, $coerced = "coerced" + $lvl;
            out += " var " + $dataType + " = typeof " + $data + "; var " + $coerced + " = undefined; ";
            if (it.opts.coerceTypes == "array") {
              out += " if (" + $dataType + " == 'object' && Array.isArray(" + $data + ") && " + $data + ".length == 1) { " + $data + " = " + $data + "[0]; " + $dataType + " = typeof " + $data + "; if (" + it.util.checkDataType(it.schema.type, $data, it.opts.strictNumbers) + ") " + $coerced + " = " + $data + "; } ";
            }
            out += " if (" + $coerced + " !== undefined) ; ";
            var arr1 = $coerceToTypes;
            if (arr1) {
              var $type, $i = -1, l1 = arr1.length - 1;
              while ($i < l1) {
                $type = arr1[$i += 1];
                if ($type == "string") {
                  out += " else if (" + $dataType + " == 'number' || " + $dataType + " == 'boolean') " + $coerced + " = '' + " + $data + "; else if (" + $data + " === null) " + $coerced + " = ''; ";
                } else if ($type == "number" || $type == "integer") {
                  out += " else if (" + $dataType + " == 'boolean' || " + $data + " === null || (" + $dataType + " == 'string' && " + $data + " && " + $data + " == +" + $data + " ";
                  if ($type == "integer") {
                    out += " && !(" + $data + " % 1)";
                  }
                  out += ")) " + $coerced + " = +" + $data + "; ";
                } else if ($type == "boolean") {
                  out += " else if (" + $data + " === 'false' || " + $data + " === 0 || " + $data + " === null) " + $coerced + " = false; else if (" + $data + " === 'true' || " + $data + " === 1) " + $coerced + " = true; ";
                } else if ($type == "null") {
                  out += " else if (" + $data + " === '' || " + $data + " === 0 || " + $data + " === false) " + $coerced + " = null; ";
                } else if (it.opts.coerceTypes == "array" && $type == "array") {
                  out += " else if (" + $dataType + " == 'string' || " + $dataType + " == 'number' || " + $dataType + " == 'boolean' || " + $data + " == null) " + $coerced + " = [" + $data + "]; ";
                }
              }
            }
            out += " else {   ";
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
              if ($typeIsArray) {
                out += "" + $typeSchema.join(",");
              } else {
                out += "" + $typeSchema;
              }
              out += "' } ";
              if (it.opts.messages !== false) {
                out += " , message: 'should be ";
                if ($typeIsArray) {
                  out += "" + $typeSchema.join(",");
                } else {
                  out += "" + $typeSchema;
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += " } if (" + $coerced + " !== undefined) {  ";
            var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
            out += " " + $data + " = " + $coerced + "; ";
            if (!$dataLvl) {
              out += "if (" + $parentData + " !== undefined)";
            }
            out += " " + $parentData + "[" + $parentDataProperty + "] = " + $coerced + "; } ";
          } else {
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
              if ($typeIsArray) {
                out += "" + $typeSchema.join(",");
              } else {
                out += "" + $typeSchema;
              }
              out += "' } ";
              if (it.opts.messages !== false) {
                out += " , message: 'should be ";
                if ($typeIsArray) {
                  out += "" + $typeSchema.join(",");
                } else {
                  out += "" + $typeSchema;
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
          }
          out += " } ";
        }
      }
      if (it.schema.$ref && !$refKeywords) {
        out += " " + it.RULES.all.$ref.code(it, "$ref") + " ";
        if ($breakOnError) {
          out += " } if (errors === ";
          if ($top) {
            out += "0";
          } else {
            out += "errs_" + $lvl;
          }
          out += ") { ";
          $closingBraces2 += "}";
        }
      } else {
        var arr2 = it.RULES;
        if (arr2) {
          var $rulesGroup, i2 = -1, l2 = arr2.length - 1;
          while (i2 < l2) {
            $rulesGroup = arr2[i2 += 1];
            if ($shouldUseGroup($rulesGroup)) {
              if ($rulesGroup.type) {
                out += " if (" + it.util.checkDataType($rulesGroup.type, $data, it.opts.strictNumbers) + ") { ";
              }
              if (it.opts.useDefaults) {
                if ($rulesGroup.type == "object" && it.schema.properties) {
                  var $schema = it.schema.properties, $schemaKeys = Object.keys($schema);
                  var arr3 = $schemaKeys;
                  if (arr3) {
                    var $propertyKey, i3 = -1, l3 = arr3.length - 1;
                    while (i3 < l3) {
                      $propertyKey = arr3[i3 += 1];
                      var $sch = $schema[$propertyKey];
                      if ($sch.default !== void 0) {
                        var $passData = $data + it.util.getProperty($propertyKey);
                        if (it.compositeRule) {
                          if (it.opts.strictDefaults) {
                            var $defaultMsg = "default is ignored for: " + $passData;
                            if (it.opts.strictDefaults === "log")
                              it.logger.warn($defaultMsg);
                            else
                              throw new Error($defaultMsg);
                          }
                        } else {
                          out += " if (" + $passData + " === undefined ";
                          if (it.opts.useDefaults == "empty") {
                            out += " || " + $passData + " === null || " + $passData + " === '' ";
                          }
                          out += " ) " + $passData + " = ";
                          if (it.opts.useDefaults == "shared") {
                            out += " " + it.useDefault($sch.default) + " ";
                          } else {
                            out += " " + JSON.stringify($sch.default) + " ";
                          }
                          out += "; ";
                        }
                      }
                    }
                  }
                } else if ($rulesGroup.type == "array" && Array.isArray(it.schema.items)) {
                  var arr4 = it.schema.items;
                  if (arr4) {
                    var $sch, $i = -1, l4 = arr4.length - 1;
                    while ($i < l4) {
                      $sch = arr4[$i += 1];
                      if ($sch.default !== void 0) {
                        var $passData = $data + "[" + $i + "]";
                        if (it.compositeRule) {
                          if (it.opts.strictDefaults) {
                            var $defaultMsg = "default is ignored for: " + $passData;
                            if (it.opts.strictDefaults === "log")
                              it.logger.warn($defaultMsg);
                            else
                              throw new Error($defaultMsg);
                          }
                        } else {
                          out += " if (" + $passData + " === undefined ";
                          if (it.opts.useDefaults == "empty") {
                            out += " || " + $passData + " === null || " + $passData + " === '' ";
                          }
                          out += " ) " + $passData + " = ";
                          if (it.opts.useDefaults == "shared") {
                            out += " " + it.useDefault($sch.default) + " ";
                          } else {
                            out += " " + JSON.stringify($sch.default) + " ";
                          }
                          out += "; ";
                        }
                      }
                    }
                  }
                }
              }
              var arr5 = $rulesGroup.rules;
              if (arr5) {
                var $rule, i5 = -1, l5 = arr5.length - 1;
                while (i5 < l5) {
                  $rule = arr5[i5 += 1];
                  if ($shouldUseRule($rule)) {
                    var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
                    if ($code) {
                      out += " " + $code + " ";
                      if ($breakOnError) {
                        $closingBraces1 += "}";
                      }
                    }
                  }
                }
              }
              if ($breakOnError) {
                out += " " + $closingBraces1 + " ";
                $closingBraces1 = "";
              }
              if ($rulesGroup.type) {
                out += " } ";
                if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
                  out += " else { ";
                  var $schemaPath = it.schemaPath + ".type", $errSchemaPath = it.errSchemaPath + "/type";
                  var $$outStack = $$outStack || [];
                  $$outStack.push(out);
                  out = "";
                  if (it.createErrors !== false) {
                    out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { type: '";
                    if ($typeIsArray) {
                      out += "" + $typeSchema.join(",");
                    } else {
                      out += "" + $typeSchema;
                    }
                    out += "' } ";
                    if (it.opts.messages !== false) {
                      out += " , message: 'should be ";
                      if ($typeIsArray) {
                        out += "" + $typeSchema.join(",");
                      } else {
                        out += "" + $typeSchema;
                      }
                      out += "' ";
                    }
                    if (it.opts.verbose) {
                      out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                    }
                    out += " } ";
                  } else {
                    out += " {} ";
                  }
                  var __err = out;
                  out = $$outStack.pop();
                  if (!it.compositeRule && $breakOnError) {
                    if (it.async) {
                      out += " throw new ValidationError([" + __err + "]); ";
                    } else {
                      out += " validate.errors = [" + __err + "]; return false; ";
                    }
                  } else {
                    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                  }
                  out += " } ";
                }
              }
              if ($breakOnError) {
                out += " if (errors === ";
                if ($top) {
                  out += "0";
                } else {
                  out += "errs_" + $lvl;
                }
                out += ") { ";
                $closingBraces2 += "}";
              }
            }
          }
        }
      }
      if ($breakOnError) {
        out += " " + $closingBraces2 + " ";
      }
      if ($top) {
        if ($async) {
          out += " if (errors === 0) return data;           ";
          out += " else throw new ValidationError(vErrors); ";
        } else {
          out += " validate.errors = vErrors; ";
          out += " return errors === 0;       ";
        }
        out += " }; return validate;";
      } else {
        out += " var " + $valid + " = errors === errs_" + $lvl + ";";
      }
      function $shouldUseGroup($rulesGroup2) {
        var rules = $rulesGroup2.rules;
        for (var i = 0; i < rules.length; i++)
          if ($shouldUseRule(rules[i]))
            return true;
      }
      function $shouldUseRule($rule2) {
        return it.schema[$rule2.keyword] !== void 0 || $rule2.implements && $ruleImplementsSomeKeyword($rule2);
      }
      function $ruleImplementsSomeKeyword($rule2) {
        var impl = $rule2.implements;
        for (var i = 0; i < impl.length; i++)
          if (it.schema[impl[i]] !== void 0)
            return true;
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/compile/index.js
var require_compile = __commonJS({
  "../../node_modules/ajv/lib/compile/index.js"(exports, module) {
    "use strict";
    var resolve = require_resolve();
    var util = require_util2();
    var errorClasses = require_error_classes();
    var stableStringify = require_fast_json_stable_stringify();
    var validateGenerator = require_validate();
    var ucs2length = util.ucs2length;
    var equal = require_fast_deep_equal();
    var ValidationError = errorClasses.Validation;
    module.exports = compile;
    function compile(schema, root, localRefs, baseId) {
      var self2 = this, opts = this._opts, refVal = [void 0], refs = {}, patterns = [], patternsHash = {}, defaults = [], defaultsHash = {}, customRules = [];
      root = root || { schema, refVal, refs };
      var c = checkCompiling.call(this, schema, root, baseId);
      var compilation = this._compilations[c.index];
      if (c.compiling)
        return compilation.callValidate = callValidate;
      var formats = this._formats;
      var RULES = this.RULES;
      try {
        var v = localCompile(schema, root, localRefs, baseId);
        compilation.validate = v;
        var cv = compilation.callValidate;
        if (cv) {
          cv.schema = v.schema;
          cv.errors = null;
          cv.refs = v.refs;
          cv.refVal = v.refVal;
          cv.root = v.root;
          cv.$async = v.$async;
          if (opts.sourceCode)
            cv.source = v.source;
        }
        return v;
      } finally {
        endCompiling.call(this, schema, root, baseId);
      }
      function callValidate() {
        var validate = compilation.validate;
        var result = validate.apply(this, arguments);
        callValidate.errors = validate.errors;
        return result;
      }
      function localCompile(_schema, _root, localRefs2, baseId2) {
        var isRoot = !_root || _root && _root.schema == _schema;
        if (_root.schema != root.schema)
          return compile.call(self2, _schema, _root, localRefs2, baseId2);
        var $async = _schema.$async === true;
        var sourceCode = validateGenerator({
          isTop: true,
          schema: _schema,
          isRoot,
          baseId: baseId2,
          root: _root,
          schemaPath: "",
          errSchemaPath: "#",
          errorPath: '""',
          MissingRefError: errorClasses.MissingRef,
          RULES,
          validate: validateGenerator,
          util,
          resolve,
          resolveRef,
          usePattern,
          useDefault,
          useCustomRule,
          opts,
          formats,
          logger: self2.logger,
          self: self2
        });
        sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode) + vars(defaults, defaultCode) + vars(customRules, customRuleCode) + sourceCode;
        if (opts.processCode)
          sourceCode = opts.processCode(sourceCode, _schema);
        var validate;
        try {
          var makeValidate = new Function(
            "self",
            "RULES",
            "formats",
            "root",
            "refVal",
            "defaults",
            "customRules",
            "equal",
            "ucs2length",
            "ValidationError",
            sourceCode
          );
          validate = makeValidate(
            self2,
            RULES,
            formats,
            root,
            refVal,
            defaults,
            customRules,
            equal,
            ucs2length,
            ValidationError
          );
          refVal[0] = validate;
        } catch (e) {
          self2.logger.error("Error compiling schema, function code:", sourceCode);
          throw e;
        }
        validate.schema = _schema;
        validate.errors = null;
        validate.refs = refs;
        validate.refVal = refVal;
        validate.root = isRoot ? validate : _root;
        if ($async)
          validate.$async = true;
        if (opts.sourceCode === true) {
          validate.source = {
            code: sourceCode,
            patterns,
            defaults
          };
        }
        return validate;
      }
      function resolveRef(baseId2, ref, isRoot) {
        ref = resolve.url(baseId2, ref);
        var refIndex = refs[ref];
        var _refVal, refCode;
        if (refIndex !== void 0) {
          _refVal = refVal[refIndex];
          refCode = "refVal[" + refIndex + "]";
          return resolvedRef(_refVal, refCode);
        }
        if (!isRoot && root.refs) {
          var rootRefId = root.refs[ref];
          if (rootRefId !== void 0) {
            _refVal = root.refVal[rootRefId];
            refCode = addLocalRef(ref, _refVal);
            return resolvedRef(_refVal, refCode);
          }
        }
        refCode = addLocalRef(ref);
        var v2 = resolve.call(self2, localCompile, root, ref);
        if (v2 === void 0) {
          var localSchema = localRefs && localRefs[ref];
          if (localSchema) {
            v2 = resolve.inlineRef(localSchema, opts.inlineRefs) ? localSchema : compile.call(self2, localSchema, root, localRefs, baseId2);
          }
        }
        if (v2 === void 0) {
          removeLocalRef(ref);
        } else {
          replaceLocalRef(ref, v2);
          return resolvedRef(v2, refCode);
        }
      }
      function addLocalRef(ref, v2) {
        var refId = refVal.length;
        refVal[refId] = v2;
        refs[ref] = refId;
        return "refVal" + refId;
      }
      function removeLocalRef(ref) {
        delete refs[ref];
      }
      function replaceLocalRef(ref, v2) {
        var refId = refs[ref];
        refVal[refId] = v2;
      }
      function resolvedRef(refVal2, code) {
        return typeof refVal2 == "object" || typeof refVal2 == "boolean" ? { code, schema: refVal2, inline: true } : { code, $async: refVal2 && !!refVal2.$async };
      }
      function usePattern(regexStr) {
        var index = patternsHash[regexStr];
        if (index === void 0) {
          index = patternsHash[regexStr] = patterns.length;
          patterns[index] = regexStr;
        }
        return "pattern" + index;
      }
      function useDefault(value) {
        switch (typeof value) {
          case "boolean":
          case "number":
            return "" + value;
          case "string":
            return util.toQuotedString(value);
          case "object":
            if (value === null)
              return "null";
            var valueStr = stableStringify(value);
            var index = defaultsHash[valueStr];
            if (index === void 0) {
              index = defaultsHash[valueStr] = defaults.length;
              defaults[index] = value;
            }
            return "default" + index;
        }
      }
      function useCustomRule(rule, schema2, parentSchema, it) {
        if (self2._opts.validateSchema !== false) {
          var deps = rule.definition.dependencies;
          if (deps && !deps.every(function(keyword) {
            return Object.prototype.hasOwnProperty.call(parentSchema, keyword);
          }))
            throw new Error("parent schema must have all required keywords: " + deps.join(","));
          var validateSchema = rule.definition.validateSchema;
          if (validateSchema) {
            var valid = validateSchema(schema2);
            if (!valid) {
              var message = "keyword schema is invalid: " + self2.errorsText(validateSchema.errors);
              if (self2._opts.validateSchema == "log")
                self2.logger.error(message);
              else
                throw new Error(message);
            }
          }
        }
        var compile2 = rule.definition.compile, inline = rule.definition.inline, macro = rule.definition.macro;
        var validate;
        if (compile2) {
          validate = compile2.call(self2, schema2, parentSchema, it);
        } else if (macro) {
          validate = macro.call(self2, schema2, parentSchema, it);
          if (opts.validateSchema !== false)
            self2.validateSchema(validate, true);
        } else if (inline) {
          validate = inline.call(self2, it, rule.keyword, schema2, parentSchema);
        } else {
          validate = rule.definition.validate;
          if (!validate)
            return;
        }
        if (validate === void 0)
          throw new Error('custom keyword "' + rule.keyword + '"failed to compile');
        var index = customRules.length;
        customRules[index] = validate;
        return {
          code: "customRule" + index,
          validate
        };
      }
    }
    function checkCompiling(schema, root, baseId) {
      var index = compIndex.call(this, schema, root, baseId);
      if (index >= 0)
        return { index, compiling: true };
      index = this._compilations.length;
      this._compilations[index] = {
        schema,
        root,
        baseId
      };
      return { index, compiling: false };
    }
    function endCompiling(schema, root, baseId) {
      var i = compIndex.call(this, schema, root, baseId);
      if (i >= 0)
        this._compilations.splice(i, 1);
    }
    function compIndex(schema, root, baseId) {
      for (var i = 0; i < this._compilations.length; i++) {
        var c = this._compilations[i];
        if (c.schema == schema && c.root == root && c.baseId == baseId)
          return i;
      }
      return -1;
    }
    function patternCode(i, patterns) {
      return "var pattern" + i + " = new RegExp(" + util.toQuotedString(patterns[i]) + ");";
    }
    function defaultCode(i) {
      return "var default" + i + " = defaults[" + i + "];";
    }
    function refValCode(i, refVal) {
      return refVal[i] === void 0 ? "" : "var refVal" + i + " = refVal[" + i + "];";
    }
    function customRuleCode(i) {
      return "var customRule" + i + " = customRules[" + i + "];";
    }
    function vars(arr, statement) {
      if (!arr.length)
        return "";
      var code = "";
      for (var i = 0; i < arr.length; i++)
        code += statement(i, arr);
      return code;
    }
  }
});

// ../../node_modules/ajv/lib/cache.js
var require_cache = __commonJS({
  "../../node_modules/ajv/lib/cache.js"(exports, module) {
    "use strict";
    var Cache = module.exports = function Cache2() {
      this._cache = {};
    };
    Cache.prototype.put = function Cache_put(key, value) {
      this._cache[key] = value;
    };
    Cache.prototype.get = function Cache_get(key) {
      return this._cache[key];
    };
    Cache.prototype.del = function Cache_del(key) {
      delete this._cache[key];
    };
    Cache.prototype.clear = function Cache_clear() {
      this._cache = {};
    };
  }
});

// ../../node_modules/ajv/lib/compile/formats.js
var require_formats = __commonJS({
  "../../node_modules/ajv/lib/compile/formats.js"(exports, module) {
    "use strict";
    var util = require_util2();
    var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
    var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
    var HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
    var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
    var URL = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
    var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
    var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
    var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
    var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
    module.exports = formats;
    function formats(mode) {
      mode = mode == "full" ? "full" : "fast";
      return util.copy(formats[mode]);
    }
    formats.fast = {
      // date: http://tools.ietf.org/html/rfc3339#section-5.6
      date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
      // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
      time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
      "date-time": /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
      // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
      uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
      "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
      "uri-template": URITEMPLATE,
      url: URL,
      // email (sources from jsen validator):
      // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
      // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')
      email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
      hostname: HOSTNAME,
      // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
      // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
      ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
      regex,
      // uuid: http://tools.ietf.org/html/rfc4122
      uuid: UUID,
      // JSON-pointer: https://tools.ietf.org/html/rfc6901
      // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
      "json-pointer": JSON_POINTER,
      "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
      // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
      "relative-json-pointer": RELATIVE_JSON_POINTER
    };
    formats.full = {
      date,
      time,
      "date-time": date_time,
      uri,
      "uri-reference": URIREF,
      "uri-template": URITEMPLATE,
      url: URL,
      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname: HOSTNAME,
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
      ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
      regex,
      uuid: UUID,
      "json-pointer": JSON_POINTER,
      "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
      "relative-json-pointer": RELATIVE_JSON_POINTER
    };
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    function date(str) {
      var matches = str.match(DATE);
      if (!matches)
        return false;
      var year = +matches[1];
      var month = +matches[2];
      var day = +matches[3];
      return month >= 1 && month <= 12 && day >= 1 && day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
    }
    function time(str, full) {
      var matches = str.match(TIME);
      if (!matches)
        return false;
      var hour = matches[1];
      var minute = matches[2];
      var second = matches[3];
      var timeZone = matches[5];
      return (hour <= 23 && minute <= 59 && second <= 59 || hour == 23 && minute == 59 && second == 60) && (!full || timeZone);
    }
    var DATE_TIME_SEPARATOR = /t|\s/i;
    function date_time(str) {
      var dateTime = str.split(DATE_TIME_SEPARATOR);
      return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
    }
    var NOT_URI_FRAGMENT = /\/|:/;
    function uri(str) {
      return NOT_URI_FRAGMENT.test(str) && URI.test(str);
    }
    var Z_ANCHOR = /[^\\]\\Z/;
    function regex(str) {
      if (Z_ANCHOR.test(str))
        return false;
      try {
        new RegExp(str);
        return true;
      } catch (e) {
        return false;
      }
    }
  }
});

// ../../node_modules/ajv/lib/dotjs/ref.js
var require_ref = __commonJS({
  "../../node_modules/ajv/lib/dotjs/ref.js"(exports, module) {
    "use strict";
    module.exports = function generate_ref(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $async, $refCode;
      if ($schema == "#" || $schema == "#/") {
        if (it.isRoot) {
          $async = it.async;
          $refCode = "validate";
        } else {
          $async = it.root.schema.$async === true;
          $refCode = "root.refVal[0]";
        }
      } else {
        var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
        if ($refVal === void 0) {
          var $message = it.MissingRefError.message(it.baseId, $schema);
          if (it.opts.missingRefs == "fail") {
            it.logger.error($message);
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: '$ref' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { ref: '" + it.util.escapeQuotes($schema) + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: 'can\\'t resolve reference " + it.util.escapeQuotes($schema) + "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: " + it.util.toQuotedString($schema) + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            if ($breakOnError) {
              out += " if (false) { ";
            }
          } else if (it.opts.missingRefs == "ignore") {
            it.logger.warn($message);
            if ($breakOnError) {
              out += " if (true) { ";
            }
          } else {
            throw new it.MissingRefError(it.baseId, $schema, $message);
          }
        } else if ($refVal.inline) {
          var $it = it.util.copy(it);
          $it.level++;
          var $nextValid = "valid" + $it.level;
          $it.schema = $refVal.schema;
          $it.schemaPath = "";
          $it.errSchemaPath = $schema;
          var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
          out += " " + $code + " ";
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
          }
        } else {
          $async = $refVal.$async === true || it.async && $refVal.$async !== false;
          $refCode = $refVal.code;
        }
      }
      if ($refCode) {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.opts.passContext) {
          out += " " + $refCode + ".call(this, ";
        } else {
          out += " " + $refCode + "( ";
        }
        out += " " + $data + ", (dataPath || '')";
        if (it.errorPath != '""') {
          out += " + " + it.errorPath;
        }
        var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
        out += " , " + $parentData + " , " + $parentDataProperty + ", rootData)  ";
        var __callValidate = out;
        out = $$outStack.pop();
        if ($async) {
          if (!it.async)
            throw new Error("async schema referenced by sync schema");
          if ($breakOnError) {
            out += " var " + $valid + "; ";
          }
          out += " try { await " + __callValidate + "; ";
          if ($breakOnError) {
            out += " " + $valid + " = true; ";
          }
          out += " } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ";
          if ($breakOnError) {
            out += " " + $valid + " = false; ";
          }
          out += " } ";
          if ($breakOnError) {
            out += " if (" + $valid + ") { ";
          }
        } else {
          out += " if (!" + __callValidate + ") { if (vErrors === null) vErrors = " + $refCode + ".errors; else vErrors = vErrors.concat(" + $refCode + ".errors); errors = vErrors.length; } ";
          if ($breakOnError) {
            out += " else { ";
          }
        }
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/allOf.js
var require_allOf = __commonJS({
  "../../node_modules/ajv/lib/dotjs/allOf.js"(exports, module) {
    "use strict";
    module.exports = function generate_allOf(it, $keyword, $ruleType) {
      var out = " ";
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $currentBaseId = $it.baseId, $allSchemasEmpty = true;
      var arr1 = $schema;
      if (arr1) {
        var $sch, $i = -1, l1 = arr1.length - 1;
        while ($i < l1) {
          $sch = arr1[$i += 1];
          if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
            $allSchemasEmpty = false;
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + "[" + $i + "]";
            $it.errSchemaPath = $errSchemaPath + "/" + $i;
            out += "  " + it.validate($it) + " ";
            $it.baseId = $currentBaseId;
            if ($breakOnError) {
              out += " if (" + $nextValid + ") { ";
              $closingBraces += "}";
            }
          }
        }
      }
      if ($breakOnError) {
        if ($allSchemasEmpty) {
          out += " if (true) { ";
        } else {
          out += " " + $closingBraces.slice(0, -1) + " ";
        }
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/anyOf.js
var require_anyOf = __commonJS({
  "../../node_modules/ajv/lib/dotjs/anyOf.js"(exports, module) {
    "use strict";
    module.exports = function generate_anyOf(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $noEmptySchema = $schema.every(function($sch2) {
        return it.opts.strictKeywords ? typeof $sch2 == "object" && Object.keys($sch2).length > 0 || $sch2 === false : it.util.schemaHasRules($sch2, it.RULES.all);
      });
      if ($noEmptySchema) {
        var $currentBaseId = $it.baseId;
        out += " var " + $errs + " = errors; var " + $valid + " = false;  ";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var arr1 = $schema;
        if (arr1) {
          var $sch, $i = -1, l1 = arr1.length - 1;
          while ($i < l1) {
            $sch = arr1[$i += 1];
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + "[" + $i + "]";
            $it.errSchemaPath = $errSchemaPath + "/" + $i;
            out += "  " + it.validate($it) + " ";
            $it.baseId = $currentBaseId;
            out += " " + $valid + " = " + $valid + " || " + $nextValid + "; if (!" + $valid + ") { ";
            $closingBraces += "}";
          }
        }
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " " + $closingBraces + " if (!" + $valid + ") {   var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: 'anyOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it.opts.messages !== false) {
            out += " , message: 'should match some schema in anyOf' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError(vErrors); ";
          } else {
            out += " validate.errors = vErrors; return false; ";
          }
        }
        out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
        if (it.opts.allErrors) {
          out += " } ";
        }
      } else {
        if ($breakOnError) {
          out += " if (true) { ";
        }
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/comment.js
var require_comment = __commonJS({
  "../../node_modules/ajv/lib/dotjs/comment.js"(exports, module) {
    "use strict";
    module.exports = function generate_comment(it, $keyword, $ruleType) {
      var out = " ";
      var $schema = it.schema[$keyword];
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $comment = it.util.toQuotedString($schema);
      if (it.opts.$comment === true) {
        out += " console.log(" + $comment + ");";
      } else if (typeof it.opts.$comment == "function") {
        out += " self._opts.$comment(" + $comment + ", " + it.util.toQuotedString($errSchemaPath) + ", validate.root.schema);";
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/const.js
var require_const = __commonJS({
  "../../node_modules/ajv/lib/dotjs/const.js"(exports, module) {
    "use strict";
    module.exports = function generate_const(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!$isData) {
        out += " var schema" + $lvl + " = validate.schema" + $schemaPath + ";";
      }
      out += "var " + $valid + " = equal(" + $data + ", schema" + $lvl + "); if (!" + $valid + ") {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'const' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValue: schema" + $lvl + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should be equal to constant' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " }";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/contains.js
var require_contains = __commonJS({
  "../../node_modules/ajv/lib/dotjs/contains.js"(exports, module) {
    "use strict";
    module.exports = function generate_contains(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId, $nonEmptySchema = it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all);
      out += "var " + $errs + " = errors;var " + $valid + ";";
      if ($nonEmptySchema) {
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += " var " + $nextValid + " = false; for (var " + $idx + " = 0; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
        $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
        var $passData = $data + "[" + $idx + "]";
        $it.dataPathArr[$dataNxt] = $idx;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
        } else {
          out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
        }
        out += " if (" + $nextValid + ") break; }  ";
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " " + $closingBraces + " if (!" + $nextValid + ") {";
      } else {
        out += " if (" + $data + ".length == 0) {";
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'contains' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
        if (it.opts.messages !== false) {
          out += " , message: 'should contain a valid item' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } else { ";
      if ($nonEmptySchema) {
        out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
      }
      if (it.opts.allErrors) {
        out += " } ";
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/dependencies.js
var require_dependencies = __commonJS({
  "../../node_modules/ajv/lib/dotjs/dependencies.js"(exports, module) {
    "use strict";
    module.exports = function generate_dependencies(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $schemaDeps = {}, $propertyDeps = {}, $ownProperties = it.opts.ownProperties;
      for ($property in $schema) {
        if ($property == "__proto__")
          continue;
        var $sch = $schema[$property];
        var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
        $deps[$property] = $sch;
      }
      out += "var " + $errs + " = errors;";
      var $currentErrorPath = it.errorPath;
      out += "var missing" + $lvl + ";";
      for (var $property in $propertyDeps) {
        $deps = $propertyDeps[$property];
        if ($deps.length) {
          out += " if ( " + $data + it.util.getProperty($property) + " !== undefined ";
          if ($ownProperties) {
            out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') ";
          }
          if ($breakOnError) {
            out += " && ( ";
            var arr1 = $deps;
            if (arr1) {
              var $propertyKey, $i = -1, l1 = arr1.length - 1;
              while ($i < l1) {
                $propertyKey = arr1[$i += 1];
                if ($i) {
                  out += " || ";
                }
                var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
                out += " ( ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
              }
            }
            out += ")) {  ";
            var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
            }
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: 'should have ";
                if ($deps.length == 1) {
                  out += "property " + it.util.escapeQuotes($deps[0]);
                } else {
                  out += "properties " + it.util.escapeQuotes($deps.join(", "));
                }
                out += " when property " + it.util.escapeQuotes($property) + " is present' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
          } else {
            out += " ) { ";
            var arr2 = $deps;
            if (arr2) {
              var $propertyKey, i2 = -1, l2 = arr2.length - 1;
              while (i2 < l2) {
                $propertyKey = arr2[i2 += 1];
                var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
                if (it.opts._errorDataPathProperty) {
                  it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                }
                out += " if ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") {  var err =   ";
                if (it.createErrors !== false) {
                  out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
                  if (it.opts.messages !== false) {
                    out += " , message: 'should have ";
                    if ($deps.length == 1) {
                      out += "property " + it.util.escapeQuotes($deps[0]);
                    } else {
                      out += "properties " + it.util.escapeQuotes($deps.join(", "));
                    }
                    out += " when property " + it.util.escapeQuotes($property) + " is present' ";
                  }
                  if (it.opts.verbose) {
                    out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                  }
                  out += " } ";
                } else {
                  out += " {} ";
                }
                out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
              }
            }
          }
          out += " }   ";
          if ($breakOnError) {
            $closingBraces += "}";
            out += " else { ";
          }
        }
      }
      it.errorPath = $currentErrorPath;
      var $currentBaseId = $it.baseId;
      for (var $property in $schemaDeps) {
        var $sch = $schemaDeps[$property];
        if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
          out += " " + $nextValid + " = true; if ( " + $data + it.util.getProperty($property) + " !== undefined ";
          if ($ownProperties) {
            out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($property) + "') ";
          }
          out += ") { ";
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + it.util.getProperty($property);
          $it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($property);
          out += "  " + it.validate($it) + " ";
          $it.baseId = $currentBaseId;
          out += " }  ";
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
          }
        }
      }
      if ($breakOnError) {
        out += "   " + $closingBraces + " if (" + $errs + " == errors) {";
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/enum.js
var require_enum = __commonJS({
  "../../node_modules/ajv/lib/dotjs/enum.js"(exports, module) {
    "use strict";
    module.exports = function generate_enum(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $i = "i" + $lvl, $vSchema = "schema" + $lvl;
      if (!$isData) {
        out += " var " + $vSchema + " = validate.schema" + $schemaPath + ";";
      }
      out += "var " + $valid + ";";
      if ($isData) {
        out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
      }
      out += "" + $valid + " = false;for (var " + $i + "=0; " + $i + "<" + $vSchema + ".length; " + $i + "++) if (equal(" + $data + ", " + $vSchema + "[" + $i + "])) { " + $valid + " = true; break; }";
      if ($isData) {
        out += "  }  ";
      }
      out += " if (!" + $valid + ") {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'enum' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { allowedValues: schema" + $lvl + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should be equal to one of the allowed values' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " }";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/format.js
var require_format = __commonJS({
  "../../node_modules/ajv/lib/dotjs/format.js"(exports, module) {
    "use strict";
    module.exports = function generate_format(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      if (it.opts.format === false) {
        if ($breakOnError) {
          out += " if (true) { ";
        }
        return out;
      }
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $unknownFormats = it.opts.unknownFormats, $allowUnknown = Array.isArray($unknownFormats);
      if ($isData) {
        var $format = "format" + $lvl, $isObject = "isObject" + $lvl, $formatType = "formatType" + $lvl;
        out += " var " + $format + " = formats[" + $schemaValue + "]; var " + $isObject + " = typeof " + $format + " == 'object' && !(" + $format + " instanceof RegExp) && " + $format + ".validate; var " + $formatType + " = " + $isObject + " && " + $format + ".type || 'string'; if (" + $isObject + ") { ";
        if (it.async) {
          out += " var async" + $lvl + " = " + $format + ".async; ";
        }
        out += " " + $format + " = " + $format + ".validate; } if (  ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
        }
        out += " (";
        if ($unknownFormats != "ignore") {
          out += " (" + $schemaValue + " && !" + $format + " ";
          if ($allowUnknown) {
            out += " && self._opts.unknownFormats.indexOf(" + $schemaValue + ") == -1 ";
          }
          out += ") || ";
        }
        out += " (" + $format + " && " + $formatType + " == '" + $ruleType + "' && !(typeof " + $format + " == 'function' ? ";
        if (it.async) {
          out += " (async" + $lvl + " ? await " + $format + "(" + $data + ") : " + $format + "(" + $data + ")) ";
        } else {
          out += " " + $format + "(" + $data + ") ";
        }
        out += " : " + $format + ".test(" + $data + "))))) {";
      } else {
        var $format = it.formats[$schema];
        if (!$format) {
          if ($unknownFormats == "ignore") {
            it.logger.warn('unknown format "' + $schema + '" ignored in schema at path "' + it.errSchemaPath + '"');
            if ($breakOnError) {
              out += " if (true) { ";
            }
            return out;
          } else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
            if ($breakOnError) {
              out += " if (true) { ";
            }
            return out;
          } else {
            throw new Error('unknown format "' + $schema + '" is used in schema at path "' + it.errSchemaPath + '"');
          }
        }
        var $isObject = typeof $format == "object" && !($format instanceof RegExp) && $format.validate;
        var $formatType = $isObject && $format.type || "string";
        if ($isObject) {
          var $async = $format.async === true;
          $format = $format.validate;
        }
        if ($formatType != $ruleType) {
          if ($breakOnError) {
            out += " if (true) { ";
          }
          return out;
        }
        if ($async) {
          if (!it.async)
            throw new Error("async format in sync schema");
          var $formatRef = "formats" + it.util.getProperty($schema) + ".validate";
          out += " if (!(await " + $formatRef + "(" + $data + "))) { ";
        } else {
          out += " if (! ";
          var $formatRef = "formats" + it.util.getProperty($schema);
          if ($isObject)
            $formatRef += ".validate";
          if (typeof $format == "function") {
            out += " " + $formatRef + "(" + $data + ") ";
          } else {
            out += " " + $formatRef + ".test(" + $data + ") ";
          }
          out += ") { ";
        }
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'format' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { format:  ";
        if ($isData) {
          out += "" + $schemaValue;
        } else {
          out += "" + it.util.toQuotedString($schema);
        }
        out += "  } ";
        if (it.opts.messages !== false) {
          out += ` , message: 'should match format "`;
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + it.util.escapeQuotes($schema);
          }
          out += `"' `;
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + it.util.toQuotedString($schema);
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/if.js
var require_if = __commonJS({
  "../../node_modules/ajv/lib/dotjs/if.js"(exports, module) {
    "use strict";
    module.exports = function generate_if(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $thenSch = it.schema["then"], $elseSch = it.schema["else"], $thenPresent = $thenSch !== void 0 && (it.opts.strictKeywords ? typeof $thenSch == "object" && Object.keys($thenSch).length > 0 || $thenSch === false : it.util.schemaHasRules($thenSch, it.RULES.all)), $elsePresent = $elseSch !== void 0 && (it.opts.strictKeywords ? typeof $elseSch == "object" && Object.keys($elseSch).length > 0 || $elseSch === false : it.util.schemaHasRules($elseSch, it.RULES.all)), $currentBaseId = $it.baseId;
      if ($thenPresent || $elsePresent) {
        var $ifClause;
        $it.createErrors = false;
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += " var " + $errs + " = errors; var " + $valid + " = true;  ";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        out += "  " + it.validate($it) + " ";
        $it.baseId = $currentBaseId;
        $it.createErrors = true;
        out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }  ";
        it.compositeRule = $it.compositeRule = $wasComposite;
        if ($thenPresent) {
          out += " if (" + $nextValid + ") {  ";
          $it.schema = it.schema["then"];
          $it.schemaPath = it.schemaPath + ".then";
          $it.errSchemaPath = it.errSchemaPath + "/then";
          out += "  " + it.validate($it) + " ";
          $it.baseId = $currentBaseId;
          out += " " + $valid + " = " + $nextValid + "; ";
          if ($thenPresent && $elsePresent) {
            $ifClause = "ifClause" + $lvl;
            out += " var " + $ifClause + " = 'then'; ";
          } else {
            $ifClause = "'then'";
          }
          out += " } ";
          if ($elsePresent) {
            out += " else { ";
          }
        } else {
          out += " if (!" + $nextValid + ") { ";
        }
        if ($elsePresent) {
          $it.schema = it.schema["else"];
          $it.schemaPath = it.schemaPath + ".else";
          $it.errSchemaPath = it.errSchemaPath + "/else";
          out += "  " + it.validate($it) + " ";
          $it.baseId = $currentBaseId;
          out += " " + $valid + " = " + $nextValid + "; ";
          if ($thenPresent && $elsePresent) {
            $ifClause = "ifClause" + $lvl;
            out += " var " + $ifClause + " = 'else'; ";
          } else {
            $ifClause = "'else'";
          }
          out += " } ";
        }
        out += " if (!" + $valid + ") {   var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: 'if' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { failingKeyword: " + $ifClause + " } ";
          if (it.opts.messages !== false) {
            out += ` , message: 'should match "' + ` + $ifClause + ` + '" schema' `;
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError(vErrors); ";
          } else {
            out += " validate.errors = vErrors; return false; ";
          }
        }
        out += " }   ";
        if ($breakOnError) {
          out += " else { ";
        }
      } else {
        if ($breakOnError) {
          out += " if (true) { ";
        }
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/items.js
var require_items = __commonJS({
  "../../node_modules/ajv/lib/dotjs/items.js"(exports, module) {
    "use strict";
    module.exports = function generate_items(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it.baseId;
      out += "var " + $errs + " = errors;var " + $valid + ";";
      if (Array.isArray($schema)) {
        var $additionalItems = it.schema.additionalItems;
        if ($additionalItems === false) {
          out += " " + $valid + " = " + $data + ".length <= " + $schema.length + "; ";
          var $currErrSchemaPath = $errSchemaPath;
          $errSchemaPath = it.errSchemaPath + "/additionalItems";
          out += "  if (!" + $valid + ") {   ";
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it.createErrors !== false) {
            out += " { keyword: 'additionalItems' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schema.length + " } ";
            if (it.opts.messages !== false) {
              out += " , message: 'should NOT have more than " + $schema.length + " items' ";
            }
            if (it.opts.verbose) {
              out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          out += " } ";
          $errSchemaPath = $currErrSchemaPath;
          if ($breakOnError) {
            $closingBraces += "}";
            out += " else { ";
          }
        }
        var arr1 = $schema;
        if (arr1) {
          var $sch, $i = -1, l1 = arr1.length - 1;
          while ($i < l1) {
            $sch = arr1[$i += 1];
            if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
              out += " " + $nextValid + " = true; if (" + $data + ".length > " + $i + ") { ";
              var $passData = $data + "[" + $i + "]";
              $it.schema = $sch;
              $it.schemaPath = $schemaPath + "[" + $i + "]";
              $it.errSchemaPath = $errSchemaPath + "/" + $i;
              $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
              $it.dataPathArr[$dataNxt] = $i;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              out += " }  ";
              if ($breakOnError) {
                out += " if (" + $nextValid + ") { ";
                $closingBraces += "}";
              }
            }
          }
        }
        if (typeof $additionalItems == "object" && (it.opts.strictKeywords ? typeof $additionalItems == "object" && Object.keys($additionalItems).length > 0 || $additionalItems === false : it.util.schemaHasRules($additionalItems, it.RULES.all))) {
          $it.schema = $additionalItems;
          $it.schemaPath = it.schemaPath + ".additionalItems";
          $it.errSchemaPath = it.errSchemaPath + "/additionalItems";
          out += " " + $nextValid + " = true; if (" + $data + ".length > " + $schema.length + ") {  for (var " + $idx + " = " + $schema.length + "; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
          $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
          var $passData = $data + "[" + $idx + "]";
          $it.dataPathArr[$dataNxt] = $idx;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
          } else {
            out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
          }
          if ($breakOnError) {
            out += " if (!" + $nextValid + ") break; ";
          }
          out += " } }  ";
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
          }
        }
      } else if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += "  for (var " + $idx + " = 0; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
        $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
        var $passData = $data + "[" + $idx + "]";
        $it.dataPathArr[$dataNxt] = $idx;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
        } else {
          out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
        }
        if ($breakOnError) {
          out += " if (!" + $nextValid + ") break; ";
        }
        out += " }";
      }
      if ($breakOnError) {
        out += " " + $closingBraces + " if (" + $errs + " == errors) {";
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/_limit.js
var require_limit = __commonJS({
  "../../node_modules/ajv/lib/dotjs/_limit.js"(exports, module) {
    "use strict";
    module.exports = function generate__limit(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $isMax = $keyword == "maximum", $exclusiveKeyword = $isMax ? "exclusiveMaximum" : "exclusiveMinimum", $schemaExcl = it.schema[$exclusiveKeyword], $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data, $op = $isMax ? "<" : ">", $notOp = $isMax ? ">" : "<", $errorKeyword = void 0;
      if (!($isData || typeof $schema == "number" || $schema === void 0)) {
        throw new Error($keyword + " must be number");
      }
      if (!($isDataExcl || $schemaExcl === void 0 || typeof $schemaExcl == "number" || typeof $schemaExcl == "boolean")) {
        throw new Error($exclusiveKeyword + " must be number or boolean");
      }
      if ($isDataExcl) {
        var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr), $exclusive = "exclusive" + $lvl, $exclType = "exclType" + $lvl, $exclIsNumber = "exclIsNumber" + $lvl, $opExpr = "op" + $lvl, $opStr = "' + " + $opExpr + " + '";
        out += " var schemaExcl" + $lvl + " = " + $schemaValueExcl + "; ";
        $schemaValueExcl = "schemaExcl" + $lvl;
        out += " var " + $exclusive + "; var " + $exclType + " = typeof " + $schemaValueExcl + "; if (" + $exclType + " != 'boolean' && " + $exclType + " != 'undefined' && " + $exclType + " != 'number') { ";
        var $errorKeyword = $exclusiveKeyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "_exclusiveLimit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it.opts.messages !== false) {
            out += " , message: '" + $exclusiveKeyword + " should be boolean' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } else if ( ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
        }
        out += " " + $exclType + " == 'number' ? ( (" + $exclusive + " = " + $schemaValue + " === undefined || " + $schemaValueExcl + " " + $op + "= " + $schemaValue + ") ? " + $data + " " + $notOp + "= " + $schemaValueExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) : ( (" + $exclusive + " = " + $schemaValueExcl + " === true) ? " + $data + " " + $notOp + "= " + $schemaValue + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { var op" + $lvl + " = " + $exclusive + " ? '" + $op + "' : '" + $op + "='; ";
        if ($schema === void 0) {
          $errorKeyword = $exclusiveKeyword;
          $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
          $schemaValue = $schemaValueExcl;
          $isData = $isDataExcl;
        }
      } else {
        var $exclIsNumber = typeof $schemaExcl == "number", $opStr = $op;
        if ($exclIsNumber && $isData) {
          var $opExpr = "'" + $opStr + "'";
          out += " if ( ";
          if ($isData) {
            out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
          }
          out += " ( " + $schemaValue + " === undefined || " + $schemaExcl + " " + $op + "= " + $schemaValue + " ? " + $data + " " + $notOp + "= " + $schemaExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { ";
        } else {
          if ($exclIsNumber && $schema === void 0) {
            $exclusive = true;
            $errorKeyword = $exclusiveKeyword;
            $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
            $schemaValue = $schemaExcl;
            $notOp += "=";
          } else {
            if ($exclIsNumber)
              $schemaValue = Math[$isMax ? "min" : "max"]($schemaExcl, $schema);
            if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
              $exclusive = true;
              $errorKeyword = $exclusiveKeyword;
              $errSchemaPath = it.errSchemaPath + "/" + $exclusiveKeyword;
              $notOp += "=";
            } else {
              $exclusive = false;
              $opStr += "=";
            }
          }
          var $opExpr = "'" + $opStr + "'";
          out += " if ( ";
          if ($isData) {
            out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
          }
          out += " " + $data + " " + $notOp + " " + $schemaValue + " || " + $data + " !== " + $data + ") { ";
        }
      }
      $errorKeyword = $errorKeyword || $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limit") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { comparison: " + $opExpr + ", limit: " + $schemaValue + ", exclusive: " + $exclusive + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should be " + $opStr + " ";
          if ($isData) {
            out += "' + " + $schemaValue;
          } else {
            out += "" + $schemaValue + "'";
          }
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/_limitItems.js
var require_limitItems = __commonJS({
  "../../node_modules/ajv/lib/dotjs/_limitItems.js"(exports, module) {
    "use strict";
    module.exports = function generate__limitItems(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!($isData || typeof $schema == "number")) {
        throw new Error($keyword + " must be number");
      }
      var $op = $keyword == "maxItems" ? ">" : "<";
      out += "if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
      }
      out += " " + $data + ".length " + $op + " " + $schemaValue + ") { ";
      var $errorKeyword = $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limitItems") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT have ";
          if ($keyword == "maxItems") {
            out += "more";
          } else {
            out += "fewer";
          }
          out += " than ";
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + $schema;
          }
          out += " items' ";
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/_limitLength.js
var require_limitLength = __commonJS({
  "../../node_modules/ajv/lib/dotjs/_limitLength.js"(exports, module) {
    "use strict";
    module.exports = function generate__limitLength(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!($isData || typeof $schema == "number")) {
        throw new Error($keyword + " must be number");
      }
      var $op = $keyword == "maxLength" ? ">" : "<";
      out += "if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
      }
      if (it.opts.unicode === false) {
        out += " " + $data + ".length ";
      } else {
        out += " ucs2length(" + $data + ") ";
      }
      out += " " + $op + " " + $schemaValue + ") { ";
      var $errorKeyword = $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limitLength") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT be ";
          if ($keyword == "maxLength") {
            out += "longer";
          } else {
            out += "shorter";
          }
          out += " than ";
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + $schema;
          }
          out += " characters' ";
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/_limitProperties.js
var require_limitProperties = __commonJS({
  "../../node_modules/ajv/lib/dotjs/_limitProperties.js"(exports, module) {
    "use strict";
    module.exports = function generate__limitProperties(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!($isData || typeof $schema == "number")) {
        throw new Error($keyword + " must be number");
      }
      var $op = $keyword == "maxProperties" ? ">" : "<";
      out += "if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
      }
      out += " Object.keys(" + $data + ").length " + $op + " " + $schemaValue + ") { ";
      var $errorKeyword = $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_limitProperties") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should NOT have ";
          if ($keyword == "maxProperties") {
            out += "more";
          } else {
            out += "fewer";
          }
          out += " than ";
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + $schema;
          }
          out += " properties' ";
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/multipleOf.js
var require_multipleOf = __commonJS({
  "../../node_modules/ajv/lib/dotjs/multipleOf.js"(exports, module) {
    "use strict";
    module.exports = function generate_multipleOf(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!($isData || typeof $schema == "number")) {
        throw new Error($keyword + " must be number");
      }
      out += "var division" + $lvl + ";if (";
      if ($isData) {
        out += " " + $schemaValue + " !== undefined && ( typeof " + $schemaValue + " != 'number' || ";
      }
      out += " (division" + $lvl + " = " + $data + " / " + $schemaValue + ", ";
      if (it.opts.multipleOfPrecision) {
        out += " Math.abs(Math.round(division" + $lvl + ") - division" + $lvl + ") > 1e-" + it.opts.multipleOfPrecision + " ";
      } else {
        out += " division" + $lvl + " !== parseInt(division" + $lvl + ") ";
      }
      out += " ) ";
      if ($isData) {
        out += "  )  ";
      }
      out += " ) {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'multipleOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { multipleOf: " + $schemaValue + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should be multiple of ";
          if ($isData) {
            out += "' + " + $schemaValue;
          } else {
            out += "" + $schemaValue + "'";
          }
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/not.js
var require_not = __commonJS({
  "../../node_modules/ajv/lib/dotjs/not.js"(exports, module) {
    "use strict";
    module.exports = function generate_not(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      $it.level++;
      var $nextValid = "valid" + $it.level;
      if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += " var " + $errs + " = errors;  ";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        $it.createErrors = false;
        var $allErrorsOption;
        if ($it.opts.allErrors) {
          $allErrorsOption = $it.opts.allErrors;
          $it.opts.allErrors = false;
        }
        out += " " + it.validate($it) + " ";
        $it.createErrors = true;
        if ($allErrorsOption)
          $it.opts.allErrors = $allErrorsOption;
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " if (" + $nextValid + ") {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it.opts.messages !== false) {
            out += " , message: 'should NOT be valid' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
        if (it.opts.allErrors) {
          out += " } ";
        }
      } else {
        out += "  var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it.opts.messages !== false) {
            out += " , message: 'should NOT be valid' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if ($breakOnError) {
          out += " if (false) { ";
        }
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/oneOf.js
var require_oneOf = __commonJS({
  "../../node_modules/ajv/lib/dotjs/oneOf.js"(exports, module) {
    "use strict";
    module.exports = function generate_oneOf(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $currentBaseId = $it.baseId, $prevValid = "prevValid" + $lvl, $passingSchemas = "passingSchemas" + $lvl;
      out += "var " + $errs + " = errors , " + $prevValid + " = false , " + $valid + " = false , " + $passingSchemas + " = null; ";
      var $wasComposite = it.compositeRule;
      it.compositeRule = $it.compositeRule = true;
      var arr1 = $schema;
      if (arr1) {
        var $sch, $i = -1, l1 = arr1.length - 1;
        while ($i < l1) {
          $sch = arr1[$i += 1];
          if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + "[" + $i + "]";
            $it.errSchemaPath = $errSchemaPath + "/" + $i;
            out += "  " + it.validate($it) + " ";
            $it.baseId = $currentBaseId;
          } else {
            out += " var " + $nextValid + " = true; ";
          }
          if ($i) {
            out += " if (" + $nextValid + " && " + $prevValid + ") { " + $valid + " = false; " + $passingSchemas + " = [" + $passingSchemas + ", " + $i + "]; } else { ";
            $closingBraces += "}";
          }
          out += " if (" + $nextValid + ") { " + $valid + " = " + $prevValid + " = true; " + $passingSchemas + " = " + $i + "; }";
        }
      }
      it.compositeRule = $it.compositeRule = $wasComposite;
      out += "" + $closingBraces + "if (!" + $valid + ") {   var err =   ";
      if (it.createErrors !== false) {
        out += " { keyword: 'oneOf' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { passingSchemas: " + $passingSchemas + " } ";
        if (it.opts.messages !== false) {
          out += " , message: 'should match exactly one schema in oneOf' ";
        }
        if (it.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError(vErrors); ";
        } else {
          out += " validate.errors = vErrors; return false; ";
        }
      }
      out += "} else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }";
      if (it.opts.allErrors) {
        out += " } ";
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/pattern.js
var require_pattern = __commonJS({
  "../../node_modules/ajv/lib/dotjs/pattern.js"(exports, module) {
    "use strict";
    module.exports = function generate_pattern(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $regexp = $isData ? "(new RegExp(" + $schemaValue + "))" : it.usePattern($schema);
      out += "if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
      }
      out += " !" + $regexp + ".test(" + $data + ") ) {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it.createErrors !== false) {
        out += " { keyword: 'pattern' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { pattern:  ";
        if ($isData) {
          out += "" + $schemaValue;
        } else {
          out += "" + it.util.toQuotedString($schema);
        }
        out += "  } ";
        if (it.opts.messages !== false) {
          out += ` , message: 'should match pattern "`;
          if ($isData) {
            out += "' + " + $schemaValue + " + '";
          } else {
            out += "" + it.util.escapeQuotes($schema);
          }
          out += `"' `;
        }
        if (it.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + it.util.toQuotedString($schema);
          }
          out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        if (it.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += "} ";
      if ($breakOnError) {
        out += " else { ";
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/properties.js
var require_properties = __commonJS({
  "../../node_modules/ajv/lib/dotjs/properties.js"(exports, module) {
    "use strict";
    module.exports = function generate_properties(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      var $key = "key" + $lvl, $idx = "idx" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl;
      var $schemaKeys = Object.keys($schema || {}).filter(notProto), $pProperties = it.schema.patternProperties || {}, $pPropertyKeys = Object.keys($pProperties).filter(notProto), $aProperties = it.schema.additionalProperties, $someProperties = $schemaKeys.length || $pPropertyKeys.length, $noAdditional = $aProperties === false, $additionalIsSchema = typeof $aProperties == "object" && Object.keys($aProperties).length, $removeAdditional = it.opts.removeAdditional, $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
      var $required = it.schema.required;
      if ($required && !(it.opts.$data && $required.$data) && $required.length < it.opts.loopRequired) {
        var $requiredHash = it.util.toHash($required);
      }
      function notProto(p) {
        return p !== "__proto__";
      }
      out += "var " + $errs + " = errors;var " + $nextValid + " = true;";
      if ($ownProperties) {
        out += " var " + $dataProperties + " = undefined;";
      }
      if ($checkAdditional) {
        if ($ownProperties) {
          out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
        } else {
          out += " for (var " + $key + " in " + $data + ") { ";
        }
        if ($someProperties) {
          out += " var isAdditional" + $lvl + " = !(false ";
          if ($schemaKeys.length) {
            if ($schemaKeys.length > 8) {
              out += " || validate.schema" + $schemaPath + ".hasOwnProperty(" + $key + ") ";
            } else {
              var arr1 = $schemaKeys;
              if (arr1) {
                var $propertyKey, i1 = -1, l1 = arr1.length - 1;
                while (i1 < l1) {
                  $propertyKey = arr1[i1 += 1];
                  out += " || " + $key + " == " + it.util.toQuotedString($propertyKey) + " ";
                }
              }
            }
          }
          if ($pPropertyKeys.length) {
            var arr2 = $pPropertyKeys;
            if (arr2) {
              var $pProperty, $i = -1, l2 = arr2.length - 1;
              while ($i < l2) {
                $pProperty = arr2[$i += 1];
                out += " || " + it.usePattern($pProperty) + ".test(" + $key + ") ";
              }
            }
          }
          out += " ); if (isAdditional" + $lvl + ") { ";
        }
        if ($removeAdditional == "all") {
          out += " delete " + $data + "[" + $key + "]; ";
        } else {
          var $currentErrorPath = it.errorPath;
          var $additionalProperty = "' + " + $key + " + '";
          if (it.opts._errorDataPathProperty) {
            it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          }
          if ($noAdditional) {
            if ($removeAdditional) {
              out += " delete " + $data + "[" + $key + "]; ";
            } else {
              out += " " + $nextValid + " = false; ";
              var $currErrSchemaPath = $errSchemaPath;
              $errSchemaPath = it.errSchemaPath + "/additionalProperties";
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = "";
              if (it.createErrors !== false) {
                out += " { keyword: 'additionalProperties' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { additionalProperty: '" + $additionalProperty + "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: '";
                  if (it.opts._errorDataPathProperty) {
                    out += "is an invalid additional property";
                  } else {
                    out += "should NOT have additional properties";
                  }
                  out += "' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: false , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                if (it.async) {
                  out += " throw new ValidationError([" + __err + "]); ";
                } else {
                  out += " validate.errors = [" + __err + "]; return false; ";
                }
              } else {
                out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
              }
              $errSchemaPath = $currErrSchemaPath;
              if ($breakOnError) {
                out += " break; ";
              }
            }
          } else if ($additionalIsSchema) {
            if ($removeAdditional == "failing") {
              out += " var " + $errs + " = errors;  ";
              var $wasComposite = it.compositeRule;
              it.compositeRule = $it.compositeRule = true;
              $it.schema = $aProperties;
              $it.schemaPath = it.schemaPath + ".additionalProperties";
              $it.errSchemaPath = it.errSchemaPath + "/additionalProperties";
              $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
              var $passData = $data + "[" + $key + "]";
              $it.dataPathArr[$dataNxt] = $key;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              out += " if (!" + $nextValid + ") { errors = " + $errs + "; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete " + $data + "[" + $key + "]; }  ";
              it.compositeRule = $it.compositeRule = $wasComposite;
            } else {
              $it.schema = $aProperties;
              $it.schemaPath = it.schemaPath + ".additionalProperties";
              $it.errSchemaPath = it.errSchemaPath + "/additionalProperties";
              $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
              var $passData = $data + "[" + $key + "]";
              $it.dataPathArr[$dataNxt] = $key;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              if ($breakOnError) {
                out += " if (!" + $nextValid + ") break; ";
              }
            }
          }
          it.errorPath = $currentErrorPath;
        }
        if ($someProperties) {
          out += " } ";
        }
        out += " }  ";
        if ($breakOnError) {
          out += " if (" + $nextValid + ") { ";
          $closingBraces += "}";
        }
      }
      var $useDefaults = it.opts.useDefaults && !it.compositeRule;
      if ($schemaKeys.length) {
        var arr3 = $schemaKeys;
        if (arr3) {
          var $propertyKey, i3 = -1, l3 = arr3.length - 1;
          while (i3 < l3) {
            $propertyKey = arr3[i3 += 1];
            var $sch = $schema[$propertyKey];
            if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
              var $prop = it.util.getProperty($propertyKey), $passData = $data + $prop, $hasDefault = $useDefaults && $sch.default !== void 0;
              $it.schema = $sch;
              $it.schemaPath = $schemaPath + $prop;
              $it.errSchemaPath = $errSchemaPath + "/" + it.util.escapeFragment($propertyKey);
              $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
              $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                $code = it.util.varReplace($code, $nextData, $passData);
                var $useData = $passData;
              } else {
                var $useData = $nextData;
                out += " var " + $nextData + " = " + $passData + "; ";
              }
              if ($hasDefault) {
                out += " " + $code + " ";
              } else {
                if ($requiredHash && $requiredHash[$propertyKey]) {
                  out += " if ( " + $useData + " === undefined ";
                  if ($ownProperties) {
                    out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                  }
                  out += ") { " + $nextValid + " = false; ";
                  var $currentErrorPath = it.errorPath, $currErrSchemaPath = $errSchemaPath, $missingProperty = it.util.escapeQuotes($propertyKey);
                  if (it.opts._errorDataPathProperty) {
                    it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                  }
                  $errSchemaPath = it.errSchemaPath + "/required";
                  var $$outStack = $$outStack || [];
                  $$outStack.push(out);
                  out = "";
                  if (it.createErrors !== false) {
                    out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                    if (it.opts.messages !== false) {
                      out += " , message: '";
                      if (it.opts._errorDataPathProperty) {
                        out += "is a required property";
                      } else {
                        out += "should have required property \\'" + $missingProperty + "\\'";
                      }
                      out += "' ";
                    }
                    if (it.opts.verbose) {
                      out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                    }
                    out += " } ";
                  } else {
                    out += " {} ";
                  }
                  var __err = out;
                  out = $$outStack.pop();
                  if (!it.compositeRule && $breakOnError) {
                    if (it.async) {
                      out += " throw new ValidationError([" + __err + "]); ";
                    } else {
                      out += " validate.errors = [" + __err + "]; return false; ";
                    }
                  } else {
                    out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                  }
                  $errSchemaPath = $currErrSchemaPath;
                  it.errorPath = $currentErrorPath;
                  out += " } else { ";
                } else {
                  if ($breakOnError) {
                    out += " if ( " + $useData + " === undefined ";
                    if ($ownProperties) {
                      out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                    }
                    out += ") { " + $nextValid + " = true; } else { ";
                  } else {
                    out += " if (" + $useData + " !== undefined ";
                    if ($ownProperties) {
                      out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                    }
                    out += " ) { ";
                  }
                }
                out += " " + $code + " } ";
              }
            }
            if ($breakOnError) {
              out += " if (" + $nextValid + ") { ";
              $closingBraces += "}";
            }
          }
        }
      }
      if ($pPropertyKeys.length) {
        var arr4 = $pPropertyKeys;
        if (arr4) {
          var $pProperty, i4 = -1, l4 = arr4.length - 1;
          while (i4 < l4) {
            $pProperty = arr4[i4 += 1];
            var $sch = $pProperties[$pProperty];
            if (it.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {
              $it.schema = $sch;
              $it.schemaPath = it.schemaPath + ".patternProperties" + it.util.getProperty($pProperty);
              $it.errSchemaPath = it.errSchemaPath + "/patternProperties/" + it.util.escapeFragment($pProperty);
              if ($ownProperties) {
                out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
              } else {
                out += " for (var " + $key + " in " + $data + ") { ";
              }
              out += " if (" + it.usePattern($pProperty) + ".test(" + $key + ")) { ";
              $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
              var $passData = $data + "[" + $key + "]";
              $it.dataPathArr[$dataNxt] = $key;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
              } else {
                out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
              }
              if ($breakOnError) {
                out += " if (!" + $nextValid + ") break; ";
              }
              out += " } ";
              if ($breakOnError) {
                out += " else " + $nextValid + " = true; ";
              }
              out += " }  ";
              if ($breakOnError) {
                out += " if (" + $nextValid + ") { ";
                $closingBraces += "}";
              }
            }
          }
        }
      }
      if ($breakOnError) {
        out += " " + $closingBraces + " if (" + $errs + " == errors) {";
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/propertyNames.js
var require_propertyNames = __commonJS({
  "../../node_modules/ajv/lib/dotjs/propertyNames.js"(exports, module) {
    "use strict";
    module.exports = function generate_propertyNames(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $errs = "errs__" + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      out += "var " + $errs + " = errors;";
      if (it.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        var $key = "key" + $lvl, $idx = "idx" + $lvl, $i = "i" + $lvl, $invalidName = "' + " + $key + " + '", $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;
        if ($ownProperties) {
          out += " var " + $dataProperties + " = undefined; ";
        }
        if ($ownProperties) {
          out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
        } else {
          out += " for (var " + $key + " in " + $data + ") { ";
        }
        out += " var startErrs" + $lvl + " = errors; ";
        var $passData = $key;
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += " " + it.util.varReplace($code, $nextData, $passData) + " ";
        } else {
          out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
        }
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " if (!" + $nextValid + ") { for (var " + $i + "=startErrs" + $lvl + "; " + $i + "<errors; " + $i + "++) { vErrors[" + $i + "].propertyName = " + $key + "; }   var err =   ";
        if (it.createErrors !== false) {
          out += " { keyword: 'propertyNames' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { propertyName: '" + $invalidName + "' } ";
          if (it.opts.messages !== false) {
            out += " , message: 'property name \\'" + $invalidName + "\\' is invalid' ";
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError(vErrors); ";
          } else {
            out += " validate.errors = vErrors; return false; ";
          }
        }
        if ($breakOnError) {
          out += " break; ";
        }
        out += " } }";
      }
      if ($breakOnError) {
        out += " " + $closingBraces + " if (" + $errs + " == errors) {";
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/required.js
var require_required = __commonJS({
  "../../node_modules/ajv/lib/dotjs/required.js"(exports, module) {
    "use strict";
    module.exports = function generate_required(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $vSchema = "schema" + $lvl;
      if (!$isData) {
        if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
          var $required = [];
          var arr1 = $schema;
          if (arr1) {
            var $property, i1 = -1, l1 = arr1.length - 1;
            while (i1 < l1) {
              $property = arr1[i1 += 1];
              var $propertySch = it.schema.properties[$property];
              if (!($propertySch && (it.opts.strictKeywords ? typeof $propertySch == "object" && Object.keys($propertySch).length > 0 || $propertySch === false : it.util.schemaHasRules($propertySch, it.RULES.all)))) {
                $required[$required.length] = $property;
              }
            }
          }
        } else {
          var $required = $schema;
        }
      }
      if ($isData || $required.length) {
        var $currentErrorPath = it.errorPath, $loopRequired = $isData || $required.length >= it.opts.loopRequired, $ownProperties = it.opts.ownProperties;
        if ($breakOnError) {
          out += " var missing" + $lvl + "; ";
          if ($loopRequired) {
            if (!$isData) {
              out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
            }
            var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
            }
            out += " var " + $valid + " = true; ";
            if ($isData) {
              out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
            }
            out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { " + $valid + " = " + $data + "[" + $vSchema + "[" + $i + "]] !== undefined ";
            if ($ownProperties) {
              out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
            }
            out += "; if (!" + $valid + ") break; } ";
            if ($isData) {
              out += "  }  ";
            }
            out += "  if (!" + $valid + ") {   ";
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: '";
                if (it.opts._errorDataPathProperty) {
                  out += "is a required property";
                } else {
                  out += "should have required property \\'" + $missingProperty + "\\'";
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += " } else { ";
          } else {
            out += " if ( ";
            var arr2 = $required;
            if (arr2) {
              var $propertyKey, $i = -1, l2 = arr2.length - 1;
              while ($i < l2) {
                $propertyKey = arr2[$i += 1];
                if ($i) {
                  out += " || ";
                }
                var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;
                out += " ( ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") && (missing" + $lvl + " = " + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
              }
            }
            out += ") {  ";
            var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
            }
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it.createErrors !== false) {
              out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: '";
                if (it.opts._errorDataPathProperty) {
                  out += "is a required property";
                } else {
                  out += "should have required property \\'" + $missingProperty + "\\'";
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              if (it.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            out += " } else { ";
          }
        } else {
          if ($loopRequired) {
            if (!$isData) {
              out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
            }
            var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
            }
            if ($isData) {
              out += " if (" + $vSchema + " && !Array.isArray(" + $vSchema + ")) {  var err =   ";
              if (it.createErrors !== false) {
                out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                if (it.opts.messages !== false) {
                  out += " , message: '";
                  if (it.opts._errorDataPathProperty) {
                    out += "is a required property";
                  } else {
                    out += "should have required property \\'" + $missingProperty + "\\'";
                  }
                  out += "' ";
                }
                if (it.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (" + $vSchema + " !== undefined) { ";
            }
            out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { if (" + $data + "[" + $vSchema + "[" + $i + "]] === undefined ";
            if ($ownProperties) {
              out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
            }
            out += ") {  var err =   ";
            if (it.createErrors !== false) {
              out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
              if (it.opts.messages !== false) {
                out += " , message: '";
                if (it.opts._errorDataPathProperty) {
                  out += "is a required property";
                } else {
                  out += "should have required property \\'" + $missingProperty + "\\'";
                }
                out += "' ";
              }
              if (it.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ";
            if ($isData) {
              out += "  }  ";
            }
          } else {
            var arr3 = $required;
            if (arr3) {
              var $propertyKey, i3 = -1, l3 = arr3.length - 1;
              while (i3 < l3) {
                $propertyKey = arr3[i3 += 1];
                var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;
                if (it.opts._errorDataPathProperty) {
                  it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                }
                out += " if ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") {  var err =   ";
                if (it.createErrors !== false) {
                  out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                  if (it.opts.messages !== false) {
                    out += " , message: '";
                    if (it.opts._errorDataPathProperty) {
                      out += "is a required property";
                    } else {
                      out += "should have required property \\'" + $missingProperty + "\\'";
                    }
                    out += "' ";
                  }
                  if (it.opts.verbose) {
                    out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
                  }
                  out += " } ";
                } else {
                  out += " {} ";
                }
                out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
              }
            }
          }
        }
        it.errorPath = $currentErrorPath;
      } else if ($breakOnError) {
        out += " if (true) {";
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/uniqueItems.js
var require_uniqueItems = __commonJS({
  "../../node_modules/ajv/lib/dotjs/uniqueItems.js"(exports, module) {
    "use strict";
    module.exports = function generate_uniqueItems(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (($schema || $isData) && it.opts.uniqueItems !== false) {
        if ($isData) {
          out += " var " + $valid + "; if (" + $schemaValue + " === false || " + $schemaValue + " === undefined) " + $valid + " = true; else if (typeof " + $schemaValue + " != 'boolean') " + $valid + " = false; else { ";
        }
        out += " var i = " + $data + ".length , " + $valid + " = true , j; if (i > 1) { ";
        var $itemType = it.schema.items && it.schema.items.type, $typeIsArray = Array.isArray($itemType);
        if (!$itemType || $itemType == "object" || $itemType == "array" || $typeIsArray && ($itemType.indexOf("object") >= 0 || $itemType.indexOf("array") >= 0)) {
          out += " outer: for (;i--;) { for (j = i; j--;) { if (equal(" + $data + "[i], " + $data + "[j])) { " + $valid + " = false; break outer; } } } ";
        } else {
          out += " var itemIndices = {}, item; for (;i--;) { var item = " + $data + "[i]; ";
          var $method = "checkDataType" + ($typeIsArray ? "s" : "");
          out += " if (" + it.util[$method]($itemType, "item", it.opts.strictNumbers, true) + ") continue; ";
          if ($typeIsArray) {
            out += ` if (typeof item == 'string') item = '"' + item; `;
          }
          out += " if (typeof itemIndices[item] == 'number') { " + $valid + " = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ";
        }
        out += " } ";
        if ($isData) {
          out += "  }  ";
        }
        out += " if (!" + $valid + ") {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: 'uniqueItems' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { i: i, j: j } ";
          if (it.opts.messages !== false) {
            out += " , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' ";
          }
          if (it.opts.verbose) {
            out += " , schema:  ";
            if ($isData) {
              out += "validate.schema" + $schemaPath;
            } else {
              out += "" + $schema;
            }
            out += "         , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } ";
        if ($breakOnError) {
          out += " else { ";
        }
      } else {
        if ($breakOnError) {
          out += " if (true) { ";
        }
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/dotjs/index.js
var require_dotjs = __commonJS({
  "../../node_modules/ajv/lib/dotjs/index.js"(exports, module) {
    "use strict";
    module.exports = {
      "$ref": require_ref(),
      allOf: require_allOf(),
      anyOf: require_anyOf(),
      "$comment": require_comment(),
      const: require_const(),
      contains: require_contains(),
      dependencies: require_dependencies(),
      "enum": require_enum(),
      format: require_format(),
      "if": require_if(),
      items: require_items(),
      maximum: require_limit(),
      minimum: require_limit(),
      maxItems: require_limitItems(),
      minItems: require_limitItems(),
      maxLength: require_limitLength(),
      minLength: require_limitLength(),
      maxProperties: require_limitProperties(),
      minProperties: require_limitProperties(),
      multipleOf: require_multipleOf(),
      not: require_not(),
      oneOf: require_oneOf(),
      pattern: require_pattern(),
      properties: require_properties(),
      propertyNames: require_propertyNames(),
      required: require_required(),
      uniqueItems: require_uniqueItems(),
      validate: require_validate()
    };
  }
});

// ../../node_modules/ajv/lib/compile/rules.js
var require_rules = __commonJS({
  "../../node_modules/ajv/lib/compile/rules.js"(exports, module) {
    "use strict";
    var ruleModules = require_dotjs();
    var toHash = require_util2().toHash;
    module.exports = function rules() {
      var RULES = [
        {
          type: "number",
          rules: [
            { "maximum": ["exclusiveMaximum"] },
            { "minimum": ["exclusiveMinimum"] },
            "multipleOf",
            "format"
          ]
        },
        {
          type: "string",
          rules: ["maxLength", "minLength", "pattern", "format"]
        },
        {
          type: "array",
          rules: ["maxItems", "minItems", "items", "contains", "uniqueItems"]
        },
        {
          type: "object",
          rules: [
            "maxProperties",
            "minProperties",
            "required",
            "dependencies",
            "propertyNames",
            { "properties": ["additionalProperties", "patternProperties"] }
          ]
        },
        { rules: ["$ref", "const", "enum", "not", "anyOf", "oneOf", "allOf", "if"] }
      ];
      var ALL = ["type", "$comment"];
      var KEYWORDS = [
        "$schema",
        "$id",
        "id",
        "$data",
        "$async",
        "title",
        "description",
        "default",
        "definitions",
        "examples",
        "readOnly",
        "writeOnly",
        "contentMediaType",
        "contentEncoding",
        "additionalItems",
        "then",
        "else"
      ];
      var TYPES = ["number", "integer", "string", "array", "object", "boolean", "null"];
      RULES.all = toHash(ALL);
      RULES.types = toHash(TYPES);
      RULES.forEach(function(group) {
        group.rules = group.rules.map(function(keyword) {
          var implKeywords;
          if (typeof keyword == "object") {
            var key = Object.keys(keyword)[0];
            implKeywords = keyword[key];
            keyword = key;
            implKeywords.forEach(function(k) {
              ALL.push(k);
              RULES.all[k] = true;
            });
          }
          ALL.push(keyword);
          var rule = RULES.all[keyword] = {
            keyword,
            code: ruleModules[keyword],
            implements: implKeywords
          };
          return rule;
        });
        RULES.all.$comment = {
          keyword: "$comment",
          code: ruleModules.$comment
        };
        if (group.type)
          RULES.types[group.type] = group;
      });
      RULES.keywords = toHash(ALL.concat(KEYWORDS));
      RULES.custom = {};
      return RULES;
    };
  }
});

// ../../node_modules/ajv/lib/data.js
var require_data = __commonJS({
  "../../node_modules/ajv/lib/data.js"(exports, module) {
    "use strict";
    var KEYWORDS = [
      "multipleOf",
      "maximum",
      "exclusiveMaximum",
      "minimum",
      "exclusiveMinimum",
      "maxLength",
      "minLength",
      "pattern",
      "additionalItems",
      "maxItems",
      "minItems",
      "uniqueItems",
      "maxProperties",
      "minProperties",
      "required",
      "additionalProperties",
      "enum",
      "format",
      "const"
    ];
    module.exports = function(metaSchema, keywordsJsonPointers) {
      for (var i = 0; i < keywordsJsonPointers.length; i++) {
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        var segments = keywordsJsonPointers[i].split("/");
        var keywords = metaSchema;
        var j;
        for (j = 1; j < segments.length; j++)
          keywords = keywords[segments[j]];
        for (j = 0; j < KEYWORDS.length; j++) {
          var key = KEYWORDS[j];
          var schema = keywords[key];
          if (schema) {
            keywords[key] = {
              anyOf: [
                schema,
                { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
              ]
            };
          }
        }
      }
      return metaSchema;
    };
  }
});

// ../../node_modules/ajv/lib/compile/async.js
var require_async = __commonJS({
  "../../node_modules/ajv/lib/compile/async.js"(exports, module) {
    "use strict";
    var MissingRefError = require_error_classes().MissingRef;
    module.exports = compileAsync;
    function compileAsync(schema, meta, callback) {
      var self2 = this;
      if (typeof this._opts.loadSchema != "function")
        throw new Error("options.loadSchema should be a function");
      if (typeof meta == "function") {
        callback = meta;
        meta = void 0;
      }
      var p = loadMetaSchemaOf(schema).then(function() {
        var schemaObj = self2._addSchema(schema, void 0, meta);
        return schemaObj.validate || _compileAsync(schemaObj);
      });
      if (callback) {
        p.then(
          function(v) {
            callback(null, v);
          },
          callback
        );
      }
      return p;
      function loadMetaSchemaOf(sch) {
        var $schema = sch.$schema;
        return $schema && !self2.getSchema($schema) ? compileAsync.call(self2, { $ref: $schema }, true) : Promise.resolve();
      }
      function _compileAsync(schemaObj) {
        try {
          return self2._compile(schemaObj);
        } catch (e) {
          if (e instanceof MissingRefError)
            return loadMissingSchema(e);
          throw e;
        }
        function loadMissingSchema(e) {
          var ref = e.missingSchema;
          if (added(ref))
            throw new Error("Schema " + ref + " is loaded but " + e.missingRef + " cannot be resolved");
          var schemaPromise = self2._loadingSchemas[ref];
          if (!schemaPromise) {
            schemaPromise = self2._loadingSchemas[ref] = self2._opts.loadSchema(ref);
            schemaPromise.then(removePromise, removePromise);
          }
          return schemaPromise.then(function(sch) {
            if (!added(ref)) {
              return loadMetaSchemaOf(sch).then(function() {
                if (!added(ref))
                  self2.addSchema(sch, ref, void 0, meta);
              });
            }
          }).then(function() {
            return _compileAsync(schemaObj);
          });
          function removePromise() {
            delete self2._loadingSchemas[ref];
          }
          function added(ref2) {
            return self2._refs[ref2] || self2._schemas[ref2];
          }
        }
      }
    }
  }
});

// ../../node_modules/ajv/lib/dotjs/custom.js
var require_custom = __commonJS({
  "../../node_modules/ajv/lib/dotjs/custom.js"(exports, module) {
    "use strict";
    module.exports = function generate_custom(it, $keyword, $ruleType) {
      var out = " ";
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      var $errs = "errs__" + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;
      if ($isData) {
        out += " var schema" + $lvl + " = " + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + "; ";
        $schemaValue = "schema" + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $rule = this, $definition = "definition" + $lvl, $rDef = $rule.definition, $closingBraces = "";
      var $compile, $inline, $macro, $ruleValidate, $validateCode;
      if ($isData && $rDef.$data) {
        $validateCode = "keywordValidate" + $lvl;
        var $validateSchema = $rDef.validateSchema;
        out += " var " + $definition + " = RULES.custom['" + $keyword + "'].definition; var " + $validateCode + " = " + $definition + ".validate;";
      } else {
        $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
        if (!$ruleValidate)
          return;
        $schemaValue = "validate.schema" + $schemaPath;
        $validateCode = $ruleValidate.code;
        $compile = $rDef.compile;
        $inline = $rDef.inline;
        $macro = $rDef.macro;
      }
      var $ruleErrs = $validateCode + ".errors", $i = "i" + $lvl, $ruleErr = "ruleErr" + $lvl, $asyncKeyword = $rDef.async;
      if ($asyncKeyword && !it.async)
        throw new Error("async keyword in sync schema");
      if (!($inline || $macro)) {
        out += "" + $ruleErrs + " = null;";
      }
      out += "var " + $errs + " = errors;var " + $valid + ";";
      if ($isData && $rDef.$data) {
        $closingBraces += "}";
        out += " if (" + $schemaValue + " === undefined) { " + $valid + " = true; } else { ";
        if ($validateSchema) {
          $closingBraces += "}";
          out += " " + $valid + " = " + $definition + ".validateSchema(" + $schemaValue + "); if (" + $valid + ") { ";
        }
      }
      if ($inline) {
        if ($rDef.statements) {
          out += " " + $ruleValidate.validate + " ";
        } else {
          out += " " + $valid + " = " + $ruleValidate.validate + "; ";
        }
      } else if ($macro) {
        var $it = it.util.copy(it);
        var $closingBraces = "";
        $it.level++;
        var $nextValid = "valid" + $it.level;
        $it.schema = $ruleValidate.validate;
        $it.schemaPath = "";
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += " " + $code;
      } else {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        out += "  " + $validateCode + ".call( ";
        if (it.opts.passContext) {
          out += "this";
        } else {
          out += "self";
        }
        if ($compile || $rDef.schema === false) {
          out += " , " + $data + " ";
        } else {
          out += " , " + $schemaValue + " , " + $data + " , validate.schema" + it.schemaPath + " ";
        }
        out += " , (dataPath || '')";
        if (it.errorPath != '""') {
          out += " + " + it.errorPath;
        }
        var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : "parentDataProperty";
        out += " , " + $parentData + " , " + $parentDataProperty + " , rootData )  ";
        var def_callRuleValidate = out;
        out = $$outStack.pop();
        if ($rDef.errors === false) {
          out += " " + $valid + " = ";
          if ($asyncKeyword) {
            out += "await ";
          }
          out += "" + def_callRuleValidate + "; ";
        } else {
          if ($asyncKeyword) {
            $ruleErrs = "customErrors" + $lvl;
            out += " var " + $ruleErrs + " = null; try { " + $valid + " = await " + def_callRuleValidate + "; } catch (e) { " + $valid + " = false; if (e instanceof ValidationError) " + $ruleErrs + " = e.errors; else throw e; } ";
          } else {
            out += " " + $ruleErrs + " = null; " + $valid + " = " + def_callRuleValidate + "; ";
          }
        }
      }
      if ($rDef.modifying) {
        out += " if (" + $parentData + ") " + $data + " = " + $parentData + "[" + $parentDataProperty + "];";
      }
      out += "" + $closingBraces;
      if ($rDef.valid) {
        if ($breakOnError) {
          out += " if (true) { ";
        }
      } else {
        out += " if ( ";
        if ($rDef.valid === void 0) {
          out += " !";
          if ($macro) {
            out += "" + $nextValid;
          } else {
            out += "" + $valid;
          }
        } else {
          out += " " + !$rDef.valid + " ";
        }
        out += ") { ";
        $errorKeyword = $rule.keyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
          if (it.opts.messages !== false) {
            out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
          }
          if (it.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          if (it.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        var def_customError = out;
        out = $$outStack.pop();
        if ($inline) {
          if ($rDef.errors) {
            if ($rDef.errors != "full") {
              out += "  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
              if (it.opts.verbose) {
                out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
              }
              out += " } ";
            }
          } else {
            if ($rDef.errors === false) {
              out += " " + def_customError + " ";
            } else {
              out += " if (" + $errs + " == errors) { " + def_customError + " } else {  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
              if (it.opts.verbose) {
                out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
              }
              out += " } } ";
            }
          }
        } else if ($macro) {
          out += "   var err =   ";
          if (it.createErrors !== false) {
            out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it.errorPath + " , schemaPath: " + it.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
            if (it.opts.messages !== false) {
              out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
            }
            if (it.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          if (!it.compositeRule && $breakOnError) {
            if (it.async) {
              out += " throw new ValidationError(vErrors); ";
            } else {
              out += " validate.errors = vErrors; return false; ";
            }
          }
        } else {
          if ($rDef.errors === false) {
            out += " " + def_customError + " ";
          } else {
            out += " if (Array.isArray(" + $ruleErrs + ")) { if (vErrors === null) vErrors = " + $ruleErrs + "; else vErrors = vErrors.concat(" + $ruleErrs + "); errors = vErrors.length;  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it.errorPath + ";  " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '";  ';
            if (it.opts.verbose) {
              out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
            }
            out += " } } else { " + def_customError + " } ";
          }
        }
        out += " } ";
        if ($breakOnError) {
          out += " else { ";
        }
      }
      return out;
    };
  }
});

// ../../node_modules/ajv/lib/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS({
  "../../node_modules/ajv/lib/refs/json-schema-draft-07.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [
            { $ref: "#/definitions/nonNegativeInteger" },
            { default: 0 }
          ]
        },
        simpleTypes: {
          enum: [
            "array",
            "boolean",
            "integer",
            "null",
            "number",
            "object",
            "string"
          ]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: true,
        readOnly: {
          type: "boolean",
          default: false
        },
        examples: {
          type: "array",
          items: true
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [
            { $ref: "#" },
            { $ref: "#/definitions/schemaArray" }
          ],
          default: true
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [
              { $ref: "#" },
              { $ref: "#/definitions/stringArray" }
            ]
          }
        },
        propertyNames: { $ref: "#" },
        const: true,
        enum: {
          type: "array",
          items: true,
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: true
    };
  }
});

// ../../node_modules/ajv/lib/definition_schema.js
var require_definition_schema = __commonJS({
  "../../node_modules/ajv/lib/definition_schema.js"(exports, module) {
    "use strict";
    var metaSchema = require_json_schema_draft_07();
    module.exports = {
      $id: "https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js",
      definitions: {
        simpleTypes: metaSchema.definitions.simpleTypes
      },
      type: "object",
      dependencies: {
        schema: ["validate"],
        $data: ["validate"],
        statements: ["inline"],
        valid: { not: { required: ["macro"] } }
      },
      properties: {
        type: metaSchema.properties.type,
        schema: { type: "boolean" },
        statements: { type: "boolean" },
        dependencies: {
          type: "array",
          items: { type: "string" }
        },
        metaSchema: { type: "object" },
        modifying: { type: "boolean" },
        valid: { type: "boolean" },
        $data: { type: "boolean" },
        async: { type: "boolean" },
        errors: {
          anyOf: [
            { type: "boolean" },
            { const: "full" }
          ]
        }
      }
    };
  }
});

// ../../node_modules/ajv/lib/keyword.js
var require_keyword = __commonJS({
  "../../node_modules/ajv/lib/keyword.js"(exports, module) {
    "use strict";
    var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
    var customRuleCode = require_custom();
    var definitionSchema = require_definition_schema();
    module.exports = {
      add: addKeyword,
      get: getKeyword,
      remove: removeKeyword,
      validate: validateKeyword
    };
    function addKeyword(keyword, definition) {
      var RULES = this.RULES;
      if (RULES.keywords[keyword])
        throw new Error("Keyword " + keyword + " is already defined");
      if (!IDENTIFIER.test(keyword))
        throw new Error("Keyword " + keyword + " is not a valid identifier");
      if (definition) {
        this.validateKeyword(definition, true);
        var dataType = definition.type;
        if (Array.isArray(dataType)) {
          for (var i = 0; i < dataType.length; i++)
            _addRule(keyword, dataType[i], definition);
        } else {
          _addRule(keyword, dataType, definition);
        }
        var metaSchema = definition.metaSchema;
        if (metaSchema) {
          if (definition.$data && this._opts.$data) {
            metaSchema = {
              anyOf: [
                metaSchema,
                { "$ref": "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" }
              ]
            };
          }
          definition.validateSchema = this.compile(metaSchema, true);
        }
      }
      RULES.keywords[keyword] = RULES.all[keyword] = true;
      function _addRule(keyword2, dataType2, definition2) {
        var ruleGroup;
        for (var i2 = 0; i2 < RULES.length; i2++) {
          var rg = RULES[i2];
          if (rg.type == dataType2) {
            ruleGroup = rg;
            break;
          }
        }
        if (!ruleGroup) {
          ruleGroup = { type: dataType2, rules: [] };
          RULES.push(ruleGroup);
        }
        var rule = {
          keyword: keyword2,
          definition: definition2,
          custom: true,
          code: customRuleCode,
          implements: definition2.implements
        };
        ruleGroup.rules.push(rule);
        RULES.custom[keyword2] = rule;
      }
      return this;
    }
    function getKeyword(keyword) {
      var rule = this.RULES.custom[keyword];
      return rule ? rule.definition : this.RULES.keywords[keyword] || false;
    }
    function removeKeyword(keyword) {
      var RULES = this.RULES;
      delete RULES.keywords[keyword];
      delete RULES.all[keyword];
      delete RULES.custom[keyword];
      for (var i = 0; i < RULES.length; i++) {
        var rules = RULES[i].rules;
        for (var j = 0; j < rules.length; j++) {
          if (rules[j].keyword == keyword) {
            rules.splice(j, 1);
            break;
          }
        }
      }
      return this;
    }
    function validateKeyword(definition, throwError) {
      validateKeyword.errors = null;
      var v = this._validateKeyword = this._validateKeyword || this.compile(definitionSchema, true);
      if (v(definition))
        return true;
      validateKeyword.errors = v.errors;
      if (throwError)
        throw new Error("custom keyword definition is invalid: " + this.errorsText(v.errors));
      else
        return false;
    }
  }
});

// ../../node_modules/ajv/lib/refs/data.json
var require_data2 = __commonJS({
  "../../node_modules/ajv/lib/refs/data.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON Schema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [
            { format: "relative-json-pointer" },
            { format: "json-pointer" }
          ]
        }
      },
      additionalProperties: false
    };
  }
});

// ../../node_modules/ajv/lib/ajv.js
var require_ajv = __commonJS({
  "../../node_modules/ajv/lib/ajv.js"(exports, module) {
    "use strict";
    var compileSchema = require_compile();
    var resolve = require_resolve();
    var Cache = require_cache();
    var SchemaObject = require_schema_obj();
    var stableStringify = require_fast_json_stable_stringify();
    var formats = require_formats();
    var rules = require_rules();
    var $dataMetaSchema = require_data();
    var util = require_util2();
    module.exports = Ajv;
    Ajv.prototype.validate = validate;
    Ajv.prototype.compile = compile;
    Ajv.prototype.addSchema = addSchema;
    Ajv.prototype.addMetaSchema = addMetaSchema;
    Ajv.prototype.validateSchema = validateSchema;
    Ajv.prototype.getSchema = getSchema;
    Ajv.prototype.removeSchema = removeSchema;
    Ajv.prototype.addFormat = addFormat;
    Ajv.prototype.errorsText = errorsText;
    Ajv.prototype._addSchema = _addSchema;
    Ajv.prototype._compile = _compile;
    Ajv.prototype.compileAsync = require_async();
    var customKeyword = require_keyword();
    Ajv.prototype.addKeyword = customKeyword.add;
    Ajv.prototype.getKeyword = customKeyword.get;
    Ajv.prototype.removeKeyword = customKeyword.remove;
    Ajv.prototype.validateKeyword = customKeyword.validate;
    var errorClasses = require_error_classes();
    Ajv.ValidationError = errorClasses.Validation;
    Ajv.MissingRefError = errorClasses.MissingRef;
    Ajv.$dataMetaSchema = $dataMetaSchema;
    var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes", "strictDefaults"];
    var META_SUPPORT_DATA = ["/properties"];
    function Ajv(opts) {
      if (!(this instanceof Ajv))
        return new Ajv(opts);
      opts = this._opts = util.copy(opts) || {};
      setLogger(this);
      this._schemas = {};
      this._refs = {};
      this._fragments = {};
      this._formats = formats(opts.format);
      this._cache = opts.cache || new Cache();
      this._loadingSchemas = {};
      this._compilations = [];
      this.RULES = rules();
      this._getId = chooseGetId(opts);
      opts.loopRequired = opts.loopRequired || Infinity;
      if (opts.errorDataPath == "property")
        opts._errorDataPathProperty = true;
      if (opts.serialize === void 0)
        opts.serialize = stableStringify;
      this._metaOpts = getMetaSchemaOptions(this);
      if (opts.formats)
        addInitialFormats(this);
      if (opts.keywords)
        addInitialKeywords(this);
      addDefaultMetaSchema(this);
      if (typeof opts.meta == "object")
        this.addMetaSchema(opts.meta);
      if (opts.nullable)
        this.addKeyword("nullable", { metaSchema: { type: "boolean" } });
      addInitialSchemas(this);
    }
    function validate(schemaKeyRef, data) {
      var v;
      if (typeof schemaKeyRef == "string") {
        v = this.getSchema(schemaKeyRef);
        if (!v)
          throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
      } else {
        var schemaObj = this._addSchema(schemaKeyRef);
        v = schemaObj.validate || this._compile(schemaObj);
      }
      var valid = v(data);
      if (v.$async !== true)
        this.errors = v.errors;
      return valid;
    }
    function compile(schema, _meta) {
      var schemaObj = this._addSchema(schema, void 0, _meta);
      return schemaObj.validate || this._compile(schemaObj);
    }
    function addSchema(schema, key, _skipValidation, _meta) {
      if (Array.isArray(schema)) {
        for (var i = 0; i < schema.length; i++)
          this.addSchema(schema[i], void 0, _skipValidation, _meta);
        return this;
      }
      var id = this._getId(schema);
      if (id !== void 0 && typeof id != "string")
        throw new Error("schema id must be string");
      key = resolve.normalizeId(key || id);
      checkUnique(this, key);
      this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
      return this;
    }
    function addMetaSchema(schema, key, skipValidation) {
      this.addSchema(schema, key, skipValidation, true);
      return this;
    }
    function validateSchema(schema, throwOrLogError) {
      var $schema = schema.$schema;
      if ($schema !== void 0 && typeof $schema != "string")
        throw new Error("$schema must be a string");
      $schema = $schema || this._opts.defaultMeta || defaultMeta(this);
      if (!$schema) {
        this.logger.warn("meta-schema not available");
        this.errors = null;
        return true;
      }
      var valid = this.validate($schema, schema);
      if (!valid && throwOrLogError) {
        var message = "schema is invalid: " + this.errorsText();
        if (this._opts.validateSchema == "log")
          this.logger.error(message);
        else
          throw new Error(message);
      }
      return valid;
    }
    function defaultMeta(self2) {
      var meta = self2._opts.meta;
      self2._opts.defaultMeta = typeof meta == "object" ? self2._getId(meta) || meta : self2.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0;
      return self2._opts.defaultMeta;
    }
    function getSchema(keyRef) {
      var schemaObj = _getSchemaObj(this, keyRef);
      switch (typeof schemaObj) {
        case "object":
          return schemaObj.validate || this._compile(schemaObj);
        case "string":
          return this.getSchema(schemaObj);
        case "undefined":
          return _getSchemaFragment(this, keyRef);
      }
    }
    function _getSchemaFragment(self2, ref) {
      var res = resolve.schema.call(self2, { schema: {} }, ref);
      if (res) {
        var schema = res.schema, root = res.root, baseId = res.baseId;
        var v = compileSchema.call(self2, schema, root, void 0, baseId);
        self2._fragments[ref] = new SchemaObject({
          ref,
          fragment: true,
          schema,
          root,
          baseId,
          validate: v
        });
        return v;
      }
    }
    function _getSchemaObj(self2, keyRef) {
      keyRef = resolve.normalizeId(keyRef);
      return self2._schemas[keyRef] || self2._refs[keyRef] || self2._fragments[keyRef];
    }
    function removeSchema(schemaKeyRef) {
      if (schemaKeyRef instanceof RegExp) {
        _removeAllSchemas(this, this._schemas, schemaKeyRef);
        _removeAllSchemas(this, this._refs, schemaKeyRef);
        return this;
      }
      switch (typeof schemaKeyRef) {
        case "undefined":
          _removeAllSchemas(this, this._schemas);
          _removeAllSchemas(this, this._refs);
          this._cache.clear();
          return this;
        case "string":
          var schemaObj = _getSchemaObj(this, schemaKeyRef);
          if (schemaObj)
            this._cache.del(schemaObj.cacheKey);
          delete this._schemas[schemaKeyRef];
          delete this._refs[schemaKeyRef];
          return this;
        case "object":
          var serialize = this._opts.serialize;
          var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
          this._cache.del(cacheKey);
          var id = this._getId(schemaKeyRef);
          if (id) {
            id = resolve.normalizeId(id);
            delete this._schemas[id];
            delete this._refs[id];
          }
      }
      return this;
    }
    function _removeAllSchemas(self2, schemas, regex) {
      for (var keyRef in schemas) {
        var schemaObj = schemas[keyRef];
        if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
          self2._cache.del(schemaObj.cacheKey);
          delete schemas[keyRef];
        }
      }
    }
    function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
      if (typeof schema != "object" && typeof schema != "boolean")
        throw new Error("schema should be object or boolean");
      var serialize = this._opts.serialize;
      var cacheKey = serialize ? serialize(schema) : schema;
      var cached = this._cache.get(cacheKey);
      if (cached)
        return cached;
      shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;
      var id = resolve.normalizeId(this._getId(schema));
      if (id && shouldAddSchema)
        checkUnique(this, id);
      var willValidate = this._opts.validateSchema !== false && !skipValidation;
      var recursiveMeta;
      if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)))
        this.validateSchema(schema, true);
      var localRefs = resolve.ids.call(this, schema);
      var schemaObj = new SchemaObject({
        id,
        schema,
        localRefs,
        cacheKey,
        meta
      });
      if (id[0] != "#" && shouldAddSchema)
        this._refs[id] = schemaObj;
      this._cache.put(cacheKey, schemaObj);
      if (willValidate && recursiveMeta)
        this.validateSchema(schema, true);
      return schemaObj;
    }
    function _compile(schemaObj, root) {
      if (schemaObj.compiling) {
        schemaObj.validate = callValidate;
        callValidate.schema = schemaObj.schema;
        callValidate.errors = null;
        callValidate.root = root ? root : callValidate;
        if (schemaObj.schema.$async === true)
          callValidate.$async = true;
        return callValidate;
      }
      schemaObj.compiling = true;
      var currentOpts;
      if (schemaObj.meta) {
        currentOpts = this._opts;
        this._opts = this._metaOpts;
      }
      var v;
      try {
        v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs);
      } catch (e) {
        delete schemaObj.validate;
        throw e;
      } finally {
        schemaObj.compiling = false;
        if (schemaObj.meta)
          this._opts = currentOpts;
      }
      schemaObj.validate = v;
      schemaObj.refs = v.refs;
      schemaObj.refVal = v.refVal;
      schemaObj.root = v.root;
      return v;
      function callValidate() {
        var _validate = schemaObj.validate;
        var result = _validate.apply(this, arguments);
        callValidate.errors = _validate.errors;
        return result;
      }
    }
    function chooseGetId(opts) {
      switch (opts.schemaId) {
        case "auto":
          return _get$IdOrId;
        case "id":
          return _getId;
        default:
          return _get$Id;
      }
    }
    function _getId(schema) {
      if (schema.$id)
        this.logger.warn("schema $id ignored", schema.$id);
      return schema.id;
    }
    function _get$Id(schema) {
      if (schema.id)
        this.logger.warn("schema id ignored", schema.id);
      return schema.$id;
    }
    function _get$IdOrId(schema) {
      if (schema.$id && schema.id && schema.$id != schema.id)
        throw new Error("schema $id is different from id");
      return schema.$id || schema.id;
    }
    function errorsText(errors, options) {
      errors = errors || this.errors;
      if (!errors)
        return "No errors";
      options = options || {};
      var separator = options.separator === void 0 ? ", " : options.separator;
      var dataVar = options.dataVar === void 0 ? "data" : options.dataVar;
      var text = "";
      for (var i = 0; i < errors.length; i++) {
        var e = errors[i];
        if (e)
          text += dataVar + e.dataPath + " " + e.message + separator;
      }
      return text.slice(0, -separator.length);
    }
    function addFormat(name, format) {
      if (typeof format == "string")
        format = new RegExp(format);
      this._formats[name] = format;
      return this;
    }
    function addDefaultMetaSchema(self2) {
      var $dataSchema;
      if (self2._opts.$data) {
        $dataSchema = require_data2();
        self2.addMetaSchema($dataSchema, $dataSchema.$id, true);
      }
      if (self2._opts.meta === false)
        return;
      var metaSchema = require_json_schema_draft_07();
      if (self2._opts.$data)
        metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
      self2.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
      self2._refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
    }
    function addInitialSchemas(self2) {
      var optsSchemas = self2._opts.schemas;
      if (!optsSchemas)
        return;
      if (Array.isArray(optsSchemas))
        self2.addSchema(optsSchemas);
      else
        for (var key in optsSchemas)
          self2.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats(self2) {
      for (var name in self2._opts.formats) {
        var format = self2._opts.formats[name];
        self2.addFormat(name, format);
      }
    }
    function addInitialKeywords(self2) {
      for (var name in self2._opts.keywords) {
        var keyword = self2._opts.keywords[name];
        self2.addKeyword(name, keyword);
      }
    }
    function checkUnique(self2, id) {
      if (self2._schemas[id] || self2._refs[id])
        throw new Error('schema with key or id "' + id + '" already exists');
    }
    function getMetaSchemaOptions(self2) {
      var metaOpts = util.copy(self2._opts);
      for (var i = 0; i < META_IGNORE_OPTIONS.length; i++)
        delete metaOpts[META_IGNORE_OPTIONS[i]];
      return metaOpts;
    }
    function setLogger(self2) {
      var logger = self2._opts.logger;
      if (logger === false) {
        self2.logger = { log: noop, warn: noop, error: noop };
      } else {
        if (logger === void 0)
          logger = console;
        if (!(typeof logger == "object" && logger.log && logger.warn && logger.error))
          throw new Error("logger must implement log, warn and error methods");
        self2.logger = logger;
      }
    }
    function noop() {
    }
  }
});

// ../../node_modules/globals/globals.json
var require_globals = __commonJS({
  "../../node_modules/globals/globals.json"(exports, module) {
    module.exports = {
      builtin: {
        AggregateError: false,
        Array: false,
        ArrayBuffer: false,
        Atomics: false,
        BigInt: false,
        BigInt64Array: false,
        BigUint64Array: false,
        Boolean: false,
        constructor: false,
        DataView: false,
        Date: false,
        decodeURI: false,
        decodeURIComponent: false,
        encodeURI: false,
        encodeURIComponent: false,
        Error: false,
        escape: false,
        eval: false,
        EvalError: false,
        FinalizationRegistry: false,
        Float32Array: false,
        Float64Array: false,
        Function: false,
        globalThis: false,
        hasOwnProperty: false,
        Infinity: false,
        Int16Array: false,
        Int32Array: false,
        Int8Array: false,
        isFinite: false,
        isNaN: false,
        isPrototypeOf: false,
        JSON: false,
        Map: false,
        Math: false,
        NaN: false,
        Number: false,
        Object: false,
        parseFloat: false,
        parseInt: false,
        Promise: false,
        propertyIsEnumerable: false,
        Proxy: false,
        RangeError: false,
        ReferenceError: false,
        Reflect: false,
        RegExp: false,
        Set: false,
        SharedArrayBuffer: false,
        String: false,
        Symbol: false,
        SyntaxError: false,
        toLocaleString: false,
        toString: false,
        TypeError: false,
        Uint16Array: false,
        Uint32Array: false,
        Uint8Array: false,
        Uint8ClampedArray: false,
        undefined: false,
        unescape: false,
        URIError: false,
        valueOf: false,
        WeakMap: false,
        WeakRef: false,
        WeakSet: false
      },
      es5: {
        Array: false,
        Boolean: false,
        constructor: false,
        Date: false,
        decodeURI: false,
        decodeURIComponent: false,
        encodeURI: false,
        encodeURIComponent: false,
        Error: false,
        escape: false,
        eval: false,
        EvalError: false,
        Function: false,
        hasOwnProperty: false,
        Infinity: false,
        isFinite: false,
        isNaN: false,
        isPrototypeOf: false,
        JSON: false,
        Math: false,
        NaN: false,
        Number: false,
        Object: false,
        parseFloat: false,
        parseInt: false,
        propertyIsEnumerable: false,
        RangeError: false,
        ReferenceError: false,
        RegExp: false,
        String: false,
        SyntaxError: false,
        toLocaleString: false,
        toString: false,
        TypeError: false,
        undefined: false,
        unescape: false,
        URIError: false,
        valueOf: false
      },
      es2015: {
        Array: false,
        ArrayBuffer: false,
        Boolean: false,
        constructor: false,
        DataView: false,
        Date: false,
        decodeURI: false,
        decodeURIComponent: false,
        encodeURI: false,
        encodeURIComponent: false,
        Error: false,
        escape: false,
        eval: false,
        EvalError: false,
        Float32Array: false,
        Float64Array: false,
        Function: false,
        hasOwnProperty: false,
        Infinity: false,
        Int16Array: false,
        Int32Array: false,
        Int8Array: false,
        isFinite: false,
        isNaN: false,
        isPrototypeOf: false,
        JSON: false,
        Map: false,
        Math: false,
        NaN: false,
        Number: false,
        Object: false,
        parseFloat: false,
        parseInt: false,
        Promise: false,
        propertyIsEnumerable: false,
        Proxy: false,
        RangeError: false,
        ReferenceError: false,
        Reflect: false,
        RegExp: false,
        Set: false,
        String: false,
        Symbol: false,
        SyntaxError: false,
        toLocaleString: false,
        toString: false,
        TypeError: false,
        Uint16Array: false,
        Uint32Array: false,
        Uint8Array: false,
        Uint8ClampedArray: false,
        undefined: false,
        unescape: false,
        URIError: false,
        valueOf: false,
        WeakMap: false,
        WeakSet: false
      },
      es2017: {
        Array: false,
        ArrayBuffer: false,
        Atomics: false,
        Boolean: false,
        constructor: false,
        DataView: false,
        Date: false,
        decodeURI: false,
        decodeURIComponent: false,
        encodeURI: false,
        encodeURIComponent: false,
        Error: false,
        escape: false,
        eval: false,
        EvalError: false,
        Float32Array: false,
        Float64Array: false,
        Function: false,
        hasOwnProperty: false,
        Infinity: false,
        Int16Array: false,
        Int32Array: false,
        Int8Array: false,
        isFinite: false,
        isNaN: false,
        isPrototypeOf: false,
        JSON: false,
        Map: false,
        Math: false,
        NaN: false,
        Number: false,
        Object: false,
        parseFloat: false,
        parseInt: false,
        Promise: false,
        propertyIsEnumerable: false,
        Proxy: false,
        RangeError: false,
        ReferenceError: false,
        Reflect: false,
        RegExp: false,
        Set: false,
        SharedArrayBuffer: false,
        String: false,
        Symbol: false,
        SyntaxError: false,
        toLocaleString: false,
        toString: false,
        TypeError: false,
        Uint16Array: false,
        Uint32Array: false,
        Uint8Array: false,
        Uint8ClampedArray: false,
        undefined: false,
        unescape: false,
        URIError: false,
        valueOf: false,
        WeakMap: false,
        WeakSet: false
      },
      es2020: {
        Array: false,
        ArrayBuffer: false,
        Atomics: false,
        BigInt: false,
        BigInt64Array: false,
        BigUint64Array: false,
        Boolean: false,
        constructor: false,
        DataView: false,
        Date: false,
        decodeURI: false,
        decodeURIComponent: false,
        encodeURI: false,
        encodeURIComponent: false,
        Error: false,
        escape: false,
        eval: false,
        EvalError: false,
        Float32Array: false,
        Float64Array: false,
        Function: false,
        globalThis: false,
        hasOwnProperty: false,
        Infinity: false,
        Int16Array: false,
        Int32Array: false,
        Int8Array: false,
        isFinite: false,
        isNaN: false,
        isPrototypeOf: false,
        JSON: false,
        Map: false,
        Math: false,
        NaN: false,
        Number: false,
        Object: false,
        parseFloat: false,
        parseInt: false,
        Promise: false,
        propertyIsEnumerable: false,
        Proxy: false,
        RangeError: false,
        ReferenceError: false,
        Reflect: false,
        RegExp: false,
        Set: false,
        SharedArrayBuffer: false,
        String: false,
        Symbol: false,
        SyntaxError: false,
        toLocaleString: false,
        toString: false,
        TypeError: false,
        Uint16Array: false,
        Uint32Array: false,
        Uint8Array: false,
        Uint8ClampedArray: false,
        undefined: false,
        unescape: false,
        URIError: false,
        valueOf: false,
        WeakMap: false,
        WeakSet: false
      },
      es2021: {
        AggregateError: false,
        Array: false,
        ArrayBuffer: false,
        Atomics: false,
        BigInt: false,
        BigInt64Array: false,
        BigUint64Array: false,
        Boolean: false,
        constructor: false,
        DataView: false,
        Date: false,
        decodeURI: false,
        decodeURIComponent: false,
        encodeURI: false,
        encodeURIComponent: false,
        Error: false,
        escape: false,
        eval: false,
        EvalError: false,
        FinalizationRegistry: false,
        Float32Array: false,
        Float64Array: false,
        Function: false,
        globalThis: false,
        hasOwnProperty: false,
        Infinity: false,
        Int16Array: false,
        Int32Array: false,
        Int8Array: false,
        isFinite: false,
        isNaN: false,
        isPrototypeOf: false,
        JSON: false,
        Map: false,
        Math: false,
        NaN: false,
        Number: false,
        Object: false,
        parseFloat: false,
        parseInt: false,
        Promise: false,
        propertyIsEnumerable: false,
        Proxy: false,
        RangeError: false,
        ReferenceError: false,
        Reflect: false,
        RegExp: false,
        Set: false,
        SharedArrayBuffer: false,
        String: false,
        Symbol: false,
        SyntaxError: false,
        toLocaleString: false,
        toString: false,
        TypeError: false,
        Uint16Array: false,
        Uint32Array: false,
        Uint8Array: false,
        Uint8ClampedArray: false,
        undefined: false,
        unescape: false,
        URIError: false,
        valueOf: false,
        WeakMap: false,
        WeakRef: false,
        WeakSet: false
      },
      browser: {
        AbortController: false,
        AbortSignal: false,
        addEventListener: false,
        alert: false,
        AnalyserNode: false,
        Animation: false,
        AnimationEffectReadOnly: false,
        AnimationEffectTiming: false,
        AnimationEffectTimingReadOnly: false,
        AnimationEvent: false,
        AnimationPlaybackEvent: false,
        AnimationTimeline: false,
        applicationCache: false,
        ApplicationCache: false,
        ApplicationCacheErrorEvent: false,
        atob: false,
        Attr: false,
        Audio: false,
        AudioBuffer: false,
        AudioBufferSourceNode: false,
        AudioContext: false,
        AudioDestinationNode: false,
        AudioListener: false,
        AudioNode: false,
        AudioParam: false,
        AudioProcessingEvent: false,
        AudioScheduledSourceNode: false,
        AudioWorkletGlobalScope: false,
        AudioWorkletNode: false,
        AudioWorkletProcessor: false,
        BarProp: false,
        BaseAudioContext: false,
        BatteryManager: false,
        BeforeUnloadEvent: false,
        BiquadFilterNode: false,
        Blob: false,
        BlobEvent: false,
        blur: false,
        BroadcastChannel: false,
        btoa: false,
        BudgetService: false,
        ByteLengthQueuingStrategy: false,
        Cache: false,
        caches: false,
        CacheStorage: false,
        cancelAnimationFrame: false,
        cancelIdleCallback: false,
        CanvasCaptureMediaStreamTrack: false,
        CanvasGradient: false,
        CanvasPattern: false,
        CanvasRenderingContext2D: false,
        ChannelMergerNode: false,
        ChannelSplitterNode: false,
        CharacterData: false,
        clearInterval: false,
        clearTimeout: false,
        clientInformation: false,
        ClipboardEvent: false,
        ClipboardItem: false,
        close: false,
        closed: false,
        CloseEvent: false,
        Comment: false,
        CompositionEvent: false,
        confirm: false,
        console: false,
        ConstantSourceNode: false,
        ConvolverNode: false,
        CountQueuingStrategy: false,
        createImageBitmap: false,
        Credential: false,
        CredentialsContainer: false,
        crypto: false,
        Crypto: false,
        CryptoKey: false,
        CSS: false,
        CSSConditionRule: false,
        CSSFontFaceRule: false,
        CSSGroupingRule: false,
        CSSImportRule: false,
        CSSKeyframeRule: false,
        CSSKeyframesRule: false,
        CSSMatrixComponent: false,
        CSSMediaRule: false,
        CSSNamespaceRule: false,
        CSSPageRule: false,
        CSSPerspective: false,
        CSSRotate: false,
        CSSRule: false,
        CSSRuleList: false,
        CSSScale: false,
        CSSSkew: false,
        CSSSkewX: false,
        CSSSkewY: false,
        CSSStyleDeclaration: false,
        CSSStyleRule: false,
        CSSStyleSheet: false,
        CSSSupportsRule: false,
        CSSTransformValue: false,
        CSSTranslate: false,
        CustomElementRegistry: false,
        customElements: false,
        CustomEvent: false,
        DataTransfer: false,
        DataTransferItem: false,
        DataTransferItemList: false,
        defaultstatus: false,
        defaultStatus: false,
        DelayNode: false,
        DeviceMotionEvent: false,
        DeviceOrientationEvent: false,
        devicePixelRatio: false,
        dispatchEvent: false,
        document: false,
        Document: false,
        DocumentFragment: false,
        DocumentType: false,
        DOMError: false,
        DOMException: false,
        DOMImplementation: false,
        DOMMatrix: false,
        DOMMatrixReadOnly: false,
        DOMParser: false,
        DOMPoint: false,
        DOMPointReadOnly: false,
        DOMQuad: false,
        DOMRect: false,
        DOMRectList: false,
        DOMRectReadOnly: false,
        DOMStringList: false,
        DOMStringMap: false,
        DOMTokenList: false,
        DragEvent: false,
        DynamicsCompressorNode: false,
        Element: false,
        ErrorEvent: false,
        event: false,
        Event: false,
        EventSource: false,
        EventTarget: false,
        external: false,
        fetch: false,
        File: false,
        FileList: false,
        FileReader: false,
        find: false,
        focus: false,
        FocusEvent: false,
        FontFace: false,
        FontFaceSetLoadEvent: false,
        FormData: false,
        FormDataEvent: false,
        frameElement: false,
        frames: false,
        GainNode: false,
        Gamepad: false,
        GamepadButton: false,
        GamepadEvent: false,
        getComputedStyle: false,
        getSelection: false,
        HashChangeEvent: false,
        Headers: false,
        history: false,
        History: false,
        HTMLAllCollection: false,
        HTMLAnchorElement: false,
        HTMLAreaElement: false,
        HTMLAudioElement: false,
        HTMLBaseElement: false,
        HTMLBodyElement: false,
        HTMLBRElement: false,
        HTMLButtonElement: false,
        HTMLCanvasElement: false,
        HTMLCollection: false,
        HTMLContentElement: false,
        HTMLDataElement: false,
        HTMLDataListElement: false,
        HTMLDetailsElement: false,
        HTMLDialogElement: false,
        HTMLDirectoryElement: false,
        HTMLDivElement: false,
        HTMLDListElement: false,
        HTMLDocument: false,
        HTMLElement: false,
        HTMLEmbedElement: false,
        HTMLFieldSetElement: false,
        HTMLFontElement: false,
        HTMLFormControlsCollection: false,
        HTMLFormElement: false,
        HTMLFrameElement: false,
        HTMLFrameSetElement: false,
        HTMLHeadElement: false,
        HTMLHeadingElement: false,
        HTMLHRElement: false,
        HTMLHtmlElement: false,
        HTMLIFrameElement: false,
        HTMLImageElement: false,
        HTMLInputElement: false,
        HTMLLabelElement: false,
        HTMLLegendElement: false,
        HTMLLIElement: false,
        HTMLLinkElement: false,
        HTMLMapElement: false,
        HTMLMarqueeElement: false,
        HTMLMediaElement: false,
        HTMLMenuElement: false,
        HTMLMetaElement: false,
        HTMLMeterElement: false,
        HTMLModElement: false,
        HTMLObjectElement: false,
        HTMLOListElement: false,
        HTMLOptGroupElement: false,
        HTMLOptionElement: false,
        HTMLOptionsCollection: false,
        HTMLOutputElement: false,
        HTMLParagraphElement: false,
        HTMLParamElement: false,
        HTMLPictureElement: false,
        HTMLPreElement: false,
        HTMLProgressElement: false,
        HTMLQuoteElement: false,
        HTMLScriptElement: false,
        HTMLSelectElement: false,
        HTMLShadowElement: false,
        HTMLSlotElement: false,
        HTMLSourceElement: false,
        HTMLSpanElement: false,
        HTMLStyleElement: false,
        HTMLTableCaptionElement: false,
        HTMLTableCellElement: false,
        HTMLTableColElement: false,
        HTMLTableElement: false,
        HTMLTableRowElement: false,
        HTMLTableSectionElement: false,
        HTMLTemplateElement: false,
        HTMLTextAreaElement: false,
        HTMLTimeElement: false,
        HTMLTitleElement: false,
        HTMLTrackElement: false,
        HTMLUListElement: false,
        HTMLUnknownElement: false,
        HTMLVideoElement: false,
        IDBCursor: false,
        IDBCursorWithValue: false,
        IDBDatabase: false,
        IDBFactory: false,
        IDBIndex: false,
        IDBKeyRange: false,
        IDBObjectStore: false,
        IDBOpenDBRequest: false,
        IDBRequest: false,
        IDBTransaction: false,
        IDBVersionChangeEvent: false,
        IdleDeadline: false,
        IIRFilterNode: false,
        Image: false,
        ImageBitmap: false,
        ImageBitmapRenderingContext: false,
        ImageCapture: false,
        ImageData: false,
        indexedDB: false,
        innerHeight: false,
        innerWidth: false,
        InputEvent: false,
        IntersectionObserver: false,
        IntersectionObserverEntry: false,
        Intl: false,
        isSecureContext: false,
        KeyboardEvent: false,
        KeyframeEffect: false,
        KeyframeEffectReadOnly: false,
        length: false,
        localStorage: false,
        location: true,
        Location: false,
        locationbar: false,
        matchMedia: false,
        MediaDeviceInfo: false,
        MediaDevices: false,
        MediaElementAudioSourceNode: false,
        MediaEncryptedEvent: false,
        MediaError: false,
        MediaKeyMessageEvent: false,
        MediaKeySession: false,
        MediaKeyStatusMap: false,
        MediaKeySystemAccess: false,
        MediaList: false,
        MediaMetadata: false,
        MediaQueryList: false,
        MediaQueryListEvent: false,
        MediaRecorder: false,
        MediaSettingsRange: false,
        MediaSource: false,
        MediaStream: false,
        MediaStreamAudioDestinationNode: false,
        MediaStreamAudioSourceNode: false,
        MediaStreamEvent: false,
        MediaStreamTrack: false,
        MediaStreamTrackEvent: false,
        menubar: false,
        MessageChannel: false,
        MessageEvent: false,
        MessagePort: false,
        MIDIAccess: false,
        MIDIConnectionEvent: false,
        MIDIInput: false,
        MIDIInputMap: false,
        MIDIMessageEvent: false,
        MIDIOutput: false,
        MIDIOutputMap: false,
        MIDIPort: false,
        MimeType: false,
        MimeTypeArray: false,
        MouseEvent: false,
        moveBy: false,
        moveTo: false,
        MutationEvent: false,
        MutationObserver: false,
        MutationRecord: false,
        name: false,
        NamedNodeMap: false,
        NavigationPreloadManager: false,
        navigator: false,
        Navigator: false,
        NavigatorUAData: false,
        NetworkInformation: false,
        Node: false,
        NodeFilter: false,
        NodeIterator: false,
        NodeList: false,
        Notification: false,
        OfflineAudioCompletionEvent: false,
        OfflineAudioContext: false,
        offscreenBuffering: false,
        OffscreenCanvas: true,
        OffscreenCanvasRenderingContext2D: false,
        onabort: true,
        onafterprint: true,
        onanimationend: true,
        onanimationiteration: true,
        onanimationstart: true,
        onappinstalled: true,
        onauxclick: true,
        onbeforeinstallprompt: true,
        onbeforeprint: true,
        onbeforeunload: true,
        onblur: true,
        oncancel: true,
        oncanplay: true,
        oncanplaythrough: true,
        onchange: true,
        onclick: true,
        onclose: true,
        oncontextmenu: true,
        oncuechange: true,
        ondblclick: true,
        ondevicemotion: true,
        ondeviceorientation: true,
        ondeviceorientationabsolute: true,
        ondrag: true,
        ondragend: true,
        ondragenter: true,
        ondragleave: true,
        ondragover: true,
        ondragstart: true,
        ondrop: true,
        ondurationchange: true,
        onemptied: true,
        onended: true,
        onerror: true,
        onfocus: true,
        ongotpointercapture: true,
        onhashchange: true,
        oninput: true,
        oninvalid: true,
        onkeydown: true,
        onkeypress: true,
        onkeyup: true,
        onlanguagechange: true,
        onload: true,
        onloadeddata: true,
        onloadedmetadata: true,
        onloadstart: true,
        onlostpointercapture: true,
        onmessage: true,
        onmessageerror: true,
        onmousedown: true,
        onmouseenter: true,
        onmouseleave: true,
        onmousemove: true,
        onmouseout: true,
        onmouseover: true,
        onmouseup: true,
        onmousewheel: true,
        onoffline: true,
        ononline: true,
        onpagehide: true,
        onpageshow: true,
        onpause: true,
        onplay: true,
        onplaying: true,
        onpointercancel: true,
        onpointerdown: true,
        onpointerenter: true,
        onpointerleave: true,
        onpointermove: true,
        onpointerout: true,
        onpointerover: true,
        onpointerup: true,
        onpopstate: true,
        onprogress: true,
        onratechange: true,
        onrejectionhandled: true,
        onreset: true,
        onresize: true,
        onscroll: true,
        onsearch: true,
        onseeked: true,
        onseeking: true,
        onselect: true,
        onstalled: true,
        onstorage: true,
        onsubmit: true,
        onsuspend: true,
        ontimeupdate: true,
        ontoggle: true,
        ontransitionend: true,
        onunhandledrejection: true,
        onunload: true,
        onvolumechange: true,
        onwaiting: true,
        onwheel: true,
        open: false,
        openDatabase: false,
        opener: false,
        Option: false,
        origin: false,
        OscillatorNode: false,
        outerHeight: false,
        outerWidth: false,
        OverconstrainedError: false,
        PageTransitionEvent: false,
        pageXOffset: false,
        pageYOffset: false,
        PannerNode: false,
        parent: false,
        Path2D: false,
        PaymentAddress: false,
        PaymentRequest: false,
        PaymentRequestUpdateEvent: false,
        PaymentResponse: false,
        performance: false,
        Performance: false,
        PerformanceEntry: false,
        PerformanceLongTaskTiming: false,
        PerformanceMark: false,
        PerformanceMeasure: false,
        PerformanceNavigation: false,
        PerformanceNavigationTiming: false,
        PerformanceObserver: false,
        PerformanceObserverEntryList: false,
        PerformancePaintTiming: false,
        PerformanceResourceTiming: false,
        PerformanceTiming: false,
        PeriodicWave: false,
        Permissions: false,
        PermissionStatus: false,
        personalbar: false,
        PhotoCapabilities: false,
        Plugin: false,
        PluginArray: false,
        PointerEvent: false,
        PopStateEvent: false,
        postMessage: false,
        Presentation: false,
        PresentationAvailability: false,
        PresentationConnection: false,
        PresentationConnectionAvailableEvent: false,
        PresentationConnectionCloseEvent: false,
        PresentationConnectionList: false,
        PresentationReceiver: false,
        PresentationRequest: false,
        print: false,
        ProcessingInstruction: false,
        ProgressEvent: false,
        PromiseRejectionEvent: false,
        prompt: false,
        PushManager: false,
        PushSubscription: false,
        PushSubscriptionOptions: false,
        queueMicrotask: false,
        RadioNodeList: false,
        Range: false,
        ReadableStream: false,
        registerProcessor: false,
        RemotePlayback: false,
        removeEventListener: false,
        reportError: false,
        Request: false,
        requestAnimationFrame: false,
        requestIdleCallback: false,
        resizeBy: false,
        ResizeObserver: false,
        ResizeObserverEntry: false,
        resizeTo: false,
        Response: false,
        RTCCertificate: false,
        RTCDataChannel: false,
        RTCDataChannelEvent: false,
        RTCDtlsTransport: false,
        RTCIceCandidate: false,
        RTCIceGatherer: false,
        RTCIceTransport: false,
        RTCPeerConnection: false,
        RTCPeerConnectionIceEvent: false,
        RTCRtpContributingSource: false,
        RTCRtpReceiver: false,
        RTCRtpSender: false,
        RTCSctpTransport: false,
        RTCSessionDescription: false,
        RTCStatsReport: false,
        RTCTrackEvent: false,
        screen: false,
        Screen: false,
        screenLeft: false,
        ScreenOrientation: false,
        screenTop: false,
        screenX: false,
        screenY: false,
        ScriptProcessorNode: false,
        scroll: false,
        scrollbars: false,
        scrollBy: false,
        scrollTo: false,
        scrollX: false,
        scrollY: false,
        SecurityPolicyViolationEvent: false,
        Selection: false,
        self: false,
        ServiceWorker: false,
        ServiceWorkerContainer: false,
        ServiceWorkerRegistration: false,
        sessionStorage: false,
        setInterval: false,
        setTimeout: false,
        ShadowRoot: false,
        SharedWorker: false,
        SourceBuffer: false,
        SourceBufferList: false,
        speechSynthesis: false,
        SpeechSynthesisEvent: false,
        SpeechSynthesisUtterance: false,
        StaticRange: false,
        status: false,
        statusbar: false,
        StereoPannerNode: false,
        stop: false,
        Storage: false,
        StorageEvent: false,
        StorageManager: false,
        structuredClone: false,
        styleMedia: false,
        StyleSheet: false,
        StyleSheetList: false,
        SubmitEvent: false,
        SubtleCrypto: false,
        SVGAElement: false,
        SVGAngle: false,
        SVGAnimatedAngle: false,
        SVGAnimatedBoolean: false,
        SVGAnimatedEnumeration: false,
        SVGAnimatedInteger: false,
        SVGAnimatedLength: false,
        SVGAnimatedLengthList: false,
        SVGAnimatedNumber: false,
        SVGAnimatedNumberList: false,
        SVGAnimatedPreserveAspectRatio: false,
        SVGAnimatedRect: false,
        SVGAnimatedString: false,
        SVGAnimatedTransformList: false,
        SVGAnimateElement: false,
        SVGAnimateMotionElement: false,
        SVGAnimateTransformElement: false,
        SVGAnimationElement: false,
        SVGCircleElement: false,
        SVGClipPathElement: false,
        SVGComponentTransferFunctionElement: false,
        SVGDefsElement: false,
        SVGDescElement: false,
        SVGDiscardElement: false,
        SVGElement: false,
        SVGEllipseElement: false,
        SVGFEBlendElement: false,
        SVGFEColorMatrixElement: false,
        SVGFEComponentTransferElement: false,
        SVGFECompositeElement: false,
        SVGFEConvolveMatrixElement: false,
        SVGFEDiffuseLightingElement: false,
        SVGFEDisplacementMapElement: false,
        SVGFEDistantLightElement: false,
        SVGFEDropShadowElement: false,
        SVGFEFloodElement: false,
        SVGFEFuncAElement: false,
        SVGFEFuncBElement: false,
        SVGFEFuncGElement: false,
        SVGFEFuncRElement: false,
        SVGFEGaussianBlurElement: false,
        SVGFEImageElement: false,
        SVGFEMergeElement: false,
        SVGFEMergeNodeElement: false,
        SVGFEMorphologyElement: false,
        SVGFEOffsetElement: false,
        SVGFEPointLightElement: false,
        SVGFESpecularLightingElement: false,
        SVGFESpotLightElement: false,
        SVGFETileElement: false,
        SVGFETurbulenceElement: false,
        SVGFilterElement: false,
        SVGForeignObjectElement: false,
        SVGGElement: false,
        SVGGeometryElement: false,
        SVGGradientElement: false,
        SVGGraphicsElement: false,
        SVGImageElement: false,
        SVGLength: false,
        SVGLengthList: false,
        SVGLinearGradientElement: false,
        SVGLineElement: false,
        SVGMarkerElement: false,
        SVGMaskElement: false,
        SVGMatrix: false,
        SVGMetadataElement: false,
        SVGMPathElement: false,
        SVGNumber: false,
        SVGNumberList: false,
        SVGPathElement: false,
        SVGPatternElement: false,
        SVGPoint: false,
        SVGPointList: false,
        SVGPolygonElement: false,
        SVGPolylineElement: false,
        SVGPreserveAspectRatio: false,
        SVGRadialGradientElement: false,
        SVGRect: false,
        SVGRectElement: false,
        SVGScriptElement: false,
        SVGSetElement: false,
        SVGStopElement: false,
        SVGStringList: false,
        SVGStyleElement: false,
        SVGSVGElement: false,
        SVGSwitchElement: false,
        SVGSymbolElement: false,
        SVGTextContentElement: false,
        SVGTextElement: false,
        SVGTextPathElement: false,
        SVGTextPositioningElement: false,
        SVGTitleElement: false,
        SVGTransform: false,
        SVGTransformList: false,
        SVGTSpanElement: false,
        SVGUnitTypes: false,
        SVGUseElement: false,
        SVGViewElement: false,
        TaskAttributionTiming: false,
        Text: false,
        TextDecoder: false,
        TextEncoder: false,
        TextEvent: false,
        TextMetrics: false,
        TextTrack: false,
        TextTrackCue: false,
        TextTrackCueList: false,
        TextTrackList: false,
        TimeRanges: false,
        toolbar: false,
        top: false,
        Touch: false,
        TouchEvent: false,
        TouchList: false,
        TrackEvent: false,
        TransformStream: false,
        TransitionEvent: false,
        TreeWalker: false,
        UIEvent: false,
        URL: false,
        URLSearchParams: false,
        ValidityState: false,
        visualViewport: false,
        VisualViewport: false,
        VTTCue: false,
        WaveShaperNode: false,
        WebAssembly: false,
        WebGL2RenderingContext: false,
        WebGLActiveInfo: false,
        WebGLBuffer: false,
        WebGLContextEvent: false,
        WebGLFramebuffer: false,
        WebGLProgram: false,
        WebGLQuery: false,
        WebGLRenderbuffer: false,
        WebGLRenderingContext: false,
        WebGLSampler: false,
        WebGLShader: false,
        WebGLShaderPrecisionFormat: false,
        WebGLSync: false,
        WebGLTexture: false,
        WebGLTransformFeedback: false,
        WebGLUniformLocation: false,
        WebGLVertexArrayObject: false,
        WebSocket: false,
        WheelEvent: false,
        window: false,
        Window: false,
        Worker: false,
        WritableStream: false,
        XMLDocument: false,
        XMLHttpRequest: false,
        XMLHttpRequestEventTarget: false,
        XMLHttpRequestUpload: false,
        XMLSerializer: false,
        XPathEvaluator: false,
        XPathExpression: false,
        XPathResult: false,
        XSLTProcessor: false
      },
      worker: {
        addEventListener: false,
        applicationCache: false,
        atob: false,
        Blob: false,
        BroadcastChannel: false,
        btoa: false,
        Cache: false,
        caches: false,
        clearInterval: false,
        clearTimeout: false,
        close: true,
        console: false,
        CustomEvent: false,
        ErrorEvent: false,
        Event: false,
        fetch: false,
        FileReaderSync: false,
        FormData: false,
        Headers: false,
        IDBCursor: false,
        IDBCursorWithValue: false,
        IDBDatabase: false,
        IDBFactory: false,
        IDBIndex: false,
        IDBKeyRange: false,
        IDBObjectStore: false,
        IDBOpenDBRequest: false,
        IDBRequest: false,
        IDBTransaction: false,
        IDBVersionChangeEvent: false,
        ImageData: false,
        importScripts: true,
        indexedDB: false,
        location: false,
        MessageChannel: false,
        MessageEvent: false,
        MessagePort: false,
        name: false,
        navigator: false,
        Notification: false,
        onclose: true,
        onconnect: true,
        onerror: true,
        onlanguagechange: true,
        onmessage: true,
        onoffline: true,
        ononline: true,
        onrejectionhandled: true,
        onunhandledrejection: true,
        performance: false,
        Performance: false,
        PerformanceEntry: false,
        PerformanceMark: false,
        PerformanceMeasure: false,
        PerformanceNavigation: false,
        PerformanceResourceTiming: false,
        PerformanceTiming: false,
        postMessage: true,
        Promise: false,
        queueMicrotask: false,
        removeEventListener: false,
        reportError: false,
        Request: false,
        Response: false,
        self: true,
        ServiceWorkerRegistration: false,
        setInterval: false,
        setTimeout: false,
        TextDecoder: false,
        TextEncoder: false,
        URL: false,
        URLSearchParams: false,
        WebSocket: false,
        Worker: false,
        WorkerGlobalScope: false,
        XMLHttpRequest: false
      },
      node: {
        __dirname: false,
        __filename: false,
        AbortController: false,
        AbortSignal: false,
        atob: false,
        btoa: false,
        Buffer: false,
        clearImmediate: false,
        clearInterval: false,
        clearTimeout: false,
        console: false,
        DOMException: false,
        Event: false,
        EventTarget: false,
        exports: true,
        fetch: false,
        FormData: false,
        global: false,
        Headers: false,
        Intl: false,
        MessageChannel: false,
        MessageEvent: false,
        MessagePort: false,
        module: false,
        performance: false,
        process: false,
        queueMicrotask: false,
        Request: false,
        require: false,
        Response: false,
        setImmediate: false,
        setInterval: false,
        setTimeout: false,
        structuredClone: false,
        TextDecoder: false,
        TextEncoder: false,
        URL: false,
        URLSearchParams: false
      },
      nodeBuiltin: {
        AbortController: false,
        AbortSignal: false,
        atob: false,
        btoa: false,
        Buffer: false,
        clearImmediate: false,
        clearInterval: false,
        clearTimeout: false,
        console: false,
        DOMException: false,
        Event: false,
        EventTarget: false,
        fetch: false,
        FormData: false,
        global: false,
        Headers: false,
        Intl: false,
        MessageChannel: false,
        MessageEvent: false,
        MessagePort: false,
        performance: false,
        process: false,
        queueMicrotask: false,
        Request: false,
        Response: false,
        setImmediate: false,
        setInterval: false,
        setTimeout: false,
        structuredClone: false,
        TextDecoder: false,
        TextEncoder: false,
        URL: false,
        URLSearchParams: false
      },
      commonjs: {
        exports: true,
        global: false,
        module: false,
        require: false
      },
      amd: {
        define: false,
        require: false
      },
      mocha: {
        after: false,
        afterEach: false,
        before: false,
        beforeEach: false,
        context: false,
        describe: false,
        it: false,
        mocha: false,
        run: false,
        setup: false,
        specify: false,
        suite: false,
        suiteSetup: false,
        suiteTeardown: false,
        teardown: false,
        test: false,
        xcontext: false,
        xdescribe: false,
        xit: false,
        xspecify: false
      },
      jasmine: {
        afterAll: false,
        afterEach: false,
        beforeAll: false,
        beforeEach: false,
        describe: false,
        expect: false,
        expectAsync: false,
        fail: false,
        fdescribe: false,
        fit: false,
        it: false,
        jasmine: false,
        pending: false,
        runs: false,
        spyOn: false,
        spyOnAllFunctions: false,
        spyOnProperty: false,
        waits: false,
        waitsFor: false,
        xdescribe: false,
        xit: false
      },
      jest: {
        afterAll: false,
        afterEach: false,
        beforeAll: false,
        beforeEach: false,
        describe: false,
        expect: false,
        fdescribe: false,
        fit: false,
        it: false,
        jest: false,
        pit: false,
        require: false,
        test: false,
        xdescribe: false,
        xit: false,
        xtest: false
      },
      qunit: {
        asyncTest: false,
        deepEqual: false,
        equal: false,
        expect: false,
        module: false,
        notDeepEqual: false,
        notEqual: false,
        notOk: false,
        notPropEqual: false,
        notStrictEqual: false,
        ok: false,
        propEqual: false,
        QUnit: false,
        raises: false,
        start: false,
        stop: false,
        strictEqual: false,
        test: false,
        throws: false
      },
      phantomjs: {
        console: true,
        exports: true,
        phantom: true,
        require: true,
        WebPage: true
      },
      couch: {
        emit: false,
        exports: false,
        getRow: false,
        log: false,
        module: false,
        provides: false,
        require: false,
        respond: false,
        send: false,
        start: false,
        sum: false
      },
      rhino: {
        defineClass: false,
        deserialize: false,
        gc: false,
        help: false,
        importClass: false,
        importPackage: false,
        java: false,
        load: false,
        loadClass: false,
        Packages: false,
        print: false,
        quit: false,
        readFile: false,
        readUrl: false,
        runCommand: false,
        seal: false,
        serialize: false,
        spawn: false,
        sync: false,
        toint32: false,
        version: false
      },
      nashorn: {
        __DIR__: false,
        __FILE__: false,
        __LINE__: false,
        com: false,
        edu: false,
        exit: false,
        java: false,
        Java: false,
        javafx: false,
        JavaImporter: false,
        javax: false,
        JSAdapter: false,
        load: false,
        loadWithNewGlobal: false,
        org: false,
        Packages: false,
        print: false,
        quit: false
      },
      wsh: {
        ActiveXObject: false,
        CollectGarbage: false,
        Debug: false,
        Enumerator: false,
        GetObject: false,
        RuntimeObject: false,
        ScriptEngine: false,
        ScriptEngineBuildVersion: false,
        ScriptEngineMajorVersion: false,
        ScriptEngineMinorVersion: false,
        VBArray: false,
        WScript: false,
        WSH: false
      },
      jquery: {
        $: false,
        jQuery: false
      },
      yui: {
        YAHOO: false,
        YAHOO_config: false,
        YUI: false,
        YUI_config: false
      },
      shelljs: {
        cat: false,
        cd: false,
        chmod: false,
        config: false,
        cp: false,
        dirs: false,
        echo: false,
        env: false,
        error: false,
        exec: false,
        exit: false,
        find: false,
        grep: false,
        ln: false,
        ls: false,
        mkdir: false,
        mv: false,
        popd: false,
        pushd: false,
        pwd: false,
        rm: false,
        sed: false,
        set: false,
        target: false,
        tempdir: false,
        test: false,
        touch: false,
        which: false
      },
      prototypejs: {
        $: false,
        $$: false,
        $A: false,
        $break: false,
        $continue: false,
        $F: false,
        $H: false,
        $R: false,
        $w: false,
        Abstract: false,
        Ajax: false,
        Autocompleter: false,
        Builder: false,
        Class: false,
        Control: false,
        Draggable: false,
        Draggables: false,
        Droppables: false,
        Effect: false,
        Element: false,
        Enumerable: false,
        Event: false,
        Field: false,
        Form: false,
        Hash: false,
        Insertion: false,
        ObjectRange: false,
        PeriodicalExecuter: false,
        Position: false,
        Prototype: false,
        Scriptaculous: false,
        Selector: false,
        Sortable: false,
        SortableObserver: false,
        Sound: false,
        Template: false,
        Toggle: false,
        Try: false
      },
      meteor: {
        $: false,
        Accounts: false,
        AccountsClient: false,
        AccountsCommon: false,
        AccountsServer: false,
        App: false,
        Assets: false,
        Blaze: false,
        check: false,
        Cordova: false,
        DDP: false,
        DDPRateLimiter: false,
        DDPServer: false,
        Deps: false,
        EJSON: false,
        Email: false,
        HTTP: false,
        Log: false,
        Match: false,
        Meteor: false,
        Mongo: false,
        MongoInternals: false,
        Npm: false,
        Package: false,
        Plugin: false,
        process: false,
        Random: false,
        ReactiveDict: false,
        ReactiveVar: false,
        Router: false,
        ServiceConfiguration: false,
        Session: false,
        share: false,
        Spacebars: false,
        Template: false,
        Tinytest: false,
        Tracker: false,
        UI: false,
        Utils: false,
        WebApp: false,
        WebAppInternals: false
      },
      mongo: {
        _isWindows: false,
        _rand: false,
        BulkWriteResult: false,
        cat: false,
        cd: false,
        connect: false,
        db: false,
        getHostName: false,
        getMemInfo: false,
        hostname: false,
        ISODate: false,
        listFiles: false,
        load: false,
        ls: false,
        md5sumFile: false,
        mkdir: false,
        Mongo: false,
        NumberInt: false,
        NumberLong: false,
        ObjectId: false,
        PlanCache: false,
        print: false,
        printjson: false,
        pwd: false,
        quit: false,
        removeFile: false,
        rs: false,
        sh: false,
        UUID: false,
        version: false,
        WriteResult: false
      },
      applescript: {
        $: false,
        Application: false,
        Automation: false,
        console: false,
        delay: false,
        Library: false,
        ObjC: false,
        ObjectSpecifier: false,
        Path: false,
        Progress: false,
        Ref: false
      },
      serviceworker: {
        addEventListener: false,
        applicationCache: false,
        atob: false,
        Blob: false,
        BroadcastChannel: false,
        btoa: false,
        Cache: false,
        caches: false,
        CacheStorage: false,
        clearInterval: false,
        clearTimeout: false,
        Client: false,
        clients: false,
        Clients: false,
        close: true,
        console: false,
        CustomEvent: false,
        ErrorEvent: false,
        Event: false,
        ExtendableEvent: false,
        ExtendableMessageEvent: false,
        fetch: false,
        FetchEvent: false,
        FileReaderSync: false,
        FormData: false,
        Headers: false,
        IDBCursor: false,
        IDBCursorWithValue: false,
        IDBDatabase: false,
        IDBFactory: false,
        IDBIndex: false,
        IDBKeyRange: false,
        IDBObjectStore: false,
        IDBOpenDBRequest: false,
        IDBRequest: false,
        IDBTransaction: false,
        IDBVersionChangeEvent: false,
        ImageData: false,
        importScripts: false,
        indexedDB: false,
        location: false,
        MessageChannel: false,
        MessageEvent: false,
        MessagePort: false,
        name: false,
        navigator: false,
        Notification: false,
        onclose: true,
        onconnect: true,
        onerror: true,
        onfetch: true,
        oninstall: true,
        onlanguagechange: true,
        onmessage: true,
        onmessageerror: true,
        onnotificationclick: true,
        onnotificationclose: true,
        onoffline: true,
        ononline: true,
        onpush: true,
        onpushsubscriptionchange: true,
        onrejectionhandled: true,
        onsync: true,
        onunhandledrejection: true,
        performance: false,
        Performance: false,
        PerformanceEntry: false,
        PerformanceMark: false,
        PerformanceMeasure: false,
        PerformanceNavigation: false,
        PerformanceResourceTiming: false,
        PerformanceTiming: false,
        postMessage: true,
        Promise: false,
        queueMicrotask: false,
        registration: false,
        removeEventListener: false,
        Request: false,
        Response: false,
        self: false,
        ServiceWorker: false,
        ServiceWorkerContainer: false,
        ServiceWorkerGlobalScope: false,
        ServiceWorkerMessageEvent: false,
        ServiceWorkerRegistration: false,
        setInterval: false,
        setTimeout: false,
        skipWaiting: false,
        TextDecoder: false,
        TextEncoder: false,
        URL: false,
        URLSearchParams: false,
        WebSocket: false,
        WindowClient: false,
        Worker: false,
        WorkerGlobalScope: false,
        XMLHttpRequest: false
      },
      atomtest: {
        advanceClock: false,
        atom: false,
        fakeClearInterval: false,
        fakeClearTimeout: false,
        fakeSetInterval: false,
        fakeSetTimeout: false,
        resetTimeouts: false,
        waitsForPromise: false
      },
      embertest: {
        andThen: false,
        click: false,
        currentPath: false,
        currentRouteName: false,
        currentURL: false,
        fillIn: false,
        find: false,
        findAll: false,
        findWithAssert: false,
        keyEvent: false,
        pauseTest: false,
        resumeTest: false,
        triggerEvent: false,
        visit: false,
        wait: false
      },
      protractor: {
        $: false,
        $$: false,
        browser: false,
        by: false,
        By: false,
        DartObject: false,
        element: false,
        protractor: false
      },
      "shared-node-browser": {
        AbortController: false,
        AbortSignal: false,
        atob: false,
        btoa: false,
        clearInterval: false,
        clearTimeout: false,
        console: false,
        DOMException: false,
        Event: false,
        EventTarget: false,
        fetch: false,
        FormData: false,
        Headers: false,
        Intl: false,
        MessageChannel: false,
        MessageEvent: false,
        MessagePort: false,
        performance: false,
        queueMicrotask: false,
        Request: false,
        Response: false,
        setInterval: false,
        setTimeout: false,
        structuredClone: false,
        TextDecoder: false,
        TextEncoder: false,
        URL: false,
        URLSearchParams: false
      },
      webextensions: {
        browser: false,
        chrome: false,
        opr: false
      },
      greasemonkey: {
        cloneInto: false,
        createObjectIn: false,
        exportFunction: false,
        GM: false,
        GM_addElement: false,
        GM_addStyle: false,
        GM_addValueChangeListener: false,
        GM_deleteValue: false,
        GM_download: false,
        GM_getResourceText: false,
        GM_getResourceURL: false,
        GM_getTab: false,
        GM_getTabs: false,
        GM_getValue: false,
        GM_info: false,
        GM_listValues: false,
        GM_log: false,
        GM_notification: false,
        GM_openInTab: false,
        GM_registerMenuCommand: false,
        GM_removeValueChangeListener: false,
        GM_saveTab: false,
        GM_setClipboard: false,
        GM_setValue: false,
        GM_unregisterMenuCommand: false,
        GM_xmlhttpRequest: false,
        unsafeWindow: false
      },
      devtools: {
        $: false,
        $_: false,
        $$: false,
        $0: false,
        $1: false,
        $2: false,
        $3: false,
        $4: false,
        $x: false,
        chrome: false,
        clear: false,
        copy: false,
        debug: false,
        dir: false,
        dirxml: false,
        getEventListeners: false,
        inspect: false,
        keys: false,
        monitor: false,
        monitorEvents: false,
        profile: false,
        profileEnd: false,
        queryObjects: false,
        table: false,
        undebug: false,
        unmonitor: false,
        unmonitorEvents: false,
        values: false
      }
    };
  }
});

// ../../node_modules/globals/index.js
var require_globals2 = __commonJS({
  "../../node_modules/globals/index.js"(exports, module) {
    "use strict";
    module.exports = require_globals();
  }
});

// ../../node_modules/@eslint/eslintrc/dist/eslintrc-universal.cjs
var require_eslintrc_universal = __commonJS({
  "../../node_modules/@eslint/eslintrc/dist/eslintrc-universal.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util = require_util();
    var path = require_path_browserify();
    var Ajv = require_ajv();
    var globals = require_globals2();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var util__default = /* @__PURE__ */ _interopDefaultLegacy(util);
    var path__default = /* @__PURE__ */ _interopDefaultLegacy(path);
    var Ajv__default = /* @__PURE__ */ _interopDefaultLegacy(Ajv);
    var globals__default = /* @__PURE__ */ _interopDefaultLegacy(globals);
    var RULE_SEVERITY_STRINGS = ["off", "warn", "error"];
    var RULE_SEVERITY = RULE_SEVERITY_STRINGS.reduce((map, value, index) => {
      map[value] = index;
      return map;
    }, {});
    var VALID_SEVERITIES = [0, 1, 2, "off", "warn", "error"];
    function getRuleSeverity(ruleConfig) {
      const severityValue = Array.isArray(ruleConfig) ? ruleConfig[0] : ruleConfig;
      if (severityValue === 0 || severityValue === 1 || severityValue === 2) {
        return severityValue;
      }
      if (typeof severityValue === "string") {
        return RULE_SEVERITY[severityValue.toLowerCase()] || 0;
      }
      return 0;
    }
    function normalizeToStrings(config) {
      if (config.rules) {
        Object.keys(config.rules).forEach((ruleId) => {
          const ruleConfig = config.rules[ruleId];
          if (typeof ruleConfig === "number") {
            config.rules[ruleId] = RULE_SEVERITY_STRINGS[ruleConfig] || RULE_SEVERITY_STRINGS[0];
          } else if (Array.isArray(ruleConfig) && typeof ruleConfig[0] === "number") {
            ruleConfig[0] = RULE_SEVERITY_STRINGS[ruleConfig[0]] || RULE_SEVERITY_STRINGS[0];
          }
        });
      }
    }
    function isErrorSeverity(ruleConfig) {
      return getRuleSeverity(ruleConfig) === 2;
    }
    function isValidSeverity(ruleConfig) {
      let severity = Array.isArray(ruleConfig) ? ruleConfig[0] : ruleConfig;
      if (typeof severity === "string") {
        severity = severity.toLowerCase();
      }
      return VALID_SEVERITIES.indexOf(severity) !== -1;
    }
    function isEverySeverityValid(config) {
      return Object.keys(config).every((ruleId) => isValidSeverity(config[ruleId]));
    }
    function normalizeConfigGlobal(configuredValue) {
      switch (configuredValue) {
        case "off":
          return "off";
        case true:
        case "true":
        case "writeable":
        case "writable":
          return "writable";
        case null:
        case false:
        case "false":
        case "readable":
        case "readonly":
          return "readonly";
        default:
          throw new Error(`'${configuredValue}' is not a valid configuration for a global (use 'readonly', 'writable', or 'off')`);
      }
    }
    var ConfigOps = {
      __proto__: null,
      getRuleSeverity,
      normalizeToStrings,
      isErrorSeverity,
      isValidSeverity,
      isEverySeverityValid,
      normalizeConfigGlobal
    };
    var deprecationWarningMessages = {
      ESLINT_LEGACY_ECMAFEATURES: "The 'ecmaFeatures' config file property is deprecated and has no effect.",
      ESLINT_PERSONAL_CONFIG_LOAD: "'~/.eslintrc.*' config files have been deprecated. Please use a config file per project or the '--config' option.",
      ESLINT_PERSONAL_CONFIG_SUPPRESS: "'~/.eslintrc.*' config files have been deprecated. Please remove it or add 'root:true' to the config files in your projects in order to avoid loading '~/.eslintrc.*' accidentally."
    };
    var sourceFileErrorCache = /* @__PURE__ */ new Set();
    function emitDeprecationWarning(source, errorCode) {
      const cacheKey = JSON.stringify({ source, errorCode });
      if (sourceFileErrorCache.has(cacheKey)) {
        return;
      }
      sourceFileErrorCache.add(cacheKey);
      const rel = path__default["default"].relative(process.cwd(), source);
      const message = deprecationWarningMessages[errorCode];
      process.emitWarning(
        `${message} (found in "${rel}")`,
        "DeprecationWarning",
        errorCode
      );
    }
    var metaSchema = {
      id: "http://json-schema.org/draft-04/schema#",
      $schema: "http://json-schema.org/draft-04/schema#",
      description: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        positiveInteger: {
          type: "integer",
          minimum: 0
        },
        positiveIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/positiveInteger" }, { default: 0 }]
        },
        simpleTypes: {
          enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          minItems: 1,
          uniqueItems: true
        }
      },
      type: "object",
      properties: {
        id: {
          type: "string"
        },
        $schema: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: {},
        multipleOf: {
          type: "number",
          minimum: 0,
          exclusiveMinimum: true
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "boolean",
          default: false
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "boolean",
          default: false
        },
        maxLength: { $ref: "#/definitions/positiveInteger" },
        minLength: { $ref: "#/definitions/positiveIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: {
          anyOf: [
            { type: "boolean" },
            { $ref: "#" }
          ],
          default: {}
        },
        items: {
          anyOf: [
            { $ref: "#" },
            { $ref: "#/definitions/schemaArray" }
          ],
          default: {}
        },
        maxItems: { $ref: "#/definitions/positiveInteger" },
        minItems: { $ref: "#/definitions/positiveIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        maxProperties: { $ref: "#/definitions/positiveInteger" },
        minProperties: { $ref: "#/definitions/positiveIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: {
          anyOf: [
            { type: "boolean" },
            { $ref: "#" }
          ],
          default: {}
        },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [
              { $ref: "#" },
              { $ref: "#/definitions/stringArray" }
            ]
          }
        },
        enum: {
          type: "array",
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      dependencies: {
        exclusiveMaximum: ["maximum"],
        exclusiveMinimum: ["minimum"]
      },
      default: {}
    };
    var ajvOrig = (additionalOptions = {}) => {
      const ajv2 = new Ajv__default["default"]({
        meta: false,
        useDefaults: true,
        validateSchema: false,
        missingRefs: "ignore",
        verbose: true,
        schemaId: "auto",
        ...additionalOptions
      });
      ajv2.addMetaSchema(metaSchema);
      ajv2._opts.defaultMeta = metaSchema.id;
      return ajv2;
    };
    var baseConfigProperties = {
      $schema: { type: "string" },
      env: { type: "object" },
      extends: { $ref: "#/definitions/stringOrStrings" },
      globals: { type: "object" },
      overrides: {
        type: "array",
        items: { $ref: "#/definitions/overrideConfig" },
        additionalItems: false
      },
      parser: { type: ["string", "null"] },
      parserOptions: { type: "object" },
      plugins: { type: "array" },
      processor: { type: "string" },
      rules: { type: "object" },
      settings: { type: "object" },
      noInlineConfig: { type: "boolean" },
      reportUnusedDisableDirectives: { type: "boolean" },
      ecmaFeatures: { type: "object" }
      // deprecated; logs a warning when used
    };
    var configSchema = {
      definitions: {
        stringOrStrings: {
          oneOf: [
            { type: "string" },
            {
              type: "array",
              items: { type: "string" },
              additionalItems: false
            }
          ]
        },
        stringOrStringsRequired: {
          oneOf: [
            { type: "string" },
            {
              type: "array",
              items: { type: "string" },
              additionalItems: false,
              minItems: 1
            }
          ]
        },
        // Config at top-level.
        objectConfig: {
          type: "object",
          properties: {
            root: { type: "boolean" },
            ignorePatterns: { $ref: "#/definitions/stringOrStrings" },
            ...baseConfigProperties
          },
          additionalProperties: false
        },
        // Config in `overrides`.
        overrideConfig: {
          type: "object",
          properties: {
            excludedFiles: { $ref: "#/definitions/stringOrStrings" },
            files: { $ref: "#/definitions/stringOrStringsRequired" },
            ...baseConfigProperties
          },
          required: ["files"],
          additionalProperties: false
        }
      },
      $ref: "#/definitions/objectConfig"
    };
    function getDiff(current, prev) {
      const retv = {};
      for (const [key, value] of Object.entries(current)) {
        if (!Object.hasOwnProperty.call(prev, key)) {
          retv[key] = value;
        }
      }
      return retv;
    }
    var newGlobals2015 = getDiff(globals__default["default"].es2015, globals__default["default"].es5);
    var newGlobals2017 = {
      Atomics: false,
      SharedArrayBuffer: false
    };
    var newGlobals2020 = {
      BigInt: false,
      BigInt64Array: false,
      BigUint64Array: false,
      globalThis: false
    };
    var newGlobals2021 = {
      AggregateError: false,
      FinalizationRegistry: false,
      WeakRef: false
    };
    var environments = new Map(Object.entries({
      // Language
      builtin: {
        globals: globals__default["default"].es5
      },
      es6: {
        globals: newGlobals2015,
        parserOptions: {
          ecmaVersion: 6
        }
      },
      es2015: {
        globals: newGlobals2015,
        parserOptions: {
          ecmaVersion: 6
        }
      },
      es2016: {
        globals: newGlobals2015,
        parserOptions: {
          ecmaVersion: 7
        }
      },
      es2017: {
        globals: { ...newGlobals2015, ...newGlobals2017 },
        parserOptions: {
          ecmaVersion: 8
        }
      },
      es2018: {
        globals: { ...newGlobals2015, ...newGlobals2017 },
        parserOptions: {
          ecmaVersion: 9
        }
      },
      es2019: {
        globals: { ...newGlobals2015, ...newGlobals2017 },
        parserOptions: {
          ecmaVersion: 10
        }
      },
      es2020: {
        globals: { ...newGlobals2015, ...newGlobals2017, ...newGlobals2020 },
        parserOptions: {
          ecmaVersion: 11
        }
      },
      es2021: {
        globals: { ...newGlobals2015, ...newGlobals2017, ...newGlobals2020, ...newGlobals2021 },
        parserOptions: {
          ecmaVersion: 12
        }
      },
      es2022: {
        globals: { ...newGlobals2015, ...newGlobals2017, ...newGlobals2020, ...newGlobals2021 },
        parserOptions: {
          ecmaVersion: 13
        }
      },
      es2023: {
        globals: { ...newGlobals2015, ...newGlobals2017, ...newGlobals2020, ...newGlobals2021 },
        parserOptions: {
          ecmaVersion: 14
        }
      },
      es2024: {
        globals: { ...newGlobals2015, ...newGlobals2017, ...newGlobals2020, ...newGlobals2021 },
        parserOptions: {
          ecmaVersion: 15
        }
      },
      // Platforms
      browser: {
        globals: globals__default["default"].browser
      },
      node: {
        globals: globals__default["default"].node,
        parserOptions: {
          ecmaFeatures: {
            globalReturn: true
          }
        }
      },
      "shared-node-browser": {
        globals: globals__default["default"]["shared-node-browser"]
      },
      worker: {
        globals: globals__default["default"].worker
      },
      serviceworker: {
        globals: globals__default["default"].serviceworker
      },
      // Frameworks
      commonjs: {
        globals: globals__default["default"].commonjs,
        parserOptions: {
          ecmaFeatures: {
            globalReturn: true
          }
        }
      },
      amd: {
        globals: globals__default["default"].amd
      },
      mocha: {
        globals: globals__default["default"].mocha
      },
      jasmine: {
        globals: globals__default["default"].jasmine
      },
      jest: {
        globals: globals__default["default"].jest
      },
      phantomjs: {
        globals: globals__default["default"].phantomjs
      },
      jquery: {
        globals: globals__default["default"].jquery
      },
      qunit: {
        globals: globals__default["default"].qunit
      },
      prototypejs: {
        globals: globals__default["default"].prototypejs
      },
      shelljs: {
        globals: globals__default["default"].shelljs
      },
      meteor: {
        globals: globals__default["default"].meteor
      },
      mongo: {
        globals: globals__default["default"].mongo
      },
      protractor: {
        globals: globals__default["default"].protractor
      },
      applescript: {
        globals: globals__default["default"].applescript
      },
      nashorn: {
        globals: globals__default["default"].nashorn
      },
      atomtest: {
        globals: globals__default["default"].atomtest
      },
      embertest: {
        globals: globals__default["default"].embertest
      },
      webextensions: {
        globals: globals__default["default"].webextensions
      },
      greasemonkey: {
        globals: globals__default["default"].greasemonkey
      }
    }));
    var ajv = ajvOrig();
    var ruleValidators = /* @__PURE__ */ new WeakMap();
    var noop = Function.prototype;
    var validateSchema;
    var severityMap = {
      error: 2,
      warn: 1,
      off: 0
    };
    var validated = /* @__PURE__ */ new WeakSet();
    var ConfigValidator = class {
      constructor({ builtInRules = /* @__PURE__ */ new Map() } = {}) {
        this.builtInRules = builtInRules;
      }
      /**
       * Gets a complete options schema for a rule.
       * @param {{create: Function, schema: (Array|null)}} rule A new-style rule object
       * @returns {Object} JSON Schema for the rule's options.
       */
      getRuleOptionsSchema(rule) {
        if (!rule) {
          return null;
        }
        const schema = rule.schema || rule.meta && rule.meta.schema;
        if (Array.isArray(schema)) {
          if (schema.length) {
            return {
              type: "array",
              items: schema,
              minItems: 0,
              maxItems: schema.length
            };
          }
          return {
            type: "array",
            minItems: 0,
            maxItems: 0
          };
        }
        return schema || null;
      }
      /**
       * Validates a rule's severity and returns the severity value. Throws an error if the severity is invalid.
       * @param {options} options The given options for the rule.
       * @returns {number|string} The rule's severity value
       */
      validateRuleSeverity(options) {
        const severity = Array.isArray(options) ? options[0] : options;
        const normSeverity = typeof severity === "string" ? severityMap[severity.toLowerCase()] : severity;
        if (normSeverity === 0 || normSeverity === 1 || normSeverity === 2) {
          return normSeverity;
        }
        throw new Error(`	Severity should be one of the following: 0 = off, 1 = warn, 2 = error (you passed '${util__default["default"].inspect(severity).replace(/'/gu, '"').replace(/\n/gu, "")}').
`);
      }
      /**
       * Validates the non-severity options passed to a rule, based on its schema.
       * @param {{create: Function}} rule The rule to validate
       * @param {Array} localOptions The options for the rule, excluding severity
       * @returns {void}
       */
      validateRuleSchema(rule, localOptions) {
        if (!ruleValidators.has(rule)) {
          const schema = this.getRuleOptionsSchema(rule);
          if (schema) {
            ruleValidators.set(rule, ajv.compile(schema));
          }
        }
        const validateRule = ruleValidators.get(rule);
        if (validateRule) {
          validateRule(localOptions);
          if (validateRule.errors) {
            throw new Error(validateRule.errors.map(
              (error) => `	Value ${JSON.stringify(error.data)} ${error.message}.
`
            ).join(""));
          }
        }
      }
      /**
       * Validates a rule's options against its schema.
       * @param {{create: Function}|null} rule The rule that the config is being validated for
       * @param {string} ruleId The rule's unique name.
       * @param {Array|number} options The given options for the rule.
       * @param {string|null} source The name of the configuration source to report in any errors. If null or undefined,
       * no source is prepended to the message.
       * @returns {void}
       */
      validateRuleOptions(rule, ruleId, options, source = null) {
        try {
          const severity = this.validateRuleSeverity(options);
          if (severity !== 0) {
            this.validateRuleSchema(rule, Array.isArray(options) ? options.slice(1) : []);
          }
        } catch (err) {
          const enhancedMessage = `Configuration for rule "${ruleId}" is invalid:
${err.message}`;
          if (typeof source === "string") {
            throw new Error(`${source}:
	${enhancedMessage}`);
          } else {
            throw new Error(enhancedMessage);
          }
        }
      }
      /**
       * Validates an environment object
       * @param {Object} environment The environment config object to validate.
       * @param {string} source The name of the configuration source to report in any errors.
       * @param {function(envId:string): Object} [getAdditionalEnv] A map from strings to loaded environments.
       * @returns {void}
       */
      validateEnvironment(environment, source, getAdditionalEnv = noop) {
        if (!environment) {
          return;
        }
        Object.keys(environment).forEach((id) => {
          const env = getAdditionalEnv(id) || environments.get(id) || null;
          if (!env) {
            const message = `${source}:
	Environment key "${id}" is unknown
`;
            throw new Error(message);
          }
        });
      }
      /**
       * Validates a rules config object
       * @param {Object} rulesConfig The rules config object to validate.
       * @param {string} source The name of the configuration source to report in any errors.
       * @param {function(ruleId:string): Object} getAdditionalRule A map from strings to loaded rules
       * @returns {void}
       */
      validateRules(rulesConfig, source, getAdditionalRule = noop) {
        if (!rulesConfig) {
          return;
        }
        Object.keys(rulesConfig).forEach((id) => {
          const rule = getAdditionalRule(id) || this.builtInRules.get(id) || null;
          this.validateRuleOptions(rule, id, rulesConfig[id], source);
        });
      }
      /**
       * Validates a `globals` section of a config file
       * @param {Object} globalsConfig The `globals` section
       * @param {string|null} source The name of the configuration source to report in the event of an error.
       * @returns {void}
       */
      validateGlobals(globalsConfig, source = null) {
        if (!globalsConfig) {
          return;
        }
        Object.entries(globalsConfig).forEach(([configuredGlobal, configuredValue]) => {
          try {
            normalizeConfigGlobal(configuredValue);
          } catch (err) {
            throw new Error(`ESLint configuration of global '${configuredGlobal}' in ${source} is invalid:
${err.message}`);
          }
        });
      }
      /**
       * Validate `processor` configuration.
       * @param {string|undefined} processorName The processor name.
       * @param {string} source The name of config file.
       * @param {function(id:string): Processor} getProcessor The getter of defined processors.
       * @returns {void}
       */
      validateProcessor(processorName, source, getProcessor) {
        if (processorName && !getProcessor(processorName)) {
          throw new Error(`ESLint configuration of processor in '${source}' is invalid: '${processorName}' was not found.`);
        }
      }
      /**
       * Formats an array of schema validation errors.
       * @param {Array} errors An array of error messages to format.
       * @returns {string} Formatted error message
       */
      formatErrors(errors) {
        return errors.map((error) => {
          if (error.keyword === "additionalProperties") {
            const formattedPropertyPath = error.dataPath.length ? `${error.dataPath.slice(1)}.${error.params.additionalProperty}` : error.params.additionalProperty;
            return `Unexpected top-level property "${formattedPropertyPath}"`;
          }
          if (error.keyword === "type") {
            const formattedField = error.dataPath.slice(1);
            const formattedExpectedType = Array.isArray(error.schema) ? error.schema.join("/") : error.schema;
            const formattedValue = JSON.stringify(error.data);
            return `Property "${formattedField}" is the wrong type (expected ${formattedExpectedType} but got \`${formattedValue}\`)`;
          }
          const field = error.dataPath[0] === "." ? error.dataPath.slice(1) : error.dataPath;
          return `"${field}" ${error.message}. Value: ${JSON.stringify(error.data)}`;
        }).map((message) => `	- ${message}.
`).join("");
      }
      /**
       * Validates the top level properties of the config object.
       * @param {Object} config The config object to validate.
       * @param {string} source The name of the configuration source to report in any errors.
       * @returns {void}
       */
      validateConfigSchema(config, source = null) {
        validateSchema = validateSchema || ajv.compile(configSchema);
        if (!validateSchema(config)) {
          throw new Error(`ESLint configuration in ${source} is invalid:
${this.formatErrors(validateSchema.errors)}`);
        }
        if (Object.hasOwnProperty.call(config, "ecmaFeatures")) {
          emitDeprecationWarning(source, "ESLINT_LEGACY_ECMAFEATURES");
        }
      }
      /**
       * Validates an entire config object.
       * @param {Object} config The config object to validate.
       * @param {string} source The name of the configuration source to report in any errors.
       * @param {function(ruleId:string): Object} [getAdditionalRule] A map from strings to loaded rules.
       * @param {function(envId:string): Object} [getAdditionalEnv] A map from strings to loaded envs.
       * @returns {void}
       */
      validate(config, source, getAdditionalRule, getAdditionalEnv) {
        this.validateConfigSchema(config, source);
        this.validateRules(config.rules, source, getAdditionalRule);
        this.validateEnvironment(config.env, source, getAdditionalEnv);
        this.validateGlobals(config.globals, source);
        for (const override of config.overrides || []) {
          this.validateRules(override.rules, source, getAdditionalRule);
          this.validateEnvironment(override.env, source, getAdditionalEnv);
          this.validateGlobals(config.globals, source);
        }
      }
      /**
       * Validate config array object.
       * @param {ConfigArray} configArray The config array to validate.
       * @returns {void}
       */
      validateConfigArray(configArray) {
        const getPluginEnv = Map.prototype.get.bind(configArray.pluginEnvironments);
        const getPluginProcessor = Map.prototype.get.bind(configArray.pluginProcessors);
        const getPluginRule = Map.prototype.get.bind(configArray.pluginRules);
        for (const element of configArray) {
          if (validated.has(element)) {
            continue;
          }
          validated.add(element);
          this.validateEnvironment(element.env, element.name, getPluginEnv);
          this.validateGlobals(element.globals, element.name);
          this.validateProcessor(element.processor, element.name, getPluginProcessor);
          this.validateRules(element.rules, element.name, getPluginRule);
        }
      }
    };
    var NAMESPACE_REGEX = /^@.*\//iu;
    function normalizePackageName(name, prefix) {
      let normalizedName = name;
      if (normalizedName.includes("\\")) {
        normalizedName = normalizedName.replace(/\\/gu, "/");
      }
      if (normalizedName.charAt(0) === "@") {
        const scopedPackageShortcutRegex = new RegExp(`^(@[^/]+)(?:/(?:${prefix})?)?$`, "u"), scopedPackageNameRegex = new RegExp(`^${prefix}(-|$)`, "u");
        if (scopedPackageShortcutRegex.test(normalizedName)) {
          normalizedName = normalizedName.replace(scopedPackageShortcutRegex, `$1/${prefix}`);
        } else if (!scopedPackageNameRegex.test(normalizedName.split("/")[1])) {
          normalizedName = normalizedName.replace(/^@([^/]+)\/(.*)$/u, `@$1/${prefix}-$2`);
        }
      } else if (!normalizedName.startsWith(`${prefix}-`)) {
        normalizedName = `${prefix}-${normalizedName}`;
      }
      return normalizedName;
    }
    function getShorthandName(fullname, prefix) {
      if (fullname[0] === "@") {
        let matchResult = new RegExp(`^(@[^/]+)/${prefix}$`, "u").exec(fullname);
        if (matchResult) {
          return matchResult[1];
        }
        matchResult = new RegExp(`^(@[^/]+)/${prefix}-(.+)$`, "u").exec(fullname);
        if (matchResult) {
          return `${matchResult[1]}/${matchResult[2]}`;
        }
      } else if (fullname.startsWith(`${prefix}-`)) {
        return fullname.slice(prefix.length + 1);
      }
      return fullname;
    }
    function getNamespaceFromTerm(term) {
      const match = term.match(NAMESPACE_REGEX);
      return match ? match[0] : "";
    }
    var naming = {
      __proto__: null,
      normalizePackageName,
      getShorthandName,
      getNamespaceFromTerm
    };
    var Legacy = {
      environments,
      // shared
      ConfigOps,
      ConfigValidator,
      naming
    };
    exports.Legacy = Legacy;
  }
});

// ../../node_modules/ms/index.js
var require_ms = __commonJS({
  "../../node_modules/ms/index.js"(exports, module) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// ../../node_modules/debug/src/common.js
var require_common = __commonJS({
  "../../node_modules/debug/src/common.js"(exports, module) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// ../../node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "../../node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// ../../node_modules/eslint/lib/shared/traverser.js
var require_traverser = __commonJS({
  "../../node_modules/eslint/lib/shared/traverser.js"(exports, module) {
    "use strict";
    var vk = require_eslint_visitor_keys();
    var debug = require_browser()("eslint:traverser");
    function noop() {
    }
    function isNode(x) {
      return x !== null && typeof x === "object" && typeof x.type === "string";
    }
    function getVisitorKeys(visitorKeys, node) {
      let keys = visitorKeys[node.type];
      if (!keys) {
        keys = vk.getKeys(node);
        debug('Unknown node type "%s": Estimated visitor keys %j', node.type, keys);
      }
      return keys;
    }
    var Traverser = class {
      constructor() {
        this._current = null;
        this._parents = [];
        this._skipped = false;
        this._broken = false;
        this._visitorKeys = null;
        this._enter = null;
        this._leave = null;
      }
      /**
       * Gives current node.
       * @returns {ASTNode} The current node.
       */
      current() {
        return this._current;
      }
      /**
       * Gives a copy of the ancestor nodes.
       * @returns {ASTNode[]} The ancestor nodes.
       */
      parents() {
        return this._parents.slice(0);
      }
      /**
       * Break the current traversal.
       * @returns {void}
       */
      break() {
        this._broken = true;
      }
      /**
       * Skip child nodes for the current traversal.
       * @returns {void}
       */
      skip() {
        this._skipped = true;
      }
      /**
       * Traverse the given AST tree.
       * @param {ASTNode} node The root node to traverse.
       * @param {Object} options The option object.
       * @param {Object} [options.visitorKeys=DEFAULT_VISITOR_KEYS] The keys of each node types to traverse child nodes. Default is `./default-visitor-keys.json`.
       * @param {Function} [options.enter=noop] The callback function which is called on entering each node.
       * @param {Function} [options.leave=noop] The callback function which is called on leaving each node.
       * @returns {void}
       */
      traverse(node, options) {
        this._current = null;
        this._parents = [];
        this._skipped = false;
        this._broken = false;
        this._visitorKeys = options.visitorKeys || vk.KEYS;
        this._enter = options.enter || noop;
        this._leave = options.leave || noop;
        this._traverse(node, null);
      }
      /**
       * Traverse the given AST tree recursively.
       * @param {ASTNode} node The current node.
       * @param {ASTNode|null} parent The parent node.
       * @returns {void}
       * @private
       */
      _traverse(node, parent) {
        if (!isNode(node)) {
          return;
        }
        this._current = node;
        this._skipped = false;
        this._enter(node, parent);
        if (!this._skipped && !this._broken) {
          const keys = getVisitorKeys(this._visitorKeys, node);
          if (keys.length >= 1) {
            this._parents.push(node);
            for (let i = 0; i < keys.length && !this._broken; ++i) {
              const child = node[keys[i]];
              if (Array.isArray(child)) {
                for (let j = 0; j < child.length && !this._broken; ++j) {
                  this._traverse(child[j], node);
                }
              } else {
                this._traverse(child, node);
              }
            }
            this._parents.pop();
          }
        }
        if (!this._broken) {
          this._leave(node, parent);
        }
        this._current = parent;
      }
      /**
       * Calculates the keys to use for traversal.
       * @param {ASTNode} node The node to read keys from.
       * @returns {string[]} An array of keys to visit on the node.
       * @private
       */
      static getKeys(node) {
        return vk.getKeys(node);
      }
      /**
       * Traverse the given AST tree.
       * @param {ASTNode} node The root node to traverse.
       * @param {Object} options The option object.
       * @param {Object} [options.visitorKeys=DEFAULT_VISITOR_KEYS] The keys of each node types to traverse child nodes. Default is `./default-visitor-keys.json`.
       * @param {Function} [options.enter=noop] The callback function which is called on entering each node.
       * @param {Function} [options.leave=noop] The callback function which is called on leaving each node.
       * @returns {void}
       */
      static traverse(node, options) {
        new Traverser().traverse(node, options);
      }
      /**
       * The default visitor keys.
       * @type {Object}
       */
      static get DEFAULT_VISITOR_KEYS() {
        return vk.KEYS;
      }
    };
    module.exports = Traverser;
  }
});

// ../../node_modules/@eslint-community/eslint-utils/index.js
var require_eslint_utils = __commonJS({
  "../../node_modules/@eslint-community/eslint-utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var eslintVisitorKeys = require_eslint_visitor_keys();
    function getInnermostScope(initialScope, node) {
      const location = node.range[0];
      let scope = initialScope;
      let found = false;
      do {
        found = false;
        for (const childScope of scope.childScopes) {
          const range = childScope.block.range;
          if (range[0] <= location && location < range[1]) {
            scope = childScope;
            found = true;
            break;
          }
        }
      } while (found);
      return scope;
    }
    function findVariable(initialScope, nameOrNode) {
      let name = "";
      let scope = initialScope;
      if (typeof nameOrNode === "string") {
        name = nameOrNode;
      } else {
        name = nameOrNode.name;
        scope = getInnermostScope(scope, nameOrNode);
      }
      while (scope != null) {
        const variable = scope.set.get(name);
        if (variable != null) {
          return variable;
        }
        scope = scope.upper;
      }
      return null;
    }
    function negate0(token) {
      return !this(token);
    }
    function negate(f) {
      return negate0.bind(f);
    }
    function isPunctuatorTokenWithValue(token, value) {
      return token.type === "Punctuator" && token.value === value;
    }
    function isArrowToken(token) {
      return isPunctuatorTokenWithValue(token, "=>");
    }
    function isCommaToken(token) {
      return isPunctuatorTokenWithValue(token, ",");
    }
    function isSemicolonToken(token) {
      return isPunctuatorTokenWithValue(token, ";");
    }
    function isColonToken(token) {
      return isPunctuatorTokenWithValue(token, ":");
    }
    function isOpeningParenToken(token) {
      return isPunctuatorTokenWithValue(token, "(");
    }
    function isClosingParenToken(token) {
      return isPunctuatorTokenWithValue(token, ")");
    }
    function isOpeningBracketToken(token) {
      return isPunctuatorTokenWithValue(token, "[");
    }
    function isClosingBracketToken(token) {
      return isPunctuatorTokenWithValue(token, "]");
    }
    function isOpeningBraceToken(token) {
      return isPunctuatorTokenWithValue(token, "{");
    }
    function isClosingBraceToken(token) {
      return isPunctuatorTokenWithValue(token, "}");
    }
    function isCommentToken(token) {
      return ["Block", "Line", "Shebang"].includes(token.type);
    }
    var isNotArrowToken = negate(isArrowToken);
    var isNotCommaToken = negate(isCommaToken);
    var isNotSemicolonToken = negate(isSemicolonToken);
    var isNotColonToken = negate(isColonToken);
    var isNotOpeningParenToken = negate(isOpeningParenToken);
    var isNotClosingParenToken = negate(isClosingParenToken);
    var isNotOpeningBracketToken = negate(isOpeningBracketToken);
    var isNotClosingBracketToken = negate(isClosingBracketToken);
    var isNotOpeningBraceToken = negate(isOpeningBraceToken);
    var isNotClosingBraceToken = negate(isClosingBraceToken);
    var isNotCommentToken = negate(isCommentToken);
    function getOpeningParenOfParams(node, sourceCode) {
      return node.id ? sourceCode.getTokenAfter(node.id, isOpeningParenToken) : sourceCode.getFirstToken(node, isOpeningParenToken);
    }
    function getFunctionHeadLocation(node, sourceCode) {
      const parent = node.parent;
      let start = null;
      let end = null;
      if (node.type === "ArrowFunctionExpression") {
        const arrowToken = sourceCode.getTokenBefore(node.body, isArrowToken);
        start = arrowToken.loc.start;
        end = arrowToken.loc.end;
      } else if (parent.type === "Property" || parent.type === "MethodDefinition" || parent.type === "PropertyDefinition") {
        start = parent.loc.start;
        end = getOpeningParenOfParams(node, sourceCode).loc.start;
      } else {
        start = node.loc.start;
        end = getOpeningParenOfParams(node, sourceCode).loc.start;
      }
      return {
        start: { ...start },
        end: { ...end }
      };
    }
    var globalObject = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
    var builtinNames = Object.freeze(
      /* @__PURE__ */ new Set([
        "Array",
        "ArrayBuffer",
        "BigInt",
        "BigInt64Array",
        "BigUint64Array",
        "Boolean",
        "DataView",
        "Date",
        "decodeURI",
        "decodeURIComponent",
        "encodeURI",
        "encodeURIComponent",
        "escape",
        "Float32Array",
        "Float64Array",
        "Function",
        "Infinity",
        "Int16Array",
        "Int32Array",
        "Int8Array",
        "isFinite",
        "isNaN",
        "isPrototypeOf",
        "JSON",
        "Map",
        "Math",
        "NaN",
        "Number",
        "Object",
        "parseFloat",
        "parseInt",
        "Promise",
        "Proxy",
        "Reflect",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "Uint16Array",
        "Uint32Array",
        "Uint8Array",
        "Uint8ClampedArray",
        "undefined",
        "unescape",
        "WeakMap",
        "WeakSet"
      ])
    );
    var callAllowed = new Set(
      [
        Array.isArray,
        Array.of,
        Array.prototype.at,
        Array.prototype.concat,
        Array.prototype.entries,
        Array.prototype.every,
        Array.prototype.filter,
        Array.prototype.find,
        Array.prototype.findIndex,
        Array.prototype.flat,
        Array.prototype.includes,
        Array.prototype.indexOf,
        Array.prototype.join,
        Array.prototype.keys,
        Array.prototype.lastIndexOf,
        Array.prototype.slice,
        Array.prototype.some,
        Array.prototype.toString,
        Array.prototype.values,
        typeof BigInt === "function" ? BigInt : void 0,
        Boolean,
        Date,
        Date.parse,
        decodeURI,
        decodeURIComponent,
        encodeURI,
        encodeURIComponent,
        escape,
        isFinite,
        isNaN,
        isPrototypeOf,
        Map,
        Map.prototype.entries,
        Map.prototype.get,
        Map.prototype.has,
        Map.prototype.keys,
        Map.prototype.values,
        ...Object.getOwnPropertyNames(Math).filter((k) => k !== "random").map((k) => Math[k]).filter((f) => typeof f === "function"),
        Number,
        Number.isFinite,
        Number.isNaN,
        Number.parseFloat,
        Number.parseInt,
        Number.prototype.toExponential,
        Number.prototype.toFixed,
        Number.prototype.toPrecision,
        Number.prototype.toString,
        Object,
        Object.entries,
        Object.is,
        Object.isExtensible,
        Object.isFrozen,
        Object.isSealed,
        Object.keys,
        Object.values,
        parseFloat,
        parseInt,
        RegExp,
        Set,
        Set.prototype.entries,
        Set.prototype.has,
        Set.prototype.keys,
        Set.prototype.values,
        String,
        String.fromCharCode,
        String.fromCodePoint,
        String.raw,
        String.prototype.at,
        String.prototype.charAt,
        String.prototype.charCodeAt,
        String.prototype.codePointAt,
        String.prototype.concat,
        String.prototype.endsWith,
        String.prototype.includes,
        String.prototype.indexOf,
        String.prototype.lastIndexOf,
        String.prototype.normalize,
        String.prototype.padEnd,
        String.prototype.padStart,
        String.prototype.slice,
        String.prototype.startsWith,
        String.prototype.substr,
        String.prototype.substring,
        String.prototype.toLowerCase,
        String.prototype.toString,
        String.prototype.toUpperCase,
        String.prototype.trim,
        String.prototype.trimEnd,
        String.prototype.trimLeft,
        String.prototype.trimRight,
        String.prototype.trimStart,
        Symbol.for,
        Symbol.keyFor,
        unescape
      ].filter((f) => typeof f === "function")
    );
    var callPassThrough = /* @__PURE__ */ new Set([
      Object.freeze,
      Object.preventExtensions,
      Object.seal
    ]);
    var getterAllowed = [
      [Map, /* @__PURE__ */ new Set(["size"])],
      [
        RegExp,
        /* @__PURE__ */ new Set([
          "dotAll",
          "flags",
          "global",
          "hasIndices",
          "ignoreCase",
          "multiline",
          "source",
          "sticky",
          "unicode"
        ])
      ],
      [Set, /* @__PURE__ */ new Set(["size"])]
    ];
    function getPropertyDescriptor(object, name) {
      let x = object;
      while ((typeof x === "object" || typeof x === "function") && x !== null) {
        const d = Object.getOwnPropertyDescriptor(x, name);
        if (d) {
          return d;
        }
        x = Object.getPrototypeOf(x);
      }
      return null;
    }
    function isGetter(object, name) {
      const d = getPropertyDescriptor(object, name);
      return d != null && d.get != null;
    }
    function getElementValues(nodeList, initialScope) {
      const valueList = [];
      for (let i = 0; i < nodeList.length; ++i) {
        const elementNode = nodeList[i];
        if (elementNode == null) {
          valueList.length = i + 1;
        } else if (elementNode.type === "SpreadElement") {
          const argument = getStaticValueR(elementNode.argument, initialScope);
          if (argument == null) {
            return null;
          }
          valueList.push(...argument.value);
        } else {
          const element = getStaticValueR(elementNode, initialScope);
          if (element == null) {
            return null;
          }
          valueList.push(element.value);
        }
      }
      return valueList;
    }
    function isEffectivelyConst(variable) {
      const refs = variable.references;
      const inits = refs.filter((r) => r.init).length;
      const reads = refs.filter((r) => r.isReadOnly()).length;
      if (inits === 1 && reads + inits === refs.length) {
        return true;
      }
      return false;
    }
    var operations = Object.freeze({
      ArrayExpression(node, initialScope) {
        const elements = getElementValues(node.elements, initialScope);
        return elements != null ? { value: elements } : null;
      },
      AssignmentExpression(node, initialScope) {
        if (node.operator === "=") {
          return getStaticValueR(node.right, initialScope);
        }
        return null;
      },
      //eslint-disable-next-line complexity
      BinaryExpression(node, initialScope) {
        if (node.operator === "in" || node.operator === "instanceof") {
          return null;
        }
        const left = getStaticValueR(node.left, initialScope);
        const right = getStaticValueR(node.right, initialScope);
        if (left != null && right != null) {
          switch (node.operator) {
            case "==":
              return { value: left.value == right.value };
            case "!=":
              return { value: left.value != right.value };
            case "===":
              return { value: left.value === right.value };
            case "!==":
              return { value: left.value !== right.value };
            case "<":
              return { value: left.value < right.value };
            case "<=":
              return { value: left.value <= right.value };
            case ">":
              return { value: left.value > right.value };
            case ">=":
              return { value: left.value >= right.value };
            case "<<":
              return { value: left.value << right.value };
            case ">>":
              return { value: left.value >> right.value };
            case ">>>":
              return { value: left.value >>> right.value };
            case "+":
              return { value: left.value + right.value };
            case "-":
              return { value: left.value - right.value };
            case "*":
              return { value: left.value * right.value };
            case "/":
              return { value: left.value / right.value };
            case "%":
              return { value: left.value % right.value };
            case "**":
              return { value: left.value ** right.value };
            case "|":
              return { value: left.value | right.value };
            case "^":
              return { value: left.value ^ right.value };
            case "&":
              return { value: left.value & right.value };
          }
        }
        return null;
      },
      CallExpression(node, initialScope) {
        const calleeNode = node.callee;
        const args = getElementValues(node.arguments, initialScope);
        if (args != null) {
          if (calleeNode.type === "MemberExpression") {
            if (calleeNode.property.type === "PrivateIdentifier") {
              return null;
            }
            const object = getStaticValueR(calleeNode.object, initialScope);
            if (object != null) {
              if (object.value == null && (object.optional || node.optional)) {
                return { value: void 0, optional: true };
              }
              const property = getStaticPropertyNameValue(
                calleeNode,
                initialScope
              );
              if (property != null) {
                const receiver = object.value;
                const methodName = property.value;
                if (callAllowed.has(receiver[methodName])) {
                  return { value: receiver[methodName](...args) };
                }
                if (callPassThrough.has(receiver[methodName])) {
                  return { value: args[0] };
                }
              }
            }
          } else {
            const callee = getStaticValueR(calleeNode, initialScope);
            if (callee != null) {
              if (callee.value == null && node.optional) {
                return { value: void 0, optional: true };
              }
              const func = callee.value;
              if (callAllowed.has(func)) {
                return { value: func(...args) };
              }
              if (callPassThrough.has(func)) {
                return { value: args[0] };
              }
            }
          }
        }
        return null;
      },
      ConditionalExpression(node, initialScope) {
        const test = getStaticValueR(node.test, initialScope);
        if (test != null) {
          return test.value ? getStaticValueR(node.consequent, initialScope) : getStaticValueR(node.alternate, initialScope);
        }
        return null;
      },
      ExpressionStatement(node, initialScope) {
        return getStaticValueR(node.expression, initialScope);
      },
      Identifier(node, initialScope) {
        if (initialScope != null) {
          const variable = findVariable(initialScope, node);
          if (variable != null && variable.defs.length === 0 && builtinNames.has(variable.name) && variable.name in globalObject) {
            return { value: globalObject[variable.name] };
          }
          if (variable != null && variable.defs.length === 1) {
            const def = variable.defs[0];
            if (def.parent && def.type === "Variable" && (def.parent.kind === "const" || isEffectivelyConst(variable)) && // TODO(mysticatea): don't support destructuring here.
            def.node.id.type === "Identifier") {
              return getStaticValueR(def.node.init, initialScope);
            }
          }
        }
        return null;
      },
      Literal(node) {
        if ((node.regex != null || node.bigint != null) && node.value == null) {
          return null;
        }
        return { value: node.value };
      },
      LogicalExpression(node, initialScope) {
        const left = getStaticValueR(node.left, initialScope);
        if (left != null) {
          if (node.operator === "||" && Boolean(left.value) === true || node.operator === "&&" && Boolean(left.value) === false || node.operator === "??" && left.value != null) {
            return left;
          }
          const right = getStaticValueR(node.right, initialScope);
          if (right != null) {
            return right;
          }
        }
        return null;
      },
      MemberExpression(node, initialScope) {
        if (node.property.type === "PrivateIdentifier") {
          return null;
        }
        const object = getStaticValueR(node.object, initialScope);
        if (object != null) {
          if (object.value == null && (object.optional || node.optional)) {
            return { value: void 0, optional: true };
          }
          const property = getStaticPropertyNameValue(node, initialScope);
          if (property != null) {
            if (!isGetter(object.value, property.value)) {
              return { value: object.value[property.value] };
            }
            for (const [classFn, allowed] of getterAllowed) {
              if (object.value instanceof classFn && allowed.has(property.value)) {
                return { value: object.value[property.value] };
              }
            }
          }
        }
        return null;
      },
      ChainExpression(node, initialScope) {
        const expression = getStaticValueR(node.expression, initialScope);
        if (expression != null) {
          return { value: expression.value };
        }
        return null;
      },
      NewExpression(node, initialScope) {
        const callee = getStaticValueR(node.callee, initialScope);
        const args = getElementValues(node.arguments, initialScope);
        if (callee != null && args != null) {
          const Func = callee.value;
          if (callAllowed.has(Func)) {
            return { value: new Func(...args) };
          }
        }
        return null;
      },
      ObjectExpression(node, initialScope) {
        const object = {};
        for (const propertyNode of node.properties) {
          if (propertyNode.type === "Property") {
            if (propertyNode.kind !== "init") {
              return null;
            }
            const key = getStaticPropertyNameValue(
              propertyNode,
              initialScope
            );
            const value = getStaticValueR(propertyNode.value, initialScope);
            if (key == null || value == null) {
              return null;
            }
            object[key.value] = value.value;
          } else if (propertyNode.type === "SpreadElement" || propertyNode.type === "ExperimentalSpreadProperty") {
            const argument = getStaticValueR(
              propertyNode.argument,
              initialScope
            );
            if (argument == null) {
              return null;
            }
            Object.assign(object, argument.value);
          } else {
            return null;
          }
        }
        return { value: object };
      },
      SequenceExpression(node, initialScope) {
        const last = node.expressions[node.expressions.length - 1];
        return getStaticValueR(last, initialScope);
      },
      TaggedTemplateExpression(node, initialScope) {
        const tag = getStaticValueR(node.tag, initialScope);
        const expressions = getElementValues(
          node.quasi.expressions,
          initialScope
        );
        if (tag != null && expressions != null) {
          const func = tag.value;
          const strings = node.quasi.quasis.map((q) => q.value.cooked);
          strings.raw = node.quasi.quasis.map((q) => q.value.raw);
          if (func === String.raw) {
            return { value: func(strings, ...expressions) };
          }
        }
        return null;
      },
      TemplateLiteral(node, initialScope) {
        const expressions = getElementValues(node.expressions, initialScope);
        if (expressions != null) {
          let value = node.quasis[0].value.cooked;
          for (let i = 0; i < expressions.length; ++i) {
            value += expressions[i];
            value += node.quasis[i + 1].value.cooked;
          }
          return { value };
        }
        return null;
      },
      UnaryExpression(node, initialScope) {
        if (node.operator === "delete") {
          return null;
        }
        if (node.operator === "void") {
          return { value: void 0 };
        }
        const arg = getStaticValueR(node.argument, initialScope);
        if (arg != null) {
          switch (node.operator) {
            case "-":
              return { value: -arg.value };
            case "+":
              return { value: +arg.value };
            case "!":
              return { value: !arg.value };
            case "~":
              return { value: ~arg.value };
            case "typeof":
              return { value: typeof arg.value };
          }
        }
        return null;
      }
    });
    function getStaticValueR(node, initialScope) {
      if (node != null && Object.hasOwnProperty.call(operations, node.type)) {
        return operations[node.type](node, initialScope);
      }
      return null;
    }
    function getStaticPropertyNameValue(node, initialScope) {
      const nameNode = node.type === "Property" ? node.key : node.property;
      if (node.computed) {
        return getStaticValueR(nameNode, initialScope);
      }
      if (nameNode.type === "Identifier") {
        return { value: nameNode.name };
      }
      if (nameNode.type === "Literal") {
        if (nameNode.bigint) {
          return { value: nameNode.bigint };
        }
        return { value: String(nameNode.value) };
      }
      return null;
    }
    function getStaticValue(node, initialScope = null) {
      try {
        return getStaticValueR(node, initialScope);
      } catch (_error) {
        return null;
      }
    }
    function getStringIfConstant(node, initialScope = null) {
      if (node && node.type === "Literal" && node.value === null) {
        if (node.regex) {
          return `/${node.regex.pattern}/${node.regex.flags}`;
        }
        if (node.bigint) {
          return node.bigint;
        }
      }
      const evaluated = getStaticValue(node, initialScope);
      return evaluated && String(evaluated.value);
    }
    function getPropertyName(node, initialScope) {
      switch (node.type) {
        case "MemberExpression":
          if (node.computed) {
            return getStringIfConstant(node.property, initialScope);
          }
          if (node.property.type === "PrivateIdentifier") {
            return null;
          }
          return node.property.name;
        case "Property":
        case "MethodDefinition":
        case "PropertyDefinition":
          if (node.computed) {
            return getStringIfConstant(node.key, initialScope);
          }
          if (node.key.type === "Literal") {
            return String(node.key.value);
          }
          if (node.key.type === "PrivateIdentifier") {
            return null;
          }
          return node.key.name;
      }
      return null;
    }
    function getFunctionNameWithKind(node, sourceCode) {
      const parent = node.parent;
      const tokens = [];
      const isObjectMethod = parent.type === "Property" && parent.value === node;
      const isClassMethod = parent.type === "MethodDefinition" && parent.value === node;
      const isClassFieldMethod = parent.type === "PropertyDefinition" && parent.value === node;
      if (isClassMethod || isClassFieldMethod) {
        if (parent.static) {
          tokens.push("static");
        }
        if (parent.key.type === "PrivateIdentifier") {
          tokens.push("private");
        }
      }
      if (node.async) {
        tokens.push("async");
      }
      if (node.generator) {
        tokens.push("generator");
      }
      if (isObjectMethod || isClassMethod) {
        if (parent.kind === "constructor") {
          return "constructor";
        }
        if (parent.kind === "get") {
          tokens.push("getter");
        } else if (parent.kind === "set") {
          tokens.push("setter");
        } else {
          tokens.push("method");
        }
      } else if (isClassFieldMethod) {
        tokens.push("method");
      } else {
        if (node.type === "ArrowFunctionExpression") {
          tokens.push("arrow");
        }
        tokens.push("function");
      }
      if (isObjectMethod || isClassMethod || isClassFieldMethod) {
        if (parent.key.type === "PrivateIdentifier") {
          tokens.push(`#${parent.key.name}`);
        } else {
          const name = getPropertyName(parent);
          if (name) {
            tokens.push(`'${name}'`);
          } else if (sourceCode) {
            const keyText = sourceCode.getText(parent.key);
            if (!keyText.includes("\n")) {
              tokens.push(`[${keyText}]`);
            }
          }
        }
      } else if (node.id) {
        tokens.push(`'${node.id.name}'`);
      } else if (parent.type === "VariableDeclarator" && parent.id && parent.id.type === "Identifier") {
        tokens.push(`'${parent.id.name}'`);
      } else if ((parent.type === "AssignmentExpression" || parent.type === "AssignmentPattern") && parent.left && parent.left.type === "Identifier") {
        tokens.push(`'${parent.left.name}'`);
      } else if (parent.type === "ExportDefaultDeclaration" && parent.declaration === node) {
        tokens.push("'default'");
      }
      return tokens.join(" ");
    }
    var typeConversionBinaryOps = Object.freeze(
      /* @__PURE__ */ new Set([
        "==",
        "!=",
        "<",
        "<=",
        ">",
        ">=",
        "<<",
        ">>",
        ">>>",
        "+",
        "-",
        "*",
        "/",
        "%",
        "|",
        "^",
        "&",
        "in"
      ])
    );
    var typeConversionUnaryOps = Object.freeze(/* @__PURE__ */ new Set(["-", "+", "!", "~"]));
    function isNode(x) {
      return x !== null && typeof x === "object" && typeof x.type === "string";
    }
    var visitor = Object.freeze(
      Object.assign(/* @__PURE__ */ Object.create(null), {
        $visit(node, options, visitorKeys) {
          const { type } = node;
          if (typeof this[type] === "function") {
            return this[type](node, options, visitorKeys);
          }
          return this.$visitChildren(node, options, visitorKeys);
        },
        $visitChildren(node, options, visitorKeys) {
          const { type } = node;
          for (const key of visitorKeys[type] || eslintVisitorKeys.getKeys(node)) {
            const value = node[key];
            if (Array.isArray(value)) {
              for (const element of value) {
                if (isNode(element) && this.$visit(element, options, visitorKeys)) {
                  return true;
                }
              }
            } else if (isNode(value) && this.$visit(value, options, visitorKeys)) {
              return true;
            }
          }
          return false;
        },
        ArrowFunctionExpression() {
          return false;
        },
        AssignmentExpression() {
          return true;
        },
        AwaitExpression() {
          return true;
        },
        BinaryExpression(node, options, visitorKeys) {
          if (options.considerImplicitTypeConversion && typeConversionBinaryOps.has(node.operator) && (node.left.type !== "Literal" || node.right.type !== "Literal")) {
            return true;
          }
          return this.$visitChildren(node, options, visitorKeys);
        },
        CallExpression() {
          return true;
        },
        FunctionExpression() {
          return false;
        },
        ImportExpression() {
          return true;
        },
        MemberExpression(node, options, visitorKeys) {
          if (options.considerGetters) {
            return true;
          }
          if (options.considerImplicitTypeConversion && node.computed && node.property.type !== "Literal") {
            return true;
          }
          return this.$visitChildren(node, options, visitorKeys);
        },
        MethodDefinition(node, options, visitorKeys) {
          if (options.considerImplicitTypeConversion && node.computed && node.key.type !== "Literal") {
            return true;
          }
          return this.$visitChildren(node, options, visitorKeys);
        },
        NewExpression() {
          return true;
        },
        Property(node, options, visitorKeys) {
          if (options.considerImplicitTypeConversion && node.computed && node.key.type !== "Literal") {
            return true;
          }
          return this.$visitChildren(node, options, visitorKeys);
        },
        PropertyDefinition(node, options, visitorKeys) {
          if (options.considerImplicitTypeConversion && node.computed && node.key.type !== "Literal") {
            return true;
          }
          return this.$visitChildren(node, options, visitorKeys);
        },
        UnaryExpression(node, options, visitorKeys) {
          if (node.operator === "delete") {
            return true;
          }
          if (options.considerImplicitTypeConversion && typeConversionUnaryOps.has(node.operator) && node.argument.type !== "Literal") {
            return true;
          }
          return this.$visitChildren(node, options, visitorKeys);
        },
        UpdateExpression() {
          return true;
        },
        YieldExpression() {
          return true;
        }
      })
    );
    function hasSideEffect(node, sourceCode, { considerGetters = false, considerImplicitTypeConversion = false } = {}) {
      return visitor.$visit(
        node,
        { considerGetters, considerImplicitTypeConversion },
        sourceCode.visitorKeys || eslintVisitorKeys.KEYS
      );
    }
    function getParentSyntaxParen(node, sourceCode) {
      const parent = node.parent;
      switch (parent.type) {
        case "CallExpression":
        case "NewExpression":
          if (parent.arguments.length === 1 && parent.arguments[0] === node) {
            return sourceCode.getTokenAfter(
              parent.callee,
              isOpeningParenToken
            );
          }
          return null;
        case "DoWhileStatement":
          if (parent.test === node) {
            return sourceCode.getTokenAfter(
              parent.body,
              isOpeningParenToken
            );
          }
          return null;
        case "IfStatement":
        case "WhileStatement":
          if (parent.test === node) {
            return sourceCode.getFirstToken(parent, 1);
          }
          return null;
        case "ImportExpression":
          if (parent.source === node) {
            return sourceCode.getFirstToken(parent, 1);
          }
          return null;
        case "SwitchStatement":
          if (parent.discriminant === node) {
            return sourceCode.getFirstToken(parent, 1);
          }
          return null;
        case "WithStatement":
          if (parent.object === node) {
            return sourceCode.getFirstToken(parent, 1);
          }
          return null;
        default:
          return null;
      }
    }
    function isParenthesized(timesOrNode, nodeOrSourceCode, optionalSourceCode) {
      let times, node, sourceCode, maybeLeftParen, maybeRightParen;
      if (typeof timesOrNode === "number") {
        times = timesOrNode | 0;
        node = nodeOrSourceCode;
        sourceCode = optionalSourceCode;
        if (!(times >= 1)) {
          throw new TypeError("'times' should be a positive integer.");
        }
      } else {
        times = 1;
        node = timesOrNode;
        sourceCode = nodeOrSourceCode;
      }
      if (node == null || // `Program` can't be parenthesized
      node.parent == null || // `CatchClause.param` can't be parenthesized, example `try {} catch (error) {}`
      node.parent.type === "CatchClause" && node.parent.param === node) {
        return false;
      }
      maybeLeftParen = maybeRightParen = node;
      do {
        maybeLeftParen = sourceCode.getTokenBefore(maybeLeftParen);
        maybeRightParen = sourceCode.getTokenAfter(maybeRightParen);
      } while (maybeLeftParen != null && maybeRightParen != null && isOpeningParenToken(maybeLeftParen) && isClosingParenToken(maybeRightParen) && // Avoid false positive such as `if (a) {}`
      maybeLeftParen !== getParentSyntaxParen(node, sourceCode) && --times > 0);
      return times === 0;
    }
    var placeholder = /\$(?:[$&`']|[1-9][0-9]?)/gu;
    var internal = /* @__PURE__ */ new WeakMap();
    function isEscaped(str, index2) {
      let escaped = false;
      for (let i = index2 - 1; i >= 0 && str.charCodeAt(i) === 92; --i) {
        escaped = !escaped;
      }
      return escaped;
    }
    function replaceS(matcher, str, replacement) {
      const chunks = [];
      let index2 = 0;
      let match = null;
      function replacer(key) {
        switch (key) {
          case "$$":
            return "$";
          case "$&":
            return match[0];
          case "$`":
            return str.slice(0, match.index);
          case "$'":
            return str.slice(match.index + match[0].length);
          default: {
            const i = key.slice(1);
            if (i in match) {
              return match[i];
            }
            return key;
          }
        }
      }
      for (match of matcher.execAll(str)) {
        chunks.push(str.slice(index2, match.index));
        chunks.push(replacement.replace(placeholder, replacer));
        index2 = match.index + match[0].length;
      }
      chunks.push(str.slice(index2));
      return chunks.join("");
    }
    function replaceF(matcher, str, replace) {
      const chunks = [];
      let index2 = 0;
      for (const match of matcher.execAll(str)) {
        chunks.push(str.slice(index2, match.index));
        chunks.push(String(replace(...match, match.index, match.input)));
        index2 = match.index + match[0].length;
      }
      chunks.push(str.slice(index2));
      return chunks.join("");
    }
    var PatternMatcher = class {
      /**
       * Initialize this matcher.
       * @param {RegExp} pattern The pattern to match.
       * @param {{escaped:boolean}} options The options.
       */
      constructor(pattern, { escaped = false } = {}) {
        if (!(pattern instanceof RegExp)) {
          throw new TypeError("'pattern' should be a RegExp instance.");
        }
        if (!pattern.flags.includes("g")) {
          throw new Error("'pattern' should contains 'g' flag.");
        }
        internal.set(this, {
          pattern: new RegExp(pattern.source, pattern.flags),
          escaped: Boolean(escaped)
        });
      }
      /**
       * Find the pattern in a given string.
       * @param {string} str The string to find.
       * @returns {IterableIterator<RegExpExecArray>} The iterator which iterate the matched information.
       */
      *execAll(str) {
        const { pattern, escaped } = internal.get(this);
        let match = null;
        let lastIndex = 0;
        pattern.lastIndex = 0;
        while ((match = pattern.exec(str)) != null) {
          if (escaped || !isEscaped(str, match.index)) {
            lastIndex = pattern.lastIndex;
            yield match;
            pattern.lastIndex = lastIndex;
          }
        }
      }
      /**
       * Check whether the pattern is found in a given string.
       * @param {string} str The string to check.
       * @returns {boolean} `true` if the pattern was found in the string.
       */
      test(str) {
        const it = this.execAll(str);
        const ret = it.next();
        return !ret.done;
      }
      /**
       * Replace a given string.
       * @param {string} str The string to be replaced.
       * @param {(string|((...strs:string[])=>string))} replacer The string or function to replace. This is the same as the 2nd argument of `String.prototype.replace`.
       * @returns {string} The replaced string.
       */
      [Symbol.replace](str, replacer) {
        return typeof replacer === "function" ? replaceF(this, String(str), replacer) : replaceS(this, String(str), String(replacer));
      }
    };
    var IMPORT_TYPE = /^(?:Import|Export(?:All|Default|Named))Declaration$/u;
    var has = Function.call.bind(Object.hasOwnProperty);
    var READ = Symbol("read");
    var CALL = Symbol("call");
    var CONSTRUCT = Symbol("construct");
    var ESM = Symbol("esm");
    var requireCall = { require: { [CALL]: true } };
    function isModifiedGlobal(variable) {
      return variable == null || variable.defs.length !== 0 || variable.references.some((r) => r.isWrite());
    }
    function isPassThrough(node) {
      const parent = node.parent;
      switch (parent && parent.type) {
        case "ConditionalExpression":
          return parent.consequent === node || parent.alternate === node;
        case "LogicalExpression":
          return true;
        case "SequenceExpression":
          return parent.expressions[parent.expressions.length - 1] === node;
        case "ChainExpression":
          return true;
        default:
          return false;
      }
    }
    var ReferenceTracker = class {
      /**
       * Initialize this tracker.
       * @param {Scope} globalScope The global scope.
       * @param {object} [options] The options.
       * @param {"legacy"|"strict"} [options.mode="strict"] The mode to determine the ImportDeclaration's behavior for CJS modules.
       * @param {string[]} [options.globalObjectNames=["global","globalThis","self","window"]] The variable names for Global Object.
       */
      constructor(globalScope, {
        mode = "strict",
        globalObjectNames = ["global", "globalThis", "self", "window"]
      } = {}) {
        this.variableStack = [];
        this.globalScope = globalScope;
        this.mode = mode;
        this.globalObjectNames = globalObjectNames.slice(0);
      }
      /**
       * Iterate the references of global variables.
       * @param {object} traceMap The trace map.
       * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
       */
      *iterateGlobalReferences(traceMap) {
        for (const key of Object.keys(traceMap)) {
          const nextTraceMap = traceMap[key];
          const path = [key];
          const variable = this.globalScope.set.get(key);
          if (isModifiedGlobal(variable)) {
            continue;
          }
          yield* this._iterateVariableReferences(
            variable,
            path,
            nextTraceMap,
            true
          );
        }
        for (const key of this.globalObjectNames) {
          const path = [];
          const variable = this.globalScope.set.get(key);
          if (isModifiedGlobal(variable)) {
            continue;
          }
          yield* this._iterateVariableReferences(
            variable,
            path,
            traceMap,
            false
          );
        }
      }
      /**
       * Iterate the references of CommonJS modules.
       * @param {object} traceMap The trace map.
       * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
       */
      *iterateCjsReferences(traceMap) {
        for (const { node } of this.iterateGlobalReferences(requireCall)) {
          const key = getStringIfConstant(node.arguments[0]);
          if (key == null || !has(traceMap, key)) {
            continue;
          }
          const nextTraceMap = traceMap[key];
          const path = [key];
          if (nextTraceMap[READ]) {
            yield {
              node,
              path,
              type: READ,
              info: nextTraceMap[READ]
            };
          }
          yield* this._iteratePropertyReferences(node, path, nextTraceMap);
        }
      }
      /**
       * Iterate the references of ES modules.
       * @param {object} traceMap The trace map.
       * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
       */
      *iterateEsmReferences(traceMap) {
        const programNode = this.globalScope.block;
        for (const node of programNode.body) {
          if (!IMPORT_TYPE.test(node.type) || node.source == null) {
            continue;
          }
          const moduleId = node.source.value;
          if (!has(traceMap, moduleId)) {
            continue;
          }
          const nextTraceMap = traceMap[moduleId];
          const path = [moduleId];
          if (nextTraceMap[READ]) {
            yield { node, path, type: READ, info: nextTraceMap[READ] };
          }
          if (node.type === "ExportAllDeclaration") {
            for (const key of Object.keys(nextTraceMap)) {
              const exportTraceMap = nextTraceMap[key];
              if (exportTraceMap[READ]) {
                yield {
                  node,
                  path: path.concat(key),
                  type: READ,
                  info: exportTraceMap[READ]
                };
              }
            }
          } else {
            for (const specifier of node.specifiers) {
              const esm = has(nextTraceMap, ESM);
              const it = this._iterateImportReferences(
                specifier,
                path,
                esm ? nextTraceMap : this.mode === "legacy" ? { default: nextTraceMap, ...nextTraceMap } : { default: nextTraceMap }
              );
              if (esm) {
                yield* it;
              } else {
                for (const report of it) {
                  report.path = report.path.filter(exceptDefault);
                  if (report.path.length >= 2 || report.type !== READ) {
                    yield report;
                  }
                }
              }
            }
          }
        }
      }
      /**
       * Iterate the references for a given variable.
       * @param {Variable} variable The variable to iterate that references.
       * @param {string[]} path The current path.
       * @param {object} traceMap The trace map.
       * @param {boolean} shouldReport = The flag to report those references.
       * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
       */
      *_iterateVariableReferences(variable, path, traceMap, shouldReport) {
        if (this.variableStack.includes(variable)) {
          return;
        }
        this.variableStack.push(variable);
        try {
          for (const reference of variable.references) {
            if (!reference.isRead()) {
              continue;
            }
            const node = reference.identifier;
            if (shouldReport && traceMap[READ]) {
              yield { node, path, type: READ, info: traceMap[READ] };
            }
            yield* this._iteratePropertyReferences(node, path, traceMap);
          }
        } finally {
          this.variableStack.pop();
        }
      }
      /**
       * Iterate the references for a given AST node.
       * @param rootNode The AST node to iterate references.
       * @param {string[]} path The current path.
       * @param {object} traceMap The trace map.
       * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
       */
      //eslint-disable-next-line complexity
      *_iteratePropertyReferences(rootNode, path, traceMap) {
        let node = rootNode;
        while (isPassThrough(node)) {
          node = node.parent;
        }
        const parent = node.parent;
        if (parent.type === "MemberExpression") {
          if (parent.object === node) {
            const key = getPropertyName(parent);
            if (key == null || !has(traceMap, key)) {
              return;
            }
            path = path.concat(key);
            const nextTraceMap = traceMap[key];
            if (nextTraceMap[READ]) {
              yield {
                node: parent,
                path,
                type: READ,
                info: nextTraceMap[READ]
              };
            }
            yield* this._iteratePropertyReferences(
              parent,
              path,
              nextTraceMap
            );
          }
          return;
        }
        if (parent.type === "CallExpression") {
          if (parent.callee === node && traceMap[CALL]) {
            yield { node: parent, path, type: CALL, info: traceMap[CALL] };
          }
          return;
        }
        if (parent.type === "NewExpression") {
          if (parent.callee === node && traceMap[CONSTRUCT]) {
            yield {
              node: parent,
              path,
              type: CONSTRUCT,
              info: traceMap[CONSTRUCT]
            };
          }
          return;
        }
        if (parent.type === "AssignmentExpression") {
          if (parent.right === node) {
            yield* this._iterateLhsReferences(parent.left, path, traceMap);
            yield* this._iteratePropertyReferences(parent, path, traceMap);
          }
          return;
        }
        if (parent.type === "AssignmentPattern") {
          if (parent.right === node) {
            yield* this._iterateLhsReferences(parent.left, path, traceMap);
          }
          return;
        }
        if (parent.type === "VariableDeclarator") {
          if (parent.init === node) {
            yield* this._iterateLhsReferences(parent.id, path, traceMap);
          }
        }
      }
      /**
       * Iterate the references for a given Pattern node.
       * @param {Node} patternNode The Pattern node to iterate references.
       * @param {string[]} path The current path.
       * @param {object} traceMap The trace map.
       * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
       */
      *_iterateLhsReferences(patternNode, path, traceMap) {
        if (patternNode.type === "Identifier") {
          const variable = findVariable(this.globalScope, patternNode);
          if (variable != null) {
            yield* this._iterateVariableReferences(
              variable,
              path,
              traceMap,
              false
            );
          }
          return;
        }
        if (patternNode.type === "ObjectPattern") {
          for (const property of patternNode.properties) {
            const key = getPropertyName(property);
            if (key == null || !has(traceMap, key)) {
              continue;
            }
            const nextPath = path.concat(key);
            const nextTraceMap = traceMap[key];
            if (nextTraceMap[READ]) {
              yield {
                node: property,
                path: nextPath,
                type: READ,
                info: nextTraceMap[READ]
              };
            }
            yield* this._iterateLhsReferences(
              property.value,
              nextPath,
              nextTraceMap
            );
          }
          return;
        }
        if (patternNode.type === "AssignmentPattern") {
          yield* this._iterateLhsReferences(patternNode.left, path, traceMap);
        }
      }
      /**
       * Iterate the references for a given ModuleSpecifier node.
       * @param {Node} specifierNode The ModuleSpecifier node to iterate references.
       * @param {string[]} path The current path.
       * @param {object} traceMap The trace map.
       * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
       */
      *_iterateImportReferences(specifierNode, path, traceMap) {
        const type = specifierNode.type;
        if (type === "ImportSpecifier" || type === "ImportDefaultSpecifier") {
          const key = type === "ImportDefaultSpecifier" ? "default" : specifierNode.imported.name;
          if (!has(traceMap, key)) {
            return;
          }
          path = path.concat(key);
          const nextTraceMap = traceMap[key];
          if (nextTraceMap[READ]) {
            yield {
              node: specifierNode,
              path,
              type: READ,
              info: nextTraceMap[READ]
            };
          }
          yield* this._iterateVariableReferences(
            findVariable(this.globalScope, specifierNode.local),
            path,
            nextTraceMap,
            false
          );
          return;
        }
        if (type === "ImportNamespaceSpecifier") {
          yield* this._iterateVariableReferences(
            findVariable(this.globalScope, specifierNode.local),
            path,
            traceMap,
            false
          );
          return;
        }
        if (type === "ExportSpecifier") {
          const key = specifierNode.local.name;
          if (!has(traceMap, key)) {
            return;
          }
          path = path.concat(key);
          const nextTraceMap = traceMap[key];
          if (nextTraceMap[READ]) {
            yield {
              node: specifierNode,
              path,
              type: READ,
              info: nextTraceMap[READ]
            };
          }
        }
      }
    };
    ReferenceTracker.READ = READ;
    ReferenceTracker.CALL = CALL;
    ReferenceTracker.CONSTRUCT = CONSTRUCT;
    ReferenceTracker.ESM = ESM;
    function exceptDefault(name, index2) {
      return !(index2 === 1 && name === "default");
    }
    var index = {
      CALL,
      CONSTRUCT,
      ESM,
      findVariable,
      getFunctionHeadLocation,
      getFunctionNameWithKind,
      getInnermostScope,
      getPropertyName,
      getStaticValue,
      getStringIfConstant,
      hasSideEffect,
      isArrowToken,
      isClosingBraceToken,
      isClosingBracketToken,
      isClosingParenToken,
      isColonToken,
      isCommaToken,
      isCommentToken,
      isNotArrowToken,
      isNotClosingBraceToken,
      isNotClosingBracketToken,
      isNotClosingParenToken,
      isNotColonToken,
      isNotCommaToken,
      isNotCommentToken,
      isNotOpeningBraceToken,
      isNotOpeningBracketToken,
      isNotOpeningParenToken,
      isNotSemicolonToken,
      isOpeningBraceToken,
      isOpeningBracketToken,
      isOpeningParenToken,
      isParenthesized,
      isSemicolonToken,
      PatternMatcher,
      READ,
      ReferenceTracker
    };
    exports.CALL = CALL;
    exports.CONSTRUCT = CONSTRUCT;
    exports.ESM = ESM;
    exports.PatternMatcher = PatternMatcher;
    exports.READ = READ;
    exports.ReferenceTracker = ReferenceTracker;
    exports["default"] = index;
    exports.findVariable = findVariable;
    exports.getFunctionHeadLocation = getFunctionHeadLocation;
    exports.getFunctionNameWithKind = getFunctionNameWithKind;
    exports.getInnermostScope = getInnermostScope;
    exports.getPropertyName = getPropertyName;
    exports.getStaticValue = getStaticValue;
    exports.getStringIfConstant = getStringIfConstant;
    exports.hasSideEffect = hasSideEffect;
    exports.isArrowToken = isArrowToken;
    exports.isClosingBraceToken = isClosingBraceToken;
    exports.isClosingBracketToken = isClosingBracketToken;
    exports.isClosingParenToken = isClosingParenToken;
    exports.isColonToken = isColonToken;
    exports.isCommaToken = isCommaToken;
    exports.isCommentToken = isCommentToken;
    exports.isNotArrowToken = isNotArrowToken;
    exports.isNotClosingBraceToken = isNotClosingBraceToken;
    exports.isNotClosingBracketToken = isNotClosingBracketToken;
    exports.isNotClosingParenToken = isNotClosingParenToken;
    exports.isNotColonToken = isNotColonToken;
    exports.isNotCommaToken = isNotCommaToken;
    exports.isNotCommentToken = isNotCommentToken;
    exports.isNotOpeningBraceToken = isNotOpeningBraceToken;
    exports.isNotOpeningBracketToken = isNotOpeningBracketToken;
    exports.isNotOpeningParenToken = isNotOpeningParenToken;
    exports.isNotSemicolonToken = isNotSemicolonToken;
    exports.isOpeningBraceToken = isOpeningBraceToken;
    exports.isOpeningBracketToken = isOpeningBracketToken;
    exports.isOpeningParenToken = isOpeningParenToken;
    exports.isParenthesized = isParenthesized;
    exports.isSemicolonToken = isSemicolonToken;
  }
});

// ../../node_modules/eslint/lib/source-code/token-store/cursor.js
var require_cursor = __commonJS({
  "../../node_modules/eslint/lib/source-code/token-store/cursor.js"(exports, module) {
    "use strict";
    module.exports = class Cursor {
      /**
       * Initializes this cursor.
       */
      constructor() {
        this.current = null;
      }
      /**
       * Gets the first token.
       * This consumes this cursor.
       * @returns {Token|Comment} The first token or null.
       */
      getOneToken() {
        return this.moveNext() ? this.current : null;
      }
      /**
       * Gets the first tokens.
       * This consumes this cursor.
       * @returns {(Token|Comment)[]} All tokens.
       */
      getAllTokens() {
        const tokens = [];
        while (this.moveNext()) {
          tokens.push(this.current);
        }
        return tokens;
      }
      /**
       * Moves this cursor to the next token.
       * @returns {boolean} `true` if the next token exists.
       * @abstract
       */
      /* c8 ignore next */
      moveNext() {
        throw new Error("Not implemented.");
      }
    };
  }
});

// ../../node_modules/eslint/lib/source-code/token-store/utils.js
var require_utils = __commonJS({
  "../../node_modules/eslint/lib/source-code/token-store/utils.js"(exports) {
    "use strict";
    exports.search = function search(tokens, location) {
      for (let minIndex = 0, maxIndex = tokens.length - 1; minIndex <= maxIndex; ) {
        const index = (minIndex + maxIndex) / 2 | 0;
        const token = tokens[index];
        const tokenStartLocation = token.range[0];
        if (location <= tokenStartLocation) {
          if (index === minIndex) {
            return index;
          }
          maxIndex = index;
        } else {
          minIndex = index + 1;
        }
      }
      return tokens.length;
    };
    exports.getFirstIndex = function getFirstIndex(tokens, indexMap, startLoc) {
      if (startLoc in indexMap) {
        return indexMap[startLoc];
      }
      if (startLoc - 1 in indexMap) {
        const index = indexMap[startLoc - 1];
        const token = tokens[index];
        if (!token) {
          return tokens.length;
        }
        if (token.range[0] >= startLoc) {
          return index;
        }
        return index + 1;
      }
      return 0;
    };
    exports.getLastIndex = function getLastIndex(tokens, indexMap, endLoc) {
      if (endLoc in indexMap) {
        return indexMap[endLoc] - 1;
      }
      if (endLoc - 1 in indexMap) {
        const index = indexMap[endLoc - 1];
        const token = tokens[index];
        if (!token) {
          return tokens.length - 1;
        }
        if (token.range[1] > endLoc) {
          return index - 1;
        }
        return index;
      }
      return tokens.length - 1;
    };
  }
});

// ../../node_modules/eslint/lib/source-code/token-store/backward-token-comment-cursor.js
var require_backward_token_comment_cursor = __commonJS({
  "../../node_modules/eslint/lib/source-code/token-store/backward-token-comment-cursor.js"(exports, module) {
    "use strict";
    var Cursor = require_cursor();
    var utils = require_utils();
    module.exports = class BackwardTokenCommentCursor extends Cursor {
      /**
       * Initializes this cursor.
       * @param {Token[]} tokens The array of tokens.
       * @param {Comment[]} comments The array of comments.
       * @param {Object} indexMap The map from locations to indices in `tokens`.
       * @param {number} startLoc The start location of the iteration range.
       * @param {number} endLoc The end location of the iteration range.
       */
      constructor(tokens, comments, indexMap, startLoc, endLoc) {
        super();
        this.tokens = tokens;
        this.comments = comments;
        this.tokenIndex = utils.getLastIndex(tokens, indexMap, endLoc);
        this.commentIndex = utils.search(comments, endLoc) - 1;
        this.border = startLoc;
      }
      /** @inheritdoc */
      moveNext() {
        const token = this.tokenIndex >= 0 ? this.tokens[this.tokenIndex] : null;
        const comment = this.commentIndex >= 0 ? this.comments[this.commentIndex] : null;
        if (token && (!comment || token.range[1] > comment.range[1])) {
          this.current = token;
          this.tokenIndex -= 1;
        } else if (comment) {
          this.current = comment;
          this.commentIndex -= 1;
        } else {
          this.current = null;
        }
        return Boolean(this.current) && (this.border === -1 || this.current.range[0] >= this.border);
      }
    };
  }
});

// ../../node_modules/eslint/lib/source-code/token-store/backward-token-cursor.js
var require_backward_token_cursor = __commonJS({
  "../../node_modules/eslint/lib/source-code/token-store/backward-token-cursor.js"(exports, module) {
    "use strict";
    var Cursor = require_cursor();
    var utils = require_utils();
    module.exports = class BackwardTokenCursor extends Cursor {
      /**
       * Initializes this cursor.
       * @param {Token[]} tokens The array of tokens.
       * @param {Comment[]} comments The array of comments.
       * @param {Object} indexMap The map from locations to indices in `tokens`.
       * @param {number} startLoc The start location of the iteration range.
       * @param {number} endLoc The end location of the iteration range.
       */
      constructor(tokens, comments, indexMap, startLoc, endLoc) {
        super();
        this.tokens = tokens;
        this.index = utils.getLastIndex(tokens, indexMap, endLoc);
        this.indexEnd = utils.getFirstIndex(tokens, indexMap, startLoc);
      }
      /** @inheritdoc */
      moveNext() {
        if (this.index >= this.indexEnd) {
          this.current = this.tokens[this.index];
          this.index -= 1;
          return true;
        }
        return false;
      }
      /*
       *
       * Shorthand for performance.
       *
       */
      /** @inheritdoc */
      getOneToken() {
        return this.index >= this.indexEnd ? this.tokens[this.index] : null;
      }
    };
  }
});

// ../../node_modules/eslint/lib/source-code/token-store/decorative-cursor.js
var require_decorative_cursor = __commonJS({
  "../../node_modules/eslint/lib/source-code/token-store/decorative-cursor.js"(exports, module) {
    "use strict";
    var Cursor = require_cursor();
    module.exports = class DecorativeCursor extends Cursor {
      /**
       * Initializes this cursor.
       * @param {Cursor} cursor The cursor to be decorated.
       */
      constructor(cursor) {
        super();
        this.cursor = cursor;
      }
      /** @inheritdoc */
      moveNext() {
        const retv = this.cursor.moveNext();
        this.current = this.cursor.current;
        return retv;
      }
    };
  }
});

// ../../node_modules/eslint/lib/source-code/token-store/filter-cursor.js
var require_filter_cursor = __commonJS({
  "../../node_modules/eslint/lib/source-code/token-store/filter-cursor.js"(exports, module) {
    "use strict";
    var DecorativeCursor = require_decorative_cursor();
    module.exports = class FilterCursor extends DecorativeCursor {
      /**
       * Initializes this cursor.
       * @param {Cursor} cursor The cursor to be decorated.
       * @param {Function} predicate The predicate function to decide tokens this cursor iterates.
       */
      constructor(cursor, predicate) {
        super(cursor);
        this.predicate = predicate;
      }
      /** @inheritdoc */
      moveNext() {
        const predicate = this.predicate;
        while (super.moveNext()) {
          if (predicate(this.current)) {
            return true;
          }
        }
        return false;
      }
    };
  }
});

// ../../node_modules/eslint/lib/source-code/token-store/forward-token-comment-cursor.js
var require_forward_token_comment_cursor = __commonJS({
  "../../node_modules/eslint/lib/source-code/token-store/forward-token-comment-cursor.js"(exports, module) {
    "use strict";
    var Cursor = require_cursor();
    var utils = require_utils();
    module.exports = class ForwardTokenCommentCursor extends Cursor {
      /**
       * Initializes this cursor.
       * @param {Token[]} tokens The array of tokens.
       * @param {Comment[]} comments The array of comments.
       * @param {Object} indexMap The map from locations to indices in `tokens`.
       * @param {number} startLoc The start location of the iteration range.
       * @param {number} endLoc The end location of the iteration range.
       */
      constructor(tokens, comments, indexMap, startLoc, endLoc) {
        super();
        this.tokens = tokens;
        this.comments = comments;
        this.tokenIndex = utils.getFirstIndex(tokens, indexMap, startLoc);
        this.commentIndex = utils.search(comments, startLoc);
        this.border = endLoc;
      }
      /** @inheritdoc */
      moveNext() {
        const token = this.tokenIndex < this.tokens.length ? this.tokens[this.tokenIndex] : null;
        const comment = this.commentIndex < this.comments.length ? this.comments[this.commentIndex] : null;
        if (token && (!comment || token.range[0] < comment.range[0])) {
          this.current = token;
          this.tokenIndex += 1;
        } else if (comment) {
          this.current = comment;
          this.commentIndex += 1;
        } else {
          this.current = null;
        }
        return Boolean(this.current) && (this.border === -1 || this.current.range[1] <= this.border);
      }
    };
  }
});

// ../../node_modules/eslint/lib/source-code/token-store/forward-token-cursor.js
var require_forward_token_cursor = __commonJS({
  "../../node_modules/eslint/lib/source-code/token-store/forward-token-cursor.js"(exports, module) {
    "use strict";
    var Cursor = require_cursor();
    var utils = require_utils();
    module.exports = class ForwardTokenCursor extends Cursor {
      /**
       * Initializes this cursor.
       * @param {Token[]} tokens The array of tokens.
       * @param {Comment[]} comments The array of comments.
       * @param {Object} indexMap The map from locations to indices in `tokens`.
       * @param {number} startLoc The start location of the iteration range.
       * @param {number} endLoc The end location of the iteration range.
       */
      constructor(tokens, comments, indexMap, startLoc, endLoc) {
        super();
        this.tokens = tokens;
        this.index = utils.getFirstIndex(tokens, indexMap, startLoc);
        this.indexEnd = utils.getLastIndex(tokens, indexMap, endLoc);
      }
      /** @inheritdoc */
      moveNext() {
        if (this.index <= this.indexEnd) {
          this.current = this.tokens[this.index];
          this.index += 1;
          return true;
        }
        return false;
      }
      /*
       *
       * Shorthand for performance.
       *
       */
      /** @inheritdoc */
      getOneToken() {
        return this.index <= this.indexEnd ? this.tokens[this.index] : null;
      }
      /** @inheritdoc */
      getAllTokens() {
        return this.tokens.slice(this.index, this.indexEnd + 1);
      }
    };
  }
});

// ../../node_modules/eslint/lib/source-code/token-store/limit-cursor.js
var require_limit_cursor = __commonJS({
  "../../node_modules/eslint/lib/source-code/token-store/limit-cursor.js"(exports, module) {
    "use strict";
    var DecorativeCursor = require_decorative_cursor();
    module.exports = class LimitCursor extends DecorativeCursor {
      /**
       * Initializes this cursor.
       * @param {Cursor} cursor The cursor to be decorated.
       * @param {number} count The count of tokens this cursor iterates.
       */
      constructor(cursor, count) {
        super(cursor);
        this.count = count;
      }
      /** @inheritdoc */
      moveNext() {
        if (this.count > 0) {
          this.count -= 1;
          return super.moveNext();
        }
        return false;
      }
    };
  }
});

// ../../node_modules/eslint/lib/source-code/token-store/skip-cursor.js
var require_skip_cursor = __commonJS({
  "../../node_modules/eslint/lib/source-code/token-store/skip-cursor.js"(exports, module) {
    "use strict";
    var DecorativeCursor = require_decorative_cursor();
    module.exports = class SkipCursor extends DecorativeCursor {
      /**
       * Initializes this cursor.
       * @param {Cursor} cursor The cursor to be decorated.
       * @param {number} count The count of tokens this cursor skips.
       */
      constructor(cursor, count) {
        super(cursor);
        this.count = count;
      }
      /** @inheritdoc */
      moveNext() {
        while (this.count > 0) {
          this.count -= 1;
          if (!super.moveNext()) {
            return false;
          }
        }
        return super.moveNext();
      }
    };
  }
});

// ../../node_modules/eslint/lib/source-code/token-store/cursors.js
var require_cursors = __commonJS({
  "../../node_modules/eslint/lib/source-code/token-store/cursors.js"(exports) {
    "use strict";
    var BackwardTokenCommentCursor = require_backward_token_comment_cursor();
    var BackwardTokenCursor = require_backward_token_cursor();
    var FilterCursor = require_filter_cursor();
    var ForwardTokenCommentCursor = require_forward_token_comment_cursor();
    var ForwardTokenCursor = require_forward_token_cursor();
    var LimitCursor = require_limit_cursor();
    var SkipCursor = require_skip_cursor();
    var CursorFactory = class {
      /**
       * Initializes this cursor.
       * @param {Function} TokenCursor The class of the cursor which iterates tokens only.
       * @param {Function} TokenCommentCursor The class of the cursor which iterates the mix of tokens and comments.
       */
      constructor(TokenCursor, TokenCommentCursor) {
        this.TokenCursor = TokenCursor;
        this.TokenCommentCursor = TokenCommentCursor;
      }
      /**
       * Creates a base cursor instance that can be decorated by createCursor.
       * @param {Token[]} tokens The array of tokens.
       * @param {Comment[]} comments The array of comments.
       * @param {Object} indexMap The map from locations to indices in `tokens`.
       * @param {number} startLoc The start location of the iteration range.
       * @param {number} endLoc The end location of the iteration range.
       * @param {boolean} includeComments The flag to iterate comments as well.
       * @returns {Cursor} The created base cursor.
       */
      createBaseCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments) {
        const Cursor = includeComments ? this.TokenCommentCursor : this.TokenCursor;
        return new Cursor(tokens, comments, indexMap, startLoc, endLoc);
      }
      /**
       * Creates a cursor that iterates tokens with normalized options.
       * @param {Token[]} tokens The array of tokens.
       * @param {Comment[]} comments The array of comments.
       * @param {Object} indexMap The map from locations to indices in `tokens`.
       * @param {number} startLoc The start location of the iteration range.
       * @param {number} endLoc The end location of the iteration range.
       * @param {boolean} includeComments The flag to iterate comments as well.
       * @param {Function|null} filter The predicate function to choose tokens.
       * @param {number} skip The count of tokens the cursor skips.
       * @param {number} count The maximum count of tokens the cursor iterates. Zero is no iteration for backward compatibility.
       * @returns {Cursor} The created cursor.
       */
      createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, skip, count) {
        let cursor = this.createBaseCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments);
        if (filter) {
          cursor = new FilterCursor(cursor, filter);
        }
        if (skip >= 1) {
          cursor = new SkipCursor(cursor, skip);
        }
        if (count >= 0) {
          cursor = new LimitCursor(cursor, count);
        }
        return cursor;
      }
    };
    exports.forward = new CursorFactory(ForwardTokenCursor, ForwardTokenCommentCursor);
    exports.backward = new CursorFactory(BackwardTokenCursor, BackwardTokenCommentCursor);
  }
});

// ../../node_modules/eslint/lib/source-code/token-store/padded-token-cursor.js
var require_padded_token_cursor = __commonJS({
  "../../node_modules/eslint/lib/source-code/token-store/padded-token-cursor.js"(exports, module) {
    "use strict";
    var ForwardTokenCursor = require_forward_token_cursor();
    module.exports = class PaddedTokenCursor extends ForwardTokenCursor {
      /**
       * Initializes this cursor.
       * @param {Token[]} tokens The array of tokens.
       * @param {Comment[]} comments The array of comments.
       * @param {Object} indexMap The map from locations to indices in `tokens`.
       * @param {number} startLoc The start location of the iteration range.
       * @param {number} endLoc The end location of the iteration range.
       * @param {number} beforeCount The number of tokens this cursor iterates before start.
       * @param {number} afterCount The number of tokens this cursor iterates after end.
       */
      constructor(tokens, comments, indexMap, startLoc, endLoc, beforeCount, afterCount) {
        super(tokens, comments, indexMap, startLoc, endLoc);
        this.index = Math.max(0, this.index - beforeCount);
        this.indexEnd = Math.min(tokens.length - 1, this.indexEnd + afterCount);
      }
    };
  }
});

// ../../node_modules/eslint/lib/source-code/token-store/index.js
var require_token_store = __commonJS({
  "../../node_modules/eslint/lib/source-code/token-store/index.js"(exports, module) {
    "use strict";
    var assert = require_assert();
    var { isCommentToken } = require_eslint_utils();
    var cursors = require_cursors();
    var ForwardTokenCursor = require_forward_token_cursor();
    var PaddedTokenCursor = require_padded_token_cursor();
    var utils = require_utils();
    var TOKENS = Symbol("tokens");
    var COMMENTS = Symbol("comments");
    var INDEX_MAP = Symbol("indexMap");
    function createIndexMap(tokens, comments) {
      const map = /* @__PURE__ */ Object.create(null);
      let tokenIndex = 0;
      let commentIndex = 0;
      let nextStart = 0;
      let range = null;
      while (tokenIndex < tokens.length || commentIndex < comments.length) {
        nextStart = commentIndex < comments.length ? comments[commentIndex].range[0] : Number.MAX_SAFE_INTEGER;
        while (tokenIndex < tokens.length && (range = tokens[tokenIndex].range)[0] < nextStart) {
          map[range[0]] = tokenIndex;
          map[range[1] - 1] = tokenIndex;
          tokenIndex += 1;
        }
        nextStart = tokenIndex < tokens.length ? tokens[tokenIndex].range[0] : Number.MAX_SAFE_INTEGER;
        while (commentIndex < comments.length && (range = comments[commentIndex].range)[0] < nextStart) {
          map[range[0]] = tokenIndex;
          map[range[1] - 1] = tokenIndex;
          commentIndex += 1;
        }
      }
      return map;
    }
    function createCursorWithSkip(factory, tokens, comments, indexMap, startLoc, endLoc, opts) {
      let includeComments = false;
      let skip = 0;
      let filter = null;
      if (typeof opts === "number") {
        skip = opts | 0;
      } else if (typeof opts === "function") {
        filter = opts;
      } else if (opts) {
        includeComments = !!opts.includeComments;
        skip = opts.skip | 0;
        filter = opts.filter || null;
      }
      assert(skip >= 0, "options.skip should be zero or a positive integer.");
      assert(!filter || typeof filter === "function", "options.filter should be a function.");
      return factory.createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, skip, -1);
    }
    function createCursorWithCount(factory, tokens, comments, indexMap, startLoc, endLoc, opts) {
      let includeComments = false;
      let count = 0;
      let countExists = false;
      let filter = null;
      if (typeof opts === "number") {
        count = opts | 0;
        countExists = true;
      } else if (typeof opts === "function") {
        filter = opts;
      } else if (opts) {
        includeComments = !!opts.includeComments;
        count = opts.count | 0;
        countExists = typeof opts.count === "number";
        filter = opts.filter || null;
      }
      assert(count >= 0, "options.count should be zero or a positive integer.");
      assert(!filter || typeof filter === "function", "options.filter should be a function.");
      return factory.createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, 0, countExists ? count : -1);
    }
    function createCursorWithPadding(tokens, comments, indexMap, startLoc, endLoc, beforeCount, afterCount) {
      if (typeof beforeCount === "undefined" && typeof afterCount === "undefined") {
        return new ForwardTokenCursor(tokens, comments, indexMap, startLoc, endLoc);
      }
      if (typeof beforeCount === "number" || typeof beforeCount === "undefined") {
        return new PaddedTokenCursor(tokens, comments, indexMap, startLoc, endLoc, beforeCount | 0, afterCount | 0);
      }
      return createCursorWithCount(cursors.forward, tokens, comments, indexMap, startLoc, endLoc, beforeCount);
    }
    function getAdjacentCommentTokensFromCursor(cursor) {
      const tokens = [];
      let currentToken = cursor.getOneToken();
      while (currentToken && isCommentToken(currentToken)) {
        tokens.push(currentToken);
        currentToken = cursor.getOneToken();
      }
      return tokens;
    }
    module.exports = class TokenStore {
      /**
       * Initializes this token store.
       * @param {Token[]} tokens The array of tokens.
       * @param {Comment[]} comments The array of comments.
       */
      constructor(tokens, comments) {
        this[TOKENS] = tokens;
        this[COMMENTS] = comments;
        this[INDEX_MAP] = createIndexMap(tokens, comments);
      }
      //--------------------------------------------------------------------------
      // Gets single token.
      //--------------------------------------------------------------------------
      /**
       * Gets the token starting at the specified index.
       * @param {number} offset Index of the start of the token's range.
       * @param {Object} [options=0] The option object.
       * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.
       * @returns {Token|null} The token starting at index, or null if no such token.
       */
      getTokenByRangeStart(offset, options) {
        const includeComments = options && options.includeComments;
        const token = cursors.forward.createBaseCursor(
          this[TOKENS],
          this[COMMENTS],
          this[INDEX_MAP],
          offset,
          -1,
          includeComments
        ).getOneToken();
        if (token && token.range[0] === offset) {
          return token;
        }
        return null;
      }
      /**
       * Gets the first token of the given node.
       * @param {ASTNode} node The AST node.
       * @param {number|Function|Object} [options=0] The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`.
       * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.
       * @param {Function|null} [options.filter=null] The predicate function to choose tokens.
       * @param {number} [options.skip=0] The count of tokens the cursor skips.
       * @returns {Token|null} An object representing the token.
       */
      getFirstToken(node, options) {
        return createCursorWithSkip(
          cursors.forward,
          this[TOKENS],
          this[COMMENTS],
          this[INDEX_MAP],
          node.range[0],
          node.range[1],
          options
        ).getOneToken();
      }
      /**
       * Gets the last token of the given node.
       * @param {ASTNode} node The AST node.
       * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()
       * @returns {Token|null} An object representing the token.
       */
      getLastToken(node, options) {
        return createCursorWithSkip(
          cursors.backward,
          this[TOKENS],
          this[COMMENTS],
          this[INDEX_MAP],
          node.range[0],
          node.range[1],
          options
        ).getOneToken();
      }
      /**
       * Gets the token that precedes a given node or token.
       * @param {ASTNode|Token|Comment} node The AST node or token.
       * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()
       * @returns {Token|null} An object representing the token.
       */
      getTokenBefore(node, options) {
        return createCursorWithSkip(
          cursors.backward,
          this[TOKENS],
          this[COMMENTS],
          this[INDEX_MAP],
          -1,
          node.range[0],
          options
        ).getOneToken();
      }
      /**
       * Gets the token that follows a given node or token.
       * @param {ASTNode|Token|Comment} node The AST node or token.
       * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()
       * @returns {Token|null} An object representing the token.
       */
      getTokenAfter(node, options) {
        return createCursorWithSkip(
          cursors.forward,
          this[TOKENS],
          this[COMMENTS],
          this[INDEX_MAP],
          node.range[1],
          -1,
          options
        ).getOneToken();
      }
      /**
       * Gets the first token between two non-overlapping nodes.
       * @param {ASTNode|Token|Comment} left Node before the desired token range.
       * @param {ASTNode|Token|Comment} right Node after the desired token range.
       * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()
       * @returns {Token|null} An object representing the token.
       */
      getFirstTokenBetween(left, right, options) {
        return createCursorWithSkip(
          cursors.forward,
          this[TOKENS],
          this[COMMENTS],
          this[INDEX_MAP],
          left.range[1],
          right.range[0],
          options
        ).getOneToken();
      }
      /**
       * Gets the last token between two non-overlapping nodes.
       * @param {ASTNode|Token|Comment} left Node before the desired token range.
       * @param {ASTNode|Token|Comment} right Node after the desired token range.
       * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()
       * @returns {Token|null} An object representing the token.
       */
      getLastTokenBetween(left, right, options) {
        return createCursorWithSkip(
          cursors.backward,
          this[TOKENS],
          this[COMMENTS],
          this[INDEX_MAP],
          left.range[1],
          right.range[0],
          options
        ).getOneToken();
      }
      /**
       * Gets the token that precedes a given node or token in the token stream.
       * This is defined for backward compatibility. Use `includeComments` option instead.
       * TODO: We have a plan to remove this in a future major version.
       * @param {ASTNode|Token|Comment} node The AST node or token.
       * @param {number} [skip=0] A number of tokens to skip.
       * @returns {Token|null} An object representing the token.
       * @deprecated
       */
      getTokenOrCommentBefore(node, skip) {
        return this.getTokenBefore(node, { includeComments: true, skip });
      }
      /**
       * Gets the token that follows a given node or token in the token stream.
       * This is defined for backward compatibility. Use `includeComments` option instead.
       * TODO: We have a plan to remove this in a future major version.
       * @param {ASTNode|Token|Comment} node The AST node or token.
       * @param {number} [skip=0] A number of tokens to skip.
       * @returns {Token|null} An object representing the token.
       * @deprecated
       */
      getTokenOrCommentAfter(node, skip) {
        return this.getTokenAfter(node, { includeComments: true, skip });
      }
      //--------------------------------------------------------------------------
      // Gets multiple tokens.
      //--------------------------------------------------------------------------
      /**
       * Gets the first `count` tokens of the given node.
       * @param {ASTNode} node The AST node.
       * @param {number|Function|Object} [options=0] The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`.
       * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.
       * @param {Function|null} [options.filter=null] The predicate function to choose tokens.
       * @param {number} [options.count=0] The maximum count of tokens the cursor iterates.
       * @returns {Token[]} Tokens.
       */
      getFirstTokens(node, options) {
        return createCursorWithCount(
          cursors.forward,
          this[TOKENS],
          this[COMMENTS],
          this[INDEX_MAP],
          node.range[0],
          node.range[1],
          options
        ).getAllTokens();
      }
      /**
       * Gets the last `count` tokens of the given node.
       * @param {ASTNode} node The AST node.
       * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()
       * @returns {Token[]} Tokens.
       */
      getLastTokens(node, options) {
        return createCursorWithCount(
          cursors.backward,
          this[TOKENS],
          this[COMMENTS],
          this[INDEX_MAP],
          node.range[0],
          node.range[1],
          options
        ).getAllTokens().reverse();
      }
      /**
       * Gets the `count` tokens that precedes a given node or token.
       * @param {ASTNode|Token|Comment} node The AST node or token.
       * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()
       * @returns {Token[]} Tokens.
       */
      getTokensBefore(node, options) {
        return createCursorWithCount(
          cursors.backward,
          this[TOKENS],
          this[COMMENTS],
          this[INDEX_MAP],
          -1,
          node.range[0],
          options
        ).getAllTokens().reverse();
      }
      /**
       * Gets the `count` tokens that follows a given node or token.
       * @param {ASTNode|Token|Comment} node The AST node or token.
       * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()
       * @returns {Token[]} Tokens.
       */
      getTokensAfter(node, options) {
        return createCursorWithCount(
          cursors.forward,
          this[TOKENS],
          this[COMMENTS],
          this[INDEX_MAP],
          node.range[1],
          -1,
          options
        ).getAllTokens();
      }
      /**
       * Gets the first `count` tokens between two non-overlapping nodes.
       * @param {ASTNode|Token|Comment} left Node before the desired token range.
       * @param {ASTNode|Token|Comment} right Node after the desired token range.
       * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()
       * @returns {Token[]} Tokens between left and right.
       */
      getFirstTokensBetween(left, right, options) {
        return createCursorWithCount(
          cursors.forward,
          this[TOKENS],
          this[COMMENTS],
          this[INDEX_MAP],
          left.range[1],
          right.range[0],
          options
        ).getAllTokens();
      }
      /**
       * Gets the last `count` tokens between two non-overlapping nodes.
       * @param {ASTNode|Token|Comment} left Node before the desired token range.
       * @param {ASTNode|Token|Comment} right Node after the desired token range.
       * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()
       * @returns {Token[]} Tokens between left and right.
       */
      getLastTokensBetween(left, right, options) {
        return createCursorWithCount(
          cursors.backward,
          this[TOKENS],
          this[COMMENTS],
          this[INDEX_MAP],
          left.range[1],
          right.range[0],
          options
        ).getAllTokens().reverse();
      }
      /**
       * Gets all tokens that are related to the given node.
       * @param {ASTNode} node The AST node.
       * @param {Function|Object} options The option object. If this is a function then it's `options.filter`.
       * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.
       * @param {Function|null} [options.filter=null] The predicate function to choose tokens.
       * @param {number} [options.count=0] The maximum count of tokens the cursor iterates.
       * @returns {Token[]} Array of objects representing tokens.
       */
      /**
       * Gets all tokens that are related to the given node.
       * @param {ASTNode} node The AST node.
       * @param {int} [beforeCount=0] The number of tokens before the node to retrieve.
       * @param {int} [afterCount=0] The number of tokens after the node to retrieve.
       * @returns {Token[]} Array of objects representing tokens.
       */
      getTokens(node, beforeCount, afterCount) {
        return createCursorWithPadding(
          this[TOKENS],
          this[COMMENTS],
          this[INDEX_MAP],
          node.range[0],
          node.range[1],
          beforeCount,
          afterCount
        ).getAllTokens();
      }
      /**
       * Gets all of the tokens between two non-overlapping nodes.
       * @param {ASTNode|Token|Comment} left Node before the desired token range.
       * @param {ASTNode|Token|Comment} right Node after the desired token range.
       * @param {Function|Object} options The option object. If this is a function then it's `options.filter`.
       * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.
       * @param {Function|null} [options.filter=null] The predicate function to choose tokens.
       * @param {number} [options.count=0] The maximum count of tokens the cursor iterates.
       * @returns {Token[]} Tokens between left and right.
       */
      /**
       * Gets all of the tokens between two non-overlapping nodes.
       * @param {ASTNode|Token|Comment} left Node before the desired token range.
       * @param {ASTNode|Token|Comment} right Node after the desired token range.
       * @param {int} [padding=0] Number of extra tokens on either side of center.
       * @returns {Token[]} Tokens between left and right.
       */
      getTokensBetween(left, right, padding) {
        return createCursorWithPadding(
          this[TOKENS],
          this[COMMENTS],
          this[INDEX_MAP],
          left.range[1],
          right.range[0],
          padding,
          padding
        ).getAllTokens();
      }
      //--------------------------------------------------------------------------
      // Others.
      //--------------------------------------------------------------------------
      /**
       * Checks whether any comments exist or not between the given 2 nodes.
       * @param {ASTNode} left The node to check.
       * @param {ASTNode} right The node to check.
       * @returns {boolean} `true` if one or more comments exist.
       */
      commentsExistBetween(left, right) {
        const index = utils.search(this[COMMENTS], left.range[1]);
        return index < this[COMMENTS].length && this[COMMENTS][index].range[1] <= right.range[0];
      }
      /**
       * Gets all comment tokens directly before the given node or token.
       * @param {ASTNode|token} nodeOrToken The AST node or token to check for adjacent comment tokens.
       * @returns {Array} An array of comments in occurrence order.
       */
      getCommentsBefore(nodeOrToken) {
        const cursor = createCursorWithCount(
          cursors.backward,
          this[TOKENS],
          this[COMMENTS],
          this[INDEX_MAP],
          -1,
          nodeOrToken.range[0],
          { includeComments: true }
        );
        return getAdjacentCommentTokensFromCursor(cursor).reverse();
      }
      /**
       * Gets all comment tokens directly after the given node or token.
       * @param {ASTNode|token} nodeOrToken The AST node or token to check for adjacent comment tokens.
       * @returns {Array} An array of comments in occurrence order.
       */
      getCommentsAfter(nodeOrToken) {
        const cursor = createCursorWithCount(
          cursors.forward,
          this[TOKENS],
          this[COMMENTS],
          this[INDEX_MAP],
          nodeOrToken.range[1],
          -1,
          { includeComments: true }
        );
        return getAdjacentCommentTokensFromCursor(cursor);
      }
      /**
       * Gets all comment tokens inside the given node.
       * @param {ASTNode} node The AST node to get the comments for.
       * @returns {Array} An array of comments in occurrence order.
       */
      getCommentsInside(node) {
        return this.getTokens(node, {
          includeComments: true,
          filter: isCommentToken
        });
      }
    };
  }
});

// ../../node_modules/eslint/lib/source-code/source-code.js
var require_source_code = __commonJS({
  "../../node_modules/eslint/lib/source-code/source-code.js"(exports, module) {
    "use strict";
    var { isCommentToken } = require_eslint_utils();
    var TokenStore = require_token_store();
    var astUtils = require_ast_utils();
    var Traverser = require_traverser();
    function validate(ast) {
      if (!ast.tokens) {
        throw new Error("AST is missing the tokens array.");
      }
      if (!ast.comments) {
        throw new Error("AST is missing the comments array.");
      }
      if (!ast.loc) {
        throw new Error("AST is missing location information.");
      }
      if (!ast.range) {
        throw new Error("AST is missing range information");
      }
    }
    function looksLikeExport(astNode) {
      return astNode.type === "ExportDefaultDeclaration" || astNode.type === "ExportNamedDeclaration" || astNode.type === "ExportAllDeclaration" || astNode.type === "ExportSpecifier";
    }
    function sortedMerge(tokens, comments) {
      const result = [];
      let tokenIndex = 0;
      let commentIndex = 0;
      while (tokenIndex < tokens.length || commentIndex < comments.length) {
        if (commentIndex >= comments.length || tokenIndex < tokens.length && tokens[tokenIndex].range[0] < comments[commentIndex].range[0]) {
          result.push(tokens[tokenIndex++]);
        } else {
          result.push(comments[commentIndex++]);
        }
      }
      return result;
    }
    function nodesOrTokensOverlap(first, second) {
      return first.range[0] <= second.range[0] && first.range[1] >= second.range[0] || second.range[0] <= first.range[0] && second.range[1] >= first.range[0];
    }
    function isSpaceBetween(sourceCode, first, second, checkInsideOfJSXText) {
      if (nodesOrTokensOverlap(first, second)) {
        return false;
      }
      const [startingNodeOrToken, endingNodeOrToken] = first.range[1] <= second.range[0] ? [first, second] : [second, first];
      const firstToken = sourceCode.getLastToken(startingNodeOrToken) || startingNodeOrToken;
      const finalToken = sourceCode.getFirstToken(endingNodeOrToken) || endingNodeOrToken;
      let currentToken = firstToken;
      while (currentToken !== finalToken) {
        const nextToken = sourceCode.getTokenAfter(currentToken, { includeComments: true });
        if (currentToken.range[1] !== nextToken.range[0] || /*
         * For backward compatibility, check spaces in JSXText.
         * https://github.com/eslint/eslint/issues/12614
         */
        checkInsideOfJSXText && nextToken !== finalToken && nextToken.type === "JSXText" && /\s/u.test(nextToken.value)) {
          return true;
        }
        currentToken = nextToken;
      }
      return false;
    }
    var caches = Symbol("caches");
    var SourceCode = class extends TokenStore {
      /**
       * @param {string|Object} textOrConfig The source code text or config object.
       * @param {string} textOrConfig.text The source code text.
       * @param {ASTNode} textOrConfig.ast The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.
       * @param {Object|null} textOrConfig.parserServices The parser services.
       * @param {ScopeManager|null} textOrConfig.scopeManager The scope of this source code.
       * @param {Object|null} textOrConfig.visitorKeys The visitor keys to traverse AST.
       * @param {ASTNode} [astIfNoConfig] The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.
       */
      constructor(textOrConfig, astIfNoConfig) {
        let text, ast, parserServices, scopeManager, visitorKeys;
        if (typeof textOrConfig === "string") {
          text = textOrConfig;
          ast = astIfNoConfig;
        } else if (typeof textOrConfig === "object" && textOrConfig !== null) {
          text = textOrConfig.text;
          ast = textOrConfig.ast;
          parserServices = textOrConfig.parserServices;
          scopeManager = textOrConfig.scopeManager;
          visitorKeys = textOrConfig.visitorKeys;
        }
        validate(ast);
        super(ast.tokens, ast.comments);
        this[caches] = /* @__PURE__ */ new Map([
          ["scopes", /* @__PURE__ */ new WeakMap()]
        ]);
        this.hasBOM = text.charCodeAt(0) === 65279;
        this.text = this.hasBOM ? text.slice(1) : text;
        this.ast = ast;
        this.parserServices = parserServices || {};
        this.scopeManager = scopeManager || null;
        this.visitorKeys = visitorKeys || Traverser.DEFAULT_VISITOR_KEYS;
        const shebangMatched = this.text.match(astUtils.shebangPattern);
        const hasShebang = shebangMatched && ast.comments.length && ast.comments[0].value === shebangMatched[1];
        if (hasShebang) {
          ast.comments[0].type = "Shebang";
        }
        this.tokensAndComments = sortedMerge(ast.tokens, ast.comments);
        this.lines = [];
        this.lineStartIndices = [0];
        const lineEndingPattern = astUtils.createGlobalLinebreakMatcher();
        let match;
        while (match = lineEndingPattern.exec(this.text)) {
          this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1], match.index));
          this.lineStartIndices.push(match.index + match[0].length);
        }
        this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1]));
        this._commentCache = /* @__PURE__ */ new WeakMap();
        Object.freeze(this);
        Object.freeze(this.lines);
      }
      /**
       * Split the source code into multiple lines based on the line delimiters.
       * @param {string} text Source code as a string.
       * @returns {string[]} Array of source code lines.
       * @public
       */
      static splitLines(text) {
        return text.split(astUtils.createGlobalLinebreakMatcher());
      }
      /**
       * Gets the source code for the given node.
       * @param {ASTNode} [node] The AST node to get the text for.
       * @param {int} [beforeCount] The number of characters before the node to retrieve.
       * @param {int} [afterCount] The number of characters after the node to retrieve.
       * @returns {string} The text representing the AST node.
       * @public
       */
      getText(node, beforeCount, afterCount) {
        if (node) {
          return this.text.slice(
            Math.max(node.range[0] - (beforeCount || 0), 0),
            node.range[1] + (afterCount || 0)
          );
        }
        return this.text;
      }
      /**
       * Gets the entire source text split into an array of lines.
       * @returns {Array} The source text as an array of lines.
       * @public
       */
      getLines() {
        return this.lines;
      }
      /**
       * Retrieves an array containing all comments in the source code.
       * @returns {ASTNode[]} An array of comment nodes.
       * @public
       */
      getAllComments() {
        return this.ast.comments;
      }
      /**
       * Gets all comments for the given node.
       * @param {ASTNode} node The AST node to get the comments for.
       * @returns {Object} An object containing a leading and trailing array
       *      of comments indexed by their position.
       * @public
       * @deprecated replaced by getCommentsBefore(), getCommentsAfter(), and getCommentsInside().
       */
      getComments(node) {
        if (this._commentCache.has(node)) {
          return this._commentCache.get(node);
        }
        const comments = {
          leading: [],
          trailing: []
        };
        if (node.type === "Program") {
          if (node.body.length === 0) {
            comments.leading = node.comments;
          }
        } else {
          if ((node.type === "BlockStatement" || node.type === "ClassBody") && node.body.length === 0 || node.type === "ObjectExpression" && node.properties.length === 0 || node.type === "ArrayExpression" && node.elements.length === 0 || node.type === "SwitchStatement" && node.cases.length === 0) {
            comments.trailing = this.getTokens(node, {
              includeComments: true,
              filter: isCommentToken
            });
          }
          let currentToken = this.getTokenBefore(node, { includeComments: true });
          while (currentToken && isCommentToken(currentToken)) {
            if (node.parent && node.parent.type !== "Program" && currentToken.start < node.parent.start) {
              break;
            }
            comments.leading.push(currentToken);
            currentToken = this.getTokenBefore(currentToken, { includeComments: true });
          }
          comments.leading.reverse();
          currentToken = this.getTokenAfter(node, { includeComments: true });
          while (currentToken && isCommentToken(currentToken)) {
            if (node.parent && node.parent.type !== "Program" && currentToken.end > node.parent.end) {
              break;
            }
            comments.trailing.push(currentToken);
            currentToken = this.getTokenAfter(currentToken, { includeComments: true });
          }
        }
        this._commentCache.set(node, comments);
        return comments;
      }
      /**
       * Retrieves the JSDoc comment for a given node.
       * @param {ASTNode} node The AST node to get the comment for.
       * @returns {Token|null} The Block comment token containing the JSDoc comment
       *      for the given node or null if not found.
       * @public
       * @deprecated
       */
      getJSDocComment(node) {
        const findJSDocComment = (astNode) => {
          const tokenBefore = this.getTokenBefore(astNode, { includeComments: true });
          if (tokenBefore && isCommentToken(tokenBefore) && tokenBefore.type === "Block" && tokenBefore.value.charAt(0) === "*" && astNode.loc.start.line - tokenBefore.loc.end.line <= 1) {
            return tokenBefore;
          }
          return null;
        };
        let parent = node.parent;
        switch (node.type) {
          case "ClassDeclaration":
          case "FunctionDeclaration":
            return findJSDocComment(looksLikeExport(parent) ? parent : node);
          case "ClassExpression":
            return findJSDocComment(parent.parent);
          case "ArrowFunctionExpression":
          case "FunctionExpression":
            if (parent.type !== "CallExpression" && parent.type !== "NewExpression") {
              while (!this.getCommentsBefore(parent).length && !/Function/u.test(parent.type) && parent.type !== "MethodDefinition" && parent.type !== "Property") {
                parent = parent.parent;
                if (!parent) {
                  break;
                }
              }
              if (parent && parent.type !== "FunctionDeclaration" && parent.type !== "Program") {
                return findJSDocComment(parent);
              }
            }
            return findJSDocComment(node);
          default:
            return null;
        }
      }
      /**
       * Gets the deepest node containing a range index.
       * @param {int} index Range index of the desired node.
       * @returns {ASTNode} The node if found or null if not found.
       * @public
       */
      getNodeByRangeIndex(index) {
        let result = null;
        Traverser.traverse(this.ast, {
          visitorKeys: this.visitorKeys,
          enter(node) {
            if (node.range[0] <= index && index < node.range[1]) {
              result = node;
            } else {
              this.skip();
            }
          },
          leave(node) {
            if (node === result) {
              this.break();
            }
          }
        });
        return result;
      }
      /**
       * Determines if two nodes or tokens have at least one whitespace character
       * between them. Order does not matter. Returns false if the given nodes or
       * tokens overlap.
       * @param {ASTNode|Token} first The first node or token to check between.
       * @param {ASTNode|Token} second The second node or token to check between.
       * @returns {boolean} True if there is a whitespace character between
       * any of the tokens found between the two given nodes or tokens.
       * @public
       */
      isSpaceBetween(first, second) {
        return isSpaceBetween(this, first, second, false);
      }
      /**
       * Determines if two nodes or tokens have at least one whitespace character
       * between them. Order does not matter. Returns false if the given nodes or
       * tokens overlap.
       * For backward compatibility, this method returns true if there are
       * `JSXText` tokens that contain whitespaces between the two.
       * @param {ASTNode|Token} first The first node or token to check between.
       * @param {ASTNode|Token} second The second node or token to check between.
       * @returns {boolean} True if there is a whitespace character between
       * any of the tokens found between the two given nodes or tokens.
       * @deprecated in favor of isSpaceBetween().
       * @public
       */
      isSpaceBetweenTokens(first, second) {
        return isSpaceBetween(this, first, second, true);
      }
      /**
       * Converts a source text index into a (line, column) pair.
       * @param {number} index The index of a character in a file
       * @throws {TypeError} If non-numeric index or index out of range.
       * @returns {Object} A {line, column} location object with a 0-indexed column
       * @public
       */
      getLocFromIndex(index) {
        if (typeof index !== "number") {
          throw new TypeError("Expected `index` to be a number.");
        }
        if (index < 0 || index > this.text.length) {
          throw new RangeError(`Index out of range (requested index ${index}, but source text has length ${this.text.length}).`);
        }
        if (index === this.text.length) {
          return { line: this.lines.length, column: this.lines[this.lines.length - 1].length };
        }
        const lineNumber = index >= this.lineStartIndices[this.lineStartIndices.length - 1] ? this.lineStartIndices.length : this.lineStartIndices.findIndex((el) => index < el);
        return { line: lineNumber, column: index - this.lineStartIndices[lineNumber - 1] };
      }
      /**
       * Converts a (line, column) pair into a range index.
       * @param {Object} loc A line/column location
       * @param {number} loc.line The line number of the location (1-indexed)
       * @param {number} loc.column The column number of the location (0-indexed)
       * @throws {TypeError|RangeError} If `loc` is not an object with a numeric
       *   `line` and `column`, if the `line` is less than or equal to zero or
       *   the line or column is out of the expected range.
       * @returns {number} The range index of the location in the file.
       * @public
       */
      getIndexFromLoc(loc) {
        if (typeof loc !== "object" || typeof loc.line !== "number" || typeof loc.column !== "number") {
          throw new TypeError("Expected `loc` to be an object with numeric `line` and `column` properties.");
        }
        if (loc.line <= 0) {
          throw new RangeError(`Line number out of range (line ${loc.line} requested). Line numbers should be 1-based.`);
        }
        if (loc.line > this.lineStartIndices.length) {
          throw new RangeError(`Line number out of range (line ${loc.line} requested, but only ${this.lineStartIndices.length} lines present).`);
        }
        const lineStartIndex = this.lineStartIndices[loc.line - 1];
        const lineEndIndex = loc.line === this.lineStartIndices.length ? this.text.length : this.lineStartIndices[loc.line];
        const positionIndex = lineStartIndex + loc.column;
        if (loc.line === this.lineStartIndices.length && positionIndex > lineEndIndex || loc.line < this.lineStartIndices.length && positionIndex >= lineEndIndex) {
          throw new RangeError(`Column number out of range (column ${loc.column} requested, but the length of line ${loc.line} is ${lineEndIndex - lineStartIndex}).`);
        }
        return positionIndex;
      }
      /**
       * Gets the scope for the given node
       * @param {ASTNode} currentNode The node to get the scope of
       * @returns {eslint-scope.Scope} The scope information for this node
       * @throws {TypeError} If the `currentNode` argument is missing.
       */
      getScope(currentNode) {
        if (!currentNode) {
          throw new TypeError("Missing required argument: node.");
        }
        const cache = this[caches].get("scopes");
        const cachedScope = cache.get(currentNode);
        if (cachedScope) {
          return cachedScope;
        }
        const inner = currentNode.type !== "Program";
        for (let node = currentNode; node; node = node.parent) {
          const scope = this.scopeManager.acquire(node, inner);
          if (scope) {
            if (scope.type === "function-expression-name") {
              cache.set(currentNode, scope.childScopes[0]);
              return scope.childScopes[0];
            }
            cache.set(currentNode, scope);
            return scope;
          }
        }
        cache.set(currentNode, this.scopeManager.scopes[0]);
        return this.scopeManager.scopes[0];
      }
      /**
       * Get the variables that `node` defines.
       * This is a convenience method that passes through
       * to the same method on the `scopeManager`.
       * @param {ASTNode} node The node for which the variables are obtained.
       * @returns {Array<Variable>} An array of variable nodes representing
       *      the variables that `node` defines.
       */
      getDeclaredVariables(node) {
        return this.scopeManager.getDeclaredVariables(node);
      }
      /* eslint-disable class-methods-use-this -- node is owned by SourceCode */
      /**
       * Gets all the ancestors of a given node
       * @param {ASTNode} node The node
       * @returns {Array<ASTNode>} All the ancestor nodes in the AST, not including the provided node, starting
       * from the root node at index 0 and going inwards to the parent node.
       * @throws {TypeError} When `node` is missing.
       */
      getAncestors(node) {
        if (!node) {
          throw new TypeError("Missing required argument: node.");
        }
        const ancestorsStartingAtParent = [];
        for (let ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
          ancestorsStartingAtParent.push(ancestor);
        }
        return ancestorsStartingAtParent.reverse();
      }
      /* eslint-enable class-methods-use-this -- node is owned by SourceCode */
      /**
       * Marks a variable as used in the current scope
       * @param {string} name The name of the variable to mark as used.
       * @param {ASTNode} [refNode] The closest node to the variable reference.
       * @returns {boolean} True if the variable was found and marked as used, false if not.
       */
      markVariableAsUsed(name, refNode = this.ast) {
        const currentScope = this.getScope(refNode);
        let initialScope = currentScope;
        if (currentScope.type === "global" && currentScope.childScopes.length > 0 && // top-level scopes refer to a `Program` node
        currentScope.childScopes[0].block === this.ast) {
          initialScope = currentScope.childScopes[0];
        }
        for (let scope = initialScope; scope; scope = scope.upper) {
          const variable = scope.variables.find((scopeVar) => scopeVar.name === name);
          if (variable) {
            variable.eslintUsed = true;
            return true;
          }
        }
        return false;
      }
    };
    module.exports = SourceCode;
  }
});

// ../../node_modules/eslint/lib/source-code/index.js
var require_source_code2 = __commonJS({
  "../../node_modules/eslint/lib/source-code/index.js"(exports, module) {
    "use strict";
    module.exports = {
      SourceCode: require_source_code()
    };
  }
});

// ../../node_modules/eslint/lib/linter/code-path-analysis/debug-helpers.js
var require_debug_helpers = __commonJS({
  "../../node_modules/eslint/lib/linter/code-path-analysis/debug-helpers.js"(exports, module) {
    "use strict";
    var debug = require_browser()("eslint:code-path");
    function getId(segment) {
      return segment.id + (segment.reachable ? "" : "!");
    }
    function nodeToString(node, label) {
      const suffix = label ? `:${label}` : "";
      switch (node.type) {
        case "Identifier":
          return `${node.type}${suffix} (${node.name})`;
        case "Literal":
          return `${node.type}${suffix} (${node.value})`;
        default:
          return `${node.type}${suffix}`;
      }
    }
    module.exports = {
      /**
       * A flag that debug dumping is enabled or not.
       * @type {boolean}
       */
      enabled: debug.enabled,
      /**
       * Dumps given objects.
       * @param {...any} args objects to dump.
       * @returns {void}
       */
      dump: debug,
      /**
       * Dumps the current analyzing state.
       * @param {ASTNode} node A node to dump.
       * @param {CodePathState} state A state to dump.
       * @param {boolean} leaving A flag whether or not it's leaving
       * @returns {void}
       */
      dumpState: !debug.enabled ? debug : (
        /* c8 ignore next */
        function(node, state, leaving) {
          for (let i = 0; i < state.currentSegments.length; ++i) {
            const segInternal = state.currentSegments[i].internal;
            if (leaving) {
              const last = segInternal.nodes.length - 1;
              if (last >= 0 && segInternal.nodes[last] === nodeToString(node, "enter")) {
                segInternal.nodes[last] = nodeToString(node, void 0);
              } else {
                segInternal.nodes.push(nodeToString(node, "exit"));
              }
            } else {
              segInternal.nodes.push(nodeToString(node, "enter"));
            }
          }
          debug([
            `${state.currentSegments.map(getId).join(",")})`,
            `${node.type}${leaving ? ":exit" : ""}`
          ].join(" "));
        }
      ),
      /**
       * Dumps a DOT code of a given code path.
       * The DOT code can be visualized with Graphvis.
       * @param {CodePath} codePath A code path to dump.
       * @returns {void}
       * @see http://www.graphviz.org
       * @see http://www.webgraphviz.com
       */
      dumpDot: !debug.enabled ? debug : (
        /* c8 ignore next */
        function(codePath) {
          let text = '\ndigraph {\nnode[shape=box,style="rounded,filled",fillcolor=white];\ninitial[label="",shape=circle,style=filled,fillcolor=black,width=0.25,height=0.25];\n';
          if (codePath.returnedSegments.length > 0) {
            text += 'final[label="",shape=doublecircle,style=filled,fillcolor=black,width=0.25,height=0.25];\n';
          }
          if (codePath.thrownSegments.length > 0) {
            text += 'thrown[label="\u2718",shape=circle,width=0.3,height=0.3,fixedsize=true];\n';
          }
          const traceMap = /* @__PURE__ */ Object.create(null);
          const arrows = this.makeDotArrows(codePath, traceMap);
          for (const id in traceMap) {
            const segment = traceMap[id];
            text += `${id}[`;
            if (segment.reachable) {
              text += 'label="';
            } else {
              text += 'style="rounded,dashed,filled",fillcolor="#FF9800",label="<<unreachable>>\\n';
            }
            if (segment.internal.nodes.length > 0) {
              text += segment.internal.nodes.join("\\n");
            } else {
              text += "????";
            }
            text += '"];\n';
          }
          text += `${arrows}
`;
          text += "}";
          debug("DOT", text);
        }
      ),
      /**
       * Makes a DOT code of a given code path.
       * The DOT code can be visualized with Graphvis.
       * @param {CodePath} codePath A code path to make DOT.
       * @param {Object} traceMap Optional. A map to check whether or not segments had been done.
       * @returns {string} A DOT code of the code path.
       */
      makeDotArrows(codePath, traceMap) {
        const stack = [[codePath.initialSegment, 0]];
        const done = traceMap || /* @__PURE__ */ Object.create(null);
        let lastId = codePath.initialSegment.id;
        let text = `initial->${codePath.initialSegment.id}`;
        while (stack.length > 0) {
          const item = stack.pop();
          const segment = item[0];
          const index = item[1];
          if (done[segment.id] && index === 0) {
            continue;
          }
          done[segment.id] = segment;
          const nextSegment = segment.allNextSegments[index];
          if (!nextSegment) {
            continue;
          }
          if (lastId === segment.id) {
            text += `->${nextSegment.id}`;
          } else {
            text += `;
${segment.id}->${nextSegment.id}`;
          }
          lastId = nextSegment.id;
          stack.unshift([segment, 1 + index]);
          stack.push([nextSegment, 0]);
        }
        codePath.returnedSegments.forEach((finalSegment) => {
          if (lastId === finalSegment.id) {
            text += "->final";
          } else {
            text += `;
${finalSegment.id}->final`;
          }
          lastId = null;
        });
        codePath.thrownSegments.forEach((finalSegment) => {
          if (lastId === finalSegment.id) {
            text += "->thrown";
          } else {
            text += `;
${finalSegment.id}->thrown`;
          }
          lastId = null;
        });
        return `${text};`;
      }
    };
  }
});

// ../../node_modules/eslint/lib/linter/code-path-analysis/code-path-segment.js
var require_code_path_segment = __commonJS({
  "../../node_modules/eslint/lib/linter/code-path-analysis/code-path-segment.js"(exports, module) {
    "use strict";
    var debug = require_debug_helpers();
    function isReachable(segment) {
      return segment.reachable;
    }
    var CodePathSegment = class {
      /**
       * @param {string} id An identifier.
       * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.
       *   This array includes unreachable segments.
       * @param {boolean} reachable A flag which shows this is reachable.
       */
      constructor(id, allPrevSegments, reachable) {
        this.id = id;
        this.nextSegments = [];
        this.prevSegments = allPrevSegments.filter(isReachable);
        this.allNextSegments = [];
        this.allPrevSegments = allPrevSegments;
        this.reachable = reachable;
        Object.defineProperty(this, "internal", {
          value: {
            used: false,
            loopedPrevSegments: []
          }
        });
        if (debug.enabled) {
          this.internal.nodes = [];
        }
      }
      /**
       * Checks a given previous segment is coming from the end of a loop.
       * @param {CodePathSegment} segment A previous segment to check.
       * @returns {boolean} `true` if the segment is coming from the end of a loop.
       */
      isLoopedPrevSegment(segment) {
        return this.internal.loopedPrevSegments.includes(segment);
      }
      /**
       * Creates the root segment.
       * @param {string} id An identifier.
       * @returns {CodePathSegment} The created segment.
       */
      static newRoot(id) {
        return new CodePathSegment(id, [], true);
      }
      /**
       * Creates a segment that follows given segments.
       * @param {string} id An identifier.
       * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.
       * @returns {CodePathSegment} The created segment.
       */
      static newNext(id, allPrevSegments) {
        return new CodePathSegment(
          id,
          CodePathSegment.flattenUnusedSegments(allPrevSegments),
          allPrevSegments.some(isReachable)
        );
      }
      /**
       * Creates an unreachable segment that follows given segments.
       * @param {string} id An identifier.
       * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.
       * @returns {CodePathSegment} The created segment.
       */
      static newUnreachable(id, allPrevSegments) {
        const segment = new CodePathSegment(id, CodePathSegment.flattenUnusedSegments(allPrevSegments), false);
        CodePathSegment.markUsed(segment);
        return segment;
      }
      /**
       * Creates a segment that follows given segments.
       * This factory method does not connect with `allPrevSegments`.
       * But this inherits `reachable` flag.
       * @param {string} id An identifier.
       * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.
       * @returns {CodePathSegment} The created segment.
       */
      static newDisconnected(id, allPrevSegments) {
        return new CodePathSegment(id, [], allPrevSegments.some(isReachable));
      }
      /**
       * Makes a given segment being used.
       *
       * And this function registers the segment into the previous segments as a next.
       * @param {CodePathSegment} segment A segment to mark.
       * @returns {void}
       */
      static markUsed(segment) {
        if (segment.internal.used) {
          return;
        }
        segment.internal.used = true;
        let i;
        if (segment.reachable) {
          for (i = 0; i < segment.allPrevSegments.length; ++i) {
            const prevSegment = segment.allPrevSegments[i];
            prevSegment.allNextSegments.push(segment);
            prevSegment.nextSegments.push(segment);
          }
        } else {
          for (i = 0; i < segment.allPrevSegments.length; ++i) {
            segment.allPrevSegments[i].allNextSegments.push(segment);
          }
        }
      }
      /**
       * Marks a previous segment as looped.
       * @param {CodePathSegment} segment A segment.
       * @param {CodePathSegment} prevSegment A previous segment to mark.
       * @returns {void}
       */
      static markPrevSegmentAsLooped(segment, prevSegment) {
        segment.internal.loopedPrevSegments.push(prevSegment);
      }
      /**
       * Replaces unused segments with the previous segments of each unused segment.
       * @param {CodePathSegment[]} segments An array of segments to replace.
       * @returns {CodePathSegment[]} The replaced array.
       */
      static flattenUnusedSegments(segments) {
        const done = /* @__PURE__ */ Object.create(null);
        const retv = [];
        for (let i = 0; i < segments.length; ++i) {
          const segment = segments[i];
          if (done[segment.id]) {
            continue;
          }
          if (!segment.internal.used) {
            for (let j = 0; j < segment.allPrevSegments.length; ++j) {
              const prevSegment = segment.allPrevSegments[j];
              if (!done[prevSegment.id]) {
                done[prevSegment.id] = true;
                retv.push(prevSegment);
              }
            }
          } else {
            done[segment.id] = true;
            retv.push(segment);
          }
        }
        return retv;
      }
    };
    module.exports = CodePathSegment;
  }
});

// ../../node_modules/eslint/lib/linter/code-path-analysis/fork-context.js
var require_fork_context = __commonJS({
  "../../node_modules/eslint/lib/linter/code-path-analysis/fork-context.js"(exports, module) {
    "use strict";
    var assert = require_assert();
    var CodePathSegment = require_code_path_segment();
    function isReachable(segment) {
      return segment.reachable;
    }
    function makeSegments(context, begin, end, create) {
      const list = context.segmentsList;
      const normalizedBegin = begin >= 0 ? begin : list.length + begin;
      const normalizedEnd = end >= 0 ? end : list.length + end;
      const segments = [];
      for (let i = 0; i < context.count; ++i) {
        const allPrevSegments = [];
        for (let j = normalizedBegin; j <= normalizedEnd; ++j) {
          allPrevSegments.push(list[j][i]);
        }
        segments.push(create(context.idGenerator.next(), allPrevSegments));
      }
      return segments;
    }
    function mergeExtraSegments(context, segments) {
      let currentSegments = segments;
      while (currentSegments.length > context.count) {
        const merged = [];
        for (let i = 0, length = currentSegments.length / 2 | 0; i < length; ++i) {
          merged.push(CodePathSegment.newNext(
            context.idGenerator.next(),
            [currentSegments[i], currentSegments[i + length]]
          ));
        }
        currentSegments = merged;
      }
      return currentSegments;
    }
    var ForkContext = class {
      /**
       * @param {IdGenerator} idGenerator An identifier generator for segments.
       * @param {ForkContext|null} upper An upper fork context.
       * @param {number} count A number of parallel segments.
       */
      constructor(idGenerator, upper, count) {
        this.idGenerator = idGenerator;
        this.upper = upper;
        this.count = count;
        this.segmentsList = [];
      }
      /**
       * The head segments.
       * @type {CodePathSegment[]}
       */
      get head() {
        const list = this.segmentsList;
        return list.length === 0 ? [] : list[list.length - 1];
      }
      /**
       * A flag which shows empty.
       * @type {boolean}
       */
      get empty() {
        return this.segmentsList.length === 0;
      }
      /**
       * A flag which shows reachable.
       * @type {boolean}
       */
      get reachable() {
        const segments = this.head;
        return segments.length > 0 && segments.some(isReachable);
      }
      /**
       * Creates new segments from this context.
       * @param {number} begin The first index of previous segments.
       * @param {number} end The last index of previous segments.
       * @returns {CodePathSegment[]} New segments.
       */
      makeNext(begin, end) {
        return makeSegments(this, begin, end, CodePathSegment.newNext);
      }
      /**
       * Creates new segments from this context.
       * The new segments is always unreachable.
       * @param {number} begin The first index of previous segments.
       * @param {number} end The last index of previous segments.
       * @returns {CodePathSegment[]} New segments.
       */
      makeUnreachable(begin, end) {
        return makeSegments(this, begin, end, CodePathSegment.newUnreachable);
      }
      /**
       * Creates new segments from this context.
       * The new segments don't have connections for previous segments.
       * But these inherit the reachable flag from this context.
       * @param {number} begin The first index of previous segments.
       * @param {number} end The last index of previous segments.
       * @returns {CodePathSegment[]} New segments.
       */
      makeDisconnected(begin, end) {
        return makeSegments(this, begin, end, CodePathSegment.newDisconnected);
      }
      /**
       * Adds segments into this context.
       * The added segments become the head.
       * @param {CodePathSegment[]} segments Segments to add.
       * @returns {void}
       */
      add(segments) {
        assert(segments.length >= this.count, `${segments.length} >= ${this.count}`);
        this.segmentsList.push(mergeExtraSegments(this, segments));
      }
      /**
       * Replaces the head segments with given segments.
       * The current head segments are removed.
       * @param {CodePathSegment[]} segments Segments to add.
       * @returns {void}
       */
      replaceHead(segments) {
        assert(segments.length >= this.count, `${segments.length} >= ${this.count}`);
        this.segmentsList.splice(-1, 1, mergeExtraSegments(this, segments));
      }
      /**
       * Adds all segments of a given fork context into this context.
       * @param {ForkContext} context A fork context to add.
       * @returns {void}
       */
      addAll(context) {
        assert(context.count === this.count);
        const source = context.segmentsList;
        for (let i = 0; i < source.length; ++i) {
          this.segmentsList.push(source[i]);
        }
      }
      /**
       * Clears all segments in this context.
       * @returns {void}
       */
      clear() {
        this.segmentsList = [];
      }
      /**
       * Creates the root fork context.
       * @param {IdGenerator} idGenerator An identifier generator for segments.
       * @returns {ForkContext} New fork context.
       */
      static newRoot(idGenerator) {
        const context = new ForkContext(idGenerator, null, 1);
        context.add([CodePathSegment.newRoot(idGenerator.next())]);
        return context;
      }
      /**
       * Creates an empty fork context preceded by a given context.
       * @param {ForkContext} parentContext The parent fork context.
       * @param {boolean} forkLeavingPath A flag which shows inside of `finally` block.
       * @returns {ForkContext} New fork context.
       */
      static newEmpty(parentContext, forkLeavingPath) {
        return new ForkContext(
          parentContext.idGenerator,
          parentContext,
          (forkLeavingPath ? 2 : 1) * parentContext.count
        );
      }
    };
    module.exports = ForkContext;
  }
});

// ../../node_modules/eslint/lib/linter/code-path-analysis/code-path-state.js
var require_code_path_state = __commonJS({
  "../../node_modules/eslint/lib/linter/code-path-analysis/code-path-state.js"(exports, module) {
    "use strict";
    var CodePathSegment = require_code_path_segment();
    var ForkContext = require_fork_context();
    function addToReturnedOrThrown(dest, others, all, segments) {
      for (let i = 0; i < segments.length; ++i) {
        const segment = segments[i];
        dest.push(segment);
        if (!others.includes(segment)) {
          all.push(segment);
        }
      }
    }
    function getContinueContext(state, label) {
      if (!label) {
        return state.loopContext;
      }
      let context = state.loopContext;
      while (context) {
        if (context.label === label) {
          return context;
        }
        context = context.upper;
      }
      return null;
    }
    function getBreakContext(state, label) {
      let context = state.breakContext;
      while (context) {
        if (label ? context.label === label : context.breakable) {
          return context;
        }
        context = context.upper;
      }
      return null;
    }
    function getReturnContext(state) {
      let context = state.tryContext;
      while (context) {
        if (context.hasFinalizer && context.position !== "finally") {
          return context;
        }
        context = context.upper;
      }
      return state;
    }
    function getThrowContext(state) {
      let context = state.tryContext;
      while (context) {
        if (context.position === "try" || context.hasFinalizer && context.position === "catch") {
          return context;
        }
        context = context.upper;
      }
      return state;
    }
    function remove(xs, x) {
      xs.splice(xs.indexOf(x), 1);
    }
    function removeConnection(prevSegments, nextSegments) {
      for (let i = 0; i < prevSegments.length; ++i) {
        const prevSegment = prevSegments[i];
        const nextSegment = nextSegments[i];
        remove(prevSegment.nextSegments, nextSegment);
        remove(prevSegment.allNextSegments, nextSegment);
        remove(nextSegment.prevSegments, prevSegment);
        remove(nextSegment.allPrevSegments, prevSegment);
      }
    }
    function makeLooped(state, unflattenedFromSegments, unflattenedToSegments) {
      const fromSegments = CodePathSegment.flattenUnusedSegments(unflattenedFromSegments);
      const toSegments = CodePathSegment.flattenUnusedSegments(unflattenedToSegments);
      const end = Math.min(fromSegments.length, toSegments.length);
      for (let i = 0; i < end; ++i) {
        const fromSegment = fromSegments[i];
        const toSegment = toSegments[i];
        if (toSegment.reachable) {
          fromSegment.nextSegments.push(toSegment);
        }
        if (fromSegment.reachable) {
          toSegment.prevSegments.push(fromSegment);
        }
        fromSegment.allNextSegments.push(toSegment);
        toSegment.allPrevSegments.push(fromSegment);
        if (toSegment.allPrevSegments.length >= 2) {
          CodePathSegment.markPrevSegmentAsLooped(toSegment, fromSegment);
        }
        state.notifyLooped(fromSegment, toSegment);
      }
    }
    function finalizeTestSegmentsOfFor(context, choiceContext, head) {
      if (!choiceContext.processed) {
        choiceContext.trueForkContext.add(head);
        choiceContext.falseForkContext.add(head);
        choiceContext.qqForkContext.add(head);
      }
      if (context.test !== true) {
        context.brokenForkContext.addAll(choiceContext.falseForkContext);
      }
      context.endOfTestSegments = choiceContext.trueForkContext.makeNext(0, -1);
    }
    var CodePathState = class {
      /**
       * @param {IdGenerator} idGenerator An id generator to generate id for code
       *   path segments.
       * @param {Function} onLooped A callback function to notify looping.
       */
      constructor(idGenerator, onLooped) {
        this.idGenerator = idGenerator;
        this.notifyLooped = onLooped;
        this.forkContext = ForkContext.newRoot(idGenerator);
        this.choiceContext = null;
        this.switchContext = null;
        this.tryContext = null;
        this.loopContext = null;
        this.breakContext = null;
        this.chainContext = null;
        this.currentSegments = [];
        this.initialSegment = this.forkContext.head[0];
        const final = this.finalSegments = [];
        const returned = this.returnedForkContext = [];
        const thrown = this.thrownForkContext = [];
        returned.add = addToReturnedOrThrown.bind(null, returned, thrown, final);
        thrown.add = addToReturnedOrThrown.bind(null, thrown, returned, final);
      }
      /**
       * The head segments.
       * @type {CodePathSegment[]}
       */
      get headSegments() {
        return this.forkContext.head;
      }
      /**
       * The parent forking context.
       * This is used for the root of new forks.
       * @type {ForkContext}
       */
      get parentForkContext() {
        const current = this.forkContext;
        return current && current.upper;
      }
      /**
       * Creates and stacks new forking context.
       * @param {boolean} forkLeavingPath A flag which shows being in a
       *   "finally" block.
       * @returns {ForkContext} The created context.
       */
      pushForkContext(forkLeavingPath) {
        this.forkContext = ForkContext.newEmpty(
          this.forkContext,
          forkLeavingPath
        );
        return this.forkContext;
      }
      /**
       * Pops and merges the last forking context.
       * @returns {ForkContext} The last context.
       */
      popForkContext() {
        const lastContext = this.forkContext;
        this.forkContext = lastContext.upper;
        this.forkContext.replaceHead(lastContext.makeNext(0, -1));
        return lastContext;
      }
      /**
       * Creates a new path.
       * @returns {void}
       */
      forkPath() {
        this.forkContext.add(this.parentForkContext.makeNext(-1, -1));
      }
      /**
       * Creates a bypass path.
       * This is used for such as IfStatement which does not have "else" chunk.
       * @returns {void}
       */
      forkBypassPath() {
        this.forkContext.add(this.parentForkContext.head);
      }
      //--------------------------------------------------------------------------
      // ConditionalExpression, LogicalExpression, IfStatement
      //--------------------------------------------------------------------------
      /**
       * Creates a context for ConditionalExpression, LogicalExpression, AssignmentExpression (logical assignments only),
       * IfStatement, WhileStatement, DoWhileStatement, or ForStatement.
       *
       * LogicalExpressions have cases that it goes different paths between the
       * `true` case and the `false` case.
       *
       * For Example:
       *
       *     if (a || b) {
       *         foo();
       *     } else {
       *         bar();
       *     }
       *
       * In this case, `b` is evaluated always in the code path of the `else`
       * block, but it's not so in the code path of the `if` block.
       * So there are 3 paths.
       *
       *     a -> foo();
       *     a -> b -> foo();
       *     a -> b -> bar();
       * @param {string} kind A kind string.
       *   If the new context is LogicalExpression's or AssignmentExpression's, this is `"&&"` or `"||"` or `"??"`.
       *   If it's IfStatement's or ConditionalExpression's, this is `"test"`.
       *   Otherwise, this is `"loop"`.
       * @param {boolean} isForkingAsResult A flag that shows that goes different
       *   paths between `true` and `false`.
       * @returns {void}
       */
      pushChoiceContext(kind, isForkingAsResult) {
        this.choiceContext = {
          upper: this.choiceContext,
          kind,
          isForkingAsResult,
          trueForkContext: ForkContext.newEmpty(this.forkContext),
          falseForkContext: ForkContext.newEmpty(this.forkContext),
          qqForkContext: ForkContext.newEmpty(this.forkContext),
          processed: false
        };
      }
      /**
       * Pops the last choice context and finalizes it.
       * @throws {Error} (Unreachable.)
       * @returns {ChoiceContext} The popped context.
       */
      popChoiceContext() {
        const context = this.choiceContext;
        this.choiceContext = context.upper;
        const forkContext = this.forkContext;
        const headSegments = forkContext.head;
        switch (context.kind) {
          case "&&":
          case "||":
          case "??":
            if (!context.processed) {
              context.trueForkContext.add(headSegments);
              context.falseForkContext.add(headSegments);
              context.qqForkContext.add(headSegments);
            }
            if (context.isForkingAsResult) {
              const parentContext = this.choiceContext;
              parentContext.trueForkContext.addAll(context.trueForkContext);
              parentContext.falseForkContext.addAll(context.falseForkContext);
              parentContext.qqForkContext.addAll(context.qqForkContext);
              parentContext.processed = true;
              return context;
            }
            break;
          case "test":
            if (!context.processed) {
              context.trueForkContext.clear();
              context.trueForkContext.add(headSegments);
            } else {
              context.falseForkContext.clear();
              context.falseForkContext.add(headSegments);
            }
            break;
          case "loop":
            return context;
          default:
            throw new Error("unreachable");
        }
        const prevForkContext = context.trueForkContext;
        prevForkContext.addAll(context.falseForkContext);
        forkContext.replaceHead(prevForkContext.makeNext(0, -1));
        return context;
      }
      /**
       * Makes a code path segment of the right-hand operand of a logical
       * expression.
       * @throws {Error} (Unreachable.)
       * @returns {void}
       */
      makeLogicalRight() {
        const context = this.choiceContext;
        const forkContext = this.forkContext;
        if (context.processed) {
          let prevForkContext;
          switch (context.kind) {
            case "&&":
              prevForkContext = context.trueForkContext;
              break;
            case "||":
              prevForkContext = context.falseForkContext;
              break;
            case "??":
              prevForkContext = context.qqForkContext;
              break;
            default:
              throw new Error("unreachable");
          }
          forkContext.replaceHead(prevForkContext.makeNext(0, -1));
          prevForkContext.clear();
          context.processed = false;
        } else {
          switch (context.kind) {
            case "&&":
              context.falseForkContext.add(forkContext.head);
              break;
            case "||":
              context.trueForkContext.add(forkContext.head);
              break;
            case "??":
              context.trueForkContext.add(forkContext.head);
              context.falseForkContext.add(forkContext.head);
              break;
            default:
              throw new Error("unreachable");
          }
          forkContext.replaceHead(forkContext.makeNext(-1, -1));
        }
      }
      /**
       * Makes a code path segment of the `if` block.
       * @returns {void}
       */
      makeIfConsequent() {
        const context = this.choiceContext;
        const forkContext = this.forkContext;
        if (!context.processed) {
          context.trueForkContext.add(forkContext.head);
          context.falseForkContext.add(forkContext.head);
          context.qqForkContext.add(forkContext.head);
        }
        context.processed = false;
        forkContext.replaceHead(
          context.trueForkContext.makeNext(0, -1)
        );
      }
      /**
       * Makes a code path segment of the `else` block.
       * @returns {void}
       */
      makeIfAlternate() {
        const context = this.choiceContext;
        const forkContext = this.forkContext;
        context.trueForkContext.clear();
        context.trueForkContext.add(forkContext.head);
        context.processed = true;
        forkContext.replaceHead(
          context.falseForkContext.makeNext(0, -1)
        );
      }
      //--------------------------------------------------------------------------
      // ChainExpression
      //--------------------------------------------------------------------------
      /**
       * Push a new `ChainExpression` context to the stack.
       * This method is called on entering to each `ChainExpression` node.
       * This context is used to count forking in the optional chain then merge them on the exiting from the `ChainExpression` node.
       * @returns {void}
       */
      pushChainContext() {
        this.chainContext = {
          upper: this.chainContext,
          countChoiceContexts: 0
        };
      }
      /**
       * Pop a `ChainExpression` context from the stack.
       * This method is called on exiting from each `ChainExpression` node.
       * This merges all forks of the last optional chaining.
       * @returns {void}
       */
      popChainContext() {
        const context = this.chainContext;
        this.chainContext = context.upper;
        for (let i = context.countChoiceContexts; i > 0; --i) {
          this.popChoiceContext();
        }
      }
      /**
       * Create a choice context for optional access.
       * This method is called on entering to each `(Call|Member)Expression[optional=true]` node.
       * This creates a choice context as similar to `LogicalExpression[operator="??"]` node.
       * @returns {void}
       */
      makeOptionalNode() {
        if (this.chainContext) {
          this.chainContext.countChoiceContexts += 1;
          this.pushChoiceContext("??", false);
        }
      }
      /**
       * Create a fork.
       * This method is called on entering to the `arguments|property` property of each `(Call|Member)Expression` node.
       * @returns {void}
       */
      makeOptionalRight() {
        if (this.chainContext) {
          this.makeLogicalRight();
        }
      }
      //--------------------------------------------------------------------------
      // SwitchStatement
      //--------------------------------------------------------------------------
      /**
       * Creates a context object of SwitchStatement and stacks it.
       * @param {boolean} hasCase `true` if the switch statement has one or more
       *   case parts.
       * @param {string|null} label The label text.
       * @returns {void}
       */
      pushSwitchContext(hasCase, label) {
        this.switchContext = {
          upper: this.switchContext,
          hasCase,
          defaultSegments: null,
          defaultBodySegments: null,
          foundDefault: false,
          lastIsDefault: false,
          countForks: 0
        };
        this.pushBreakContext(true, label);
      }
      /**
       * Pops the last context of SwitchStatement and finalizes it.
       *
       * - Disposes all forking stack for `case` and `default`.
       * - Creates the next code path segment from `context.brokenForkContext`.
       * - If the last `SwitchCase` node is not a `default` part, creates a path
       *   to the `default` body.
       * @returns {void}
       */
      popSwitchContext() {
        const context = this.switchContext;
        this.switchContext = context.upper;
        const forkContext = this.forkContext;
        const brokenForkContext = this.popBreakContext().brokenForkContext;
        if (context.countForks === 0) {
          if (!brokenForkContext.empty) {
            brokenForkContext.add(forkContext.makeNext(-1, -1));
            forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
          }
          return;
        }
        const lastSegments = forkContext.head;
        this.forkBypassPath();
        const lastCaseSegments = forkContext.head;
        brokenForkContext.add(lastSegments);
        if (!context.lastIsDefault) {
          if (context.defaultBodySegments) {
            removeConnection(context.defaultSegments, context.defaultBodySegments);
            makeLooped(this, lastCaseSegments, context.defaultBodySegments);
          } else {
            brokenForkContext.add(lastCaseSegments);
          }
        }
        for (let i = 0; i < context.countForks; ++i) {
          this.forkContext = this.forkContext.upper;
        }
        this.forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
      }
      /**
       * Makes a code path segment for a `SwitchCase` node.
       * @param {boolean} isEmpty `true` if the body is empty.
       * @param {boolean} isDefault `true` if the body is the default case.
       * @returns {void}
       */
      makeSwitchCaseBody(isEmpty, isDefault) {
        const context = this.switchContext;
        if (!context.hasCase) {
          return;
        }
        const parentForkContext = this.forkContext;
        const forkContext = this.pushForkContext();
        forkContext.add(parentForkContext.makeNext(0, -1));
        if (isDefault) {
          context.defaultSegments = parentForkContext.head;
          if (isEmpty) {
            context.foundDefault = true;
          } else {
            context.defaultBodySegments = forkContext.head;
          }
        } else {
          if (!isEmpty && context.foundDefault) {
            context.foundDefault = false;
            context.defaultBodySegments = forkContext.head;
          }
        }
        context.lastIsDefault = isDefault;
        context.countForks += 1;
      }
      //--------------------------------------------------------------------------
      // TryStatement
      //--------------------------------------------------------------------------
      /**
       * Creates a context object of TryStatement and stacks it.
       * @param {boolean} hasFinalizer `true` if the try statement has a
       *   `finally` block.
       * @returns {void}
       */
      pushTryContext(hasFinalizer) {
        this.tryContext = {
          upper: this.tryContext,
          position: "try",
          hasFinalizer,
          returnedForkContext: hasFinalizer ? ForkContext.newEmpty(this.forkContext) : null,
          thrownForkContext: ForkContext.newEmpty(this.forkContext),
          lastOfTryIsReachable: false,
          lastOfCatchIsReachable: false
        };
      }
      /**
       * Pops the last context of TryStatement and finalizes it.
       * @returns {void}
       */
      popTryContext() {
        const context = this.tryContext;
        this.tryContext = context.upper;
        if (context.position === "catch") {
          this.popForkContext();
          return;
        }
        const returned = context.returnedForkContext;
        const thrown = context.thrownForkContext;
        if (returned.empty && thrown.empty) {
          return;
        }
        const headSegments = this.forkContext.head;
        this.forkContext = this.forkContext.upper;
        const normalSegments = headSegments.slice(0, headSegments.length / 2 | 0);
        const leavingSegments = headSegments.slice(headSegments.length / 2 | 0);
        if (!returned.empty) {
          getReturnContext(this).returnedForkContext.add(leavingSegments);
        }
        if (!thrown.empty) {
          getThrowContext(this).thrownForkContext.add(leavingSegments);
        }
        this.forkContext.replaceHead(normalSegments);
        if (!context.lastOfTryIsReachable && !context.lastOfCatchIsReachable) {
          this.forkContext.makeUnreachable();
        }
      }
      /**
       * Makes a code path segment for a `catch` block.
       * @returns {void}
       */
      makeCatchBlock() {
        const context = this.tryContext;
        const forkContext = this.forkContext;
        const thrown = context.thrownForkContext;
        context.position = "catch";
        context.thrownForkContext = ForkContext.newEmpty(forkContext);
        context.lastOfTryIsReachable = forkContext.reachable;
        thrown.add(forkContext.head);
        const thrownSegments = thrown.makeNext(0, -1);
        this.pushForkContext();
        this.forkBypassPath();
        this.forkContext.add(thrownSegments);
      }
      /**
       * Makes a code path segment for a `finally` block.
       *
       * In the `finally` block, parallel paths are created. The parallel paths
       * are used as leaving-paths. The leaving-paths are paths from `return`
       * statements and `throw` statements in a `try` block or a `catch` block.
       * @returns {void}
       */
      makeFinallyBlock() {
        const context = this.tryContext;
        let forkContext = this.forkContext;
        const returned = context.returnedForkContext;
        const thrown = context.thrownForkContext;
        const headOfLeavingSegments = forkContext.head;
        if (context.position === "catch") {
          this.popForkContext();
          forkContext = this.forkContext;
          context.lastOfCatchIsReachable = forkContext.reachable;
        } else {
          context.lastOfTryIsReachable = forkContext.reachable;
        }
        context.position = "finally";
        if (returned.empty && thrown.empty) {
          return;
        }
        const segments = forkContext.makeNext(-1, -1);
        for (let i = 0; i < forkContext.count; ++i) {
          const prevSegsOfLeavingSegment = [headOfLeavingSegments[i]];
          for (let j = 0; j < returned.segmentsList.length; ++j) {
            prevSegsOfLeavingSegment.push(returned.segmentsList[j][i]);
          }
          for (let j = 0; j < thrown.segmentsList.length; ++j) {
            prevSegsOfLeavingSegment.push(thrown.segmentsList[j][i]);
          }
          segments.push(
            CodePathSegment.newNext(
              this.idGenerator.next(),
              prevSegsOfLeavingSegment
            )
          );
        }
        this.pushForkContext(true);
        this.forkContext.add(segments);
      }
      /**
       * Makes a code path segment from the first throwable node to the `catch`
       * block or the `finally` block.
       * @returns {void}
       */
      makeFirstThrowablePathInTryBlock() {
        const forkContext = this.forkContext;
        if (!forkContext.reachable) {
          return;
        }
        const context = getThrowContext(this);
        if (context === this || context.position !== "try" || !context.thrownForkContext.empty) {
          return;
        }
        context.thrownForkContext.add(forkContext.head);
        forkContext.replaceHead(forkContext.makeNext(-1, -1));
      }
      //--------------------------------------------------------------------------
      // Loop Statements
      //--------------------------------------------------------------------------
      /**
       * Creates a context object of a loop statement and stacks it.
       * @param {string} type The type of the node which was triggered. One of
       *   `WhileStatement`, `DoWhileStatement`, `ForStatement`, `ForInStatement`,
       *   and `ForStatement`.
       * @param {string|null} label A label of the node which was triggered.
       * @throws {Error} (Unreachable - unknown type.)
       * @returns {void}
       */
      pushLoopContext(type, label) {
        const forkContext = this.forkContext;
        const breakContext = this.pushBreakContext(true, label);
        switch (type) {
          case "WhileStatement":
            this.pushChoiceContext("loop", false);
            this.loopContext = {
              upper: this.loopContext,
              type,
              label,
              test: void 0,
              continueDestSegments: null,
              brokenForkContext: breakContext.brokenForkContext
            };
            break;
          case "DoWhileStatement":
            this.pushChoiceContext("loop", false);
            this.loopContext = {
              upper: this.loopContext,
              type,
              label,
              test: void 0,
              entrySegments: null,
              continueForkContext: ForkContext.newEmpty(forkContext),
              brokenForkContext: breakContext.brokenForkContext
            };
            break;
          case "ForStatement":
            this.pushChoiceContext("loop", false);
            this.loopContext = {
              upper: this.loopContext,
              type,
              label,
              test: void 0,
              endOfInitSegments: null,
              testSegments: null,
              endOfTestSegments: null,
              updateSegments: null,
              endOfUpdateSegments: null,
              continueDestSegments: null,
              brokenForkContext: breakContext.brokenForkContext
            };
            break;
          case "ForInStatement":
          case "ForOfStatement":
            this.loopContext = {
              upper: this.loopContext,
              type,
              label,
              prevSegments: null,
              leftSegments: null,
              endOfLeftSegments: null,
              continueDestSegments: null,
              brokenForkContext: breakContext.brokenForkContext
            };
            break;
          default:
            throw new Error(`unknown type: "${type}"`);
        }
      }
      /**
       * Pops the last context of a loop statement and finalizes it.
       * @throws {Error} (Unreachable - unknown type.)
       * @returns {void}
       */
      popLoopContext() {
        const context = this.loopContext;
        this.loopContext = context.upper;
        const forkContext = this.forkContext;
        const brokenForkContext = this.popBreakContext().brokenForkContext;
        switch (context.type) {
          case "WhileStatement":
          case "ForStatement":
            this.popChoiceContext();
            makeLooped(
              this,
              forkContext.head,
              context.continueDestSegments
            );
            break;
          case "DoWhileStatement": {
            const choiceContext = this.popChoiceContext();
            if (!choiceContext.processed) {
              choiceContext.trueForkContext.add(forkContext.head);
              choiceContext.falseForkContext.add(forkContext.head);
            }
            if (context.test !== true) {
              brokenForkContext.addAll(choiceContext.falseForkContext);
            }
            const segmentsList = choiceContext.trueForkContext.segmentsList;
            for (let i = 0; i < segmentsList.length; ++i) {
              makeLooped(
                this,
                segmentsList[i],
                context.entrySegments
              );
            }
            break;
          }
          case "ForInStatement":
          case "ForOfStatement":
            brokenForkContext.add(forkContext.head);
            makeLooped(
              this,
              forkContext.head,
              context.leftSegments
            );
            break;
          default:
            throw new Error("unreachable");
        }
        if (brokenForkContext.empty) {
          forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
        } else {
          forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
        }
      }
      /**
       * Makes a code path segment for the test part of a WhileStatement.
       * @param {boolean|undefined} test The test value (only when constant).
       * @returns {void}
       */
      makeWhileTest(test) {
        const context = this.loopContext;
        const forkContext = this.forkContext;
        const testSegments = forkContext.makeNext(0, -1);
        context.test = test;
        context.continueDestSegments = testSegments;
        forkContext.replaceHead(testSegments);
      }
      /**
       * Makes a code path segment for the body part of a WhileStatement.
       * @returns {void}
       */
      makeWhileBody() {
        const context = this.loopContext;
        const choiceContext = this.choiceContext;
        const forkContext = this.forkContext;
        if (!choiceContext.processed) {
          choiceContext.trueForkContext.add(forkContext.head);
          choiceContext.falseForkContext.add(forkContext.head);
        }
        if (context.test !== true) {
          context.brokenForkContext.addAll(choiceContext.falseForkContext);
        }
        forkContext.replaceHead(choiceContext.trueForkContext.makeNext(0, -1));
      }
      /**
       * Makes a code path segment for the body part of a DoWhileStatement.
       * @returns {void}
       */
      makeDoWhileBody() {
        const context = this.loopContext;
        const forkContext = this.forkContext;
        const bodySegments = forkContext.makeNext(-1, -1);
        context.entrySegments = bodySegments;
        forkContext.replaceHead(bodySegments);
      }
      /**
       * Makes a code path segment for the test part of a DoWhileStatement.
       * @param {boolean|undefined} test The test value (only when constant).
       * @returns {void}
       */
      makeDoWhileTest(test) {
        const context = this.loopContext;
        const forkContext = this.forkContext;
        context.test = test;
        if (!context.continueForkContext.empty) {
          context.continueForkContext.add(forkContext.head);
          const testSegments = context.continueForkContext.makeNext(0, -1);
          forkContext.replaceHead(testSegments);
        }
      }
      /**
       * Makes a code path segment for the test part of a ForStatement.
       * @param {boolean|undefined} test The test value (only when constant).
       * @returns {void}
       */
      makeForTest(test) {
        const context = this.loopContext;
        const forkContext = this.forkContext;
        const endOfInitSegments = forkContext.head;
        const testSegments = forkContext.makeNext(-1, -1);
        context.test = test;
        context.endOfInitSegments = endOfInitSegments;
        context.continueDestSegments = context.testSegments = testSegments;
        forkContext.replaceHead(testSegments);
      }
      /**
       * Makes a code path segment for the update part of a ForStatement.
       * @returns {void}
       */
      makeForUpdate() {
        const context = this.loopContext;
        const choiceContext = this.choiceContext;
        const forkContext = this.forkContext;
        if (context.testSegments) {
          finalizeTestSegmentsOfFor(
            context,
            choiceContext,
            forkContext.head
          );
        } else {
          context.endOfInitSegments = forkContext.head;
        }
        const updateSegments = forkContext.makeDisconnected(-1, -1);
        context.continueDestSegments = context.updateSegments = updateSegments;
        forkContext.replaceHead(updateSegments);
      }
      /**
       * Makes a code path segment for the body part of a ForStatement.
       * @returns {void}
       */
      makeForBody() {
        const context = this.loopContext;
        const choiceContext = this.choiceContext;
        const forkContext = this.forkContext;
        if (context.updateSegments) {
          context.endOfUpdateSegments = forkContext.head;
          if (context.testSegments) {
            makeLooped(
              this,
              context.endOfUpdateSegments,
              context.testSegments
            );
          }
        } else if (context.testSegments) {
          finalizeTestSegmentsOfFor(
            context,
            choiceContext,
            forkContext.head
          );
        } else {
          context.endOfInitSegments = forkContext.head;
        }
        let bodySegments = context.endOfTestSegments;
        if (!bodySegments) {
          const prevForkContext = ForkContext.newEmpty(forkContext);
          prevForkContext.add(context.endOfInitSegments);
          if (context.endOfUpdateSegments) {
            prevForkContext.add(context.endOfUpdateSegments);
          }
          bodySegments = prevForkContext.makeNext(0, -1);
        }
        context.continueDestSegments = context.continueDestSegments || bodySegments;
        forkContext.replaceHead(bodySegments);
      }
      /**
       * Makes a code path segment for the left part of a ForInStatement and a
       * ForOfStatement.
       * @returns {void}
       */
      makeForInOfLeft() {
        const context = this.loopContext;
        const forkContext = this.forkContext;
        const leftSegments = forkContext.makeDisconnected(-1, -1);
        context.prevSegments = forkContext.head;
        context.leftSegments = context.continueDestSegments = leftSegments;
        forkContext.replaceHead(leftSegments);
      }
      /**
       * Makes a code path segment for the right part of a ForInStatement and a
       * ForOfStatement.
       * @returns {void}
       */
      makeForInOfRight() {
        const context = this.loopContext;
        const forkContext = this.forkContext;
        const temp = ForkContext.newEmpty(forkContext);
        temp.add(context.prevSegments);
        const rightSegments = temp.makeNext(-1, -1);
        context.endOfLeftSegments = forkContext.head;
        forkContext.replaceHead(rightSegments);
      }
      /**
       * Makes a code path segment for the body part of a ForInStatement and a
       * ForOfStatement.
       * @returns {void}
       */
      makeForInOfBody() {
        const context = this.loopContext;
        const forkContext = this.forkContext;
        const temp = ForkContext.newEmpty(forkContext);
        temp.add(context.endOfLeftSegments);
        const bodySegments = temp.makeNext(-1, -1);
        makeLooped(this, forkContext.head, context.leftSegments);
        context.brokenForkContext.add(forkContext.head);
        forkContext.replaceHead(bodySegments);
      }
      //--------------------------------------------------------------------------
      // Control Statements
      //--------------------------------------------------------------------------
      /**
       * Creates new context for BreakStatement.
       * @param {boolean} breakable The flag to indicate it can break by
       *      an unlabeled BreakStatement.
       * @param {string|null} label The label of this context.
       * @returns {Object} The new context.
       */
      pushBreakContext(breakable, label) {
        this.breakContext = {
          upper: this.breakContext,
          breakable,
          label,
          brokenForkContext: ForkContext.newEmpty(this.forkContext)
        };
        return this.breakContext;
      }
      /**
       * Removes the top item of the break context stack.
       * @returns {Object} The removed context.
       */
      popBreakContext() {
        const context = this.breakContext;
        const forkContext = this.forkContext;
        this.breakContext = context.upper;
        if (!context.breakable) {
          const brokenForkContext = context.brokenForkContext;
          if (!brokenForkContext.empty) {
            brokenForkContext.add(forkContext.head);
            forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
          }
        }
        return context;
      }
      /**
       * Makes a path for a `break` statement.
       *
       * It registers the head segment to a context of `break`.
       * It makes new unreachable segment, then it set the head with the segment.
       * @param {string} label A label of the break statement.
       * @returns {void}
       */
      makeBreak(label) {
        const forkContext = this.forkContext;
        if (!forkContext.reachable) {
          return;
        }
        const context = getBreakContext(this, label);
        if (context) {
          context.brokenForkContext.add(forkContext.head);
        }
        forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
      }
      /**
       * Makes a path for a `continue` statement.
       *
       * It makes a looping path.
       * It makes new unreachable segment, then it set the head with the segment.
       * @param {string} label A label of the continue statement.
       * @returns {void}
       */
      makeContinue(label) {
        const forkContext = this.forkContext;
        if (!forkContext.reachable) {
          return;
        }
        const context = getContinueContext(this, label);
        if (context) {
          if (context.continueDestSegments) {
            makeLooped(this, forkContext.head, context.continueDestSegments);
            if (context.type === "ForInStatement" || context.type === "ForOfStatement") {
              context.brokenForkContext.add(forkContext.head);
            }
          } else {
            context.continueForkContext.add(forkContext.head);
          }
        }
        forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
      }
      /**
       * Makes a path for a `return` statement.
       *
       * It registers the head segment to a context of `return`.
       * It makes new unreachable segment, then it set the head with the segment.
       * @returns {void}
       */
      makeReturn() {
        const forkContext = this.forkContext;
        if (forkContext.reachable) {
          getReturnContext(this).returnedForkContext.add(forkContext.head);
          forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
        }
      }
      /**
       * Makes a path for a `throw` statement.
       *
       * It registers the head segment to a context of `throw`.
       * It makes new unreachable segment, then it set the head with the segment.
       * @returns {void}
       */
      makeThrow() {
        const forkContext = this.forkContext;
        if (forkContext.reachable) {
          getThrowContext(this).thrownForkContext.add(forkContext.head);
          forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
        }
      }
      /**
       * Makes the final path.
       * @returns {void}
       */
      makeFinal() {
        const segments = this.currentSegments;
        if (segments.length > 0 && segments[0].reachable) {
          this.returnedForkContext.add(segments);
        }
      }
    };
    module.exports = CodePathState;
  }
});

// ../../node_modules/eslint/lib/linter/code-path-analysis/id-generator.js
var require_id_generator = __commonJS({
  "../../node_modules/eslint/lib/linter/code-path-analysis/id-generator.js"(exports, module) {
    "use strict";
    var IdGenerator = class {
      /**
       * @param {string} prefix Optional. A prefix of generated ids.
       */
      constructor(prefix) {
        this.prefix = String(prefix);
        this.n = 0;
      }
      /**
       * Generates id.
       * @returns {string} A generated id.
       */
      next() {
        this.n = 1 + this.n | 0;
        if (this.n < 0) {
          this.n = 1;
        }
        return this.prefix + this.n;
      }
    };
    module.exports = IdGenerator;
  }
});

// ../../node_modules/eslint/lib/linter/code-path-analysis/code-path.js
var require_code_path = __commonJS({
  "../../node_modules/eslint/lib/linter/code-path-analysis/code-path.js"(exports, module) {
    "use strict";
    var CodePathState = require_code_path_state();
    var IdGenerator = require_id_generator();
    var CodePath = class {
      /**
       * Creates a new instance.
       * @param {Object} options Options for the function (see below).
       * @param {string} options.id An identifier.
       * @param {string} options.origin The type of code path origin.
       * @param {CodePath|null} options.upper The code path of the upper function scope.
       * @param {Function} options.onLooped A callback function to notify looping.
       */
      constructor({ id, origin, upper, onLooped }) {
        this.id = id;
        this.origin = origin;
        this.upper = upper;
        this.childCodePaths = [];
        Object.defineProperty(
          this,
          "internal",
          { value: new CodePathState(new IdGenerator(`${id}_`), onLooped) }
        );
        if (upper) {
          upper.childCodePaths.push(this);
        }
      }
      /**
       * Gets the state of a given code path.
       * @param {CodePath} codePath A code path to get.
       * @returns {CodePathState} The state of the code path.
       */
      static getState(codePath) {
        return codePath.internal;
      }
      /**
       * The initial code path segment.
       * @type {CodePathSegment}
       */
      get initialSegment() {
        return this.internal.initialSegment;
      }
      /**
       * Final code path segments.
       * This array is a mix of `returnedSegments` and `thrownSegments`.
       * @type {CodePathSegment[]}
       */
      get finalSegments() {
        return this.internal.finalSegments;
      }
      /**
       * Final code path segments which is with `return` statements.
       * This array contains the last path segment if it's reachable.
       * Since the reachable last path returns `undefined`.
       * @type {CodePathSegment[]}
       */
      get returnedSegments() {
        return this.internal.returnedForkContext;
      }
      /**
       * Final code path segments which is with `throw` statements.
       * @type {CodePathSegment[]}
       */
      get thrownSegments() {
        return this.internal.thrownForkContext;
      }
      /**
       * Current code path segments.
       * @type {CodePathSegment[]}
       */
      get currentSegments() {
        return this.internal.currentSegments;
      }
      /**
       * Traverses all segments in this code path.
       *
       *     codePath.traverseSegments(function(segment, controller) {
       *         // do something.
       *     });
       *
       * This method enumerates segments in order from the head.
       *
       * The `controller` object has two methods.
       *
       * - `controller.skip()` - Skip the following segments in this branch.
       * - `controller.break()` - Skip all following segments.
       * @param {Object} [options] Omittable.
       * @param {CodePathSegment} [options.first] The first segment to traverse.
       * @param {CodePathSegment} [options.last] The last segment to traverse.
       * @param {Function} callback A callback function.
       * @returns {void}
       */
      traverseSegments(options, callback) {
        let resolvedOptions;
        let resolvedCallback;
        if (typeof options === "function") {
          resolvedCallback = options;
          resolvedOptions = {};
        } else {
          resolvedOptions = options || {};
          resolvedCallback = callback;
        }
        const startSegment = resolvedOptions.first || this.internal.initialSegment;
        const lastSegment = resolvedOptions.last;
        let item = null;
        let index = 0;
        let end = 0;
        let segment = null;
        const visited = /* @__PURE__ */ Object.create(null);
        const stack = [[startSegment, 0]];
        let skippedSegment = null;
        let broken = false;
        const controller = {
          skip() {
            if (stack.length <= 1) {
              broken = true;
            } else {
              skippedSegment = stack[stack.length - 2][0];
            }
          },
          break() {
            broken = true;
          }
        };
        function isVisited(prevSegment) {
          return visited[prevSegment.id] || segment.isLoopedPrevSegment(prevSegment);
        }
        while (stack.length > 0) {
          item = stack[stack.length - 1];
          segment = item[0];
          index = item[1];
          if (index === 0) {
            if (visited[segment.id]) {
              stack.pop();
              continue;
            }
            if (segment !== startSegment && segment.prevSegments.length > 0 && !segment.prevSegments.every(isVisited)) {
              stack.pop();
              continue;
            }
            if (skippedSegment && segment.prevSegments.includes(skippedSegment)) {
              skippedSegment = null;
            }
            visited[segment.id] = true;
            if (!skippedSegment) {
              resolvedCallback.call(this, segment, controller);
              if (segment === lastSegment) {
                controller.skip();
              }
              if (broken) {
                break;
              }
            }
          }
          end = segment.nextSegments.length - 1;
          if (index < end) {
            item[1] += 1;
            stack.push([segment.nextSegments[index], 0]);
          } else if (index === end) {
            item[0] = segment.nextSegments[index];
            item[1] = 0;
          } else {
            stack.pop();
          }
        }
      }
    };
    module.exports = CodePath;
  }
});

// ../../node_modules/eslint/lib/linter/code-path-analysis/code-path-analyzer.js
var require_code_path_analyzer = __commonJS({
  "../../node_modules/eslint/lib/linter/code-path-analysis/code-path-analyzer.js"(exports, module) {
    "use strict";
    var assert = require_assert();
    var { breakableTypePattern } = require_ast_utils();
    var CodePath = require_code_path();
    var CodePathSegment = require_code_path_segment();
    var IdGenerator = require_id_generator();
    var debug = require_debug_helpers();
    function isCaseNode(node) {
      return Boolean(node.test);
    }
    function isPropertyDefinitionValue(node) {
      const parent = node.parent;
      return parent && parent.type === "PropertyDefinition" && parent.value === node;
    }
    function isHandledLogicalOperator(operator) {
      return operator === "&&" || operator === "||" || operator === "??";
    }
    function isLogicalAssignmentOperator(operator) {
      return operator === "&&=" || operator === "||=" || operator === "??=";
    }
    function getLabel(node) {
      if (node.parent.type === "LabeledStatement") {
        return node.parent.label.name;
      }
      return null;
    }
    function isForkingByTrueOrFalse(node) {
      const parent = node.parent;
      switch (parent.type) {
        case "ConditionalExpression":
        case "IfStatement":
        case "WhileStatement":
        case "DoWhileStatement":
        case "ForStatement":
          return parent.test === node;
        case "LogicalExpression":
          return isHandledLogicalOperator(parent.operator);
        case "AssignmentExpression":
          return isLogicalAssignmentOperator(parent.operator);
        default:
          return false;
      }
    }
    function getBooleanValueIfSimpleConstant(node) {
      if (node.type === "Literal") {
        return Boolean(node.value);
      }
      return void 0;
    }
    function isIdentifierReference(node) {
      const parent = node.parent;
      switch (parent.type) {
        case "LabeledStatement":
        case "BreakStatement":
        case "ContinueStatement":
        case "ArrayPattern":
        case "RestElement":
        case "ImportSpecifier":
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "CatchClause":
          return false;
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ArrowFunctionExpression":
        case "ClassDeclaration":
        case "ClassExpression":
        case "VariableDeclarator":
          return parent.id !== node;
        case "Property":
        case "PropertyDefinition":
        case "MethodDefinition":
          return parent.key !== node || parent.computed || parent.shorthand;
        case "AssignmentPattern":
          return parent.key !== node;
        default:
          return true;
      }
    }
    function forwardCurrentToHead(analyzer, node) {
      const codePath = analyzer.codePath;
      const state = CodePath.getState(codePath);
      const currentSegments = state.currentSegments;
      const headSegments = state.headSegments;
      const end = Math.max(currentSegments.length, headSegments.length);
      let i, currentSegment, headSegment;
      for (i = 0; i < end; ++i) {
        currentSegment = currentSegments[i];
        headSegment = headSegments[i];
        if (currentSegment !== headSegment && currentSegment) {
          debug.dump(`onCodePathSegmentEnd ${currentSegment.id}`);
          if (currentSegment.reachable) {
            analyzer.emitter.emit(
              "onCodePathSegmentEnd",
              currentSegment,
              node
            );
          }
        }
      }
      state.currentSegments = headSegments;
      for (i = 0; i < end; ++i) {
        currentSegment = currentSegments[i];
        headSegment = headSegments[i];
        if (currentSegment !== headSegment && headSegment) {
          debug.dump(`onCodePathSegmentStart ${headSegment.id}`);
          CodePathSegment.markUsed(headSegment);
          if (headSegment.reachable) {
            analyzer.emitter.emit(
              "onCodePathSegmentStart",
              headSegment,
              node
            );
          }
        }
      }
    }
    function leaveFromCurrentSegment(analyzer, node) {
      const state = CodePath.getState(analyzer.codePath);
      const currentSegments = state.currentSegments;
      for (let i = 0; i < currentSegments.length; ++i) {
        const currentSegment = currentSegments[i];
        debug.dump(`onCodePathSegmentEnd ${currentSegment.id}`);
        if (currentSegment.reachable) {
          analyzer.emitter.emit(
            "onCodePathSegmentEnd",
            currentSegment,
            node
          );
        }
      }
      state.currentSegments = [];
    }
    function preprocess(analyzer, node) {
      const codePath = analyzer.codePath;
      const state = CodePath.getState(codePath);
      const parent = node.parent;
      switch (parent.type) {
        case "CallExpression":
          if (parent.optional === true && parent.arguments.length >= 1 && parent.arguments[0] === node) {
            state.makeOptionalRight();
          }
          break;
        case "MemberExpression":
          if (parent.optional === true && parent.property === node) {
            state.makeOptionalRight();
          }
          break;
        case "LogicalExpression":
          if (parent.right === node && isHandledLogicalOperator(parent.operator)) {
            state.makeLogicalRight();
          }
          break;
        case "AssignmentExpression":
          if (parent.right === node && isLogicalAssignmentOperator(parent.operator)) {
            state.makeLogicalRight();
          }
          break;
        case "ConditionalExpression":
        case "IfStatement":
          if (parent.consequent === node) {
            state.makeIfConsequent();
          } else if (parent.alternate === node) {
            state.makeIfAlternate();
          }
          break;
        case "SwitchCase":
          if (parent.consequent[0] === node) {
            state.makeSwitchCaseBody(false, !parent.test);
          }
          break;
        case "TryStatement":
          if (parent.handler === node) {
            state.makeCatchBlock();
          } else if (parent.finalizer === node) {
            state.makeFinallyBlock();
          }
          break;
        case "WhileStatement":
          if (parent.test === node) {
            state.makeWhileTest(getBooleanValueIfSimpleConstant(node));
          } else {
            assert(parent.body === node);
            state.makeWhileBody();
          }
          break;
        case "DoWhileStatement":
          if (parent.body === node) {
            state.makeDoWhileBody();
          } else {
            assert(parent.test === node);
            state.makeDoWhileTest(getBooleanValueIfSimpleConstant(node));
          }
          break;
        case "ForStatement":
          if (parent.test === node) {
            state.makeForTest(getBooleanValueIfSimpleConstant(node));
          } else if (parent.update === node) {
            state.makeForUpdate();
          } else if (parent.body === node) {
            state.makeForBody();
          }
          break;
        case "ForInStatement":
        case "ForOfStatement":
          if (parent.left === node) {
            state.makeForInOfLeft();
          } else if (parent.right === node) {
            state.makeForInOfRight();
          } else {
            assert(parent.body === node);
            state.makeForInOfBody();
          }
          break;
        case "AssignmentPattern":
          if (parent.right === node) {
            state.pushForkContext();
            state.forkBypassPath();
            state.forkPath();
          }
          break;
        default:
          break;
      }
    }
    function processCodePathToEnter(analyzer, node) {
      let codePath = analyzer.codePath;
      let state = codePath && CodePath.getState(codePath);
      const parent = node.parent;
      function startCodePath(origin) {
        if (codePath) {
          forwardCurrentToHead(analyzer, node);
          debug.dumpState(node, state, false);
        }
        codePath = analyzer.codePath = new CodePath({
          id: analyzer.idGenerator.next(),
          origin,
          upper: codePath,
          onLooped: analyzer.onLooped
        });
        state = CodePath.getState(codePath);
        debug.dump(`onCodePathStart ${codePath.id}`);
        analyzer.emitter.emit("onCodePathStart", codePath, node);
      }
      if (isPropertyDefinitionValue(node)) {
        startCodePath("class-field-initializer");
      }
      switch (node.type) {
        case "Program":
          startCodePath("program");
          break;
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ArrowFunctionExpression":
          startCodePath("function");
          break;
        case "StaticBlock":
          startCodePath("class-static-block");
          break;
        case "ChainExpression":
          state.pushChainContext();
          break;
        case "CallExpression":
          if (node.optional === true) {
            state.makeOptionalNode();
          }
          break;
        case "MemberExpression":
          if (node.optional === true) {
            state.makeOptionalNode();
          }
          break;
        case "LogicalExpression":
          if (isHandledLogicalOperator(node.operator)) {
            state.pushChoiceContext(
              node.operator,
              isForkingByTrueOrFalse(node)
            );
          }
          break;
        case "AssignmentExpression":
          if (isLogicalAssignmentOperator(node.operator)) {
            state.pushChoiceContext(
              node.operator.slice(0, -1),
              // removes `=` from the end
              isForkingByTrueOrFalse(node)
            );
          }
          break;
        case "ConditionalExpression":
        case "IfStatement":
          state.pushChoiceContext("test", false);
          break;
        case "SwitchStatement":
          state.pushSwitchContext(
            node.cases.some(isCaseNode),
            getLabel(node)
          );
          break;
        case "TryStatement":
          state.pushTryContext(Boolean(node.finalizer));
          break;
        case "SwitchCase":
          if (parent.discriminant !== node && parent.cases[0] !== node) {
            state.forkPath();
          }
          break;
        case "WhileStatement":
        case "DoWhileStatement":
        case "ForStatement":
        case "ForInStatement":
        case "ForOfStatement":
          state.pushLoopContext(node.type, getLabel(node));
          break;
        case "LabeledStatement":
          if (!breakableTypePattern.test(node.body.type)) {
            state.pushBreakContext(false, node.label.name);
          }
          break;
        default:
          break;
      }
      forwardCurrentToHead(analyzer, node);
      debug.dumpState(node, state, false);
    }
    function processCodePathToExit(analyzer, node) {
      const codePath = analyzer.codePath;
      const state = CodePath.getState(codePath);
      let dontForward = false;
      switch (node.type) {
        case "ChainExpression":
          state.popChainContext();
          break;
        case "IfStatement":
        case "ConditionalExpression":
          state.popChoiceContext();
          break;
        case "LogicalExpression":
          if (isHandledLogicalOperator(node.operator)) {
            state.popChoiceContext();
          }
          break;
        case "AssignmentExpression":
          if (isLogicalAssignmentOperator(node.operator)) {
            state.popChoiceContext();
          }
          break;
        case "SwitchStatement":
          state.popSwitchContext();
          break;
        case "SwitchCase":
          if (node.consequent.length === 0) {
            state.makeSwitchCaseBody(true, !node.test);
          }
          if (state.forkContext.reachable) {
            dontForward = true;
          }
          break;
        case "TryStatement":
          state.popTryContext();
          break;
        case "BreakStatement":
          forwardCurrentToHead(analyzer, node);
          state.makeBreak(node.label && node.label.name);
          dontForward = true;
          break;
        case "ContinueStatement":
          forwardCurrentToHead(analyzer, node);
          state.makeContinue(node.label && node.label.name);
          dontForward = true;
          break;
        case "ReturnStatement":
          forwardCurrentToHead(analyzer, node);
          state.makeReturn();
          dontForward = true;
          break;
        case "ThrowStatement":
          forwardCurrentToHead(analyzer, node);
          state.makeThrow();
          dontForward = true;
          break;
        case "Identifier":
          if (isIdentifierReference(node)) {
            state.makeFirstThrowablePathInTryBlock();
            dontForward = true;
          }
          break;
        case "CallExpression":
        case "ImportExpression":
        case "MemberExpression":
        case "NewExpression":
        case "YieldExpression":
          state.makeFirstThrowablePathInTryBlock();
          break;
        case "WhileStatement":
        case "DoWhileStatement":
        case "ForStatement":
        case "ForInStatement":
        case "ForOfStatement":
          state.popLoopContext();
          break;
        case "AssignmentPattern":
          state.popForkContext();
          break;
        case "LabeledStatement":
          if (!breakableTypePattern.test(node.body.type)) {
            state.popBreakContext();
          }
          break;
        default:
          break;
      }
      if (!dontForward) {
        forwardCurrentToHead(analyzer, node);
      }
      debug.dumpState(node, state, true);
    }
    function postprocess(analyzer, node) {
      function endCodePath() {
        let codePath = analyzer.codePath;
        CodePath.getState(codePath).makeFinal();
        leaveFromCurrentSegment(analyzer, node);
        debug.dump(`onCodePathEnd ${codePath.id}`);
        analyzer.emitter.emit("onCodePathEnd", codePath, node);
        debug.dumpDot(codePath);
        codePath = analyzer.codePath = analyzer.codePath.upper;
        if (codePath) {
          debug.dumpState(node, CodePath.getState(codePath), true);
        }
      }
      switch (node.type) {
        case "Program":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ArrowFunctionExpression":
        case "StaticBlock": {
          endCodePath();
          break;
        }
        case "CallExpression":
          if (node.optional === true && node.arguments.length === 0) {
            CodePath.getState(analyzer.codePath).makeOptionalRight();
          }
          break;
        default:
          break;
      }
      if (isPropertyDefinitionValue(node)) {
        endCodePath();
      }
    }
    var CodePathAnalyzer = class {
      /**
       * @param {EventGenerator} eventGenerator An event generator to wrap.
       */
      constructor(eventGenerator) {
        this.original = eventGenerator;
        this.emitter = eventGenerator.emitter;
        this.codePath = null;
        this.idGenerator = new IdGenerator("s");
        this.currentNode = null;
        this.onLooped = this.onLooped.bind(this);
      }
      /**
       * Does the process to enter a given AST node.
       * This updates state of analysis and calls `enterNode` of the wrapped.
       * @param {ASTNode} node A node which is entering.
       * @returns {void}
       */
      enterNode(node) {
        this.currentNode = node;
        if (node.parent) {
          preprocess(this, node);
        }
        processCodePathToEnter(this, node);
        this.original.enterNode(node);
        this.currentNode = null;
      }
      /**
       * Does the process to leave a given AST node.
       * This updates state of analysis and calls `leaveNode` of the wrapped.
       * @param {ASTNode} node A node which is leaving.
       * @returns {void}
       */
      leaveNode(node) {
        this.currentNode = node;
        processCodePathToExit(this, node);
        this.original.leaveNode(node);
        postprocess(this, node);
        this.currentNode = null;
      }
      /**
       * This is called on a code path looped.
       * Then this raises a looped event.
       * @param {CodePathSegment} fromSegment A segment of prev.
       * @param {CodePathSegment} toSegment A segment of next.
       * @returns {void}
       */
      onLooped(fromSegment, toSegment) {
        if (fromSegment.reachable && toSegment.reachable) {
          debug.dump(`onCodePathSegmentLoop ${fromSegment.id} -> ${toSegment.id}`);
          this.emitter.emit(
            "onCodePathSegmentLoop",
            fromSegment,
            toSegment,
            this.currentNode
          );
        }
      }
    };
    module.exports = CodePathAnalyzer;
  }
});

// ../../node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "../../node_modules/escape-string-regexp/index.js"(exports, module) {
    "use strict";
    module.exports = (string) => {
      if (typeof string !== "string") {
        throw new TypeError("Expected a string");
      }
      return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
    };
  }
});

// ../../node_modules/eslint/lib/linter/apply-disable-directives.js
var require_apply_disable_directives = __commonJS({
  "../../node_modules/eslint/lib/linter/apply-disable-directives.js"(exports, module) {
    "use strict";
    var escapeRegExp = require_escape_string_regexp();
    function compareLocations(itemA, itemB) {
      return itemA.line - itemB.line || itemA.column - itemB.column;
    }
    function groupByParentComment(directives) {
      const groups = /* @__PURE__ */ new Map();
      for (const directive of directives) {
        const { unprocessedDirective: { parentComment } } = directive;
        if (groups.has(parentComment)) {
          groups.get(parentComment).push(directive);
        } else {
          groups.set(parentComment, [directive]);
        }
      }
      return [...groups.values()];
    }
    function createIndividualDirectivesRemoval(directives, commentToken) {
      const commentValueStart = commentToken.range[0] + "//".length;
      const listStartOffset = /^\s*\S+\s+/u.exec(commentToken.value)[0].length;
      const listText = commentToken.value.slice(listStartOffset).split(/\s-{2,}\s/u)[0].trimEnd();
      return directives.map((directive) => {
        const { ruleId } = directive;
        const regex = new RegExp(String.raw`(?:^|\s*,\s*)${escapeRegExp(ruleId)}(?:\s*,\s*|$)`, "u");
        const match = regex.exec(listText);
        const matchedText = match[0];
        const matchStartOffset = listStartOffset + match.index;
        const matchEndOffset = matchStartOffset + matchedText.length;
        const firstIndexOfComma = matchedText.indexOf(",");
        const lastIndexOfComma = matchedText.lastIndexOf(",");
        let removalStartOffset, removalEndOffset;
        if (firstIndexOfComma !== lastIndexOfComma) {
          removalStartOffset = matchStartOffset + firstIndexOfComma;
          removalEndOffset = matchStartOffset + lastIndexOfComma;
        } else {
          removalStartOffset = matchStartOffset;
          removalEndOffset = matchEndOffset;
        }
        return {
          description: `'${ruleId}'`,
          fix: {
            range: [
              commentValueStart + removalStartOffset,
              commentValueStart + removalEndOffset
            ],
            text: ""
          },
          unprocessedDirective: directive.unprocessedDirective
        };
      });
    }
    function createCommentRemoval(directives, commentToken) {
      const { range } = commentToken;
      const ruleIds = directives.filter((directive) => directive.ruleId).map((directive) => `'${directive.ruleId}'`);
      return {
        description: ruleIds.length <= 2 ? ruleIds.join(" or ") : `${ruleIds.slice(0, ruleIds.length - 1).join(", ")}, or ${ruleIds[ruleIds.length - 1]}`,
        fix: {
          range,
          text: " "
        },
        unprocessedDirective: directives[0].unprocessedDirective
      };
    }
    function processUnusedDisableDirectives(allDirectives) {
      const directiveGroups = groupByParentComment(allDirectives);
      return directiveGroups.flatMap(
        (directives) => {
          const { parentComment } = directives[0].unprocessedDirective;
          const remainingRuleIds = new Set(parentComment.ruleIds);
          for (const directive of directives) {
            remainingRuleIds.delete(directive.ruleId);
          }
          return remainingRuleIds.size ? createIndividualDirectivesRemoval(directives, parentComment.commentToken) : [createCommentRemoval(directives, parentComment.commentToken)];
        }
      );
    }
    function applyDirectives(options) {
      const problems = [];
      const usedDisableDirectives = /* @__PURE__ */ new Set();
      for (const problem of options.problems) {
        let disableDirectivesForProblem = [];
        let nextDirectiveIndex = 0;
        while (nextDirectiveIndex < options.directives.length && compareLocations(options.directives[nextDirectiveIndex], problem) <= 0) {
          const directive = options.directives[nextDirectiveIndex++];
          if (directive.ruleId === null || directive.ruleId === problem.ruleId) {
            switch (directive.type) {
              case "disable":
                disableDirectivesForProblem.push(directive);
                break;
              case "enable":
                disableDirectivesForProblem = [];
                break;
            }
          }
        }
        if (disableDirectivesForProblem.length > 0) {
          const suppressions = disableDirectivesForProblem.map((directive) => ({
            kind: "directive",
            justification: directive.unprocessedDirective.justification
          }));
          if (problem.suppressions) {
            problem.suppressions = problem.suppressions.concat(suppressions);
          } else {
            problem.suppressions = suppressions;
            usedDisableDirectives.add(disableDirectivesForProblem[disableDirectivesForProblem.length - 1]);
          }
        }
        problems.push(problem);
      }
      const unusedDisableDirectivesToReport = options.directives.filter((directive) => directive.type === "disable" && !usedDisableDirectives.has(directive));
      const processed = processUnusedDisableDirectives(unusedDisableDirectivesToReport);
      const unusedDisableDirectives = processed.map(({ description, fix, unprocessedDirective }) => {
        const { parentComment, type, line, column } = unprocessedDirective;
        return {
          ruleId: null,
          message: description ? `Unused eslint-disable directive (no problems were reported from ${description}).` : "Unused eslint-disable directive (no problems were reported).",
          line: type === "disable-next-line" ? parentComment.commentToken.loc.start.line : line,
          column: type === "disable-next-line" ? parentComment.commentToken.loc.start.column + 1 : column,
          severity: options.reportUnusedDisableDirectives === "warn" ? 1 : 2,
          nodeType: null,
          ...options.disableFixes ? {} : { fix }
        };
      });
      return { problems, unusedDisableDirectives };
    }
    module.exports = ({ directives, disableFixes, problems, reportUnusedDisableDirectives = "off" }) => {
      const blockDirectives = directives.filter((directive) => directive.type === "disable" || directive.type === "enable").map((directive) => Object.assign({}, directive, { unprocessedDirective: directive })).sort(compareLocations);
      const lineDirectives = directives.flatMap((directive) => {
        switch (directive.type) {
          case "disable":
          case "enable":
            return [];
          case "disable-line":
            return [
              { type: "disable", line: directive.line, column: 1, ruleId: directive.ruleId, unprocessedDirective: directive },
              { type: "enable", line: directive.line + 1, column: 0, ruleId: directive.ruleId, unprocessedDirective: directive }
            ];
          case "disable-next-line":
            return [
              { type: "disable", line: directive.line + 1, column: 1, ruleId: directive.ruleId, unprocessedDirective: directive },
              { type: "enable", line: directive.line + 2, column: 0, ruleId: directive.ruleId, unprocessedDirective: directive }
            ];
          default:
            throw new TypeError(`Unrecognized directive type '${directive.type}'`);
        }
      }).sort(compareLocations);
      const blockDirectivesResult = applyDirectives({
        problems,
        directives: blockDirectives,
        disableFixes,
        reportUnusedDisableDirectives
      });
      const lineDirectivesResult = applyDirectives({
        problems: blockDirectivesResult.problems,
        directives: lineDirectives,
        disableFixes,
        reportUnusedDisableDirectives
      });
      return reportUnusedDisableDirectives !== "off" ? lineDirectivesResult.problems.concat(blockDirectivesResult.unusedDisableDirectives).concat(lineDirectivesResult.unusedDisableDirectives).sort(compareLocations) : lineDirectivesResult.problems;
    };
  }
});

// ../../node_modules/prelude-ls/lib/Func.js
var require_Func = __commonJS({
  "../../node_modules/prelude-ls/lib/Func.js"(exports, module) {
    var apply;
    var curry;
    var flip;
    var fix;
    var over;
    var memoize;
    var toString$ = {}.toString;
    apply = curry$(function(f, list) {
      return f.apply(null, list);
    });
    curry = function(f) {
      return curry$(f);
    };
    flip = curry$(function(f, x, y) {
      return f(y, x);
    });
    fix = function(f) {
      return function(g) {
        return function() {
          return f(g(g)).apply(null, arguments);
        };
      }(function(g) {
        return function() {
          return f(g(g)).apply(null, arguments);
        };
      });
    };
    over = curry$(function(f, g, x, y) {
      return f(g(x), g(y));
    });
    memoize = function(f) {
      var memo;
      memo = {};
      return function() {
        var args, res$, i$, to$, key, arg;
        res$ = [];
        for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
          res$.push(arguments[i$]);
        }
        args = res$;
        key = function() {
          var i$2, ref$, len$, results$ = [];
          for (i$2 = 0, len$ = (ref$ = args).length; i$2 < len$; ++i$2) {
            arg = ref$[i$2];
            results$.push(arg + toString$.call(arg).slice(8, -1));
          }
          return results$;
        }().join("");
        return memo[key] = key in memo ? memo[key] : f.apply(null, args);
      };
    };
    module.exports = {
      curry,
      flip,
      fix,
      apply,
      over,
      memoize
    };
    function curry$(f, bound) {
      var context, _curry = function(args) {
        return f.length > 1 ? function() {
          var params = args ? args.concat() : [];
          context = bound ? context || this : this;
          return params.push.apply(params, arguments) < f.length && arguments.length ? _curry.call(context, params) : f.apply(context, params);
        } : f;
      };
      return _curry();
    }
  }
});

// ../../node_modules/prelude-ls/lib/List.js
var require_List = __commonJS({
  "../../node_modules/prelude-ls/lib/List.js"(exports, module) {
    var each;
    var map;
    var compact;
    var filter;
    var reject;
    var remove;
    var partition;
    var find;
    var head;
    var first;
    var tail;
    var last;
    var initial;
    var empty;
    var reverse;
    var unique;
    var uniqueBy;
    var fold;
    var foldl;
    var fold1;
    var foldl1;
    var foldr;
    var foldr1;
    var unfoldr;
    var concat;
    var concatMap;
    var flatten;
    var difference;
    var intersection;
    var union;
    var countBy;
    var groupBy;
    var andList;
    var orList;
    var any;
    var all;
    var sort;
    var sortWith;
    var sortBy;
    var sum;
    var product;
    var mean;
    var average;
    var maximum;
    var minimum;
    var maximumBy;
    var minimumBy;
    var scan;
    var scanl;
    var scan1;
    var scanl1;
    var scanr;
    var scanr1;
    var slice;
    var take;
    var drop;
    var splitAt;
    var takeWhile;
    var dropWhile;
    var span;
    var breakList;
    var zip;
    var zipWith;
    var zipAll;
    var zipAllWith;
    var at;
    var elemIndex;
    var elemIndices;
    var findIndex;
    var findIndices;
    var toString$ = {}.toString;
    each = curry$(function(f, xs) {
      var i$, len$, x;
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        f(x);
      }
      return xs;
    });
    map = curry$(function(f, xs) {
      var i$, len$, x, results$ = [];
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        results$.push(f(x));
      }
      return results$;
    });
    compact = function(xs) {
      var i$, len$, x, results$ = [];
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        if (x) {
          results$.push(x);
        }
      }
      return results$;
    };
    filter = curry$(function(f, xs) {
      var i$, len$, x, results$ = [];
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        if (f(x)) {
          results$.push(x);
        }
      }
      return results$;
    });
    reject = curry$(function(f, xs) {
      var i$, len$, x, results$ = [];
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        if (!f(x)) {
          results$.push(x);
        }
      }
      return results$;
    });
    remove = curry$(function(el, xs) {
      var i, x$;
      i = elemIndex(el, xs);
      x$ = xs.slice();
      if (i != null) {
        x$.splice(i, 1);
      }
      return x$;
    });
    partition = curry$(function(f, xs) {
      var passed, failed, i$, len$, x;
      passed = [];
      failed = [];
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        (f(x) ? passed : failed).push(x);
      }
      return [passed, failed];
    });
    find = curry$(function(f, xs) {
      var i$, len$, x;
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        if (f(x)) {
          return x;
        }
      }
    });
    head = first = function(xs) {
      return xs[0];
    };
    tail = function(xs) {
      if (!xs.length) {
        return;
      }
      return xs.slice(1);
    };
    last = function(xs) {
      return xs[xs.length - 1];
    };
    initial = function(xs) {
      if (!xs.length) {
        return;
      }
      return xs.slice(0, -1);
    };
    empty = function(xs) {
      return !xs.length;
    };
    reverse = function(xs) {
      return xs.concat().reverse();
    };
    unique = function(xs) {
      var result, i$, len$, x;
      result = [];
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        if (!in$(x, result)) {
          result.push(x);
        }
      }
      return result;
    };
    uniqueBy = curry$(function(f, xs) {
      var seen, i$, len$, x, val, results$ = [];
      seen = [];
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        val = f(x);
        if (in$(val, seen)) {
          continue;
        }
        seen.push(val);
        results$.push(x);
      }
      return results$;
    });
    fold = foldl = curry$(function(f, memo, xs) {
      var i$, len$, x;
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        memo = f(memo, x);
      }
      return memo;
    });
    fold1 = foldl1 = curry$(function(f, xs) {
      return fold(f, xs[0], xs.slice(1));
    });
    foldr = curry$(function(f, memo, xs) {
      var i$, x;
      for (i$ = xs.length - 1; i$ >= 0; --i$) {
        x = xs[i$];
        memo = f(x, memo);
      }
      return memo;
    });
    foldr1 = curry$(function(f, xs) {
      return foldr(f, xs[xs.length - 1], xs.slice(0, -1));
    });
    unfoldr = curry$(function(f, b) {
      var result, x, that;
      result = [];
      x = b;
      while ((that = f(x)) != null) {
        result.push(that[0]);
        x = that[1];
      }
      return result;
    });
    concat = function(xss) {
      return [].concat.apply([], xss);
    };
    concatMap = curry$(function(f, xs) {
      var x;
      return [].concat.apply([], function() {
        var i$, ref$, len$, results$ = [];
        for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
          x = ref$[i$];
          results$.push(f(x));
        }
        return results$;
      }());
    });
    flatten = function(xs) {
      var x;
      return [].concat.apply([], function() {
        var i$, ref$, len$, results$ = [];
        for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
          x = ref$[i$];
          if (toString$.call(x).slice(8, -1) === "Array") {
            results$.push(flatten(x));
          } else {
            results$.push(x);
          }
        }
        return results$;
      }());
    };
    difference = function(xs) {
      var yss, res$, i$, to$, results, len$, x, j$, len1$, ys;
      res$ = [];
      for (i$ = 1, to$ = arguments.length; i$ < to$; ++i$) {
        res$.push(arguments[i$]);
      }
      yss = res$;
      results = [];
      outer:
        for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
          x = xs[i$];
          for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {
            ys = yss[j$];
            if (in$(x, ys)) {
              continue outer;
            }
          }
          results.push(x);
        }
      return results;
    };
    intersection = function(xs) {
      var yss, res$, i$, to$, results, len$, x, j$, len1$, ys;
      res$ = [];
      for (i$ = 1, to$ = arguments.length; i$ < to$; ++i$) {
        res$.push(arguments[i$]);
      }
      yss = res$;
      results = [];
      outer:
        for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
          x = xs[i$];
          for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {
            ys = yss[j$];
            if (!in$(x, ys)) {
              continue outer;
            }
          }
          results.push(x);
        }
      return results;
    };
    union = function() {
      var xss, res$, i$, to$, results, len$, xs, j$, len1$, x;
      res$ = [];
      for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
        res$.push(arguments[i$]);
      }
      xss = res$;
      results = [];
      for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
        xs = xss[i$];
        for (j$ = 0, len1$ = xs.length; j$ < len1$; ++j$) {
          x = xs[j$];
          if (!in$(x, results)) {
            results.push(x);
          }
        }
      }
      return results;
    };
    countBy = curry$(function(f, xs) {
      var results, i$, len$, x, key;
      results = {};
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        key = f(x);
        if (key in results) {
          results[key] += 1;
        } else {
          results[key] = 1;
        }
      }
      return results;
    });
    groupBy = curry$(function(f, xs) {
      var results, i$, len$, x, key;
      results = {};
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        key = f(x);
        if (key in results) {
          results[key].push(x);
        } else {
          results[key] = [x];
        }
      }
      return results;
    });
    andList = function(xs) {
      var i$, len$, x;
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        if (!x) {
          return false;
        }
      }
      return true;
    };
    orList = function(xs) {
      var i$, len$, x;
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        if (x) {
          return true;
        }
      }
      return false;
    };
    any = curry$(function(f, xs) {
      var i$, len$, x;
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        if (f(x)) {
          return true;
        }
      }
      return false;
    });
    all = curry$(function(f, xs) {
      var i$, len$, x;
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        if (!f(x)) {
          return false;
        }
      }
      return true;
    });
    sort = function(xs) {
      return xs.concat().sort(function(x, y) {
        if (x > y) {
          return 1;
        } else if (x < y) {
          return -1;
        } else {
          return 0;
        }
      });
    };
    sortWith = curry$(function(f, xs) {
      return xs.concat().sort(f);
    });
    sortBy = curry$(function(f, xs) {
      return xs.concat().sort(function(x, y) {
        if (f(x) > f(y)) {
          return 1;
        } else if (f(x) < f(y)) {
          return -1;
        } else {
          return 0;
        }
      });
    });
    sum = function(xs) {
      var result, i$, len$, x;
      result = 0;
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        result += x;
      }
      return result;
    };
    product = function(xs) {
      var result, i$, len$, x;
      result = 1;
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        result *= x;
      }
      return result;
    };
    mean = average = function(xs) {
      var sum2, i$, len$, x;
      sum2 = 0;
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        sum2 += x;
      }
      return sum2 / xs.length;
    };
    maximum = function(xs) {
      var max, i$, ref$, len$, x;
      max = xs[0];
      for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
        x = ref$[i$];
        if (x > max) {
          max = x;
        }
      }
      return max;
    };
    minimum = function(xs) {
      var min, i$, ref$, len$, x;
      min = xs[0];
      for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
        x = ref$[i$];
        if (x < min) {
          min = x;
        }
      }
      return min;
    };
    maximumBy = curry$(function(f, xs) {
      var max, i$, ref$, len$, x;
      max = xs[0];
      for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
        x = ref$[i$];
        if (f(x) > f(max)) {
          max = x;
        }
      }
      return max;
    });
    minimumBy = curry$(function(f, xs) {
      var min, i$, ref$, len$, x;
      min = xs[0];
      for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
        x = ref$[i$];
        if (f(x) < f(min)) {
          min = x;
        }
      }
      return min;
    });
    scan = scanl = curry$(function(f, memo, xs) {
      var last2, x;
      last2 = memo;
      return [memo].concat(function() {
        var i$, ref$, len$, results$ = [];
        for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
          x = ref$[i$];
          results$.push(last2 = f(last2, x));
        }
        return results$;
      }());
    });
    scan1 = scanl1 = curry$(function(f, xs) {
      if (!xs.length) {
        return;
      }
      return scan(f, xs[0], xs.slice(1));
    });
    scanr = curry$(function(f, memo, xs) {
      xs = xs.concat().reverse();
      return scan(f, memo, xs).reverse();
    });
    scanr1 = curry$(function(f, xs) {
      if (!xs.length) {
        return;
      }
      xs = xs.concat().reverse();
      return scan(f, xs[0], xs.slice(1)).reverse();
    });
    slice = curry$(function(x, y, xs) {
      return xs.slice(x, y);
    });
    take = curry$(function(n, xs) {
      if (n <= 0) {
        return xs.slice(0, 0);
      } else {
        return xs.slice(0, n);
      }
    });
    drop = curry$(function(n, xs) {
      if (n <= 0) {
        return xs;
      } else {
        return xs.slice(n);
      }
    });
    splitAt = curry$(function(n, xs) {
      return [take(n, xs), drop(n, xs)];
    });
    takeWhile = curry$(function(p, xs) {
      var len, i;
      len = xs.length;
      if (!len) {
        return xs;
      }
      i = 0;
      while (i < len && p(xs[i])) {
        i += 1;
      }
      return xs.slice(0, i);
    });
    dropWhile = curry$(function(p, xs) {
      var len, i;
      len = xs.length;
      if (!len) {
        return xs;
      }
      i = 0;
      while (i < len && p(xs[i])) {
        i += 1;
      }
      return xs.slice(i);
    });
    span = curry$(function(p, xs) {
      return [takeWhile(p, xs), dropWhile(p, xs)];
    });
    breakList = curry$(function(p, xs) {
      return span(compose$(p, not$), xs);
    });
    zip = curry$(function(xs, ys) {
      var result, len, i$, len$, i, x;
      result = [];
      len = ys.length;
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        i = i$;
        x = xs[i$];
        if (i === len) {
          break;
        }
        result.push([x, ys[i]]);
      }
      return result;
    });
    zipWith = curry$(function(f, xs, ys) {
      var result, len, i$, len$, i, x;
      result = [];
      len = ys.length;
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        i = i$;
        x = xs[i$];
        if (i === len) {
          break;
        }
        result.push(f(x, ys[i]));
      }
      return result;
    });
    zipAll = function() {
      var xss, res$, i$, to$, minLength, len$, xs, ref$, i, lresult$, j$, results$ = [];
      res$ = [];
      for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
        res$.push(arguments[i$]);
      }
      xss = res$;
      minLength = void 0;
      for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
        xs = xss[i$];
        minLength <= (ref$ = xs.length) || (minLength = ref$);
      }
      for (i$ = 0; i$ < minLength; ++i$) {
        i = i$;
        lresult$ = [];
        for (j$ = 0, len$ = xss.length; j$ < len$; ++j$) {
          xs = xss[j$];
          lresult$.push(xs[i]);
        }
        results$.push(lresult$);
      }
      return results$;
    };
    zipAllWith = function(f) {
      var xss, res$, i$, to$, minLength, len$, xs, ref$, i, results$ = [];
      res$ = [];
      for (i$ = 1, to$ = arguments.length; i$ < to$; ++i$) {
        res$.push(arguments[i$]);
      }
      xss = res$;
      minLength = void 0;
      for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
        xs = xss[i$];
        minLength <= (ref$ = xs.length) || (minLength = ref$);
      }
      for (i$ = 0; i$ < minLength; ++i$) {
        i = i$;
        results$.push(f.apply(null, fn$()));
      }
      return results$;
      function fn$() {
        var i$2, ref$2, len$2, results$2 = [];
        for (i$2 = 0, len$2 = (ref$2 = xss).length; i$2 < len$2; ++i$2) {
          xs = ref$2[i$2];
          results$2.push(xs[i]);
        }
        return results$2;
      }
    };
    at = curry$(function(n, xs) {
      if (n < 0) {
        return xs[xs.length + n];
      } else {
        return xs[n];
      }
    });
    elemIndex = curry$(function(el, xs) {
      var i$, len$, i, x;
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        i = i$;
        x = xs[i$];
        if (x === el) {
          return i;
        }
      }
    });
    elemIndices = curry$(function(el, xs) {
      var i$, len$, i, x, results$ = [];
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        i = i$;
        x = xs[i$];
        if (x === el) {
          results$.push(i);
        }
      }
      return results$;
    });
    findIndex = curry$(function(f, xs) {
      var i$, len$, i, x;
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        i = i$;
        x = xs[i$];
        if (f(x)) {
          return i;
        }
      }
    });
    findIndices = curry$(function(f, xs) {
      var i$, len$, i, x, results$ = [];
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        i = i$;
        x = xs[i$];
        if (f(x)) {
          results$.push(i);
        }
      }
      return results$;
    });
    module.exports = {
      each,
      map,
      filter,
      compact,
      reject,
      remove,
      partition,
      find,
      head,
      first,
      tail,
      last,
      initial,
      empty,
      reverse,
      difference,
      intersection,
      union,
      countBy,
      groupBy,
      fold,
      fold1,
      foldl,
      foldl1,
      foldr,
      foldr1,
      unfoldr,
      andList,
      orList,
      any,
      all,
      unique,
      uniqueBy,
      sort,
      sortWith,
      sortBy,
      sum,
      product,
      mean,
      average,
      concat,
      concatMap,
      flatten,
      maximum,
      minimum,
      maximumBy,
      minimumBy,
      scan,
      scan1,
      scanl,
      scanl1,
      scanr,
      scanr1,
      slice,
      take,
      drop,
      splitAt,
      takeWhile,
      dropWhile,
      span,
      breakList,
      zip,
      zipWith,
      zipAll,
      zipAllWith,
      at,
      elemIndex,
      elemIndices,
      findIndex,
      findIndices
    };
    function curry$(f, bound) {
      var context, _curry = function(args) {
        return f.length > 1 ? function() {
          var params = args ? args.concat() : [];
          context = bound ? context || this : this;
          return params.push.apply(params, arguments) < f.length && arguments.length ? _curry.call(context, params) : f.apply(context, params);
        } : f;
      };
      return _curry();
    }
    function in$(x, xs) {
      var i = -1, l = xs.length >>> 0;
      while (++i < l)
        if (x === xs[i])
          return true;
      return false;
    }
    function compose$() {
      var functions = arguments;
      return function() {
        var i, result;
        result = functions[0].apply(this, arguments);
        for (i = 1; i < functions.length; ++i) {
          result = functions[i](result);
        }
        return result;
      };
    }
    function not$(x) {
      return !x;
    }
  }
});

// ../../node_modules/prelude-ls/lib/Obj.js
var require_Obj = __commonJS({
  "../../node_modules/prelude-ls/lib/Obj.js"(exports, module) {
    var values;
    var keys;
    var pairsToObj;
    var objToPairs;
    var listsToObj;
    var objToLists;
    var empty;
    var each;
    var map;
    var compact;
    var filter;
    var reject;
    var partition;
    var find;
    values = function(object) {
      var i$, x, results$ = [];
      for (i$ in object) {
        x = object[i$];
        results$.push(x);
      }
      return results$;
    };
    keys = function(object) {
      var x, results$ = [];
      for (x in object) {
        results$.push(x);
      }
      return results$;
    };
    pairsToObj = function(object) {
      var i$, len$, x, resultObj$ = {};
      for (i$ = 0, len$ = object.length; i$ < len$; ++i$) {
        x = object[i$];
        resultObj$[x[0]] = x[1];
      }
      return resultObj$;
    };
    objToPairs = function(object) {
      var key, value, results$ = [];
      for (key in object) {
        value = object[key];
        results$.push([key, value]);
      }
      return results$;
    };
    listsToObj = curry$(function(keys2, values2) {
      var i$, len$, i, key, resultObj$ = {};
      for (i$ = 0, len$ = keys2.length; i$ < len$; ++i$) {
        i = i$;
        key = keys2[i$];
        resultObj$[key] = values2[i];
      }
      return resultObj$;
    });
    objToLists = function(object) {
      var keys2, values2, key, value;
      keys2 = [];
      values2 = [];
      for (key in object) {
        value = object[key];
        keys2.push(key);
        values2.push(value);
      }
      return [keys2, values2];
    };
    empty = function(object) {
      var x;
      for (x in object) {
        return false;
      }
      return true;
    };
    each = curry$(function(f, object) {
      var i$, x;
      for (i$ in object) {
        x = object[i$];
        f(x);
      }
      return object;
    });
    map = curry$(function(f, object) {
      var k, x, resultObj$ = {};
      for (k in object) {
        x = object[k];
        resultObj$[k] = f(x);
      }
      return resultObj$;
    });
    compact = function(object) {
      var k, x, resultObj$ = {};
      for (k in object) {
        x = object[k];
        if (x) {
          resultObj$[k] = x;
        }
      }
      return resultObj$;
    };
    filter = curry$(function(f, object) {
      var k, x, resultObj$ = {};
      for (k in object) {
        x = object[k];
        if (f(x)) {
          resultObj$[k] = x;
        }
      }
      return resultObj$;
    });
    reject = curry$(function(f, object) {
      var k, x, resultObj$ = {};
      for (k in object) {
        x = object[k];
        if (!f(x)) {
          resultObj$[k] = x;
        }
      }
      return resultObj$;
    });
    partition = curry$(function(f, object) {
      var passed, failed, k, x;
      passed = {};
      failed = {};
      for (k in object) {
        x = object[k];
        (f(x) ? passed : failed)[k] = x;
      }
      return [passed, failed];
    });
    find = curry$(function(f, object) {
      var i$, x;
      for (i$ in object) {
        x = object[i$];
        if (f(x)) {
          return x;
        }
      }
    });
    module.exports = {
      values,
      keys,
      pairsToObj,
      objToPairs,
      listsToObj,
      objToLists,
      empty,
      each,
      map,
      filter,
      compact,
      reject,
      partition,
      find
    };
    function curry$(f, bound) {
      var context, _curry = function(args) {
        return f.length > 1 ? function() {
          var params = args ? args.concat() : [];
          context = bound ? context || this : this;
          return params.push.apply(params, arguments) < f.length && arguments.length ? _curry.call(context, params) : f.apply(context, params);
        } : f;
      };
      return _curry();
    }
  }
});

// ../../node_modules/prelude-ls/lib/Str.js
var require_Str = __commonJS({
  "../../node_modules/prelude-ls/lib/Str.js"(exports, module) {
    var split;
    var join;
    var lines;
    var unlines;
    var words;
    var unwords;
    var chars;
    var unchars;
    var reverse;
    var repeat;
    var capitalize;
    var camelize;
    var dasherize;
    split = curry$(function(sep, str) {
      return str.split(sep);
    });
    join = curry$(function(sep, xs) {
      return xs.join(sep);
    });
    lines = function(str) {
      if (!str.length) {
        return [];
      }
      return str.split("\n");
    };
    unlines = function(it) {
      return it.join("\n");
    };
    words = function(str) {
      if (!str.length) {
        return [];
      }
      return str.split(/[ ]+/);
    };
    unwords = function(it) {
      return it.join(" ");
    };
    chars = function(it) {
      return it.split("");
    };
    unchars = function(it) {
      return it.join("");
    };
    reverse = function(str) {
      return str.split("").reverse().join("");
    };
    repeat = curry$(function(n, str) {
      var result, i$;
      result = "";
      for (i$ = 0; i$ < n; ++i$) {
        result += str;
      }
      return result;
    });
    capitalize = function(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    };
    camelize = function(it) {
      return it.replace(/[-_]+(.)?/g, function(arg$, c) {
        return (c != null ? c : "").toUpperCase();
      });
    };
    dasherize = function(str) {
      return str.replace(/([^-A-Z])([A-Z]+)/g, function(arg$, lower, upper) {
        return lower + "-" + (upper.length > 1 ? upper : upper.toLowerCase());
      }).replace(/^([A-Z]+)/, function(arg$, upper) {
        if (upper.length > 1) {
          return upper + "-";
        } else {
          return upper.toLowerCase();
        }
      });
    };
    module.exports = {
      split,
      join,
      lines,
      unlines,
      words,
      unwords,
      chars,
      unchars,
      reverse,
      repeat,
      capitalize,
      camelize,
      dasherize
    };
    function curry$(f, bound) {
      var context, _curry = function(args) {
        return f.length > 1 ? function() {
          var params = args ? args.concat() : [];
          context = bound ? context || this : this;
          return params.push.apply(params, arguments) < f.length && arguments.length ? _curry.call(context, params) : f.apply(context, params);
        } : f;
      };
      return _curry();
    }
  }
});

// ../../node_modules/prelude-ls/lib/Num.js
var require_Num = __commonJS({
  "../../node_modules/prelude-ls/lib/Num.js"(exports, module) {
    var max;
    var min;
    var negate;
    var abs;
    var signum;
    var quot;
    var rem;
    var div;
    var mod;
    var recip;
    var pi;
    var tau;
    var exp;
    var sqrt;
    var ln;
    var pow;
    var sin;
    var tan;
    var cos;
    var asin;
    var acos;
    var atan;
    var atan2;
    var truncate;
    var round;
    var ceiling;
    var floor;
    var isItNaN;
    var even;
    var odd;
    var gcd;
    var lcm;
    max = curry$(function(x$, y$) {
      return x$ > y$ ? x$ : y$;
    });
    min = curry$(function(x$, y$) {
      return x$ < y$ ? x$ : y$;
    });
    negate = function(x) {
      return -x;
    };
    abs = Math.abs;
    signum = function(x) {
      if (x < 0) {
        return -1;
      } else if (x > 0) {
        return 1;
      } else {
        return 0;
      }
    };
    quot = curry$(function(x, y) {
      return ~~(x / y);
    });
    rem = curry$(function(x$, y$) {
      return x$ % y$;
    });
    div = curry$(function(x, y) {
      return Math.floor(x / y);
    });
    mod = curry$(function(x$, y$) {
      var ref$;
      return (x$ % (ref$ = y$) + ref$) % ref$;
    });
    recip = function(it) {
      return 1 / it;
    };
    pi = Math.PI;
    tau = pi * 2;
    exp = Math.exp;
    sqrt = Math.sqrt;
    ln = Math.log;
    pow = curry$(function(x$, y$) {
      return Math.pow(x$, y$);
    });
    sin = Math.sin;
    tan = Math.tan;
    cos = Math.cos;
    asin = Math.asin;
    acos = Math.acos;
    atan = Math.atan;
    atan2 = curry$(function(x, y) {
      return Math.atan2(x, y);
    });
    truncate = function(x) {
      return ~~x;
    };
    round = Math.round;
    ceiling = Math.ceil;
    floor = Math.floor;
    isItNaN = function(x) {
      return x !== x;
    };
    even = function(x) {
      return x % 2 === 0;
    };
    odd = function(x) {
      return x % 2 !== 0;
    };
    gcd = curry$(function(x, y) {
      var z;
      x = Math.abs(x);
      y = Math.abs(y);
      while (y !== 0) {
        z = x % y;
        x = y;
        y = z;
      }
      return x;
    });
    lcm = curry$(function(x, y) {
      return Math.abs(Math.floor(x / gcd(x, y) * y));
    });
    module.exports = {
      max,
      min,
      negate,
      abs,
      signum,
      quot,
      rem,
      div,
      mod,
      recip,
      pi,
      tau,
      exp,
      sqrt,
      ln,
      pow,
      sin,
      tan,
      cos,
      acos,
      asin,
      atan,
      atan2,
      truncate,
      round,
      ceiling,
      floor,
      isItNaN,
      even,
      odd,
      gcd,
      lcm
    };
    function curry$(f, bound) {
      var context, _curry = function(args) {
        return f.length > 1 ? function() {
          var params = args ? args.concat() : [];
          context = bound ? context || this : this;
          return params.push.apply(params, arguments) < f.length && arguments.length ? _curry.call(context, params) : f.apply(context, params);
        } : f;
      };
      return _curry();
    }
  }
});

// ../../node_modules/prelude-ls/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/prelude-ls/lib/index.js"(exports, module) {
    var Func;
    var List;
    var Obj;
    var Str;
    var Num;
    var id;
    var isType;
    var replicate;
    var prelude;
    var toString$ = {}.toString;
    Func = require_Func();
    List = require_List();
    Obj = require_Obj();
    Str = require_Str();
    Num = require_Num();
    id = function(x) {
      return x;
    };
    isType = curry$(function(type, x) {
      return toString$.call(x).slice(8, -1) === type;
    });
    replicate = curry$(function(n, x) {
      var i$, results$ = [];
      for (i$ = 0; i$ < n; ++i$) {
        results$.push(x);
      }
      return results$;
    });
    Str.empty = List.empty;
    Str.slice = List.slice;
    Str.take = List.take;
    Str.drop = List.drop;
    Str.splitAt = List.splitAt;
    Str.takeWhile = List.takeWhile;
    Str.dropWhile = List.dropWhile;
    Str.span = List.span;
    Str.breakStr = List.breakList;
    prelude = {
      Func,
      List,
      Obj,
      Str,
      Num,
      id,
      isType,
      replicate
    };
    prelude.each = List.each;
    prelude.map = List.map;
    prelude.filter = List.filter;
    prelude.compact = List.compact;
    prelude.reject = List.reject;
    prelude.partition = List.partition;
    prelude.find = List.find;
    prelude.head = List.head;
    prelude.first = List.first;
    prelude.tail = List.tail;
    prelude.last = List.last;
    prelude.initial = List.initial;
    prelude.empty = List.empty;
    prelude.reverse = List.reverse;
    prelude.difference = List.difference;
    prelude.intersection = List.intersection;
    prelude.union = List.union;
    prelude.countBy = List.countBy;
    prelude.groupBy = List.groupBy;
    prelude.fold = List.fold;
    prelude.foldl = List.foldl;
    prelude.fold1 = List.fold1;
    prelude.foldl1 = List.foldl1;
    prelude.foldr = List.foldr;
    prelude.foldr1 = List.foldr1;
    prelude.unfoldr = List.unfoldr;
    prelude.andList = List.andList;
    prelude.orList = List.orList;
    prelude.any = List.any;
    prelude.all = List.all;
    prelude.unique = List.unique;
    prelude.uniqueBy = List.uniqueBy;
    prelude.sort = List.sort;
    prelude.sortWith = List.sortWith;
    prelude.sortBy = List.sortBy;
    prelude.sum = List.sum;
    prelude.product = List.product;
    prelude.mean = List.mean;
    prelude.average = List.average;
    prelude.concat = List.concat;
    prelude.concatMap = List.concatMap;
    prelude.flatten = List.flatten;
    prelude.maximum = List.maximum;
    prelude.minimum = List.minimum;
    prelude.maximumBy = List.maximumBy;
    prelude.minimumBy = List.minimumBy;
    prelude.scan = List.scan;
    prelude.scanl = List.scanl;
    prelude.scan1 = List.scan1;
    prelude.scanl1 = List.scanl1;
    prelude.scanr = List.scanr;
    prelude.scanr1 = List.scanr1;
    prelude.slice = List.slice;
    prelude.take = List.take;
    prelude.drop = List.drop;
    prelude.splitAt = List.splitAt;
    prelude.takeWhile = List.takeWhile;
    prelude.dropWhile = List.dropWhile;
    prelude.span = List.span;
    prelude.breakList = List.breakList;
    prelude.zip = List.zip;
    prelude.zipWith = List.zipWith;
    prelude.zipAll = List.zipAll;
    prelude.zipAllWith = List.zipAllWith;
    prelude.at = List.at;
    prelude.elemIndex = List.elemIndex;
    prelude.elemIndices = List.elemIndices;
    prelude.findIndex = List.findIndex;
    prelude.findIndices = List.findIndices;
    prelude.apply = Func.apply;
    prelude.curry = Func.curry;
    prelude.flip = Func.flip;
    prelude.fix = Func.fix;
    prelude.over = Func.over;
    prelude.split = Str.split;
    prelude.join = Str.join;
    prelude.lines = Str.lines;
    prelude.unlines = Str.unlines;
    prelude.words = Str.words;
    prelude.unwords = Str.unwords;
    prelude.chars = Str.chars;
    prelude.unchars = Str.unchars;
    prelude.repeat = Str.repeat;
    prelude.capitalize = Str.capitalize;
    prelude.camelize = Str.camelize;
    prelude.dasherize = Str.dasherize;
    prelude.values = Obj.values;
    prelude.keys = Obj.keys;
    prelude.pairsToObj = Obj.pairsToObj;
    prelude.objToPairs = Obj.objToPairs;
    prelude.listsToObj = Obj.listsToObj;
    prelude.objToLists = Obj.objToLists;
    prelude.max = Num.max;
    prelude.min = Num.min;
    prelude.negate = Num.negate;
    prelude.abs = Num.abs;
    prelude.signum = Num.signum;
    prelude.quot = Num.quot;
    prelude.rem = Num.rem;
    prelude.div = Num.div;
    prelude.mod = Num.mod;
    prelude.recip = Num.recip;
    prelude.pi = Num.pi;
    prelude.tau = Num.tau;
    prelude.exp = Num.exp;
    prelude.sqrt = Num.sqrt;
    prelude.ln = Num.ln;
    prelude.pow = Num.pow;
    prelude.sin = Num.sin;
    prelude.tan = Num.tan;
    prelude.cos = Num.cos;
    prelude.acos = Num.acos;
    prelude.asin = Num.asin;
    prelude.atan = Num.atan;
    prelude.atan2 = Num.atan2;
    prelude.truncate = Num.truncate;
    prelude.round = Num.round;
    prelude.ceiling = Num.ceiling;
    prelude.floor = Num.floor;
    prelude.isItNaN = Num.isItNaN;
    prelude.even = Num.even;
    prelude.odd = Num.odd;
    prelude.gcd = Num.gcd;
    prelude.lcm = Num.lcm;
    prelude.VERSION = "1.2.1";
    module.exports = prelude;
    function curry$(f, bound) {
      var context, _curry = function(args) {
        return f.length > 1 ? function() {
          var params = args ? args.concat() : [];
          context = bound ? context || this : this;
          return params.push.apply(params, arguments) < f.length && arguments.length ? _curry.call(context, params) : f.apply(context, params);
        } : f;
      };
      return _curry();
    }
  }
});

// ../../node_modules/levn/lib/parse-string.js
var require_parse_string = __commonJS({
  "../../node_modules/levn/lib/parse-string.js"(exports, module) {
    (function() {
      var reject, special, tokenRegex;
      reject = require_lib().reject;
      function consumeOp(tokens, op) {
        if (tokens[0] === op) {
          return tokens.shift();
        } else {
          throw new Error("Expected '" + op + "', but got '" + tokens[0] + "' instead in " + JSON.stringify(tokens) + ".");
        }
      }
      function maybeConsumeOp(tokens, op) {
        if (tokens[0] === op) {
          return tokens.shift();
        }
      }
      function consumeList(tokens, arg$, hasDelimiters) {
        var open, close, result, untilTest;
        open = arg$[0], close = arg$[1];
        if (hasDelimiters) {
          consumeOp(tokens, open);
        }
        result = [];
        untilTest = "," + (hasDelimiters ? close : "");
        while (tokens.length && (hasDelimiters && tokens[0] !== close)) {
          result.push(consumeElement(tokens, untilTest));
          maybeConsumeOp(tokens, ",");
        }
        if (hasDelimiters) {
          consumeOp(tokens, close);
        }
        return result;
      }
      function consumeArray(tokens, hasDelimiters) {
        return consumeList(tokens, ["[", "]"], hasDelimiters);
      }
      function consumeTuple(tokens, hasDelimiters) {
        return consumeList(tokens, ["(", ")"], hasDelimiters);
      }
      function consumeFields(tokens, hasDelimiters) {
        var result, untilTest, key;
        if (hasDelimiters) {
          consumeOp(tokens, "{");
        }
        result = {};
        untilTest = "," + (hasDelimiters ? "}" : "");
        while (tokens.length && (!hasDelimiters || tokens[0] !== "}")) {
          key = consumeValue(tokens, ":");
          consumeOp(tokens, ":");
          result[key] = consumeElement(tokens, untilTest);
          maybeConsumeOp(tokens, ",");
        }
        if (hasDelimiters) {
          consumeOp(tokens, "}");
        }
        return result;
      }
      function consumeValue(tokens, untilTest) {
        var out;
        untilTest == null && (untilTest = "");
        out = "";
        while (tokens.length && -1 === untilTest.indexOf(tokens[0])) {
          out += tokens.shift();
        }
        return out;
      }
      function consumeElement(tokens, untilTest) {
        switch (tokens[0]) {
          case "[":
            return consumeArray(tokens, true);
          case "(":
            return consumeTuple(tokens, true);
          case "{":
            return consumeFields(tokens, true);
          default:
            return consumeValue(tokens, untilTest);
        }
      }
      function consumeTopLevel(tokens, types, options) {
        var ref$, type, structure, origTokens, result, finalResult, x$, y$;
        ref$ = types[0], type = ref$.type, structure = ref$.structure;
        origTokens = tokens.concat();
        if (!options.explicit && types.length === 1 && (!type && structure || (type === "Array" || type === "Object"))) {
          result = structure === "array" || type === "Array" ? consumeArray(tokens, tokens[0] === "[") : structure === "tuple" ? consumeTuple(tokens, tokens[0] === "(") : consumeFields(tokens, tokens[0] === "{");
          finalResult = tokens.length ? consumeElement(structure === "array" || type === "Array" ? (x$ = origTokens, x$.unshift("["), x$.push("]"), x$) : (y$ = origTokens, y$.unshift("("), y$.push(")"), y$)) : result;
        } else {
          finalResult = consumeElement(tokens);
        }
        return finalResult;
      }
      special = /\[\]\(\)}{:,/.source;
      tokenRegex = RegExp(`("(?:\\\\"|[^"])*")|('(?:\\\\'|[^'])*')|(/(?:\\\\/|[^/])*/[a-zA-Z]*)|(#.*#)|([` + special + "])|([^\\s" + special + "](?:\\s*[^\\s" + special + "]+)*)|\\s*");
      module.exports = function(types, string, options) {
        var tokens, node;
        options == null && (options = {});
        if (!options.explicit && types.length === 1 && types[0].type === "String") {
          return string;
        }
        tokens = reject(not$, string.split(tokenRegex));
        node = consumeTopLevel(tokens, types, options);
        if (!node) {
          throw new Error("Error parsing '" + string + "'.");
        }
        return node;
      };
      function not$(x) {
        return !x;
      }
    }).call(exports);
  }
});

// ../../node_modules/type-check/lib/parse-type.js
var require_parse_type = __commonJS({
  "../../node_modules/type-check/lib/parse-type.js"(exports, module) {
    (function() {
      var identifierRegex, tokenRegex;
      identifierRegex = /[\$\w]+/;
      function peek(tokens) {
        var token;
        token = tokens[0];
        if (token == null) {
          throw new Error("Unexpected end of input.");
        }
        return token;
      }
      function consumeIdent(tokens) {
        var token;
        token = peek(tokens);
        if (!identifierRegex.test(token)) {
          throw new Error("Expected text, got '" + token + "' instead.");
        }
        return tokens.shift();
      }
      function consumeOp(tokens, op) {
        var token;
        token = peek(tokens);
        if (token !== op) {
          throw new Error("Expected '" + op + "', got '" + token + "' instead.");
        }
        return tokens.shift();
      }
      function maybeConsumeOp(tokens, op) {
        var token;
        token = tokens[0];
        if (token === op) {
          return tokens.shift();
        } else {
          return null;
        }
      }
      function consumeArray(tokens) {
        var types;
        consumeOp(tokens, "[");
        if (peek(tokens) === "]") {
          throw new Error("Must specify type of Array - eg. [Type], got [] instead.");
        }
        types = consumeTypes(tokens);
        consumeOp(tokens, "]");
        return {
          structure: "array",
          of: types
        };
      }
      function consumeTuple(tokens) {
        var components;
        components = [];
        consumeOp(tokens, "(");
        if (peek(tokens) === ")") {
          throw new Error("Tuple must be of at least length 1 - eg. (Type), got () instead.");
        }
        for (; ; ) {
          components.push(consumeTypes(tokens));
          maybeConsumeOp(tokens, ",");
          if (")" === peek(tokens)) {
            break;
          }
        }
        consumeOp(tokens, ")");
        return {
          structure: "tuple",
          of: components
        };
      }
      function consumeFields(tokens) {
        var fields, subset, ref$, key, types;
        fields = {};
        consumeOp(tokens, "{");
        subset = false;
        for (; ; ) {
          if (maybeConsumeOp(tokens, "...")) {
            subset = true;
            break;
          }
          ref$ = consumeField(tokens), key = ref$[0], types = ref$[1];
          fields[key] = types;
          maybeConsumeOp(tokens, ",");
          if ("}" === peek(tokens)) {
            break;
          }
        }
        consumeOp(tokens, "}");
        return {
          structure: "fields",
          of: fields,
          subset
        };
      }
      function consumeField(tokens) {
        var key, types;
        key = consumeIdent(tokens);
        consumeOp(tokens, ":");
        types = consumeTypes(tokens);
        return [key, types];
      }
      function maybeConsumeStructure(tokens) {
        switch (tokens[0]) {
          case "[":
            return consumeArray(tokens);
          case "(":
            return consumeTuple(tokens);
          case "{":
            return consumeFields(tokens);
        }
      }
      function consumeType(tokens) {
        var token, wildcard, type, structure;
        token = peek(tokens);
        wildcard = token === "*";
        if (wildcard || identifierRegex.test(token)) {
          type = wildcard ? consumeOp(tokens, "*") : consumeIdent(tokens);
          structure = maybeConsumeStructure(tokens);
          if (structure) {
            return structure.type = type, structure;
          } else {
            return {
              type
            };
          }
        } else {
          structure = maybeConsumeStructure(tokens);
          if (!structure) {
            throw new Error("Unexpected character: " + token);
          }
          return structure;
        }
      }
      function consumeTypes(tokens) {
        var lookahead, types, typesSoFar, typeObj, type, structure;
        if ("::" === peek(tokens)) {
          throw new Error("No comment before comment separator '::' found.");
        }
        lookahead = tokens[1];
        if (lookahead != null && lookahead === "::") {
          tokens.shift();
          tokens.shift();
        }
        types = [];
        typesSoFar = {};
        if ("Maybe" === peek(tokens)) {
          tokens.shift();
          types = [
            {
              type: "Undefined"
            },
            {
              type: "Null"
            }
          ];
          typesSoFar = {
            Undefined: true,
            Null: true
          };
        }
        for (; ; ) {
          typeObj = consumeType(tokens), type = typeObj.type, structure = typeObj.structure;
          if (!typesSoFar[type]) {
            types.push(typeObj);
          }
          if (structure == null) {
            typesSoFar[type] = true;
          }
          if (!maybeConsumeOp(tokens, "|")) {
            break;
          }
        }
        return types;
      }
      tokenRegex = RegExp("\\.\\.\\.|::|->|" + identifierRegex.source + "|\\S", "g");
      module.exports = function(input) {
        var tokens, e;
        if (!input.length) {
          throw new Error("No type specified.");
        }
        tokens = input.match(tokenRegex) || [];
        if (in$("->", tokens)) {
          throw new Error("Function types are not supported. To validate that something is a function, you may use 'Function'.");
        }
        try {
          return consumeTypes(tokens);
        } catch (e$) {
          e = e$;
          throw new Error(e.message + " - Remaining tokens: " + JSON.stringify(tokens) + " - Initial input: '" + input + "'");
        }
      };
      function in$(x, xs) {
        var i = -1, l = xs.length >>> 0;
        while (++i < l)
          if (x === xs[i])
            return true;
        return false;
      }
    }).call(exports);
  }
});

// ../../node_modules/type-check/lib/check.js
var require_check = __commonJS({
  "../../node_modules/type-check/lib/check.js"(exports, module) {
    (function() {
      var ref$, any, all, isItNaN, types, defaultType, toString$ = {}.toString;
      ref$ = require_lib(), any = ref$.any, all = ref$.all, isItNaN = ref$.isItNaN;
      types = {
        Number: {
          typeOf: "Number",
          validate: function(it) {
            return !isItNaN(it);
          }
        },
        NaN: {
          typeOf: "Number",
          validate: isItNaN
        },
        Int: {
          typeOf: "Number",
          validate: function(it) {
            return !isItNaN(it) && it % 1 === 0;
          }
        },
        Float: {
          typeOf: "Number",
          validate: function(it) {
            return !isItNaN(it);
          }
        },
        Date: {
          typeOf: "Date",
          validate: function(it) {
            return !isItNaN(it.getTime());
          }
        }
      };
      defaultType = {
        array: "Array",
        tuple: "Array"
      };
      function checkArray(input, type, options) {
        return all(function(it) {
          return checkMultiple(it, type.of, options);
        }, input);
      }
      function checkTuple(input, type, options) {
        var i, i$, ref$2, len$, types2;
        i = 0;
        for (i$ = 0, len$ = (ref$2 = type.of).length; i$ < len$; ++i$) {
          types2 = ref$2[i$];
          if (!checkMultiple(input[i], types2, options)) {
            return false;
          }
          i++;
        }
        return input.length <= i;
      }
      function checkFields(input, type, options) {
        var inputKeys, numInputKeys, k, numOfKeys, key, ref$2, types2;
        inputKeys = {};
        numInputKeys = 0;
        for (k in input) {
          inputKeys[k] = true;
          numInputKeys++;
        }
        numOfKeys = 0;
        for (key in ref$2 = type.of) {
          types2 = ref$2[key];
          if (!checkMultiple(input[key], types2, options)) {
            return false;
          }
          if (inputKeys[key]) {
            numOfKeys++;
          }
        }
        return type.subset || numInputKeys === numOfKeys;
      }
      function checkStructure(input, type, options) {
        if (!(input instanceof Object)) {
          return false;
        }
        switch (type.structure) {
          case "fields":
            return checkFields(input, type, options);
          case "array":
            return checkArray(input, type, options);
          case "tuple":
            return checkTuple(input, type, options);
        }
      }
      function check(input, typeObj, options) {
        var type, structure, setting, that;
        type = typeObj.type, structure = typeObj.structure;
        if (type) {
          if (type === "*") {
            return true;
          }
          setting = options.customTypes[type] || types[type];
          if (setting) {
            return (setting.typeOf === void 0 || setting.typeOf === toString$.call(input).slice(8, -1)) && setting.validate(input);
          } else {
            return type === toString$.call(input).slice(8, -1) && (!structure || checkStructure(input, typeObj, options));
          }
        } else if (structure) {
          if (that = defaultType[structure]) {
            if (that !== toString$.call(input).slice(8, -1)) {
              return false;
            }
          }
          return checkStructure(input, typeObj, options);
        } else {
          throw new Error("No type defined. Input: " + input + ".");
        }
      }
      function checkMultiple(input, types2, options) {
        if (toString$.call(types2).slice(8, -1) !== "Array") {
          throw new Error("Types must be in an array. Input: " + input + ".");
        }
        return any(function(it) {
          return check(input, it, options);
        }, types2);
      }
      module.exports = function(parsedType, input, options) {
        options == null && (options = {});
        if (options.customTypes == null) {
          options.customTypes = {};
        }
        return checkMultiple(input, parsedType, options);
      };
    }).call(exports);
  }
});

// ../../node_modules/type-check/lib/index.js
var require_lib2 = __commonJS({
  "../../node_modules/type-check/lib/index.js"(exports, module) {
    (function() {
      var VERSION, parseType, parsedTypeCheck, typeCheck;
      VERSION = "0.4.0";
      parseType = require_parse_type();
      parsedTypeCheck = require_check();
      typeCheck = function(type, input, options) {
        return parsedTypeCheck(parseType(type), input, options);
      };
      module.exports = {
        VERSION,
        typeCheck,
        parsedTypeCheck,
        parseType
      };
    }).call(exports);
  }
});

// ../../node_modules/levn/lib/cast.js
var require_cast = __commonJS({
  "../../node_modules/levn/lib/cast.js"(exports, module) {
    (function() {
      var parsedTypeCheck, types, toString$ = {}.toString;
      parsedTypeCheck = require_lib2().parsedTypeCheck;
      types = {
        "*": function(value, options) {
          switch (toString$.call(value).slice(8, -1)) {
            case "Array":
              return typeCast(value, {
                type: "Array"
              }, options);
            case "Object":
              return typeCast(value, {
                type: "Object"
              }, options);
            default:
              return {
                type: "Just",
                value: typesCast(value, [
                  {
                    type: "Undefined"
                  },
                  {
                    type: "Null"
                  },
                  {
                    type: "NaN"
                  },
                  {
                    type: "Boolean"
                  },
                  {
                    type: "Number"
                  },
                  {
                    type: "Date"
                  },
                  {
                    type: "RegExp"
                  },
                  {
                    type: "Array"
                  },
                  {
                    type: "Object"
                  },
                  {
                    type: "String"
                  }
                ], (options.explicit = true, options))
              };
          }
        },
        Undefined: function(it) {
          if (it === "undefined" || it === void 0) {
            return {
              type: "Just",
              value: void 0
            };
          } else {
            return {
              type: "Nothing"
            };
          }
        },
        Null: function(it) {
          if (it === "null") {
            return {
              type: "Just",
              value: null
            };
          } else {
            return {
              type: "Nothing"
            };
          }
        },
        NaN: function(it) {
          if (it === "NaN") {
            return {
              type: "Just",
              value: NaN
            };
          } else {
            return {
              type: "Nothing"
            };
          }
        },
        Boolean: function(it) {
          if (it === "true") {
            return {
              type: "Just",
              value: true
            };
          } else if (it === "false") {
            return {
              type: "Just",
              value: false
            };
          } else {
            return {
              type: "Nothing"
            };
          }
        },
        Number: function(it) {
          return {
            type: "Just",
            value: +it
          };
        },
        Int: function(it) {
          return {
            type: "Just",
            value: +it
          };
        },
        Float: function(it) {
          return {
            type: "Just",
            value: +it
          };
        },
        Date: function(value, options) {
          var that;
          if (that = /^\#([\s\S]*)\#$/.exec(value)) {
            return {
              type: "Just",
              value: new Date(+that[1] || that[1])
            };
          } else if (options.explicit) {
            return {
              type: "Nothing"
            };
          } else {
            return {
              type: "Just",
              value: new Date(+value || value)
            };
          }
        },
        RegExp: function(value, options) {
          var that;
          if (that = /^\/([\s\S]*)\/([gimy]*)$/.exec(value)) {
            return {
              type: "Just",
              value: new RegExp(that[1], that[2])
            };
          } else if (options.explicit) {
            return {
              type: "Nothing"
            };
          } else {
            return {
              type: "Just",
              value: new RegExp(value)
            };
          }
        },
        Array: function(value, options) {
          return castArray(value, {
            of: [{
              type: "*"
            }]
          }, options);
        },
        Object: function(value, options) {
          return castFields(value, {
            of: {}
          }, options);
        },
        String: function(it) {
          var replace, that;
          if (toString$.call(it).slice(8, -1) !== "String") {
            return {
              type: "Nothing"
            };
          }
          replace = function(value, quote) {
            return value.replace(/\\([^u]|u[0-9a-fA-F]{4})/g, function(all, escaped) {
              switch (escaped[0]) {
                case quote:
                  return quote;
                case "\\":
                  return "\\";
                case "b":
                  return "\b";
                case "f":
                  return "\f";
                case "n":
                  return "\n";
                case "r":
                  return "\r";
                case "t":
                  return "	";
                case "u":
                  return JSON.parse('"' + all + '"');
                default:
                  return escaped;
              }
            });
          };
          if (that = it.match(/^'([\s\S]*)'$/)) {
            return {
              type: "Just",
              value: replace(that[1], "'")
            };
          } else if (that = it.match(/^"([\s\S]*)"$/)) {
            return {
              type: "Just",
              value: replace(that[1], '"')
            };
          } else {
            return {
              type: "Just",
              value: it
            };
          }
        }
      };
      function castArray(node, type, options) {
        var typeOf, element;
        if (toString$.call(node).slice(8, -1) !== "Array") {
          return {
            type: "Nothing"
          };
        }
        typeOf = type.of;
        return {
          type: "Just",
          value: function() {
            var i$, ref$, len$, results$ = [];
            for (i$ = 0, len$ = (ref$ = node).length; i$ < len$; ++i$) {
              element = ref$[i$];
              results$.push(typesCast(element, typeOf, options));
            }
            return results$;
          }()
        };
      }
      function castTuple(node, type, options) {
        var result, i, i$, ref$, len$, types2, cast;
        if (toString$.call(node).slice(8, -1) !== "Array") {
          return {
            type: "Nothing"
          };
        }
        result = [];
        i = 0;
        for (i$ = 0, len$ = (ref$ = type.of).length; i$ < len$; ++i$) {
          types2 = ref$[i$];
          cast = typesCast(node[i], types2, options);
          if (toString$.call(cast).slice(8, -1) !== "Undefined") {
            result.push(cast);
          }
          i++;
        }
        if (node.length <= i) {
          return {
            type: "Just",
            value: result
          };
        } else {
          return {
            type: "Nothing"
          };
        }
      }
      function castFields(node, type, options) {
        var typeOf, key, value;
        if (toString$.call(node).slice(8, -1) !== "Object") {
          return {
            type: "Nothing"
          };
        }
        typeOf = type.of;
        return {
          type: "Just",
          value: function() {
            var ref$, resultObj$ = {};
            for (key in ref$ = node) {
              value = ref$[key];
              resultObj$[typesCast(key, [{
                type: "String"
              }], options)] = typesCast(value, typeOf[key] || [{
                type: "*"
              }], options);
            }
            return resultObj$;
          }()
        };
      }
      function typeCast(node, typeObj, options) {
        var type, structure, castFunc, ref$;
        type = typeObj.type, structure = typeObj.structure;
        if (type) {
          castFunc = ((ref$ = options.customTypes[type]) != null ? ref$.cast : void 0) || types[type];
          if (!castFunc) {
            throw new Error("Type not defined: " + type + ".");
          }
          return castFunc(node, options, typesCast);
        } else {
          switch (structure) {
            case "array":
              return castArray(node, typeObj, options);
            case "tuple":
              return castTuple(node, typeObj, options);
            case "fields":
              return castFields(node, typeObj, options);
          }
        }
      }
      function typesCast(node, types2, options) {
        var i$, len$, type, ref$, valueType, value;
        for (i$ = 0, len$ = types2.length; i$ < len$; ++i$) {
          type = types2[i$];
          ref$ = typeCast(node, type, options), valueType = ref$.type, value = ref$.value;
          if (valueType === "Nothing") {
            continue;
          }
          if (parsedTypeCheck([type], value, {
            customTypes: options.customTypes
          })) {
            return value;
          }
        }
        throw new Error("Value " + JSON.stringify(node) + " does not type check against " + JSON.stringify(types2) + ".");
      }
      module.exports = function(node, types2, options) {
        if (!options.explicit && types2.length === 1 && types2[0].type === "String") {
          return node;
        }
        return typesCast(node, types2, options);
      };
    }).call(exports);
  }
});

// ../../node_modules/levn/lib/index.js
var require_lib3 = __commonJS({
  "../../node_modules/levn/lib/index.js"(exports, module) {
    (function() {
      var parseString, cast, parseType, VERSION, parsedTypeParse, parse;
      parseString = require_parse_string();
      cast = require_cast();
      parseType = require_lib2().parseType;
      VERSION = "0.4.1";
      parsedTypeParse = function(parsedType, string, options) {
        options == null && (options = {});
        options.explicit == null && (options.explicit = false);
        options.customTypes == null && (options.customTypes = {});
        return cast(parseString(parsedType, string, options), parsedType, options);
      };
      parse = function(type, string, options) {
        return parsedTypeParse(parseType(type), string, options);
      };
      module.exports = {
        VERSION,
        parse,
        parsedTypeParse
      };
    }).call(exports);
  }
});

// ../../node_modules/eslint/lib/linter/config-comment-parser.js
var require_config_comment_parser = __commonJS({
  "../../node_modules/eslint/lib/linter/config-comment-parser.js"(exports, module) {
    "use strict";
    var levn = require_lib3();
    var {
      Legacy: {
        ConfigOps
      }
    } = require_eslintrc_universal();
    var debug = require_browser()("eslint:config-comment-parser");
    module.exports = class ConfigCommentParser {
      /**
       * Parses a list of "name:string_value" or/and "name" options divided by comma or
       * whitespace. Used for "global" and "exported" comments.
       * @param {string} string The string to parse.
       * @param {Comment} comment The comment node which has the string.
       * @returns {Object} Result map object of names and string values, or null values if no value was provided
       */
      parseStringConfig(string, comment) {
        debug("Parsing String config");
        const items = {};
        const trimmedString = string.replace(/\s*([:,])\s*/gu, "$1");
        trimmedString.split(/\s|,+/u).forEach((name) => {
          if (!name) {
            return;
          }
          const [key, value = null] = name.split(":");
          items[key] = { value, comment };
        });
        return items;
      }
      /**
       * Parses a JSON-like config.
       * @param {string} string The string to parse.
       * @param {Object} location Start line and column of comments for potential error message.
       * @returns {({success: true, config: Object}|{success: false, error: LintMessage})} Result map object
       */
      parseJsonConfig(string, location) {
        debug("Parsing JSON config");
        let items = {};
        try {
          items = levn.parse("Object", string) || {};
          if (ConfigOps.isEverySeverityValid(items)) {
            return {
              success: true,
              config: items
            };
          }
        } catch {
          debug("Levn parsing failed; falling back to manual parsing.");
        }
        items = {};
        const normalizedString = string.replace(/([-a-zA-Z0-9/]+):/gu, '"$1":').replace(/(\]|[0-9])\s+(?=")/u, "$1,");
        try {
          items = JSON.parse(`{${normalizedString}}`);
        } catch (ex) {
          debug("Manual parsing failed.");
          return {
            success: false,
            error: {
              ruleId: null,
              fatal: true,
              severity: 2,
              message: `Failed to parse JSON from '${normalizedString}': ${ex.message}`,
              line: location.start.line,
              column: location.start.column + 1,
              nodeType: null
            }
          };
        }
        return {
          success: true,
          config: items
        };
      }
      /**
       * Parses a config of values separated by comma.
       * @param {string} string The string to parse.
       * @returns {Object} Result map of values and true values
       */
      parseListConfig(string) {
        debug("Parsing list config");
        const items = {};
        string.split(",").forEach((name) => {
          const trimmedName = name.trim();
          if (trimmedName) {
            items[trimmedName] = true;
          }
        });
        return items;
      }
    };
  }
});

// ../../node_modules/esquery/dist/esquery.min.js
var require_esquery_min = __commonJS({
  "../../node_modules/esquery/dist/esquery.min.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = e || self).esquery = t();
    }(exports, function() {
      "use strict";
      function e(t2) {
        return (e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e2) {
          return typeof e2;
        } : function(e2) {
          return e2 && "function" == typeof Symbol && e2.constructor === Symbol && e2 !== Symbol.prototype ? "symbol" : typeof e2;
        })(t2);
      }
      function t(e2, t2) {
        return function(e3) {
          if (Array.isArray(e3))
            return e3;
        }(e2) || function(e3, t3) {
          var r2 = null == e3 ? null : "undefined" != typeof Symbol && e3[Symbol.iterator] || e3["@@iterator"];
          if (null != r2) {
            var n2, o2, a2, i2, s2 = [], u2 = true, l2 = false;
            try {
              if (a2 = (r2 = r2.call(e3)).next, 0 === t3) {
                if (Object(r2) !== r2)
                  return;
                u2 = false;
              } else
                for (; !(u2 = (n2 = a2.call(r2)).done) && (s2.push(n2.value), s2.length !== t3); u2 = true)
                  ;
            } catch (e4) {
              l2 = true, o2 = e4;
            } finally {
              try {
                if (!u2 && null != r2.return && (i2 = r2.return(), Object(i2) !== i2))
                  return;
              } finally {
                if (l2)
                  throw o2;
              }
            }
            return s2;
          }
        }(e2, t2) || n(e2, t2) || function() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function r(e2) {
        return function(e3) {
          if (Array.isArray(e3))
            return o(e3);
        }(e2) || function(e3) {
          if ("undefined" != typeof Symbol && null != e3[Symbol.iterator] || null != e3["@@iterator"])
            return Array.from(e3);
        }(e2) || n(e2) || function() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function n(e2, t2) {
        if (e2) {
          if ("string" == typeof e2)
            return o(e2, t2);
          var r2 = Object.prototype.toString.call(e2).slice(8, -1);
          return "Object" === r2 && e2.constructor && (r2 = e2.constructor.name), "Map" === r2 || "Set" === r2 ? Array.from(e2) : "Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2) ? o(e2, t2) : void 0;
        }
      }
      function o(e2, t2) {
        (null == t2 || t2 > e2.length) && (t2 = e2.length);
        for (var r2 = 0, n2 = new Array(t2); r2 < t2; r2++)
          n2[r2] = e2[r2];
        return n2;
      }
      "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self && self;
      function a(e2, t2) {
        return e2(t2 = { exports: {} }, t2.exports), t2.exports;
      }
      var i = a(function(e2, t2) {
        !function e3(t3) {
          var r2, n2, o2, a2, i2, s2;
          function u2(e4) {
            var t4, r3, n3 = {};
            for (t4 in e4)
              e4.hasOwnProperty(t4) && (r3 = e4[t4], n3[t4] = "object" == typeof r3 && null !== r3 ? u2(r3) : r3);
            return n3;
          }
          function l2(e4, t4) {
            this.parent = e4, this.key = t4;
          }
          function c2(e4, t4, r3, n3) {
            this.node = e4, this.path = t4, this.wrap = r3, this.ref = n3;
          }
          function f2() {
          }
          function p2(e4) {
            return null != e4 && ("object" == typeof e4 && "string" == typeof e4.type);
          }
          function h2(e4, t4) {
            return (e4 === r2.ObjectExpression || e4 === r2.ObjectPattern) && "properties" === t4;
          }
          function y2(e4, t4) {
            for (var r3 = e4.length - 1; r3 >= 0; --r3)
              if (e4[r3].node === t4)
                return true;
            return false;
          }
          function d2(e4, t4) {
            return new f2().traverse(e4, t4);
          }
          function m2(e4, t4) {
            var r3;
            return r3 = function(e5, t5) {
              var r4, n3, o3, a3;
              for (n3 = e5.length, o3 = 0; n3; )
                t5(e5[a3 = o3 + (r4 = n3 >>> 1)]) ? n3 = r4 : (o3 = a3 + 1, n3 -= r4 + 1);
              return o3;
            }(t4, function(t5) {
              return t5.range[0] > e4.range[0];
            }), e4.extendedRange = [e4.range[0], e4.range[1]], r3 !== t4.length && (e4.extendedRange[1] = t4[r3].range[0]), (r3 -= 1) >= 0 && (e4.extendedRange[0] = t4[r3].range[1]), e4;
          }
          return r2 = { AssignmentExpression: "AssignmentExpression", AssignmentPattern: "AssignmentPattern", ArrayExpression: "ArrayExpression", ArrayPattern: "ArrayPattern", ArrowFunctionExpression: "ArrowFunctionExpression", AwaitExpression: "AwaitExpression", BlockStatement: "BlockStatement", BinaryExpression: "BinaryExpression", BreakStatement: "BreakStatement", CallExpression: "CallExpression", CatchClause: "CatchClause", ChainExpression: "ChainExpression", ClassBody: "ClassBody", ClassDeclaration: "ClassDeclaration", ClassExpression: "ClassExpression", ComprehensionBlock: "ComprehensionBlock", ComprehensionExpression: "ComprehensionExpression", ConditionalExpression: "ConditionalExpression", ContinueStatement: "ContinueStatement", DebuggerStatement: "DebuggerStatement", DirectiveStatement: "DirectiveStatement", DoWhileStatement: "DoWhileStatement", EmptyStatement: "EmptyStatement", ExportAllDeclaration: "ExportAllDeclaration", ExportDefaultDeclaration: "ExportDefaultDeclaration", ExportNamedDeclaration: "ExportNamedDeclaration", ExportSpecifier: "ExportSpecifier", ExpressionStatement: "ExpressionStatement", ForStatement: "ForStatement", ForInStatement: "ForInStatement", ForOfStatement: "ForOfStatement", FunctionDeclaration: "FunctionDeclaration", FunctionExpression: "FunctionExpression", GeneratorExpression: "GeneratorExpression", Identifier: "Identifier", IfStatement: "IfStatement", ImportExpression: "ImportExpression", ImportDeclaration: "ImportDeclaration", ImportDefaultSpecifier: "ImportDefaultSpecifier", ImportNamespaceSpecifier: "ImportNamespaceSpecifier", ImportSpecifier: "ImportSpecifier", Literal: "Literal", LabeledStatement: "LabeledStatement", LogicalExpression: "LogicalExpression", MemberExpression: "MemberExpression", MetaProperty: "MetaProperty", MethodDefinition: "MethodDefinition", ModuleSpecifier: "ModuleSpecifier", NewExpression: "NewExpression", ObjectExpression: "ObjectExpression", ObjectPattern: "ObjectPattern", PrivateIdentifier: "PrivateIdentifier", Program: "Program", Property: "Property", PropertyDefinition: "PropertyDefinition", RestElement: "RestElement", ReturnStatement: "ReturnStatement", SequenceExpression: "SequenceExpression", SpreadElement: "SpreadElement", Super: "Super", SwitchStatement: "SwitchStatement", SwitchCase: "SwitchCase", TaggedTemplateExpression: "TaggedTemplateExpression", TemplateElement: "TemplateElement", TemplateLiteral: "TemplateLiteral", ThisExpression: "ThisExpression", ThrowStatement: "ThrowStatement", TryStatement: "TryStatement", UnaryExpression: "UnaryExpression", UpdateExpression: "UpdateExpression", VariableDeclaration: "VariableDeclaration", VariableDeclarator: "VariableDeclarator", WhileStatement: "WhileStatement", WithStatement: "WithStatement", YieldExpression: "YieldExpression" }, o2 = { AssignmentExpression: ["left", "right"], AssignmentPattern: ["left", "right"], ArrayExpression: ["elements"], ArrayPattern: ["elements"], ArrowFunctionExpression: ["params", "body"], AwaitExpression: ["argument"], BlockStatement: ["body"], BinaryExpression: ["left", "right"], BreakStatement: ["label"], CallExpression: ["callee", "arguments"], CatchClause: ["param", "body"], ChainExpression: ["expression"], ClassBody: ["body"], ClassDeclaration: ["id", "superClass", "body"], ClassExpression: ["id", "superClass", "body"], ComprehensionBlock: ["left", "right"], ComprehensionExpression: ["blocks", "filter", "body"], ConditionalExpression: ["test", "consequent", "alternate"], ContinueStatement: ["label"], DebuggerStatement: [], DirectiveStatement: [], DoWhileStatement: ["body", "test"], EmptyStatement: [], ExportAllDeclaration: ["source"], ExportDefaultDeclaration: ["declaration"], ExportNamedDeclaration: ["declaration", "specifiers", "source"], ExportSpecifier: ["exported", "local"], ExpressionStatement: ["expression"], ForStatement: ["init", "test", "update", "body"], ForInStatement: ["left", "right", "body"], ForOfStatement: ["left", "right", "body"], FunctionDeclaration: ["id", "params", "body"], FunctionExpression: ["id", "params", "body"], GeneratorExpression: ["blocks", "filter", "body"], Identifier: [], IfStatement: ["test", "consequent", "alternate"], ImportExpression: ["source"], ImportDeclaration: ["specifiers", "source"], ImportDefaultSpecifier: ["local"], ImportNamespaceSpecifier: ["local"], ImportSpecifier: ["imported", "local"], Literal: [], LabeledStatement: ["label", "body"], LogicalExpression: ["left", "right"], MemberExpression: ["object", "property"], MetaProperty: ["meta", "property"], MethodDefinition: ["key", "value"], ModuleSpecifier: [], NewExpression: ["callee", "arguments"], ObjectExpression: ["properties"], ObjectPattern: ["properties"], PrivateIdentifier: [], Program: ["body"], Property: ["key", "value"], PropertyDefinition: ["key", "value"], RestElement: ["argument"], ReturnStatement: ["argument"], SequenceExpression: ["expressions"], SpreadElement: ["argument"], Super: [], SwitchStatement: ["discriminant", "cases"], SwitchCase: ["test", "consequent"], TaggedTemplateExpression: ["tag", "quasi"], TemplateElement: [], TemplateLiteral: ["quasis", "expressions"], ThisExpression: [], ThrowStatement: ["argument"], TryStatement: ["block", "handler", "finalizer"], UnaryExpression: ["argument"], UpdateExpression: ["argument"], VariableDeclaration: ["declarations"], VariableDeclarator: ["id", "init"], WhileStatement: ["test", "body"], WithStatement: ["object", "body"], YieldExpression: ["argument"] }, n2 = { Break: a2 = {}, Skip: i2 = {}, Remove: s2 = {} }, l2.prototype.replace = function(e4) {
            this.parent[this.key] = e4;
          }, l2.prototype.remove = function() {
            return Array.isArray(this.parent) ? (this.parent.splice(this.key, 1), true) : (this.replace(null), false);
          }, f2.prototype.path = function() {
            var e4, t4, r3, n3, o3;
            function a3(e5, t5) {
              if (Array.isArray(t5))
                for (r3 = 0, n3 = t5.length; r3 < n3; ++r3)
                  e5.push(t5[r3]);
              else
                e5.push(t5);
            }
            if (!this.__current.path)
              return null;
            for (o3 = [], e4 = 2, t4 = this.__leavelist.length; e4 < t4; ++e4)
              a3(o3, this.__leavelist[e4].path);
            return a3(o3, this.__current.path), o3;
          }, f2.prototype.type = function() {
            return this.current().type || this.__current.wrap;
          }, f2.prototype.parents = function() {
            var e4, t4, r3;
            for (r3 = [], e4 = 1, t4 = this.__leavelist.length; e4 < t4; ++e4)
              r3.push(this.__leavelist[e4].node);
            return r3;
          }, f2.prototype.current = function() {
            return this.__current.node;
          }, f2.prototype.__execute = function(e4, t4) {
            var r3, n3;
            return n3 = void 0, r3 = this.__current, this.__current = t4, this.__state = null, e4 && (n3 = e4.call(this, t4.node, this.__leavelist[this.__leavelist.length - 1].node)), this.__current = r3, n3;
          }, f2.prototype.notify = function(e4) {
            this.__state = e4;
          }, f2.prototype.skip = function() {
            this.notify(i2);
          }, f2.prototype.break = function() {
            this.notify(a2);
          }, f2.prototype.remove = function() {
            this.notify(s2);
          }, f2.prototype.__initialize = function(e4, t4) {
            this.visitor = t4, this.root = e4, this.__worklist = [], this.__leavelist = [], this.__current = null, this.__state = null, this.__fallback = null, "iteration" === t4.fallback ? this.__fallback = Object.keys : "function" == typeof t4.fallback && (this.__fallback = t4.fallback), this.__keys = o2, t4.keys && (this.__keys = Object.assign(Object.create(this.__keys), t4.keys));
          }, f2.prototype.traverse = function(e4, t4) {
            var r3, n3, o3, s3, u3, l3, f3, d3, m3, x2, v2, g2;
            for (this.__initialize(e4, t4), g2 = {}, r3 = this.__worklist, n3 = this.__leavelist, r3.push(new c2(e4, null, null, null)), n3.push(new c2(null, null, null, null)); r3.length; )
              if ((o3 = r3.pop()) !== g2) {
                if (o3.node) {
                  if (l3 = this.__execute(t4.enter, o3), this.__state === a2 || l3 === a2)
                    return;
                  if (r3.push(g2), n3.push(o3), this.__state === i2 || l3 === i2)
                    continue;
                  if (u3 = (s3 = o3.node).type || o3.wrap, !(x2 = this.__keys[u3])) {
                    if (!this.__fallback)
                      throw new Error("Unknown node type " + u3 + ".");
                    x2 = this.__fallback(s3);
                  }
                  for (d3 = x2.length; (d3 -= 1) >= 0; )
                    if (v2 = s3[f3 = x2[d3]]) {
                      if (Array.isArray(v2)) {
                        for (m3 = v2.length; (m3 -= 1) >= 0; )
                          if (v2[m3] && !y2(n3, v2[m3])) {
                            if (h2(u3, x2[d3]))
                              o3 = new c2(v2[m3], [f3, m3], "Property", null);
                            else {
                              if (!p2(v2[m3]))
                                continue;
                              o3 = new c2(v2[m3], [f3, m3], null, null);
                            }
                            r3.push(o3);
                          }
                      } else if (p2(v2)) {
                        if (y2(n3, v2))
                          continue;
                        r3.push(new c2(v2, f3, null, null));
                      }
                    }
                }
              } else if (o3 = n3.pop(), l3 = this.__execute(t4.leave, o3), this.__state === a2 || l3 === a2)
                return;
          }, f2.prototype.replace = function(e4, t4) {
            var r3, n3, o3, u3, f3, y3, d3, m3, x2, v2, g2, A2, E;
            function b(e5) {
              var t5, n4, o4, a3;
              if (e5.ref.remove()) {
                for (n4 = e5.ref.key, a3 = e5.ref.parent, t5 = r3.length; t5--; )
                  if ((o4 = r3[t5]).ref && o4.ref.parent === a3) {
                    if (o4.ref.key < n4)
                      break;
                    --o4.ref.key;
                  }
              }
            }
            for (this.__initialize(e4, t4), g2 = {}, r3 = this.__worklist, n3 = this.__leavelist, y3 = new c2(e4, null, null, new l2(A2 = { root: e4 }, "root")), r3.push(y3), n3.push(y3); r3.length; )
              if ((y3 = r3.pop()) !== g2) {
                if (void 0 !== (f3 = this.__execute(t4.enter, y3)) && f3 !== a2 && f3 !== i2 && f3 !== s2 && (y3.ref.replace(f3), y3.node = f3), this.__state !== s2 && f3 !== s2 || (b(y3), y3.node = null), this.__state === a2 || f3 === a2)
                  return A2.root;
                if ((o3 = y3.node) && (r3.push(g2), n3.push(y3), this.__state !== i2 && f3 !== i2)) {
                  if (u3 = o3.type || y3.wrap, !(x2 = this.__keys[u3])) {
                    if (!this.__fallback)
                      throw new Error("Unknown node type " + u3 + ".");
                    x2 = this.__fallback(o3);
                  }
                  for (d3 = x2.length; (d3 -= 1) >= 0; )
                    if (v2 = o3[E = x2[d3]])
                      if (Array.isArray(v2)) {
                        for (m3 = v2.length; (m3 -= 1) >= 0; )
                          if (v2[m3]) {
                            if (h2(u3, x2[d3]))
                              y3 = new c2(v2[m3], [E, m3], "Property", new l2(v2, m3));
                            else {
                              if (!p2(v2[m3]))
                                continue;
                              y3 = new c2(v2[m3], [E, m3], null, new l2(v2, m3));
                            }
                            r3.push(y3);
                          }
                      } else
                        p2(v2) && r3.push(new c2(v2, E, null, new l2(o3, E)));
                }
              } else if (y3 = n3.pop(), void 0 !== (f3 = this.__execute(t4.leave, y3)) && f3 !== a2 && f3 !== i2 && f3 !== s2 && y3.ref.replace(f3), this.__state !== s2 && f3 !== s2 || b(y3), this.__state === a2 || f3 === a2)
                return A2.root;
            return A2.root;
          }, t3.Syntax = r2, t3.traverse = d2, t3.replace = function(e4, t4) {
            return new f2().replace(e4, t4);
          }, t3.attachComments = function(e4, t4, r3) {
            var o3, a3, i3, s3, l3 = [];
            if (!e4.range)
              throw new Error("attachComments needs range information");
            if (!r3.length) {
              if (t4.length) {
                for (i3 = 0, a3 = t4.length; i3 < a3; i3 += 1)
                  (o3 = u2(t4[i3])).extendedRange = [0, e4.range[0]], l3.push(o3);
                e4.leadingComments = l3;
              }
              return e4;
            }
            for (i3 = 0, a3 = t4.length; i3 < a3; i3 += 1)
              l3.push(m2(u2(t4[i3]), r3));
            return s3 = 0, d2(e4, { enter: function(e5) {
              for (var t5; s3 < l3.length && !((t5 = l3[s3]).extendedRange[1] > e5.range[0]); )
                t5.extendedRange[1] === e5.range[0] ? (e5.leadingComments || (e5.leadingComments = []), e5.leadingComments.push(t5), l3.splice(s3, 1)) : s3 += 1;
              return s3 === l3.length ? n2.Break : l3[s3].extendedRange[0] > e5.range[1] ? n2.Skip : void 0;
            } }), s3 = 0, d2(e4, { leave: function(e5) {
              for (var t5; s3 < l3.length && (t5 = l3[s3], !(e5.range[1] < t5.extendedRange[0])); )
                e5.range[1] === t5.extendedRange[0] ? (e5.trailingComments || (e5.trailingComments = []), e5.trailingComments.push(t5), l3.splice(s3, 1)) : s3 += 1;
              return s3 === l3.length ? n2.Break : l3[s3].extendedRange[0] > e5.range[1] ? n2.Skip : void 0;
            } }), e4;
          }, t3.VisitorKeys = o2, t3.VisitorOption = n2, t3.Controller = f2, t3.cloneEnvironment = function() {
            return e3({});
          }, t3;
        }(t2);
      }), s = a(function(e2) {
        e2.exports && (e2.exports = function() {
          function e3(t2, r2, n2, o2) {
            this.message = t2, this.expected = r2, this.found = n2, this.location = o2, this.name = "SyntaxError", "function" == typeof Error.captureStackTrace && Error.captureStackTrace(this, e3);
          }
          return function(e4, t2) {
            function r2() {
              this.constructor = e4;
            }
            r2.prototype = t2.prototype, e4.prototype = new r2();
          }(e3, Error), e3.buildMessage = function(e4, t2) {
            var r2 = { literal: function(e5) {
              return '"' + o2(e5.text) + '"';
            }, class: function(e5) {
              var t3, r3 = "";
              for (t3 = 0; t3 < e5.parts.length; t3++)
                r3 += e5.parts[t3] instanceof Array ? a2(e5.parts[t3][0]) + "-" + a2(e5.parts[t3][1]) : a2(e5.parts[t3]);
              return "[" + (e5.inverted ? "^" : "") + r3 + "]";
            }, any: function(e5) {
              return "any character";
            }, end: function(e5) {
              return "end of input";
            }, other: function(e5) {
              return e5.description;
            } };
            function n2(e5) {
              return e5.charCodeAt(0).toString(16).toUpperCase();
            }
            function o2(e5) {
              return e5.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(e6) {
                return "\\x0" + n2(e6);
              }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(e6) {
                return "\\x" + n2(e6);
              });
            }
            function a2(e5) {
              return e5.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(e6) {
                return "\\x0" + n2(e6);
              }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(e6) {
                return "\\x" + n2(e6);
              });
            }
            return "Expected " + function(e5) {
              var t3, n3, o3, a3 = new Array(e5.length);
              for (t3 = 0; t3 < e5.length; t3++)
                a3[t3] = (o3 = e5[t3], r2[o3.type](o3));
              if (a3.sort(), a3.length > 0) {
                for (t3 = 1, n3 = 1; t3 < a3.length; t3++)
                  a3[t3 - 1] !== a3[t3] && (a3[n3] = a3[t3], n3++);
                a3.length = n3;
              }
              switch (a3.length) {
                case 1:
                  return a3[0];
                case 2:
                  return a3[0] + " or " + a3[1];
                default:
                  return a3.slice(0, -1).join(", ") + ", or " + a3[a3.length - 1];
              }
            }(e4) + " but " + function(e5) {
              return e5 ? '"' + o2(e5) + '"' : "end of input";
            }(t2) + " found.";
          }, { SyntaxError: e3, parse: function(t2, r2) {
            r2 = void 0 !== r2 ? r2 : {};
            var n2, o2, a2, i2, s2 = {}, u2 = { start: de }, l2 = de, c2 = ce(" ", false), f2 = /^[^ [\],():#!=><~+.]/, p2 = fe([" ", "[", "]", ",", "(", ")", ":", "#", "!", "=", ">", "<", "~", "+", "."], true, false), h2 = ce(">", false), y2 = ce("~", false), d2 = ce("+", false), m2 = ce(",", false), x2 = ce("!", false), v2 = ce("*", false), g2 = ce("#", false), A2 = ce("[", false), E = ce("]", false), b = /^[><!]/, S = fe([">", "<", "!"], false, false), _ = ce("=", false), C = function(e4) {
              return (e4 || "") + "=";
            }, w = /^[><]/, P = fe([">", "<"], false, false), k = ce(".", false), D = function(e4, t3, r3) {
              return { type: "attribute", name: e4, operator: t3, value: r3 };
            }, I = ce('"', false), j = /^[^\\"]/, T = fe(["\\", '"'], true, false), F = ce("\\", false), R = { type: "any" }, O = function(e4, t3) {
              return e4 + t3;
            }, L = function(e4) {
              return { type: "literal", value: (t3 = e4.join(""), t3.replace(/\\(.)/g, function(e5, t4) {
                switch (t4) {
                  case "b":
                    return "\b";
                  case "f":
                    return "\f";
                  case "n":
                    return "\n";
                  case "r":
                    return "\r";
                  case "t":
                    return "	";
                  case "v":
                    return "\v";
                  default:
                    return t4;
                }
              })) };
              var t3;
            }, M = ce("'", false), B = /^[^\\']/, U = fe(["\\", "'"], true, false), K = /^[0-9]/, W = fe([["0", "9"]], false, false), q = ce("type(", false), V = /^[^ )]/, N = fe([" ", ")"], true, false), G = ce(")", false), z = /^[imsu]/, H = fe(["i", "m", "s", "u"], false, false), Y = ce("/", false), $ = /^[^\/]/, J = fe(["/"], true, false), Q = ce(":not(", false), X = ce(":matches(", false), Z = ce(":has(", false), ee = ce(":first-child", false), te = ce(":last-child", false), re = ce(":nth-child(", false), ne = ce(":nth-last-child(", false), oe = ce(":", false), ae = 0, ie = [{ line: 1, column: 1 }], se = 0, ue = [], le = {};
            if ("startRule" in r2) {
              if (!(r2.startRule in u2))
                throw new Error(`Can't start parsing from rule "` + r2.startRule + '".');
              l2 = u2[r2.startRule];
            }
            function ce(e4, t3) {
              return { type: "literal", text: e4, ignoreCase: t3 };
            }
            function fe(e4, t3, r3) {
              return { type: "class", parts: e4, inverted: t3, ignoreCase: r3 };
            }
            function pe(e4) {
              var r3, n3 = ie[e4];
              if (n3)
                return n3;
              for (r3 = e4 - 1; !ie[r3]; )
                r3--;
              for (n3 = { line: (n3 = ie[r3]).line, column: n3.column }; r3 < e4; )
                10 === t2.charCodeAt(r3) ? (n3.line++, n3.column = 1) : n3.column++, r3++;
              return ie[e4] = n3, n3;
            }
            function he(e4, t3) {
              var r3 = pe(e4), n3 = pe(t3);
              return { start: { offset: e4, line: r3.line, column: r3.column }, end: { offset: t3, line: n3.line, column: n3.column } };
            }
            function ye(e4) {
              ae < se || (ae > se && (se = ae, ue = []), ue.push(e4));
            }
            function de() {
              var e4, t3, r3, n3, o3 = 30 * ae + 0, a3 = le[o3];
              return a3 ? (ae = a3.nextPos, a3.result) : (e4 = ae, (t3 = me()) !== s2 && (r3 = ge()) !== s2 && me() !== s2 ? e4 = t3 = 1 === (n3 = r3).length ? n3[0] : { type: "matches", selectors: n3 } : (ae = e4, e4 = s2), e4 === s2 && (e4 = ae, (t3 = me()) !== s2 && (t3 = void 0), e4 = t3), le[o3] = { nextPos: ae, result: e4 }, e4);
            }
            function me() {
              var e4, r3, n3 = 30 * ae + 1, o3 = le[n3];
              if (o3)
                return ae = o3.nextPos, o3.result;
              for (e4 = [], 32 === t2.charCodeAt(ae) ? (r3 = " ", ae++) : (r3 = s2, ye(c2)); r3 !== s2; )
                e4.push(r3), 32 === t2.charCodeAt(ae) ? (r3 = " ", ae++) : (r3 = s2, ye(c2));
              return le[n3] = { nextPos: ae, result: e4 }, e4;
            }
            function xe() {
              var e4, r3, n3, o3 = 30 * ae + 2, a3 = le[o3];
              if (a3)
                return ae = a3.nextPos, a3.result;
              if (r3 = [], f2.test(t2.charAt(ae)) ? (n3 = t2.charAt(ae), ae++) : (n3 = s2, ye(p2)), n3 !== s2)
                for (; n3 !== s2; )
                  r3.push(n3), f2.test(t2.charAt(ae)) ? (n3 = t2.charAt(ae), ae++) : (n3 = s2, ye(p2));
              else
                r3 = s2;
              return r3 !== s2 && (r3 = r3.join("")), e4 = r3, le[o3] = { nextPos: ae, result: e4 }, e4;
            }
            function ve() {
              var e4, r3, n3, o3 = 30 * ae + 3, a3 = le[o3];
              return a3 ? (ae = a3.nextPos, a3.result) : (e4 = ae, (r3 = me()) !== s2 ? (62 === t2.charCodeAt(ae) ? (n3 = ">", ae++) : (n3 = s2, ye(h2)), n3 !== s2 && me() !== s2 ? e4 = r3 = "child" : (ae = e4, e4 = s2)) : (ae = e4, e4 = s2), e4 === s2 && (e4 = ae, (r3 = me()) !== s2 ? (126 === t2.charCodeAt(ae) ? (n3 = "~", ae++) : (n3 = s2, ye(y2)), n3 !== s2 && me() !== s2 ? e4 = r3 = "sibling" : (ae = e4, e4 = s2)) : (ae = e4, e4 = s2), e4 === s2 && (e4 = ae, (r3 = me()) !== s2 ? (43 === t2.charCodeAt(ae) ? (n3 = "+", ae++) : (n3 = s2, ye(d2)), n3 !== s2 && me() !== s2 ? e4 = r3 = "adjacent" : (ae = e4, e4 = s2)) : (ae = e4, e4 = s2), e4 === s2 && (e4 = ae, 32 === t2.charCodeAt(ae) ? (r3 = " ", ae++) : (r3 = s2, ye(c2)), r3 !== s2 && (n3 = me()) !== s2 ? e4 = r3 = "descendant" : (ae = e4, e4 = s2)))), le[o3] = { nextPos: ae, result: e4 }, e4);
            }
            function ge() {
              var e4, r3, n3, o3, a3, i3, u3, l3, c3 = 30 * ae + 4, f3 = le[c3];
              if (f3)
                return ae = f3.nextPos, f3.result;
              if (e4 = ae, (r3 = Ae()) !== s2) {
                for (n3 = [], o3 = ae, (a3 = me()) !== s2 ? (44 === t2.charCodeAt(ae) ? (i3 = ",", ae++) : (i3 = s2, ye(m2)), i3 !== s2 && (u3 = me()) !== s2 && (l3 = Ae()) !== s2 ? o3 = a3 = [a3, i3, u3, l3] : (ae = o3, o3 = s2)) : (ae = o3, o3 = s2); o3 !== s2; )
                  n3.push(o3), o3 = ae, (a3 = me()) !== s2 ? (44 === t2.charCodeAt(ae) ? (i3 = ",", ae++) : (i3 = s2, ye(m2)), i3 !== s2 && (u3 = me()) !== s2 && (l3 = Ae()) !== s2 ? o3 = a3 = [a3, i3, u3, l3] : (ae = o3, o3 = s2)) : (ae = o3, o3 = s2);
                n3 !== s2 ? e4 = r3 = [r3].concat(n3.map(function(e5) {
                  return e5[3];
                })) : (ae = e4, e4 = s2);
              } else
                ae = e4, e4 = s2;
              return le[c3] = { nextPos: ae, result: e4 }, e4;
            }
            function Ae() {
              var e4, t3, r3, n3, o3, a3, i3, u3 = 30 * ae + 5, l3 = le[u3];
              if (l3)
                return ae = l3.nextPos, l3.result;
              if (e4 = ae, (t3 = Ee()) !== s2) {
                for (r3 = [], n3 = ae, (o3 = ve()) !== s2 && (a3 = Ee()) !== s2 ? n3 = o3 = [o3, a3] : (ae = n3, n3 = s2); n3 !== s2; )
                  r3.push(n3), n3 = ae, (o3 = ve()) !== s2 && (a3 = Ee()) !== s2 ? n3 = o3 = [o3, a3] : (ae = n3, n3 = s2);
                r3 !== s2 ? (i3 = t3, e4 = t3 = r3.reduce(function(e5, t4) {
                  return { type: t4[0], left: e5, right: t4[1] };
                }, i3)) : (ae = e4, e4 = s2);
              } else
                ae = e4, e4 = s2;
              return le[u3] = { nextPos: ae, result: e4 }, e4;
            }
            function Ee() {
              var e4, r3, n3, o3, a3, i3, u3, l3 = 30 * ae + 6, c3 = le[l3];
              if (c3)
                return ae = c3.nextPos, c3.result;
              if (e4 = ae, 33 === t2.charCodeAt(ae) ? (r3 = "!", ae++) : (r3 = s2, ye(x2)), r3 === s2 && (r3 = null), r3 !== s2) {
                if (n3 = [], (o3 = be()) !== s2)
                  for (; o3 !== s2; )
                    n3.push(o3), o3 = be();
                else
                  n3 = s2;
                n3 !== s2 ? (a3 = r3, u3 = 1 === (i3 = n3).length ? i3[0] : { type: "compound", selectors: i3 }, a3 && (u3.subject = true), e4 = r3 = u3) : (ae = e4, e4 = s2);
              } else
                ae = e4, e4 = s2;
              return le[l3] = { nextPos: ae, result: e4 }, e4;
            }
            function be() {
              var e4, r3 = 30 * ae + 7, n3 = le[r3];
              return n3 ? (ae = n3.nextPos, n3.result) : ((e4 = function() {
                var e5, r4, n4 = 30 * ae + 8, o3 = le[n4];
                return o3 ? (ae = o3.nextPos, o3.result) : (42 === t2.charCodeAt(ae) ? (r4 = "*", ae++) : (r4 = s2, ye(v2)), r4 !== s2 && (r4 = { type: "wildcard", value: r4 }), e5 = r4, le[n4] = { nextPos: ae, result: e5 }, e5);
              }()) === s2 && (e4 = function() {
                var e5, r4, n4, o3 = 30 * ae + 9, a3 = le[o3];
                return a3 ? (ae = a3.nextPos, a3.result) : (e5 = ae, 35 === t2.charCodeAt(ae) ? (r4 = "#", ae++) : (r4 = s2, ye(g2)), r4 === s2 && (r4 = null), r4 !== s2 && (n4 = xe()) !== s2 ? e5 = r4 = { type: "identifier", value: n4 } : (ae = e5, e5 = s2), le[o3] = { nextPos: ae, result: e5 }, e5);
              }()) === s2 && (e4 = function() {
                var e5, r4, n4, o3, a3 = 30 * ae + 10, i3 = le[a3];
                return i3 ? (ae = i3.nextPos, i3.result) : (e5 = ae, 91 === t2.charCodeAt(ae) ? (r4 = "[", ae++) : (r4 = s2, ye(A2)), r4 !== s2 && me() !== s2 && (n4 = function() {
                  var e6, r5, n5, o4, a4 = 30 * ae + 14, i4 = le[a4];
                  return i4 ? (ae = i4.nextPos, i4.result) : (e6 = ae, (r5 = Se()) !== s2 && me() !== s2 && (n5 = function() {
                    var e7, r6, n6, o5 = 30 * ae + 12, a5 = le[o5];
                    return a5 ? (ae = a5.nextPos, a5.result) : (e7 = ae, 33 === t2.charCodeAt(ae) ? (r6 = "!", ae++) : (r6 = s2, ye(x2)), r6 === s2 && (r6 = null), r6 !== s2 ? (61 === t2.charCodeAt(ae) ? (n6 = "=", ae++) : (n6 = s2, ye(_)), n6 !== s2 ? (r6 = C(r6), e7 = r6) : (ae = e7, e7 = s2)) : (ae = e7, e7 = s2), le[o5] = { nextPos: ae, result: e7 }, e7);
                  }()) !== s2 && me() !== s2 ? ((o4 = function() {
                    var e7, r6, n6, o5, a5, i5 = 30 * ae + 18, u3 = le[i5];
                    if (u3)
                      return ae = u3.nextPos, u3.result;
                    if (e7 = ae, "type(" === t2.substr(ae, 5) ? (r6 = "type(", ae += 5) : (r6 = s2, ye(q)), r6 !== s2)
                      if (me() !== s2) {
                        if (n6 = [], V.test(t2.charAt(ae)) ? (o5 = t2.charAt(ae), ae++) : (o5 = s2, ye(N)), o5 !== s2)
                          for (; o5 !== s2; )
                            n6.push(o5), V.test(t2.charAt(ae)) ? (o5 = t2.charAt(ae), ae++) : (o5 = s2, ye(N));
                        else
                          n6 = s2;
                        n6 !== s2 && (o5 = me()) !== s2 ? (41 === t2.charCodeAt(ae) ? (a5 = ")", ae++) : (a5 = s2, ye(G)), a5 !== s2 ? (r6 = { type: "type", value: n6.join("") }, e7 = r6) : (ae = e7, e7 = s2)) : (ae = e7, e7 = s2);
                      } else
                        ae = e7, e7 = s2;
                    else
                      ae = e7, e7 = s2;
                    return le[i5] = { nextPos: ae, result: e7 }, e7;
                  }()) === s2 && (o4 = function() {
                    var e7, r6, n6, o5, a5, i5, u3 = 30 * ae + 20, l3 = le[u3];
                    if (l3)
                      return ae = l3.nextPos, l3.result;
                    if (e7 = ae, 47 === t2.charCodeAt(ae) ? (r6 = "/", ae++) : (r6 = s2, ye(Y)), r6 !== s2) {
                      if (n6 = [], $.test(t2.charAt(ae)) ? (o5 = t2.charAt(ae), ae++) : (o5 = s2, ye(J)), o5 !== s2)
                        for (; o5 !== s2; )
                          n6.push(o5), $.test(t2.charAt(ae)) ? (o5 = t2.charAt(ae), ae++) : (o5 = s2, ye(J));
                      else
                        n6 = s2;
                      n6 !== s2 ? (47 === t2.charCodeAt(ae) ? (o5 = "/", ae++) : (o5 = s2, ye(Y)), o5 !== s2 ? ((a5 = function() {
                        var e8, r7, n7 = 30 * ae + 19, o6 = le[n7];
                        if (o6)
                          return ae = o6.nextPos, o6.result;
                        if (e8 = [], z.test(t2.charAt(ae)) ? (r7 = t2.charAt(ae), ae++) : (r7 = s2, ye(H)), r7 !== s2)
                          for (; r7 !== s2; )
                            e8.push(r7), z.test(t2.charAt(ae)) ? (r7 = t2.charAt(ae), ae++) : (r7 = s2, ye(H));
                        else
                          e8 = s2;
                        return le[n7] = { nextPos: ae, result: e8 }, e8;
                      }()) === s2 && (a5 = null), a5 !== s2 ? (i5 = a5, r6 = { type: "regexp", value: new RegExp(n6.join(""), i5 ? i5.join("") : "") }, e7 = r6) : (ae = e7, e7 = s2)) : (ae = e7, e7 = s2)) : (ae = e7, e7 = s2);
                    } else
                      ae = e7, e7 = s2;
                    return le[u3] = { nextPos: ae, result: e7 }, e7;
                  }()), o4 !== s2 ? (r5 = D(r5, n5, o4), e6 = r5) : (ae = e6, e6 = s2)) : (ae = e6, e6 = s2), e6 === s2 && (e6 = ae, (r5 = Se()) !== s2 && me() !== s2 && (n5 = function() {
                    var e7, r6, n6, o5 = 30 * ae + 11, a5 = le[o5];
                    return a5 ? (ae = a5.nextPos, a5.result) : (e7 = ae, b.test(t2.charAt(ae)) ? (r6 = t2.charAt(ae), ae++) : (r6 = s2, ye(S)), r6 === s2 && (r6 = null), r6 !== s2 ? (61 === t2.charCodeAt(ae) ? (n6 = "=", ae++) : (n6 = s2, ye(_)), n6 !== s2 ? (r6 = C(r6), e7 = r6) : (ae = e7, e7 = s2)) : (ae = e7, e7 = s2), e7 === s2 && (w.test(t2.charAt(ae)) ? (e7 = t2.charAt(ae), ae++) : (e7 = s2, ye(P))), le[o5] = { nextPos: ae, result: e7 }, e7);
                  }()) !== s2 && me() !== s2 ? ((o4 = function() {
                    var e7, r6, n6, o5, a5, i5, u3 = 30 * ae + 15, l3 = le[u3];
                    if (l3)
                      return ae = l3.nextPos, l3.result;
                    if (e7 = ae, 34 === t2.charCodeAt(ae) ? (r6 = '"', ae++) : (r6 = s2, ye(I)), r6 !== s2) {
                      for (n6 = [], j.test(t2.charAt(ae)) ? (o5 = t2.charAt(ae), ae++) : (o5 = s2, ye(T)), o5 === s2 && (o5 = ae, 92 === t2.charCodeAt(ae) ? (a5 = "\\", ae++) : (a5 = s2, ye(F)), a5 !== s2 ? (t2.length > ae ? (i5 = t2.charAt(ae), ae++) : (i5 = s2, ye(R)), i5 !== s2 ? (a5 = O(a5, i5), o5 = a5) : (ae = o5, o5 = s2)) : (ae = o5, o5 = s2)); o5 !== s2; )
                        n6.push(o5), j.test(t2.charAt(ae)) ? (o5 = t2.charAt(ae), ae++) : (o5 = s2, ye(T)), o5 === s2 && (o5 = ae, 92 === t2.charCodeAt(ae) ? (a5 = "\\", ae++) : (a5 = s2, ye(F)), a5 !== s2 ? (t2.length > ae ? (i5 = t2.charAt(ae), ae++) : (i5 = s2, ye(R)), i5 !== s2 ? (a5 = O(a5, i5), o5 = a5) : (ae = o5, o5 = s2)) : (ae = o5, o5 = s2));
                      n6 !== s2 ? (34 === t2.charCodeAt(ae) ? (o5 = '"', ae++) : (o5 = s2, ye(I)), o5 !== s2 ? (r6 = L(n6), e7 = r6) : (ae = e7, e7 = s2)) : (ae = e7, e7 = s2);
                    } else
                      ae = e7, e7 = s2;
                    if (e7 === s2)
                      if (e7 = ae, 39 === t2.charCodeAt(ae) ? (r6 = "'", ae++) : (r6 = s2, ye(M)), r6 !== s2) {
                        for (n6 = [], B.test(t2.charAt(ae)) ? (o5 = t2.charAt(ae), ae++) : (o5 = s2, ye(U)), o5 === s2 && (o5 = ae, 92 === t2.charCodeAt(ae) ? (a5 = "\\", ae++) : (a5 = s2, ye(F)), a5 !== s2 ? (t2.length > ae ? (i5 = t2.charAt(ae), ae++) : (i5 = s2, ye(R)), i5 !== s2 ? (a5 = O(a5, i5), o5 = a5) : (ae = o5, o5 = s2)) : (ae = o5, o5 = s2)); o5 !== s2; )
                          n6.push(o5), B.test(t2.charAt(ae)) ? (o5 = t2.charAt(ae), ae++) : (o5 = s2, ye(U)), o5 === s2 && (o5 = ae, 92 === t2.charCodeAt(ae) ? (a5 = "\\", ae++) : (a5 = s2, ye(F)), a5 !== s2 ? (t2.length > ae ? (i5 = t2.charAt(ae), ae++) : (i5 = s2, ye(R)), i5 !== s2 ? (a5 = O(a5, i5), o5 = a5) : (ae = o5, o5 = s2)) : (ae = o5, o5 = s2));
                        n6 !== s2 ? (39 === t2.charCodeAt(ae) ? (o5 = "'", ae++) : (o5 = s2, ye(M)), o5 !== s2 ? (r6 = L(n6), e7 = r6) : (ae = e7, e7 = s2)) : (ae = e7, e7 = s2);
                      } else
                        ae = e7, e7 = s2;
                    return le[u3] = { nextPos: ae, result: e7 }, e7;
                  }()) === s2 && (o4 = function() {
                    var e7, r6, n6, o5, a5, i5, u3, l3 = 30 * ae + 16, c3 = le[l3];
                    if (c3)
                      return ae = c3.nextPos, c3.result;
                    for (e7 = ae, r6 = ae, n6 = [], K.test(t2.charAt(ae)) ? (o5 = t2.charAt(ae), ae++) : (o5 = s2, ye(W)); o5 !== s2; )
                      n6.push(o5), K.test(t2.charAt(ae)) ? (o5 = t2.charAt(ae), ae++) : (o5 = s2, ye(W));
                    if (n6 !== s2 ? (46 === t2.charCodeAt(ae) ? (o5 = ".", ae++) : (o5 = s2, ye(k)), o5 !== s2 ? r6 = n6 = [n6, o5] : (ae = r6, r6 = s2)) : (ae = r6, r6 = s2), r6 === s2 && (r6 = null), r6 !== s2) {
                      if (n6 = [], K.test(t2.charAt(ae)) ? (o5 = t2.charAt(ae), ae++) : (o5 = s2, ye(W)), o5 !== s2)
                        for (; o5 !== s2; )
                          n6.push(o5), K.test(t2.charAt(ae)) ? (o5 = t2.charAt(ae), ae++) : (o5 = s2, ye(W));
                      else
                        n6 = s2;
                      n6 !== s2 ? (i5 = n6, u3 = (a5 = r6) ? [].concat.apply([], a5).join("") : "", r6 = { type: "literal", value: parseFloat(u3 + i5.join("")) }, e7 = r6) : (ae = e7, e7 = s2);
                    } else
                      ae = e7, e7 = s2;
                    return le[l3] = { nextPos: ae, result: e7 }, e7;
                  }()) === s2 && (o4 = function() {
                    var e7, t3, r6 = 30 * ae + 17, n6 = le[r6];
                    return n6 ? (ae = n6.nextPos, n6.result) : ((t3 = xe()) !== s2 && (t3 = { type: "literal", value: t3 }), e7 = t3, le[r6] = { nextPos: ae, result: e7 }, e7);
                  }()), o4 !== s2 ? (r5 = D(r5, n5, o4), e6 = r5) : (ae = e6, e6 = s2)) : (ae = e6, e6 = s2), e6 === s2 && (e6 = ae, (r5 = Se()) !== s2 && (r5 = { type: "attribute", name: r5 }), e6 = r5)), le[a4] = { nextPos: ae, result: e6 }, e6);
                }()) !== s2 && me() !== s2 ? (93 === t2.charCodeAt(ae) ? (o3 = "]", ae++) : (o3 = s2, ye(E)), o3 !== s2 ? e5 = r4 = n4 : (ae = e5, e5 = s2)) : (ae = e5, e5 = s2), le[a3] = { nextPos: ae, result: e5 }, e5);
              }()) === s2 && (e4 = function() {
                var e5, r4, n4, o3, a3, i3, u3, l3, c3 = 30 * ae + 21, f3 = le[c3];
                if (f3)
                  return ae = f3.nextPos, f3.result;
                if (e5 = ae, 46 === t2.charCodeAt(ae) ? (r4 = ".", ae++) : (r4 = s2, ye(k)), r4 !== s2)
                  if ((n4 = xe()) !== s2) {
                    for (o3 = [], a3 = ae, 46 === t2.charCodeAt(ae) ? (i3 = ".", ae++) : (i3 = s2, ye(k)), i3 !== s2 && (u3 = xe()) !== s2 ? a3 = i3 = [i3, u3] : (ae = a3, a3 = s2); a3 !== s2; )
                      o3.push(a3), a3 = ae, 46 === t2.charCodeAt(ae) ? (i3 = ".", ae++) : (i3 = s2, ye(k)), i3 !== s2 && (u3 = xe()) !== s2 ? a3 = i3 = [i3, u3] : (ae = a3, a3 = s2);
                    o3 !== s2 ? (l3 = n4, r4 = { type: "field", name: o3.reduce(function(e6, t3) {
                      return e6 + t3[0] + t3[1];
                    }, l3) }, e5 = r4) : (ae = e5, e5 = s2);
                  } else
                    ae = e5, e5 = s2;
                else
                  ae = e5, e5 = s2;
                return le[c3] = { nextPos: ae, result: e5 }, e5;
              }()) === s2 && (e4 = function() {
                var e5, r4, n4, o3, a3 = 30 * ae + 22, i3 = le[a3];
                return i3 ? (ae = i3.nextPos, i3.result) : (e5 = ae, ":not(" === t2.substr(ae, 5) ? (r4 = ":not(", ae += 5) : (r4 = s2, ye(Q)), r4 !== s2 && me() !== s2 && (n4 = ge()) !== s2 && me() !== s2 ? (41 === t2.charCodeAt(ae) ? (o3 = ")", ae++) : (o3 = s2, ye(G)), o3 !== s2 ? e5 = r4 = { type: "not", selectors: n4 } : (ae = e5, e5 = s2)) : (ae = e5, e5 = s2), le[a3] = { nextPos: ae, result: e5 }, e5);
              }()) === s2 && (e4 = function() {
                var e5, r4, n4, o3, a3 = 30 * ae + 23, i3 = le[a3];
                return i3 ? (ae = i3.nextPos, i3.result) : (e5 = ae, ":matches(" === t2.substr(ae, 9) ? (r4 = ":matches(", ae += 9) : (r4 = s2, ye(X)), r4 !== s2 && me() !== s2 && (n4 = ge()) !== s2 && me() !== s2 ? (41 === t2.charCodeAt(ae) ? (o3 = ")", ae++) : (o3 = s2, ye(G)), o3 !== s2 ? e5 = r4 = { type: "matches", selectors: n4 } : (ae = e5, e5 = s2)) : (ae = e5, e5 = s2), le[a3] = { nextPos: ae, result: e5 }, e5);
              }()) === s2 && (e4 = function() {
                var e5, r4, n4, o3, a3 = 30 * ae + 24, i3 = le[a3];
                return i3 ? (ae = i3.nextPos, i3.result) : (e5 = ae, ":has(" === t2.substr(ae, 5) ? (r4 = ":has(", ae += 5) : (r4 = s2, ye(Z)), r4 !== s2 && me() !== s2 && (n4 = ge()) !== s2 && me() !== s2 ? (41 === t2.charCodeAt(ae) ? (o3 = ")", ae++) : (o3 = s2, ye(G)), o3 !== s2 ? e5 = r4 = { type: "has", selectors: n4 } : (ae = e5, e5 = s2)) : (ae = e5, e5 = s2), le[a3] = { nextPos: ae, result: e5 }, e5);
              }()) === s2 && (e4 = function() {
                var e5, r4, n4 = 30 * ae + 25, o3 = le[n4];
                return o3 ? (ae = o3.nextPos, o3.result) : (":first-child" === t2.substr(ae, 12) ? (r4 = ":first-child", ae += 12) : (r4 = s2, ye(ee)), r4 !== s2 && (r4 = _e(1)), e5 = r4, le[n4] = { nextPos: ae, result: e5 }, e5);
              }()) === s2 && (e4 = function() {
                var e5, r4, n4 = 30 * ae + 26, o3 = le[n4];
                return o3 ? (ae = o3.nextPos, o3.result) : (":last-child" === t2.substr(ae, 11) ? (r4 = ":last-child", ae += 11) : (r4 = s2, ye(te)), r4 !== s2 && (r4 = Ce(1)), e5 = r4, le[n4] = { nextPos: ae, result: e5 }, e5);
              }()) === s2 && (e4 = function() {
                var e5, r4, n4, o3, a3, i3 = 30 * ae + 27, u3 = le[i3];
                if (u3)
                  return ae = u3.nextPos, u3.result;
                if (e5 = ae, ":nth-child(" === t2.substr(ae, 11) ? (r4 = ":nth-child(", ae += 11) : (r4 = s2, ye(re)), r4 !== s2)
                  if (me() !== s2) {
                    if (n4 = [], K.test(t2.charAt(ae)) ? (o3 = t2.charAt(ae), ae++) : (o3 = s2, ye(W)), o3 !== s2)
                      for (; o3 !== s2; )
                        n4.push(o3), K.test(t2.charAt(ae)) ? (o3 = t2.charAt(ae), ae++) : (o3 = s2, ye(W));
                    else
                      n4 = s2;
                    n4 !== s2 && (o3 = me()) !== s2 ? (41 === t2.charCodeAt(ae) ? (a3 = ")", ae++) : (a3 = s2, ye(G)), a3 !== s2 ? (r4 = _e(parseInt(n4.join(""), 10)), e5 = r4) : (ae = e5, e5 = s2)) : (ae = e5, e5 = s2);
                  } else
                    ae = e5, e5 = s2;
                else
                  ae = e5, e5 = s2;
                return le[i3] = { nextPos: ae, result: e5 }, e5;
              }()) === s2 && (e4 = function() {
                var e5, r4, n4, o3, a3, i3 = 30 * ae + 28, u3 = le[i3];
                if (u3)
                  return ae = u3.nextPos, u3.result;
                if (e5 = ae, ":nth-last-child(" === t2.substr(ae, 16) ? (r4 = ":nth-last-child(", ae += 16) : (r4 = s2, ye(ne)), r4 !== s2)
                  if (me() !== s2) {
                    if (n4 = [], K.test(t2.charAt(ae)) ? (o3 = t2.charAt(ae), ae++) : (o3 = s2, ye(W)), o3 !== s2)
                      for (; o3 !== s2; )
                        n4.push(o3), K.test(t2.charAt(ae)) ? (o3 = t2.charAt(ae), ae++) : (o3 = s2, ye(W));
                    else
                      n4 = s2;
                    n4 !== s2 && (o3 = me()) !== s2 ? (41 === t2.charCodeAt(ae) ? (a3 = ")", ae++) : (a3 = s2, ye(G)), a3 !== s2 ? (r4 = Ce(parseInt(n4.join(""), 10)), e5 = r4) : (ae = e5, e5 = s2)) : (ae = e5, e5 = s2);
                  } else
                    ae = e5, e5 = s2;
                else
                  ae = e5, e5 = s2;
                return le[i3] = { nextPos: ae, result: e5 }, e5;
              }()) === s2 && (e4 = function() {
                var e5, r4, n4, o3 = 30 * ae + 29, a3 = le[o3];
                return a3 ? (ae = a3.nextPos, a3.result) : (e5 = ae, 58 === t2.charCodeAt(ae) ? (r4 = ":", ae++) : (r4 = s2, ye(oe)), r4 !== s2 && (n4 = xe()) !== s2 ? e5 = r4 = { type: "class", name: n4 } : (ae = e5, e5 = s2), le[o3] = { nextPos: ae, result: e5 }, e5);
              }()), le[r3] = { nextPos: ae, result: e4 }, e4);
            }
            function Se() {
              var e4, r3, n3, o3, a3, i3, u3, l3, c3 = 30 * ae + 13, f3 = le[c3];
              if (f3)
                return ae = f3.nextPos, f3.result;
              if (e4 = ae, (r3 = xe()) !== s2) {
                for (n3 = [], o3 = ae, 46 === t2.charCodeAt(ae) ? (a3 = ".", ae++) : (a3 = s2, ye(k)), a3 !== s2 && (i3 = xe()) !== s2 ? o3 = a3 = [a3, i3] : (ae = o3, o3 = s2); o3 !== s2; )
                  n3.push(o3), o3 = ae, 46 === t2.charCodeAt(ae) ? (a3 = ".", ae++) : (a3 = s2, ye(k)), a3 !== s2 && (i3 = xe()) !== s2 ? o3 = a3 = [a3, i3] : (ae = o3, o3 = s2);
                n3 !== s2 ? (u3 = r3, l3 = n3, e4 = r3 = [].concat.apply([u3], l3).join("")) : (ae = e4, e4 = s2);
              } else
                ae = e4, e4 = s2;
              return le[c3] = { nextPos: ae, result: e4 }, e4;
            }
            function _e(e4) {
              return { type: "nth-child", index: { type: "literal", value: e4 } };
            }
            function Ce(e4) {
              return { type: "nth-last-child", index: { type: "literal", value: e4 } };
            }
            if ((n2 = l2()) !== s2 && ae === t2.length)
              return n2;
            throw n2 !== s2 && ae < t2.length && ye({ type: "end" }), o2 = ue, a2 = se < t2.length ? t2.charAt(se) : null, i2 = se < t2.length ? he(se, se + 1) : he(se, se), new e3(e3.buildMessage(o2, a2), o2, a2, i2);
          } };
        }());
      });
      function u(e2, t2) {
        for (var r2 = 0; r2 < t2.length; ++r2) {
          if (null == e2)
            return e2;
          e2 = e2[t2[r2]];
        }
        return e2;
      }
      var l = "function" == typeof WeakMap ? /* @__PURE__ */ new WeakMap() : null;
      function c(e2) {
        if (null == e2)
          return function() {
            return true;
          };
        if (null != l) {
          var t2 = l.get(e2);
          return null != t2 || (t2 = f(e2), l.set(e2, t2)), t2;
        }
        return f(e2);
      }
      function f(t2) {
        switch (t2.type) {
          case "wildcard":
            return function() {
              return true;
            };
          case "identifier":
            var r2 = t2.value.toLowerCase();
            return function(e2, t3, n3) {
              var o3 = n3 && n3.nodeTypeKey || "type";
              return r2 === e2[o3].toLowerCase();
            };
          case "field":
            var n2 = t2.name.split(".");
            return function(e2, t3) {
              return function e3(t4, r3, n3, o3) {
                for (var a3 = r3, i2 = o3; i2 < n3.length; ++i2) {
                  if (null == a3)
                    return false;
                  var s3 = a3[n3[i2]];
                  if (Array.isArray(s3)) {
                    for (var u2 = 0; u2 < s3.length; ++u2)
                      if (e3(t4, s3[u2], n3, i2 + 1))
                        return true;
                    return false;
                  }
                  a3 = s3;
                }
                return t4 === a3;
              }(e2, t3[n2.length - 1], n2, 0);
            };
          case "matches":
            var o2 = t2.selectors.map(c);
            return function(e2, t3, r3) {
              for (var n3 = 0; n3 < o2.length; ++n3)
                if (o2[n3](e2, t3, r3))
                  return true;
              return false;
            };
          case "compound":
            var a2 = t2.selectors.map(c);
            return function(e2, t3, r3) {
              for (var n3 = 0; n3 < a2.length; ++n3)
                if (!a2[n3](e2, t3, r3))
                  return false;
              return true;
            };
          case "not":
            var s2 = t2.selectors.map(c);
            return function(e2, t3, r3) {
              for (var n3 = 0; n3 < s2.length; ++n3)
                if (s2[n3](e2, t3, r3))
                  return false;
              return true;
            };
          case "has":
            var l2 = t2.selectors.map(c);
            return function(e2, t3, r3) {
              var n3 = false, o3 = [];
              return i.traverse(e2, { enter: function(e3, t4) {
                null != t4 && o3.unshift(t4);
                for (var a3 = 0; a3 < l2.length; ++a3)
                  if (l2[a3](e3, o3, r3))
                    return n3 = true, void this.break();
              }, leave: function() {
                o3.shift();
              }, keys: r3 && r3.visitorKeys, fallback: r3 && r3.fallback || "iteration" }), n3;
            };
          case "child":
            var f2 = c(t2.left), p2 = c(t2.right);
            return function(e2, t3, r3) {
              return !!(t3.length > 0 && p2(e2, t3, r3)) && f2(t3[0], t3.slice(1), r3);
            };
          case "descendant":
            var h2 = c(t2.left), x2 = c(t2.right);
            return function(e2, t3, r3) {
              if (x2(e2, t3, r3)) {
                for (var n3 = 0, o3 = t3.length; n3 < o3; ++n3)
                  if (h2(t3[n3], t3.slice(n3 + 1), r3))
                    return true;
              }
              return false;
            };
          case "attribute":
            var v2 = t2.name.split(".");
            switch (t2.operator) {
              case void 0:
                return function(e2) {
                  return null != u(e2, v2);
                };
              case "=":
                switch (t2.value.type) {
                  case "regexp":
                    return function(e2) {
                      var r3 = u(e2, v2);
                      return "string" == typeof r3 && t2.value.value.test(r3);
                    };
                  case "literal":
                    var g2 = "".concat(t2.value.value);
                    return function(e2) {
                      return g2 === "".concat(u(e2, v2));
                    };
                  case "type":
                    return function(r3) {
                      return t2.value.value === e(u(r3, v2));
                    };
                }
                throw new Error("Unknown selector value type: ".concat(t2.value.type));
              case "!=":
                switch (t2.value.type) {
                  case "regexp":
                    return function(e2) {
                      return !t2.value.value.test(u(e2, v2));
                    };
                  case "literal":
                    var A2 = "".concat(t2.value.value);
                    return function(e2) {
                      return A2 !== "".concat(u(e2, v2));
                    };
                  case "type":
                    return function(r3) {
                      return t2.value.value !== e(u(r3, v2));
                    };
                }
                throw new Error("Unknown selector value type: ".concat(t2.value.type));
              case "<=":
                return function(e2) {
                  return u(e2, v2) <= t2.value.value;
                };
              case "<":
                return function(e2) {
                  return u(e2, v2) < t2.value.value;
                };
              case ">":
                return function(e2) {
                  return u(e2, v2) > t2.value.value;
                };
              case ">=":
                return function(e2) {
                  return u(e2, v2) >= t2.value.value;
                };
            }
            throw new Error("Unknown operator: ".concat(t2.operator));
          case "sibling":
            var E = c(t2.left), b = c(t2.right);
            return function(e2, r3, n3) {
              return b(e2, r3, n3) && y(e2, E, r3, "LEFT_SIDE", n3) || t2.left.subject && E(e2, r3, n3) && y(e2, b, r3, "RIGHT_SIDE", n3);
            };
          case "adjacent":
            var S = c(t2.left), _ = c(t2.right);
            return function(e2, r3, n3) {
              return _(e2, r3, n3) && d(e2, S, r3, "LEFT_SIDE", n3) || t2.right.subject && S(e2, r3, n3) && d(e2, _, r3, "RIGHT_SIDE", n3);
            };
          case "nth-child":
            var C = t2.index.value, w = c(t2.right);
            return function(e2, t3, r3) {
              return w(e2, t3, r3) && m(e2, t3, C, r3);
            };
          case "nth-last-child":
            var P = -t2.index.value, k = c(t2.right);
            return function(e2, t3, r3) {
              return k(e2, t3, r3) && m(e2, t3, P, r3);
            };
          case "class":
            return function(e2, r3, n3) {
              if (n3 && n3.matchClass)
                return n3.matchClass(t2.name, e2, r3);
              if (n3 && n3.nodeTypeKey)
                return false;
              switch (t2.name.toLowerCase()) {
                case "statement":
                  if ("Statement" === e2.type.slice(-9))
                    return true;
                case "declaration":
                  return "Declaration" === e2.type.slice(-11);
                case "pattern":
                  if ("Pattern" === e2.type.slice(-7))
                    return true;
                case "expression":
                  return "Expression" === e2.type.slice(-10) || "Literal" === e2.type.slice(-7) || "Identifier" === e2.type && (0 === r3.length || "MetaProperty" !== r3[0].type) || "MetaProperty" === e2.type;
                case "function":
                  return "FunctionDeclaration" === e2.type || "FunctionExpression" === e2.type || "ArrowFunctionExpression" === e2.type;
              }
              throw new Error("Unknown class name: ".concat(t2.name));
            };
        }
        throw new Error("Unknown selector type: ".concat(t2.type));
      }
      function p(e2, t2) {
        var r2 = t2 && t2.nodeTypeKey || "type", n2 = e2[r2];
        return t2 && t2.visitorKeys && t2.visitorKeys[n2] ? t2.visitorKeys[n2] : i.VisitorKeys[n2] ? i.VisitorKeys[n2] : t2 && "function" == typeof t2.fallback ? t2.fallback(e2) : Object.keys(e2).filter(function(e3) {
          return e3 !== r2;
        });
      }
      function h(t2, r2) {
        var n2 = r2 && r2.nodeTypeKey || "type";
        return null !== t2 && "object" === e(t2) && "string" == typeof t2[n2];
      }
      function y(e2, r2, n2, o2, a2) {
        var i2 = t(n2, 1)[0];
        if (!i2)
          return false;
        for (var s2 = p(i2, a2), u2 = 0; u2 < s2.length; ++u2) {
          var l2 = i2[s2[u2]];
          if (Array.isArray(l2)) {
            var c2 = l2.indexOf(e2);
            if (c2 < 0)
              continue;
            var f2 = void 0, y2 = void 0;
            "LEFT_SIDE" === o2 ? (f2 = 0, y2 = c2) : (f2 = c2 + 1, y2 = l2.length);
            for (var d2 = f2; d2 < y2; ++d2)
              if (h(l2[d2], a2) && r2(l2[d2], n2, a2))
                return true;
          }
        }
        return false;
      }
      function d(e2, r2, n2, o2, a2) {
        var i2 = t(n2, 1)[0];
        if (!i2)
          return false;
        for (var s2 = p(i2, a2), u2 = 0; u2 < s2.length; ++u2) {
          var l2 = i2[s2[u2]];
          if (Array.isArray(l2)) {
            var c2 = l2.indexOf(e2);
            if (c2 < 0)
              continue;
            if ("LEFT_SIDE" === o2 && c2 > 0 && h(l2[c2 - 1], a2) && r2(l2[c2 - 1], n2, a2))
              return true;
            if ("RIGHT_SIDE" === o2 && c2 < l2.length - 1 && h(l2[c2 + 1], a2) && r2(l2[c2 + 1], n2, a2))
              return true;
          }
        }
        return false;
      }
      function m(e2, r2, n2, o2) {
        if (0 === n2)
          return false;
        var a2 = t(r2, 1)[0];
        if (!a2)
          return false;
        for (var i2 = p(a2, o2), s2 = 0; s2 < i2.length; ++s2) {
          var u2 = a2[i2[s2]];
          if (Array.isArray(u2)) {
            var l2 = n2 < 0 ? u2.length + n2 : n2 - 1;
            if (l2 >= 0 && l2 < u2.length && u2[l2] === e2)
              return true;
          }
        }
        return false;
      }
      function x(t2, n2, o2, a2) {
        if (n2) {
          var s2 = [], u2 = c(n2), l2 = function t3(n3, o3) {
            if (null == n3 || "object" != e(n3))
              return [];
            null == o3 && (o3 = n3);
            for (var a3 = n3.subject ? [o3] : [], i2 = Object.keys(n3), s3 = 0; s3 < i2.length; ++s3) {
              var u3 = i2[s3], l3 = n3[u3];
              a3.push.apply(a3, r(t3(l3, "left" === u3 ? l3 : o3)));
            }
            return a3;
          }(n2).map(c);
          i.traverse(t2, { enter: function(e2, t3) {
            if (null != t3 && s2.unshift(t3), u2(e2, s2, a2))
              if (l2.length)
                for (var r2 = 0, n3 = l2.length; r2 < n3; ++r2) {
                  l2[r2](e2, s2, a2) && o2(e2, t3, s2);
                  for (var i2 = 0, c2 = s2.length; i2 < c2; ++i2) {
                    var f2 = s2.slice(i2 + 1);
                    l2[r2](s2[i2], f2, a2) && o2(s2[i2], t3, f2);
                  }
                }
              else
                o2(e2, t3, s2);
          }, leave: function() {
            s2.shift();
          }, keys: a2 && a2.visitorKeys, fallback: a2 && a2.fallback || "iteration" });
        }
      }
      function v(e2, t2, r2) {
        var n2 = [];
        return x(e2, t2, function(e3) {
          n2.push(e3);
        }, r2), n2;
      }
      function g(e2) {
        return s.parse(e2);
      }
      function A(e2, t2, r2) {
        return v(e2, g(t2), r2);
      }
      return A.parse = g, A.match = v, A.traverse = x, A.matches = function(e2, t2, r2, n2) {
        return !t2 || !!e2 && (r2 || (r2 = []), c(t2)(e2, r2, n2));
      }, A.query = A, A;
    });
  }
});

// ../../node_modules/eslint/lib/linter/node-event-generator.js
var require_node_event_generator = __commonJS({
  "../../node_modules/eslint/lib/linter/node-event-generator.js"(exports, module) {
    "use strict";
    var esquery = require_esquery_min();
    function union(...arrays) {
      return [...new Set(arrays.flat())];
    }
    function intersection(...arrays) {
      if (arrays.length === 0) {
        return [];
      }
      let result = [...new Set(arrays[0])];
      for (const array of arrays.slice(1)) {
        result = result.filter((x) => array.includes(x));
      }
      return result;
    }
    function getPossibleTypes(parsedSelector) {
      switch (parsedSelector.type) {
        case "identifier":
          return [parsedSelector.value];
        case "matches": {
          const typesForComponents = parsedSelector.selectors.map(getPossibleTypes);
          if (typesForComponents.every(Boolean)) {
            return union(...typesForComponents);
          }
          return null;
        }
        case "compound": {
          const typesForComponents = parsedSelector.selectors.map(getPossibleTypes).filter((typesForComponent) => typesForComponent);
          if (!typesForComponents.length) {
            return null;
          }
          return intersection(...typesForComponents);
        }
        case "child":
        case "descendant":
        case "sibling":
        case "adjacent":
          return getPossibleTypes(parsedSelector.right);
        case "class":
          if (parsedSelector.name === "function") {
            return ["FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"];
          }
          return null;
        default:
          return null;
      }
    }
    function countClassAttributes(parsedSelector) {
      switch (parsedSelector.type) {
        case "child":
        case "descendant":
        case "sibling":
        case "adjacent":
          return countClassAttributes(parsedSelector.left) + countClassAttributes(parsedSelector.right);
        case "compound":
        case "not":
        case "matches":
          return parsedSelector.selectors.reduce((sum, childSelector) => sum + countClassAttributes(childSelector), 0);
        case "attribute":
        case "field":
        case "nth-child":
        case "nth-last-child":
          return 1;
        default:
          return 0;
      }
    }
    function countIdentifiers(parsedSelector) {
      switch (parsedSelector.type) {
        case "child":
        case "descendant":
        case "sibling":
        case "adjacent":
          return countIdentifiers(parsedSelector.left) + countIdentifiers(parsedSelector.right);
        case "compound":
        case "not":
        case "matches":
          return parsedSelector.selectors.reduce((sum, childSelector) => sum + countIdentifiers(childSelector), 0);
        case "identifier":
          return 1;
        default:
          return 0;
      }
    }
    function compareSpecificity(selectorA, selectorB) {
      return selectorA.attributeCount - selectorB.attributeCount || selectorA.identifierCount - selectorB.identifierCount || (selectorA.rawSelector <= selectorB.rawSelector ? -1 : 1);
    }
    function tryParseSelector(rawSelector) {
      try {
        return esquery.parse(rawSelector.replace(/:exit$/u, ""));
      } catch (err) {
        if (err.location && err.location.start && typeof err.location.start.offset === "number") {
          throw new SyntaxError(`Syntax error in selector "${rawSelector}" at position ${err.location.start.offset}: ${err.message}`);
        }
        throw err;
      }
    }
    var selectorCache = /* @__PURE__ */ new Map();
    function parseSelector(rawSelector) {
      if (selectorCache.has(rawSelector)) {
        return selectorCache.get(rawSelector);
      }
      const parsedSelector = tryParseSelector(rawSelector);
      const result = {
        rawSelector,
        isExit: rawSelector.endsWith(":exit"),
        parsedSelector,
        listenerTypes: getPossibleTypes(parsedSelector),
        attributeCount: countClassAttributes(parsedSelector),
        identifierCount: countIdentifiers(parsedSelector)
      };
      selectorCache.set(rawSelector, result);
      return result;
    }
    var NodeEventGenerator = class {
      /**
       * @param {SafeEmitter} emitter
       * An SafeEmitter which is the destination of events. This emitter must already
       * have registered listeners for all of the events that it needs to listen for.
       * (See lib/linter/safe-emitter.js for more details on `SafeEmitter`.)
       * @param {ESQueryOptions} esqueryOptions `esquery` options for traversing custom nodes.
       * @returns {NodeEventGenerator} new instance
       */
      constructor(emitter, esqueryOptions) {
        this.emitter = emitter;
        this.esqueryOptions = esqueryOptions;
        this.currentAncestry = [];
        this.enterSelectorsByNodeType = /* @__PURE__ */ new Map();
        this.exitSelectorsByNodeType = /* @__PURE__ */ new Map();
        this.anyTypeEnterSelectors = [];
        this.anyTypeExitSelectors = [];
        emitter.eventNames().forEach((rawSelector) => {
          const selector = parseSelector(rawSelector);
          if (selector.listenerTypes) {
            const typeMap = selector.isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType;
            selector.listenerTypes.forEach((nodeType) => {
              if (!typeMap.has(nodeType)) {
                typeMap.set(nodeType, []);
              }
              typeMap.get(nodeType).push(selector);
            });
            return;
          }
          const selectors = selector.isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors;
          selectors.push(selector);
        });
        this.anyTypeEnterSelectors.sort(compareSpecificity);
        this.anyTypeExitSelectors.sort(compareSpecificity);
        this.enterSelectorsByNodeType.forEach((selectorList) => selectorList.sort(compareSpecificity));
        this.exitSelectorsByNodeType.forEach((selectorList) => selectorList.sort(compareSpecificity));
      }
      /**
       * Checks a selector against a node, and emits it if it matches
       * @param {ASTNode} node The node to check
       * @param {ASTSelector} selector An AST selector descriptor
       * @returns {void}
       */
      applySelector(node, selector) {
        if (esquery.matches(node, selector.parsedSelector, this.currentAncestry, this.esqueryOptions)) {
          this.emitter.emit(selector.rawSelector, node);
        }
      }
      /**
       * Applies all appropriate selectors to a node, in specificity order
       * @param {ASTNode} node The node to check
       * @param {boolean} isExit `false` if the node is currently being entered, `true` if it's currently being exited
       * @returns {void}
       */
      applySelectors(node, isExit) {
        const selectorsByNodeType = (isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType).get(node.type) || [];
        const anyTypeSelectors = isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors;
        let selectorsByTypeIndex = 0;
        let anyTypeSelectorsIndex = 0;
        while (selectorsByTypeIndex < selectorsByNodeType.length || anyTypeSelectorsIndex < anyTypeSelectors.length) {
          if (selectorsByTypeIndex >= selectorsByNodeType.length || anyTypeSelectorsIndex < anyTypeSelectors.length && compareSpecificity(anyTypeSelectors[anyTypeSelectorsIndex], selectorsByNodeType[selectorsByTypeIndex]) < 0) {
            this.applySelector(node, anyTypeSelectors[anyTypeSelectorsIndex++]);
          } else {
            this.applySelector(node, selectorsByNodeType[selectorsByTypeIndex++]);
          }
        }
      }
      /**
       * Emits an event of entering AST node.
       * @param {ASTNode} node A node which was entered.
       * @returns {void}
       */
      enterNode(node) {
        if (node.parent) {
          this.currentAncestry.unshift(node.parent);
        }
        this.applySelectors(node, false);
      }
      /**
       * Emits an event of leaving AST node.
       * @param {ASTNode} node A node which was left.
       * @returns {void}
       */
      leaveNode(node) {
        this.applySelectors(node, true);
        this.currentAncestry.shift();
      }
    };
    module.exports = NodeEventGenerator;
  }
});

// ../../node_modules/eslint/lib/linter/rule-fixer.js
var require_rule_fixer = __commonJS({
  "../../node_modules/eslint/lib/linter/rule-fixer.js"(exports, module) {
    "use strict";
    function insertTextAt(index, text) {
      return {
        range: [index, index],
        text
      };
    }
    var ruleFixer = Object.freeze({
      /**
       * Creates a fix command that inserts text after the given node or token.
       * The fix is not applied until applyFixes() is called.
       * @param {ASTNode|Token} nodeOrToken The node or token to insert after.
       * @param {string} text The text to insert.
       * @returns {Object} The fix command.
       */
      insertTextAfter(nodeOrToken, text) {
        return this.insertTextAfterRange(nodeOrToken.range, text);
      },
      /**
       * Creates a fix command that inserts text after the specified range in the source text.
       * The fix is not applied until applyFixes() is called.
       * @param {int[]} range The range to replace, first item is start of range, second
       *      is end of range.
       * @param {string} text The text to insert.
       * @returns {Object} The fix command.
       */
      insertTextAfterRange(range, text) {
        return insertTextAt(range[1], text);
      },
      /**
       * Creates a fix command that inserts text before the given node or token.
       * The fix is not applied until applyFixes() is called.
       * @param {ASTNode|Token} nodeOrToken The node or token to insert before.
       * @param {string} text The text to insert.
       * @returns {Object} The fix command.
       */
      insertTextBefore(nodeOrToken, text) {
        return this.insertTextBeforeRange(nodeOrToken.range, text);
      },
      /**
       * Creates a fix command that inserts text before the specified range in the source text.
       * The fix is not applied until applyFixes() is called.
       * @param {int[]} range The range to replace, first item is start of range, second
       *      is end of range.
       * @param {string} text The text to insert.
       * @returns {Object} The fix command.
       */
      insertTextBeforeRange(range, text) {
        return insertTextAt(range[0], text);
      },
      /**
       * Creates a fix command that replaces text at the node or token.
       * The fix is not applied until applyFixes() is called.
       * @param {ASTNode|Token} nodeOrToken The node or token to remove.
       * @param {string} text The text to insert.
       * @returns {Object} The fix command.
       */
      replaceText(nodeOrToken, text) {
        return this.replaceTextRange(nodeOrToken.range, text);
      },
      /**
       * Creates a fix command that replaces text at the specified range in the source text.
       * The fix is not applied until applyFixes() is called.
       * @param {int[]} range The range to replace, first item is start of range, second
       *      is end of range.
       * @param {string} text The text to insert.
       * @returns {Object} The fix command.
       */
      replaceTextRange(range, text) {
        return {
          range,
          text
        };
      },
      /**
       * Creates a fix command that removes the node or token from the source.
       * The fix is not applied until applyFixes() is called.
       * @param {ASTNode|Token} nodeOrToken The node or token to remove.
       * @returns {Object} The fix command.
       */
      remove(nodeOrToken) {
        return this.removeRange(nodeOrToken.range);
      },
      /**
       * Creates a fix command that removes the specified range of text from the source.
       * The fix is not applied until applyFixes() is called.
       * @param {int[]} range The range to remove, first item is start of range, second
       *      is end of range.
       * @returns {Object} The fix command.
       */
      removeRange(range) {
        return {
          range,
          text: ""
        };
      }
    });
    module.exports = ruleFixer;
  }
});

// ../../node_modules/eslint/lib/linter/interpolate.js
var require_interpolate = __commonJS({
  "../../node_modules/eslint/lib/linter/interpolate.js"(exports, module) {
    "use strict";
    module.exports = (text, data) => {
      if (!data) {
        return text;
      }
      return text.replace(/\{\{([^{}]+?)\}\}/gu, (fullMatch, termWithWhitespace) => {
        const term = termWithWhitespace.trim();
        if (term in data) {
          return data[term];
        }
        return fullMatch;
      });
    };
  }
});

// ../../node_modules/eslint/lib/linter/report-translator.js
var require_report_translator = __commonJS({
  "../../node_modules/eslint/lib/linter/report-translator.js"(exports, module) {
    "use strict";
    var assert = require_assert();
    var ruleFixer = require_rule_fixer();
    var interpolate = require_interpolate();
    function normalizeMultiArgReportCall(...args) {
      if (args.length === 1) {
        return Object.assign({}, args[0]);
      }
      if (typeof args[1] === "string") {
        return {
          node: args[0],
          message: args[1],
          data: args[2],
          fix: args[3]
        };
      }
      return {
        node: args[0],
        loc: args[1],
        message: args[2],
        data: args[3],
        fix: args[4]
      };
    }
    function assertValidNodeInfo(descriptor) {
      if (descriptor.node) {
        assert(typeof descriptor.node === "object", "Node must be an object");
      } else {
        assert(descriptor.loc, "Node must be provided when reporting error if location is not provided");
      }
    }
    function normalizeReportLoc(descriptor) {
      if (descriptor.loc) {
        if (descriptor.loc.start) {
          return descriptor.loc;
        }
        return { start: descriptor.loc, end: null };
      }
      return descriptor.node.loc;
    }
    function cloneFix(fix) {
      if (!fix) {
        return null;
      }
      return {
        range: [fix.range[0], fix.range[1]],
        text: fix.text
      };
    }
    function assertValidFix(fix) {
      if (fix) {
        assert(fix.range && typeof fix.range[0] === "number" && typeof fix.range[1] === "number", `Fix has invalid range: ${JSON.stringify(fix, null, 2)}`);
      }
    }
    function compareFixesByRange(a, b) {
      return a.range[0] - b.range[0] || a.range[1] - b.range[1];
    }
    function mergeFixes(fixes, sourceCode) {
      for (const fix of fixes) {
        assertValidFix(fix);
      }
      if (fixes.length === 0) {
        return null;
      }
      if (fixes.length === 1) {
        return cloneFix(fixes[0]);
      }
      fixes.sort(compareFixesByRange);
      const originalText = sourceCode.text;
      const start = fixes[0].range[0];
      const end = fixes[fixes.length - 1].range[1];
      let text = "";
      let lastPos = Number.MIN_SAFE_INTEGER;
      for (const fix of fixes) {
        assert(fix.range[0] >= lastPos, "Fix objects must not be overlapped in a report.");
        if (fix.range[0] >= 0) {
          text += originalText.slice(Math.max(0, start, lastPos), fix.range[0]);
        }
        text += fix.text;
        lastPos = fix.range[1];
      }
      text += originalText.slice(Math.max(0, start, lastPos), end);
      return { range: [start, end], text };
    }
    function normalizeFixes(descriptor, sourceCode) {
      if (typeof descriptor.fix !== "function") {
        return null;
      }
      const fix = descriptor.fix(ruleFixer);
      if (fix && Symbol.iterator in fix) {
        return mergeFixes(Array.from(fix), sourceCode);
      }
      assertValidFix(fix);
      return cloneFix(fix);
    }
    function mapSuggestions(descriptor, sourceCode, messages) {
      if (!descriptor.suggest || !Array.isArray(descriptor.suggest)) {
        return [];
      }
      return descriptor.suggest.map((suggestInfo) => {
        const computedDesc = suggestInfo.desc || messages[suggestInfo.messageId];
        return {
          ...suggestInfo,
          desc: interpolate(computedDesc, suggestInfo.data),
          fix: normalizeFixes(suggestInfo, sourceCode)
        };
      }).filter(({ fix }) => fix);
    }
    function createProblem(options) {
      const problem = {
        ruleId: options.ruleId,
        severity: options.severity,
        message: options.message,
        line: options.loc.start.line,
        column: options.loc.start.column + 1,
        nodeType: options.node && options.node.type || null
      };
      if (options.messageId) {
        problem.messageId = options.messageId;
      }
      if (options.loc.end) {
        problem.endLine = options.loc.end.line;
        problem.endColumn = options.loc.end.column + 1;
      }
      if (options.fix) {
        problem.fix = options.fix;
      }
      if (options.suggestions && options.suggestions.length > 0) {
        problem.suggestions = options.suggestions;
      }
      return problem;
    }
    function validateSuggestions(suggest, messages) {
      if (suggest && Array.isArray(suggest)) {
        suggest.forEach((suggestion) => {
          if (suggestion.messageId) {
            const { messageId } = suggestion;
            if (!messages) {
              throw new TypeError(`context.report() called with a suggest option with a messageId '${messageId}', but no messages were present in the rule metadata.`);
            }
            if (!messages[messageId]) {
              throw new TypeError(`context.report() called with a suggest option with a messageId '${messageId}' which is not present in the 'messages' config: ${JSON.stringify(messages, null, 2)}`);
            }
            if (suggestion.desc) {
              throw new TypeError("context.report() called with a suggest option that defines both a 'messageId' and an 'desc'. Please only pass one.");
            }
          } else if (!suggestion.desc) {
            throw new TypeError("context.report() called with a suggest option that doesn't have either a `desc` or `messageId`");
          }
          if (typeof suggestion.fix !== "function") {
            throw new TypeError(`context.report() called with a suggest option without a fix function. See: ${suggestion}`);
          }
        });
      }
    }
    module.exports = function createReportTranslator(metadata) {
      return (...args) => {
        const descriptor = normalizeMultiArgReportCall(...args);
        const messages = metadata.messageIds;
        assertValidNodeInfo(descriptor);
        let computedMessage;
        if (descriptor.messageId) {
          if (!messages) {
            throw new TypeError("context.report() called with a messageId, but no messages were present in the rule metadata.");
          }
          const id = descriptor.messageId;
          if (descriptor.message) {
            throw new TypeError("context.report() called with a message and a messageId. Please only pass one.");
          }
          if (!messages || !Object.prototype.hasOwnProperty.call(messages, id)) {
            throw new TypeError(`context.report() called with a messageId of '${id}' which is not present in the 'messages' config: ${JSON.stringify(messages, null, 2)}`);
          }
          computedMessage = messages[id];
        } else if (descriptor.message) {
          computedMessage = descriptor.message;
        } else {
          throw new TypeError("Missing `message` property in report() call; add a message that describes the linting problem.");
        }
        validateSuggestions(descriptor.suggest, messages);
        return createProblem({
          ruleId: metadata.ruleId,
          severity: metadata.severity,
          node: descriptor.node,
          message: interpolate(computedMessage, descriptor.data),
          messageId: descriptor.messageId,
          loc: normalizeReportLoc(descriptor),
          fix: metadata.disableFixes ? null : normalizeFixes(descriptor, metadata.sourceCode),
          suggestions: metadata.disableFixes ? [] : mapSuggestions(descriptor, metadata.sourceCode, messages)
        });
      };
    };
  }
});

// ../../node_modules/eslint/lib/rules/utils/lazy-loading-rule-map.js
var require_lazy_loading_rule_map = __commonJS({
  "../../node_modules/eslint/lib/rules/utils/lazy-loading-rule-map.js"(exports, module) {
    "use strict";
    var debug = require_browser()("eslint:rules");
    var LazyLoadingRuleMap = class extends Map {
      /**
       * Initialize this map.
       * @param {Array<[string, function(): Rule]>} loaders The rule loaders.
       */
      constructor(loaders) {
        let remaining = loaders.length;
        super(
          debug.enabled ? loaders.map(([ruleId, load]) => {
            let cache = null;
            return [
              ruleId,
              () => {
                if (!cache) {
                  debug("Loading rule %o (remaining=%d)", ruleId, --remaining);
                  cache = load();
                }
                return cache;
              }
            ];
          }) : loaders
        );
        Object.defineProperty(LazyLoadingRuleMap.prototype, "set", {
          configurable: true,
          value: void 0
        });
      }
      /**
       * Get a rule.
       * Each rule will be loaded on the first access.
       * @param {string} ruleId The rule ID to get.
       * @returns {Rule|undefined} The rule.
       */
      get(ruleId) {
        const load = super.get(ruleId);
        return load && load();
      }
      /**
       * Iterate rules.
       * @returns {IterableIterator<Rule>} Rules.
       */
      *values() {
        for (const load of super.values()) {
          yield load();
        }
      }
      /**
       * Iterate rules.
       * @returns {IterableIterator<[string, Rule]>} Rules.
       */
      *entries() {
        for (const [ruleId, load] of super.entries()) {
          yield [ruleId, load()];
        }
      }
      /**
       * Call a function with each rule.
       * @param {Function} callbackFn The callback function.
       * @param {any} [thisArg] The object to pass to `this` of the callback function.
       * @returns {void}
       */
      forEach(callbackFn, thisArg) {
        for (const [ruleId, load] of super.entries()) {
          callbackFn.call(thisArg, load(), ruleId, this);
        }
      }
    };
    Object.defineProperties(LazyLoadingRuleMap.prototype, {
      clear: { configurable: true, value: void 0 },
      delete: { configurable: true, value: void 0 },
      [Symbol.iterator]: {
        configurable: true,
        writable: true,
        value: LazyLoadingRuleMap.prototype.entries
      }
    });
    module.exports = { LazyLoadingRuleMap };
  }
});

// ../../node_modules/esutils/lib/ast.js
var require_ast = __commonJS({
  "../../node_modules/esutils/lib/ast.js"(exports, module) {
    (function() {
      "use strict";
      function isExpression(node) {
        if (node == null) {
          return false;
        }
        switch (node.type) {
          case "ArrayExpression":
          case "AssignmentExpression":
          case "BinaryExpression":
          case "CallExpression":
          case "ConditionalExpression":
          case "FunctionExpression":
          case "Identifier":
          case "Literal":
          case "LogicalExpression":
          case "MemberExpression":
          case "NewExpression":
          case "ObjectExpression":
          case "SequenceExpression":
          case "ThisExpression":
          case "UnaryExpression":
          case "UpdateExpression":
            return true;
        }
        return false;
      }
      function isIterationStatement(node) {
        if (node == null) {
          return false;
        }
        switch (node.type) {
          case "DoWhileStatement":
          case "ForInStatement":
          case "ForStatement":
          case "WhileStatement":
            return true;
        }
        return false;
      }
      function isStatement(node) {
        if (node == null) {
          return false;
        }
        switch (node.type) {
          case "BlockStatement":
          case "BreakStatement":
          case "ContinueStatement":
          case "DebuggerStatement":
          case "DoWhileStatement":
          case "EmptyStatement":
          case "ExpressionStatement":
          case "ForInStatement":
          case "ForStatement":
          case "IfStatement":
          case "LabeledStatement":
          case "ReturnStatement":
          case "SwitchStatement":
          case "ThrowStatement":
          case "TryStatement":
          case "VariableDeclaration":
          case "WhileStatement":
          case "WithStatement":
            return true;
        }
        return false;
      }
      function isSourceElement(node) {
        return isStatement(node) || node != null && node.type === "FunctionDeclaration";
      }
      function trailingStatement(node) {
        switch (node.type) {
          case "IfStatement":
            if (node.alternate != null) {
              return node.alternate;
            }
            return node.consequent;
          case "LabeledStatement":
          case "ForStatement":
          case "ForInStatement":
          case "WhileStatement":
          case "WithStatement":
            return node.body;
        }
        return null;
      }
      function isProblematicIfStatement(node) {
        var current;
        if (node.type !== "IfStatement") {
          return false;
        }
        if (node.alternate == null) {
          return false;
        }
        current = node.consequent;
        do {
          if (current.type === "IfStatement") {
            if (current.alternate == null) {
              return true;
            }
          }
          current = trailingStatement(current);
        } while (current);
        return false;
      }
      module.exports = {
        isExpression,
        isStatement,
        isIterationStatement,
        isSourceElement,
        isProblematicIfStatement,
        trailingStatement
      };
    })();
  }
});

// ../../node_modules/esutils/lib/code.js
var require_code = __commonJS({
  "../../node_modules/esutils/lib/code.js"(exports, module) {
    (function() {
      "use strict";
      var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;
      ES5Regex = {
        // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
        // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
      };
      ES6Regex = {
        // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
        // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
      };
      function isDecimalDigit(ch2) {
        return 48 <= ch2 && ch2 <= 57;
      }
      function isHexDigit(ch2) {
        return 48 <= ch2 && ch2 <= 57 || // 0..9
        97 <= ch2 && ch2 <= 102 || // a..f
        65 <= ch2 && ch2 <= 70;
      }
      function isOctalDigit(ch2) {
        return ch2 >= 48 && ch2 <= 55;
      }
      NON_ASCII_WHITESPACES = [
        5760,
        8192,
        8193,
        8194,
        8195,
        8196,
        8197,
        8198,
        8199,
        8200,
        8201,
        8202,
        8239,
        8287,
        12288,
        65279
      ];
      function isWhiteSpace(ch2) {
        return ch2 === 32 || ch2 === 9 || ch2 === 11 || ch2 === 12 || ch2 === 160 || ch2 >= 5760 && NON_ASCII_WHITESPACES.indexOf(ch2) >= 0;
      }
      function isLineTerminator(ch2) {
        return ch2 === 10 || ch2 === 13 || ch2 === 8232 || ch2 === 8233;
      }
      function fromCodePoint(cp) {
        if (cp <= 65535) {
          return String.fromCharCode(cp);
        }
        var cu1 = String.fromCharCode(Math.floor((cp - 65536) / 1024) + 55296);
        var cu2 = String.fromCharCode((cp - 65536) % 1024 + 56320);
        return cu1 + cu2;
      }
      IDENTIFIER_START = new Array(128);
      for (ch = 0; ch < 128; ++ch) {
        IDENTIFIER_START[ch] = ch >= 97 && ch <= 122 || // a..z
        ch >= 65 && ch <= 90 || // A..Z
        ch === 36 || ch === 95;
      }
      IDENTIFIER_PART = new Array(128);
      for (ch = 0; ch < 128; ++ch) {
        IDENTIFIER_PART[ch] = ch >= 97 && ch <= 122 || // a..z
        ch >= 65 && ch <= 90 || // A..Z
        ch >= 48 && ch <= 57 || // 0..9
        ch === 36 || ch === 95;
      }
      function isIdentifierStartES5(ch2) {
        return ch2 < 128 ? IDENTIFIER_START[ch2] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch2));
      }
      function isIdentifierPartES5(ch2) {
        return ch2 < 128 ? IDENTIFIER_PART[ch2] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch2));
      }
      function isIdentifierStartES6(ch2) {
        return ch2 < 128 ? IDENTIFIER_START[ch2] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch2));
      }
      function isIdentifierPartES6(ch2) {
        return ch2 < 128 ? IDENTIFIER_PART[ch2] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch2));
      }
      module.exports = {
        isDecimalDigit,
        isHexDigit,
        isOctalDigit,
        isWhiteSpace,
        isLineTerminator,
        isIdentifierStartES5,
        isIdentifierPartES5,
        isIdentifierStartES6,
        isIdentifierPartES6
      };
    })();
  }
});

// ../../node_modules/esutils/lib/keyword.js
var require_keyword2 = __commonJS({
  "../../node_modules/esutils/lib/keyword.js"(exports, module) {
    (function() {
      "use strict";
      var code = require_code();
      function isStrictModeReservedWordES6(id) {
        switch (id) {
          case "implements":
          case "interface":
          case "package":
          case "private":
          case "protected":
          case "public":
          case "static":
          case "let":
            return true;
          default:
            return false;
        }
      }
      function isKeywordES5(id, strict) {
        if (!strict && id === "yield") {
          return false;
        }
        return isKeywordES6(id, strict);
      }
      function isKeywordES6(id, strict) {
        if (strict && isStrictModeReservedWordES6(id)) {
          return true;
        }
        switch (id.length) {
          case 2:
            return id === "if" || id === "in" || id === "do";
          case 3:
            return id === "var" || id === "for" || id === "new" || id === "try";
          case 4:
            return id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum";
          case 5:
            return id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super";
          case 6:
            return id === "return" || id === "typeof" || id === "delete" || id === "switch" || id === "export" || id === "import";
          case 7:
            return id === "default" || id === "finally" || id === "extends";
          case 8:
            return id === "function" || id === "continue" || id === "debugger";
          case 10:
            return id === "instanceof";
          default:
            return false;
        }
      }
      function isReservedWordES5(id, strict) {
        return id === "null" || id === "true" || id === "false" || isKeywordES5(id, strict);
      }
      function isReservedWordES6(id, strict) {
        return id === "null" || id === "true" || id === "false" || isKeywordES6(id, strict);
      }
      function isRestrictedWord(id) {
        return id === "eval" || id === "arguments";
      }
      function isIdentifierNameES5(id) {
        var i, iz, ch;
        if (id.length === 0) {
          return false;
        }
        ch = id.charCodeAt(0);
        if (!code.isIdentifierStartES5(ch)) {
          return false;
        }
        for (i = 1, iz = id.length; i < iz; ++i) {
          ch = id.charCodeAt(i);
          if (!code.isIdentifierPartES5(ch)) {
            return false;
          }
        }
        return true;
      }
      function decodeUtf16(lead, trail) {
        return (lead - 55296) * 1024 + (trail - 56320) + 65536;
      }
      function isIdentifierNameES6(id) {
        var i, iz, ch, lowCh, check;
        if (id.length === 0) {
          return false;
        }
        check = code.isIdentifierStartES6;
        for (i = 0, iz = id.length; i < iz; ++i) {
          ch = id.charCodeAt(i);
          if (55296 <= ch && ch <= 56319) {
            ++i;
            if (i >= iz) {
              return false;
            }
            lowCh = id.charCodeAt(i);
            if (!(56320 <= lowCh && lowCh <= 57343)) {
              return false;
            }
            ch = decodeUtf16(ch, lowCh);
          }
          if (!check(ch)) {
            return false;
          }
          check = code.isIdentifierPartES6;
        }
        return true;
      }
      function isIdentifierES5(id, strict) {
        return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
      }
      function isIdentifierES6(id, strict) {
        return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
      }
      module.exports = {
        isKeywordES5,
        isKeywordES6,
        isReservedWordES5,
        isReservedWordES6,
        isRestrictedWord,
        isIdentifierNameES5,
        isIdentifierNameES6,
        isIdentifierES5,
        isIdentifierES6
      };
    })();
  }
});

// ../../node_modules/esutils/lib/utils.js
var require_utils2 = __commonJS({
  "../../node_modules/esutils/lib/utils.js"(exports) {
    (function() {
      "use strict";
      exports.ast = require_ast();
      exports.code = require_code();
      exports.keyword = require_keyword2();
    })();
  }
});

// ../../node_modules/eslint/lib/rules/utils/ast-utils.js
var require_ast_utils2 = __commonJS({
  "../../node_modules/eslint/lib/rules/utils/ast-utils.js"(exports, module) {
    "use strict";
    var { KEYS: eslintVisitorKeys } = require_eslint_visitor_keys();
    var esutils = require_utils2();
    var espree = require_espree();
    var escapeRegExp = require_escape_string_regexp();
    var {
      breakableTypePattern,
      createGlobalLinebreakMatcher,
      lineBreakPattern,
      shebangPattern
    } = require_ast_utils();
    var anyFunctionPattern = /^(?:Function(?:Declaration|Expression)|ArrowFunctionExpression)$/u;
    var anyLoopPattern = /^(?:DoWhile|For|ForIn|ForOf|While)Statement$/u;
    var arrayOrTypedArrayPattern = /Array$/u;
    var arrayMethodPattern = /^(?:every|filter|find|findIndex|forEach|map|some)$/u;
    var bindOrCallOrApplyPattern = /^(?:bind|call|apply)$/u;
    var thisTagPattern = /^[\s*]*@this/mu;
    var COMMENTS_IGNORE_PATTERN = /^\s*(?:eslint|jshint\s+|jslint\s+|istanbul\s+|globals?\s+|exported\s+|jscs)/u;
    var ESLINT_DIRECTIVE_PATTERN = /^(?:eslint[- ]|(?:globals?|exported) )/u;
    var LINEBREAKS = /* @__PURE__ */ new Set(["\r\n", "\r", "\n", "\u2028", "\u2029"]);
    var STATEMENT_LIST_PARENTS = /* @__PURE__ */ new Set(["Program", "BlockStatement", "StaticBlock", "SwitchCase"]);
    var DECIMAL_INTEGER_PATTERN = /^(?:0|0[0-7]*[89]\d*|[1-9](?:_?\d)*)$/u;
    var OCTAL_OR_NON_OCTAL_DECIMAL_ESCAPE_PATTERN = /^(?:[^\\]|\\.)*\\(?:[1-9]|0[0-9])/su;
    var LOGICAL_ASSIGNMENT_OPERATORS = /* @__PURE__ */ new Set(["&&=", "||=", "??="]);
    function isModifyingReference(reference, index, references) {
      const identifier = reference.identifier;
      const modifyingDifferentIdentifier = index === 0 || references[index - 1].identifier !== identifier;
      return identifier && reference.init === false && reference.isWrite() && modifyingDifferentIdentifier;
    }
    function startsWithUpperCase(s) {
      return s[0] !== s[0].toLocaleLowerCase();
    }
    function isES5Constructor(node) {
      return node.id && startsWithUpperCase(node.id.name);
    }
    function getUpperFunction(node) {
      for (let currentNode = node; currentNode; currentNode = currentNode.parent) {
        if (anyFunctionPattern.test(currentNode.type)) {
          return currentNode;
        }
      }
      return null;
    }
    function isFunction(node) {
      return Boolean(node && anyFunctionPattern.test(node.type));
    }
    function isLoop(node) {
      return Boolean(node && anyLoopPattern.test(node.type));
    }
    function isInLoop(node) {
      for (let currentNode = node; currentNode && !isFunction(currentNode); currentNode = currentNode.parent) {
        if (isLoop(currentNode)) {
          return true;
        }
      }
      return false;
    }
    function isNullLiteral(node) {
      return node.type === "Literal" && node.value === null && !node.regex && !node.bigint;
    }
    function isNullOrUndefined(node) {
      return isNullLiteral(node) || node.type === "Identifier" && node.name === "undefined" || node.type === "UnaryExpression" && node.operator === "void";
    }
    function isCallee(node) {
      return node.parent.type === "CallExpression" && node.parent.callee === node;
    }
    function getStaticStringValue(node) {
      switch (node.type) {
        case "Literal":
          if (node.value === null) {
            if (isNullLiteral(node)) {
              return String(node.value);
            }
            if (node.regex) {
              return `/${node.regex.pattern}/${node.regex.flags}`;
            }
            if (node.bigint) {
              return node.bigint;
            }
          } else {
            return String(node.value);
          }
          break;
        case "TemplateLiteral":
          if (node.expressions.length === 0 && node.quasis.length === 1) {
            return node.quasis[0].value.cooked;
          }
          break;
      }
      return null;
    }
    function getStaticPropertyName(node) {
      let prop;
      switch (node && node.type) {
        case "ChainExpression":
          return getStaticPropertyName(node.expression);
        case "Property":
        case "PropertyDefinition":
        case "MethodDefinition":
          prop = node.key;
          break;
        case "MemberExpression":
          prop = node.property;
          break;
      }
      if (prop) {
        if (prop.type === "Identifier" && !node.computed) {
          return prop.name;
        }
        return getStaticStringValue(prop);
      }
      return null;
    }
    function skipChainExpression(node) {
      return node && node.type === "ChainExpression" ? node.expression : node;
    }
    function checkText(actual, expected) {
      return typeof expected === "string" ? actual === expected : expected.test(actual);
    }
    function isSpecificId(node, name) {
      return node.type === "Identifier" && checkText(node.name, name);
    }
    function isSpecificMemberAccess(node, objectName, propertyName) {
      const checkNode = skipChainExpression(node);
      if (checkNode.type !== "MemberExpression") {
        return false;
      }
      if (objectName && !isSpecificId(checkNode.object, objectName)) {
        return false;
      }
      if (propertyName) {
        const actualPropertyName = getStaticPropertyName(checkNode);
        if (typeof actualPropertyName !== "string" || !checkText(actualPropertyName, propertyName)) {
          return false;
        }
      }
      return true;
    }
    function equalLiteralValue(left, right) {
      if (left.regex || right.regex) {
        return Boolean(
          left.regex && right.regex && left.regex.pattern === right.regex.pattern && left.regex.flags === right.regex.flags
        );
      }
      if (left.bigint || right.bigint) {
        return left.bigint === right.bigint;
      }
      return left.value === right.value;
    }
    function isSameReference(left, right, disableStaticComputedKey = false) {
      if (left.type !== right.type) {
        if (left.type === "ChainExpression") {
          return isSameReference(left.expression, right, disableStaticComputedKey);
        }
        if (right.type === "ChainExpression") {
          return isSameReference(left, right.expression, disableStaticComputedKey);
        }
        return false;
      }
      switch (left.type) {
        case "Super":
        case "ThisExpression":
          return true;
        case "Identifier":
        case "PrivateIdentifier":
          return left.name === right.name;
        case "Literal":
          return equalLiteralValue(left, right);
        case "ChainExpression":
          return isSameReference(left.expression, right.expression, disableStaticComputedKey);
        case "MemberExpression": {
          if (!disableStaticComputedKey) {
            const nameA = getStaticPropertyName(left);
            if (nameA !== null) {
              return isSameReference(left.object, right.object, disableStaticComputedKey) && nameA === getStaticPropertyName(right);
            }
          }
          return left.computed === right.computed && isSameReference(left.object, right.object, disableStaticComputedKey) && isSameReference(left.property, right.property, disableStaticComputedKey);
        }
        default:
          return false;
      }
    }
    function isReflectApply(node) {
      return isSpecificMemberAccess(node, "Reflect", "apply");
    }
    function isArrayFromMethod(node) {
      return isSpecificMemberAccess(node, arrayOrTypedArrayPattern, "from");
    }
    function isMethodWhichHasThisArg(node) {
      return isSpecificMemberAccess(node, null, arrayMethodPattern);
    }
    function negate(f) {
      return (token) => !f(token);
    }
    function hasJSDocThisTag(node, sourceCode) {
      const jsdocComment = sourceCode.getJSDocComment(node);
      if (jsdocComment && thisTagPattern.test(jsdocComment.value)) {
        return true;
      }
      return sourceCode.getCommentsBefore(node).some((comment) => thisTagPattern.test(comment.value));
    }
    function isParenthesised(sourceCode, node) {
      const previousToken = sourceCode.getTokenBefore(node), nextToken = sourceCode.getTokenAfter(node);
      return Boolean(previousToken && nextToken) && previousToken.value === "(" && previousToken.range[1] <= node.range[0] && nextToken.value === ")" && nextToken.range[0] >= node.range[1];
    }
    function isEqToken(token) {
      return token.value === "=" && token.type === "Punctuator";
    }
    function isArrowToken(token) {
      return token.value === "=>" && token.type === "Punctuator";
    }
    function isCommaToken(token) {
      return token.value === "," && token.type === "Punctuator";
    }
    function isDotToken(token) {
      return token.value === "." && token.type === "Punctuator";
    }
    function isQuestionDotToken(token) {
      return token.value === "?." && token.type === "Punctuator";
    }
    function isSemicolonToken(token) {
      return token.value === ";" && token.type === "Punctuator";
    }
    function isColonToken(token) {
      return token.value === ":" && token.type === "Punctuator";
    }
    function isOpeningParenToken(token) {
      return token.value === "(" && token.type === "Punctuator";
    }
    function isClosingParenToken(token) {
      return token.value === ")" && token.type === "Punctuator";
    }
    function isOpeningBracketToken(token) {
      return token.value === "[" && token.type === "Punctuator";
    }
    function isClosingBracketToken(token) {
      return token.value === "]" && token.type === "Punctuator";
    }
    function isOpeningBraceToken(token) {
      return token.value === "{" && token.type === "Punctuator";
    }
    function isClosingBraceToken(token) {
      return token.value === "}" && token.type === "Punctuator";
    }
    function isCommentToken(token) {
      return token.type === "Line" || token.type === "Block" || token.type === "Shebang";
    }
    function isKeywordToken(token) {
      return token.type === "Keyword";
    }
    function getOpeningParenOfParams(node, sourceCode) {
      if (node.type === "ArrowFunctionExpression" && node.params.length === 1) {
        const argToken = sourceCode.getFirstToken(node.params[0]);
        const maybeParenToken = sourceCode.getTokenBefore(argToken);
        return isOpeningParenToken(maybeParenToken) ? maybeParenToken : argToken;
      }
      return node.id ? sourceCode.getTokenAfter(node.id, isOpeningParenToken) : sourceCode.getFirstToken(node, isOpeningParenToken);
    }
    function equalTokens(left, right, sourceCode) {
      const tokensL = sourceCode.getTokens(left);
      const tokensR = sourceCode.getTokens(right);
      if (tokensL.length !== tokensR.length) {
        return false;
      }
      for (let i = 0; i < tokensL.length; ++i) {
        if (tokensL[i].type !== tokensR[i].type || tokensL[i].value !== tokensR[i].value) {
          return false;
        }
      }
      return true;
    }
    function isLogicalExpression(node) {
      return node.type === "LogicalExpression" && (node.operator === "&&" || node.operator === "||");
    }
    function isCoalesceExpression(node) {
      return node.type === "LogicalExpression" && node.operator === "??";
    }
    function isMixedLogicalAndCoalesceExpressions(left, right) {
      return isLogicalExpression(left) && isCoalesceExpression(right) || isCoalesceExpression(left) && isLogicalExpression(right);
    }
    function isLogicalAssignmentOperator(operator) {
      return LOGICAL_ASSIGNMENT_OPERATORS.has(operator);
    }
    function getSwitchCaseColonToken(node, sourceCode) {
      if (node.test) {
        return sourceCode.getTokenAfter(node.test, isColonToken);
      }
      return sourceCode.getFirstToken(node, 1);
    }
    function getModuleExportName(node) {
      if (node.type === "Identifier") {
        return node.name;
      }
      return node.value;
    }
    function getBooleanValue(node) {
      if (node.value === null) {
        if (node.raw === "null") {
          return false;
        }
        if (typeof node.regex === "object") {
          return true;
        }
        return null;
      }
      return !!node.value;
    }
    function isLogicalIdentity(node, operator) {
      switch (node.type) {
        case "Literal":
          return operator === "||" && getBooleanValue(node) === true || operator === "&&" && getBooleanValue(node) === false;
        case "UnaryExpression":
          return operator === "&&" && node.operator === "void";
        case "LogicalExpression":
          return operator === node.operator && (isLogicalIdentity(node.left, operator) || isLogicalIdentity(node.right, operator));
        case "AssignmentExpression":
          return ["||=", "&&="].includes(node.operator) && operator === node.operator.slice(0, -1) && isLogicalIdentity(node.right, operator);
      }
      return false;
    }
    function isReferenceToGlobalVariable(scope, node) {
      const reference = scope.references.find((ref) => ref.identifier === node);
      return Boolean(
        reference && reference.resolved && reference.resolved.scope.type === "global" && reference.resolved.defs.length === 0
      );
    }
    function isConstant(scope, node, inBooleanPosition) {
      if (!node) {
        return true;
      }
      switch (node.type) {
        case "Literal":
        case "ArrowFunctionExpression":
        case "FunctionExpression":
          return true;
        case "ClassExpression":
        case "ObjectExpression":
          return true;
        case "TemplateLiteral":
          return inBooleanPosition && node.quasis.some((quasi) => quasi.value.cooked.length) || node.expressions.every((exp) => isConstant(scope, exp, false));
        case "ArrayExpression": {
          if (!inBooleanPosition) {
            return node.elements.every((element) => isConstant(scope, element, false));
          }
          return true;
        }
        case "UnaryExpression":
          if (node.operator === "void" || node.operator === "typeof" && inBooleanPosition) {
            return true;
          }
          if (node.operator === "!") {
            return isConstant(scope, node.argument, true);
          }
          return isConstant(scope, node.argument, false);
        case "BinaryExpression":
          return isConstant(scope, node.left, false) && isConstant(scope, node.right, false) && node.operator !== "in";
        case "LogicalExpression": {
          const isLeftConstant = isConstant(scope, node.left, inBooleanPosition);
          const isRightConstant = isConstant(scope, node.right, inBooleanPosition);
          const isLeftShortCircuit = isLeftConstant && isLogicalIdentity(node.left, node.operator);
          const isRightShortCircuit = inBooleanPosition && isRightConstant && isLogicalIdentity(node.right, node.operator);
          return isLeftConstant && isRightConstant || isLeftShortCircuit || isRightShortCircuit;
        }
        case "NewExpression":
          return inBooleanPosition;
        case "AssignmentExpression":
          if (node.operator === "=") {
            return isConstant(scope, node.right, inBooleanPosition);
          }
          if (["||=", "&&="].includes(node.operator) && inBooleanPosition) {
            return isLogicalIdentity(node.right, node.operator.slice(0, -1));
          }
          return false;
        case "SequenceExpression":
          return isConstant(scope, node.expressions[node.expressions.length - 1], inBooleanPosition);
        case "SpreadElement":
          return isConstant(scope, node.argument, inBooleanPosition);
        case "CallExpression":
          if (node.callee.type === "Identifier" && node.callee.name === "Boolean") {
            if (node.arguments.length === 0 || isConstant(scope, node.arguments[0], true)) {
              return isReferenceToGlobalVariable(scope, node.callee);
            }
          }
          return false;
        case "Identifier":
          return node.name === "undefined" && isReferenceToGlobalVariable(scope, node);
      }
      return false;
    }
    function isTopLevelExpressionStatement(node) {
      if (node.type !== "ExpressionStatement") {
        return false;
      }
      const parent = node.parent;
      return parent.type === "Program" || parent.type === "BlockStatement" && isFunction(parent.parent);
    }
    function isDirective(node) {
      return node.type === "ExpressionStatement" && typeof node.directive === "string";
    }
    module.exports = {
      COMMENTS_IGNORE_PATTERN,
      LINEBREAKS,
      LINEBREAK_MATCHER: lineBreakPattern,
      SHEBANG_MATCHER: shebangPattern,
      STATEMENT_LIST_PARENTS,
      /**
       * Determines whether two adjacent tokens are on the same line.
       * @param {Object} left The left token object.
       * @param {Object} right The right token object.
       * @returns {boolean} Whether or not the tokens are on the same line.
       * @public
       */
      isTokenOnSameLine(left, right) {
        return left.loc.end.line === right.loc.start.line;
      },
      isNullOrUndefined,
      isCallee,
      isES5Constructor,
      getUpperFunction,
      isFunction,
      isLoop,
      isInLoop,
      isArrayFromMethod,
      isParenthesised,
      createGlobalLinebreakMatcher,
      equalTokens,
      isArrowToken,
      isClosingBraceToken,
      isClosingBracketToken,
      isClosingParenToken,
      isColonToken,
      isCommaToken,
      isCommentToken,
      isDotToken,
      isQuestionDotToken,
      isKeywordToken,
      isNotClosingBraceToken: negate(isClosingBraceToken),
      isNotClosingBracketToken: negate(isClosingBracketToken),
      isNotClosingParenToken: negate(isClosingParenToken),
      isNotColonToken: negate(isColonToken),
      isNotCommaToken: negate(isCommaToken),
      isNotDotToken: negate(isDotToken),
      isNotQuestionDotToken: negate(isQuestionDotToken),
      isNotOpeningBraceToken: negate(isOpeningBraceToken),
      isNotOpeningBracketToken: negate(isOpeningBracketToken),
      isNotOpeningParenToken: negate(isOpeningParenToken),
      isNotSemicolonToken: negate(isSemicolonToken),
      isOpeningBraceToken,
      isOpeningBracketToken,
      isOpeningParenToken,
      isSemicolonToken,
      isEqToken,
      /**
       * Checks whether or not a given node is a string literal.
       * @param {ASTNode} node A node to check.
       * @returns {boolean} `true` if the node is a string literal.
       */
      isStringLiteral(node) {
        return node.type === "Literal" && typeof node.value === "string" || node.type === "TemplateLiteral";
      },
      /**
       * Checks whether a given node is a breakable statement or not.
       * The node is breakable if the node is one of the following type:
       *
       * - DoWhileStatement
       * - ForInStatement
       * - ForOfStatement
       * - ForStatement
       * - SwitchStatement
       * - WhileStatement
       * @param {ASTNode} node A node to check.
       * @returns {boolean} `true` if the node is breakable.
       */
      isBreakableStatement(node) {
        return breakableTypePattern.test(node.type);
      },
      /**
       * Gets references which are non initializer and writable.
       * @param {Reference[]} references An array of references.
       * @returns {Reference[]} An array of only references which are non initializer and writable.
       * @public
       */
      getModifyingReferences(references) {
        return references.filter(isModifyingReference);
      },
      /**
       * Validate that a string passed in is surrounded by the specified character
       * @param {string} val The text to check.
       * @param {string} character The character to see if it's surrounded by.
       * @returns {boolean} True if the text is surrounded by the character, false if not.
       * @private
       */
      isSurroundedBy(val, character) {
        return val[0] === character && val[val.length - 1] === character;
      },
      /**
       * Returns whether the provided node is an ESLint directive comment or not
       * @param {Line|Block} node The comment token to be checked
       * @returns {boolean} `true` if the node is an ESLint directive comment
       */
      isDirectiveComment(node) {
        const comment = node.value.trim();
        return node.type === "Line" && comment.startsWith("eslint-") || node.type === "Block" && ESLINT_DIRECTIVE_PATTERN.test(comment);
      },
      /**
       * Gets the trailing statement of a given node.
       *
       *     if (code)
       *         consequent;
       *
       * When taking this `IfStatement`, returns `consequent;` statement.
       * @param {ASTNode} A node to get.
       * @returns {ASTNode|null} The trailing statement's node.
       */
      getTrailingStatement: esutils.ast.trailingStatement,
      /**
       * Finds the variable by a given name in a given scope and its upper scopes.
       * @param {eslint-scope.Scope} initScope A scope to start find.
       * @param {string} name A variable name to find.
       * @returns {eslint-scope.Variable|null} A found variable or `null`.
       */
      getVariableByName(initScope, name) {
        let scope = initScope;
        while (scope) {
          const variable = scope.set.get(name);
          if (variable) {
            return variable;
          }
          scope = scope.upper;
        }
        return null;
      },
      /**
       * Checks whether or not a given function node is the default `this` binding.
       *
       * First, this checks the node:
       *
       * - The given node is not in `PropertyDefinition#value` position.
       * - The given node is not `StaticBlock`.
       * - The function name does not start with uppercase. It's a convention to capitalize the names
       *   of constructor functions. This check is not performed if `capIsConstructor` is set to `false`.
       * - The function does not have a JSDoc comment that has a @this tag.
       *
       * Next, this checks the location of the node.
       * If the location is below, this judges `this` is valid.
       *
       * - The location is not on an object literal.
       * - The location is not assigned to a variable which starts with an uppercase letter. Applies to anonymous
       *   functions only, as the name of the variable is considered to be the name of the function in this case.
       *   This check is not performed if `capIsConstructor` is set to `false`.
       * - The location is not on an ES2015 class.
       * - Its `bind`/`call`/`apply` method is not called directly.
       * - The function is not a callback of array methods (such as `.forEach()`) if `thisArg` is given.
       * @param {ASTNode} node A function node to check. It also can be an implicit function, like `StaticBlock`
       * or any expression that is `PropertyDefinition#value` node.
       * @param {SourceCode} sourceCode A SourceCode instance to get comments.
       * @param {boolean} [capIsConstructor = true] `false` disables the assumption that functions which name starts
       * with an uppercase or are assigned to a variable which name starts with an uppercase are constructors.
       * @returns {boolean} The function node is the default `this` binding.
       */
      isDefaultThisBinding(node, sourceCode, { capIsConstructor = true } = {}) {
        if (node.parent.type === "PropertyDefinition" && node.parent.value === node) {
          return false;
        }
        if (node.type === "StaticBlock") {
          return false;
        }
        if (capIsConstructor && isES5Constructor(node) || hasJSDocThisTag(node, sourceCode)) {
          return false;
        }
        const isAnonymous = node.id === null;
        let currentNode = node;
        while (currentNode) {
          const parent = currentNode.parent;
          switch (parent.type) {
            case "LogicalExpression":
            case "ConditionalExpression":
            case "ChainExpression":
              currentNode = parent;
              break;
            case "ReturnStatement": {
              const func = getUpperFunction(parent);
              if (func === null || !isCallee(func)) {
                return true;
              }
              currentNode = func.parent;
              break;
            }
            case "ArrowFunctionExpression":
              if (currentNode !== parent.body || !isCallee(parent)) {
                return true;
              }
              currentNode = parent.parent;
              break;
            case "Property":
            case "PropertyDefinition":
            case "MethodDefinition":
              return parent.value !== currentNode;
            case "AssignmentExpression":
            case "AssignmentPattern":
              if (parent.left.type === "MemberExpression") {
                return false;
              }
              if (capIsConstructor && isAnonymous && parent.left.type === "Identifier" && startsWithUpperCase(parent.left.name)) {
                return false;
              }
              return true;
            case "VariableDeclarator":
              return !(capIsConstructor && isAnonymous && parent.init === currentNode && parent.id.type === "Identifier" && startsWithUpperCase(parent.id.name));
            case "MemberExpression":
              if (parent.object === currentNode && isSpecificMemberAccess(parent, null, bindOrCallOrApplyPattern)) {
                const maybeCalleeNode = parent.parent.type === "ChainExpression" ? parent.parent : parent;
                return !(isCallee(maybeCalleeNode) && maybeCalleeNode.parent.arguments.length >= 1 && !isNullOrUndefined(maybeCalleeNode.parent.arguments[0]));
              }
              return true;
            case "CallExpression":
              if (isReflectApply(parent.callee)) {
                return parent.arguments.length !== 3 || parent.arguments[0] !== currentNode || isNullOrUndefined(parent.arguments[1]);
              }
              if (isArrayFromMethod(parent.callee)) {
                return parent.arguments.length !== 3 || parent.arguments[1] !== currentNode || isNullOrUndefined(parent.arguments[2]);
              }
              if (isMethodWhichHasThisArg(parent.callee)) {
                return parent.arguments.length !== 2 || parent.arguments[0] !== currentNode || isNullOrUndefined(parent.arguments[1]);
              }
              return true;
            default:
              return true;
          }
        }
        return true;
      },
      /**
       * Get the precedence level based on the node type
       * @param {ASTNode} node node to evaluate
       * @returns {int} precedence level
       * @private
       */
      getPrecedence(node) {
        switch (node.type) {
          case "SequenceExpression":
            return 0;
          case "AssignmentExpression":
          case "ArrowFunctionExpression":
          case "YieldExpression":
            return 1;
          case "ConditionalExpression":
            return 3;
          case "LogicalExpression":
            switch (node.operator) {
              case "||":
              case "??":
                return 4;
              case "&&":
                return 5;
            }
          case "BinaryExpression":
            switch (node.operator) {
              case "|":
                return 6;
              case "^":
                return 7;
              case "&":
                return 8;
              case "==":
              case "!=":
              case "===":
              case "!==":
                return 9;
              case "<":
              case "<=":
              case ">":
              case ">=":
              case "in":
              case "instanceof":
                return 10;
              case "<<":
              case ">>":
              case ">>>":
                return 11;
              case "+":
              case "-":
                return 12;
              case "*":
              case "/":
              case "%":
                return 13;
              case "**":
                return 15;
            }
          case "UnaryExpression":
          case "AwaitExpression":
            return 16;
          case "UpdateExpression":
            return 17;
          case "CallExpression":
          case "ChainExpression":
          case "ImportExpression":
            return 18;
          case "NewExpression":
            return 19;
          default:
            if (node.type in eslintVisitorKeys) {
              return 20;
            }
            return -1;
        }
      },
      /**
       * Checks whether the given node is an empty block node or not.
       * @param {ASTNode|null} node The node to check.
       * @returns {boolean} `true` if the node is an empty block.
       */
      isEmptyBlock(node) {
        return Boolean(node && node.type === "BlockStatement" && node.body.length === 0);
      },
      /**
       * Checks whether the given node is an empty function node or not.
       * @param {ASTNode|null} node The node to check.
       * @returns {boolean} `true` if the node is an empty function.
       */
      isEmptyFunction(node) {
        return isFunction(node) && module.exports.isEmptyBlock(node.body);
      },
      /**
       * Get directives from directive prologue of a Program or Function node.
       * @param {ASTNode} node The node to check.
       * @returns {ASTNode[]} The directives found in the directive prologue.
       */
      getDirectivePrologue(node) {
        const directives = [];
        if (node.type === "Program" || node.type === "FunctionDeclaration" || node.type === "FunctionExpression" || /*
         * Do not check arrow functions with implicit return.
         * `() => "use strict";` returns the string `"use strict"`.
         */
        node.type === "ArrowFunctionExpression" && node.body.type === "BlockStatement") {
          const statements = node.type === "Program" ? node.body : node.body.body;
          for (const statement of statements) {
            if (statement.type === "ExpressionStatement" && statement.expression.type === "Literal") {
              directives.push(statement);
            } else {
              break;
            }
          }
        }
        return directives;
      },
      /**
       * Determines whether this node is a decimal integer literal. If a node is a decimal integer literal, a dot added
       * after the node will be parsed as a decimal point, rather than a property-access dot.
       * @param {ASTNode} node The node to check.
       * @returns {boolean} `true` if this node is a decimal integer.
       * @example
       *
       * 0         // true
       * 5         // true
       * 50        // true
       * 5_000     // true
       * 1_234_56  // true
       * 08        // true
       * 0192      // true
       * 5.        // false
       * .5        // false
       * 5.0       // false
       * 5.00_00   // false
       * 05        // false
       * 0x5       // false
       * 0b101     // false
       * 0b11_01   // false
       * 0o5       // false
       * 5e0       // false
       * 5e1_000   // false
       * 5n        // false
       * 1_000n    // false
       * "5"       // false
       *
       */
      isDecimalInteger(node) {
        return node.type === "Literal" && typeof node.value === "number" && DECIMAL_INTEGER_PATTERN.test(node.raw);
      },
      /**
       * Determines whether this token is a decimal integer numeric token.
       * This is similar to isDecimalInteger(), but for tokens.
       * @param {Token} token The token to check.
       * @returns {boolean} `true` if this token is a decimal integer.
       */
      isDecimalIntegerNumericToken(token) {
        return token.type === "Numeric" && DECIMAL_INTEGER_PATTERN.test(token.value);
      },
      /**
       * Gets the name and kind of the given function node.
       *
       * - `function foo() {}`  .................... `function 'foo'`
       * - `(function foo() {})`  .................. `function 'foo'`
       * - `(function() {})`  ...................... `function`
       * - `function* foo() {}`  ................... `generator function 'foo'`
       * - `(function* foo() {})`  ................. `generator function 'foo'`
       * - `(function*() {})`  ..................... `generator function`
       * - `() => {}`  ............................. `arrow function`
       * - `async () => {}`  ....................... `async arrow function`
       * - `({ foo: function foo() {} })`  ......... `method 'foo'`
       * - `({ foo: function() {} })`  ............. `method 'foo'`
       * - `({ ['foo']: function() {} })`  ......... `method 'foo'`
       * - `({ [foo]: function() {} })`  ........... `method`
       * - `({ foo() {} })`  ....................... `method 'foo'`
       * - `({ foo: function* foo() {} })`  ........ `generator method 'foo'`
       * - `({ foo: function*() {} })`  ............ `generator method 'foo'`
       * - `({ ['foo']: function*() {} })`  ........ `generator method 'foo'`
       * - `({ [foo]: function*() {} })`  .......... `generator method`
       * - `({ *foo() {} })`  ...................... `generator method 'foo'`
       * - `({ foo: async function foo() {} })`  ... `async method 'foo'`
       * - `({ foo: async function() {} })`  ....... `async method 'foo'`
       * - `({ ['foo']: async function() {} })`  ... `async method 'foo'`
       * - `({ [foo]: async function() {} })`  ..... `async method`
       * - `({ async foo() {} })`  ................. `async method 'foo'`
       * - `({ get foo() {} })`  ................... `getter 'foo'`
       * - `({ set foo(a) {} })`  .................. `setter 'foo'`
       * - `class A { constructor() {} }`  ......... `constructor`
       * - `class A { foo() {} }`  ................. `method 'foo'`
       * - `class A { *foo() {} }`  ................ `generator method 'foo'`
       * - `class A { async foo() {} }`  ........... `async method 'foo'`
       * - `class A { ['foo']() {} }`  ............. `method 'foo'`
       * - `class A { *['foo']() {} }`  ............ `generator method 'foo'`
       * - `class A { async ['foo']() {} }`  ....... `async method 'foo'`
       * - `class A { [foo]() {} }`  ............... `method`
       * - `class A { *[foo]() {} }`  .............. `generator method`
       * - `class A { async [foo]() {} }`  ......... `async method`
       * - `class A { get foo() {} }`  ............. `getter 'foo'`
       * - `class A { set foo(a) {} }`  ............ `setter 'foo'`
       * - `class A { static foo() {} }`  .......... `static method 'foo'`
       * - `class A { static *foo() {} }`  ......... `static generator method 'foo'`
       * - `class A { static async foo() {} }`  .... `static async method 'foo'`
       * - `class A { static get foo() {} }`  ...... `static getter 'foo'`
       * - `class A { static set foo(a) {} }`  ..... `static setter 'foo'`
       * - `class A { foo = () => {}; }`  .......... `method 'foo'`
       * - `class A { foo = function() {}; }`  ..... `method 'foo'`
       * - `class A { foo = function bar() {}; }`  . `method 'foo'`
       * - `class A { static foo = () => {}; }`  ... `static method 'foo'`
       * - `class A { '#foo' = () => {}; }`  ....... `method '#foo'`
       * - `class A { #foo = () => {}; }`  ......... `private method #foo`
       * - `class A { static #foo = () => {}; }`  .. `static private method #foo`
       * - `class A { '#foo'() {} }`  .............. `method '#foo'`
       * - `class A { #foo() {} }`  ................ `private method #foo`
       * - `class A { static #foo() {} }`  ......... `static private method #foo`
       * @param {ASTNode} node The function node to get.
       * @returns {string} The name and kind of the function node.
       */
      getFunctionNameWithKind(node) {
        const parent = node.parent;
        const tokens = [];
        if (parent.type === "MethodDefinition" || parent.type === "PropertyDefinition") {
          if (parent.static) {
            tokens.push("static");
          }
          if (!parent.computed && parent.key.type === "PrivateIdentifier") {
            tokens.push("private");
          }
        }
        if (node.async) {
          tokens.push("async");
        }
        if (node.generator) {
          tokens.push("generator");
        }
        if (parent.type === "Property" || parent.type === "MethodDefinition") {
          if (parent.kind === "constructor") {
            return "constructor";
          }
          if (parent.kind === "get") {
            tokens.push("getter");
          } else if (parent.kind === "set") {
            tokens.push("setter");
          } else {
            tokens.push("method");
          }
        } else if (parent.type === "PropertyDefinition") {
          tokens.push("method");
        } else {
          if (node.type === "ArrowFunctionExpression") {
            tokens.push("arrow");
          }
          tokens.push("function");
        }
        if (parent.type === "Property" || parent.type === "MethodDefinition" || parent.type === "PropertyDefinition") {
          if (!parent.computed && parent.key.type === "PrivateIdentifier") {
            tokens.push(`#${parent.key.name}`);
          } else {
            const name = getStaticPropertyName(parent);
            if (name !== null) {
              tokens.push(`'${name}'`);
            } else if (node.id) {
              tokens.push(`'${node.id.name}'`);
            }
          }
        } else if (node.id) {
          tokens.push(`'${node.id.name}'`);
        }
        return tokens.join(" ");
      },
      /**
       * Gets the location of the given function node for reporting.
       *
       * - `function foo() {}`
       *    ^^^^^^^^^^^^
       * - `(function foo() {})`
       *     ^^^^^^^^^^^^
       * - `(function() {})`
       *     ^^^^^^^^
       * - `function* foo() {}`
       *    ^^^^^^^^^^^^^
       * - `(function* foo() {})`
       *     ^^^^^^^^^^^^^
       * - `(function*() {})`
       *     ^^^^^^^^^
       * - `() => {}`
       *       ^^
       * - `async () => {}`
       *             ^^
       * - `({ foo: function foo() {} })`
       *       ^^^^^^^^^^^^^^^^^
       * - `({ foo: function() {} })`
       *       ^^^^^^^^^^^^^
       * - `({ ['foo']: function() {} })`
       *       ^^^^^^^^^^^^^^^^^
       * - `({ [foo]: function() {} })`
       *       ^^^^^^^^^^^^^^^
       * - `({ foo() {} })`
       *       ^^^
       * - `({ foo: function* foo() {} })`
       *       ^^^^^^^^^^^^^^^^^^
       * - `({ foo: function*() {} })`
       *       ^^^^^^^^^^^^^^
       * - `({ ['foo']: function*() {} })`
       *       ^^^^^^^^^^^^^^^^^^
       * - `({ [foo]: function*() {} })`
       *       ^^^^^^^^^^^^^^^^
       * - `({ *foo() {} })`
       *       ^^^^
       * - `({ foo: async function foo() {} })`
       *       ^^^^^^^^^^^^^^^^^^^^^^^
       * - `({ foo: async function() {} })`
       *       ^^^^^^^^^^^^^^^^^^^
       * - `({ ['foo']: async function() {} })`
       *       ^^^^^^^^^^^^^^^^^^^^^^^
       * - `({ [foo]: async function() {} })`
       *       ^^^^^^^^^^^^^^^^^^^^^
       * - `({ async foo() {} })`
       *       ^^^^^^^^^
       * - `({ get foo() {} })`
       *       ^^^^^^^
       * - `({ set foo(a) {} })`
       *       ^^^^^^^
       * - `class A { constructor() {} }`
       *              ^^^^^^^^^^^
       * - `class A { foo() {} }`
       *              ^^^
       * - `class A { *foo() {} }`
       *              ^^^^
       * - `class A { async foo() {} }`
       *              ^^^^^^^^^
       * - `class A { ['foo']() {} }`
       *              ^^^^^^^
       * - `class A { *['foo']() {} }`
       *              ^^^^^^^^
       * - `class A { async ['foo']() {} }`
       *              ^^^^^^^^^^^^^
       * - `class A { [foo]() {} }`
       *              ^^^^^
       * - `class A { *[foo]() {} }`
       *              ^^^^^^
       * - `class A { async [foo]() {} }`
       *              ^^^^^^^^^^^
       * - `class A { get foo() {} }`
       *              ^^^^^^^
       * - `class A { set foo(a) {} }`
       *              ^^^^^^^
       * - `class A { static foo() {} }`
       *              ^^^^^^^^^^
       * - `class A { static *foo() {} }`
       *              ^^^^^^^^^^^
       * - `class A { static async foo() {} }`
       *              ^^^^^^^^^^^^^^^^
       * - `class A { static get foo() {} }`
       *              ^^^^^^^^^^^^^^
       * - `class A { static set foo(a) {} }`
       *              ^^^^^^^^^^^^^^
       * - `class A { foo = function() {} }`
       *              ^^^^^^^^^^^^^^
       * - `class A { static foo = function() {} }`
       *              ^^^^^^^^^^^^^^^^^^^^^
       * - `class A { foo = (a, b) => {} }`
       *              ^^^^^^
       * @param {ASTNode} node The function node to get.
       * @param {SourceCode} sourceCode The source code object to get tokens.
       * @returns {string} The location of the function node for reporting.
       */
      getFunctionHeadLoc(node, sourceCode) {
        const parent = node.parent;
        let start = null;
        let end = null;
        if (parent.type === "Property" || parent.type === "MethodDefinition" || parent.type === "PropertyDefinition") {
          start = parent.loc.start;
          end = getOpeningParenOfParams(node, sourceCode).loc.start;
        } else if (node.type === "ArrowFunctionExpression") {
          const arrowToken = sourceCode.getTokenBefore(node.body, isArrowToken);
          start = arrowToken.loc.start;
          end = arrowToken.loc.end;
        } else {
          start = node.loc.start;
          end = getOpeningParenOfParams(node, sourceCode).loc.start;
        }
        return {
          start: Object.assign({}, start),
          end: Object.assign({}, end)
        };
      },
      /**
       * Gets next location when the result is not out of bound, otherwise returns null.
       *
       * Assumptions:
       *
       * - The given location represents a valid location in the given source code.
       * - Columns are 0-based.
       * - Lines are 1-based.
       * - Column immediately after the last character in a line (not incl. linebreaks) is considered to be a valid location.
       * - If the source code ends with a linebreak, `sourceCode.lines` array will have an extra element (empty string) at the end.
       *   The start (column 0) of that extra line is considered to be a valid location.
       *
       * Examples of successive locations (line, column):
       *
       * code: foo
       * locations: (1, 0) -> (1, 1) -> (1, 2) -> (1, 3) -> null
       *
       * code: foo<LF>
       * locations: (1, 0) -> (1, 1) -> (1, 2) -> (1, 3) -> (2, 0) -> null
       *
       * code: foo<CR><LF>
       * locations: (1, 0) -> (1, 1) -> (1, 2) -> (1, 3) -> (2, 0) -> null
       *
       * code: a<LF>b
       * locations: (1, 0) -> (1, 1) -> (2, 0) -> (2, 1) -> null
       *
       * code: a<LF>b<LF>
       * locations: (1, 0) -> (1, 1) -> (2, 0) -> (2, 1) -> (3, 0) -> null
       *
       * code: a<CR><LF>b<CR><LF>
       * locations: (1, 0) -> (1, 1) -> (2, 0) -> (2, 1) -> (3, 0) -> null
       *
       * code: a<LF><LF>
       * locations: (1, 0) -> (1, 1) -> (2, 0) -> (3, 0) -> null
       *
       * code: <LF>
       * locations: (1, 0) -> (2, 0) -> null
       *
       * code:
       * locations: (1, 0) -> null
       * @param {SourceCode} sourceCode The sourceCode
       * @param {{line: number, column: number}} location The location
       * @returns {{line: number, column: number} | null} Next location
       */
      getNextLocation(sourceCode, { line, column }) {
        if (column < sourceCode.lines[line - 1].length) {
          return {
            line,
            column: column + 1
          };
        }
        if (line < sourceCode.lines.length) {
          return {
            line: line + 1,
            column: 0
          };
        }
        return null;
      },
      /**
       * Gets the parenthesized text of a node. This is similar to sourceCode.getText(node), but it also includes any parentheses
       * surrounding the node.
       * @param {SourceCode} sourceCode The source code object
       * @param {ASTNode} node An expression node
       * @returns {string} The text representing the node, with all surrounding parentheses included
       */
      getParenthesisedText(sourceCode, node) {
        let leftToken = sourceCode.getFirstToken(node);
        let rightToken = sourceCode.getLastToken(node);
        while (sourceCode.getTokenBefore(leftToken) && sourceCode.getTokenBefore(leftToken).type === "Punctuator" && sourceCode.getTokenBefore(leftToken).value === "(" && sourceCode.getTokenAfter(rightToken) && sourceCode.getTokenAfter(rightToken).type === "Punctuator" && sourceCode.getTokenAfter(rightToken).value === ")") {
          leftToken = sourceCode.getTokenBefore(leftToken);
          rightToken = sourceCode.getTokenAfter(rightToken);
        }
        return sourceCode.getText().slice(leftToken.range[0], rightToken.range[1]);
      },
      /**
       * Determine if a node has a possibility to be an Error object
       * @param {ASTNode} node ASTNode to check
       * @returns {boolean} True if there is a chance it contains an Error obj
       */
      couldBeError(node) {
        switch (node.type) {
          case "Identifier":
          case "CallExpression":
          case "NewExpression":
          case "MemberExpression":
          case "TaggedTemplateExpression":
          case "YieldExpression":
          case "AwaitExpression":
          case "ChainExpression":
            return true;
          case "AssignmentExpression":
            if (["=", "&&="].includes(node.operator)) {
              return module.exports.couldBeError(node.right);
            }
            if (["||=", "??="].includes(node.operator)) {
              return module.exports.couldBeError(node.left) || module.exports.couldBeError(node.right);
            }
            return false;
          case "SequenceExpression": {
            const exprs = node.expressions;
            return exprs.length !== 0 && module.exports.couldBeError(exprs[exprs.length - 1]);
          }
          case "LogicalExpression":
            if (node.operator === "&&") {
              return module.exports.couldBeError(node.right);
            }
            return module.exports.couldBeError(node.left) || module.exports.couldBeError(node.right);
          case "ConditionalExpression":
            return module.exports.couldBeError(node.consequent) || module.exports.couldBeError(node.alternate);
          default:
            return false;
        }
      },
      /**
       * Check if a given node is a numeric literal or not.
       * @param {ASTNode} node The node to check.
       * @returns {boolean} `true` if the node is a number or bigint literal.
       */
      isNumericLiteral(node) {
        return node.type === "Literal" && (typeof node.value === "number" || Boolean(node.bigint));
      },
      /**
       * Determines whether two tokens can safely be placed next to each other without merging into a single token
       * @param {Token|string} leftValue The left token. If this is a string, it will be tokenized and the last token will be used.
       * @param {Token|string} rightValue The right token. If this is a string, it will be tokenized and the first token will be used.
       * @returns {boolean} If the tokens cannot be safely placed next to each other, returns `false`. If the tokens can be placed
       * next to each other, behavior is undefined (although it should return `true` in most cases).
       */
      canTokensBeAdjacent(leftValue, rightValue) {
        const espreeOptions = {
          ecmaVersion: espree.latestEcmaVersion,
          comment: true,
          range: true
        };
        let leftToken;
        if (typeof leftValue === "string") {
          let tokens;
          try {
            tokens = espree.tokenize(leftValue, espreeOptions);
          } catch {
            return false;
          }
          const comments = tokens.comments;
          leftToken = tokens[tokens.length - 1];
          if (comments.length) {
            const lastComment = comments[comments.length - 1];
            if (!leftToken || lastComment.range[0] > leftToken.range[0]) {
              leftToken = lastComment;
            }
          }
        } else {
          leftToken = leftValue;
        }
        if (leftToken.type === "Shebang" || leftToken.type === "Hashbang") {
          return false;
        }
        let rightToken;
        if (typeof rightValue === "string") {
          let tokens;
          try {
            tokens = espree.tokenize(rightValue, espreeOptions);
          } catch {
            return false;
          }
          const comments = tokens.comments;
          rightToken = tokens[0];
          if (comments.length) {
            const firstComment = comments[0];
            if (!rightToken || firstComment.range[0] < rightToken.range[0]) {
              rightToken = firstComment;
            }
          }
        } else {
          rightToken = rightValue;
        }
        if (leftToken.type === "Punctuator" || rightToken.type === "Punctuator") {
          if (leftToken.type === "Punctuator" && rightToken.type === "Punctuator") {
            const PLUS_TOKENS = /* @__PURE__ */ new Set(["+", "++"]);
            const MINUS_TOKENS = /* @__PURE__ */ new Set(["-", "--"]);
            return !(PLUS_TOKENS.has(leftToken.value) && PLUS_TOKENS.has(rightToken.value) || MINUS_TOKENS.has(leftToken.value) && MINUS_TOKENS.has(rightToken.value));
          }
          if (leftToken.type === "Punctuator" && leftToken.value === "/") {
            return !["Block", "Line", "RegularExpression"].includes(rightToken.type);
          }
          return true;
        }
        if (leftToken.type === "String" || rightToken.type === "String" || leftToken.type === "Template" || rightToken.type === "Template") {
          return true;
        }
        if (leftToken.type !== "Numeric" && rightToken.type === "Numeric" && rightToken.value.startsWith(".")) {
          return true;
        }
        if (leftToken.type === "Block" || rightToken.type === "Block" || rightToken.type === "Line") {
          return true;
        }
        if (rightToken.type === "PrivateIdentifier") {
          return true;
        }
        return false;
      },
      /**
       * Get the `loc` object of a given name in a `/*globals` directive comment.
       * @param {SourceCode} sourceCode The source code to convert index to loc.
       * @param {Comment} comment The `/*globals` directive comment which include the name.
       * @param {string} name The name to find.
       * @returns {SourceLocation} The `loc` object.
       */
      getNameLocationInGlobalDirectiveComment(sourceCode, comment, name) {
        const namePattern = new RegExp(`[\\s,]${escapeRegExp(name)}(?:$|[\\s,:])`, "gu");
        namePattern.lastIndex = comment.value.indexOf("global") + 6;
        const match = namePattern.exec(comment.value);
        const start = sourceCode.getLocFromIndex(
          comment.range[0] + "/*".length + (match ? match.index + 1 : 0)
        );
        const end = {
          line: start.line,
          column: start.column + (match ? name.length : 1)
        };
        return { start, end };
      },
      /**
       * Determines whether the given raw string contains an octal escape sequence
       * or a non-octal decimal escape sequence ("\8", "\9").
       *
       * "\1", "\2" ... "\7", "\8", "\9"
       * "\00", "\01" ... "\07", "\08", "\09"
       *
       * "\0", when not followed by a digit, is not an octal escape sequence.
       * @param {string} rawString A string in its raw representation.
       * @returns {boolean} `true` if the string contains at least one octal escape sequence
       * or at least one non-octal decimal escape sequence.
       */
      hasOctalOrNonOctalDecimalEscapeSequence(rawString) {
        return OCTAL_OR_NON_OCTAL_DECIMAL_ESCAPE_PATTERN.test(rawString);
      },
      /**
       * Determines whether the given node is a template literal without expressions.
       * @param {ASTNode} node Node to check.
       * @returns {boolean} True if the node is a template literal without expressions.
       */
      isStaticTemplateLiteral(node) {
        return node.type === "TemplateLiteral" && node.expressions.length === 0;
      },
      isReferenceToGlobalVariable,
      isLogicalExpression,
      isCoalesceExpression,
      isMixedLogicalAndCoalesceExpressions,
      isNullLiteral,
      getStaticStringValue,
      getStaticPropertyName,
      skipChainExpression,
      isSpecificId,
      isSpecificMemberAccess,
      equalLiteralValue,
      isSameReference,
      isLogicalAssignmentOperator,
      getSwitchCaseColonToken,
      getModuleExportName,
      isConstant,
      isTopLevelExpressionStatement,
      isDirective
    };
  }
});

// ../../node_modules/eslint/lib/rules/accessor-pairs.js
var require_accessor_pairs = __commonJS({
  "../../node_modules/eslint/lib/rules/accessor-pairs.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    function areEqualTokenLists(left, right) {
      if (left.length !== right.length) {
        return false;
      }
      for (let i = 0; i < left.length; i++) {
        const leftToken = left[i], rightToken = right[i];
        if (leftToken.type !== rightToken.type || leftToken.value !== rightToken.value) {
          return false;
        }
      }
      return true;
    }
    function areEqualKeys(left, right) {
      if (typeof left === "string" && typeof right === "string") {
        return left === right;
      }
      if (Array.isArray(left) && Array.isArray(right)) {
        return areEqualTokenLists(left, right);
      }
      return false;
    }
    function isAccessorKind(node) {
      return node.kind === "get" || node.kind === "set";
    }
    function isArgumentOfMethodCall(node, index, object, property) {
      const parent = node.parent;
      return parent.type === "CallExpression" && astUtils.isSpecificMemberAccess(parent.callee, object, property) && parent.arguments[index] === node;
    }
    function isPropertyDescriptor(node) {
      if (isArgumentOfMethodCall(node, 2, "Object", "defineProperty") || isArgumentOfMethodCall(node, 2, "Reflect", "defineProperty")) {
        return true;
      }
      const grandparent = node.parent.parent;
      return grandparent.type === "ObjectExpression" && (isArgumentOfMethodCall(grandparent, 1, "Object", "create") || isArgumentOfMethodCall(grandparent, 1, "Object", "defineProperties"));
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Enforce getter and setter pairs in objects and classes",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/accessor-pairs"
        },
        schema: [{
          type: "object",
          properties: {
            getWithoutSet: {
              type: "boolean",
              default: false
            },
            setWithoutGet: {
              type: "boolean",
              default: true
            },
            enforceForClassMembers: {
              type: "boolean",
              default: true
            }
          },
          additionalProperties: false
        }],
        messages: {
          missingGetterInPropertyDescriptor: "Getter is not present in property descriptor.",
          missingSetterInPropertyDescriptor: "Setter is not present in property descriptor.",
          missingGetterInObjectLiteral: "Getter is not present for {{ name }}.",
          missingSetterInObjectLiteral: "Setter is not present for {{ name }}.",
          missingGetterInClass: "Getter is not present for class {{ name }}.",
          missingSetterInClass: "Setter is not present for class {{ name }}."
        }
      },
      create(context) {
        const config = context.options[0] || {};
        const checkGetWithoutSet = config.getWithoutSet === true;
        const checkSetWithoutGet = config.setWithoutGet !== false;
        const enforceForClassMembers = config.enforceForClassMembers !== false;
        const sourceCode = context.sourceCode;
        function report(node, messageKind) {
          if (node.type === "Property") {
            context.report({
              node,
              messageId: `${messageKind}InObjectLiteral`,
              loc: astUtils.getFunctionHeadLoc(node.value, sourceCode),
              data: { name: astUtils.getFunctionNameWithKind(node.value) }
            });
          } else if (node.type === "MethodDefinition") {
            context.report({
              node,
              messageId: `${messageKind}InClass`,
              loc: astUtils.getFunctionHeadLoc(node.value, sourceCode),
              data: { name: astUtils.getFunctionNameWithKind(node.value) }
            });
          } else {
            context.report({
              node,
              messageId: `${messageKind}InPropertyDescriptor`
            });
          }
        }
        function reportList(nodes, messageKind) {
          for (const node of nodes) {
            report(node, messageKind);
          }
        }
        function checkList(nodes) {
          const accessors = [];
          let found = false;
          for (let i = 0; i < nodes.length; i++) {
            const node = nodes[i];
            if (isAccessorKind(node)) {
              const name = astUtils.getStaticPropertyName(node);
              const key = name !== null ? name : sourceCode.getTokens(node.key);
              for (let j = 0; j < accessors.length; j++) {
                const accessor = accessors[j];
                if (areEqualKeys(accessor.key, key)) {
                  accessor.getters.push(...node.kind === "get" ? [node] : []);
                  accessor.setters.push(...node.kind === "set" ? [node] : []);
                  found = true;
                  break;
                }
              }
              if (!found) {
                accessors.push({
                  key,
                  getters: node.kind === "get" ? [node] : [],
                  setters: node.kind === "set" ? [node] : []
                });
              }
              found = false;
            }
          }
          for (const { getters, setters } of accessors) {
            if (checkSetWithoutGet && setters.length && !getters.length) {
              reportList(setters, "missingGetter");
            }
            if (checkGetWithoutSet && getters.length && !setters.length) {
              reportList(getters, "missingSetter");
            }
          }
        }
        function checkObjectLiteral(node) {
          checkList(node.properties.filter((p) => p.type === "Property"));
        }
        function checkPropertyDescriptor(node) {
          const namesToCheck = new Set(node.properties.filter((p) => p.type === "Property" && p.kind === "init" && !p.computed).map(({ key }) => key.name));
          const hasGetter = namesToCheck.has("get");
          const hasSetter = namesToCheck.has("set");
          if (checkSetWithoutGet && hasSetter && !hasGetter) {
            report(node, "missingGetter");
          }
          if (checkGetWithoutSet && hasGetter && !hasSetter) {
            report(node, "missingSetter");
          }
        }
        function checkObjectExpression(node) {
          checkObjectLiteral(node);
          if (isPropertyDescriptor(node)) {
            checkPropertyDescriptor(node);
          }
        }
        function checkClassBody(node) {
          const methodDefinitions = node.body.filter((m) => m.type === "MethodDefinition");
          checkList(methodDefinitions.filter((m) => m.static));
          checkList(methodDefinitions.filter((m) => !m.static));
        }
        const listeners = {};
        if (checkSetWithoutGet || checkGetWithoutSet) {
          listeners.ObjectExpression = checkObjectExpression;
          if (enforceForClassMembers) {
            listeners.ClassBody = checkClassBody;
          }
        }
        return listeners;
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/array-bracket-newline.js
var require_array_bracket_newline = __commonJS({
  "../../node_modules/eslint/lib/rules/array-bracket-newline.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Enforce linebreaks after opening and before closing array brackets",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/array-bracket-newline"
        },
        fixable: "whitespace",
        schema: [
          {
            oneOf: [
              {
                enum: ["always", "never", "consistent"]
              },
              {
                type: "object",
                properties: {
                  multiline: {
                    type: "boolean"
                  },
                  minItems: {
                    type: ["integer", "null"],
                    minimum: 0
                  }
                },
                additionalProperties: false
              }
            ]
          }
        ],
        messages: {
          unexpectedOpeningLinebreak: "There should be no linebreak after '['.",
          unexpectedClosingLinebreak: "There should be no linebreak before ']'.",
          missingOpeningLinebreak: "A linebreak is required after '['.",
          missingClosingLinebreak: "A linebreak is required before ']'."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        function normalizeOptionValue(option) {
          let consistent = false;
          let multiline = false;
          let minItems = 0;
          if (option) {
            if (option === "consistent") {
              consistent = true;
              minItems = Number.POSITIVE_INFINITY;
            } else if (option === "always" || option.minItems === 0) {
              minItems = 0;
            } else if (option === "never") {
              minItems = Number.POSITIVE_INFINITY;
            } else {
              multiline = Boolean(option.multiline);
              minItems = option.minItems || Number.POSITIVE_INFINITY;
            }
          } else {
            consistent = false;
            multiline = true;
            minItems = Number.POSITIVE_INFINITY;
          }
          return { consistent, multiline, minItems };
        }
        function normalizeOptions(options) {
          const value = normalizeOptionValue(options);
          return { ArrayExpression: value, ArrayPattern: value };
        }
        function reportNoBeginningLinebreak(node, token) {
          context.report({
            node,
            loc: token.loc,
            messageId: "unexpectedOpeningLinebreak",
            fix(fixer) {
              const nextToken = sourceCode.getTokenAfter(token, { includeComments: true });
              if (astUtils.isCommentToken(nextToken)) {
                return null;
              }
              return fixer.removeRange([token.range[1], nextToken.range[0]]);
            }
          });
        }
        function reportNoEndingLinebreak(node, token) {
          context.report({
            node,
            loc: token.loc,
            messageId: "unexpectedClosingLinebreak",
            fix(fixer) {
              const previousToken = sourceCode.getTokenBefore(token, { includeComments: true });
              if (astUtils.isCommentToken(previousToken)) {
                return null;
              }
              return fixer.removeRange([previousToken.range[1], token.range[0]]);
            }
          });
        }
        function reportRequiredBeginningLinebreak(node, token) {
          context.report({
            node,
            loc: token.loc,
            messageId: "missingOpeningLinebreak",
            fix(fixer) {
              return fixer.insertTextAfter(token, "\n");
            }
          });
        }
        function reportRequiredEndingLinebreak(node, token) {
          context.report({
            node,
            loc: token.loc,
            messageId: "missingClosingLinebreak",
            fix(fixer) {
              return fixer.insertTextBefore(token, "\n");
            }
          });
        }
        function check(node) {
          const elements = node.elements;
          const normalizedOptions = normalizeOptions(context.options[0]);
          const options = normalizedOptions[node.type];
          const openBracket = sourceCode.getFirstToken(node);
          const closeBracket = sourceCode.getLastToken(node);
          const firstIncComment = sourceCode.getTokenAfter(openBracket, { includeComments: true });
          const lastIncComment = sourceCode.getTokenBefore(closeBracket, { includeComments: true });
          const first = sourceCode.getTokenAfter(openBracket);
          const last = sourceCode.getTokenBefore(closeBracket);
          const needsLinebreaks = elements.length >= options.minItems || options.multiline && elements.length > 0 && firstIncComment.loc.start.line !== lastIncComment.loc.end.line || elements.length === 0 && firstIncComment.type === "Block" && firstIncComment.loc.start.line !== lastIncComment.loc.end.line && firstIncComment === lastIncComment || options.consistent && openBracket.loc.end.line !== first.loc.start.line;
          if (needsLinebreaks) {
            if (astUtils.isTokenOnSameLine(openBracket, first)) {
              reportRequiredBeginningLinebreak(node, openBracket);
            }
            if (astUtils.isTokenOnSameLine(last, closeBracket)) {
              reportRequiredEndingLinebreak(node, closeBracket);
            }
          } else {
            if (!astUtils.isTokenOnSameLine(openBracket, first)) {
              reportNoBeginningLinebreak(node, openBracket);
            }
            if (!astUtils.isTokenOnSameLine(last, closeBracket)) {
              reportNoEndingLinebreak(node, closeBracket);
            }
          }
        }
        return {
          ArrayPattern: check,
          ArrayExpression: check
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/array-bracket-spacing.js
var require_array_bracket_spacing = __commonJS({
  "../../node_modules/eslint/lib/rules/array-bracket-spacing.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Enforce consistent spacing inside array brackets",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/array-bracket-spacing"
        },
        fixable: "whitespace",
        schema: [
          {
            enum: ["always", "never"]
          },
          {
            type: "object",
            properties: {
              singleValue: {
                type: "boolean"
              },
              objectsInArrays: {
                type: "boolean"
              },
              arraysInArrays: {
                type: "boolean"
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          unexpectedSpaceAfter: "There should be no space after '{{tokenValue}}'.",
          unexpectedSpaceBefore: "There should be no space before '{{tokenValue}}'.",
          missingSpaceAfter: "A space is required after '{{tokenValue}}'.",
          missingSpaceBefore: "A space is required before '{{tokenValue}}'."
        }
      },
      create(context) {
        const spaced = context.options[0] === "always", sourceCode = context.sourceCode;
        function isOptionSet(option) {
          return context.options[1] ? context.options[1][option] === !spaced : false;
        }
        const options = {
          spaced,
          singleElementException: isOptionSet("singleValue"),
          objectsInArraysException: isOptionSet("objectsInArrays"),
          arraysInArraysException: isOptionSet("arraysInArrays")
        };
        function reportNoBeginningSpace(node, token) {
          const nextToken = sourceCode.getTokenAfter(token);
          context.report({
            node,
            loc: { start: token.loc.end, end: nextToken.loc.start },
            messageId: "unexpectedSpaceAfter",
            data: {
              tokenValue: token.value
            },
            fix(fixer) {
              return fixer.removeRange([token.range[1], nextToken.range[0]]);
            }
          });
        }
        function reportNoEndingSpace(node, token) {
          const previousToken = sourceCode.getTokenBefore(token);
          context.report({
            node,
            loc: { start: previousToken.loc.end, end: token.loc.start },
            messageId: "unexpectedSpaceBefore",
            data: {
              tokenValue: token.value
            },
            fix(fixer) {
              return fixer.removeRange([previousToken.range[1], token.range[0]]);
            }
          });
        }
        function reportRequiredBeginningSpace(node, token) {
          context.report({
            node,
            loc: token.loc,
            messageId: "missingSpaceAfter",
            data: {
              tokenValue: token.value
            },
            fix(fixer) {
              return fixer.insertTextAfter(token, " ");
            }
          });
        }
        function reportRequiredEndingSpace(node, token) {
          context.report({
            node,
            loc: token.loc,
            messageId: "missingSpaceBefore",
            data: {
              tokenValue: token.value
            },
            fix(fixer) {
              return fixer.insertTextBefore(token, " ");
            }
          });
        }
        function isObjectType(node) {
          return node && (node.type === "ObjectExpression" || node.type === "ObjectPattern");
        }
        function isArrayType(node) {
          return node && (node.type === "ArrayExpression" || node.type === "ArrayPattern");
        }
        function validateArraySpacing(node) {
          if (options.spaced && node.elements.length === 0) {
            return;
          }
          const first = sourceCode.getFirstToken(node), second = sourceCode.getFirstToken(node, 1), last = node.typeAnnotation ? sourceCode.getTokenBefore(node.typeAnnotation) : sourceCode.getLastToken(node), penultimate = sourceCode.getTokenBefore(last), firstElement = node.elements[0], lastElement = node.elements[node.elements.length - 1];
          const openingBracketMustBeSpaced = options.objectsInArraysException && isObjectType(firstElement) || options.arraysInArraysException && isArrayType(firstElement) || options.singleElementException && node.elements.length === 1 ? !options.spaced : options.spaced;
          const closingBracketMustBeSpaced = options.objectsInArraysException && isObjectType(lastElement) || options.arraysInArraysException && isArrayType(lastElement) || options.singleElementException && node.elements.length === 1 ? !options.spaced : options.spaced;
          if (astUtils.isTokenOnSameLine(first, second)) {
            if (openingBracketMustBeSpaced && !sourceCode.isSpaceBetweenTokens(first, second)) {
              reportRequiredBeginningSpace(node, first);
            }
            if (!openingBracketMustBeSpaced && sourceCode.isSpaceBetweenTokens(first, second)) {
              reportNoBeginningSpace(node, first);
            }
          }
          if (first !== penultimate && astUtils.isTokenOnSameLine(penultimate, last)) {
            if (closingBracketMustBeSpaced && !sourceCode.isSpaceBetweenTokens(penultimate, last)) {
              reportRequiredEndingSpace(node, last);
            }
            if (!closingBracketMustBeSpaced && sourceCode.isSpaceBetweenTokens(penultimate, last)) {
              reportNoEndingSpace(node, last);
            }
          }
        }
        return {
          ArrayPattern: validateArraySpacing,
          ArrayExpression: validateArraySpacing
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/array-callback-return.js
var require_array_callback_return = __commonJS({
  "../../node_modules/eslint/lib/rules/array-callback-return.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/u;
    var TARGET_METHODS = /^(?:every|filter|find(?:Last)?(?:Index)?|flatMap|forEach|map|reduce(?:Right)?|some|sort|toSorted)$/u;
    function isReachable(segment) {
      return segment.reachable;
    }
    function isTargetMethod(node) {
      return astUtils.isSpecificMemberAccess(node, null, TARGET_METHODS);
    }
    function fullMethodName(arrayMethodName) {
      if (["from", "of", "isArray"].includes(arrayMethodName)) {
        return "Array.".concat(arrayMethodName);
      }
      return "Array.prototype.".concat(arrayMethodName);
    }
    function getArrayMethodName(node) {
      let currentNode = node;
      while (currentNode) {
        const parent = currentNode.parent;
        switch (parent.type) {
          case "LogicalExpression":
          case "ConditionalExpression":
          case "ChainExpression":
            currentNode = parent;
            break;
          case "ReturnStatement": {
            const func = astUtils.getUpperFunction(parent);
            if (func === null || !astUtils.isCallee(func)) {
              return null;
            }
            currentNode = func.parent;
            break;
          }
          case "CallExpression":
            if (astUtils.isArrayFromMethod(parent.callee)) {
              if (parent.arguments.length >= 2 && parent.arguments[1] === currentNode) {
                return "from";
              }
            }
            if (isTargetMethod(parent.callee)) {
              if (parent.arguments.length >= 1 && parent.arguments[0] === currentNode) {
                return astUtils.getStaticPropertyName(parent.callee);
              }
            }
            return null;
          default:
            return null;
        }
      }
      return null;
    }
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Enforce `return` statements in callbacks of array methods",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/array-callback-return"
        },
        schema: [
          {
            type: "object",
            properties: {
              allowImplicit: {
                type: "boolean",
                default: false
              },
              checkForEach: {
                type: "boolean",
                default: false
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          expectedAtEnd: "{{arrayMethodName}}() expects a value to be returned at the end of {{name}}.",
          expectedInside: "{{arrayMethodName}}() expects a return value from {{name}}.",
          expectedReturnValue: "{{arrayMethodName}}() expects a return value from {{name}}.",
          expectedNoReturnValue: "{{arrayMethodName}}() expects no useless return value from {{name}}."
        }
      },
      create(context) {
        const options = context.options[0] || { allowImplicit: false, checkForEach: false };
        const sourceCode = context.sourceCode;
        let funcInfo = {
          arrayMethodName: null,
          upper: null,
          codePath: null,
          hasReturn: false,
          shouldCheck: false,
          node: null
        };
        function checkLastSegment(node) {
          if (!funcInfo.shouldCheck) {
            return;
          }
          let messageId = null;
          if (funcInfo.arrayMethodName === "forEach") {
            if (options.checkForEach && node.type === "ArrowFunctionExpression" && node.expression) {
              messageId = "expectedNoReturnValue";
            }
          } else {
            if (node.body.type === "BlockStatement" && funcInfo.codePath.currentSegments.some(isReachable)) {
              messageId = funcInfo.hasReturn ? "expectedAtEnd" : "expectedInside";
            }
          }
          if (messageId) {
            const name = astUtils.getFunctionNameWithKind(node);
            context.report({
              node,
              loc: astUtils.getFunctionHeadLoc(node, sourceCode),
              messageId,
              data: { name, arrayMethodName: fullMethodName(funcInfo.arrayMethodName) }
            });
          }
        }
        return {
          // Stacks this function's information.
          onCodePathStart(codePath, node) {
            let methodName = null;
            if (TARGET_NODE_TYPE.test(node.type)) {
              methodName = getArrayMethodName(node);
            }
            funcInfo = {
              arrayMethodName: methodName,
              upper: funcInfo,
              codePath,
              hasReturn: false,
              shouldCheck: methodName && !node.async && !node.generator,
              node
            };
          },
          // Pops this function's information.
          onCodePathEnd() {
            funcInfo = funcInfo.upper;
          },
          // Checks the return statement is valid.
          ReturnStatement(node) {
            if (!funcInfo.shouldCheck) {
              return;
            }
            funcInfo.hasReturn = true;
            let messageId = null;
            if (funcInfo.arrayMethodName === "forEach") {
              if (options.checkForEach && node.argument) {
                messageId = "expectedNoReturnValue";
              }
            } else {
              if (!options.allowImplicit && !node.argument) {
                messageId = "expectedReturnValue";
              }
            }
            if (messageId) {
              context.report({
                node,
                messageId,
                data: {
                  name: astUtils.getFunctionNameWithKind(funcInfo.node),
                  arrayMethodName: fullMethodName(funcInfo.arrayMethodName)
                }
              });
            }
          },
          // Reports a given function if the last path is reachable.
          "FunctionExpression:exit": checkLastSegment,
          "ArrowFunctionExpression:exit": checkLastSegment
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/array-element-newline.js
var require_array_element_newline = __commonJS({
  "../../node_modules/eslint/lib/rules/array-element-newline.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Enforce line breaks after each array element",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/array-element-newline"
        },
        fixable: "whitespace",
        schema: {
          definitions: {
            basicConfig: {
              oneOf: [
                {
                  enum: ["always", "never", "consistent"]
                },
                {
                  type: "object",
                  properties: {
                    multiline: {
                      type: "boolean"
                    },
                    minItems: {
                      type: ["integer", "null"],
                      minimum: 0
                    }
                  },
                  additionalProperties: false
                }
              ]
            }
          },
          type: "array",
          items: [
            {
              oneOf: [
                {
                  $ref: "#/definitions/basicConfig"
                },
                {
                  type: "object",
                  properties: {
                    ArrayExpression: {
                      $ref: "#/definitions/basicConfig"
                    },
                    ArrayPattern: {
                      $ref: "#/definitions/basicConfig"
                    }
                  },
                  additionalProperties: false,
                  minProperties: 1
                }
              ]
            }
          ]
        },
        messages: {
          unexpectedLineBreak: "There should be no linebreak here.",
          missingLineBreak: "There should be a linebreak after this element."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        function normalizeOptionValue(providedOption) {
          let consistent = false;
          let multiline = false;
          let minItems;
          const option = providedOption || "always";
          if (!option || option === "always" || option.minItems === 0) {
            minItems = 0;
          } else if (option === "never") {
            minItems = Number.POSITIVE_INFINITY;
          } else if (option === "consistent") {
            consistent = true;
            minItems = Number.POSITIVE_INFINITY;
          } else {
            multiline = Boolean(option.multiline);
            minItems = option.minItems || Number.POSITIVE_INFINITY;
          }
          return { consistent, multiline, minItems };
        }
        function normalizeOptions(options) {
          if (options && (options.ArrayExpression || options.ArrayPattern)) {
            let expressionOptions, patternOptions;
            if (options.ArrayExpression) {
              expressionOptions = normalizeOptionValue(options.ArrayExpression);
            }
            if (options.ArrayPattern) {
              patternOptions = normalizeOptionValue(options.ArrayPattern);
            }
            return { ArrayExpression: expressionOptions, ArrayPattern: patternOptions };
          }
          const value = normalizeOptionValue(options);
          return { ArrayExpression: value, ArrayPattern: value };
        }
        function reportNoLineBreak(token) {
          const tokenBefore = sourceCode.getTokenBefore(token, { includeComments: true });
          context.report({
            loc: {
              start: tokenBefore.loc.end,
              end: token.loc.start
            },
            messageId: "unexpectedLineBreak",
            fix(fixer) {
              if (astUtils.isCommentToken(tokenBefore)) {
                return null;
              }
              if (!astUtils.isTokenOnSameLine(tokenBefore, token)) {
                return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], " ");
              }
              const twoTokensBefore = sourceCode.getTokenBefore(tokenBefore, { includeComments: true });
              if (astUtils.isCommentToken(twoTokensBefore)) {
                return null;
              }
              return fixer.replaceTextRange([twoTokensBefore.range[1], tokenBefore.range[0]], "");
            }
          });
        }
        function reportRequiredLineBreak(token) {
          const tokenBefore = sourceCode.getTokenBefore(token, { includeComments: true });
          context.report({
            loc: {
              start: tokenBefore.loc.end,
              end: token.loc.start
            },
            messageId: "missingLineBreak",
            fix(fixer) {
              return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], "\n");
            }
          });
        }
        function check(node) {
          const elements = node.elements;
          const normalizedOptions = normalizeOptions(context.options[0]);
          const options = normalizedOptions[node.type];
          if (!options) {
            return;
          }
          let elementBreak = false;
          if (options.multiline) {
            elementBreak = elements.filter((element) => element !== null).some((element) => element.loc.start.line !== element.loc.end.line);
          }
          let linebreaksCount = 0;
          for (let i = 0; i < node.elements.length; i++) {
            const element = node.elements[i];
            const previousElement = elements[i - 1];
            if (i === 0 || element === null || previousElement === null) {
              continue;
            }
            const commaToken = sourceCode.getFirstTokenBetween(previousElement, element, astUtils.isCommaToken);
            const lastTokenOfPreviousElement = sourceCode.getTokenBefore(commaToken);
            const firstTokenOfCurrentElement = sourceCode.getTokenAfter(commaToken);
            if (!astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {
              linebreaksCount++;
            }
          }
          const needsLinebreaks = elements.length >= options.minItems || options.multiline && elementBreak || options.consistent && linebreaksCount > 0 && linebreaksCount < node.elements.length;
          elements.forEach((element, i) => {
            const previousElement = elements[i - 1];
            if (i === 0 || element === null || previousElement === null) {
              return;
            }
            const commaToken = sourceCode.getFirstTokenBetween(previousElement, element, astUtils.isCommaToken);
            const lastTokenOfPreviousElement = sourceCode.getTokenBefore(commaToken);
            const firstTokenOfCurrentElement = sourceCode.getTokenAfter(commaToken);
            if (needsLinebreaks) {
              if (astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {
                reportRequiredLineBreak(firstTokenOfCurrentElement);
              }
            } else {
              if (!astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {
                reportNoLineBreak(firstTokenOfCurrentElement);
              }
            }
          });
        }
        return {
          ArrayPattern: check,
          ArrayExpression: check
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/arrow-body-style.js
var require_arrow_body_style = __commonJS({
  "../../node_modules/eslint/lib/rules/arrow-body-style.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Require braces around arrow function bodies",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/arrow-body-style"
        },
        schema: {
          anyOf: [
            {
              type: "array",
              items: [
                {
                  enum: ["always", "never"]
                }
              ],
              minItems: 0,
              maxItems: 1
            },
            {
              type: "array",
              items: [
                {
                  enum: ["as-needed"]
                },
                {
                  type: "object",
                  properties: {
                    requireReturnForObjectLiteral: { type: "boolean" }
                  },
                  additionalProperties: false
                }
              ],
              minItems: 0,
              maxItems: 2
            }
          ]
        },
        fixable: "code",
        messages: {
          unexpectedOtherBlock: "Unexpected block statement surrounding arrow body.",
          unexpectedEmptyBlock: "Unexpected block statement surrounding arrow body; put a value of `undefined` immediately after the `=>`.",
          unexpectedObjectBlock: "Unexpected block statement surrounding arrow body; parenthesize the returned value and move it immediately after the `=>`.",
          unexpectedSingleBlock: "Unexpected block statement surrounding arrow body; move the returned value immediately after the `=>`.",
          expectedBlock: "Expected block statement surrounding arrow body."
        }
      },
      create(context) {
        const options = context.options;
        const always = options[0] === "always";
        const asNeeded = !options[0] || options[0] === "as-needed";
        const never = options[0] === "never";
        const requireReturnForObjectLiteral = options[1] && options[1].requireReturnForObjectLiteral;
        const sourceCode = context.sourceCode;
        let funcInfo = null;
        function hasASIProblem(token) {
          return token && token.type === "Punctuator" && /^[([/`+-]/u.test(token.value);
        }
        function findClosingParen(node) {
          let nodeToCheck = node;
          while (!astUtils.isParenthesised(sourceCode, nodeToCheck)) {
            nodeToCheck = nodeToCheck.parent;
          }
          return sourceCode.getTokenAfter(nodeToCheck);
        }
        function isInsideForLoopInitializer(node) {
          if (node && node.parent) {
            if (node.parent.type === "ForStatement" && node.parent.init === node) {
              return true;
            }
            return isInsideForLoopInitializer(node.parent);
          }
          return false;
        }
        function validate(node) {
          const arrowBody = node.body;
          if (arrowBody.type === "BlockStatement") {
            const blockBody = arrowBody.body;
            if (blockBody.length !== 1 && !never) {
              return;
            }
            if (asNeeded && requireReturnForObjectLiteral && blockBody[0].type === "ReturnStatement" && blockBody[0].argument && blockBody[0].argument.type === "ObjectExpression") {
              return;
            }
            if (never || asNeeded && blockBody[0].type === "ReturnStatement") {
              let messageId;
              if (blockBody.length === 0) {
                messageId = "unexpectedEmptyBlock";
              } else if (blockBody.length > 1) {
                messageId = "unexpectedOtherBlock";
              } else if (blockBody[0].argument === null) {
                messageId = "unexpectedSingleBlock";
              } else if (astUtils.isOpeningBraceToken(sourceCode.getFirstToken(blockBody[0], { skip: 1 }))) {
                messageId = "unexpectedObjectBlock";
              } else {
                messageId = "unexpectedSingleBlock";
              }
              context.report({
                node,
                loc: arrowBody.loc,
                messageId,
                fix(fixer) {
                  const fixes = [];
                  if (blockBody.length !== 1 || blockBody[0].type !== "ReturnStatement" || !blockBody[0].argument || hasASIProblem(sourceCode.getTokenAfter(arrowBody))) {
                    return fixes;
                  }
                  const openingBrace = sourceCode.getFirstToken(arrowBody);
                  const closingBrace = sourceCode.getLastToken(arrowBody);
                  const firstValueToken = sourceCode.getFirstToken(blockBody[0], 1);
                  const lastValueToken = sourceCode.getLastToken(blockBody[0]);
                  const commentsExist = sourceCode.commentsExistBetween(openingBrace, firstValueToken) || sourceCode.commentsExistBetween(lastValueToken, closingBrace);
                  if (commentsExist) {
                    fixes.push(
                      fixer.remove(openingBrace),
                      fixer.remove(closingBrace),
                      fixer.remove(sourceCode.getTokenAfter(openingBrace))
                      // return keyword
                    );
                  } else {
                    fixes.push(
                      fixer.removeRange([openingBrace.range[0], firstValueToken.range[0]]),
                      fixer.removeRange([lastValueToken.range[1], closingBrace.range[1]])
                    );
                  }
                  if (astUtils.isOpeningBraceToken(firstValueToken) || blockBody[0].argument.type === "SequenceExpression" || funcInfo.hasInOperator && isInsideForLoopInitializer(node)) {
                    if (!astUtils.isParenthesised(sourceCode, blockBody[0].argument)) {
                      fixes.push(
                        fixer.insertTextBefore(firstValueToken, "("),
                        fixer.insertTextAfter(lastValueToken, ")")
                      );
                    }
                  }
                  if (astUtils.isSemicolonToken(lastValueToken)) {
                    fixes.push(fixer.remove(lastValueToken));
                  }
                  return fixes;
                }
              });
            }
          } else {
            if (always || asNeeded && requireReturnForObjectLiteral && arrowBody.type === "ObjectExpression") {
              context.report({
                node,
                loc: arrowBody.loc,
                messageId: "expectedBlock",
                fix(fixer) {
                  const fixes = [];
                  const arrowToken = sourceCode.getTokenBefore(arrowBody, astUtils.isArrowToken);
                  const [firstTokenAfterArrow, secondTokenAfterArrow] = sourceCode.getTokensAfter(arrowToken, { count: 2 });
                  const lastToken = sourceCode.getLastToken(node);
                  let parenthesisedObjectLiteral = null;
                  if (astUtils.isOpeningParenToken(firstTokenAfterArrow) && astUtils.isOpeningBraceToken(secondTokenAfterArrow)) {
                    const braceNode = sourceCode.getNodeByRangeIndex(secondTokenAfterArrow.range[0]);
                    if (braceNode.type === "ObjectExpression") {
                      parenthesisedObjectLiteral = braceNode;
                    }
                  }
                  if (parenthesisedObjectLiteral) {
                    const openingParenToken = firstTokenAfterArrow;
                    const openingBraceToken = secondTokenAfterArrow;
                    if (astUtils.isTokenOnSameLine(openingParenToken, openingBraceToken)) {
                      fixes.push(fixer.replaceText(openingParenToken, "{return "));
                    } else {
                      fixes.push(
                        fixer.replaceText(openingParenToken, "{"),
                        fixer.insertTextBefore(openingBraceToken, "return ")
                      );
                    }
                    fixes.push(fixer.remove(findClosingParen(parenthesisedObjectLiteral)));
                    fixes.push(fixer.insertTextAfter(lastToken, "}"));
                  } else {
                    fixes.push(fixer.insertTextBefore(firstTokenAfterArrow, "{return "));
                    fixes.push(fixer.insertTextAfter(lastToken, "}"));
                  }
                  return fixes;
                }
              });
            }
          }
        }
        return {
          "BinaryExpression[operator='in']"() {
            let info = funcInfo;
            while (info) {
              info.hasInOperator = true;
              info = info.upper;
            }
          },
          ArrowFunctionExpression() {
            funcInfo = {
              upper: funcInfo,
              hasInOperator: false
            };
          },
          "ArrowFunctionExpression:exit"(node) {
            validate(node);
            funcInfo = funcInfo.upper;
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/arrow-parens.js
var require_arrow_parens = __commonJS({
  "../../node_modules/eslint/lib/rules/arrow-parens.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    function hasBlockBody(node) {
      return node.body.type === "BlockStatement";
    }
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Require parentheses around arrow function arguments",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/arrow-parens"
        },
        fixable: "code",
        schema: [
          {
            enum: ["always", "as-needed"]
          },
          {
            type: "object",
            properties: {
              requireForBlockBody: {
                type: "boolean",
                default: false
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          unexpectedParens: "Unexpected parentheses around single function argument.",
          expectedParens: "Expected parentheses around arrow function argument.",
          unexpectedParensInline: "Unexpected parentheses around single function argument having a body with no curly braces.",
          expectedParensBlock: "Expected parentheses around arrow function argument having a body with curly braces."
        }
      },
      create(context) {
        const asNeeded = context.options[0] === "as-needed";
        const requireForBlockBody = asNeeded && context.options[1] && context.options[1].requireForBlockBody === true;
        const sourceCode = context.sourceCode;
        function findOpeningParenOfParams(node) {
          const tokenBeforeParams = sourceCode.getTokenBefore(node.params[0]);
          if (tokenBeforeParams && astUtils.isOpeningParenToken(tokenBeforeParams) && node.range[0] <= tokenBeforeParams.range[0]) {
            return tokenBeforeParams;
          }
          return null;
        }
        function getClosingParenOfParams(node) {
          return sourceCode.getTokenAfter(node.params[0], astUtils.isClosingParenToken);
        }
        function hasCommentsInParensOfParams(node, openingParen) {
          return sourceCode.commentsExistBetween(openingParen, getClosingParenOfParams(node));
        }
        function hasUnexpectedTokensBeforeOpeningParen(node, openingParen) {
          const expectedCount = node.async ? 1 : 0;
          return sourceCode.getFirstToken(node, { skip: expectedCount }) !== openingParen;
        }
        return {
          "ArrowFunctionExpression[params.length=1]"(node) {
            const shouldHaveParens = !asNeeded || requireForBlockBody && hasBlockBody(node);
            const openingParen = findOpeningParenOfParams(node);
            const hasParens = openingParen !== null;
            const [param] = node.params;
            if (shouldHaveParens && !hasParens) {
              context.report({
                node,
                messageId: requireForBlockBody ? "expectedParensBlock" : "expectedParens",
                loc: param.loc,
                *fix(fixer) {
                  yield fixer.insertTextBefore(param, "(");
                  yield fixer.insertTextAfter(param, ")");
                }
              });
            }
            if (!shouldHaveParens && hasParens && param.type === "Identifier" && !param.typeAnnotation && !node.returnType && !hasCommentsInParensOfParams(node, openingParen) && !hasUnexpectedTokensBeforeOpeningParen(node, openingParen)) {
              context.report({
                node,
                messageId: requireForBlockBody ? "unexpectedParensInline" : "unexpectedParens",
                loc: param.loc,
                *fix(fixer) {
                  const tokenBeforeOpeningParen = sourceCode.getTokenBefore(openingParen);
                  const closingParen = getClosingParenOfParams(node);
                  if (tokenBeforeOpeningParen && tokenBeforeOpeningParen.range[1] === openingParen.range[0] && !astUtils.canTokensBeAdjacent(tokenBeforeOpeningParen, sourceCode.getFirstToken(param))) {
                    yield fixer.insertTextBefore(openingParen, " ");
                  }
                  yield fixer.removeRange([openingParen.range[0], param.range[0]]);
                  yield fixer.removeRange([param.range[1], closingParen.range[1]]);
                }
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/arrow-spacing.js
var require_arrow_spacing = __commonJS({
  "../../node_modules/eslint/lib/rules/arrow-spacing.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Enforce consistent spacing before and after the arrow in arrow functions",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/arrow-spacing"
        },
        fixable: "whitespace",
        schema: [
          {
            type: "object",
            properties: {
              before: {
                type: "boolean",
                default: true
              },
              after: {
                type: "boolean",
                default: true
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          expectedBefore: "Missing space before =>.",
          unexpectedBefore: "Unexpected space before =>.",
          expectedAfter: "Missing space after =>.",
          unexpectedAfter: "Unexpected space after =>."
        }
      },
      create(context) {
        const rule = Object.assign({}, context.options[0]);
        rule.before = rule.before !== false;
        rule.after = rule.after !== false;
        const sourceCode = context.sourceCode;
        function getTokens(node) {
          const arrow = sourceCode.getTokenBefore(node.body, astUtils.isArrowToken);
          return {
            before: sourceCode.getTokenBefore(arrow),
            arrow,
            after: sourceCode.getTokenAfter(arrow)
          };
        }
        function countSpaces(tokens) {
          const before = tokens.arrow.range[0] - tokens.before.range[1];
          const after = tokens.after.range[0] - tokens.arrow.range[1];
          return { before, after };
        }
        function spaces(node) {
          const tokens = getTokens(node);
          const countSpace = countSpaces(tokens);
          if (rule.before) {
            if (countSpace.before === 0) {
              context.report({
                node: tokens.before,
                messageId: "expectedBefore",
                fix(fixer) {
                  return fixer.insertTextBefore(tokens.arrow, " ");
                }
              });
            }
          } else {
            if (countSpace.before > 0) {
              context.report({
                node: tokens.before,
                messageId: "unexpectedBefore",
                fix(fixer) {
                  return fixer.removeRange([tokens.before.range[1], tokens.arrow.range[0]]);
                }
              });
            }
          }
          if (rule.after) {
            if (countSpace.after === 0) {
              context.report({
                node: tokens.after,
                messageId: "expectedAfter",
                fix(fixer) {
                  return fixer.insertTextAfter(tokens.arrow, " ");
                }
              });
            }
          } else {
            if (countSpace.after > 0) {
              context.report({
                node: tokens.after,
                messageId: "unexpectedAfter",
                fix(fixer) {
                  return fixer.removeRange([tokens.arrow.range[1], tokens.after.range[0]]);
                }
              });
            }
          }
        }
        return {
          ArrowFunctionExpression: spaces
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/block-scoped-var.js
var require_block_scoped_var = __commonJS({
  "../../node_modules/eslint/lib/rules/block-scoped-var.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Enforce the use of variables within the scope they are defined",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/block-scoped-var"
        },
        schema: [],
        messages: {
          outOfScope: "'{{name}}' declared on line {{definitionLine}} column {{definitionColumn}} is used outside of binding context."
        }
      },
      create(context) {
        let stack = [];
        const sourceCode = context.sourceCode;
        function enterScope(node) {
          stack.push(node.range);
        }
        function exitScope() {
          stack.pop();
        }
        function report(reference, definition) {
          const identifier = reference.identifier;
          const definitionPosition = definition.name.loc.start;
          context.report({
            node: identifier,
            messageId: "outOfScope",
            data: {
              name: identifier.name,
              definitionLine: definitionPosition.line,
              definitionColumn: definitionPosition.column + 1
            }
          });
        }
        function checkForVariables(node) {
          if (node.kind !== "var") {
            return;
          }
          const scopeRange = stack[stack.length - 1];
          function isOutsideOfScope(reference) {
            const idRange = reference.identifier.range;
            return idRange[0] < scopeRange[0] || idRange[1] > scopeRange[1];
          }
          const variables = sourceCode.getDeclaredVariables(node);
          for (let i = 0; i < variables.length; ++i) {
            variables[i].references.filter(isOutsideOfScope).forEach((ref) => report(ref, variables[i].defs.find((def) => def.parent === node)));
          }
        }
        return {
          Program(node) {
            stack = [node.range];
          },
          // Manages scopes.
          BlockStatement: enterScope,
          "BlockStatement:exit": exitScope,
          ForStatement: enterScope,
          "ForStatement:exit": exitScope,
          ForInStatement: enterScope,
          "ForInStatement:exit": exitScope,
          ForOfStatement: enterScope,
          "ForOfStatement:exit": exitScope,
          SwitchStatement: enterScope,
          "SwitchStatement:exit": exitScope,
          CatchClause: enterScope,
          "CatchClause:exit": exitScope,
          StaticBlock: enterScope,
          "StaticBlock:exit": exitScope,
          // Finds and reports references which are outside of valid scope.
          VariableDeclaration: checkForVariables
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/block-spacing.js
var require_block_spacing = __commonJS({
  "../../node_modules/eslint/lib/rules/block-spacing.js"(exports, module) {
    "use strict";
    var util = require_ast_utils2();
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Disallow or enforce spaces inside of blocks after opening block and before closing block",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/block-spacing"
        },
        fixable: "whitespace",
        schema: [
          { enum: ["always", "never"] }
        ],
        messages: {
          missing: "Requires a space {{location}} '{{token}}'.",
          extra: "Unexpected space(s) {{location}} '{{token}}'."
        }
      },
      create(context) {
        const always = context.options[0] !== "never", messageId = always ? "missing" : "extra", sourceCode = context.sourceCode;
        function getOpenBrace(node) {
          if (node.type === "SwitchStatement") {
            if (node.cases.length > 0) {
              return sourceCode.getTokenBefore(node.cases[0]);
            }
            return sourceCode.getLastToken(node, 1);
          }
          if (node.type === "StaticBlock") {
            return sourceCode.getFirstToken(node, { skip: 1 });
          }
          return sourceCode.getFirstToken(node);
        }
        function isValid(left, right) {
          return !util.isTokenOnSameLine(left, right) || sourceCode.isSpaceBetweenTokens(left, right) === always;
        }
        function checkSpacingInsideBraces(node) {
          const openBrace = getOpenBrace(node);
          const closeBrace = sourceCode.getLastToken(node);
          const firstToken = sourceCode.getTokenAfter(openBrace, { includeComments: true });
          const lastToken = sourceCode.getTokenBefore(closeBrace, { includeComments: true });
          if (openBrace.type !== "Punctuator" || openBrace.value !== "{" || closeBrace.type !== "Punctuator" || closeBrace.value !== "}" || firstToken === closeBrace) {
            return;
          }
          if (!always && firstToken.type === "Line") {
            return;
          }
          if (!isValid(openBrace, firstToken)) {
            let loc = openBrace.loc;
            if (messageId === "extra") {
              loc = {
                start: openBrace.loc.end,
                end: firstToken.loc.start
              };
            }
            context.report({
              node,
              loc,
              messageId,
              data: {
                location: "after",
                token: openBrace.value
              },
              fix(fixer) {
                if (always) {
                  return fixer.insertTextBefore(firstToken, " ");
                }
                return fixer.removeRange([openBrace.range[1], firstToken.range[0]]);
              }
            });
          }
          if (!isValid(lastToken, closeBrace)) {
            let loc = closeBrace.loc;
            if (messageId === "extra") {
              loc = {
                start: lastToken.loc.end,
                end: closeBrace.loc.start
              };
            }
            context.report({
              node,
              loc,
              messageId,
              data: {
                location: "before",
                token: closeBrace.value
              },
              fix(fixer) {
                if (always) {
                  return fixer.insertTextAfter(lastToken, " ");
                }
                return fixer.removeRange([lastToken.range[1], closeBrace.range[0]]);
              }
            });
          }
        }
        return {
          BlockStatement: checkSpacingInsideBraces,
          StaticBlock: checkSpacingInsideBraces,
          SwitchStatement: checkSpacingInsideBraces
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/brace-style.js
var require_brace_style = __commonJS({
  "../../node_modules/eslint/lib/rules/brace-style.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Enforce consistent brace style for blocks",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/brace-style"
        },
        schema: [
          {
            enum: ["1tbs", "stroustrup", "allman"]
          },
          {
            type: "object",
            properties: {
              allowSingleLine: {
                type: "boolean",
                default: false
              }
            },
            additionalProperties: false
          }
        ],
        fixable: "whitespace",
        messages: {
          nextLineOpen: "Opening curly brace does not appear on the same line as controlling statement.",
          sameLineOpen: "Opening curly brace appears on the same line as controlling statement.",
          blockSameLine: "Statement inside of curly braces should be on next line.",
          nextLineClose: "Closing curly brace does not appear on the same line as the subsequent block.",
          singleLineClose: "Closing curly brace should be on the same line as opening curly brace or on the line after the previous block.",
          sameLineClose: "Closing curly brace appears on the same line as the subsequent block."
        }
      },
      create(context) {
        const style = context.options[0] || "1tbs", params = context.options[1] || {}, sourceCode = context.sourceCode;
        function removeNewlineBetween(firstToken, secondToken) {
          const textRange = [firstToken.range[1], secondToken.range[0]];
          const textBetween = sourceCode.text.slice(textRange[0], textRange[1]);
          if (textBetween.trim()) {
            return null;
          }
          return (fixer) => fixer.replaceTextRange(textRange, " ");
        }
        function validateCurlyPair(openingCurly, closingCurly) {
          const tokenBeforeOpeningCurly = sourceCode.getTokenBefore(openingCurly);
          const tokenAfterOpeningCurly = sourceCode.getTokenAfter(openingCurly);
          const tokenBeforeClosingCurly = sourceCode.getTokenBefore(closingCurly);
          const singleLineException = params.allowSingleLine && astUtils.isTokenOnSameLine(openingCurly, closingCurly);
          if (style !== "allman" && !astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly)) {
            context.report({
              node: openingCurly,
              messageId: "nextLineOpen",
              fix: removeNewlineBetween(tokenBeforeOpeningCurly, openingCurly)
            });
          }
          if (style === "allman" && astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly) && !singleLineException) {
            context.report({
              node: openingCurly,
              messageId: "sameLineOpen",
              fix: (fixer) => fixer.insertTextBefore(openingCurly, "\n")
            });
          }
          if (astUtils.isTokenOnSameLine(openingCurly, tokenAfterOpeningCurly) && tokenAfterOpeningCurly !== closingCurly && !singleLineException) {
            context.report({
              node: openingCurly,
              messageId: "blockSameLine",
              fix: (fixer) => fixer.insertTextAfter(openingCurly, "\n")
            });
          }
          if (tokenBeforeClosingCurly !== openingCurly && !singleLineException && astUtils.isTokenOnSameLine(tokenBeforeClosingCurly, closingCurly)) {
            context.report({
              node: closingCurly,
              messageId: "singleLineClose",
              fix: (fixer) => fixer.insertTextBefore(closingCurly, "\n")
            });
          }
        }
        function validateCurlyBeforeKeyword(curlyToken) {
          const keywordToken = sourceCode.getTokenAfter(curlyToken);
          if (style === "1tbs" && !astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {
            context.report({
              node: curlyToken,
              messageId: "nextLineClose",
              fix: removeNewlineBetween(curlyToken, keywordToken)
            });
          }
          if (style !== "1tbs" && astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {
            context.report({
              node: curlyToken,
              messageId: "sameLineClose",
              fix: (fixer) => fixer.insertTextAfter(curlyToken, "\n")
            });
          }
        }
        return {
          BlockStatement(node) {
            if (!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {
              validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));
            }
          },
          StaticBlock(node) {
            validateCurlyPair(
              sourceCode.getFirstToken(node, { skip: 1 }),
              // skip the `static` token
              sourceCode.getLastToken(node)
            );
          },
          ClassBody(node) {
            validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));
          },
          SwitchStatement(node) {
            const closingCurly = sourceCode.getLastToken(node);
            const openingCurly = sourceCode.getTokenBefore(node.cases.length ? node.cases[0] : closingCurly);
            validateCurlyPair(openingCurly, closingCurly);
          },
          IfStatement(node) {
            if (node.consequent.type === "BlockStatement" && node.alternate) {
              validateCurlyBeforeKeyword(sourceCode.getLastToken(node.consequent));
            }
          },
          TryStatement(node) {
            validateCurlyBeforeKeyword(sourceCode.getLastToken(node.block));
            if (node.handler && node.finalizer) {
              validateCurlyBeforeKeyword(sourceCode.getLastToken(node.handler.body));
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/callback-return.js
var require_callback_return = __commonJS({
  "../../node_modules/eslint/lib/rules/callback-return.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        deprecated: true,
        replacedBy: [],
        type: "suggestion",
        docs: {
          description: "Require `return` statements after callbacks",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/callback-return"
        },
        schema: [{
          type: "array",
          items: { type: "string" }
        }],
        messages: {
          missingReturn: "Expected return with your callback function."
        }
      },
      create(context) {
        const callbacks = context.options[0] || ["callback", "cb", "next"], sourceCode = context.sourceCode;
        function findClosestParentOfType(node, types) {
          if (!node.parent) {
            return null;
          }
          if (!types.includes(node.parent.type)) {
            return findClosestParentOfType(node.parent, types);
          }
          return node.parent;
        }
        function containsOnlyIdentifiers(node) {
          if (node.type === "Identifier") {
            return true;
          }
          if (node.type === "MemberExpression") {
            if (node.object.type === "Identifier") {
              return true;
            }
            if (node.object.type === "MemberExpression") {
              return containsOnlyIdentifiers(node.object);
            }
          }
          return false;
        }
        function isCallback(node) {
          return containsOnlyIdentifiers(node.callee) && callbacks.includes(sourceCode.getText(node.callee));
        }
        function isCallbackExpression(node, parentNode) {
          if (!parentNode || parentNode.type !== "ExpressionStatement") {
            return false;
          }
          if (parentNode.expression === node) {
            return true;
          }
          if (parentNode.expression.type === "BinaryExpression" || parentNode.expression.type === "LogicalExpression") {
            if (parentNode.expression.right === node) {
              return true;
            }
          }
          return false;
        }
        return {
          CallExpression(node) {
            if (!isCallback(node)) {
              return;
            }
            const closestBlock = findClosestParentOfType(node, ["BlockStatement", "ReturnStatement", "ArrowFunctionExpression"]) || {};
            if (closestBlock.type === "ReturnStatement") {
              return;
            }
            if (closestBlock.type === "ArrowFunctionExpression") {
              return;
            }
            if (closestBlock.type === "BlockStatement") {
              const lastItem = closestBlock.body[closestBlock.body.length - 1];
              if (isCallbackExpression(node, lastItem)) {
                const parentType = closestBlock.parent.type;
                if (parentType === "FunctionExpression" || parentType === "FunctionDeclaration" || parentType === "ArrowFunctionExpression") {
                  return;
                }
              }
              if (lastItem.type === "ReturnStatement") {
                if (isCallbackExpression(node, closestBlock.body[closestBlock.body.length - 2])) {
                  return;
                }
              }
            }
            if (findClosestParentOfType(node, ["FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"])) {
              context.report({ node, messageId: "missingReturn" });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/camelcase.js
var require_camelcase = __commonJS({
  "../../node_modules/eslint/lib/rules/camelcase.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Enforce camelcase naming convention",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/camelcase"
        },
        schema: [
          {
            type: "object",
            properties: {
              ignoreDestructuring: {
                type: "boolean",
                default: false
              },
              ignoreImports: {
                type: "boolean",
                default: false
              },
              ignoreGlobals: {
                type: "boolean",
                default: false
              },
              properties: {
                enum: ["always", "never"]
              },
              allow: {
                type: "array",
                items: [
                  {
                    type: "string"
                  }
                ],
                minItems: 0,
                uniqueItems: true
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          notCamelCase: "Identifier '{{name}}' is not in camel case.",
          notCamelCasePrivate: "#{{name}} is not in camel case."
        }
      },
      create(context) {
        const options = context.options[0] || {};
        const properties = options.properties === "never" ? "never" : "always";
        const ignoreDestructuring = options.ignoreDestructuring;
        const ignoreImports = options.ignoreImports;
        const ignoreGlobals = options.ignoreGlobals;
        const allow = options.allow || [];
        const sourceCode = context.sourceCode;
        const reported = /* @__PURE__ */ new Set();
        function isUnderscored(name) {
          const nameBody = name.replace(/^_+|_+$/gu, "");
          return nameBody.includes("_") && nameBody !== nameBody.toUpperCase();
        }
        function isAllowed(name) {
          return allow.some(
            (entry) => name === entry || name.match(new RegExp(entry, "u"))
          );
        }
        function isGoodName(name) {
          return !isUnderscored(name) || isAllowed(name);
        }
        function isAssignmentTarget(node) {
          const parent = node.parent;
          switch (parent.type) {
            case "AssignmentExpression":
            case "AssignmentPattern":
              return parent.left === node;
            case "Property":
              return parent.parent.type === "ObjectPattern" && parent.value === node;
            case "ArrayPattern":
            case "RestElement":
              return true;
            default:
              return false;
          }
        }
        function equalsToOriginalName(node) {
          const localName = node.name;
          const valueNode = node.parent.type === "AssignmentPattern" ? node.parent : node;
          const parent = valueNode.parent;
          switch (parent.type) {
            case "Property":
              return (parent.parent.type === "ObjectPattern" || parent.parent.type === "ObjectExpression") && parent.value === valueNode && !parent.computed && parent.key.type === "Identifier" && parent.key.name === localName;
            case "ImportSpecifier":
              return parent.local === node && astUtils.getModuleExportName(parent.imported) === localName;
            default:
              return false;
          }
        }
        function report(node) {
          if (reported.has(node.range[0])) {
            return;
          }
          reported.add(node.range[0]);
          context.report({
            node,
            messageId: node.type === "PrivateIdentifier" ? "notCamelCasePrivate" : "notCamelCase",
            data: { name: node.name }
          });
        }
        function reportReferenceId(node) {
          if (node.parent.type === "CallExpression" || node.parent.type === "NewExpression") {
            return;
          }
          if (node.parent.type === "AssignmentPattern" && node.parent.right === node) {
            return;
          }
          if (ignoreDestructuring && equalsToOriginalName(node)) {
            return;
          }
          report(node);
        }
        return {
          // Report camelcase of global variable references ------------------
          Program(node) {
            const scope = sourceCode.getScope(node);
            if (!ignoreGlobals) {
              for (const variable of scope.variables) {
                if (variable.identifiers.length > 0 || isGoodName(variable.name)) {
                  continue;
                }
                for (const reference of variable.references) {
                  reportReferenceId(reference.identifier);
                }
              }
            }
            for (const reference of scope.through) {
              const id = reference.identifier;
              if (isGoodName(id.name)) {
                continue;
              }
              reportReferenceId(id);
            }
          },
          // Report camelcase of declared variables --------------------------
          [[
            "VariableDeclaration",
            "FunctionDeclaration",
            "FunctionExpression",
            "ArrowFunctionExpression",
            "ClassDeclaration",
            "ClassExpression",
            "CatchClause"
          ]](node) {
            for (const variable of sourceCode.getDeclaredVariables(node)) {
              if (isGoodName(variable.name)) {
                continue;
              }
              const id = variable.identifiers[0];
              if (!(ignoreDestructuring && equalsToOriginalName(id))) {
                report(id);
              }
              for (const reference of variable.references) {
                if (reference.init) {
                  continue;
                }
                reportReferenceId(reference.identifier);
              }
            }
          },
          // Report camelcase in properties ----------------------------------
          [[
            "ObjectExpression > Property[computed!=true] > Identifier.key",
            "MethodDefinition[computed!=true] > Identifier.key",
            "PropertyDefinition[computed!=true] > Identifier.key",
            "MethodDefinition > PrivateIdentifier.key",
            "PropertyDefinition > PrivateIdentifier.key"
          ]](node) {
            if (properties === "never" || isGoodName(node.name)) {
              return;
            }
            report(node);
          },
          "MemberExpression[computed!=true] > Identifier.property"(node) {
            if (properties === "never" || !isAssignmentTarget(node.parent) || //  ignore read-only references.
            isGoodName(node.name)) {
              return;
            }
            report(node);
          },
          // Report camelcase in import --------------------------------------
          ImportDeclaration(node) {
            for (const variable of sourceCode.getDeclaredVariables(node)) {
              if (isGoodName(variable.name)) {
                continue;
              }
              const id = variable.identifiers[0];
              if (!(ignoreImports && equalsToOriginalName(id))) {
                report(id);
              }
              for (const reference of variable.references) {
                reportReferenceId(reference.identifier);
              }
            }
          },
          // Report camelcase in re-export -----------------------------------
          [[
            "ExportAllDeclaration > Identifier.exported",
            "ExportSpecifier > Identifier.exported"
          ]](node) {
            if (isGoodName(node.name)) {
              return;
            }
            report(node);
          },
          // Report camelcase in labels --------------------------------------
          [[
            "LabeledStatement > Identifier.label",
            /*
             * For backward compatibility, report references as well.
             * It looks unnecessary because declarations are reported.
             */
            "BreakStatement > Identifier.label",
            "ContinueStatement > Identifier.label"
          ]](node) {
            if (isGoodName(node.name)) {
              return;
            }
            report(node);
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/utils/patterns/letters.js
var require_letters = __commonJS({
  "../../node_modules/eslint/lib/rules/utils/patterns/letters.js"(exports, module) {
    "use strict";
    module.exports = /[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/u;
  }
});

// ../../node_modules/eslint/lib/rules/capitalized-comments.js
var require_capitalized_comments = __commonJS({
  "../../node_modules/eslint/lib/rules/capitalized-comments.js"(exports, module) {
    "use strict";
    var LETTER_PATTERN = require_letters();
    var astUtils = require_ast_utils2();
    var DEFAULT_IGNORE_PATTERN = astUtils.COMMENTS_IGNORE_PATTERN;
    var WHITESPACE = /\s/gu;
    var MAYBE_URL = /^\s*[^:/?#\s]+:\/\/[^?#]/u;
    var SCHEMA_BODY = {
      type: "object",
      properties: {
        ignorePattern: {
          type: "string"
        },
        ignoreInlineComments: {
          type: "boolean"
        },
        ignoreConsecutiveComments: {
          type: "boolean"
        }
      },
      additionalProperties: false
    };
    var DEFAULTS = {
      ignorePattern: "",
      ignoreInlineComments: false,
      ignoreConsecutiveComments: false
    };
    function getNormalizedOptions(rawOptions, which) {
      return Object.assign({}, DEFAULTS, rawOptions[which] || rawOptions);
    }
    function getAllNormalizedOptions(rawOptions = {}) {
      return {
        Line: getNormalizedOptions(rawOptions, "line"),
        Block: getNormalizedOptions(rawOptions, "block")
      };
    }
    function createRegExpForIgnorePatterns(normalizedOptions) {
      Object.keys(normalizedOptions).forEach((key) => {
        const ignorePatternStr = normalizedOptions[key].ignorePattern;
        if (ignorePatternStr) {
          const regExp = RegExp(`^\\s*(?:${ignorePatternStr})`, "u");
          normalizedOptions[key].ignorePatternRegExp = regExp;
        }
      });
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Enforce or disallow capitalization of the first letter of a comment",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/capitalized-comments"
        },
        fixable: "code",
        schema: [
          { enum: ["always", "never"] },
          {
            oneOf: [
              SCHEMA_BODY,
              {
                type: "object",
                properties: {
                  line: SCHEMA_BODY,
                  block: SCHEMA_BODY
                },
                additionalProperties: false
              }
            ]
          }
        ],
        messages: {
          unexpectedLowercaseComment: "Comments should not begin with a lowercase character.",
          unexpectedUppercaseComment: "Comments should not begin with an uppercase character."
        }
      },
      create(context) {
        const capitalize = context.options[0] || "always", normalizedOptions = getAllNormalizedOptions(context.options[1]), sourceCode = context.sourceCode;
        createRegExpForIgnorePatterns(normalizedOptions);
        function isInlineComment(comment) {
          const previousToken = sourceCode.getTokenBefore(comment, { includeComments: true }), nextToken = sourceCode.getTokenAfter(comment, { includeComments: true });
          return Boolean(
            previousToken && nextToken && comment.loc.start.line === previousToken.loc.end.line && comment.loc.end.line === nextToken.loc.start.line
          );
        }
        function isConsecutiveComment(comment) {
          const previousTokenOrComment = sourceCode.getTokenBefore(comment, { includeComments: true });
          return Boolean(
            previousTokenOrComment && ["Block", "Line"].includes(previousTokenOrComment.type)
          );
        }
        function isCommentValid(comment, options) {
          if (DEFAULT_IGNORE_PATTERN.test(comment.value)) {
            return true;
          }
          const commentWithoutAsterisks = comment.value.replace(/\*/gu, "");
          if (options.ignorePatternRegExp && options.ignorePatternRegExp.test(commentWithoutAsterisks)) {
            return true;
          }
          if (options.ignoreInlineComments && isInlineComment(comment)) {
            return true;
          }
          if (options.ignoreConsecutiveComments && isConsecutiveComment(comment)) {
            return true;
          }
          if (MAYBE_URL.test(commentWithoutAsterisks)) {
            return true;
          }
          const commentWordCharsOnly = commentWithoutAsterisks.replace(WHITESPACE, "");
          if (commentWordCharsOnly.length === 0) {
            return true;
          }
          const firstWordChar = commentWordCharsOnly[0];
          if (!LETTER_PATTERN.test(firstWordChar)) {
            return true;
          }
          const isUppercase = firstWordChar !== firstWordChar.toLocaleLowerCase(), isLowercase = firstWordChar !== firstWordChar.toLocaleUpperCase();
          if (capitalize === "always" && isLowercase) {
            return false;
          }
          if (capitalize === "never" && isUppercase) {
            return false;
          }
          return true;
        }
        function processComment(comment) {
          const options = normalizedOptions[comment.type], commentValid = isCommentValid(comment, options);
          if (!commentValid) {
            const messageId = capitalize === "always" ? "unexpectedLowercaseComment" : "unexpectedUppercaseComment";
            context.report({
              node: null,
              // Intentionally using loc instead
              loc: comment.loc,
              messageId,
              fix(fixer) {
                const match = comment.value.match(LETTER_PATTERN);
                return fixer.replaceTextRange(
                  // Offset match.index by 2 to account for the first 2 characters that start the comment (// or /*)
                  [comment.range[0] + match.index + 2, comment.range[0] + match.index + 3],
                  capitalize === "always" ? match[0].toLocaleUpperCase() : match[0].toLocaleLowerCase()
                );
              }
            });
          }
        }
        return {
          Program() {
            const comments = sourceCode.getAllComments();
            comments.filter((token) => token.type !== "Shebang").forEach(processComment);
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/class-methods-use-this.js
var require_class_methods_use_this = __commonJS({
  "../../node_modules/eslint/lib/rules/class-methods-use-this.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Enforce that class methods utilize `this`",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/class-methods-use-this"
        },
        schema: [{
          type: "object",
          properties: {
            exceptMethods: {
              type: "array",
              items: {
                type: "string"
              }
            },
            enforceForClassFields: {
              type: "boolean",
              default: true
            }
          },
          additionalProperties: false
        }],
        messages: {
          missingThis: "Expected 'this' to be used by class {{name}}."
        }
      },
      create(context) {
        const config = Object.assign({}, context.options[0]);
        const enforceForClassFields = config.enforceForClassFields !== false;
        const exceptMethods = new Set(config.exceptMethods || []);
        const stack = [];
        function pushContext() {
          stack.push(false);
        }
        function popContext() {
          return stack.pop();
        }
        function enterFunction() {
          pushContext();
        }
        function isInstanceMethod(node) {
          switch (node.type) {
            case "MethodDefinition":
              return !node.static && node.kind !== "constructor";
            case "PropertyDefinition":
              return !node.static && enforceForClassFields;
            default:
              return false;
          }
        }
        function isIncludedInstanceMethod(node) {
          if (isInstanceMethod(node)) {
            if (node.computed) {
              return true;
            }
            const hashIfNeeded = node.key.type === "PrivateIdentifier" ? "#" : "";
            const name = node.key.type === "Literal" ? astUtils.getStaticStringValue(node.key) : node.key.name || "";
            return !exceptMethods.has(hashIfNeeded + name);
          }
          return false;
        }
        function exitFunction(node) {
          const methodUsesThis = popContext();
          if (isIncludedInstanceMethod(node.parent) && !methodUsesThis) {
            context.report({
              node,
              loc: astUtils.getFunctionHeadLoc(node, context.sourceCode),
              messageId: "missingThis",
              data: {
                name: astUtils.getFunctionNameWithKind(node)
              }
            });
          }
        }
        function markThisUsed() {
          if (stack.length) {
            stack[stack.length - 1] = true;
          }
        }
        return {
          FunctionDeclaration: enterFunction,
          "FunctionDeclaration:exit": exitFunction,
          FunctionExpression: enterFunction,
          "FunctionExpression:exit": exitFunction,
          /*
           * Class field value are implicit functions.
           */
          "PropertyDefinition > *.key:exit": pushContext,
          "PropertyDefinition:exit": popContext,
          /*
           * Class static blocks are implicit functions. They aren't required to use `this`,
           * but we have to push context so that it captures any use of `this` in the static block
           * separately from enclosing contexts, because static blocks have their own `this` and it
           * shouldn't count as used `this` in enclosing contexts.
           */
          StaticBlock: pushContext,
          "StaticBlock:exit": popContext,
          ThisExpression: markThisUsed,
          Super: markThisUsed,
          ...enforceForClassFields && {
            "PropertyDefinition > ArrowFunctionExpression.value": enterFunction,
            "PropertyDefinition > ArrowFunctionExpression.value:exit": exitFunction
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/comma-dangle.js
var require_comma_dangle = __commonJS({
  "../../node_modules/eslint/lib/rules/comma-dangle.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var DEFAULT_OPTIONS = Object.freeze({
      arrays: "never",
      objects: "never",
      imports: "never",
      exports: "never",
      functions: "never"
    });
    function isTrailingCommaAllowed(lastItem) {
      return !(lastItem.type === "RestElement" || lastItem.type === "RestProperty" || lastItem.type === "ExperimentalRestProperty");
    }
    function normalizeOptions(optionValue, ecmaVersion) {
      if (typeof optionValue === "string") {
        return {
          arrays: optionValue,
          objects: optionValue,
          imports: optionValue,
          exports: optionValue,
          functions: ecmaVersion < 2017 ? "ignore" : optionValue
        };
      }
      if (typeof optionValue === "object" && optionValue !== null) {
        return {
          arrays: optionValue.arrays || DEFAULT_OPTIONS.arrays,
          objects: optionValue.objects || DEFAULT_OPTIONS.objects,
          imports: optionValue.imports || DEFAULT_OPTIONS.imports,
          exports: optionValue.exports || DEFAULT_OPTIONS.exports,
          functions: optionValue.functions || DEFAULT_OPTIONS.functions
        };
      }
      return DEFAULT_OPTIONS;
    }
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Require or disallow trailing commas",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/comma-dangle"
        },
        fixable: "code",
        schema: {
          definitions: {
            value: {
              enum: [
                "always-multiline",
                "always",
                "never",
                "only-multiline"
              ]
            },
            valueWithIgnore: {
              enum: [
                "always-multiline",
                "always",
                "ignore",
                "never",
                "only-multiline"
              ]
            }
          },
          type: "array",
          items: [
            {
              oneOf: [
                {
                  $ref: "#/definitions/value"
                },
                {
                  type: "object",
                  properties: {
                    arrays: { $ref: "#/definitions/valueWithIgnore" },
                    objects: { $ref: "#/definitions/valueWithIgnore" },
                    imports: { $ref: "#/definitions/valueWithIgnore" },
                    exports: { $ref: "#/definitions/valueWithIgnore" },
                    functions: { $ref: "#/definitions/valueWithIgnore" }
                  },
                  additionalProperties: false
                }
              ]
            }
          ],
          additionalItems: false
        },
        messages: {
          unexpected: "Unexpected trailing comma.",
          missing: "Missing trailing comma."
        }
      },
      create(context) {
        const options = normalizeOptions(context.options[0], context.languageOptions.ecmaVersion);
        const sourceCode = context.sourceCode;
        function getLastItem(node) {
          function last(array) {
            return array[array.length - 1];
          }
          switch (node.type) {
            case "ObjectExpression":
            case "ObjectPattern":
              return last(node.properties);
            case "ArrayExpression":
            case "ArrayPattern":
              return last(node.elements);
            case "ImportDeclaration":
            case "ExportNamedDeclaration":
              return last(node.specifiers);
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
              return last(node.params);
            case "CallExpression":
            case "NewExpression":
              return last(node.arguments);
            default:
              return null;
          }
        }
        function getTrailingToken(node, lastItem) {
          switch (node.type) {
            case "ObjectExpression":
            case "ArrayExpression":
            case "CallExpression":
            case "NewExpression":
              return sourceCode.getLastToken(node, 1);
            default: {
              const nextToken = sourceCode.getTokenAfter(lastItem);
              if (astUtils.isCommaToken(nextToken)) {
                return nextToken;
              }
              return sourceCode.getLastToken(lastItem);
            }
          }
        }
        function isMultiline(node) {
          const lastItem = getLastItem(node);
          if (!lastItem) {
            return false;
          }
          const penultimateToken = getTrailingToken(node, lastItem);
          const lastToken = sourceCode.getTokenAfter(penultimateToken);
          return lastToken.loc.end.line !== penultimateToken.loc.end.line;
        }
        function forbidTrailingComma(node) {
          const lastItem = getLastItem(node);
          if (!lastItem || node.type === "ImportDeclaration" && lastItem.type !== "ImportSpecifier") {
            return;
          }
          const trailingToken = getTrailingToken(node, lastItem);
          if (astUtils.isCommaToken(trailingToken)) {
            context.report({
              node: lastItem,
              loc: trailingToken.loc,
              messageId: "unexpected",
              *fix(fixer) {
                yield fixer.remove(trailingToken);
                yield fixer.insertTextBefore(sourceCode.getTokenBefore(trailingToken), "");
                yield fixer.insertTextAfter(sourceCode.getTokenAfter(trailingToken), "");
              }
            });
          }
        }
        function forceTrailingComma(node) {
          const lastItem = getLastItem(node);
          if (!lastItem || node.type === "ImportDeclaration" && lastItem.type !== "ImportSpecifier") {
            return;
          }
          if (!isTrailingCommaAllowed(lastItem)) {
            forbidTrailingComma(node);
            return;
          }
          const trailingToken = getTrailingToken(node, lastItem);
          if (trailingToken.value !== ",") {
            context.report({
              node: lastItem,
              loc: {
                start: trailingToken.loc.end,
                end: astUtils.getNextLocation(sourceCode, trailingToken.loc.end)
              },
              messageId: "missing",
              *fix(fixer) {
                yield fixer.insertTextAfter(trailingToken, ",");
                yield fixer.insertTextBefore(trailingToken, "");
                yield fixer.insertTextAfter(sourceCode.getTokenAfter(trailingToken), "");
              }
            });
          }
        }
        function forceTrailingCommaIfMultiline(node) {
          if (isMultiline(node)) {
            forceTrailingComma(node);
          } else {
            forbidTrailingComma(node);
          }
        }
        function allowTrailingCommaIfMultiline(node) {
          if (!isMultiline(node)) {
            forbidTrailingComma(node);
          }
        }
        const predicate = {
          always: forceTrailingComma,
          "always-multiline": forceTrailingCommaIfMultiline,
          "only-multiline": allowTrailingCommaIfMultiline,
          never: forbidTrailingComma,
          ignore() {
          }
        };
        return {
          ObjectExpression: predicate[options.objects],
          ObjectPattern: predicate[options.objects],
          ArrayExpression: predicate[options.arrays],
          ArrayPattern: predicate[options.arrays],
          ImportDeclaration: predicate[options.imports],
          ExportNamedDeclaration: predicate[options.exports],
          FunctionDeclaration: predicate[options.functions],
          FunctionExpression: predicate[options.functions],
          ArrowFunctionExpression: predicate[options.functions],
          CallExpression: predicate[options.functions],
          NewExpression: predicate[options.functions]
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/comma-spacing.js
var require_comma_spacing = __commonJS({
  "../../node_modules/eslint/lib/rules/comma-spacing.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Enforce consistent spacing before and after commas",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/comma-spacing"
        },
        fixable: "whitespace",
        schema: [
          {
            type: "object",
            properties: {
              before: {
                type: "boolean",
                default: false
              },
              after: {
                type: "boolean",
                default: true
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          missing: "A space is required {{loc}} ','.",
          unexpected: "There should be no space {{loc}} ','."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        const tokensAndComments = sourceCode.tokensAndComments;
        const options = {
          before: context.options[0] ? context.options[0].before : false,
          after: context.options[0] ? context.options[0].after : true
        };
        const commaTokensToIgnore = [];
        function report(node, loc, otherNode) {
          context.report({
            node,
            fix(fixer) {
              if (options[loc]) {
                if (loc === "before") {
                  return fixer.insertTextBefore(node, " ");
                }
                return fixer.insertTextAfter(node, " ");
              }
              let start, end;
              const newText = "";
              if (loc === "before") {
                start = otherNode.range[1];
                end = node.range[0];
              } else {
                start = node.range[1];
                end = otherNode.range[0];
              }
              return fixer.replaceTextRange([start, end], newText);
            },
            messageId: options[loc] ? "missing" : "unexpected",
            data: {
              loc
            }
          });
        }
        function addNullElementsToIgnoreList(node) {
          let previousToken = sourceCode.getFirstToken(node);
          node.elements.forEach((element) => {
            let token;
            if (element === null) {
              token = sourceCode.getTokenAfter(previousToken);
              if (astUtils.isCommaToken(token)) {
                commaTokensToIgnore.push(token);
              }
            } else {
              token = sourceCode.getTokenAfter(element);
            }
            previousToken = token;
          });
        }
        return {
          "Program:exit"() {
            tokensAndComments.forEach((token, i) => {
              if (!astUtils.isCommaToken(token)) {
                return;
              }
              const previousToken = tokensAndComments[i - 1];
              const nextToken = tokensAndComments[i + 1];
              if (previousToken && !astUtils.isCommaToken(previousToken) && // ignore spacing between two commas
              /*
               * `commaTokensToIgnore` are ending commas of `null` elements (array holes/elisions).
               * In addition to spacing between two commas, this can also ignore:
               *
               *   - Spacing after `[` (controlled by array-bracket-spacing)
               *       Example: [ , ]
               *                 ^
               *   - Spacing after a comment (for backwards compatibility, this was possibly unintentional)
               *       Example: [a, /* * / ,]
               *                          ^
               */
              !commaTokensToIgnore.includes(token) && astUtils.isTokenOnSameLine(previousToken, token) && options.before !== sourceCode.isSpaceBetweenTokens(previousToken, token)) {
                report(token, "before", previousToken);
              }
              if (nextToken && !astUtils.isCommaToken(nextToken) && // ignore spacing between two commas
              !astUtils.isClosingParenToken(nextToken) && // controlled by space-in-parens
              !astUtils.isClosingBracketToken(nextToken) && // controlled by array-bracket-spacing
              !astUtils.isClosingBraceToken(nextToken) && // controlled by object-curly-spacing
              !(!options.after && nextToken.type === "Line") && // special case, allow space before line comment
              astUtils.isTokenOnSameLine(token, nextToken) && options.after !== sourceCode.isSpaceBetweenTokens(token, nextToken)) {
                report(token, "after", nextToken);
              }
            });
          },
          ArrayExpression: addNullElementsToIgnoreList,
          ArrayPattern: addNullElementsToIgnoreList
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/comma-style.js
var require_comma_style = __commonJS({
  "../../node_modules/eslint/lib/rules/comma-style.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Enforce consistent comma style",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/comma-style"
        },
        fixable: "code",
        schema: [
          {
            enum: ["first", "last"]
          },
          {
            type: "object",
            properties: {
              exceptions: {
                type: "object",
                additionalProperties: {
                  type: "boolean"
                }
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          unexpectedLineBeforeAndAfterComma: "Bad line breaking before and after ','.",
          expectedCommaFirst: "',' should be placed first.",
          expectedCommaLast: "',' should be placed last."
        }
      },
      create(context) {
        const style = context.options[0] || "last", sourceCode = context.sourceCode;
        const exceptions = {
          ArrayPattern: true,
          ArrowFunctionExpression: true,
          CallExpression: true,
          FunctionDeclaration: true,
          FunctionExpression: true,
          ImportDeclaration: true,
          ObjectPattern: true,
          NewExpression: true
        };
        if (context.options.length === 2 && Object.prototype.hasOwnProperty.call(context.options[1], "exceptions")) {
          const keys = Object.keys(context.options[1].exceptions);
          for (let i = 0; i < keys.length; i++) {
            exceptions[keys[i]] = context.options[1].exceptions[keys[i]];
          }
        }
        function getReplacedText(styleType, text) {
          switch (styleType) {
            case "between":
              return `,${text.replace(astUtils.LINEBREAK_MATCHER, "")}`;
            case "first":
              return `${text},`;
            case "last":
              return `,${text}`;
            default:
              return "";
          }
        }
        function getFixerFunction(styleType, previousItemToken, commaToken, currentItemToken) {
          const text = sourceCode.text.slice(previousItemToken.range[1], commaToken.range[0]) + sourceCode.text.slice(commaToken.range[1], currentItemToken.range[0]);
          const range = [previousItemToken.range[1], currentItemToken.range[0]];
          return function(fixer) {
            return fixer.replaceTextRange(range, getReplacedText(styleType, text));
          };
        }
        function validateCommaItemSpacing(previousItemToken, commaToken, currentItemToken, reportItem) {
          if (astUtils.isTokenOnSameLine(commaToken, currentItemToken) && astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {
          } else if (!astUtils.isTokenOnSameLine(commaToken, currentItemToken) && !astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {
            const comment = sourceCode.getCommentsAfter(commaToken)[0];
            const styleType = comment && comment.type === "Block" && astUtils.isTokenOnSameLine(commaToken, comment) ? style : "between";
            context.report({
              node: reportItem,
              loc: commaToken.loc,
              messageId: "unexpectedLineBeforeAndAfterComma",
              fix: getFixerFunction(styleType, previousItemToken, commaToken, currentItemToken)
            });
          } else if (style === "first" && !astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {
            context.report({
              node: reportItem,
              loc: commaToken.loc,
              messageId: "expectedCommaFirst",
              fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)
            });
          } else if (style === "last" && astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {
            context.report({
              node: reportItem,
              loc: commaToken.loc,
              messageId: "expectedCommaLast",
              fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)
            });
          }
        }
        function validateComma(node, property) {
          const items = node[property], arrayLiteral = node.type === "ArrayExpression" || node.type === "ArrayPattern";
          if (items.length > 1 || arrayLiteral) {
            let previousItemToken = sourceCode.getFirstToken(node);
            items.forEach((item) => {
              const commaToken = item ? sourceCode.getTokenBefore(item) : previousItemToken, currentItemToken = item ? sourceCode.getFirstToken(item) : sourceCode.getTokenAfter(commaToken), reportItem = item || currentItemToken;
              if (astUtils.isCommaToken(commaToken)) {
                validateCommaItemSpacing(previousItemToken, commaToken, currentItemToken, reportItem);
              }
              if (item) {
                const tokenAfterItem = sourceCode.getTokenAfter(item, astUtils.isNotClosingParenToken);
                previousItemToken = tokenAfterItem ? sourceCode.getTokenBefore(tokenAfterItem) : sourceCode.ast.tokens[sourceCode.ast.tokens.length - 1];
              } else {
                previousItemToken = currentItemToken;
              }
            });
            if (arrayLiteral) {
              const lastToken = sourceCode.getLastToken(node), nextToLastToken = sourceCode.getTokenBefore(lastToken);
              if (astUtils.isCommaToken(nextToLastToken)) {
                validateCommaItemSpacing(
                  sourceCode.getTokenBefore(nextToLastToken),
                  nextToLastToken,
                  lastToken,
                  lastToken
                );
              }
            }
          }
        }
        const nodes = {};
        if (!exceptions.VariableDeclaration) {
          nodes.VariableDeclaration = function(node) {
            validateComma(node, "declarations");
          };
        }
        if (!exceptions.ObjectExpression) {
          nodes.ObjectExpression = function(node) {
            validateComma(node, "properties");
          };
        }
        if (!exceptions.ObjectPattern) {
          nodes.ObjectPattern = function(node) {
            validateComma(node, "properties");
          };
        }
        if (!exceptions.ArrayExpression) {
          nodes.ArrayExpression = function(node) {
            validateComma(node, "elements");
          };
        }
        if (!exceptions.ArrayPattern) {
          nodes.ArrayPattern = function(node) {
            validateComma(node, "elements");
          };
        }
        if (!exceptions.FunctionDeclaration) {
          nodes.FunctionDeclaration = function(node) {
            validateComma(node, "params");
          };
        }
        if (!exceptions.FunctionExpression) {
          nodes.FunctionExpression = function(node) {
            validateComma(node, "params");
          };
        }
        if (!exceptions.ArrowFunctionExpression) {
          nodes.ArrowFunctionExpression = function(node) {
            validateComma(node, "params");
          };
        }
        if (!exceptions.CallExpression) {
          nodes.CallExpression = function(node) {
            validateComma(node, "arguments");
          };
        }
        if (!exceptions.ImportDeclaration) {
          nodes.ImportDeclaration = function(node) {
            validateComma(node, "specifiers");
          };
        }
        if (!exceptions.NewExpression) {
          nodes.NewExpression = function(node) {
            validateComma(node, "arguments");
          };
        }
        return nodes;
      }
    };
  }
});

// ../../node_modules/graphemer/lib/boundaries.js
var require_boundaries = __commonJS({
  "../../node_modules/graphemer/lib/boundaries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EXTENDED_PICTOGRAPHIC = exports.CLUSTER_BREAK = void 0;
    var CLUSTER_BREAK;
    (function(CLUSTER_BREAK2) {
      CLUSTER_BREAK2[CLUSTER_BREAK2["CR"] = 0] = "CR";
      CLUSTER_BREAK2[CLUSTER_BREAK2["LF"] = 1] = "LF";
      CLUSTER_BREAK2[CLUSTER_BREAK2["CONTROL"] = 2] = "CONTROL";
      CLUSTER_BREAK2[CLUSTER_BREAK2["EXTEND"] = 3] = "EXTEND";
      CLUSTER_BREAK2[CLUSTER_BREAK2["REGIONAL_INDICATOR"] = 4] = "REGIONAL_INDICATOR";
      CLUSTER_BREAK2[CLUSTER_BREAK2["SPACINGMARK"] = 5] = "SPACINGMARK";
      CLUSTER_BREAK2[CLUSTER_BREAK2["L"] = 6] = "L";
      CLUSTER_BREAK2[CLUSTER_BREAK2["V"] = 7] = "V";
      CLUSTER_BREAK2[CLUSTER_BREAK2["T"] = 8] = "T";
      CLUSTER_BREAK2[CLUSTER_BREAK2["LV"] = 9] = "LV";
      CLUSTER_BREAK2[CLUSTER_BREAK2["LVT"] = 10] = "LVT";
      CLUSTER_BREAK2[CLUSTER_BREAK2["OTHER"] = 11] = "OTHER";
      CLUSTER_BREAK2[CLUSTER_BREAK2["PREPEND"] = 12] = "PREPEND";
      CLUSTER_BREAK2[CLUSTER_BREAK2["E_BASE"] = 13] = "E_BASE";
      CLUSTER_BREAK2[CLUSTER_BREAK2["E_MODIFIER"] = 14] = "E_MODIFIER";
      CLUSTER_BREAK2[CLUSTER_BREAK2["ZWJ"] = 15] = "ZWJ";
      CLUSTER_BREAK2[CLUSTER_BREAK2["GLUE_AFTER_ZWJ"] = 16] = "GLUE_AFTER_ZWJ";
      CLUSTER_BREAK2[CLUSTER_BREAK2["E_BASE_GAZ"] = 17] = "E_BASE_GAZ";
    })(CLUSTER_BREAK = exports.CLUSTER_BREAK || (exports.CLUSTER_BREAK = {}));
    exports.EXTENDED_PICTOGRAPHIC = 101;
  }
});

// ../../node_modules/graphemer/lib/GraphemerHelper.js
var require_GraphemerHelper = __commonJS({
  "../../node_modules/graphemer/lib/GraphemerHelper.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var boundaries_1 = require_boundaries();
    var NotBreak = 0;
    var BreakStart = 1;
    var Break = 2;
    var BreakLastRegional = 3;
    var BreakPenultimateRegional = 4;
    var GraphemerHelper = class {
      /**
       * Check if the the character at the position {pos} of the string is surrogate
       * @param str {string}
       * @param pos {number}
       * @returns {boolean}
       */
      static isSurrogate(str, pos) {
        return 55296 <= str.charCodeAt(pos) && str.charCodeAt(pos) <= 56319 && 56320 <= str.charCodeAt(pos + 1) && str.charCodeAt(pos + 1) <= 57343;
      }
      /**
       * The String.prototype.codePointAt polyfill
       * Private function, gets a Unicode code point from a JavaScript UTF-16 string
       * handling surrogate pairs appropriately
       * @param str {string}
       * @param idx {number}
       * @returns {number}
       */
      static codePointAt(str, idx) {
        if (idx === void 0) {
          idx = 0;
        }
        const code = str.charCodeAt(idx);
        if (55296 <= code && code <= 56319 && idx < str.length - 1) {
          const hi = code;
          const low = str.charCodeAt(idx + 1);
          if (56320 <= low && low <= 57343) {
            return (hi - 55296) * 1024 + (low - 56320) + 65536;
          }
          return hi;
        }
        if (56320 <= code && code <= 57343 && idx >= 1) {
          const hi = str.charCodeAt(idx - 1);
          const low = code;
          if (55296 <= hi && hi <= 56319) {
            return (hi - 55296) * 1024 + (low - 56320) + 65536;
          }
          return low;
        }
        return code;
      }
      //
      /**
       * Private function, returns whether a break is allowed between the two given grapheme breaking classes
       * Implemented the UAX #29 3.1.1 Grapheme Cluster Boundary Rules on extended grapheme clusters
       * @param start {number}
       * @param mid {Array<number>}
       * @param end {number}
       * @param startEmoji {number}
       * @param midEmoji {Array<number>}
       * @param endEmoji {number}
       * @returns {number}
       */
      static shouldBreak(start, mid, end, startEmoji, midEmoji, endEmoji) {
        const all = [start].concat(mid).concat([end]);
        const allEmoji = [startEmoji].concat(midEmoji).concat([endEmoji]);
        const previous = all[all.length - 2];
        const next = end;
        const nextEmoji = endEmoji;
        const rIIndex = all.lastIndexOf(boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR);
        if (rIIndex > 0 && all.slice(1, rIIndex).every(function(c) {
          return c === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR;
        }) && [boundaries_1.CLUSTER_BREAK.PREPEND, boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR].indexOf(previous) === -1) {
          if (all.filter(function(c) {
            return c === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR;
          }).length % 2 === 1) {
            return BreakLastRegional;
          } else {
            return BreakPenultimateRegional;
          }
        }
        if (previous === boundaries_1.CLUSTER_BREAK.CR && next === boundaries_1.CLUSTER_BREAK.LF) {
          return NotBreak;
        } else if (previous === boundaries_1.CLUSTER_BREAK.CONTROL || previous === boundaries_1.CLUSTER_BREAK.CR || previous === boundaries_1.CLUSTER_BREAK.LF) {
          return BreakStart;
        } else if (next === boundaries_1.CLUSTER_BREAK.CONTROL || next === boundaries_1.CLUSTER_BREAK.CR || next === boundaries_1.CLUSTER_BREAK.LF) {
          return BreakStart;
        } else if (previous === boundaries_1.CLUSTER_BREAK.L && (next === boundaries_1.CLUSTER_BREAK.L || next === boundaries_1.CLUSTER_BREAK.V || next === boundaries_1.CLUSTER_BREAK.LV || next === boundaries_1.CLUSTER_BREAK.LVT)) {
          return NotBreak;
        } else if ((previous === boundaries_1.CLUSTER_BREAK.LV || previous === boundaries_1.CLUSTER_BREAK.V) && (next === boundaries_1.CLUSTER_BREAK.V || next === boundaries_1.CLUSTER_BREAK.T)) {
          return NotBreak;
        } else if ((previous === boundaries_1.CLUSTER_BREAK.LVT || previous === boundaries_1.CLUSTER_BREAK.T) && next === boundaries_1.CLUSTER_BREAK.T) {
          return NotBreak;
        } else if (next === boundaries_1.CLUSTER_BREAK.EXTEND || next === boundaries_1.CLUSTER_BREAK.ZWJ) {
          return NotBreak;
        } else if (next === boundaries_1.CLUSTER_BREAK.SPACINGMARK) {
          return NotBreak;
        } else if (previous === boundaries_1.CLUSTER_BREAK.PREPEND) {
          return NotBreak;
        }
        const previousNonExtendIndex = allEmoji.slice(0, -1).lastIndexOf(boundaries_1.EXTENDED_PICTOGRAPHIC);
        if (previousNonExtendIndex !== -1 && allEmoji[previousNonExtendIndex] === boundaries_1.EXTENDED_PICTOGRAPHIC && all.slice(previousNonExtendIndex + 1, -2).every(function(c) {
          return c === boundaries_1.CLUSTER_BREAK.EXTEND;
        }) && previous === boundaries_1.CLUSTER_BREAK.ZWJ && nextEmoji === boundaries_1.EXTENDED_PICTOGRAPHIC) {
          return NotBreak;
        }
        if (mid.indexOf(boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR) !== -1) {
          return Break;
        }
        if (previous === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR && next === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR) {
          return NotBreak;
        }
        return BreakStart;
      }
    };
    exports.default = GraphemerHelper;
  }
});

// ../../node_modules/graphemer/lib/GraphemerIterator.js
var require_GraphemerIterator = __commonJS({
  "../../node_modules/graphemer/lib/GraphemerIterator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var GraphemerIterator = class {
      constructor(str, nextBreak) {
        this._index = 0;
        this._str = str;
        this._nextBreak = nextBreak;
      }
      [Symbol.iterator]() {
        return this;
      }
      next() {
        let brk;
        if ((brk = this._nextBreak(this._str, this._index)) < this._str.length) {
          const value = this._str.slice(this._index, brk);
          this._index = brk;
          return { value, done: false };
        }
        if (this._index < this._str.length) {
          const value = this._str.slice(this._index);
          this._index = this._str.length;
          return { value, done: false };
        }
        return { value: void 0, done: true };
      }
    };
    exports.default = GraphemerIterator;
  }
});

// ../../node_modules/graphemer/lib/Graphemer.js
var require_Graphemer = __commonJS({
  "../../node_modules/graphemer/lib/Graphemer.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var boundaries_1 = require_boundaries();
    var GraphemerHelper_1 = __importDefault(require_GraphemerHelper());
    var GraphemerIterator_1 = __importDefault(require_GraphemerIterator());
    var Graphemer = class {
      /**
       * Returns the next grapheme break in the string after the given index
       * @param string {string}
       * @param index {number}
       * @returns {number}
       */
      static nextBreak(string, index) {
        if (index === void 0) {
          index = 0;
        }
        if (index < 0) {
          return 0;
        }
        if (index >= string.length - 1) {
          return string.length;
        }
        const prevCP = GraphemerHelper_1.default.codePointAt(string, index);
        const prev = Graphemer.getGraphemeBreakProperty(prevCP);
        const prevEmoji = Graphemer.getEmojiProperty(prevCP);
        const mid = [];
        const midEmoji = [];
        for (let i = index + 1; i < string.length; i++) {
          if (GraphemerHelper_1.default.isSurrogate(string, i - 1)) {
            continue;
          }
          const nextCP = GraphemerHelper_1.default.codePointAt(string, i);
          const next = Graphemer.getGraphemeBreakProperty(nextCP);
          const nextEmoji = Graphemer.getEmojiProperty(nextCP);
          if (GraphemerHelper_1.default.shouldBreak(prev, mid, next, prevEmoji, midEmoji, nextEmoji)) {
            return i;
          }
          mid.push(next);
          midEmoji.push(nextEmoji);
        }
        return string.length;
      }
      /**
       * Breaks the given string into an array of grapheme clusters
       * @param str {string}
       * @returns {string[]}
       */
      splitGraphemes(str) {
        const res = [];
        let index = 0;
        let brk;
        while ((brk = Graphemer.nextBreak(str, index)) < str.length) {
          res.push(str.slice(index, brk));
          index = brk;
        }
        if (index < str.length) {
          res.push(str.slice(index));
        }
        return res;
      }
      /**
       * Returns an iterator of grapheme clusters in the given string
       * @param str {string}
       * @returns {GraphemerIterator}
       */
      iterateGraphemes(str) {
        return new GraphemerIterator_1.default(str, Graphemer.nextBreak);
      }
      /**
       * Returns the number of grapheme clusters in the given string
       * @param str {string}
       * @returns {number}
       */
      countGraphemes(str) {
        let count = 0;
        let index = 0;
        let brk;
        while ((brk = Graphemer.nextBreak(str, index)) < str.length) {
          index = brk;
          count++;
        }
        if (index < str.length) {
          count++;
        }
        return count;
      }
      /**
       * Given a Unicode code point, determines this symbol's grapheme break property
       * @param code {number} Unicode code point
       * @returns {number}
       */
      static getGraphemeBreakProperty(code) {
        if (code < 48905) {
          if (code < 44116) {
            if (code < 4141) {
              if (code < 2818) {
                if (code < 2363) {
                  if (code < 1759) {
                    if (code < 1471) {
                      if (code < 127) {
                        if (code < 11) {
                          if (code < 10) {
                            if (0 <= code && code <= 9) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                          } else {
                            if (10 === code) {
                              return boundaries_1.CLUSTER_BREAK.LF;
                            }
                          }
                        } else {
                          if (code < 13) {
                            if (11 <= code && code <= 12) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                          } else {
                            if (code < 14) {
                              if (13 === code) {
                                return boundaries_1.CLUSTER_BREAK.CR;
                              }
                            } else {
                              if (14 <= code && code <= 31) {
                                return boundaries_1.CLUSTER_BREAK.CONTROL;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 768) {
                          if (code < 173) {
                            if (127 <= code && code <= 159) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                          } else {
                            if (173 === code) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                          }
                        } else {
                          if (code < 1155) {
                            if (768 <= code && code <= 879) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 1425) {
                              if (1155 <= code && code <= 1161) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (1425 <= code && code <= 1469) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 1552) {
                        if (code < 1476) {
                          if (code < 1473) {
                            if (1471 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (1473 <= code && code <= 1474) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 1479) {
                            if (1476 <= code && code <= 1477) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 1536) {
                              if (1479 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (1536 <= code && code <= 1541) {
                                return boundaries_1.CLUSTER_BREAK.PREPEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 1648) {
                          if (code < 1564) {
                            if (1552 <= code && code <= 1562) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 1611) {
                              if (1564 === code) {
                                return boundaries_1.CLUSTER_BREAK.CONTROL;
                              }
                            } else {
                              if (1611 <= code && code <= 1631) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 1750) {
                            if (1648 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 1757) {
                              if (1750 <= code && code <= 1756) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (1757 === code) {
                                return boundaries_1.CLUSTER_BREAK.PREPEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 2075) {
                      if (code < 1840) {
                        if (code < 1770) {
                          if (code < 1767) {
                            if (1759 <= code && code <= 1764) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (1767 <= code && code <= 1768) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 1807) {
                            if (1770 <= code && code <= 1773) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (1807 === code) {
                              return boundaries_1.CLUSTER_BREAK.PREPEND;
                            }
                            if (1809 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      } else {
                        if (code < 2027) {
                          if (code < 1958) {
                            if (1840 <= code && code <= 1866) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (1958 <= code && code <= 1968) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 2045) {
                            if (2027 <= code && code <= 2035) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 2070) {
                              if (2045 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (2070 <= code && code <= 2073) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 2200) {
                        if (code < 2089) {
                          if (code < 2085) {
                            if (2075 <= code && code <= 2083) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (2085 <= code && code <= 2087) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 2137) {
                            if (2089 <= code && code <= 2093) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 2192) {
                              if (2137 <= code && code <= 2139) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (2192 <= code && code <= 2193) {
                                return boundaries_1.CLUSTER_BREAK.PREPEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 2275) {
                          if (code < 2250) {
                            if (2200 <= code && code <= 2207) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 2274) {
                              if (2250 <= code && code <= 2273) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (2274 === code) {
                                return boundaries_1.CLUSTER_BREAK.PREPEND;
                              }
                            }
                          }
                        } else {
                          if (code < 2307) {
                            if (2275 <= code && code <= 2306) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (2307 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                            if (2362 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 2561) {
                    if (code < 2434) {
                      if (code < 2381) {
                        if (code < 2366) {
                          if (2363 === code) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                          if (2364 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code < 2369) {
                            if (2366 <= code && code <= 2368) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 2377) {
                              if (2369 <= code && code <= 2376) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (2377 <= code && code <= 2380) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 2385) {
                          if (code < 2382) {
                            if (2381 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (2382 <= code && code <= 2383) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 2402) {
                            if (2385 <= code && code <= 2391) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 2433) {
                              if (2402 <= code && code <= 2403) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (2433 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 2503) {
                        if (code < 2494) {
                          if (code < 2492) {
                            if (2434 <= code && code <= 2435) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (2492 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 2495) {
                            if (2494 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 2497) {
                              if (2495 <= code && code <= 2496) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (2497 <= code && code <= 2500) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 2519) {
                          if (code < 2507) {
                            if (2503 <= code && code <= 2504) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 2509) {
                              if (2507 <= code && code <= 2508) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (2509 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 2530) {
                            if (2519 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 2558) {
                              if (2530 <= code && code <= 2531) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (2558 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 2691) {
                      if (code < 2631) {
                        if (code < 2620) {
                          if (code < 2563) {
                            if (2561 <= code && code <= 2562) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (2563 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 2622) {
                            if (2620 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 2625) {
                              if (2622 <= code && code <= 2624) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (2625 <= code && code <= 2626) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 2672) {
                          if (code < 2635) {
                            if (2631 <= code && code <= 2632) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 2641) {
                              if (2635 <= code && code <= 2637) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (2641 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 2677) {
                            if (2672 <= code && code <= 2673) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 2689) {
                              if (2677 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (2689 <= code && code <= 2690) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 2761) {
                        if (code < 2750) {
                          if (2691 === code) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                          if (2748 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code < 2753) {
                            if (2750 <= code && code <= 2752) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 2759) {
                              if (2753 <= code && code <= 2757) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (2759 <= code && code <= 2760) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 2786) {
                          if (code < 2763) {
                            if (2761 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 2765) {
                              if (2763 <= code && code <= 2764) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (2765 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 2810) {
                            if (2786 <= code && code <= 2787) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 2817) {
                              if (2810 <= code && code <= 2815) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (2817 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code < 3315) {
                  if (code < 3076) {
                    if (code < 2946) {
                      if (code < 2887) {
                        if (code < 2878) {
                          if (code < 2876) {
                            if (2818 <= code && code <= 2819) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (2876 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 2880) {
                            if (2878 <= code && code <= 2879) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 2881) {
                              if (2880 === code) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (2881 <= code && code <= 2884) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 2893) {
                          if (code < 2891) {
                            if (2887 <= code && code <= 2888) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (2891 <= code && code <= 2892) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 2901) {
                            if (2893 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 2914) {
                              if (2901 <= code && code <= 2903) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (2914 <= code && code <= 2915) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 3014) {
                        if (code < 3007) {
                          if (2946 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                          if (3006 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code < 3008) {
                            if (3007 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 3009) {
                              if (3008 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3009 <= code && code <= 3010) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 3031) {
                          if (code < 3018) {
                            if (3014 <= code && code <= 3016) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 3021) {
                              if (3018 <= code && code <= 3020) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (3021 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 3072) {
                            if (3031 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 3073) {
                              if (3072 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3073 <= code && code <= 3075) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 3262) {
                      if (code < 3146) {
                        if (code < 3134) {
                          if (3076 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                          if (3132 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code < 3137) {
                            if (3134 <= code && code <= 3136) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 3142) {
                              if (3137 <= code && code <= 3140) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (3142 <= code && code <= 3144) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 3201) {
                          if (code < 3157) {
                            if (3146 <= code && code <= 3149) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 3170) {
                              if (3157 <= code && code <= 3158) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3170 <= code && code <= 3171) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 3202) {
                            if (3201 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 3260) {
                              if (3202 <= code && code <= 3203) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (3260 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 3270) {
                        if (code < 3264) {
                          if (3262 === code) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                          if (3263 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code < 3266) {
                            if (3264 <= code && code <= 3265) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 3267) {
                              if (3266 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3267 <= code && code <= 3268) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 3276) {
                          if (code < 3271) {
                            if (3270 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 3274) {
                              if (3271 <= code && code <= 3272) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (3274 <= code && code <= 3275) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        } else {
                          if (code < 3285) {
                            if (3276 <= code && code <= 3277) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 3298) {
                              if (3285 <= code && code <= 3286) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3298 <= code && code <= 3299) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 3551) {
                    if (code < 3406) {
                      if (code < 3391) {
                        if (code < 3330) {
                          if (code < 3328) {
                            if (3315 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (3328 <= code && code <= 3329) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 3387) {
                            if (3330 <= code && code <= 3331) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 3390) {
                              if (3387 <= code && code <= 3388) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3390 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 3398) {
                          if (code < 3393) {
                            if (3391 <= code && code <= 3392) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (3393 <= code && code <= 3396) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 3402) {
                            if (3398 <= code && code <= 3400) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 3405) {
                              if (3402 <= code && code <= 3404) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (3405 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 3530) {
                        if (code < 3426) {
                          if (3406 === code) {
                            return boundaries_1.CLUSTER_BREAK.PREPEND;
                          }
                          if (3415 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code < 3457) {
                            if (3426 <= code && code <= 3427) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 3458) {
                              if (3457 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3458 <= code && code <= 3459) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 3538) {
                          if (code < 3535) {
                            if (3530 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 3536) {
                              if (3535 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3536 <= code && code <= 3537) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        } else {
                          if (code < 3542) {
                            if (3538 <= code && code <= 3540) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 3544) {
                              if (3542 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3544 <= code && code <= 3550) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 3893) {
                      if (code < 3655) {
                        if (code < 3633) {
                          if (code < 3570) {
                            if (3551 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (3570 <= code && code <= 3571) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 3635) {
                            if (3633 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 3636) {
                              if (3635 === code) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (3636 <= code && code <= 3642) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 3764) {
                          if (code < 3761) {
                            if (3655 <= code && code <= 3662) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (3761 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (3763 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 3784) {
                            if (3764 <= code && code <= 3772) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 3864) {
                              if (3784 <= code && code <= 3790) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3864 <= code && code <= 3865) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 3967) {
                        if (code < 3897) {
                          if (3893 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                          if (3895 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code < 3902) {
                            if (3897 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 3953) {
                              if (3902 <= code && code <= 3903) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (3953 <= code && code <= 3966) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 3981) {
                          if (code < 3968) {
                            if (3967 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 3974) {
                              if (3968 <= code && code <= 3972) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (3974 <= code && code <= 3975) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 3993) {
                            if (3981 <= code && code <= 3991) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 4038) {
                              if (3993 <= code && code <= 4028) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (4038 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            } else {
              if (code < 7204) {
                if (code < 6448) {
                  if (code < 5938) {
                    if (code < 4226) {
                      if (code < 4157) {
                        if (code < 4146) {
                          if (code < 4145) {
                            if (4141 <= code && code <= 4144) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (4145 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 4153) {
                            if (4146 <= code && code <= 4151) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 4155) {
                              if (4153 <= code && code <= 4154) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (4155 <= code && code <= 4156) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 4184) {
                          if (code < 4182) {
                            if (4157 <= code && code <= 4158) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (4182 <= code && code <= 4183) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 4190) {
                            if (4184 <= code && code <= 4185) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 4209) {
                              if (4190 <= code && code <= 4192) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (4209 <= code && code <= 4212) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 4352) {
                        if (code < 4229) {
                          if (4226 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                          if (4228 === code) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                        } else {
                          if (code < 4237) {
                            if (4229 <= code && code <= 4230) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (4237 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (4253 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      } else {
                        if (code < 4957) {
                          if (code < 4448) {
                            if (4352 <= code && code <= 4447) {
                              return boundaries_1.CLUSTER_BREAK.L;
                            }
                          } else {
                            if (code < 4520) {
                              if (4448 <= code && code <= 4519) {
                                return boundaries_1.CLUSTER_BREAK.V;
                              }
                            } else {
                              if (4520 <= code && code <= 4607) {
                                return boundaries_1.CLUSTER_BREAK.T;
                              }
                            }
                          }
                        } else {
                          if (code < 5906) {
                            if (4957 <= code && code <= 4959) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 5909) {
                              if (5906 <= code && code <= 5908) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (5909 === code) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 6089) {
                      if (code < 6070) {
                        if (code < 5970) {
                          if (code < 5940) {
                            if (5938 <= code && code <= 5939) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (5940 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 6002) {
                            if (5970 <= code && code <= 5971) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 6068) {
                              if (6002 <= code && code <= 6003) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (6068 <= code && code <= 6069) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 6078) {
                          if (code < 6071) {
                            if (6070 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (6071 <= code && code <= 6077) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 6086) {
                            if (6078 <= code && code <= 6085) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 6087) {
                              if (6086 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (6087 <= code && code <= 6088) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 6277) {
                        if (code < 6155) {
                          if (code < 6109) {
                            if (6089 <= code && code <= 6099) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (6109 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 6158) {
                            if (6155 <= code && code <= 6157) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (6158 === code) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                            if (6159 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      } else {
                        if (code < 6435) {
                          if (code < 6313) {
                            if (6277 <= code && code <= 6278) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 6432) {
                              if (6313 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (6432 <= code && code <= 6434) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 6439) {
                            if (6435 <= code && code <= 6438) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 6441) {
                              if (6439 <= code && code <= 6440) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (6441 <= code && code <= 6443) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 6971) {
                    if (code < 6744) {
                      if (code < 6681) {
                        if (code < 6451) {
                          if (code < 6450) {
                            if (6448 <= code && code <= 6449) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (6450 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 6457) {
                            if (6451 <= code && code <= 6456) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 6679) {
                              if (6457 <= code && code <= 6459) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (6679 <= code && code <= 6680) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 6741) {
                          if (code < 6683) {
                            if (6681 <= code && code <= 6682) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (6683 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 6742) {
                            if (6741 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (6742 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (6743 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 6771) {
                        if (code < 6754) {
                          if (code < 6752) {
                            if (6744 <= code && code <= 6750) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (6752 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 6757) {
                            if (6754 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 6765) {
                              if (6757 <= code && code <= 6764) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (6765 <= code && code <= 6770) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 6912) {
                          if (code < 6783) {
                            if (6771 <= code && code <= 6780) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 6832) {
                              if (6783 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (6832 <= code && code <= 6862) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 6916) {
                            if (6912 <= code && code <= 6915) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 6964) {
                              if (6916 === code) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (6964 <= code && code <= 6970) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 7080) {
                      if (code < 7019) {
                        if (code < 6973) {
                          if (6971 === code) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                          if (6972 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code < 6978) {
                            if (6973 <= code && code <= 6977) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 6979) {
                              if (6978 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (6979 <= code && code <= 6980) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 7073) {
                          if (code < 7040) {
                            if (7019 <= code && code <= 7027) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 7042) {
                              if (7040 <= code && code <= 7041) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (7042 === code) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        } else {
                          if (code < 7074) {
                            if (7073 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 7078) {
                              if (7074 <= code && code <= 7077) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (7078 <= code && code <= 7079) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 7144) {
                        if (code < 7083) {
                          if (code < 7082) {
                            if (7080 <= code && code <= 7081) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (7082 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 7142) {
                            if (7083 <= code && code <= 7085) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (7142 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (7143 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        }
                      } else {
                        if (code < 7150) {
                          if (code < 7146) {
                            if (7144 <= code && code <= 7145) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 7149) {
                              if (7146 <= code && code <= 7148) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (7149 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 7151) {
                            if (7150 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 7154) {
                              if (7151 <= code && code <= 7153) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (7154 <= code && code <= 7155) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code < 43346) {
                  if (code < 11647) {
                    if (code < 7415) {
                      if (code < 7380) {
                        if (code < 7220) {
                          if (code < 7212) {
                            if (7204 <= code && code <= 7211) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (7212 <= code && code <= 7219) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 7222) {
                            if (7220 <= code && code <= 7221) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 7376) {
                              if (7222 <= code && code <= 7223) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (7376 <= code && code <= 7378) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 7394) {
                          if (code < 7393) {
                            if (7380 <= code && code <= 7392) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (7393 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 7405) {
                            if (7394 <= code && code <= 7400) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (7405 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (7412 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 8205) {
                        if (code < 7616) {
                          if (code < 7416) {
                            if (7415 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (7416 <= code && code <= 7417) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 8203) {
                            if (7616 <= code && code <= 7679) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (8203 === code) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                            if (8204 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      } else {
                        if (code < 8288) {
                          if (code < 8206) {
                            if (8205 === code) {
                              return boundaries_1.CLUSTER_BREAK.ZWJ;
                            }
                          } else {
                            if (code < 8232) {
                              if (8206 <= code && code <= 8207) {
                                return boundaries_1.CLUSTER_BREAK.CONTROL;
                              }
                            } else {
                              if (8232 <= code && code <= 8238) {
                                return boundaries_1.CLUSTER_BREAK.CONTROL;
                              }
                            }
                          }
                        } else {
                          if (code < 8400) {
                            if (8288 <= code && code <= 8303) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                          } else {
                            if (code < 11503) {
                              if (8400 <= code && code <= 8432) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (11503 <= code && code <= 11505) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 43043) {
                      if (code < 42612) {
                        if (code < 12330) {
                          if (code < 11744) {
                            if (11647 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (11744 <= code && code <= 11775) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 12441) {
                            if (12330 <= code && code <= 12335) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 42607) {
                              if (12441 <= code && code <= 12442) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (42607 <= code && code <= 42610) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 43010) {
                          if (code < 42654) {
                            if (42612 <= code && code <= 42621) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 42736) {
                              if (42654 <= code && code <= 42655) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (42736 <= code && code <= 42737) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 43014) {
                            if (43010 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (43014 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (43019 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 43188) {
                        if (code < 43047) {
                          if (code < 43045) {
                            if (43043 <= code && code <= 43044) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (43045 <= code && code <= 43046) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 43052) {
                            if (43047 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 43136) {
                              if (43052 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (43136 <= code && code <= 43137) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 43263) {
                          if (code < 43204) {
                            if (43188 <= code && code <= 43203) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 43232) {
                              if (43204 <= code && code <= 43205) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (43232 <= code && code <= 43249) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 43302) {
                            if (43263 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 43335) {
                              if (43302 <= code && code <= 43309) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (43335 <= code && code <= 43345) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 43698) {
                    if (code < 43493) {
                      if (code < 43444) {
                        if (code < 43392) {
                          if (code < 43360) {
                            if (43346 <= code && code <= 43347) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (43360 <= code && code <= 43388) {
                              return boundaries_1.CLUSTER_BREAK.L;
                            }
                          }
                        } else {
                          if (code < 43395) {
                            if (43392 <= code && code <= 43394) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (43395 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                            if (43443 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      } else {
                        if (code < 43450) {
                          if (code < 43446) {
                            if (43444 <= code && code <= 43445) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (43446 <= code && code <= 43449) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 43452) {
                            if (43450 <= code && code <= 43451) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 43454) {
                              if (43452 <= code && code <= 43453) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (43454 <= code && code <= 43456) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 43573) {
                        if (code < 43567) {
                          if (code < 43561) {
                            if (43493 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (43561 <= code && code <= 43566) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 43569) {
                            if (43567 <= code && code <= 43568) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 43571) {
                              if (43569 <= code && code <= 43570) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (43571 <= code && code <= 43572) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 43597) {
                          if (code < 43587) {
                            if (43573 <= code && code <= 43574) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (43587 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (43596 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 43644) {
                            if (43597 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (43644 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (43696 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 44006) {
                      if (code < 43756) {
                        if (code < 43710) {
                          if (code < 43703) {
                            if (43698 <= code && code <= 43700) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (43703 <= code && code <= 43704) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 43713) {
                            if (43710 <= code && code <= 43711) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (43713 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (43755 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        }
                      } else {
                        if (code < 43766) {
                          if (code < 43758) {
                            if (43756 <= code && code <= 43757) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 43765) {
                              if (43758 <= code && code <= 43759) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (43765 === code) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        } else {
                          if (code < 44003) {
                            if (43766 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 44005) {
                              if (44003 <= code && code <= 44004) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (44005 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 44032) {
                        if (code < 44009) {
                          if (code < 44008) {
                            if (44006 <= code && code <= 44007) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (44008 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 44012) {
                            if (44009 <= code && code <= 44010) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (44012 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                            if (44013 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      } else {
                        if (code < 44061) {
                          if (code < 44033) {
                            if (44032 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 44060) {
                              if (44033 <= code && code <= 44059) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (44060 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 44088) {
                            if (44061 <= code && code <= 44087) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 44089) {
                              if (44088 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (44089 <= code && code <= 44115) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          } else {
            if (code < 46497) {
              if (code < 45293) {
                if (code < 44704) {
                  if (code < 44397) {
                    if (code < 44256) {
                      if (code < 44173) {
                        if (code < 44144) {
                          if (code < 44117) {
                            if (44116 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (44117 <= code && code <= 44143) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 44145) {
                            if (44144 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 44172) {
                              if (44145 <= code && code <= 44171) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (44172 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 44201) {
                          if (code < 44200) {
                            if (44173 <= code && code <= 44199) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (44200 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 44228) {
                            if (44201 <= code && code <= 44227) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 44229) {
                              if (44228 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (44229 <= code && code <= 44255) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 44313) {
                        if (code < 44284) {
                          if (code < 44257) {
                            if (44256 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (44257 <= code && code <= 44283) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 44285) {
                            if (44284 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 44312) {
                              if (44285 <= code && code <= 44311) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (44312 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 44368) {
                          if (code < 44340) {
                            if (44313 <= code && code <= 44339) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 44341) {
                              if (44340 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (44341 <= code && code <= 44367) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 44369) {
                            if (44368 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 44396) {
                              if (44369 <= code && code <= 44395) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (44396 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 44537) {
                      if (code < 44480) {
                        if (code < 44425) {
                          if (code < 44424) {
                            if (44397 <= code && code <= 44423) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (44424 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 44452) {
                            if (44425 <= code && code <= 44451) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 44453) {
                              if (44452 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (44453 <= code && code <= 44479) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 44508) {
                          if (code < 44481) {
                            if (44480 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (44481 <= code && code <= 44507) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 44509) {
                            if (44508 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 44536) {
                              if (44509 <= code && code <= 44535) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (44536 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 44620) {
                        if (code < 44565) {
                          if (code < 44564) {
                            if (44537 <= code && code <= 44563) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (44564 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 44592) {
                            if (44565 <= code && code <= 44591) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 44593) {
                              if (44592 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (44593 <= code && code <= 44619) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 44649) {
                          if (code < 44621) {
                            if (44620 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 44648) {
                              if (44621 <= code && code <= 44647) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (44648 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 44676) {
                            if (44649 <= code && code <= 44675) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 44677) {
                              if (44676 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (44677 <= code && code <= 44703) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 44985) {
                    if (code < 44844) {
                      if (code < 44761) {
                        if (code < 44732) {
                          if (code < 44705) {
                            if (44704 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (44705 <= code && code <= 44731) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 44733) {
                            if (44732 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 44760) {
                              if (44733 <= code && code <= 44759) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (44760 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 44789) {
                          if (code < 44788) {
                            if (44761 <= code && code <= 44787) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (44788 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 44816) {
                            if (44789 <= code && code <= 44815) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 44817) {
                              if (44816 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (44817 <= code && code <= 44843) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 44901) {
                        if (code < 44872) {
                          if (code < 44845) {
                            if (44844 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (44845 <= code && code <= 44871) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 44873) {
                            if (44872 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 44900) {
                              if (44873 <= code && code <= 44899) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (44900 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 44956) {
                          if (code < 44928) {
                            if (44901 <= code && code <= 44927) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 44929) {
                              if (44928 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (44929 <= code && code <= 44955) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 44957) {
                            if (44956 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 44984) {
                              if (44957 <= code && code <= 44983) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (44984 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 45152) {
                      if (code < 45068) {
                        if (code < 45013) {
                          if (code < 45012) {
                            if (44985 <= code && code <= 45011) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (45012 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 45040) {
                            if (45013 <= code && code <= 45039) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 45041) {
                              if (45040 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (45041 <= code && code <= 45067) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 45097) {
                          if (code < 45069) {
                            if (45068 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 45096) {
                              if (45069 <= code && code <= 45095) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (45096 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 45124) {
                            if (45097 <= code && code <= 45123) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 45125) {
                              if (45124 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (45125 <= code && code <= 45151) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 45209) {
                        if (code < 45180) {
                          if (code < 45153) {
                            if (45152 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (45153 <= code && code <= 45179) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 45181) {
                            if (45180 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 45208) {
                              if (45181 <= code && code <= 45207) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (45208 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 45264) {
                          if (code < 45236) {
                            if (45209 <= code && code <= 45235) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 45237) {
                              if (45236 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (45237 <= code && code <= 45263) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 45265) {
                            if (45264 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 45292) {
                              if (45265 <= code && code <= 45291) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (45292 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code < 45908) {
                  if (code < 45600) {
                    if (code < 45433) {
                      if (code < 45376) {
                        if (code < 45321) {
                          if (code < 45320) {
                            if (45293 <= code && code <= 45319) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (45320 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 45348) {
                            if (45321 <= code && code <= 45347) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 45349) {
                              if (45348 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (45349 <= code && code <= 45375) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 45404) {
                          if (code < 45377) {
                            if (45376 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (45377 <= code && code <= 45403) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 45405) {
                            if (45404 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 45432) {
                              if (45405 <= code && code <= 45431) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (45432 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 45516) {
                        if (code < 45461) {
                          if (code < 45460) {
                            if (45433 <= code && code <= 45459) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (45460 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 45488) {
                            if (45461 <= code && code <= 45487) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 45489) {
                              if (45488 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (45489 <= code && code <= 45515) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 45545) {
                          if (code < 45517) {
                            if (45516 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 45544) {
                              if (45517 <= code && code <= 45543) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (45544 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 45572) {
                            if (45545 <= code && code <= 45571) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 45573) {
                              if (45572 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (45573 <= code && code <= 45599) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 45741) {
                      if (code < 45657) {
                        if (code < 45628) {
                          if (code < 45601) {
                            if (45600 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (45601 <= code && code <= 45627) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 45629) {
                            if (45628 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 45656) {
                              if (45629 <= code && code <= 45655) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (45656 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 45712) {
                          if (code < 45684) {
                            if (45657 <= code && code <= 45683) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 45685) {
                              if (45684 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (45685 <= code && code <= 45711) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 45713) {
                            if (45712 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 45740) {
                              if (45713 <= code && code <= 45739) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (45740 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 45824) {
                        if (code < 45769) {
                          if (code < 45768) {
                            if (45741 <= code && code <= 45767) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (45768 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 45796) {
                            if (45769 <= code && code <= 45795) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 45797) {
                              if (45796 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (45797 <= code && code <= 45823) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 45853) {
                          if (code < 45825) {
                            if (45824 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 45852) {
                              if (45825 <= code && code <= 45851) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (45852 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 45880) {
                            if (45853 <= code && code <= 45879) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 45881) {
                              if (45880 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (45881 <= code && code <= 45907) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 46189) {
                    if (code < 46048) {
                      if (code < 45965) {
                        if (code < 45936) {
                          if (code < 45909) {
                            if (45908 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (45909 <= code && code <= 45935) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 45937) {
                            if (45936 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 45964) {
                              if (45937 <= code && code <= 45963) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (45964 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 45993) {
                          if (code < 45992) {
                            if (45965 <= code && code <= 45991) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (45992 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 46020) {
                            if (45993 <= code && code <= 46019) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 46021) {
                              if (46020 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (46021 <= code && code <= 46047) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 46105) {
                        if (code < 46076) {
                          if (code < 46049) {
                            if (46048 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (46049 <= code && code <= 46075) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 46077) {
                            if (46076 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 46104) {
                              if (46077 <= code && code <= 46103) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (46104 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 46160) {
                          if (code < 46132) {
                            if (46105 <= code && code <= 46131) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 46133) {
                              if (46132 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (46133 <= code && code <= 46159) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 46161) {
                            if (46160 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 46188) {
                              if (46161 <= code && code <= 46187) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (46188 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 46356) {
                      if (code < 46272) {
                        if (code < 46217) {
                          if (code < 46216) {
                            if (46189 <= code && code <= 46215) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (46216 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 46244) {
                            if (46217 <= code && code <= 46243) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 46245) {
                              if (46244 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (46245 <= code && code <= 46271) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 46301) {
                          if (code < 46273) {
                            if (46272 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 46300) {
                              if (46273 <= code && code <= 46299) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (46300 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 46328) {
                            if (46301 <= code && code <= 46327) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 46329) {
                              if (46328 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (46329 <= code && code <= 46355) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 46413) {
                        if (code < 46384) {
                          if (code < 46357) {
                            if (46356 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (46357 <= code && code <= 46383) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 46385) {
                            if (46384 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 46412) {
                              if (46385 <= code && code <= 46411) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (46412 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 46468) {
                          if (code < 46440) {
                            if (46413 <= code && code <= 46439) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 46441) {
                              if (46440 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (46441 <= code && code <= 46467) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 46469) {
                            if (46468 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 46496) {
                              if (46469 <= code && code <= 46495) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (46496 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            } else {
              if (code < 47701) {
                if (code < 47112) {
                  if (code < 46804) {
                    if (code < 46637) {
                      if (code < 46580) {
                        if (code < 46525) {
                          if (code < 46524) {
                            if (46497 <= code && code <= 46523) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (46524 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 46552) {
                            if (46525 <= code && code <= 46551) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 46553) {
                              if (46552 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (46553 <= code && code <= 46579) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 46608) {
                          if (code < 46581) {
                            if (46580 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (46581 <= code && code <= 46607) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 46609) {
                            if (46608 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 46636) {
                              if (46609 <= code && code <= 46635) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (46636 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 46720) {
                        if (code < 46665) {
                          if (code < 46664) {
                            if (46637 <= code && code <= 46663) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (46664 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 46692) {
                            if (46665 <= code && code <= 46691) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 46693) {
                              if (46692 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (46693 <= code && code <= 46719) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 46749) {
                          if (code < 46721) {
                            if (46720 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 46748) {
                              if (46721 <= code && code <= 46747) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (46748 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 46776) {
                            if (46749 <= code && code <= 46775) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 46777) {
                              if (46776 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (46777 <= code && code <= 46803) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 46945) {
                      if (code < 46861) {
                        if (code < 46832) {
                          if (code < 46805) {
                            if (46804 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (46805 <= code && code <= 46831) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 46833) {
                            if (46832 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 46860) {
                              if (46833 <= code && code <= 46859) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (46860 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 46916) {
                          if (code < 46888) {
                            if (46861 <= code && code <= 46887) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 46889) {
                              if (46888 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (46889 <= code && code <= 46915) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 46917) {
                            if (46916 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 46944) {
                              if (46917 <= code && code <= 46943) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (46944 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 47028) {
                        if (code < 46973) {
                          if (code < 46972) {
                            if (46945 <= code && code <= 46971) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (46972 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 47e3) {
                            if (46973 <= code && code <= 46999) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 47001) {
                              if (47e3 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (47001 <= code && code <= 47027) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 47057) {
                          if (code < 47029) {
                            if (47028 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 47056) {
                              if (47029 <= code && code <= 47055) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (47056 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 47084) {
                            if (47057 <= code && code <= 47083) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 47085) {
                              if (47084 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (47085 <= code && code <= 47111) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 47393) {
                    if (code < 47252) {
                      if (code < 47169) {
                        if (code < 47140) {
                          if (code < 47113) {
                            if (47112 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (47113 <= code && code <= 47139) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 47141) {
                            if (47140 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 47168) {
                              if (47141 <= code && code <= 47167) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (47168 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 47197) {
                          if (code < 47196) {
                            if (47169 <= code && code <= 47195) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (47196 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 47224) {
                            if (47197 <= code && code <= 47223) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 47225) {
                              if (47224 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (47225 <= code && code <= 47251) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 47309) {
                        if (code < 47280) {
                          if (code < 47253) {
                            if (47252 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (47253 <= code && code <= 47279) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 47281) {
                            if (47280 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 47308) {
                              if (47281 <= code && code <= 47307) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (47308 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 47364) {
                          if (code < 47336) {
                            if (47309 <= code && code <= 47335) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 47337) {
                              if (47336 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (47337 <= code && code <= 47363) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 47365) {
                            if (47364 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 47392) {
                              if (47365 <= code && code <= 47391) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (47392 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 47560) {
                      if (code < 47476) {
                        if (code < 47421) {
                          if (code < 47420) {
                            if (47393 <= code && code <= 47419) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (47420 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 47448) {
                            if (47421 <= code && code <= 47447) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 47449) {
                              if (47448 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (47449 <= code && code <= 47475) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 47505) {
                          if (code < 47477) {
                            if (47476 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 47504) {
                              if (47477 <= code && code <= 47503) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (47504 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 47532) {
                            if (47505 <= code && code <= 47531) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 47533) {
                              if (47532 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (47533 <= code && code <= 47559) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 47617) {
                        if (code < 47588) {
                          if (code < 47561) {
                            if (47560 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (47561 <= code && code <= 47587) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 47589) {
                            if (47588 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 47616) {
                              if (47589 <= code && code <= 47615) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (47616 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 47672) {
                          if (code < 47644) {
                            if (47617 <= code && code <= 47643) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 47645) {
                              if (47644 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (47645 <= code && code <= 47671) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 47673) {
                            if (47672 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 47700) {
                              if (47673 <= code && code <= 47699) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (47700 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code < 48316) {
                  if (code < 48008) {
                    if (code < 47841) {
                      if (code < 47784) {
                        if (code < 47729) {
                          if (code < 47728) {
                            if (47701 <= code && code <= 47727) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (47728 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 47756) {
                            if (47729 <= code && code <= 47755) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 47757) {
                              if (47756 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (47757 <= code && code <= 47783) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 47812) {
                          if (code < 47785) {
                            if (47784 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (47785 <= code && code <= 47811) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 47813) {
                            if (47812 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 47840) {
                              if (47813 <= code && code <= 47839) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (47840 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 47924) {
                        if (code < 47869) {
                          if (code < 47868) {
                            if (47841 <= code && code <= 47867) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (47868 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 47896) {
                            if (47869 <= code && code <= 47895) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 47897) {
                              if (47896 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (47897 <= code && code <= 47923) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 47953) {
                          if (code < 47925) {
                            if (47924 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 47952) {
                              if (47925 <= code && code <= 47951) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (47952 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 47980) {
                            if (47953 <= code && code <= 47979) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 47981) {
                              if (47980 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (47981 <= code && code <= 48007) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 48149) {
                      if (code < 48065) {
                        if (code < 48036) {
                          if (code < 48009) {
                            if (48008 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (48009 <= code && code <= 48035) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 48037) {
                            if (48036 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 48064) {
                              if (48037 <= code && code <= 48063) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (48064 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 48120) {
                          if (code < 48092) {
                            if (48065 <= code && code <= 48091) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 48093) {
                              if (48092 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (48093 <= code && code <= 48119) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 48121) {
                            if (48120 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 48148) {
                              if (48121 <= code && code <= 48147) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (48148 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 48232) {
                        if (code < 48177) {
                          if (code < 48176) {
                            if (48149 <= code && code <= 48175) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (48176 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 48204) {
                            if (48177 <= code && code <= 48203) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 48205) {
                              if (48204 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (48205 <= code && code <= 48231) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 48261) {
                          if (code < 48233) {
                            if (48232 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 48260) {
                              if (48233 <= code && code <= 48259) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (48260 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 48288) {
                            if (48261 <= code && code <= 48287) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 48289) {
                              if (48288 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (48289 <= code && code <= 48315) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 48597) {
                    if (code < 48456) {
                      if (code < 48373) {
                        if (code < 48344) {
                          if (code < 48317) {
                            if (48316 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (48317 <= code && code <= 48343) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 48345) {
                            if (48344 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 48372) {
                              if (48345 <= code && code <= 48371) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (48372 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 48401) {
                          if (code < 48400) {
                            if (48373 <= code && code <= 48399) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (48400 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 48428) {
                            if (48401 <= code && code <= 48427) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 48429) {
                              if (48428 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (48429 <= code && code <= 48455) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 48513) {
                        if (code < 48484) {
                          if (code < 48457) {
                            if (48456 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (48457 <= code && code <= 48483) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 48485) {
                            if (48484 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 48512) {
                              if (48485 <= code && code <= 48511) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (48512 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 48568) {
                          if (code < 48540) {
                            if (48513 <= code && code <= 48539) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 48541) {
                              if (48540 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (48541 <= code && code <= 48567) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 48569) {
                            if (48568 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 48596) {
                              if (48569 <= code && code <= 48595) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (48596 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 48764) {
                      if (code < 48680) {
                        if (code < 48625) {
                          if (code < 48624) {
                            if (48597 <= code && code <= 48623) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (48624 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 48652) {
                            if (48625 <= code && code <= 48651) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 48653) {
                              if (48652 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (48653 <= code && code <= 48679) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 48709) {
                          if (code < 48681) {
                            if (48680 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 48708) {
                              if (48681 <= code && code <= 48707) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (48708 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 48736) {
                            if (48709 <= code && code <= 48735) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 48737) {
                              if (48736 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (48737 <= code && code <= 48763) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 48821) {
                        if (code < 48792) {
                          if (code < 48765) {
                            if (48764 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (48765 <= code && code <= 48791) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 48793) {
                            if (48792 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 48820) {
                              if (48793 <= code && code <= 48819) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (48820 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 48876) {
                          if (code < 48848) {
                            if (48821 <= code && code <= 48847) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 48849) {
                              if (48848 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (48849 <= code && code <= 48875) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 48877) {
                            if (48876 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 48904) {
                              if (48877 <= code && code <= 48903) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (48904 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          if (code < 53720) {
            if (code < 51312) {
              if (code < 50108) {
                if (code < 49493) {
                  if (code < 49212) {
                    if (code < 49045) {
                      if (code < 48988) {
                        if (code < 48933) {
                          if (code < 48932) {
                            if (48905 <= code && code <= 48931) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (48932 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 48960) {
                            if (48933 <= code && code <= 48959) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 48961) {
                              if (48960 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (48961 <= code && code <= 48987) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 49016) {
                          if (code < 48989) {
                            if (48988 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (48989 <= code && code <= 49015) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 49017) {
                            if (49016 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 49044) {
                              if (49017 <= code && code <= 49043) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (49044 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 49128) {
                        if (code < 49073) {
                          if (code < 49072) {
                            if (49045 <= code && code <= 49071) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (49072 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 49100) {
                            if (49073 <= code && code <= 49099) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 49101) {
                              if (49100 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (49101 <= code && code <= 49127) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 49157) {
                          if (code < 49129) {
                            if (49128 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 49156) {
                              if (49129 <= code && code <= 49155) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (49156 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 49184) {
                            if (49157 <= code && code <= 49183) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 49185) {
                              if (49184 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (49185 <= code && code <= 49211) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 49352) {
                      if (code < 49269) {
                        if (code < 49240) {
                          if (code < 49213) {
                            if (49212 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (49213 <= code && code <= 49239) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 49241) {
                            if (49240 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 49268) {
                              if (49241 <= code && code <= 49267) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (49268 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 49297) {
                          if (code < 49296) {
                            if (49269 <= code && code <= 49295) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (49296 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 49324) {
                            if (49297 <= code && code <= 49323) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 49325) {
                              if (49324 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (49325 <= code && code <= 49351) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 49409) {
                        if (code < 49380) {
                          if (code < 49353) {
                            if (49352 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (49353 <= code && code <= 49379) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 49381) {
                            if (49380 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 49408) {
                              if (49381 <= code && code <= 49407) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (49408 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 49464) {
                          if (code < 49436) {
                            if (49409 <= code && code <= 49435) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 49437) {
                              if (49436 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (49437 <= code && code <= 49463) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 49465) {
                            if (49464 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 49492) {
                              if (49465 <= code && code <= 49491) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (49492 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 49800) {
                    if (code < 49633) {
                      if (code < 49576) {
                        if (code < 49521) {
                          if (code < 49520) {
                            if (49493 <= code && code <= 49519) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (49520 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 49548) {
                            if (49521 <= code && code <= 49547) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 49549) {
                              if (49548 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (49549 <= code && code <= 49575) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 49604) {
                          if (code < 49577) {
                            if (49576 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (49577 <= code && code <= 49603) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 49605) {
                            if (49604 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 49632) {
                              if (49605 <= code && code <= 49631) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (49632 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 49716) {
                        if (code < 49661) {
                          if (code < 49660) {
                            if (49633 <= code && code <= 49659) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (49660 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 49688) {
                            if (49661 <= code && code <= 49687) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 49689) {
                              if (49688 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (49689 <= code && code <= 49715) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 49745) {
                          if (code < 49717) {
                            if (49716 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 49744) {
                              if (49717 <= code && code <= 49743) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (49744 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 49772) {
                            if (49745 <= code && code <= 49771) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 49773) {
                              if (49772 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (49773 <= code && code <= 49799) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 49941) {
                      if (code < 49857) {
                        if (code < 49828) {
                          if (code < 49801) {
                            if (49800 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (49801 <= code && code <= 49827) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 49829) {
                            if (49828 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 49856) {
                              if (49829 <= code && code <= 49855) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (49856 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 49912) {
                          if (code < 49884) {
                            if (49857 <= code && code <= 49883) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 49885) {
                              if (49884 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (49885 <= code && code <= 49911) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 49913) {
                            if (49912 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 49940) {
                              if (49913 <= code && code <= 49939) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (49940 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 50024) {
                        if (code < 49969) {
                          if (code < 49968) {
                            if (49941 <= code && code <= 49967) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (49968 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 49996) {
                            if (49969 <= code && code <= 49995) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 49997) {
                              if (49996 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (49997 <= code && code <= 50023) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 50053) {
                          if (code < 50025) {
                            if (50024 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 50052) {
                              if (50025 <= code && code <= 50051) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (50052 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 50080) {
                            if (50053 <= code && code <= 50079) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 50081) {
                              if (50080 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (50081 <= code && code <= 50107) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code < 50697) {
                  if (code < 50389) {
                    if (code < 50248) {
                      if (code < 50165) {
                        if (code < 50136) {
                          if (code < 50109) {
                            if (50108 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (50109 <= code && code <= 50135) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 50137) {
                            if (50136 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 50164) {
                              if (50137 <= code && code <= 50163) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (50164 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 50193) {
                          if (code < 50192) {
                            if (50165 <= code && code <= 50191) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (50192 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 50220) {
                            if (50193 <= code && code <= 50219) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 50221) {
                              if (50220 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (50221 <= code && code <= 50247) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 50305) {
                        if (code < 50276) {
                          if (code < 50249) {
                            if (50248 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (50249 <= code && code <= 50275) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 50277) {
                            if (50276 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 50304) {
                              if (50277 <= code && code <= 50303) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (50304 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 50360) {
                          if (code < 50332) {
                            if (50305 <= code && code <= 50331) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 50333) {
                              if (50332 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (50333 <= code && code <= 50359) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 50361) {
                            if (50360 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 50388) {
                              if (50361 <= code && code <= 50387) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (50388 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 50556) {
                      if (code < 50472) {
                        if (code < 50417) {
                          if (code < 50416) {
                            if (50389 <= code && code <= 50415) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (50416 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 50444) {
                            if (50417 <= code && code <= 50443) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 50445) {
                              if (50444 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (50445 <= code && code <= 50471) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 50501) {
                          if (code < 50473) {
                            if (50472 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 50500) {
                              if (50473 <= code && code <= 50499) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (50500 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 50528) {
                            if (50501 <= code && code <= 50527) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 50529) {
                              if (50528 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (50529 <= code && code <= 50555) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 50613) {
                        if (code < 50584) {
                          if (code < 50557) {
                            if (50556 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (50557 <= code && code <= 50583) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 50585) {
                            if (50584 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 50612) {
                              if (50585 <= code && code <= 50611) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (50612 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 50668) {
                          if (code < 50640) {
                            if (50613 <= code && code <= 50639) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 50641) {
                              if (50640 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (50641 <= code && code <= 50667) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 50669) {
                            if (50668 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 50696) {
                              if (50669 <= code && code <= 50695) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (50696 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 51004) {
                    if (code < 50837) {
                      if (code < 50780) {
                        if (code < 50725) {
                          if (code < 50724) {
                            if (50697 <= code && code <= 50723) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (50724 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 50752) {
                            if (50725 <= code && code <= 50751) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 50753) {
                              if (50752 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (50753 <= code && code <= 50779) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 50808) {
                          if (code < 50781) {
                            if (50780 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (50781 <= code && code <= 50807) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 50809) {
                            if (50808 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 50836) {
                              if (50809 <= code && code <= 50835) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (50836 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 50920) {
                        if (code < 50865) {
                          if (code < 50864) {
                            if (50837 <= code && code <= 50863) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (50864 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 50892) {
                            if (50865 <= code && code <= 50891) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 50893) {
                              if (50892 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (50893 <= code && code <= 50919) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 50949) {
                          if (code < 50921) {
                            if (50920 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 50948) {
                              if (50921 <= code && code <= 50947) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (50948 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 50976) {
                            if (50949 <= code && code <= 50975) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 50977) {
                              if (50976 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (50977 <= code && code <= 51003) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 51145) {
                      if (code < 51061) {
                        if (code < 51032) {
                          if (code < 51005) {
                            if (51004 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (51005 <= code && code <= 51031) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 51033) {
                            if (51032 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 51060) {
                              if (51033 <= code && code <= 51059) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (51060 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 51116) {
                          if (code < 51088) {
                            if (51061 <= code && code <= 51087) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 51089) {
                              if (51088 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (51089 <= code && code <= 51115) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 51117) {
                            if (51116 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 51144) {
                              if (51117 <= code && code <= 51143) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (51144 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 51228) {
                        if (code < 51173) {
                          if (code < 51172) {
                            if (51145 <= code && code <= 51171) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (51172 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 51200) {
                            if (51173 <= code && code <= 51199) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 51201) {
                              if (51200 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (51201 <= code && code <= 51227) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 51257) {
                          if (code < 51229) {
                            if (51228 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 51256) {
                              if (51229 <= code && code <= 51255) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (51256 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 51284) {
                            if (51257 <= code && code <= 51283) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 51285) {
                              if (51284 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (51285 <= code && code <= 51311) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            } else {
              if (code < 52516) {
                if (code < 51901) {
                  if (code < 51593) {
                    if (code < 51452) {
                      if (code < 51369) {
                        if (code < 51340) {
                          if (code < 51313) {
                            if (51312 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (51313 <= code && code <= 51339) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 51341) {
                            if (51340 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 51368) {
                              if (51341 <= code && code <= 51367) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (51368 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 51397) {
                          if (code < 51396) {
                            if (51369 <= code && code <= 51395) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (51396 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 51424) {
                            if (51397 <= code && code <= 51423) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 51425) {
                              if (51424 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (51425 <= code && code <= 51451) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 51509) {
                        if (code < 51480) {
                          if (code < 51453) {
                            if (51452 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (51453 <= code && code <= 51479) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 51481) {
                            if (51480 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 51508) {
                              if (51481 <= code && code <= 51507) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (51508 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 51564) {
                          if (code < 51536) {
                            if (51509 <= code && code <= 51535) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 51537) {
                              if (51536 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (51537 <= code && code <= 51563) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 51565) {
                            if (51564 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 51592) {
                              if (51565 <= code && code <= 51591) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (51592 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 51760) {
                      if (code < 51676) {
                        if (code < 51621) {
                          if (code < 51620) {
                            if (51593 <= code && code <= 51619) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (51620 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 51648) {
                            if (51621 <= code && code <= 51647) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 51649) {
                              if (51648 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (51649 <= code && code <= 51675) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 51705) {
                          if (code < 51677) {
                            if (51676 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 51704) {
                              if (51677 <= code && code <= 51703) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (51704 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 51732) {
                            if (51705 <= code && code <= 51731) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 51733) {
                              if (51732 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (51733 <= code && code <= 51759) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 51817) {
                        if (code < 51788) {
                          if (code < 51761) {
                            if (51760 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (51761 <= code && code <= 51787) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 51789) {
                            if (51788 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 51816) {
                              if (51789 <= code && code <= 51815) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (51816 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 51872) {
                          if (code < 51844) {
                            if (51817 <= code && code <= 51843) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 51845) {
                              if (51844 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (51845 <= code && code <= 51871) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 51873) {
                            if (51872 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 51900) {
                              if (51873 <= code && code <= 51899) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (51900 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 52208) {
                    if (code < 52041) {
                      if (code < 51984) {
                        if (code < 51929) {
                          if (code < 51928) {
                            if (51901 <= code && code <= 51927) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (51928 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 51956) {
                            if (51929 <= code && code <= 51955) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 51957) {
                              if (51956 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (51957 <= code && code <= 51983) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 52012) {
                          if (code < 51985) {
                            if (51984 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (51985 <= code && code <= 52011) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 52013) {
                            if (52012 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 52040) {
                              if (52013 <= code && code <= 52039) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (52040 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 52124) {
                        if (code < 52069) {
                          if (code < 52068) {
                            if (52041 <= code && code <= 52067) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (52068 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 52096) {
                            if (52069 <= code && code <= 52095) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 52097) {
                              if (52096 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (52097 <= code && code <= 52123) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 52153) {
                          if (code < 52125) {
                            if (52124 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 52152) {
                              if (52125 <= code && code <= 52151) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (52152 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 52180) {
                            if (52153 <= code && code <= 52179) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 52181) {
                              if (52180 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (52181 <= code && code <= 52207) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 52349) {
                      if (code < 52265) {
                        if (code < 52236) {
                          if (code < 52209) {
                            if (52208 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (52209 <= code && code <= 52235) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 52237) {
                            if (52236 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 52264) {
                              if (52237 <= code && code <= 52263) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (52264 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 52320) {
                          if (code < 52292) {
                            if (52265 <= code && code <= 52291) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 52293) {
                              if (52292 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (52293 <= code && code <= 52319) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 52321) {
                            if (52320 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 52348) {
                              if (52321 <= code && code <= 52347) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (52348 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 52432) {
                        if (code < 52377) {
                          if (code < 52376) {
                            if (52349 <= code && code <= 52375) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (52376 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 52404) {
                            if (52377 <= code && code <= 52403) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 52405) {
                              if (52404 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (52405 <= code && code <= 52431) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 52461) {
                          if (code < 52433) {
                            if (52432 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 52460) {
                              if (52433 <= code && code <= 52459) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (52460 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 52488) {
                            if (52461 <= code && code <= 52487) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 52489) {
                              if (52488 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (52489 <= code && code <= 52515) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code < 53105) {
                  if (code < 52797) {
                    if (code < 52656) {
                      if (code < 52573) {
                        if (code < 52544) {
                          if (code < 52517) {
                            if (52516 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (52517 <= code && code <= 52543) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 52545) {
                            if (52544 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 52572) {
                              if (52545 <= code && code <= 52571) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (52572 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 52601) {
                          if (code < 52600) {
                            if (52573 <= code && code <= 52599) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (52600 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 52628) {
                            if (52601 <= code && code <= 52627) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 52629) {
                              if (52628 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (52629 <= code && code <= 52655) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 52713) {
                        if (code < 52684) {
                          if (code < 52657) {
                            if (52656 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (52657 <= code && code <= 52683) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 52685) {
                            if (52684 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 52712) {
                              if (52685 <= code && code <= 52711) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (52712 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 52768) {
                          if (code < 52740) {
                            if (52713 <= code && code <= 52739) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 52741) {
                              if (52740 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (52741 <= code && code <= 52767) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 52769) {
                            if (52768 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 52796) {
                              if (52769 <= code && code <= 52795) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (52796 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 52964) {
                      if (code < 52880) {
                        if (code < 52825) {
                          if (code < 52824) {
                            if (52797 <= code && code <= 52823) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (52824 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 52852) {
                            if (52825 <= code && code <= 52851) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 52853) {
                              if (52852 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (52853 <= code && code <= 52879) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 52909) {
                          if (code < 52881) {
                            if (52880 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 52908) {
                              if (52881 <= code && code <= 52907) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (52908 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 52936) {
                            if (52909 <= code && code <= 52935) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 52937) {
                              if (52936 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (52937 <= code && code <= 52963) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 53021) {
                        if (code < 52992) {
                          if (code < 52965) {
                            if (52964 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (52965 <= code && code <= 52991) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 52993) {
                            if (52992 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 53020) {
                              if (52993 <= code && code <= 53019) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (53020 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 53076) {
                          if (code < 53048) {
                            if (53021 <= code && code <= 53047) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 53049) {
                              if (53048 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (53049 <= code && code <= 53075) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 53077) {
                            if (53076 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 53104) {
                              if (53077 <= code && code <= 53103) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (53104 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 53412) {
                    if (code < 53245) {
                      if (code < 53188) {
                        if (code < 53133) {
                          if (code < 53132) {
                            if (53105 <= code && code <= 53131) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (53132 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 53160) {
                            if (53133 <= code && code <= 53159) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 53161) {
                              if (53160 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (53161 <= code && code <= 53187) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 53216) {
                          if (code < 53189) {
                            if (53188 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (53189 <= code && code <= 53215) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 53217) {
                            if (53216 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 53244) {
                              if (53217 <= code && code <= 53243) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (53244 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 53328) {
                        if (code < 53273) {
                          if (code < 53272) {
                            if (53245 <= code && code <= 53271) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (53272 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 53300) {
                            if (53273 <= code && code <= 53299) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 53301) {
                              if (53300 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (53301 <= code && code <= 53327) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 53357) {
                          if (code < 53329) {
                            if (53328 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 53356) {
                              if (53329 <= code && code <= 53355) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (53356 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 53384) {
                            if (53357 <= code && code <= 53383) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 53385) {
                              if (53384 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (53385 <= code && code <= 53411) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 53553) {
                      if (code < 53469) {
                        if (code < 53440) {
                          if (code < 53413) {
                            if (53412 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (53413 <= code && code <= 53439) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 53441) {
                            if (53440 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 53468) {
                              if (53441 <= code && code <= 53467) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (53468 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 53524) {
                          if (code < 53496) {
                            if (53469 <= code && code <= 53495) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 53497) {
                              if (53496 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (53497 <= code && code <= 53523) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 53525) {
                            if (53524 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 53552) {
                              if (53525 <= code && code <= 53551) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (53552 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 53636) {
                        if (code < 53581) {
                          if (code < 53580) {
                            if (53553 <= code && code <= 53579) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (53580 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 53608) {
                            if (53581 <= code && code <= 53607) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 53609) {
                              if (53608 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (53609 <= code && code <= 53635) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 53665) {
                          if (code < 53637) {
                            if (53636 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 53664) {
                              if (53637 <= code && code <= 53663) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (53664 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 53692) {
                            if (53665 <= code && code <= 53691) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 53693) {
                              if (53692 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (53693 <= code && code <= 53719) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          } else {
            if (code < 70459) {
              if (code < 54897) {
                if (code < 54308) {
                  if (code < 54001) {
                    if (code < 53860) {
                      if (code < 53777) {
                        if (code < 53748) {
                          if (code < 53721) {
                            if (53720 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (53721 <= code && code <= 53747) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 53749) {
                            if (53748 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 53776) {
                              if (53749 <= code && code <= 53775) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (53776 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 53805) {
                          if (code < 53804) {
                            if (53777 <= code && code <= 53803) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (53804 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 53832) {
                            if (53805 <= code && code <= 53831) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 53833) {
                              if (53832 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (53833 <= code && code <= 53859) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 53917) {
                        if (code < 53888) {
                          if (code < 53861) {
                            if (53860 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (53861 <= code && code <= 53887) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 53889) {
                            if (53888 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 53916) {
                              if (53889 <= code && code <= 53915) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (53916 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 53972) {
                          if (code < 53944) {
                            if (53917 <= code && code <= 53943) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 53945) {
                              if (53944 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (53945 <= code && code <= 53971) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 53973) {
                            if (53972 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 54e3) {
                              if (53973 <= code && code <= 53999) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (54e3 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 54141) {
                      if (code < 54084) {
                        if (code < 54029) {
                          if (code < 54028) {
                            if (54001 <= code && code <= 54027) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (54028 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 54056) {
                            if (54029 <= code && code <= 54055) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 54057) {
                              if (54056 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (54057 <= code && code <= 54083) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 54112) {
                          if (code < 54085) {
                            if (54084 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (54085 <= code && code <= 54111) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 54113) {
                            if (54112 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 54140) {
                              if (54113 <= code && code <= 54139) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (54140 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 54224) {
                        if (code < 54169) {
                          if (code < 54168) {
                            if (54141 <= code && code <= 54167) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (54168 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 54196) {
                            if (54169 <= code && code <= 54195) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 54197) {
                              if (54196 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (54197 <= code && code <= 54223) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 54253) {
                          if (code < 54225) {
                            if (54224 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 54252) {
                              if (54225 <= code && code <= 54251) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (54252 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 54280) {
                            if (54253 <= code && code <= 54279) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 54281) {
                              if (54280 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (54281 <= code && code <= 54307) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 54589) {
                    if (code < 54448) {
                      if (code < 54365) {
                        if (code < 54336) {
                          if (code < 54309) {
                            if (54308 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (54309 <= code && code <= 54335) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 54337) {
                            if (54336 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 54364) {
                              if (54337 <= code && code <= 54363) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (54364 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 54393) {
                          if (code < 54392) {
                            if (54365 <= code && code <= 54391) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (54392 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 54420) {
                            if (54393 <= code && code <= 54419) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 54421) {
                              if (54420 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (54421 <= code && code <= 54447) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 54505) {
                        if (code < 54476) {
                          if (code < 54449) {
                            if (54448 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (54449 <= code && code <= 54475) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 54477) {
                            if (54476 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 54504) {
                              if (54477 <= code && code <= 54503) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (54504 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 54560) {
                          if (code < 54532) {
                            if (54505 <= code && code <= 54531) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 54533) {
                              if (54532 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (54533 <= code && code <= 54559) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 54561) {
                            if (54560 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 54588) {
                              if (54561 <= code && code <= 54587) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (54588 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 54756) {
                      if (code < 54672) {
                        if (code < 54617) {
                          if (code < 54616) {
                            if (54589 <= code && code <= 54615) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (54616 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 54644) {
                            if (54617 <= code && code <= 54643) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 54645) {
                              if (54644 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (54645 <= code && code <= 54671) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 54701) {
                          if (code < 54673) {
                            if (54672 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 54700) {
                              if (54673 <= code && code <= 54699) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (54700 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 54728) {
                            if (54701 <= code && code <= 54727) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 54729) {
                              if (54728 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (54729 <= code && code <= 54755) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 54813) {
                        if (code < 54784) {
                          if (code < 54757) {
                            if (54756 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (54757 <= code && code <= 54783) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 54785) {
                            if (54784 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 54812) {
                              if (54785 <= code && code <= 54811) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (54812 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 54868) {
                          if (code < 54840) {
                            if (54813 <= code && code <= 54839) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 54841) {
                              if (54840 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (54841 <= code && code <= 54867) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        } else {
                          if (code < 54869) {
                            if (54868 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 54896) {
                              if (54869 <= code && code <= 54895) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (54896 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code < 69632) {
                  if (code < 55216) {
                    if (code < 55037) {
                      if (code < 54980) {
                        if (code < 54925) {
                          if (code < 54924) {
                            if (54897 <= code && code <= 54923) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (54924 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 54952) {
                            if (54925 <= code && code <= 54951) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 54953) {
                              if (54952 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (54953 <= code && code <= 54979) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 55008) {
                          if (code < 54981) {
                            if (54980 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (54981 <= code && code <= 55007) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          }
                        } else {
                          if (code < 55009) {
                            if (55008 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 55036) {
                              if (55009 <= code && code <= 55035) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (55036 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 55120) {
                        if (code < 55065) {
                          if (code < 55064) {
                            if (55037 <= code && code <= 55063) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (55064 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          }
                        } else {
                          if (code < 55092) {
                            if (55065 <= code && code <= 55091) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 55093) {
                              if (55092 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (55093 <= code && code <= 55119) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 55149) {
                          if (code < 55121) {
                            if (55120 === code) {
                              return boundaries_1.CLUSTER_BREAK.LV;
                            }
                          } else {
                            if (code < 55148) {
                              if (55121 <= code && code <= 55147) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            } else {
                              if (55148 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            }
                          }
                        } else {
                          if (code < 55176) {
                            if (55149 <= code && code <= 55175) {
                              return boundaries_1.CLUSTER_BREAK.LVT;
                            }
                          } else {
                            if (code < 55177) {
                              if (55176 === code) {
                                return boundaries_1.CLUSTER_BREAK.LV;
                              }
                            } else {
                              if (55177 <= code && code <= 55203) {
                                return boundaries_1.CLUSTER_BREAK.LVT;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 68097) {
                      if (code < 65279) {
                        if (code < 64286) {
                          if (code < 55243) {
                            if (55216 <= code && code <= 55238) {
                              return boundaries_1.CLUSTER_BREAK.V;
                            }
                          } else {
                            if (55243 <= code && code <= 55291) {
                              return boundaries_1.CLUSTER_BREAK.T;
                            }
                          }
                        } else {
                          if (code < 65024) {
                            if (64286 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 65056) {
                              if (65024 <= code && code <= 65039) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (65056 <= code && code <= 65071) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 66045) {
                          if (code < 65438) {
                            if (65279 === code) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                          } else {
                            if (code < 65520) {
                              if (65438 <= code && code <= 65439) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (65520 <= code && code <= 65531) {
                                return boundaries_1.CLUSTER_BREAK.CONTROL;
                              }
                            }
                          }
                        } else {
                          if (code < 66272) {
                            if (66045 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 66422) {
                              if (66272 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (66422 <= code && code <= 66426) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 68325) {
                        if (code < 68108) {
                          if (code < 68101) {
                            if (68097 <= code && code <= 68099) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (68101 <= code && code <= 68102) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 68152) {
                            if (68108 <= code && code <= 68111) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 68159) {
                              if (68152 <= code && code <= 68154) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (68159 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 69373) {
                          if (code < 68900) {
                            if (68325 <= code && code <= 68326) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 69291) {
                              if (68900 <= code && code <= 68903) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (69291 <= code && code <= 69292) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 69446) {
                            if (69373 <= code && code <= 69375) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 69506) {
                              if (69446 <= code && code <= 69456) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (69506 <= code && code <= 69509) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 70016) {
                    if (code < 69815) {
                      if (code < 69747) {
                        if (code < 69634) {
                          if (69632 === code) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                          if (69633 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code < 69688) {
                            if (69634 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 69744) {
                              if (69688 <= code && code <= 69702) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (69744 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 69762) {
                          if (code < 69759) {
                            if (69747 <= code && code <= 69748) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (69759 <= code && code <= 69761) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 69808) {
                            if (69762 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 69811) {
                              if (69808 <= code && code <= 69810) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (69811 <= code && code <= 69814) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 69888) {
                        if (code < 69821) {
                          if (code < 69817) {
                            if (69815 <= code && code <= 69816) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (69817 <= code && code <= 69818) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 69826) {
                            if (69821 === code) {
                              return boundaries_1.CLUSTER_BREAK.PREPEND;
                            }
                          } else {
                            if (69826 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (69837 === code) {
                              return boundaries_1.CLUSTER_BREAK.PREPEND;
                            }
                          }
                        }
                      } else {
                        if (code < 69933) {
                          if (code < 69927) {
                            if (69888 <= code && code <= 69890) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 69932) {
                              if (69927 <= code && code <= 69931) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (69932 === code) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        } else {
                          if (code < 69957) {
                            if (69933 <= code && code <= 69940) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 70003) {
                              if (69957 <= code && code <= 69958) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (70003 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 70194) {
                      if (code < 70082) {
                        if (code < 70067) {
                          if (code < 70018) {
                            if (70016 <= code && code <= 70017) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (70018 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 70070) {
                            if (70067 <= code && code <= 70069) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 70079) {
                              if (70070 <= code && code <= 70078) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (70079 <= code && code <= 70080) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 70095) {
                          if (code < 70089) {
                            if (70082 <= code && code <= 70083) {
                              return boundaries_1.CLUSTER_BREAK.PREPEND;
                            }
                          } else {
                            if (code < 70094) {
                              if (70089 <= code && code <= 70092) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (70094 === code) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        } else {
                          if (code < 70188) {
                            if (70095 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 70191) {
                              if (70188 <= code && code <= 70190) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (70191 <= code && code <= 70193) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 70209) {
                        if (code < 70197) {
                          if (code < 70196) {
                            if (70194 <= code && code <= 70195) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (70196 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 70198) {
                            if (70197 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 70206) {
                              if (70198 <= code && code <= 70199) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (70206 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 70371) {
                          if (code < 70367) {
                            if (70209 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 70368) {
                              if (70367 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (70368 <= code && code <= 70370) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        } else {
                          if (code < 70400) {
                            if (70371 <= code && code <= 70378) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 70402) {
                              if (70400 <= code && code <= 70401) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (70402 <= code && code <= 70403) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            } else {
              if (code < 72343) {
                if (code < 71339) {
                  if (code < 70841) {
                    if (code < 70512) {
                      if (code < 70471) {
                        if (code < 70463) {
                          if (code < 70462) {
                            if (70459 <= code && code <= 70460) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (70462 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 70464) {
                            if (70463 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 70465) {
                              if (70464 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (70465 <= code && code <= 70468) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 70487) {
                          if (code < 70475) {
                            if (70471 <= code && code <= 70472) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (70475 <= code && code <= 70477) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 70498) {
                            if (70487 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 70502) {
                              if (70498 <= code && code <= 70499) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (70502 <= code && code <= 70508) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 70725) {
                        if (code < 70712) {
                          if (code < 70709) {
                            if (70512 <= code && code <= 70516) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (70709 <= code && code <= 70711) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 70720) {
                            if (70712 <= code && code <= 70719) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 70722) {
                              if (70720 <= code && code <= 70721) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (70722 <= code && code <= 70724) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 70832) {
                          if (code < 70726) {
                            if (70725 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (70726 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (70750 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 70833) {
                            if (70832 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 70835) {
                              if (70833 <= code && code <= 70834) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (70835 <= code && code <= 70840) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 71096) {
                      if (code < 70847) {
                        if (code < 70843) {
                          if (70841 === code) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                          if (70842 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code < 70845) {
                            if (70843 <= code && code <= 70844) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (70845 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (70846 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        }
                      } else {
                        if (code < 71087) {
                          if (code < 70849) {
                            if (70847 <= code && code <= 70848) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 70850) {
                              if (70849 === code) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (70850 <= code && code <= 70851) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 71088) {
                            if (71087 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 71090) {
                              if (71088 <= code && code <= 71089) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (71090 <= code && code <= 71093) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 71216) {
                        if (code < 71102) {
                          if (code < 71100) {
                            if (71096 <= code && code <= 71099) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (71100 <= code && code <= 71101) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 71103) {
                            if (71102 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 71132) {
                              if (71103 <= code && code <= 71104) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (71132 <= code && code <= 71133) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 71229) {
                          if (code < 71219) {
                            if (71216 <= code && code <= 71218) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 71227) {
                              if (71219 <= code && code <= 71226) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (71227 <= code && code <= 71228) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        } else {
                          if (code < 71230) {
                            if (71229 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 71231) {
                              if (71230 === code) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (71231 <= code && code <= 71232) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 71999) {
                    if (code < 71463) {
                      if (code < 71350) {
                        if (code < 71341) {
                          if (71339 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                          if (71340 === code) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                        } else {
                          if (code < 71342) {
                            if (71341 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 71344) {
                              if (71342 <= code && code <= 71343) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (71344 <= code && code <= 71349) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 71453) {
                          if (71350 === code) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                          if (71351 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code < 71458) {
                            if (71453 <= code && code <= 71455) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 71462) {
                              if (71458 <= code && code <= 71461) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (71462 === code) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 71984) {
                        if (code < 71727) {
                          if (code < 71724) {
                            if (71463 <= code && code <= 71467) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (71724 <= code && code <= 71726) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 71736) {
                            if (71727 <= code && code <= 71735) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 71737) {
                              if (71736 === code) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (71737 <= code && code <= 71738) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 71995) {
                          if (code < 71985) {
                            if (71984 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 71991) {
                              if (71985 <= code && code <= 71989) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (71991 <= code && code <= 71992) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        } else {
                          if (code < 71997) {
                            if (71995 <= code && code <= 71996) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (71997 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                            if (71998 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 72193) {
                      if (code < 72145) {
                        if (code < 72001) {
                          if (71999 === code) {
                            return boundaries_1.CLUSTER_BREAK.PREPEND;
                          }
                          if (72e3 === code) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                        } else {
                          if (code < 72002) {
                            if (72001 === code) {
                              return boundaries_1.CLUSTER_BREAK.PREPEND;
                            }
                          } else {
                            if (72002 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                            if (72003 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      } else {
                        if (code < 72156) {
                          if (code < 72148) {
                            if (72145 <= code && code <= 72147) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 72154) {
                              if (72148 <= code && code <= 72151) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (72154 <= code && code <= 72155) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 72160) {
                            if (72156 <= code && code <= 72159) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (72160 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (72164 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 72263) {
                        if (code < 72249) {
                          if (code < 72243) {
                            if (72193 <= code && code <= 72202) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (72243 <= code && code <= 72248) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 72250) {
                            if (72249 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 72251) {
                              if (72250 === code) {
                                return boundaries_1.CLUSTER_BREAK.PREPEND;
                              }
                            } else {
                              if (72251 <= code && code <= 72254) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 72281) {
                          if (code < 72273) {
                            if (72263 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 72279) {
                              if (72273 <= code && code <= 72278) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (72279 <= code && code <= 72280) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        } else {
                          if (code < 72324) {
                            if (72281 <= code && code <= 72283) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 72330) {
                              if (72324 <= code && code <= 72329) {
                                return boundaries_1.CLUSTER_BREAK.PREPEND;
                              }
                            } else {
                              if (72330 <= code && code <= 72342) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                if (code < 94033) {
                  if (code < 73104) {
                    if (code < 72881) {
                      if (code < 72766) {
                        if (code < 72751) {
                          if (code < 72344) {
                            if (72343 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (72344 <= code && code <= 72345) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 72752) {
                            if (72751 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 72760) {
                              if (72752 <= code && code <= 72758) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (72760 <= code && code <= 72765) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 72850) {
                          if (72766 === code) {
                            return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                          }
                          if (72767 === code) {
                            return boundaries_1.CLUSTER_BREAK.EXTEND;
                          }
                        } else {
                          if (code < 72873) {
                            if (72850 <= code && code <= 72871) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 72874) {
                              if (72873 === code) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (72874 <= code && code <= 72880) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 73018) {
                        if (code < 72884) {
                          if (code < 72882) {
                            if (72881 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (72882 <= code && code <= 72883) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 72885) {
                            if (72884 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (code < 73009) {
                              if (72885 <= code && code <= 72886) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (73009 <= code && code <= 73014) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 73030) {
                          if (code < 73020) {
                            if (73018 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 73023) {
                              if (73020 <= code && code <= 73021) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (73023 <= code && code <= 73029) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 73031) {
                            if (73030 === code) {
                              return boundaries_1.CLUSTER_BREAK.PREPEND;
                            }
                          } else {
                            if (code < 73098) {
                              if (73031 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (73098 <= code && code <= 73102) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 73526) {
                      if (code < 73459) {
                        if (code < 73109) {
                          if (code < 73107) {
                            if (73104 <= code && code <= 73105) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (73107 <= code && code <= 73108) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 73110) {
                            if (73109 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (73110 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                            if (73111 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      } else {
                        if (code < 73474) {
                          if (code < 73461) {
                            if (73459 <= code && code <= 73460) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 73472) {
                              if (73461 <= code && code <= 73462) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (73472 <= code && code <= 73473) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 73475) {
                            if (73474 === code) {
                              return boundaries_1.CLUSTER_BREAK.PREPEND;
                            }
                          } else {
                            if (code < 73524) {
                              if (73475 === code) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (73524 <= code && code <= 73525) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 78896) {
                        if (code < 73536) {
                          if (code < 73534) {
                            if (73526 <= code && code <= 73530) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (73534 <= code && code <= 73535) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 73537) {
                            if (73536 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (73537 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                            if (73538 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        }
                      } else {
                        if (code < 92912) {
                          if (code < 78912) {
                            if (78896 <= code && code <= 78911) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                          } else {
                            if (code < 78919) {
                              if (78912 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (78919 <= code && code <= 78933) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 92976) {
                            if (92912 <= code && code <= 92916) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 94031) {
                              if (92976 <= code && code <= 92982) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (94031 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  if (code < 121476) {
                    if (code < 119143) {
                      if (code < 113824) {
                        if (code < 94180) {
                          if (code < 94095) {
                            if (94033 <= code && code <= 94087) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          } else {
                            if (94095 <= code && code <= 94098) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 94192) {
                            if (94180 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 113821) {
                              if (94192 <= code && code <= 94193) {
                                return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                              }
                            } else {
                              if (113821 <= code && code <= 113822) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 118576) {
                          if (code < 118528) {
                            if (113824 <= code && code <= 113827) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                          } else {
                            if (118528 <= code && code <= 118573) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 119141) {
                            if (118576 <= code && code <= 118598) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (119141 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                            if (119142 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 119173) {
                        if (code < 119150) {
                          if (code < 119149) {
                            if (119143 <= code && code <= 119145) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (119149 === code) {
                              return boundaries_1.CLUSTER_BREAK.SPACINGMARK;
                            }
                          }
                        } else {
                          if (code < 119155) {
                            if (119150 <= code && code <= 119154) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 119163) {
                              if (119155 <= code && code <= 119162) {
                                return boundaries_1.CLUSTER_BREAK.CONTROL;
                              }
                            } else {
                              if (119163 <= code && code <= 119170) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 121344) {
                          if (code < 119210) {
                            if (119173 <= code && code <= 119179) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 119362) {
                              if (119210 <= code && code <= 119213) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (119362 <= code && code <= 119364) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 121403) {
                            if (121344 <= code && code <= 121398) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 121461) {
                              if (121403 <= code && code <= 121452) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (121461 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    if (code < 123628) {
                      if (code < 122907) {
                        if (code < 121505) {
                          if (code < 121499) {
                            if (121476 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (121499 <= code && code <= 121503) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 122880) {
                            if (121505 <= code && code <= 121519) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 122888) {
                              if (122880 <= code && code <= 122886) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (122888 <= code && code <= 122904) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 123023) {
                          if (code < 122915) {
                            if (122907 <= code && code <= 122913) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 122918) {
                              if (122915 <= code && code <= 122916) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (122918 <= code && code <= 122922) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 123184) {
                            if (123023 === code) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 123566) {
                              if (123184 <= code && code <= 123190) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (123566 === code) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (code < 127995) {
                        if (code < 125136) {
                          if (code < 124140) {
                            if (123628 <= code && code <= 123631) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (124140 <= code && code <= 124143) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          }
                        } else {
                          if (code < 125252) {
                            if (125136 <= code && code <= 125142) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 127462) {
                              if (125252 <= code && code <= 125258) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (127462 <= code && code <= 127487) {
                                return boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR;
                              }
                            }
                          }
                        }
                      } else {
                        if (code < 917632) {
                          if (code < 917504) {
                            if (127995 <= code && code <= 127999) {
                              return boundaries_1.CLUSTER_BREAK.EXTEND;
                            }
                          } else {
                            if (code < 917536) {
                              if (917504 <= code && code <= 917535) {
                                return boundaries_1.CLUSTER_BREAK.CONTROL;
                              }
                            } else {
                              if (917536 <= code && code <= 917631) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            }
                          }
                        } else {
                          if (code < 917760) {
                            if (917632 <= code && code <= 917759) {
                              return boundaries_1.CLUSTER_BREAK.CONTROL;
                            }
                          } else {
                            if (code < 918e3) {
                              if (917760 <= code && code <= 917999) {
                                return boundaries_1.CLUSTER_BREAK.EXTEND;
                              }
                            } else {
                              if (918e3 <= code && code <= 921599) {
                                return boundaries_1.CLUSTER_BREAK.CONTROL;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return boundaries_1.CLUSTER_BREAK.OTHER;
      }
      /**
       * Given a Unicode code point, returns if symbol is an extended pictographic or some other break
       * @param code {number} Unicode code point
       * @returns {number}
       */
      static getEmojiProperty(code) {
        if (code < 10160) {
          if (code < 9728) {
            if (code < 9e3) {
              if (code < 8482) {
                if (code < 8252) {
                  if (169 === code) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                  if (174 === code) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                } else {
                  if (8252 === code) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                  if (8265 === code) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                }
              } else {
                if (code < 8596) {
                  if (8482 === code) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                  if (8505 === code) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                } else {
                  if (code < 8617) {
                    if (8596 <= code && code <= 8601) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code < 8986) {
                      if (8617 <= code && code <= 8618) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (8986 <= code && code <= 8987) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              }
            } else {
              if (code < 9410) {
                if (code < 9167) {
                  if (9e3 === code) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                  if (9096 === code) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                } else {
                  if (code < 9193) {
                    if (9167 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code < 9208) {
                      if (9193 <= code && code <= 9203) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (9208 <= code && code <= 9210) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              } else {
                if (code < 9654) {
                  if (code < 9642) {
                    if (9410 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (9642 <= code && code <= 9643) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                } else {
                  if (code < 9664) {
                    if (9654 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code < 9723) {
                      if (9664 === code) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (9723 <= code && code <= 9726) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              }
            }
          } else {
            if (code < 10035) {
              if (code < 10004) {
                if (code < 9748) {
                  if (code < 9735) {
                    if (9728 <= code && code <= 9733) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (9735 <= code && code <= 9746) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                } else {
                  if (code < 9872) {
                    if (9748 <= code && code <= 9861) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code < 9992) {
                      if (9872 <= code && code <= 9989) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (9992 <= code && code <= 10002) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              } else {
                if (code < 10013) {
                  if (10004 === code) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                  if (10006 === code) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                } else {
                  if (code < 10017) {
                    if (10013 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (10017 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                    if (10024 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                }
              }
            } else {
              if (code < 10067) {
                if (code < 10055) {
                  if (code < 10052) {
                    if (10035 <= code && code <= 10036) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (10052 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                } else {
                  if (code < 10060) {
                    if (10055 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (10060 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                    if (10062 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                }
              } else {
                if (code < 10083) {
                  if (code < 10071) {
                    if (10067 <= code && code <= 10069) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (10071 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                } else {
                  if (code < 10133) {
                    if (10083 <= code && code <= 10087) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code < 10145) {
                      if (10133 <= code && code <= 10135) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (10145 === code) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          if (code < 127489) {
            if (code < 12951) {
              if (code < 11035) {
                if (code < 10548) {
                  if (10160 === code) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                  if (10175 === code) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                } else {
                  if (code < 11013) {
                    if (10548 <= code && code <= 10549) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (11013 <= code && code <= 11015) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                }
              } else {
                if (code < 11093) {
                  if (code < 11088) {
                    if (11035 <= code && code <= 11036) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (11088 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                } else {
                  if (code < 12336) {
                    if (11093 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (12336 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                    if (12349 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                }
              }
            } else {
              if (code < 127340) {
                if (code < 126976) {
                  if (12951 === code) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                  if (12953 === code) {
                    return boundaries_1.EXTENDED_PICTOGRAPHIC;
                  }
                } else {
                  if (code < 127245) {
                    if (126976 <= code && code <= 127231) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code < 127279) {
                      if (127245 <= code && code <= 127247) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (127279 === code) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              } else {
                if (code < 127374) {
                  if (code < 127358) {
                    if (127340 <= code && code <= 127345) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (127358 <= code && code <= 127359) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                } else {
                  if (code < 127377) {
                    if (127374 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code < 127405) {
                      if (127377 <= code && code <= 127386) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (127405 <= code && code <= 127461) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              }
            }
          } else {
            if (code < 128981) {
              if (code < 127561) {
                if (code < 127535) {
                  if (code < 127514) {
                    if (127489 <= code && code <= 127503) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (127514 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                } else {
                  if (code < 127538) {
                    if (127535 === code) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code < 127548) {
                      if (127538 <= code && code <= 127546) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (127548 <= code && code <= 127551) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              } else {
                if (code < 128326) {
                  if (code < 128e3) {
                    if (127561 <= code && code <= 127994) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (128e3 <= code && code <= 128317) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                } else {
                  if (code < 128640) {
                    if (128326 <= code && code <= 128591) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code < 128884) {
                      if (128640 <= code && code <= 128767) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (128884 <= code && code <= 128895) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              }
            } else {
              if (code < 129198) {
                if (code < 129096) {
                  if (code < 129036) {
                    if (128981 <= code && code <= 129023) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (129036 <= code && code <= 129039) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                } else {
                  if (code < 129114) {
                    if (129096 <= code && code <= 129103) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code < 129160) {
                      if (129114 <= code && code <= 129119) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (129160 <= code && code <= 129167) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              } else {
                if (code < 129340) {
                  if (code < 129292) {
                    if (129198 <= code && code <= 129279) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (129292 <= code && code <= 129338) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  }
                } else {
                  if (code < 129351) {
                    if (129340 <= code && code <= 129349) {
                      return boundaries_1.EXTENDED_PICTOGRAPHIC;
                    }
                  } else {
                    if (code < 130048) {
                      if (129351 <= code && code <= 129791) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    } else {
                      if (130048 <= code && code <= 131069) {
                        return boundaries_1.EXTENDED_PICTOGRAPHIC;
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return boundaries_1.CLUSTER_BREAK.OTHER;
      }
    };
    exports.default = Graphemer;
  }
});

// ../../node_modules/graphemer/lib/index.js
var require_lib4 = __commonJS({
  "../../node_modules/graphemer/lib/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var Graphemer_1 = __importDefault(require_Graphemer());
    exports.default = Graphemer_1.default;
  }
});

// ../../node_modules/eslint/lib/shared/string-utils.js
var require_string_utils = __commonJS({
  "../../node_modules/eslint/lib/shared/string-utils.js"(exports, module) {
    "use strict";
    var Graphemer = require_lib4().default;
    var ASCII_REGEX = /^[\u0000-\u007f]*$/u;
    var splitter;
    function upperCaseFirst(string) {
      if (string.length <= 1) {
        return string.toUpperCase();
      }
      return string[0].toUpperCase() + string.slice(1);
    }
    function getGraphemeCount(value) {
      if (ASCII_REGEX.test(value)) {
        return value.length;
      }
      if (!splitter) {
        splitter = new Graphemer();
      }
      return splitter.countGraphemes(value);
    }
    module.exports = {
      upperCaseFirst,
      getGraphemeCount
    };
  }
});

// ../../node_modules/eslint/lib/rules/complexity.js
var require_complexity = __commonJS({
  "../../node_modules/eslint/lib/rules/complexity.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var { upperCaseFirst } = require_string_utils();
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Enforce a maximum cyclomatic complexity allowed in a program",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/complexity"
        },
        schema: [
          {
            oneOf: [
              {
                type: "integer",
                minimum: 0
              },
              {
                type: "object",
                properties: {
                  maximum: {
                    type: "integer",
                    minimum: 0
                  },
                  max: {
                    type: "integer",
                    minimum: 0
                  }
                },
                additionalProperties: false
              }
            ]
          }
        ],
        messages: {
          complex: "{{name}} has a complexity of {{complexity}}. Maximum allowed is {{max}}."
        }
      },
      create(context) {
        const option = context.options[0];
        let THRESHOLD = 20;
        if (typeof option === "object" && (Object.prototype.hasOwnProperty.call(option, "maximum") || Object.prototype.hasOwnProperty.call(option, "max"))) {
          THRESHOLD = option.maximum || option.max;
        } else if (typeof option === "number") {
          THRESHOLD = option;
        }
        const complexities = [];
        function increaseComplexity() {
          complexities[complexities.length - 1]++;
        }
        return {
          onCodePathStart() {
            complexities.push(1);
          },
          // Each branching in the code adds 1 to the complexity
          CatchClause: increaseComplexity,
          ConditionalExpression: increaseComplexity,
          LogicalExpression: increaseComplexity,
          ForStatement: increaseComplexity,
          ForInStatement: increaseComplexity,
          ForOfStatement: increaseComplexity,
          IfStatement: increaseComplexity,
          WhileStatement: increaseComplexity,
          DoWhileStatement: increaseComplexity,
          // Avoid `default`
          "SwitchCase[test]": increaseComplexity,
          // Logical assignment operators have short-circuiting behavior
          AssignmentExpression(node) {
            if (astUtils.isLogicalAssignmentOperator(node.operator)) {
              increaseComplexity();
            }
          },
          onCodePathEnd(codePath, node) {
            const complexity = complexities.pop();
            if (codePath.origin !== "function" && codePath.origin !== "class-field-initializer" && codePath.origin !== "class-static-block") {
              return;
            }
            if (complexity > THRESHOLD) {
              let name;
              if (codePath.origin === "class-field-initializer") {
                name = "class field initializer";
              } else if (codePath.origin === "class-static-block") {
                name = "class static block";
              } else {
                name = astUtils.getFunctionNameWithKind(node);
              }
              context.report({
                node,
                messageId: "complex",
                data: {
                  name: upperCaseFirst(name),
                  complexity,
                  max: THRESHOLD
                }
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/computed-property-spacing.js
var require_computed_property_spacing = __commonJS({
  "../../node_modules/eslint/lib/rules/computed-property-spacing.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Enforce consistent spacing inside computed property brackets",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/computed-property-spacing"
        },
        fixable: "whitespace",
        schema: [
          {
            enum: ["always", "never"]
          },
          {
            type: "object",
            properties: {
              enforceForClassMembers: {
                type: "boolean",
                default: true
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          unexpectedSpaceBefore: "There should be no space before '{{tokenValue}}'.",
          unexpectedSpaceAfter: "There should be no space after '{{tokenValue}}'.",
          missingSpaceBefore: "A space is required before '{{tokenValue}}'.",
          missingSpaceAfter: "A space is required after '{{tokenValue}}'."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        const propertyNameMustBeSpaced = context.options[0] === "always";
        const enforceForClassMembers = !context.options[1] || context.options[1].enforceForClassMembers;
        function reportNoBeginningSpace(node, token, tokenAfter) {
          context.report({
            node,
            loc: { start: token.loc.end, end: tokenAfter.loc.start },
            messageId: "unexpectedSpaceAfter",
            data: {
              tokenValue: token.value
            },
            fix(fixer) {
              return fixer.removeRange([token.range[1], tokenAfter.range[0]]);
            }
          });
        }
        function reportNoEndingSpace(node, token, tokenBefore) {
          context.report({
            node,
            loc: { start: tokenBefore.loc.end, end: token.loc.start },
            messageId: "unexpectedSpaceBefore",
            data: {
              tokenValue: token.value
            },
            fix(fixer) {
              return fixer.removeRange([tokenBefore.range[1], token.range[0]]);
            }
          });
        }
        function reportRequiredBeginningSpace(node, token) {
          context.report({
            node,
            loc: token.loc,
            messageId: "missingSpaceAfter",
            data: {
              tokenValue: token.value
            },
            fix(fixer) {
              return fixer.insertTextAfter(token, " ");
            }
          });
        }
        function reportRequiredEndingSpace(node, token) {
          context.report({
            node,
            loc: token.loc,
            messageId: "missingSpaceBefore",
            data: {
              tokenValue: token.value
            },
            fix(fixer) {
              return fixer.insertTextBefore(token, " ");
            }
          });
        }
        function checkSpacing(propertyName) {
          return function(node) {
            if (!node.computed) {
              return;
            }
            const property = node[propertyName];
            const before = sourceCode.getTokenBefore(property, astUtils.isOpeningBracketToken), first = sourceCode.getTokenAfter(before, { includeComments: true }), after = sourceCode.getTokenAfter(property, astUtils.isClosingBracketToken), last = sourceCode.getTokenBefore(after, { includeComments: true });
            if (astUtils.isTokenOnSameLine(before, first)) {
              if (propertyNameMustBeSpaced) {
                if (!sourceCode.isSpaceBetweenTokens(before, first) && astUtils.isTokenOnSameLine(before, first)) {
                  reportRequiredBeginningSpace(node, before);
                }
              } else {
                if (sourceCode.isSpaceBetweenTokens(before, first)) {
                  reportNoBeginningSpace(node, before, first);
                }
              }
            }
            if (astUtils.isTokenOnSameLine(last, after)) {
              if (propertyNameMustBeSpaced) {
                if (!sourceCode.isSpaceBetweenTokens(last, after) && astUtils.isTokenOnSameLine(last, after)) {
                  reportRequiredEndingSpace(node, after);
                }
              } else {
                if (sourceCode.isSpaceBetweenTokens(last, after)) {
                  reportNoEndingSpace(node, after, last);
                }
              }
            }
          };
        }
        const listeners = {
          Property: checkSpacing("key"),
          MemberExpression: checkSpacing("property")
        };
        if (enforceForClassMembers) {
          listeners.MethodDefinition = listeners.PropertyDefinition = listeners.Property;
        }
        return listeners;
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/consistent-return.js
var require_consistent_return = __commonJS({
  "../../node_modules/eslint/lib/rules/consistent-return.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var { upperCaseFirst } = require_string_utils();
    function isUnreachable(segment) {
      return !segment.reachable;
    }
    function isClassConstructor(node) {
      return node.type === "FunctionExpression" && node.parent && node.parent.type === "MethodDefinition" && node.parent.kind === "constructor";
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Require `return` statements to either always or never specify values",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/consistent-return"
        },
        schema: [{
          type: "object",
          properties: {
            treatUndefinedAsUnspecified: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }],
        messages: {
          missingReturn: "Expected to return a value at the end of {{name}}.",
          missingReturnValue: "{{name}} expected a return value.",
          unexpectedReturnValue: "{{name}} expected no return value."
        }
      },
      create(context) {
        const options = context.options[0] || {};
        const treatUndefinedAsUnspecified = options.treatUndefinedAsUnspecified === true;
        let funcInfo = null;
        function checkLastSegment(node) {
          let loc, name;
          if (!funcInfo.hasReturnValue || funcInfo.codePath.currentSegments.every(isUnreachable) || astUtils.isES5Constructor(node) || isClassConstructor(node)) {
            return;
          }
          if (node.type === "Program") {
            loc = { line: 1, column: 0 };
            name = "program";
          } else if (node.type === "ArrowFunctionExpression") {
            loc = context.sourceCode.getTokenBefore(node.body, astUtils.isArrowToken).loc;
          } else if (node.parent.type === "MethodDefinition" || node.parent.type === "Property" && node.parent.method) {
            loc = node.parent.key.loc;
          } else {
            loc = (node.id || context.sourceCode.getFirstToken(node)).loc;
          }
          if (!name) {
            name = astUtils.getFunctionNameWithKind(node);
          }
          context.report({
            node,
            loc,
            messageId: "missingReturn",
            data: { name }
          });
        }
        return {
          // Initializes/Disposes state of each code path.
          onCodePathStart(codePath, node) {
            funcInfo = {
              upper: funcInfo,
              codePath,
              hasReturn: false,
              hasReturnValue: false,
              messageId: "",
              node
            };
          },
          onCodePathEnd() {
            funcInfo = funcInfo.upper;
          },
          // Reports a given return statement if it's inconsistent.
          ReturnStatement(node) {
            const argument = node.argument;
            let hasReturnValue = Boolean(argument);
            if (treatUndefinedAsUnspecified && hasReturnValue) {
              hasReturnValue = !astUtils.isSpecificId(argument, "undefined") && argument.operator !== "void";
            }
            if (!funcInfo.hasReturn) {
              funcInfo.hasReturn = true;
              funcInfo.hasReturnValue = hasReturnValue;
              funcInfo.messageId = hasReturnValue ? "missingReturnValue" : "unexpectedReturnValue";
              funcInfo.data = {
                name: funcInfo.node.type === "Program" ? "Program" : upperCaseFirst(astUtils.getFunctionNameWithKind(funcInfo.node))
              };
            } else if (funcInfo.hasReturnValue !== hasReturnValue) {
              context.report({
                node,
                messageId: funcInfo.messageId,
                data: funcInfo.data
              });
            }
          },
          // Reports a given program/function if the implicit returning is not consistent.
          "Program:exit": checkLastSegment,
          "FunctionDeclaration:exit": checkLastSegment,
          "FunctionExpression:exit": checkLastSegment,
          "ArrowFunctionExpression:exit": checkLastSegment
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/consistent-this.js
var require_consistent_this = __commonJS({
  "../../node_modules/eslint/lib/rules/consistent-this.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Enforce consistent naming when capturing the current execution context",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/consistent-this"
        },
        schema: {
          type: "array",
          items: {
            type: "string",
            minLength: 1
          },
          uniqueItems: true
        },
        messages: {
          aliasNotAssignedToThis: "Designated alias '{{name}}' is not assigned to 'this'.",
          unexpectedAlias: "Unexpected alias '{{name}}' for 'this'."
        }
      },
      create(context) {
        let aliases = [];
        const sourceCode = context.sourceCode;
        if (context.options.length === 0) {
          aliases.push("that");
        } else {
          aliases = context.options;
        }
        function reportBadAssignment(node, name) {
          context.report({ node, messageId: "aliasNotAssignedToThis", data: { name } });
        }
        function checkAssignment(node, name, value) {
          const isThis = value.type === "ThisExpression";
          if (aliases.includes(name)) {
            if (!isThis || node.operator && node.operator !== "=") {
              reportBadAssignment(node, name);
            }
          } else if (isThis) {
            context.report({ node, messageId: "unexpectedAlias", data: { name } });
          }
        }
        function checkWasAssigned(alias, scope) {
          const variable = scope.set.get(alias);
          if (!variable) {
            return;
          }
          if (variable.defs.some((def) => def.node.type === "VariableDeclarator" && def.node.init !== null)) {
            return;
          }
          if (!variable.references.some((reference) => {
            const write = reference.writeExpr;
            return reference.from === scope && write && write.type === "ThisExpression" && write.parent.operator === "=";
          })) {
            variable.defs.map((def) => def.node).forEach((node) => {
              reportBadAssignment(node, alias);
            });
          }
        }
        function ensureWasAssigned(node) {
          const scope = sourceCode.getScope(node);
          aliases.forEach((alias) => {
            checkWasAssigned(alias, scope);
          });
        }
        return {
          "Program:exit": ensureWasAssigned,
          "FunctionExpression:exit": ensureWasAssigned,
          "FunctionDeclaration:exit": ensureWasAssigned,
          VariableDeclarator(node) {
            const id = node.id;
            const isDestructuring = id.type === "ArrayPattern" || id.type === "ObjectPattern";
            if (node.init !== null && !isDestructuring) {
              checkAssignment(node, id.name, node.init);
            }
          },
          AssignmentExpression(node) {
            if (node.left.type === "Identifier") {
              checkAssignment(node, node.left.name, node.right);
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/constructor-super.js
var require_constructor_super = __commonJS({
  "../../node_modules/eslint/lib/rules/constructor-super.js"(exports, module) {
    "use strict";
    function isReachable(segment) {
      return segment.reachable;
    }
    function isConstructorFunction(node) {
      return node.type === "FunctionExpression" && node.parent.type === "MethodDefinition" && node.parent.kind === "constructor";
    }
    function isPossibleConstructor(node) {
      if (!node) {
        return false;
      }
      switch (node.type) {
        case "ClassExpression":
        case "FunctionExpression":
        case "ThisExpression":
        case "MemberExpression":
        case "CallExpression":
        case "NewExpression":
        case "ChainExpression":
        case "YieldExpression":
        case "TaggedTemplateExpression":
        case "MetaProperty":
          return true;
        case "Identifier":
          return node.name !== "undefined";
        case "AssignmentExpression":
          if (["=", "&&="].includes(node.operator)) {
            return isPossibleConstructor(node.right);
          }
          if (["||=", "??="].includes(node.operator)) {
            return isPossibleConstructor(node.left) || isPossibleConstructor(node.right);
          }
          return false;
        case "LogicalExpression":
          if (node.operator === "&&") {
            return isPossibleConstructor(node.right);
          }
          return isPossibleConstructor(node.left) || isPossibleConstructor(node.right);
        case "ConditionalExpression":
          return isPossibleConstructor(node.alternate) || isPossibleConstructor(node.consequent);
        case "SequenceExpression": {
          const lastExpression = node.expressions[node.expressions.length - 1];
          return isPossibleConstructor(lastExpression);
        }
        default:
          return false;
      }
    }
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Require `super()` calls in constructors",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/constructor-super"
        },
        schema: [],
        messages: {
          missingSome: "Lacked a call of 'super()' in some code paths.",
          missingAll: "Expected to call 'super()'.",
          duplicate: "Unexpected duplicate 'super()'.",
          badSuper: "Unexpected 'super()' because 'super' is not a constructor.",
          unexpected: "Unexpected 'super()'."
        }
      },
      create(context) {
        let funcInfo = null;
        let segInfoMap = /* @__PURE__ */ Object.create(null);
        function isCalledInSomePath(segment) {
          return segment.reachable && segInfoMap[segment.id].calledInSomePaths;
        }
        function isCalledInEveryPath(segment) {
          if (segment.nextSegments.length === 1 && segment.nextSegments[0].isLoopedPrevSegment(segment)) {
            return true;
          }
          return segment.reachable && segInfoMap[segment.id].calledInEveryPaths;
        }
        return {
          /**
           * Stacks a constructor information.
           * @param {CodePath} codePath A code path which was started.
           * @param {ASTNode} node The current node.
           * @returns {void}
           */
          onCodePathStart(codePath, node) {
            if (isConstructorFunction(node)) {
              const classNode = node.parent.parent.parent;
              const superClass = classNode.superClass;
              funcInfo = {
                upper: funcInfo,
                isConstructor: true,
                hasExtends: Boolean(superClass),
                superIsConstructor: isPossibleConstructor(superClass),
                codePath
              };
            } else {
              funcInfo = {
                upper: funcInfo,
                isConstructor: false,
                hasExtends: false,
                superIsConstructor: false,
                codePath
              };
            }
          },
          /**
           * Pops a constructor information.
           * And reports if `super()` lacked.
           * @param {CodePath} codePath A code path which was ended.
           * @param {ASTNode} node The current node.
           * @returns {void}
           */
          onCodePathEnd(codePath, node) {
            const hasExtends = funcInfo.hasExtends;
            funcInfo = funcInfo.upper;
            if (!hasExtends) {
              return;
            }
            const segments = codePath.returnedSegments;
            const calledInEveryPaths = segments.every(isCalledInEveryPath);
            const calledInSomePaths = segments.some(isCalledInSomePath);
            if (!calledInEveryPaths) {
              context.report({
                messageId: calledInSomePaths ? "missingSome" : "missingAll",
                node: node.parent
              });
            }
          },
          /**
           * Initialize information of a given code path segment.
           * @param {CodePathSegment} segment A code path segment to initialize.
           * @returns {void}
           */
          onCodePathSegmentStart(segment) {
            if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {
              return;
            }
            const info = segInfoMap[segment.id] = {
              calledInSomePaths: false,
              calledInEveryPaths: false,
              validNodes: []
            };
            const prevSegments = segment.prevSegments;
            if (prevSegments.length > 0) {
              info.calledInSomePaths = prevSegments.some(isCalledInSomePath);
              info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);
            }
          },
          /**
           * Update information of the code path segment when a code path was
           * looped.
           * @param {CodePathSegment} fromSegment The code path segment of the
           *      end of a loop.
           * @param {CodePathSegment} toSegment A code path segment of the head
           *      of a loop.
           * @returns {void}
           */
          onCodePathSegmentLoop(fromSegment, toSegment) {
            if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {
              return;
            }
            const isRealLoop = toSegment.prevSegments.length >= 2;
            funcInfo.codePath.traverseSegments(
              { first: toSegment, last: fromSegment },
              (segment) => {
                const info = segInfoMap[segment.id];
                const prevSegments = segment.prevSegments;
                info.calledInSomePaths = prevSegments.some(isCalledInSomePath);
                info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);
                if (info.calledInSomePaths || isRealLoop) {
                  const nodes = info.validNodes;
                  info.validNodes = [];
                  for (let i = 0; i < nodes.length; ++i) {
                    const node = nodes[i];
                    context.report({
                      messageId: "duplicate",
                      node
                    });
                  }
                }
              }
            );
          },
          /**
           * Checks for a call of `super()`.
           * @param {ASTNode} node A CallExpression node to check.
           * @returns {void}
           */
          "CallExpression:exit"(node) {
            if (!(funcInfo && funcInfo.isConstructor)) {
              return;
            }
            if (node.callee.type !== "Super") {
              return;
            }
            if (funcInfo.hasExtends) {
              const segments = funcInfo.codePath.currentSegments;
              let duplicate = false;
              let info = null;
              for (let i = 0; i < segments.length; ++i) {
                const segment = segments[i];
                if (segment.reachable) {
                  info = segInfoMap[segment.id];
                  duplicate = duplicate || info.calledInSomePaths;
                  info.calledInSomePaths = info.calledInEveryPaths = true;
                }
              }
              if (info) {
                if (duplicate) {
                  context.report({
                    messageId: "duplicate",
                    node
                  });
                } else if (!funcInfo.superIsConstructor) {
                  context.report({
                    messageId: "badSuper",
                    node
                  });
                } else {
                  info.validNodes.push(node);
                }
              }
            } else if (funcInfo.codePath.currentSegments.some(isReachable)) {
              context.report({
                messageId: "unexpected",
                node
              });
            }
          },
          /**
           * Set the mark to the returned path as `super()` was called.
           * @param {ASTNode} node A ReturnStatement node to check.
           * @returns {void}
           */
          ReturnStatement(node) {
            if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {
              return;
            }
            if (!node.argument) {
              return;
            }
            const segments = funcInfo.codePath.currentSegments;
            for (let i = 0; i < segments.length; ++i) {
              const segment = segments[i];
              if (segment.reachable) {
                const info = segInfoMap[segment.id];
                info.calledInSomePaths = info.calledInEveryPaths = true;
              }
            }
          },
          /**
           * Resets state.
           * @returns {void}
           */
          "Program:exit"() {
            segInfoMap = /* @__PURE__ */ Object.create(null);
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/curly.js
var require_curly = __commonJS({
  "../../node_modules/eslint/lib/rules/curly.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Enforce consistent brace style for all control statements",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/curly"
        },
        schema: {
          anyOf: [
            {
              type: "array",
              items: [
                {
                  enum: ["all"]
                }
              ],
              minItems: 0,
              maxItems: 1
            },
            {
              type: "array",
              items: [
                {
                  enum: ["multi", "multi-line", "multi-or-nest"]
                },
                {
                  enum: ["consistent"]
                }
              ],
              minItems: 0,
              maxItems: 2
            }
          ]
        },
        fixable: "code",
        messages: {
          missingCurlyAfter: "Expected { after '{{name}}'.",
          missingCurlyAfterCondition: "Expected { after '{{name}}' condition.",
          unexpectedCurlyAfter: "Unnecessary { after '{{name}}'.",
          unexpectedCurlyAfterCondition: "Unnecessary { after '{{name}}' condition."
        }
      },
      create(context) {
        const multiOnly = context.options[0] === "multi";
        const multiLine = context.options[0] === "multi-line";
        const multiOrNest = context.options[0] === "multi-or-nest";
        const consistent = context.options[1] === "consistent";
        const sourceCode = context.sourceCode;
        function isCollapsedOneLiner(node) {
          const before = sourceCode.getTokenBefore(node);
          const last = sourceCode.getLastToken(node);
          const lastExcludingSemicolon = astUtils.isSemicolonToken(last) ? sourceCode.getTokenBefore(last) : last;
          return before.loc.start.line === lastExcludingSemicolon.loc.end.line;
        }
        function isOneLiner(node) {
          if (node.type === "EmptyStatement") {
            return true;
          }
          const first = sourceCode.getFirstToken(node);
          const last = sourceCode.getLastToken(node);
          const lastExcludingSemicolon = astUtils.isSemicolonToken(last) ? sourceCode.getTokenBefore(last) : last;
          return first.loc.start.line === lastExcludingSemicolon.loc.end.line;
        }
        function isLexicalDeclaration(node) {
          if (node.type === "VariableDeclaration") {
            return node.kind === "const" || node.kind === "let";
          }
          return node.type === "FunctionDeclaration" || node.type === "ClassDeclaration";
        }
        function isElseKeywordToken(token) {
          return token.value === "else" && token.type === "Keyword";
        }
        function isFollowedByElseKeyword(node) {
          const nextToken = sourceCode.getTokenAfter(node);
          return Boolean(nextToken) && isElseKeywordToken(nextToken);
        }
        function needsSemicolon(closingBracket) {
          const tokenBefore = sourceCode.getTokenBefore(closingBracket);
          const tokenAfter = sourceCode.getTokenAfter(closingBracket);
          const lastBlockNode = sourceCode.getNodeByRangeIndex(tokenBefore.range[0]);
          if (astUtils.isSemicolonToken(tokenBefore)) {
            return false;
          }
          if (!tokenAfter) {
            return false;
          }
          if (lastBlockNode.type === "BlockStatement" && lastBlockNode.parent.type !== "FunctionExpression" && lastBlockNode.parent.type !== "ArrowFunctionExpression") {
            return false;
          }
          if (tokenBefore.loc.end.line === tokenAfter.loc.start.line) {
            return true;
          }
          if (/^[([/`+-]/u.test(tokenAfter.value)) {
            return true;
          }
          if (tokenBefore.type === "Punctuator" && (tokenBefore.value === "++" || tokenBefore.value === "--")) {
            return true;
          }
          return false;
        }
        function hasUnsafeIf(node) {
          switch (node.type) {
            case "IfStatement":
              if (!node.alternate) {
                return true;
              }
              return hasUnsafeIf(node.alternate);
            case "ForStatement":
            case "ForInStatement":
            case "ForOfStatement":
            case "LabeledStatement":
            case "WithStatement":
            case "WhileStatement":
              return hasUnsafeIf(node.body);
            default:
              return false;
          }
        }
        function areBracesNecessary(node) {
          const statement = node.body[0];
          return isLexicalDeclaration(statement) || hasUnsafeIf(statement) && isFollowedByElseKeyword(node);
        }
        function prepareCheck(node, body, name, opts) {
          const hasBlock = body.type === "BlockStatement";
          let expected = null;
          if (hasBlock && (body.body.length !== 1 || areBracesNecessary(body))) {
            expected = true;
          } else if (multiOnly) {
            expected = false;
          } else if (multiLine) {
            if (!isCollapsedOneLiner(body)) {
              expected = true;
            }
          } else if (multiOrNest) {
            if (hasBlock) {
              const statement = body.body[0];
              const leadingCommentsInBlock = sourceCode.getCommentsBefore(statement);
              expected = !isOneLiner(statement) || leadingCommentsInBlock.length > 0;
            } else {
              expected = !isOneLiner(body);
            }
          } else {
            expected = true;
          }
          return {
            actual: hasBlock,
            expected,
            check() {
              if (this.expected !== null && this.expected !== this.actual) {
                if (this.expected) {
                  context.report({
                    node,
                    loc: body.loc,
                    messageId: opts && opts.condition ? "missingCurlyAfterCondition" : "missingCurlyAfter",
                    data: {
                      name
                    },
                    fix: (fixer) => fixer.replaceText(body, `{${sourceCode.getText(body)}}`)
                  });
                } else {
                  context.report({
                    node,
                    loc: body.loc,
                    messageId: opts && opts.condition ? "unexpectedCurlyAfterCondition" : "unexpectedCurlyAfter",
                    data: {
                      name
                    },
                    fix(fixer) {
                      const needsPrecedingSpace = node.type === "DoWhileStatement" && sourceCode.getTokenBefore(body).range[1] === body.range[0] && !astUtils.canTokensBeAdjacent("do", sourceCode.getFirstToken(body, { skip: 1 }));
                      const openingBracket = sourceCode.getFirstToken(body);
                      const closingBracket = sourceCode.getLastToken(body);
                      const lastTokenInBlock = sourceCode.getTokenBefore(closingBracket);
                      if (needsSemicolon(closingBracket)) {
                        return null;
                      }
                      const resultingBodyText = sourceCode.getText().slice(openingBracket.range[1], lastTokenInBlock.range[0]) + sourceCode.getText(lastTokenInBlock) + sourceCode.getText().slice(lastTokenInBlock.range[1], closingBracket.range[0]);
                      return fixer.replaceText(body, (needsPrecedingSpace ? " " : "") + resultingBodyText);
                    }
                  });
                }
              }
            }
          };
        }
        function prepareIfChecks(node) {
          const preparedChecks = [];
          for (let currentNode = node; currentNode; currentNode = currentNode.alternate) {
            preparedChecks.push(prepareCheck(currentNode, currentNode.consequent, "if", { condition: true }));
            if (currentNode.alternate && currentNode.alternate.type !== "IfStatement") {
              preparedChecks.push(prepareCheck(currentNode, currentNode.alternate, "else"));
              break;
            }
          }
          if (consistent) {
            const expected = preparedChecks.some((preparedCheck) => {
              if (preparedCheck.expected !== null) {
                return preparedCheck.expected;
              }
              return preparedCheck.actual;
            });
            preparedChecks.forEach((preparedCheck) => {
              preparedCheck.expected = expected;
            });
          }
          return preparedChecks;
        }
        return {
          IfStatement(node) {
            const parent = node.parent;
            const isElseIf = parent.type === "IfStatement" && parent.alternate === node;
            if (!isElseIf) {
              prepareIfChecks(node).forEach((preparedCheck) => {
                preparedCheck.check();
              });
            }
          },
          WhileStatement(node) {
            prepareCheck(node, node.body, "while", { condition: true }).check();
          },
          DoWhileStatement(node) {
            prepareCheck(node, node.body, "do").check();
          },
          ForStatement(node) {
            prepareCheck(node, node.body, "for", { condition: true }).check();
          },
          ForInStatement(node) {
            prepareCheck(node, node.body, "for-in").check();
          },
          ForOfStatement(node) {
            prepareCheck(node, node.body, "for-of").check();
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/default-case.js
var require_default_case = __commonJS({
  "../../node_modules/eslint/lib/rules/default-case.js"(exports, module) {
    "use strict";
    var DEFAULT_COMMENT_PATTERN = /^no default$/iu;
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Require `default` cases in `switch` statements",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/default-case"
        },
        schema: [{
          type: "object",
          properties: {
            commentPattern: {
              type: "string"
            }
          },
          additionalProperties: false
        }],
        messages: {
          missingDefaultCase: "Expected a default case."
        }
      },
      create(context) {
        const options = context.options[0] || {};
        const commentPattern = options.commentPattern ? new RegExp(options.commentPattern, "u") : DEFAULT_COMMENT_PATTERN;
        const sourceCode = context.sourceCode;
        function last(collection) {
          return collection[collection.length - 1];
        }
        return {
          SwitchStatement(node) {
            if (!node.cases.length) {
              return;
            }
            const hasDefault = node.cases.some((v) => v.test === null);
            if (!hasDefault) {
              let comment;
              const lastCase = last(node.cases);
              const comments = sourceCode.getCommentsAfter(lastCase);
              if (comments.length) {
                comment = last(comments);
              }
              if (!comment || !commentPattern.test(comment.value.trim())) {
                context.report({ node, messageId: "missingDefaultCase" });
              }
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/default-case-last.js
var require_default_case_last = __commonJS({
  "../../node_modules/eslint/lib/rules/default-case-last.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Enforce default clauses in switch statements to be last",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/default-case-last"
        },
        schema: [],
        messages: {
          notLast: "Default clause should be the last clause."
        }
      },
      create(context) {
        return {
          SwitchStatement(node) {
            const cases = node.cases, indexOfDefault = cases.findIndex((c) => c.test === null);
            if (indexOfDefault !== -1 && indexOfDefault !== cases.length - 1) {
              const defaultClause = cases[indexOfDefault];
              context.report({ node: defaultClause, messageId: "notLast" });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/default-param-last.js
var require_default_param_last = __commonJS({
  "../../node_modules/eslint/lib/rules/default-param-last.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Enforce default parameters to be last",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/default-param-last"
        },
        schema: [],
        messages: {
          shouldBeLast: "Default parameters should be last."
        }
      },
      create(context) {
        function handleFunction(node) {
          let hasSeenPlainParam = false;
          for (let i = node.params.length - 1; i >= 0; i -= 1) {
            const param = node.params[i];
            if (param.type !== "AssignmentPattern" && param.type !== "RestElement") {
              hasSeenPlainParam = true;
              continue;
            }
            if (hasSeenPlainParam && param.type === "AssignmentPattern") {
              context.report({
                node: param,
                messageId: "shouldBeLast"
              });
            }
          }
        }
        return {
          FunctionDeclaration: handleFunction,
          FunctionExpression: handleFunction,
          ArrowFunctionExpression: handleFunction
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/dot-location.js
var require_dot_location = __commonJS({
  "../../node_modules/eslint/lib/rules/dot-location.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Enforce consistent newlines before and after dots",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/dot-location"
        },
        schema: [
          {
            enum: ["object", "property"]
          }
        ],
        fixable: "code",
        messages: {
          expectedDotAfterObject: "Expected dot to be on same line as object.",
          expectedDotBeforeProperty: "Expected dot to be on same line as property."
        }
      },
      create(context) {
        const config = context.options[0];
        const onObject = config === "object" || !config;
        const sourceCode = context.sourceCode;
        function checkDotLocation(node) {
          const property = node.property;
          const dotToken = sourceCode.getTokenBefore(property);
          if (onObject) {
            const tokenBeforeDot = sourceCode.getTokenBefore(dotToken);
            if (!astUtils.isTokenOnSameLine(tokenBeforeDot, dotToken)) {
              context.report({
                node,
                loc: dotToken.loc,
                messageId: "expectedDotAfterObject",
                *fix(fixer) {
                  if (dotToken.value.startsWith(".") && astUtils.isDecimalIntegerNumericToken(tokenBeforeDot)) {
                    yield fixer.insertTextAfter(tokenBeforeDot, ` ${dotToken.value}`);
                  } else {
                    yield fixer.insertTextAfter(tokenBeforeDot, dotToken.value);
                  }
                  yield fixer.remove(dotToken);
                }
              });
            }
          } else if (!astUtils.isTokenOnSameLine(dotToken, property)) {
            context.report({
              node,
              loc: dotToken.loc,
              messageId: "expectedDotBeforeProperty",
              *fix(fixer) {
                yield fixer.remove(dotToken);
                yield fixer.insertTextBefore(property, dotToken.value);
              }
            });
          }
        }
        function checkNode(node) {
          if (!node.computed) {
            checkDotLocation(node);
          }
        }
        return {
          MemberExpression: checkNode
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/utils/keywords.js
var require_keywords = __commonJS({
  "../../node_modules/eslint/lib/rules/utils/keywords.js"(exports, module) {
    "use strict";
    module.exports = [
      "abstract",
      "boolean",
      "break",
      "byte",
      "case",
      "catch",
      "char",
      "class",
      "const",
      "continue",
      "debugger",
      "default",
      "delete",
      "do",
      "double",
      "else",
      "enum",
      "export",
      "extends",
      "false",
      "final",
      "finally",
      "float",
      "for",
      "function",
      "goto",
      "if",
      "implements",
      "import",
      "in",
      "instanceof",
      "int",
      "interface",
      "long",
      "native",
      "new",
      "null",
      "package",
      "private",
      "protected",
      "public",
      "return",
      "short",
      "static",
      "super",
      "switch",
      "synchronized",
      "this",
      "throw",
      "throws",
      "transient",
      "true",
      "try",
      "typeof",
      "var",
      "void",
      "volatile",
      "while",
      "with"
    ];
  }
});

// ../../node_modules/eslint/lib/rules/dot-notation.js
var require_dot_notation = __commonJS({
  "../../node_modules/eslint/lib/rules/dot-notation.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var keywords = require_keywords();
    var validIdentifier = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/u;
    var literalTypesToCheck = /* @__PURE__ */ new Set(["string", "boolean"]);
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Enforce dot notation whenever possible",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/dot-notation"
        },
        schema: [
          {
            type: "object",
            properties: {
              allowKeywords: {
                type: "boolean",
                default: true
              },
              allowPattern: {
                type: "string",
                default: ""
              }
            },
            additionalProperties: false
          }
        ],
        fixable: "code",
        messages: {
          useDot: "[{{key}}] is better written in dot notation.",
          useBrackets: ".{{key}} is a syntax error."
        }
      },
      create(context) {
        const options = context.options[0] || {};
        const allowKeywords = options.allowKeywords === void 0 || options.allowKeywords;
        const sourceCode = context.sourceCode;
        let allowPattern;
        if (options.allowPattern) {
          allowPattern = new RegExp(options.allowPattern, "u");
        }
        function checkComputedProperty(node, value) {
          if (validIdentifier.test(value) && (allowKeywords || !keywords.includes(String(value))) && !(allowPattern && allowPattern.test(value))) {
            const formattedValue = node.property.type === "Literal" ? JSON.stringify(value) : `\`${value}\``;
            context.report({
              node: node.property,
              messageId: "useDot",
              data: {
                key: formattedValue
              },
              *fix(fixer) {
                const leftBracket = sourceCode.getTokenAfter(node.object, astUtils.isOpeningBracketToken);
                const rightBracket = sourceCode.getLastToken(node);
                const nextToken = sourceCode.getTokenAfter(node);
                if (sourceCode.commentsExistBetween(leftBracket, rightBracket)) {
                  return;
                }
                if (!node.optional) {
                  yield fixer.insertTextBefore(
                    leftBracket,
                    astUtils.isDecimalInteger(node.object) ? " ." : "."
                  );
                }
                yield fixer.replaceTextRange(
                  [leftBracket.range[0], rightBracket.range[1]],
                  value
                );
                if (nextToken && rightBracket.range[1] === nextToken.range[0] && !astUtils.canTokensBeAdjacent(String(value), nextToken)) {
                  yield fixer.insertTextAfter(node, " ");
                }
              }
            });
          }
        }
        return {
          MemberExpression(node) {
            if (node.computed && node.property.type === "Literal" && (literalTypesToCheck.has(typeof node.property.value) || astUtils.isNullLiteral(node.property))) {
              checkComputedProperty(node, node.property.value);
            }
            if (node.computed && astUtils.isStaticTemplateLiteral(node.property)) {
              checkComputedProperty(node, node.property.quasis[0].value.cooked);
            }
            if (!allowKeywords && !node.computed && node.property.type === "Identifier" && keywords.includes(String(node.property.name))) {
              context.report({
                node: node.property,
                messageId: "useBrackets",
                data: {
                  key: node.property.name
                },
                *fix(fixer) {
                  const dotToken = sourceCode.getTokenBefore(node.property);
                  if (node.object.type === "Identifier" && node.object.name === "let" && !node.optional) {
                    return;
                  }
                  if (sourceCode.commentsExistBetween(dotToken, node.property)) {
                    return;
                  }
                  if (!node.optional) {
                    yield fixer.remove(dotToken);
                  }
                  yield fixer.replaceText(node.property, `["${node.property.name}"]`);
                }
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/eol-last.js
var require_eol_last = __commonJS({
  "../../node_modules/eslint/lib/rules/eol-last.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Require or disallow newline at the end of files",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/eol-last"
        },
        fixable: "whitespace",
        schema: [
          {
            enum: ["always", "never", "unix", "windows"]
          }
        ],
        messages: {
          missing: "Newline required at end of file but not found.",
          unexpected: "Newline not allowed at end of file."
        }
      },
      create(context) {
        return {
          Program: function checkBadEOF(node) {
            const sourceCode = context.sourceCode, src = sourceCode.getText(), lastLine = sourceCode.lines[sourceCode.lines.length - 1], location = {
              column: lastLine.length,
              line: sourceCode.lines.length
            }, LF = "\n", CRLF = `\r${LF}`, endsWithNewline = src.endsWith(LF);
            if (!src.length) {
              return;
            }
            let mode = context.options[0] || "always", appendCRLF = false;
            if (mode === "unix") {
              mode = "always";
            }
            if (mode === "windows") {
              mode = "always";
              appendCRLF = true;
            }
            if (mode === "always" && !endsWithNewline) {
              context.report({
                node,
                loc: location,
                messageId: "missing",
                fix(fixer) {
                  return fixer.insertTextAfterRange([0, src.length], appendCRLF ? CRLF : LF);
                }
              });
            } else if (mode === "never" && endsWithNewline) {
              const secondLastLine = sourceCode.lines[sourceCode.lines.length - 2];
              context.report({
                node,
                loc: {
                  start: { line: sourceCode.lines.length - 1, column: secondLastLine.length },
                  end: { line: sourceCode.lines.length, column: 0 }
                },
                messageId: "unexpected",
                fix(fixer) {
                  const finalEOLs = /(?:\r?\n)+$/u, match = finalEOLs.exec(sourceCode.text), start = match.index, end = sourceCode.text.length;
                  return fixer.replaceTextRange([start, end], "");
                }
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/eqeqeq.js
var require_eqeqeq = __commonJS({
  "../../node_modules/eslint/lib/rules/eqeqeq.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Require the use of `===` and `!==`",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/eqeqeq"
        },
        schema: {
          anyOf: [
            {
              type: "array",
              items: [
                {
                  enum: ["always"]
                },
                {
                  type: "object",
                  properties: {
                    null: {
                      enum: ["always", "never", "ignore"]
                    }
                  },
                  additionalProperties: false
                }
              ],
              additionalItems: false
            },
            {
              type: "array",
              items: [
                {
                  enum: ["smart", "allow-null"]
                }
              ],
              additionalItems: false
            }
          ]
        },
        fixable: "code",
        messages: {
          unexpected: "Expected '{{expectedOperator}}' and instead saw '{{actualOperator}}'."
        }
      },
      create(context) {
        const config = context.options[0] || "always";
        const options = context.options[1] || {};
        const sourceCode = context.sourceCode;
        const nullOption = config === "always" ? options.null || "always" : "ignore";
        const enforceRuleForNull = nullOption === "always";
        const enforceInverseRuleForNull = nullOption === "never";
        function isTypeOf(node) {
          return node.type === "UnaryExpression" && node.operator === "typeof";
        }
        function isTypeOfBinary(node) {
          return isTypeOf(node.left) || isTypeOf(node.right);
        }
        function areLiteralsAndSameType(node) {
          return node.left.type === "Literal" && node.right.type === "Literal" && typeof node.left.value === typeof node.right.value;
        }
        function isNullCheck(node) {
          return astUtils.isNullLiteral(node.right) || astUtils.isNullLiteral(node.left);
        }
        function report(node, expectedOperator) {
          const operatorToken = sourceCode.getFirstTokenBetween(
            node.left,
            node.right,
            (token) => token.value === node.operator
          );
          context.report({
            node,
            loc: operatorToken.loc,
            messageId: "unexpected",
            data: { expectedOperator, actualOperator: node.operator },
            fix(fixer) {
              if (isTypeOfBinary(node) || areLiteralsAndSameType(node)) {
                return fixer.replaceText(operatorToken, expectedOperator);
              }
              return null;
            }
          });
        }
        return {
          BinaryExpression(node) {
            const isNull = isNullCheck(node);
            if (node.operator !== "==" && node.operator !== "!=") {
              if (enforceInverseRuleForNull && isNull) {
                report(node, node.operator.slice(0, -1));
              }
              return;
            }
            if (config === "smart" && (isTypeOfBinary(node) || areLiteralsAndSameType(node) || isNull)) {
              return;
            }
            if (!enforceRuleForNull && isNull) {
              return;
            }
            report(node, `${node.operator}=`);
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/for-direction.js
var require_for_direction = __commonJS({
  "../../node_modules/eslint/lib/rules/for-direction.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: 'Enforce "for" loop update clause moving the counter in the right direction',
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/for-direction"
        },
        fixable: null,
        schema: [],
        messages: {
          incorrectDirection: "The update clause in this loop moves the variable in the wrong direction."
        }
      },
      create(context) {
        function report(node) {
          context.report({
            node,
            messageId: "incorrectDirection"
          });
        }
        function getRightDirection(update, dir) {
          if (update.right.type === "UnaryExpression") {
            if (update.right.operator === "-") {
              return -dir;
            }
          } else if (update.right.type === "Identifier") {
            return 0;
          }
          return dir;
        }
        function getUpdateDirection(update, counter) {
          if (update.argument.type === "Identifier" && update.argument.name === counter) {
            if (update.operator === "++") {
              return 1;
            }
            if (update.operator === "--") {
              return -1;
            }
          }
          return 0;
        }
        function getAssignmentDirection(update, counter) {
          if (update.left.name === counter) {
            if (update.operator === "+=") {
              return getRightDirection(update, 1);
            }
            if (update.operator === "-=") {
              return getRightDirection(update, -1);
            }
          }
          return 0;
        }
        return {
          ForStatement(node) {
            if (node.test && node.test.type === "BinaryExpression" && node.test.left.type === "Identifier" && node.update) {
              const counter = node.test.left.name;
              const operator = node.test.operator;
              const update = node.update;
              let wrongDirection;
              if (operator === "<" || operator === "<=") {
                wrongDirection = -1;
              } else if (operator === ">" || operator === ">=") {
                wrongDirection = 1;
              } else {
                return;
              }
              if (update.type === "UpdateExpression") {
                if (getUpdateDirection(update, counter) === wrongDirection) {
                  report(node);
                }
              } else if (update.type === "AssignmentExpression" && getAssignmentDirection(update, counter) === wrongDirection) {
                report(node);
              }
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/func-call-spacing.js
var require_func_call_spacing = __commonJS({
  "../../node_modules/eslint/lib/rules/func-call-spacing.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Require or disallow spacing between function identifiers and their invocations",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/func-call-spacing"
        },
        fixable: "whitespace",
        schema: {
          anyOf: [
            {
              type: "array",
              items: [
                {
                  enum: ["never"]
                }
              ],
              minItems: 0,
              maxItems: 1
            },
            {
              type: "array",
              items: [
                {
                  enum: ["always"]
                },
                {
                  type: "object",
                  properties: {
                    allowNewlines: {
                      type: "boolean"
                    }
                  },
                  additionalProperties: false
                }
              ],
              minItems: 0,
              maxItems: 2
            }
          ]
        },
        messages: {
          unexpectedWhitespace: "Unexpected whitespace between function name and paren.",
          unexpectedNewline: "Unexpected newline between function name and paren.",
          missing: "Missing space between function name and paren."
        }
      },
      create(context) {
        const never = context.options[0] !== "always";
        const allowNewlines = !never && context.options[1] && context.options[1].allowNewlines;
        const sourceCode = context.sourceCode;
        const text = sourceCode.getText();
        function checkSpacing(node, leftToken, rightToken) {
          const textBetweenTokens = text.slice(leftToken.range[1], rightToken.range[0]).replace(/\/\*.*?\*\//gu, "");
          const hasWhitespace = /\s/u.test(textBetweenTokens);
          const hasNewline = hasWhitespace && astUtils.LINEBREAK_MATCHER.test(textBetweenTokens);
          if (never && hasWhitespace) {
            context.report({
              node,
              loc: {
                start: leftToken.loc.end,
                end: {
                  line: rightToken.loc.start.line,
                  column: rightToken.loc.start.column - 1
                }
              },
              messageId: "unexpectedWhitespace",
              fix(fixer) {
                if (sourceCode.commentsExistBetween(leftToken, rightToken)) {
                  return null;
                }
                if (node.optional) {
                  return fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], "?.");
                }
                if (hasNewline) {
                  return null;
                }
                return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);
              }
            });
          } else if (!never && !hasWhitespace) {
            context.report({
              node,
              loc: {
                start: {
                  line: leftToken.loc.end.line,
                  column: leftToken.loc.end.column - 1
                },
                end: rightToken.loc.start
              },
              messageId: "missing",
              fix(fixer) {
                if (node.optional) {
                  return null;
                }
                return fixer.insertTextBefore(rightToken, " ");
              }
            });
          } else if (!never && !allowNewlines && hasNewline) {
            context.report({
              node,
              loc: {
                start: leftToken.loc.end,
                end: rightToken.loc.start
              },
              messageId: "unexpectedNewline",
              fix(fixer) {
                if (!node.optional) {
                  return null;
                }
                if (sourceCode.commentsExistBetween(leftToken, rightToken)) {
                  return null;
                }
                const range = [leftToken.range[1], rightToken.range[0]];
                const qdToken = sourceCode.getTokenAfter(leftToken);
                if (qdToken.range[0] === leftToken.range[1]) {
                  return fixer.replaceTextRange(range, "?. ");
                }
                if (qdToken.range[1] === rightToken.range[0]) {
                  return fixer.replaceTextRange(range, " ?.");
                }
                return fixer.replaceTextRange(range, " ?. ");
              }
            });
          }
        }
        return {
          "CallExpression, NewExpression"(node) {
            const lastToken = sourceCode.getLastToken(node);
            const lastCalleeToken = sourceCode.getLastToken(node.callee);
            const parenToken = sourceCode.getFirstTokenBetween(lastCalleeToken, lastToken, astUtils.isOpeningParenToken);
            const prevToken = parenToken && sourceCode.getTokenBefore(parenToken, astUtils.isNotQuestionDotToken);
            if (!(parenToken && parenToken.range[1] < node.range[1])) {
              return;
            }
            checkSpacing(node, prevToken, parenToken);
          },
          ImportExpression(node) {
            const leftToken = sourceCode.getFirstToken(node);
            const rightToken = sourceCode.getTokenAfter(leftToken);
            checkSpacing(node, leftToken, rightToken);
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/func-name-matching.js
var require_func_name_matching = __commonJS({
  "../../node_modules/eslint/lib/rules/func-name-matching.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var esutils = require_utils2();
    function isModuleExports(pattern) {
      if (pattern.type === "MemberExpression" && pattern.object.type === "Identifier" && pattern.object.name === "module") {
        if (pattern.property.type === "Identifier" && pattern.property.name === "exports") {
          return true;
        }
        if (pattern.property.type === "Literal" && pattern.property.value === "exports") {
          return true;
        }
      }
      return false;
    }
    function isIdentifier(name, ecmaVersion) {
      if (ecmaVersion >= 2015) {
        return esutils.keyword.isIdentifierES6(name);
      }
      return esutils.keyword.isIdentifierES5(name);
    }
    var alwaysOrNever = { enum: ["always", "never"] };
    var optionsObject = {
      type: "object",
      properties: {
        considerPropertyDescriptor: {
          type: "boolean"
        },
        includeCommonJSModuleExports: {
          type: "boolean"
        }
      },
      additionalProperties: false
    };
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Require function names to match the name of the variable or property to which they are assigned",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/func-name-matching"
        },
        schema: {
          anyOf: [{
            type: "array",
            additionalItems: false,
            items: [alwaysOrNever, optionsObject]
          }, {
            type: "array",
            additionalItems: false,
            items: [optionsObject]
          }]
        },
        messages: {
          matchProperty: "Function name `{{funcName}}` should match property name `{{name}}`.",
          matchVariable: "Function name `{{funcName}}` should match variable name `{{name}}`.",
          notMatchProperty: "Function name `{{funcName}}` should not match property name `{{name}}`.",
          notMatchVariable: "Function name `{{funcName}}` should not match variable name `{{name}}`."
        }
      },
      create(context) {
        const options = (typeof context.options[0] === "object" ? context.options[0] : context.options[1]) || {};
        const nameMatches = typeof context.options[0] === "string" ? context.options[0] : "always";
        const considerPropertyDescriptor = options.considerPropertyDescriptor;
        const includeModuleExports = options.includeCommonJSModuleExports;
        const ecmaVersion = context.languageOptions.ecmaVersion;
        function isPropertyCall(objName, funcName, node) {
          if (!node) {
            return false;
          }
          return node.type === "CallExpression" && astUtils.isSpecificMemberAccess(node.callee, objName, funcName);
        }
        function shouldWarn(x, y) {
          return nameMatches === "always" && x !== y || nameMatches === "never" && x === y;
        }
        function report(node, name, funcName, isProp) {
          let messageId;
          if (nameMatches === "always" && isProp) {
            messageId = "matchProperty";
          } else if (nameMatches === "always") {
            messageId = "matchVariable";
          } else if (isProp) {
            messageId = "notMatchProperty";
          } else {
            messageId = "notMatchVariable";
          }
          context.report({
            node,
            messageId,
            data: {
              name,
              funcName
            }
          });
        }
        function isStringLiteral(node) {
          return node.type === "Literal" && typeof node.value === "string";
        }
        return {
          VariableDeclarator(node) {
            if (!node.init || node.init.type !== "FunctionExpression" || node.id.type !== "Identifier") {
              return;
            }
            if (node.init.id && shouldWarn(node.id.name, node.init.id.name)) {
              report(node, node.id.name, node.init.id.name, false);
            }
          },
          AssignmentExpression(node) {
            if (node.right.type !== "FunctionExpression" || node.left.computed && node.left.property.type !== "Literal" || !includeModuleExports && isModuleExports(node.left) || node.left.type !== "Identifier" && node.left.type !== "MemberExpression") {
              return;
            }
            const isProp = node.left.type === "MemberExpression";
            const name = isProp ? astUtils.getStaticPropertyName(node.left) : node.left.name;
            if (node.right.id && name && isIdentifier(name) && shouldWarn(name, node.right.id.name)) {
              report(node, name, node.right.id.name, isProp);
            }
          },
          "Property, PropertyDefinition[value]"(node) {
            if (!(node.value.type === "FunctionExpression" && node.value.id)) {
              return;
            }
            if (node.key.type === "Identifier" && !node.computed) {
              const functionName = node.value.id.name;
              let propertyName = node.key.name;
              if (considerPropertyDescriptor && propertyName === "value" && node.parent.type === "ObjectExpression") {
                if (isPropertyCall("Object", "defineProperty", node.parent.parent) || isPropertyCall("Reflect", "defineProperty", node.parent.parent)) {
                  const property = node.parent.parent.arguments[1];
                  if (isStringLiteral(property) && shouldWarn(property.value, functionName)) {
                    report(node, property.value, functionName, true);
                  }
                } else if (isPropertyCall("Object", "defineProperties", node.parent.parent.parent.parent)) {
                  propertyName = node.parent.parent.key.name;
                  if (!node.parent.parent.computed && shouldWarn(propertyName, functionName)) {
                    report(node, propertyName, functionName, true);
                  }
                } else if (isPropertyCall("Object", "create", node.parent.parent.parent.parent)) {
                  propertyName = node.parent.parent.key.name;
                  if (!node.parent.parent.computed && shouldWarn(propertyName, functionName)) {
                    report(node, propertyName, functionName, true);
                  }
                } else if (shouldWarn(propertyName, functionName)) {
                  report(node, propertyName, functionName, true);
                }
              } else if (shouldWarn(propertyName, functionName)) {
                report(node, propertyName, functionName, true);
              }
              return;
            }
            if (isStringLiteral(node.key) && isIdentifier(node.key.value, ecmaVersion) && shouldWarn(node.key.value, node.value.id.name)) {
              report(node, node.key.value, node.value.id.name, true);
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/func-names.js
var require_func_names = __commonJS({
  "../../node_modules/eslint/lib/rules/func-names.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    function isFunctionName(variable) {
      return variable && variable.defs[0].type === "FunctionName";
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Require or disallow named `function` expressions",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/func-names"
        },
        schema: {
          definitions: {
            value: {
              enum: [
                "always",
                "as-needed",
                "never"
              ]
            }
          },
          items: [
            {
              $ref: "#/definitions/value"
            },
            {
              type: "object",
              properties: {
                generators: {
                  $ref: "#/definitions/value"
                }
              },
              additionalProperties: false
            }
          ]
        },
        messages: {
          unnamed: "Unexpected unnamed {{name}}.",
          named: "Unexpected named {{name}}."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        function getConfigForNode(node) {
          if (node.generator && context.options.length > 1 && context.options[1].generators) {
            return context.options[1].generators;
          }
          return context.options[0] || "always";
        }
        function isObjectOrClassMethod(node) {
          const parent = node.parent;
          return parent.type === "MethodDefinition" || parent.type === "Property" && (parent.method || parent.kind === "get" || parent.kind === "set");
        }
        function hasInferredName(node) {
          const parent = node.parent;
          return isObjectOrClassMethod(node) || parent.type === "VariableDeclarator" && parent.id.type === "Identifier" && parent.init === node || parent.type === "Property" && parent.value === node || parent.type === "PropertyDefinition" && parent.value === node || parent.type === "AssignmentExpression" && parent.left.type === "Identifier" && parent.right === node || parent.type === "AssignmentPattern" && parent.left.type === "Identifier" && parent.right === node;
        }
        function reportUnexpectedUnnamedFunction(node) {
          context.report({
            node,
            messageId: "unnamed",
            loc: astUtils.getFunctionHeadLoc(node, sourceCode),
            data: { name: astUtils.getFunctionNameWithKind(node) }
          });
        }
        function reportUnexpectedNamedFunction(node) {
          context.report({
            node,
            messageId: "named",
            loc: astUtils.getFunctionHeadLoc(node, sourceCode),
            data: { name: astUtils.getFunctionNameWithKind(node) }
          });
        }
        function handleFunction(node) {
          const nameVar = sourceCode.getDeclaredVariables(node)[0];
          if (isFunctionName(nameVar) && nameVar.references.length > 0) {
            return;
          }
          const hasName = Boolean(node.id && node.id.name);
          const config = getConfigForNode(node);
          if (config === "never") {
            if (hasName && node.type !== "FunctionDeclaration") {
              reportUnexpectedNamedFunction(node);
            }
          } else if (config === "as-needed") {
            if (!hasName && !hasInferredName(node)) {
              reportUnexpectedUnnamedFunction(node);
            }
          } else {
            if (!hasName && !isObjectOrClassMethod(node)) {
              reportUnexpectedUnnamedFunction(node);
            }
          }
        }
        return {
          "FunctionExpression:exit": handleFunction,
          "ExportDefaultDeclaration > FunctionDeclaration": handleFunction
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/func-style.js
var require_func_style = __commonJS({
  "../../node_modules/eslint/lib/rules/func-style.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Enforce the consistent use of either `function` declarations or expressions",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/func-style"
        },
        schema: [
          {
            enum: ["declaration", "expression"]
          },
          {
            type: "object",
            properties: {
              allowArrowFunctions: {
                type: "boolean",
                default: false
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          expression: "Expected a function expression.",
          declaration: "Expected a function declaration."
        }
      },
      create(context) {
        const style = context.options[0], allowArrowFunctions = context.options[1] && context.options[1].allowArrowFunctions, enforceDeclarations = style === "declaration", stack = [];
        const nodesToCheck = {
          FunctionDeclaration(node) {
            stack.push(false);
            if (!enforceDeclarations && node.parent.type !== "ExportDefaultDeclaration") {
              context.report({ node, messageId: "expression" });
            }
          },
          "FunctionDeclaration:exit"() {
            stack.pop();
          },
          FunctionExpression(node) {
            stack.push(false);
            if (enforceDeclarations && node.parent.type === "VariableDeclarator") {
              context.report({ node: node.parent, messageId: "declaration" });
            }
          },
          "FunctionExpression:exit"() {
            stack.pop();
          },
          ThisExpression() {
            if (stack.length > 0) {
              stack[stack.length - 1] = true;
            }
          }
        };
        if (!allowArrowFunctions) {
          nodesToCheck.ArrowFunctionExpression = function() {
            stack.push(false);
          };
          nodesToCheck["ArrowFunctionExpression:exit"] = function(node) {
            const hasThisExpr = stack.pop();
            if (enforceDeclarations && !hasThisExpr && node.parent.type === "VariableDeclarator") {
              context.report({ node: node.parent, messageId: "declaration" });
            }
          };
        }
        return nodesToCheck;
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/function-call-argument-newline.js
var require_function_call_argument_newline = __commonJS({
  "../../node_modules/eslint/lib/rules/function-call-argument-newline.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Enforce line breaks between arguments of a function call",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/function-call-argument-newline"
        },
        fixable: "whitespace",
        schema: [
          {
            enum: ["always", "never", "consistent"]
          }
        ],
        messages: {
          unexpectedLineBreak: "There should be no line break here.",
          missingLineBreak: "There should be a line break after this argument."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        const checkers = {
          unexpected: {
            messageId: "unexpectedLineBreak",
            check: (prevToken, currentToken) => prevToken.loc.end.line !== currentToken.loc.start.line,
            createFix: (token, tokenBefore) => (fixer) => fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], " ")
          },
          missing: {
            messageId: "missingLineBreak",
            check: (prevToken, currentToken) => prevToken.loc.end.line === currentToken.loc.start.line,
            createFix: (token, tokenBefore) => (fixer) => fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], "\n")
          }
        };
        function checkArguments(node, checker) {
          for (let i = 1; i < node.arguments.length; i++) {
            const prevArgToken = sourceCode.getLastToken(node.arguments[i - 1]);
            const currentArgToken = sourceCode.getFirstToken(node.arguments[i]);
            if (checker.check(prevArgToken, currentArgToken)) {
              const tokenBefore = sourceCode.getTokenBefore(
                currentArgToken,
                { includeComments: true }
              );
              const hasLineCommentBefore = tokenBefore.type === "Line";
              context.report({
                node,
                loc: {
                  start: tokenBefore.loc.end,
                  end: currentArgToken.loc.start
                },
                messageId: checker.messageId,
                fix: hasLineCommentBefore ? null : checker.createFix(currentArgToken, tokenBefore)
              });
            }
          }
        }
        function check(node) {
          if (node.arguments.length < 2) {
            return;
          }
          const option = context.options[0] || "always";
          if (option === "never") {
            checkArguments(node, checkers.unexpected);
          } else if (option === "always") {
            checkArguments(node, checkers.missing);
          } else if (option === "consistent") {
            const firstArgToken = sourceCode.getLastToken(node.arguments[0]);
            const secondArgToken = sourceCode.getFirstToken(node.arguments[1]);
            if (firstArgToken.loc.end.line === secondArgToken.loc.start.line) {
              checkArguments(node, checkers.unexpected);
            } else {
              checkArguments(node, checkers.missing);
            }
          }
        }
        return {
          CallExpression: check,
          NewExpression: check
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/function-paren-newline.js
var require_function_paren_newline = __commonJS({
  "../../node_modules/eslint/lib/rules/function-paren-newline.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Enforce consistent line breaks inside function parentheses",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/function-paren-newline"
        },
        fixable: "whitespace",
        schema: [
          {
            oneOf: [
              {
                enum: ["always", "never", "consistent", "multiline", "multiline-arguments"]
              },
              {
                type: "object",
                properties: {
                  minItems: {
                    type: "integer",
                    minimum: 0
                  }
                },
                additionalProperties: false
              }
            ]
          }
        ],
        messages: {
          expectedBefore: "Expected newline before ')'.",
          expectedAfter: "Expected newline after '('.",
          expectedBetween: "Expected newline between arguments/params.",
          unexpectedBefore: "Unexpected newline before ')'.",
          unexpectedAfter: "Unexpected newline after '('."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        const rawOption = context.options[0] || "multiline";
        const multilineOption = rawOption === "multiline";
        const multilineArgumentsOption = rawOption === "multiline-arguments";
        const consistentOption = rawOption === "consistent";
        let minItems;
        if (typeof rawOption === "object") {
          minItems = rawOption.minItems;
        } else if (rawOption === "always") {
          minItems = 0;
        } else if (rawOption === "never") {
          minItems = Infinity;
        } else {
          minItems = null;
        }
        function shouldHaveNewlines(elements, hasLeftNewline) {
          if (multilineArgumentsOption && elements.length === 1) {
            return hasLeftNewline;
          }
          if (multilineOption || multilineArgumentsOption) {
            return elements.some((element, index) => index !== elements.length - 1 && element.loc.end.line !== elements[index + 1].loc.start.line);
          }
          if (consistentOption) {
            return hasLeftNewline;
          }
          return elements.length >= minItems;
        }
        function validateParens(parens, elements) {
          const leftParen = parens.leftParen;
          const rightParen = parens.rightParen;
          const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParen);
          const tokenBeforeRightParen = sourceCode.getTokenBefore(rightParen);
          const hasLeftNewline = !astUtils.isTokenOnSameLine(leftParen, tokenAfterLeftParen);
          const hasRightNewline = !astUtils.isTokenOnSameLine(tokenBeforeRightParen, rightParen);
          const needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);
          if (hasLeftNewline && !needsNewlines) {
            context.report({
              node: leftParen,
              messageId: "unexpectedAfter",
              fix(fixer) {
                return sourceCode.getText().slice(leftParen.range[1], tokenAfterLeftParen.range[0]).trim() ? null : fixer.removeRange([leftParen.range[1], tokenAfterLeftParen.range[0]]);
              }
            });
          } else if (!hasLeftNewline && needsNewlines) {
            context.report({
              node: leftParen,
              messageId: "expectedAfter",
              fix: (fixer) => fixer.insertTextAfter(leftParen, "\n")
            });
          }
          if (hasRightNewline && !needsNewlines) {
            context.report({
              node: rightParen,
              messageId: "unexpectedBefore",
              fix(fixer) {
                return sourceCode.getText().slice(tokenBeforeRightParen.range[1], rightParen.range[0]).trim() ? null : fixer.removeRange([tokenBeforeRightParen.range[1], rightParen.range[0]]);
              }
            });
          } else if (!hasRightNewline && needsNewlines) {
            context.report({
              node: rightParen,
              messageId: "expectedBefore",
              fix: (fixer) => fixer.insertTextBefore(rightParen, "\n")
            });
          }
        }
        function validateArguments(parens, elements) {
          const leftParen = parens.leftParen;
          const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParen);
          const hasLeftNewline = !astUtils.isTokenOnSameLine(leftParen, tokenAfterLeftParen);
          const needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);
          for (let i = 0; i <= elements.length - 2; i++) {
            const currentElement = elements[i];
            const nextElement = elements[i + 1];
            const hasNewLine = currentElement.loc.end.line !== nextElement.loc.start.line;
            if (!hasNewLine && needsNewlines) {
              context.report({
                node: currentElement,
                messageId: "expectedBetween",
                fix: (fixer) => fixer.insertTextBefore(nextElement, "\n")
              });
            }
          }
        }
        function getParenTokens(node) {
          switch (node.type) {
            case "NewExpression":
              if (!node.arguments.length && !(astUtils.isOpeningParenToken(sourceCode.getLastToken(node, { skip: 1 })) && astUtils.isClosingParenToken(sourceCode.getLastToken(node)) && node.callee.range[1] < node.range[1])) {
                return null;
              }
            case "CallExpression":
              return {
                leftParen: sourceCode.getTokenAfter(node.callee, astUtils.isOpeningParenToken),
                rightParen: sourceCode.getLastToken(node)
              };
            case "FunctionDeclaration":
            case "FunctionExpression": {
              const leftParen = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);
              const rightParen = node.params.length ? sourceCode.getTokenAfter(node.params[node.params.length - 1], astUtils.isClosingParenToken) : sourceCode.getTokenAfter(leftParen);
              return { leftParen, rightParen };
            }
            case "ArrowFunctionExpression": {
              const firstToken = sourceCode.getFirstToken(node, { skip: node.async ? 1 : 0 });
              if (!astUtils.isOpeningParenToken(firstToken)) {
                return null;
              }
              const rightParen = node.params.length ? sourceCode.getTokenAfter(node.params[node.params.length - 1], astUtils.isClosingParenToken) : sourceCode.getTokenAfter(firstToken);
              return {
                leftParen: firstToken,
                rightParen
              };
            }
            case "ImportExpression": {
              const leftParen = sourceCode.getFirstToken(node, 1);
              const rightParen = sourceCode.getLastToken(node);
              return { leftParen, rightParen };
            }
            default:
              throw new TypeError(`unexpected node with type ${node.type}`);
          }
        }
        return {
          [[
            "ArrowFunctionExpression",
            "CallExpression",
            "FunctionDeclaration",
            "FunctionExpression",
            "ImportExpression",
            "NewExpression"
          ]](node) {
            const parens = getParenTokens(node);
            let params;
            if (node.type === "ImportExpression") {
              params = [node.source];
            } else if (astUtils.isFunction(node)) {
              params = node.params;
            } else {
              params = node.arguments;
            }
            if (parens) {
              validateParens(parens, params);
              if (multilineArgumentsOption) {
                validateArguments(parens, params);
              }
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/generator-star-spacing.js
var require_generator_star_spacing = __commonJS({
  "../../node_modules/eslint/lib/rules/generator-star-spacing.js"(exports, module) {
    "use strict";
    var OVERRIDE_SCHEMA = {
      oneOf: [
        {
          enum: ["before", "after", "both", "neither"]
        },
        {
          type: "object",
          properties: {
            before: { type: "boolean" },
            after: { type: "boolean" }
          },
          additionalProperties: false
        }
      ]
    };
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Enforce consistent spacing around `*` operators in generator functions",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/generator-star-spacing"
        },
        fixable: "whitespace",
        schema: [
          {
            oneOf: [
              {
                enum: ["before", "after", "both", "neither"]
              },
              {
                type: "object",
                properties: {
                  before: { type: "boolean" },
                  after: { type: "boolean" },
                  named: OVERRIDE_SCHEMA,
                  anonymous: OVERRIDE_SCHEMA,
                  method: OVERRIDE_SCHEMA
                },
                additionalProperties: false
              }
            ]
          }
        ],
        messages: {
          missingBefore: "Missing space before *.",
          missingAfter: "Missing space after *.",
          unexpectedBefore: "Unexpected space before *.",
          unexpectedAfter: "Unexpected space after *."
        }
      },
      create(context) {
        const optionDefinitions = {
          before: { before: true, after: false },
          after: { before: false, after: true },
          both: { before: true, after: true },
          neither: { before: false, after: false }
        };
        function optionToDefinition(option, defaults) {
          if (!option) {
            return defaults;
          }
          return typeof option === "string" ? optionDefinitions[option] : Object.assign({}, defaults, option);
        }
        const modes = function(option) {
          const defaults = optionToDefinition(option, optionDefinitions.before);
          return {
            named: optionToDefinition(option.named, defaults),
            anonymous: optionToDefinition(option.anonymous, defaults),
            method: optionToDefinition(option.method, defaults)
          };
        }(context.options[0] || {});
        const sourceCode = context.sourceCode;
        function isStarToken(token) {
          return token.value === "*" && token.type === "Punctuator";
        }
        function getStarToken(node) {
          return sourceCode.getFirstToken(
            node.parent.method || node.parent.type === "MethodDefinition" ? node.parent : node,
            isStarToken
          );
        }
        function capitalize(str) {
          return str[0].toUpperCase() + str.slice(1);
        }
        function checkSpacing(kind, side, leftToken, rightToken) {
          if (!!(rightToken.range[0] - leftToken.range[1]) !== modes[kind][side]) {
            const after = leftToken.value === "*";
            const spaceRequired = modes[kind][side];
            const node = after ? leftToken : rightToken;
            const messageId = `${spaceRequired ? "missing" : "unexpected"}${capitalize(side)}`;
            context.report({
              node,
              messageId,
              fix(fixer) {
                if (spaceRequired) {
                  if (after) {
                    return fixer.insertTextAfter(node, " ");
                  }
                  return fixer.insertTextBefore(node, " ");
                }
                return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);
              }
            });
          }
        }
        function checkFunction(node) {
          if (!node.generator) {
            return;
          }
          const starToken = getStarToken(node);
          const prevToken = sourceCode.getTokenBefore(starToken);
          const nextToken = sourceCode.getTokenAfter(starToken);
          let kind = "named";
          if (node.parent.type === "MethodDefinition" || node.parent.type === "Property" && node.parent.method) {
            kind = "method";
          } else if (!node.id) {
            kind = "anonymous";
          }
          if (!(kind === "method" && starToken === sourceCode.getFirstToken(node.parent))) {
            checkSpacing(kind, "before", prevToken, starToken);
          }
          checkSpacing(kind, "after", starToken, nextToken);
        }
        return {
          FunctionDeclaration: checkFunction,
          FunctionExpression: checkFunction
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/getter-return.js
var require_getter_return = __commonJS({
  "../../node_modules/eslint/lib/rules/getter-return.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/u;
    function isReachable(segment) {
      return segment.reachable;
    }
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Enforce `return` statements in getters",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/getter-return"
        },
        fixable: null,
        schema: [
          {
            type: "object",
            properties: {
              allowImplicit: {
                type: "boolean",
                default: false
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          expected: "Expected to return a value in {{name}}.",
          expectedAlways: "Expected {{name}} to always return a value."
        }
      },
      create(context) {
        const options = context.options[0] || { allowImplicit: false };
        const sourceCode = context.sourceCode;
        let funcInfo = {
          upper: null,
          codePath: null,
          hasReturn: false,
          shouldCheck: false,
          node: null
        };
        function checkLastSegment(node) {
          if (funcInfo.shouldCheck && funcInfo.codePath.currentSegments.some(isReachable)) {
            context.report({
              node,
              loc: astUtils.getFunctionHeadLoc(node, sourceCode),
              messageId: funcInfo.hasReturn ? "expectedAlways" : "expected",
              data: {
                name: astUtils.getFunctionNameWithKind(funcInfo.node)
              }
            });
          }
        }
        function isGetter(node) {
          const parent = node.parent;
          if (TARGET_NODE_TYPE.test(node.type) && node.body.type === "BlockStatement") {
            if (parent.kind === "get") {
              return true;
            }
            if (parent.type === "Property" && astUtils.getStaticPropertyName(parent) === "get" && parent.parent.type === "ObjectExpression") {
              if (parent.parent.parent.type === "CallExpression") {
                const callNode = parent.parent.parent.callee;
                if (astUtils.isSpecificMemberAccess(callNode, "Object", "defineProperty") || astUtils.isSpecificMemberAccess(callNode, "Reflect", "defineProperty")) {
                  return true;
                }
              }
              if (parent.parent.parent.type === "Property" && parent.parent.parent.parent.type === "ObjectExpression" && parent.parent.parent.parent.parent.type === "CallExpression") {
                const callNode = parent.parent.parent.parent.parent.callee;
                return astUtils.isSpecificMemberAccess(callNode, "Object", "defineProperties") || astUtils.isSpecificMemberAccess(callNode, "Object", "create");
              }
            }
          }
          return false;
        }
        return {
          // Stacks this function's information.
          onCodePathStart(codePath, node) {
            funcInfo = {
              upper: funcInfo,
              codePath,
              hasReturn: false,
              shouldCheck: isGetter(node),
              node
            };
          },
          // Pops this function's information.
          onCodePathEnd() {
            funcInfo = funcInfo.upper;
          },
          // Checks the return statement is valid.
          ReturnStatement(node) {
            if (funcInfo.shouldCheck) {
              funcInfo.hasReturn = true;
              if (!options.allowImplicit && !node.argument) {
                context.report({
                  node,
                  messageId: "expected",
                  data: {
                    name: astUtils.getFunctionNameWithKind(funcInfo.node)
                  }
                });
              }
            }
          },
          // Reports a given function if the last path is reachable.
          "FunctionExpression:exit": checkLastSegment,
          "ArrowFunctionExpression:exit": checkLastSegment
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/global-require.js
var require_global_require = __commonJS({
  "../../node_modules/eslint/lib/rules/global-require.js"(exports, module) {
    "use strict";
    var ACCEPTABLE_PARENTS = /* @__PURE__ */ new Set([
      "AssignmentExpression",
      "VariableDeclarator",
      "MemberExpression",
      "ExpressionStatement",
      "CallExpression",
      "ConditionalExpression",
      "Program",
      "VariableDeclaration",
      "ChainExpression"
    ]);
    function findReference(scope, node) {
      const references = scope.references.filter((reference) => reference.identifier.range[0] === node.range[0] && reference.identifier.range[1] === node.range[1]);
      if (references.length === 1) {
        return references[0];
      }
      return null;
    }
    function isShadowed(scope, node) {
      const reference = findReference(scope, node);
      return reference && reference.resolved && reference.resolved.defs.length > 0;
    }
    module.exports = {
      meta: {
        deprecated: true,
        replacedBy: [],
        type: "suggestion",
        docs: {
          description: "Require `require()` calls to be placed at top-level module scope",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/global-require"
        },
        schema: [],
        messages: {
          unexpected: "Unexpected require()."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        return {
          CallExpression(node) {
            const currentScope = sourceCode.getScope(node);
            if (node.callee.name === "require" && !isShadowed(currentScope, node.callee)) {
              const isGoodRequire = sourceCode.getAncestors(node).every((parent) => ACCEPTABLE_PARENTS.has(parent.type));
              if (!isGoodRequire) {
                context.report({ node, messageId: "unexpected" });
              }
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/grouped-accessor-pairs.js
var require_grouped_accessor_pairs = __commonJS({
  "../../node_modules/eslint/lib/rules/grouped-accessor-pairs.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    function areEqualTokenLists(left, right) {
      if (left.length !== right.length) {
        return false;
      }
      for (let i = 0; i < left.length; i++) {
        const leftToken = left[i], rightToken = right[i];
        if (leftToken.type !== rightToken.type || leftToken.value !== rightToken.value) {
          return false;
        }
      }
      return true;
    }
    function areEqualKeys(left, right) {
      if (typeof left === "string" && typeof right === "string") {
        return left === right;
      }
      if (Array.isArray(left) && Array.isArray(right)) {
        return areEqualTokenLists(left, right);
      }
      return false;
    }
    function isAccessorKind(node) {
      return node.kind === "get" || node.kind === "set";
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Require grouped accessor pairs in object literals and classes",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/grouped-accessor-pairs"
        },
        schema: [
          {
            enum: ["anyOrder", "getBeforeSet", "setBeforeGet"]
          }
        ],
        messages: {
          notGrouped: "Accessor pair {{ formerName }} and {{ latterName }} should be grouped.",
          invalidOrder: "Expected {{ latterName }} to be before {{ formerName }}."
        }
      },
      create(context) {
        const order = context.options[0] || "anyOrder";
        const sourceCode = context.sourceCode;
        function report(messageId, formerNode, latterNode) {
          context.report({
            node: latterNode,
            messageId,
            loc: astUtils.getFunctionHeadLoc(latterNode.value, sourceCode),
            data: {
              formerName: astUtils.getFunctionNameWithKind(formerNode.value),
              latterName: astUtils.getFunctionNameWithKind(latterNode.value)
            }
          });
        }
        function checkList(nodes, shouldCheck) {
          const accessors = [];
          let found = false;
          for (let i = 0; i < nodes.length; i++) {
            const node = nodes[i];
            if (shouldCheck(node) && isAccessorKind(node)) {
              const name = astUtils.getStaticPropertyName(node);
              const key = name !== null ? name : sourceCode.getTokens(node.key);
              for (let j = 0; j < accessors.length; j++) {
                const accessor = accessors[j];
                if (areEqualKeys(accessor.key, key)) {
                  accessor.getters.push(...node.kind === "get" ? [node] : []);
                  accessor.setters.push(...node.kind === "set" ? [node] : []);
                  found = true;
                  break;
                }
              }
              if (!found) {
                accessors.push({
                  key,
                  getters: node.kind === "get" ? [node] : [],
                  setters: node.kind === "set" ? [node] : []
                });
              }
              found = false;
            }
          }
          for (const { getters, setters } of accessors) {
            if (getters.length === 1 && setters.length === 1) {
              const [getter] = getters, [setter] = setters, getterIndex = nodes.indexOf(getter), setterIndex = nodes.indexOf(setter), formerNode = getterIndex < setterIndex ? getter : setter, latterNode = getterIndex < setterIndex ? setter : getter;
              if (Math.abs(getterIndex - setterIndex) > 1) {
                report("notGrouped", formerNode, latterNode);
              } else if (order === "getBeforeSet" && getterIndex > setterIndex || order === "setBeforeGet" && getterIndex < setterIndex) {
                report("invalidOrder", formerNode, latterNode);
              }
            }
          }
        }
        return {
          ObjectExpression(node) {
            checkList(node.properties, (n) => n.type === "Property");
          },
          ClassBody(node) {
            checkList(node.body, (n) => n.type === "MethodDefinition" && !n.static);
            checkList(node.body, (n) => n.type === "MethodDefinition" && n.static);
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/guard-for-in.js
var require_guard_for_in = __commonJS({
  "../../node_modules/eslint/lib/rules/guard-for-in.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Require `for-in` loops to include an `if` statement",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/guard-for-in"
        },
        schema: [],
        messages: {
          wrap: "The body of a for-in should be wrapped in an if statement to filter unwanted properties from the prototype."
        }
      },
      create(context) {
        return {
          ForInStatement(node) {
            const body = node.body;
            if (body.type === "EmptyStatement") {
              return;
            }
            if (body.type === "IfStatement") {
              return;
            }
            if (body.type === "BlockStatement" && body.body.length === 0) {
              return;
            }
            if (body.type === "BlockStatement" && body.body.length === 1 && body.body[0].type === "IfStatement") {
              return;
            }
            if (body.type === "BlockStatement" && body.body.length >= 1 && body.body[0].type === "IfStatement") {
              const i = body.body[0];
              if (i.consequent.type === "ContinueStatement") {
                return;
              }
              if (i.consequent.type === "BlockStatement" && i.consequent.body.length === 1 && i.consequent.body[0].type === "ContinueStatement") {
                return;
              }
            }
            context.report({ node, messageId: "wrap" });
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/handle-callback-err.js
var require_handle_callback_err = __commonJS({
  "../../node_modules/eslint/lib/rules/handle-callback-err.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        deprecated: true,
        replacedBy: [],
        type: "suggestion",
        docs: {
          description: "Require error handling in callbacks",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/handle-callback-err"
        },
        schema: [
          {
            type: "string"
          }
        ],
        messages: {
          expected: "Expected error to be handled."
        }
      },
      create(context) {
        const errorArgument = context.options[0] || "err";
        const sourceCode = context.sourceCode;
        function isPattern(stringToCheck) {
          const firstChar = stringToCheck[0];
          return firstChar === "^";
        }
        function matchesConfiguredErrorName(name) {
          if (isPattern(errorArgument)) {
            const regexp = new RegExp(errorArgument, "u");
            return regexp.test(name);
          }
          return name === errorArgument;
        }
        function getParameters(scope) {
          return scope.variables.filter((variable) => variable.defs[0] && variable.defs[0].type === "Parameter");
        }
        function checkForError(node) {
          const scope = sourceCode.getScope(node), parameters = getParameters(scope), firstParameter = parameters[0];
          if (firstParameter && matchesConfiguredErrorName(firstParameter.name)) {
            if (firstParameter.references.length === 0) {
              context.report({ node, messageId: "expected" });
            }
          }
        }
        return {
          FunctionDeclaration: checkForError,
          FunctionExpression: checkForError,
          ArrowFunctionExpression: checkForError
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/id-blacklist.js
var require_id_blacklist = __commonJS({
  "../../node_modules/eslint/lib/rules/id-blacklist.js"(exports, module) {
    "use strict";
    function isAssignmentTarget(node) {
      const parent = node.parent;
      return (
        // normal assignment
        parent.type === "AssignmentExpression" && parent.left === node || // destructuring
        parent.type === "ArrayPattern" || parent.type === "RestElement" || parent.type === "Property" && parent.value === node && parent.parent.type === "ObjectPattern" || parent.type === "AssignmentPattern" && parent.left === node
      );
    }
    function isRenamedImport(node) {
      const parent = node.parent;
      return parent.type === "ImportSpecifier" && parent.imported !== parent.local && parent.imported === node || parent.type === "ExportSpecifier" && parent.parent.source && // re-export
      parent.local !== parent.exported && parent.local === node;
    }
    function isRenamedInDestructuring(node) {
      const parent = node.parent;
      return !parent.computed && parent.type === "Property" && parent.parent.type === "ObjectPattern" && parent.value !== node && parent.key === node;
    }
    function isShorthandPropertyDefinition(node) {
      const parent = node.parent;
      return parent.type === "Property" && parent.parent.type === "ObjectExpression" && parent.shorthand;
    }
    module.exports = {
      meta: {
        deprecated: true,
        replacedBy: ["id-denylist"],
        type: "suggestion",
        docs: {
          description: "Disallow specified identifiers",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/id-blacklist"
        },
        schema: {
          type: "array",
          items: {
            type: "string"
          },
          uniqueItems: true
        },
        messages: {
          restricted: "Identifier '{{name}}' is restricted."
        }
      },
      create(context) {
        const denyList = new Set(context.options);
        const reportedNodes = /* @__PURE__ */ new Set();
        const sourceCode = context.sourceCode;
        let globalScope;
        function isRestricted(name) {
          return denyList.has(name);
        }
        function isReferenceToGlobalVariable(node) {
          const variable = globalScope.set.get(node.name);
          return variable && variable.defs.length === 0 && variable.references.some((ref) => ref.identifier === node);
        }
        function shouldCheck(node) {
          const parent = node.parent;
          if (parent.type === "MemberExpression" && parent.property === node && !parent.computed) {
            return isAssignmentTarget(parent);
          }
          return parent.type !== "CallExpression" && parent.type !== "NewExpression" && !isRenamedImport(node) && !isRenamedInDestructuring(node) && !(isReferenceToGlobalVariable(node) && !isShorthandPropertyDefinition(node));
        }
        function report(node) {
          if (!reportedNodes.has(node.range.toString())) {
            context.report({
              node,
              messageId: "restricted",
              data: {
                name: node.name
              }
            });
            reportedNodes.add(node.range.toString());
          }
        }
        return {
          Program(node) {
            globalScope = sourceCode.getScope(node);
          },
          Identifier(node) {
            if (isRestricted(node.name) && shouldCheck(node)) {
              report(node);
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/id-denylist.js
var require_id_denylist = __commonJS({
  "../../node_modules/eslint/lib/rules/id-denylist.js"(exports, module) {
    "use strict";
    function isAssignmentTarget(node) {
      const parent = node.parent;
      return (
        // normal assignment
        parent.type === "AssignmentExpression" && parent.left === node || // destructuring
        parent.type === "ArrayPattern" || parent.type === "RestElement" || parent.type === "Property" && parent.value === node && parent.parent.type === "ObjectPattern" || parent.type === "AssignmentPattern" && parent.left === node
      );
    }
    function isRenamedImport(node) {
      const parent = node.parent;
      return parent.type === "ImportSpecifier" && parent.imported !== parent.local && parent.imported === node || parent.type === "ExportSpecifier" && parent.parent.source && // re-export
      parent.local !== parent.exported && parent.local === node;
    }
    function isPropertyNameInDestructuring(node) {
      const parent = node.parent;
      return !parent.computed && parent.type === "Property" && parent.parent.type === "ObjectPattern" && parent.key === node;
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow specified identifiers",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/id-denylist"
        },
        schema: {
          type: "array",
          items: {
            type: "string"
          },
          uniqueItems: true
        },
        messages: {
          restricted: "Identifier '{{name}}' is restricted.",
          restrictedPrivate: "Identifier '#{{name}}' is restricted."
        }
      },
      create(context) {
        const denyList = new Set(context.options);
        const reportedNodes = /* @__PURE__ */ new Set();
        const sourceCode = context.sourceCode;
        let globalScope;
        function isRestricted(name) {
          return denyList.has(name);
        }
        function isReferenceToGlobalVariable(node) {
          const variable = globalScope.set.get(node.name);
          return variable && variable.defs.length === 0 && variable.references.some((ref) => ref.identifier === node);
        }
        function shouldCheck(node) {
          const parent = node.parent;
          if (parent.type === "MemberExpression" && parent.property === node && !parent.computed) {
            return isAssignmentTarget(parent);
          }
          return parent.type !== "CallExpression" && parent.type !== "NewExpression" && !isRenamedImport(node) && !isPropertyNameInDestructuring(node) && !isReferenceToGlobalVariable(node);
        }
        function report(node) {
          if (!reportedNodes.has(node.range.toString())) {
            const isPrivate = node.type === "PrivateIdentifier";
            context.report({
              node,
              messageId: isPrivate ? "restrictedPrivate" : "restricted",
              data: {
                name: node.name
              }
            });
            reportedNodes.add(node.range.toString());
          }
        }
        return {
          Program(node) {
            globalScope = sourceCode.getScope(node);
          },
          [[
            "Identifier",
            "PrivateIdentifier"
          ]](node) {
            if (isRestricted(node.name) && shouldCheck(node)) {
              report(node);
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/id-length.js
var require_id_length = __commonJS({
  "../../node_modules/eslint/lib/rules/id-length.js"(exports, module) {
    "use strict";
    var { getGraphemeCount } = require_string_utils();
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Enforce minimum and maximum identifier lengths",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/id-length"
        },
        schema: [
          {
            type: "object",
            properties: {
              min: {
                type: "integer",
                default: 2
              },
              max: {
                type: "integer"
              },
              exceptions: {
                type: "array",
                uniqueItems: true,
                items: {
                  type: "string"
                }
              },
              exceptionPatterns: {
                type: "array",
                uniqueItems: true,
                items: {
                  type: "string"
                }
              },
              properties: {
                enum: ["always", "never"]
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          tooShort: "Identifier name '{{name}}' is too short (< {{min}}).",
          tooShortPrivate: "Identifier name '#{{name}}' is too short (< {{min}}).",
          tooLong: "Identifier name '{{name}}' is too long (> {{max}}).",
          tooLongPrivate: "Identifier name #'{{name}}' is too long (> {{max}})."
        }
      },
      create(context) {
        const options = context.options[0] || {};
        const minLength = typeof options.min !== "undefined" ? options.min : 2;
        const maxLength = typeof options.max !== "undefined" ? options.max : Infinity;
        const properties = options.properties !== "never";
        const exceptions = new Set(options.exceptions);
        const exceptionPatterns = (options.exceptionPatterns || []).map((pattern) => new RegExp(pattern, "u"));
        const reportedNodes = /* @__PURE__ */ new Set();
        function matchesExceptionPattern(name) {
          return exceptionPatterns.some((pattern) => pattern.test(name));
        }
        const SUPPORTED_EXPRESSIONS = {
          MemberExpression: properties && function(parent) {
            return !parent.computed && // regular property assignment
            (parent.parent.left === parent && parent.parent.type === "AssignmentExpression" || // or the last identifier in an ObjectPattern destructuring
            parent.parent.type === "Property" && parent.parent.value === parent && parent.parent.parent.type === "ObjectPattern" && parent.parent.parent.parent.left === parent.parent.parent);
          },
          AssignmentPattern(parent, node) {
            return parent.left === node;
          },
          VariableDeclarator(parent, node) {
            return parent.id === node;
          },
          Property(parent, node) {
            if (parent.parent.type === "ObjectPattern") {
              const isKeyAndValueSame = parent.value.name === parent.key.name;
              return !isKeyAndValueSame && parent.value === node || isKeyAndValueSame && parent.key === node && properties;
            }
            return properties && !parent.computed && parent.key.name === node.name;
          },
          ImportDefaultSpecifier: true,
          RestElement: true,
          FunctionExpression: true,
          ArrowFunctionExpression: true,
          ClassDeclaration: true,
          FunctionDeclaration: true,
          MethodDefinition: true,
          PropertyDefinition: true,
          CatchClause: true,
          ArrayPattern: true
        };
        return {
          [[
            "Identifier",
            "PrivateIdentifier"
          ]](node) {
            const name = node.name;
            const parent = node.parent;
            const nameLength = getGraphemeCount(name);
            const isShort = nameLength < minLength;
            const isLong = nameLength > maxLength;
            if (!(isShort || isLong) || exceptions.has(name) || matchesExceptionPattern(name)) {
              return;
            }
            const isValidExpression = SUPPORTED_EXPRESSIONS[parent.type];
            if (isValidExpression && !reportedNodes.has(node.range.toString()) && (isValidExpression === true || isValidExpression(parent, node))) {
              reportedNodes.add(node.range.toString());
              let messageId = isShort ? "tooShort" : "tooLong";
              if (node.type === "PrivateIdentifier") {
                messageId += "Private";
              }
              context.report({
                node,
                messageId,
                data: { name, min: minLength, max: maxLength }
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/id-match.js
var require_id_match = __commonJS({
  "../../node_modules/eslint/lib/rules/id-match.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Require identifiers to match a specified regular expression",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/id-match"
        },
        schema: [
          {
            type: "string"
          },
          {
            type: "object",
            properties: {
              properties: {
                type: "boolean",
                default: false
              },
              classFields: {
                type: "boolean",
                default: false
              },
              onlyDeclarations: {
                type: "boolean",
                default: false
              },
              ignoreDestructuring: {
                type: "boolean",
                default: false
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          notMatch: "Identifier '{{name}}' does not match the pattern '{{pattern}}'.",
          notMatchPrivate: "Identifier '#{{name}}' does not match the pattern '{{pattern}}'."
        }
      },
      create(context) {
        const pattern = context.options[0] || "^.+$", regexp = new RegExp(pattern, "u");
        const options = context.options[1] || {}, checkProperties = !!options.properties, checkClassFields = !!options.classFields, onlyDeclarations = !!options.onlyDeclarations, ignoreDestructuring = !!options.ignoreDestructuring;
        const sourceCode = context.sourceCode;
        let globalScope;
        const reportedNodes = /* @__PURE__ */ new Set();
        const ALLOWED_PARENT_TYPES = /* @__PURE__ */ new Set(["CallExpression", "NewExpression"]);
        const DECLARATION_TYPES = /* @__PURE__ */ new Set(["FunctionDeclaration", "VariableDeclarator"]);
        const IMPORT_TYPES = /* @__PURE__ */ new Set(["ImportSpecifier", "ImportNamespaceSpecifier", "ImportDefaultSpecifier"]);
        function isReferenceToGlobalVariable(node) {
          const variable = globalScope.set.get(node.name);
          return variable && variable.defs.length === 0 && variable.references.some((ref) => ref.identifier === node);
        }
        function isInvalid(name) {
          return !regexp.test(name);
        }
        function isInsideObjectPattern(node) {
          let { parent } = node;
          while (parent) {
            if (parent.type === "ObjectPattern") {
              return true;
            }
            parent = parent.parent;
          }
          return false;
        }
        function shouldReport(effectiveParent, name) {
          return (!onlyDeclarations || DECLARATION_TYPES.has(effectiveParent.type)) && !ALLOWED_PARENT_TYPES.has(effectiveParent.type) && isInvalid(name);
        }
        function report(node) {
          if (!reportedNodes.has(node.range.toString())) {
            const messageId = node.type === "PrivateIdentifier" ? "notMatchPrivate" : "notMatch";
            context.report({
              node,
              messageId,
              data: {
                name: node.name,
                pattern
              }
            });
            reportedNodes.add(node.range.toString());
          }
        }
        return {
          Program(node) {
            globalScope = sourceCode.getScope(node);
          },
          Identifier(node) {
            const name = node.name, parent = node.parent, effectiveParent = parent.type === "MemberExpression" ? parent.parent : parent;
            if (isReferenceToGlobalVariable(node)) {
              return;
            }
            if (parent.type === "MemberExpression") {
              if (!checkProperties) {
                return;
              }
              if (parent.object.type === "Identifier" && parent.object.name === name) {
                if (isInvalid(name)) {
                  report(node);
                }
              } else if (effectiveParent.type === "AssignmentExpression" && effectiveParent.left.type === "MemberExpression" && effectiveParent.left.property.name === node.name) {
                if (isInvalid(name)) {
                  report(node);
                }
              } else if (effectiveParent.type === "AssignmentExpression" && effectiveParent.right.type !== "MemberExpression") {
                if (isInvalid(name)) {
                  report(node);
                }
              }
            } else if (parent.type === "Property" && parent.parent.type === "ObjectExpression" && parent.key === node && !parent.computed) {
              if (checkProperties && isInvalid(name)) {
                report(node);
              }
            } else if (parent.type === "Property" || parent.type === "AssignmentPattern") {
              if (parent.parent && parent.parent.type === "ObjectPattern") {
                if (!ignoreDestructuring && parent.shorthand && parent.value.left && isInvalid(name)) {
                  report(node);
                }
                const assignmentKeyEqualsValue = parent.key.name === parent.value.name;
                if (!assignmentKeyEqualsValue && parent.key === node) {
                  return;
                }
                const valueIsInvalid = parent.value.name && isInvalid(name);
                if (valueIsInvalid && !(assignmentKeyEqualsValue && ignoreDestructuring)) {
                  report(node);
                }
              }
              if (!checkProperties && !parent.computed || ignoreDestructuring && isInsideObjectPattern(node)) {
                return;
              }
              if (parent.right !== node && shouldReport(effectiveParent, name)) {
                report(node);
              }
            } else if (IMPORT_TYPES.has(parent.type)) {
              if (parent.local && parent.local.name === node.name && isInvalid(name)) {
                report(node);
              }
            } else if (parent.type === "PropertyDefinition") {
              if (checkClassFields && isInvalid(name)) {
                report(node);
              }
            } else if (shouldReport(effectiveParent, name)) {
              report(node);
            }
          },
          "PrivateIdentifier"(node) {
            const isClassField = node.parent.type === "PropertyDefinition";
            if (isClassField && !checkClassFields) {
              return;
            }
            if (isInvalid(node.name)) {
              report(node);
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/implicit-arrow-linebreak.js
var require_implicit_arrow_linebreak = __commonJS({
  "../../node_modules/eslint/lib/rules/implicit-arrow-linebreak.js"(exports, module) {
    "use strict";
    var { isCommentToken, isNotOpeningParenToken } = require_ast_utils2();
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Enforce the location of arrow function bodies",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/implicit-arrow-linebreak"
        },
        fixable: "whitespace",
        schema: [
          {
            enum: ["beside", "below"]
          }
        ],
        messages: {
          expected: "Expected a linebreak before this expression.",
          unexpected: "Expected no linebreak before this expression."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        const option = context.options[0] || "beside";
        function validateExpression(node) {
          if (node.body.type === "BlockStatement") {
            return;
          }
          const arrowToken = sourceCode.getTokenBefore(node.body, isNotOpeningParenToken);
          const firstTokenOfBody = sourceCode.getTokenAfter(arrowToken);
          if (arrowToken.loc.end.line === firstTokenOfBody.loc.start.line && option === "below") {
            context.report({
              node: firstTokenOfBody,
              messageId: "expected",
              fix: (fixer) => fixer.insertTextBefore(firstTokenOfBody, "\n")
            });
          } else if (arrowToken.loc.end.line !== firstTokenOfBody.loc.start.line && option === "beside") {
            context.report({
              node: firstTokenOfBody,
              messageId: "unexpected",
              fix(fixer) {
                if (sourceCode.getFirstTokenBetween(arrowToken, firstTokenOfBody, { includeComments: true, filter: isCommentToken })) {
                  return null;
                }
                return fixer.replaceTextRange([arrowToken.range[1], firstTokenOfBody.range[0]], " ");
              }
            });
          }
        }
        return {
          ArrowFunctionExpression: (node) => validateExpression(node)
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/indent.js
var require_indent = __commonJS({
  "../../node_modules/eslint/lib/rules/indent.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var KNOWN_NODES = /* @__PURE__ */ new Set([
      "AssignmentExpression",
      "AssignmentPattern",
      "ArrayExpression",
      "ArrayPattern",
      "ArrowFunctionExpression",
      "AwaitExpression",
      "BlockStatement",
      "BinaryExpression",
      "BreakStatement",
      "CallExpression",
      "CatchClause",
      "ChainExpression",
      "ClassBody",
      "ClassDeclaration",
      "ClassExpression",
      "ConditionalExpression",
      "ContinueStatement",
      "DoWhileStatement",
      "DebuggerStatement",
      "EmptyStatement",
      "ExperimentalRestProperty",
      "ExperimentalSpreadProperty",
      "ExpressionStatement",
      "ForStatement",
      "ForInStatement",
      "ForOfStatement",
      "FunctionDeclaration",
      "FunctionExpression",
      "Identifier",
      "IfStatement",
      "Literal",
      "LabeledStatement",
      "LogicalExpression",
      "MemberExpression",
      "MetaProperty",
      "MethodDefinition",
      "NewExpression",
      "ObjectExpression",
      "ObjectPattern",
      "PrivateIdentifier",
      "Program",
      "Property",
      "PropertyDefinition",
      "RestElement",
      "ReturnStatement",
      "SequenceExpression",
      "SpreadElement",
      "StaticBlock",
      "Super",
      "SwitchCase",
      "SwitchStatement",
      "TaggedTemplateExpression",
      "TemplateElement",
      "TemplateLiteral",
      "ThisExpression",
      "ThrowStatement",
      "TryStatement",
      "UnaryExpression",
      "UpdateExpression",
      "VariableDeclaration",
      "VariableDeclarator",
      "WhileStatement",
      "WithStatement",
      "YieldExpression",
      "JSXFragment",
      "JSXOpeningFragment",
      "JSXClosingFragment",
      "JSXIdentifier",
      "JSXNamespacedName",
      "JSXMemberExpression",
      "JSXEmptyExpression",
      "JSXExpressionContainer",
      "JSXElement",
      "JSXClosingElement",
      "JSXOpeningElement",
      "JSXAttribute",
      "JSXSpreadAttribute",
      "JSXText",
      "ExportDefaultDeclaration",
      "ExportNamedDeclaration",
      "ExportAllDeclaration",
      "ExportSpecifier",
      "ImportDeclaration",
      "ImportSpecifier",
      "ImportDefaultSpecifier",
      "ImportNamespaceSpecifier",
      "ImportExpression"
    ]);
    var IndexMap = class {
      /**
       * Creates an empty map
       * @param {number} maxKey The maximum key
       */
      constructor(maxKey) {
        this._values = Array(maxKey + 1);
      }
      /**
       * Inserts an entry into the map.
       * @param {number} key The entry's key
       * @param {any} value The entry's value
       * @returns {void}
       */
      insert(key, value) {
        this._values[key] = value;
      }
      /**
       * Finds the value of the entry with the largest key less than or equal to the provided key
       * @param {number} key The provided key
       * @returns {*|undefined} The value of the found entry, or undefined if no such entry exists.
       */
      findLastNotAfter(key) {
        const values = this._values;
        for (let index = key; index >= 0; index--) {
          const value = values[index];
          if (value) {
            return value;
          }
        }
        return void 0;
      }
      /**
       * Deletes all of the keys in the interval [start, end)
       * @param {number} start The start of the range
       * @param {number} end The end of the range
       * @returns {void}
       */
      deleteRange(start, end) {
        this._values.fill(void 0, start, end);
      }
    };
    var TokenInfo = class {
      /**
       * @param {SourceCode} sourceCode A SourceCode object
       */
      constructor(sourceCode) {
        this.sourceCode = sourceCode;
        this.firstTokensByLineNumber = /* @__PURE__ */ new Map();
        const tokens = sourceCode.tokensAndComments;
        for (let i = 0; i < tokens.length; i++) {
          const token = tokens[i];
          if (!this.firstTokensByLineNumber.has(token.loc.start.line)) {
            this.firstTokensByLineNumber.set(token.loc.start.line, token);
          }
          if (!this.firstTokensByLineNumber.has(token.loc.end.line) && sourceCode.text.slice(token.range[1] - token.loc.end.column, token.range[1]).trim()) {
            this.firstTokensByLineNumber.set(token.loc.end.line, token);
          }
        }
      }
      /**
       * Gets the first token on a given token's line
       * @param {Token|ASTNode} token a node or token
       * @returns {Token} The first token on the given line
       */
      getFirstTokenOfLine(token) {
        return this.firstTokensByLineNumber.get(token.loc.start.line);
      }
      /**
       * Determines whether a token is the first token in its line
       * @param {Token} token The token
       * @returns {boolean} `true` if the token is the first on its line
       */
      isFirstTokenOfLine(token) {
        return this.getFirstTokenOfLine(token) === token;
      }
      /**
       * Get the actual indent of a token
       * @param {Token} token Token to examine. This should be the first token on its line.
       * @returns {string} The indentation characters that precede the token
       */
      getTokenIndent(token) {
        return this.sourceCode.text.slice(token.range[0] - token.loc.start.column, token.range[0]);
      }
    };
    var OffsetStorage = class {
      /**
       * @param {TokenInfo} tokenInfo a TokenInfo instance
       * @param {number} indentSize The desired size of each indentation level
       * @param {string} indentType The indentation character
       * @param {number} maxIndex The maximum end index of any token
       */
      constructor(tokenInfo, indentSize, indentType, maxIndex) {
        this._tokenInfo = tokenInfo;
        this._indentSize = indentSize;
        this._indentType = indentType;
        this._indexMap = new IndexMap(maxIndex);
        this._indexMap.insert(0, { offset: 0, from: null, force: false });
        this._lockedFirstTokens = /* @__PURE__ */ new WeakMap();
        this._desiredIndentCache = /* @__PURE__ */ new WeakMap();
        this._ignoredTokens = /* @__PURE__ */ new WeakSet();
      }
      _getOffsetDescriptor(token) {
        return this._indexMap.findLastNotAfter(token.range[0]);
      }
      /**
       * Sets the offset column of token B to match the offset column of token A.
       * - **WARNING**: This matches a *column*, even if baseToken is not the first token on its line. In
       * most cases, `setDesiredOffset` should be used instead.
       * @param {Token} baseToken The first token
       * @param {Token} offsetToken The second token, whose offset should be matched to the first token
       * @returns {void}
       */
      matchOffsetOf(baseToken, offsetToken) {
        this._lockedFirstTokens.set(offsetToken, baseToken);
      }
      /**
       * Sets the desired offset of a token.
       *
       * This uses a line-based offset collapsing behavior to handle tokens on the same line.
       * For example, consider the following two cases:
       *
       * (
       *     [
       *         bar
       *     ]
       * )
       *
       * ([
       *     bar
       * ])
       *
       * Based on the first case, it's clear that the `bar` token needs to have an offset of 1 indent level (4 spaces) from
       * the `[` token, and the `[` token has to have an offset of 1 indent level from the `(` token. Since the `(` token is
       * the first on its line (with an indent of 0 spaces), the `bar` token needs to be offset by 2 indent levels (8 spaces)
       * from the start of its line.
       *
       * However, in the second case `bar` should only be indented by 4 spaces. This is because the offset of 1 indent level
       * between the `(` and the `[` tokens gets "collapsed" because the two tokens are on the same line. As a result, the
       * `(` token is mapped to the `[` token with an offset of 0, and the rule correctly decides that `bar` should be indented
       * by 1 indent level from the start of the line.
       *
       * This is useful because rule listeners can usually just call `setDesiredOffset` for all the tokens in the node,
       * without needing to check which lines those tokens are on.
       *
       * Note that since collapsing only occurs when two tokens are on the same line, there are a few cases where non-intuitive
       * behavior can occur. For example, consider the following cases:
       *
       * foo(
       * ).
       *     bar(
       *         baz
       *     )
       *
       * foo(
       * ).bar(
       *     baz
       * )
       *
       * Based on the first example, it would seem that `bar` should be offset by 1 indent level from `foo`, and `baz`
       * should be offset by 1 indent level from `bar`. However, this is not correct, because it would result in `baz`
       * being indented by 2 indent levels in the second case (since `foo`, `bar`, and `baz` are all on separate lines, no
       * collapsing would occur).
       *
       * Instead, the correct way would be to offset `baz` by 1 level from `bar`, offset `bar` by 1 level from the `)`, and
       * offset the `)` by 0 levels from `foo`. This ensures that the offset between `bar` and the `)` are correctly collapsed
       * in the second case.
       * @param {Token} token The token
       * @param {Token} fromToken The token that `token` should be offset from
       * @param {number} offset The desired indent level
       * @returns {void}
       */
      setDesiredOffset(token, fromToken, offset) {
        return this.setDesiredOffsets(token.range, fromToken, offset);
      }
      /**
       * Sets the desired offset of all tokens in a range
       * It's common for node listeners in this file to need to apply the same offset to a large, contiguous range of tokens.
       * Moreover, the offset of any given token is usually updated multiple times (roughly once for each node that contains
       * it). This means that the offset of each token is updated O(AST depth) times.
       * It would not be performant to store and update the offsets for each token independently, because the rule would end
       * up having a time complexity of O(number of tokens * AST depth), which is quite slow for large files.
       *
       * Instead, the offset tree is represented as a collection of contiguous offset ranges in a file. For example, the following
       * list could represent the state of the offset tree at a given point:
       *
       * - Tokens starting in the interval [0, 15) are aligned with the beginning of the file
       * - Tokens starting in the interval [15, 30) are offset by 1 indent level from the `bar` token
       * - Tokens starting in the interval [30, 43) are offset by 1 indent level from the `foo` token
       * - Tokens starting in the interval [43, 820) are offset by 2 indent levels from the `bar` token
       * - Tokens starting in the interval [820, ) are offset by 1 indent level from the `baz` token
       *
       * The `setDesiredOffsets` methods inserts ranges like the ones above. The third line above would be inserted by using:
       * `setDesiredOffsets([30, 43], fooToken, 1);`
       * @param {[number, number]} range A [start, end] pair. All tokens with range[0] <= token.start < range[1] will have the offset applied.
       * @param {Token} fromToken The token that this is offset from
       * @param {number} offset The desired indent level
       * @param {boolean} force `true` if this offset should not use the normal collapsing behavior. This should almost always be false.
       * @returns {void}
       */
      setDesiredOffsets(range, fromToken, offset, force) {
        const descriptorToInsert = { offset, from: fromToken, force };
        const descriptorAfterRange = this._indexMap.findLastNotAfter(range[1]);
        const fromTokenIsInRange = fromToken && fromToken.range[0] >= range[0] && fromToken.range[1] <= range[1];
        const fromTokenDescriptor = fromTokenIsInRange && this._getOffsetDescriptor(fromToken);
        this._indexMap.deleteRange(range[0] + 1, range[1]);
        this._indexMap.insert(range[0], descriptorToInsert);
        if (fromTokenIsInRange) {
          this._indexMap.insert(fromToken.range[0], fromTokenDescriptor);
          this._indexMap.insert(fromToken.range[1], descriptorToInsert);
        }
        this._indexMap.insert(range[1], descriptorAfterRange);
      }
      /**
       * Gets the desired indent of a token
       * @param {Token} token The token
       * @returns {string} The desired indent of the token
       */
      getDesiredIndent(token) {
        if (!this._desiredIndentCache.has(token)) {
          if (this._ignoredTokens.has(token)) {
            this._desiredIndentCache.set(
              token,
              this._tokenInfo.getTokenIndent(token)
            );
          } else if (this._lockedFirstTokens.has(token)) {
            const firstToken = this._lockedFirstTokens.get(token);
            this._desiredIndentCache.set(
              token,
              // (indentation for the first element's line)
              this.getDesiredIndent(this._tokenInfo.getFirstTokenOfLine(firstToken)) + // (space between the start of the first element's line and the first element)
              this._indentType.repeat(firstToken.loc.start.column - this._tokenInfo.getFirstTokenOfLine(firstToken).loc.start.column)
            );
          } else {
            const offsetInfo = this._getOffsetDescriptor(token);
            const offset = offsetInfo.from && offsetInfo.from.loc.start.line === token.loc.start.line && !/^\s*?\n/u.test(token.value) && !offsetInfo.force ? 0 : offsetInfo.offset * this._indentSize;
            this._desiredIndentCache.set(
              token,
              (offsetInfo.from ? this.getDesiredIndent(offsetInfo.from) : "") + this._indentType.repeat(offset)
            );
          }
        }
        return this._desiredIndentCache.get(token);
      }
      /**
       * Ignores a token, preventing it from being reported.
       * @param {Token} token The token
       * @returns {void}
       */
      ignoreToken(token) {
        if (this._tokenInfo.isFirstTokenOfLine(token)) {
          this._ignoredTokens.add(token);
        }
      }
      /**
       * Gets the first token that the given token's indentation is dependent on
       * @param {Token} token The token
       * @returns {Token} The token that the given token depends on, or `null` if the given token is at the top level
       */
      getFirstDependency(token) {
        return this._getOffsetDescriptor(token).from;
      }
    };
    var ELEMENT_LIST_SCHEMA = {
      oneOf: [
        {
          type: "integer",
          minimum: 0
        },
        {
          enum: ["first", "off"]
        }
      ]
    };
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Enforce consistent indentation",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/indent"
        },
        fixable: "whitespace",
        schema: [
          {
            oneOf: [
              {
                enum: ["tab"]
              },
              {
                type: "integer",
                minimum: 0
              }
            ]
          },
          {
            type: "object",
            properties: {
              SwitchCase: {
                type: "integer",
                minimum: 0,
                default: 0
              },
              VariableDeclarator: {
                oneOf: [
                  ELEMENT_LIST_SCHEMA,
                  {
                    type: "object",
                    properties: {
                      var: ELEMENT_LIST_SCHEMA,
                      let: ELEMENT_LIST_SCHEMA,
                      const: ELEMENT_LIST_SCHEMA
                    },
                    additionalProperties: false
                  }
                ]
              },
              outerIIFEBody: {
                oneOf: [
                  {
                    type: "integer",
                    minimum: 0
                  },
                  {
                    enum: ["off"]
                  }
                ]
              },
              MemberExpression: {
                oneOf: [
                  {
                    type: "integer",
                    minimum: 0
                  },
                  {
                    enum: ["off"]
                  }
                ]
              },
              FunctionDeclaration: {
                type: "object",
                properties: {
                  parameters: ELEMENT_LIST_SCHEMA,
                  body: {
                    type: "integer",
                    minimum: 0
                  }
                },
                additionalProperties: false
              },
              FunctionExpression: {
                type: "object",
                properties: {
                  parameters: ELEMENT_LIST_SCHEMA,
                  body: {
                    type: "integer",
                    minimum: 0
                  }
                },
                additionalProperties: false
              },
              StaticBlock: {
                type: "object",
                properties: {
                  body: {
                    type: "integer",
                    minimum: 0
                  }
                },
                additionalProperties: false
              },
              CallExpression: {
                type: "object",
                properties: {
                  arguments: ELEMENT_LIST_SCHEMA
                },
                additionalProperties: false
              },
              ArrayExpression: ELEMENT_LIST_SCHEMA,
              ObjectExpression: ELEMENT_LIST_SCHEMA,
              ImportDeclaration: ELEMENT_LIST_SCHEMA,
              flatTernaryExpressions: {
                type: "boolean",
                default: false
              },
              offsetTernaryExpressions: {
                type: "boolean",
                default: false
              },
              ignoredNodes: {
                type: "array",
                items: {
                  type: "string",
                  not: {
                    pattern: ":exit$"
                  }
                }
              },
              ignoreComments: {
                type: "boolean",
                default: false
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          wrongIndentation: "Expected indentation of {{expected}} but found {{actual}}."
        }
      },
      create(context) {
        const DEFAULT_VARIABLE_INDENT = 1;
        const DEFAULT_PARAMETER_INDENT = 1;
        const DEFAULT_FUNCTION_BODY_INDENT = 1;
        let indentType = "space";
        let indentSize = 4;
        const options = {
          SwitchCase: 0,
          VariableDeclarator: {
            var: DEFAULT_VARIABLE_INDENT,
            let: DEFAULT_VARIABLE_INDENT,
            const: DEFAULT_VARIABLE_INDENT
          },
          outerIIFEBody: 1,
          FunctionDeclaration: {
            parameters: DEFAULT_PARAMETER_INDENT,
            body: DEFAULT_FUNCTION_BODY_INDENT
          },
          FunctionExpression: {
            parameters: DEFAULT_PARAMETER_INDENT,
            body: DEFAULT_FUNCTION_BODY_INDENT
          },
          StaticBlock: {
            body: DEFAULT_FUNCTION_BODY_INDENT
          },
          CallExpression: {
            arguments: DEFAULT_PARAMETER_INDENT
          },
          MemberExpression: 1,
          ArrayExpression: 1,
          ObjectExpression: 1,
          ImportDeclaration: 1,
          flatTernaryExpressions: false,
          ignoredNodes: [],
          ignoreComments: false
        };
        if (context.options.length) {
          if (context.options[0] === "tab") {
            indentSize = 1;
            indentType = "tab";
          } else {
            indentSize = context.options[0];
            indentType = "space";
          }
          if (context.options[1]) {
            Object.assign(options, context.options[1]);
            if (typeof options.VariableDeclarator === "number" || options.VariableDeclarator === "first") {
              options.VariableDeclarator = {
                var: options.VariableDeclarator,
                let: options.VariableDeclarator,
                const: options.VariableDeclarator
              };
            }
          }
        }
        const sourceCode = context.sourceCode;
        const tokenInfo = new TokenInfo(sourceCode);
        const offsets = new OffsetStorage(tokenInfo, indentSize, indentType === "space" ? " " : "	", sourceCode.text.length);
        const parameterParens = /* @__PURE__ */ new WeakSet();
        function createErrorMessageData(expectedAmount, actualSpaces, actualTabs) {
          const expectedStatement = `${expectedAmount} ${indentType}${expectedAmount === 1 ? "" : "s"}`;
          const foundSpacesWord = `space${actualSpaces === 1 ? "" : "s"}`;
          const foundTabsWord = `tab${actualTabs === 1 ? "" : "s"}`;
          let foundStatement;
          if (actualSpaces > 0) {
            foundStatement = indentType === "space" ? actualSpaces : `${actualSpaces} ${foundSpacesWord}`;
          } else if (actualTabs > 0) {
            foundStatement = indentType === "tab" ? actualTabs : `${actualTabs} ${foundTabsWord}`;
          } else {
            foundStatement = "0";
          }
          return {
            expected: expectedStatement,
            actual: foundStatement
          };
        }
        function report(token, neededIndent) {
          const actualIndent = Array.from(tokenInfo.getTokenIndent(token));
          const numSpaces = actualIndent.filter((char) => char === " ").length;
          const numTabs = actualIndent.filter((char) => char === "	").length;
          context.report({
            node: token,
            messageId: "wrongIndentation",
            data: createErrorMessageData(neededIndent.length, numSpaces, numTabs),
            loc: {
              start: { line: token.loc.start.line, column: 0 },
              end: { line: token.loc.start.line, column: token.loc.start.column }
            },
            fix(fixer) {
              const range = [token.range[0] - token.loc.start.column, token.range[0]];
              const newText = neededIndent;
              return fixer.replaceTextRange(range, newText);
            }
          });
        }
        function validateTokenIndent(token, desiredIndent) {
          const indentation = tokenInfo.getTokenIndent(token);
          return indentation === desiredIndent || // To avoid conflicts with no-mixed-spaces-and-tabs, don't report mixed spaces and tabs.
          indentation.includes(" ") && indentation.includes("	");
        }
        function isOuterIIFE(node) {
          if (!node.parent || node.parent.type !== "CallExpression" || node.parent.callee !== node) {
            return false;
          }
          let statement = node.parent && node.parent.parent;
          while (statement.type === "UnaryExpression" && ["!", "~", "+", "-"].includes(statement.operator) || statement.type === "AssignmentExpression" || statement.type === "LogicalExpression" || statement.type === "SequenceExpression" || statement.type === "VariableDeclarator") {
            statement = statement.parent;
          }
          return (statement.type === "ExpressionStatement" || statement.type === "VariableDeclaration") && statement.parent.type === "Program";
        }
        function countTrailingLinebreaks(string) {
          const trailingWhitespace = string.match(/\s*$/u)[0];
          const linebreakMatches = trailingWhitespace.match(astUtils.createGlobalLinebreakMatcher());
          return linebreakMatches === null ? 0 : linebreakMatches.length;
        }
        function addElementListIndent(elements, startToken, endToken, offset) {
          function getFirstToken(element) {
            let token = sourceCode.getTokenBefore(element);
            while (astUtils.isOpeningParenToken(token) && token !== startToken) {
              token = sourceCode.getTokenBefore(token);
            }
            return sourceCode.getTokenAfter(token);
          }
          offsets.setDesiredOffsets(
            [startToken.range[1], endToken.range[0]],
            startToken,
            typeof offset === "number" ? offset : 1
          );
          offsets.setDesiredOffset(endToken, startToken, 0);
          if (offset === "first" && elements.length && !elements[0]) {
            return;
          }
          elements.forEach((element, index) => {
            if (!element) {
              return;
            }
            if (offset === "off") {
              offsets.ignoreToken(getFirstToken(element));
            }
            if (index === 0) {
              return;
            }
            if (offset === "first" && tokenInfo.isFirstTokenOfLine(getFirstToken(element))) {
              offsets.matchOffsetOf(getFirstToken(elements[0]), getFirstToken(element));
            } else {
              const previousElement = elements[index - 1];
              const firstTokenOfPreviousElement = previousElement && getFirstToken(previousElement);
              const previousElementLastToken = previousElement && sourceCode.getLastToken(previousElement);
              if (previousElement && previousElementLastToken.loc.end.line - countTrailingLinebreaks(previousElementLastToken.value) > startToken.loc.end.line) {
                offsets.setDesiredOffsets(
                  [previousElement.range[1], element.range[1]],
                  firstTokenOfPreviousElement,
                  0
                );
              }
            }
          });
        }
        function addBlocklessNodeIndent(node) {
          if (node.type !== "BlockStatement") {
            const lastParentToken = sourceCode.getTokenBefore(node, astUtils.isNotOpeningParenToken);
            let firstBodyToken = sourceCode.getFirstToken(node);
            let lastBodyToken = sourceCode.getLastToken(node);
            while (astUtils.isOpeningParenToken(sourceCode.getTokenBefore(firstBodyToken)) && astUtils.isClosingParenToken(sourceCode.getTokenAfter(lastBodyToken))) {
              firstBodyToken = sourceCode.getTokenBefore(firstBodyToken);
              lastBodyToken = sourceCode.getTokenAfter(lastBodyToken);
            }
            offsets.setDesiredOffsets([firstBodyToken.range[0], lastBodyToken.range[1]], lastParentToken, 1);
          }
        }
        function addFunctionCallIndent(node) {
          let openingParen;
          if (node.arguments.length) {
            openingParen = sourceCode.getFirstTokenBetween(node.callee, node.arguments[0], astUtils.isOpeningParenToken);
          } else {
            openingParen = sourceCode.getLastToken(node, 1);
          }
          const closingParen = sourceCode.getLastToken(node);
          parameterParens.add(openingParen);
          parameterParens.add(closingParen);
          if (node.optional) {
            const dotToken = sourceCode.getTokenAfter(node.callee, astUtils.isQuestionDotToken);
            const calleeParenCount = sourceCode.getTokensBetween(node.callee, dotToken, { filter: astUtils.isClosingParenToken }).length;
            const firstTokenOfCallee = calleeParenCount ? sourceCode.getTokenBefore(node.callee, { skip: calleeParenCount - 1 }) : sourceCode.getFirstToken(node.callee);
            const lastTokenOfCallee = sourceCode.getTokenBefore(dotToken);
            const offsetBase = lastTokenOfCallee.loc.end.line === openingParen.loc.start.line ? lastTokenOfCallee : firstTokenOfCallee;
            offsets.setDesiredOffset(dotToken, offsetBase, 1);
          }
          const offsetAfterToken = node.callee.type === "TaggedTemplateExpression" ? sourceCode.getFirstToken(node.callee.quasi) : openingParen;
          const offsetToken = sourceCode.getTokenBefore(offsetAfterToken);
          offsets.setDesiredOffset(openingParen, offsetToken, 0);
          addElementListIndent(node.arguments, openingParen, closingParen, options.CallExpression.arguments);
        }
        function addParensIndent(tokens) {
          const parenStack = [];
          const parenPairs = [];
          for (let i = 0; i < tokens.length; i++) {
            const nextToken = tokens[i];
            if (astUtils.isOpeningParenToken(nextToken)) {
              parenStack.push(nextToken);
            } else if (astUtils.isClosingParenToken(nextToken)) {
              parenPairs.push({ left: parenStack.pop(), right: nextToken });
            }
          }
          for (let i = parenPairs.length - 1; i >= 0; i--) {
            const leftParen = parenPairs[i].left;
            const rightParen = parenPairs[i].right;
            if (!parameterParens.has(leftParen) && !parameterParens.has(rightParen)) {
              const parenthesizedTokens = new Set(sourceCode.getTokensBetween(leftParen, rightParen));
              parenthesizedTokens.forEach((token) => {
                if (!parenthesizedTokens.has(offsets.getFirstDependency(token))) {
                  offsets.setDesiredOffset(token, leftParen, 1);
                }
              });
            }
            offsets.setDesiredOffset(rightParen, leftParen, 0);
          }
        }
        function ignoreNode(node) {
          const unknownNodeTokens = new Set(sourceCode.getTokens(node, { includeComments: true }));
          unknownNodeTokens.forEach((token) => {
            if (!unknownNodeTokens.has(offsets.getFirstDependency(token))) {
              const firstTokenOfLine = tokenInfo.getFirstTokenOfLine(token);
              if (token === firstTokenOfLine) {
                offsets.ignoreToken(token);
              } else {
                offsets.setDesiredOffset(token, firstTokenOfLine, 0);
              }
            }
          });
        }
        function isOnFirstLineOfStatement(token, leafNode) {
          let node = leafNode;
          while (node.parent && !node.parent.type.endsWith("Statement") && !node.parent.type.endsWith("Declaration")) {
            node = node.parent;
          }
          node = node.parent;
          return !node || node.loc.start.line === token.loc.start.line;
        }
        function hasBlankLinesBetween(firstToken, secondToken) {
          const firstTokenLine = firstToken.loc.end.line;
          const secondTokenLine = secondToken.loc.start.line;
          if (firstTokenLine === secondTokenLine || firstTokenLine === secondTokenLine - 1) {
            return false;
          }
          for (let line = firstTokenLine + 1; line < secondTokenLine; ++line) {
            if (!tokenInfo.firstTokensByLineNumber.has(line)) {
              return true;
            }
          }
          return false;
        }
        const ignoredNodeFirstTokens = /* @__PURE__ */ new Set();
        const baseOffsetListeners = {
          "ArrayExpression, ArrayPattern"(node) {
            const openingBracket = sourceCode.getFirstToken(node);
            const closingBracket = sourceCode.getTokenAfter([...node.elements].reverse().find((_) => _) || openingBracket, astUtils.isClosingBracketToken);
            addElementListIndent(node.elements, openingBracket, closingBracket, options.ArrayExpression);
          },
          "ObjectExpression, ObjectPattern"(node) {
            const openingCurly = sourceCode.getFirstToken(node);
            const closingCurly = sourceCode.getTokenAfter(
              node.properties.length ? node.properties[node.properties.length - 1] : openingCurly,
              astUtils.isClosingBraceToken
            );
            addElementListIndent(node.properties, openingCurly, closingCurly, options.ObjectExpression);
          },
          ArrowFunctionExpression(node) {
            const maybeOpeningParen = sourceCode.getFirstToken(node, { skip: node.async ? 1 : 0 });
            if (astUtils.isOpeningParenToken(maybeOpeningParen)) {
              const openingParen = maybeOpeningParen;
              const closingParen = sourceCode.getTokenBefore(node.body, astUtils.isClosingParenToken);
              parameterParens.add(openingParen);
              parameterParens.add(closingParen);
              addElementListIndent(node.params, openingParen, closingParen, options.FunctionExpression.parameters);
            }
            addBlocklessNodeIndent(node.body);
          },
          AssignmentExpression(node) {
            const operator = sourceCode.getFirstTokenBetween(node.left, node.right, (token) => token.value === node.operator);
            offsets.setDesiredOffsets([operator.range[0], node.range[1]], sourceCode.getLastToken(node.left), 1);
            offsets.ignoreToken(operator);
            offsets.ignoreToken(sourceCode.getTokenAfter(operator));
          },
          "BinaryExpression, LogicalExpression"(node) {
            const operator = sourceCode.getFirstTokenBetween(node.left, node.right, (token) => token.value === node.operator);
            const tokenAfterOperator = sourceCode.getTokenAfter(operator);
            offsets.ignoreToken(operator);
            offsets.ignoreToken(tokenAfterOperator);
            offsets.setDesiredOffset(tokenAfterOperator, operator, 0);
          },
          "BlockStatement, ClassBody"(node) {
            let blockIndentLevel;
            if (node.parent && isOuterIIFE(node.parent)) {
              blockIndentLevel = options.outerIIFEBody;
            } else if (node.parent && (node.parent.type === "FunctionExpression" || node.parent.type === "ArrowFunctionExpression")) {
              blockIndentLevel = options.FunctionExpression.body;
            } else if (node.parent && node.parent.type === "FunctionDeclaration") {
              blockIndentLevel = options.FunctionDeclaration.body;
            } else {
              blockIndentLevel = 1;
            }
            if (!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {
              offsets.setDesiredOffset(sourceCode.getFirstToken(node), sourceCode.getFirstToken(node.parent), 0);
            }
            addElementListIndent(node.body, sourceCode.getFirstToken(node), sourceCode.getLastToken(node), blockIndentLevel);
          },
          CallExpression: addFunctionCallIndent,
          "ClassDeclaration[superClass], ClassExpression[superClass]"(node) {
            const classToken = sourceCode.getFirstToken(node);
            const extendsToken = sourceCode.getTokenBefore(node.superClass, astUtils.isNotOpeningParenToken);
            offsets.setDesiredOffsets([extendsToken.range[0], node.body.range[0]], classToken, 1);
          },
          ConditionalExpression(node) {
            const firstToken = sourceCode.getFirstToken(node);
            if (!options.flatTernaryExpressions || !astUtils.isTokenOnSameLine(node.test, node.consequent) || isOnFirstLineOfStatement(firstToken, node)) {
              const questionMarkToken = sourceCode.getFirstTokenBetween(node.test, node.consequent, (token) => token.type === "Punctuator" && token.value === "?");
              const colonToken = sourceCode.getFirstTokenBetween(node.consequent, node.alternate, (token) => token.type === "Punctuator" && token.value === ":");
              const firstConsequentToken = sourceCode.getTokenAfter(questionMarkToken);
              const lastConsequentToken = sourceCode.getTokenBefore(colonToken);
              const firstAlternateToken = sourceCode.getTokenAfter(colonToken);
              offsets.setDesiredOffset(questionMarkToken, firstToken, 1);
              offsets.setDesiredOffset(colonToken, firstToken, 1);
              offsets.setDesiredOffset(firstConsequentToken, firstToken, firstConsequentToken.type === "Punctuator" && options.offsetTernaryExpressions ? 2 : 1);
              if (lastConsequentToken.loc.end.line === firstAlternateToken.loc.start.line) {
                offsets.setDesiredOffset(firstAlternateToken, firstConsequentToken, 0);
              } else {
                offsets.setDesiredOffset(firstAlternateToken, firstToken, firstAlternateToken.type === "Punctuator" && options.offsetTernaryExpressions ? 2 : 1);
              }
            }
          },
          "DoWhileStatement, WhileStatement, ForInStatement, ForOfStatement, WithStatement": (node) => addBlocklessNodeIndent(node.body),
          ExportNamedDeclaration(node) {
            if (node.declaration === null) {
              const closingCurly = sourceCode.getLastToken(node, astUtils.isClosingBraceToken);
              addElementListIndent(node.specifiers, sourceCode.getFirstToken(node, { skip: 1 }), closingCurly, 1);
              if (node.source) {
                offsets.setDesiredOffsets([closingCurly.range[1], node.range[1]], sourceCode.getFirstToken(node), 1);
              }
            }
          },
          ForStatement(node) {
            const forOpeningParen = sourceCode.getFirstToken(node, 1);
            if (node.init) {
              offsets.setDesiredOffsets(node.init.range, forOpeningParen, 1);
            }
            if (node.test) {
              offsets.setDesiredOffsets(node.test.range, forOpeningParen, 1);
            }
            if (node.update) {
              offsets.setDesiredOffsets(node.update.range, forOpeningParen, 1);
            }
            addBlocklessNodeIndent(node.body);
          },
          "FunctionDeclaration, FunctionExpression"(node) {
            const closingParen = sourceCode.getTokenBefore(node.body);
            const openingParen = sourceCode.getTokenBefore(node.params.length ? node.params[0] : closingParen);
            parameterParens.add(openingParen);
            parameterParens.add(closingParen);
            addElementListIndent(node.params, openingParen, closingParen, options[node.type].parameters);
          },
          IfStatement(node) {
            addBlocklessNodeIndent(node.consequent);
            if (node.alternate) {
              addBlocklessNodeIndent(node.alternate);
            }
          },
          /*
           * For blockless nodes with semicolon-first style, don't indent the semicolon.
           * e.g.
           * if (foo)
           *     bar()
           * ; [1, 2, 3].map(foo)
           *
           * Traversal into the node sets indentation of the semicolon, so we need to override it on exit.
           */
          ":matches(DoWhileStatement, ForStatement, ForInStatement, ForOfStatement, IfStatement, WhileStatement, WithStatement):exit"(node) {
            let nodesToCheck;
            if (node.type === "IfStatement") {
              nodesToCheck = [node.consequent];
              if (node.alternate) {
                nodesToCheck.push(node.alternate);
              }
            } else {
              nodesToCheck = [node.body];
            }
            for (const nodeToCheck of nodesToCheck) {
              const lastToken = sourceCode.getLastToken(nodeToCheck);
              if (astUtils.isSemicolonToken(lastToken)) {
                const tokenBeforeLast = sourceCode.getTokenBefore(lastToken);
                const tokenAfterLast = sourceCode.getTokenAfter(lastToken);
                if (!astUtils.isTokenOnSameLine(tokenBeforeLast, lastToken) && tokenAfterLast && astUtils.isTokenOnSameLine(lastToken, tokenAfterLast)) {
                  offsets.setDesiredOffset(
                    lastToken,
                    sourceCode.getFirstToken(node),
                    0
                  );
                }
              }
            }
          },
          ImportDeclaration(node) {
            if (node.specifiers.some((specifier) => specifier.type === "ImportSpecifier")) {
              const openingCurly = sourceCode.getFirstToken(node, astUtils.isOpeningBraceToken);
              const closingCurly = sourceCode.getLastToken(node, astUtils.isClosingBraceToken);
              addElementListIndent(node.specifiers.filter((specifier) => specifier.type === "ImportSpecifier"), openingCurly, closingCurly, options.ImportDeclaration);
            }
            const fromToken = sourceCode.getLastToken(node, (token) => token.type === "Identifier" && token.value === "from");
            const sourceToken = sourceCode.getLastToken(node, (token) => token.type === "String");
            const semiToken = sourceCode.getLastToken(node, (token) => token.type === "Punctuator" && token.value === ";");
            if (fromToken) {
              const end = semiToken && semiToken.range[1] === sourceToken.range[1] ? node.range[1] : sourceToken.range[1];
              offsets.setDesiredOffsets([fromToken.range[0], end], sourceCode.getFirstToken(node), 1);
            }
          },
          ImportExpression(node) {
            const openingParen = sourceCode.getFirstToken(node, 1);
            const closingParen = sourceCode.getLastToken(node);
            parameterParens.add(openingParen);
            parameterParens.add(closingParen);
            offsets.setDesiredOffset(openingParen, sourceCode.getTokenBefore(openingParen), 0);
            addElementListIndent([node.source], openingParen, closingParen, options.CallExpression.arguments);
          },
          "MemberExpression, JSXMemberExpression, MetaProperty"(node) {
            const object = node.type === "MetaProperty" ? node.meta : node.object;
            const firstNonObjectToken = sourceCode.getFirstTokenBetween(object, node.property, astUtils.isNotClosingParenToken);
            const secondNonObjectToken = sourceCode.getTokenAfter(firstNonObjectToken);
            const objectParenCount = sourceCode.getTokensBetween(object, node.property, { filter: astUtils.isClosingParenToken }).length;
            const firstObjectToken = objectParenCount ? sourceCode.getTokenBefore(object, { skip: objectParenCount - 1 }) : sourceCode.getFirstToken(object);
            const lastObjectToken = sourceCode.getTokenBefore(firstNonObjectToken);
            const firstPropertyToken = node.computed ? firstNonObjectToken : secondNonObjectToken;
            if (node.computed) {
              offsets.setDesiredOffset(sourceCode.getLastToken(node), firstNonObjectToken, 0);
              offsets.setDesiredOffsets(node.property.range, firstNonObjectToken, 1);
            }
            const offsetBase = lastObjectToken.loc.end.line === firstPropertyToken.loc.start.line ? lastObjectToken : firstObjectToken;
            if (typeof options.MemberExpression === "number") {
              offsets.setDesiredOffset(firstNonObjectToken, offsetBase, options.MemberExpression);
              offsets.setDesiredOffset(secondNonObjectToken, node.computed ? firstNonObjectToken : offsetBase, options.MemberExpression);
            } else {
              offsets.ignoreToken(firstNonObjectToken);
              offsets.ignoreToken(secondNonObjectToken);
              offsets.setDesiredOffset(firstNonObjectToken, offsetBase, 0);
              offsets.setDesiredOffset(secondNonObjectToken, firstNonObjectToken, 0);
            }
          },
          NewExpression(node) {
            if (node.arguments.length > 0 || astUtils.isClosingParenToken(sourceCode.getLastToken(node)) && astUtils.isOpeningParenToken(sourceCode.getLastToken(node, 1))) {
              addFunctionCallIndent(node);
            }
          },
          Property(node) {
            if (!node.shorthand && !node.method && node.kind === "init") {
              const colon = sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isColonToken);
              offsets.ignoreToken(sourceCode.getTokenAfter(colon));
            }
          },
          PropertyDefinition(node) {
            const firstToken = sourceCode.getFirstToken(node);
            const maybeSemicolonToken = sourceCode.getLastToken(node);
            let keyLastToken = null;
            if (node.computed) {
              const bracketTokenL = sourceCode.getTokenBefore(node.key, astUtils.isOpeningBracketToken);
              const bracketTokenR = keyLastToken = sourceCode.getTokenAfter(node.key, astUtils.isClosingBracketToken);
              const keyRange = [bracketTokenL.range[1], bracketTokenR.range[0]];
              if (bracketTokenL !== firstToken) {
                offsets.setDesiredOffset(bracketTokenL, firstToken, 0);
              }
              offsets.setDesiredOffsets(keyRange, bracketTokenL, 1);
              offsets.setDesiredOffset(bracketTokenR, bracketTokenL, 0);
            } else {
              const idToken = keyLastToken = sourceCode.getFirstToken(node.key);
              if (idToken !== firstToken) {
                offsets.setDesiredOffset(idToken, firstToken, 1);
              }
            }
            if (node.value) {
              const eqToken = sourceCode.getTokenBefore(node.value, astUtils.isEqToken);
              const valueToken = sourceCode.getTokenAfter(eqToken);
              offsets.setDesiredOffset(eqToken, keyLastToken, 1);
              offsets.setDesiredOffset(valueToken, eqToken, 1);
              if (astUtils.isSemicolonToken(maybeSemicolonToken)) {
                offsets.setDesiredOffset(maybeSemicolonToken, eqToken, 1);
              }
            } else if (astUtils.isSemicolonToken(maybeSemicolonToken)) {
              offsets.setDesiredOffset(maybeSemicolonToken, keyLastToken, 1);
            }
          },
          StaticBlock(node) {
            const openingCurly = sourceCode.getFirstToken(node, { skip: 1 });
            const closingCurly = sourceCode.getLastToken(node);
            addElementListIndent(node.body, openingCurly, closingCurly, options.StaticBlock.body);
          },
          SwitchStatement(node) {
            const openingCurly = sourceCode.getTokenAfter(node.discriminant, astUtils.isOpeningBraceToken);
            const closingCurly = sourceCode.getLastToken(node);
            offsets.setDesiredOffsets([openingCurly.range[1], closingCurly.range[0]], openingCurly, options.SwitchCase);
            if (node.cases.length) {
              sourceCode.getTokensBetween(
                node.cases[node.cases.length - 1],
                closingCurly,
                { includeComments: true, filter: astUtils.isCommentToken }
              ).forEach((token) => offsets.ignoreToken(token));
            }
          },
          SwitchCase(node) {
            if (!(node.consequent.length === 1 && node.consequent[0].type === "BlockStatement")) {
              const caseKeyword = sourceCode.getFirstToken(node);
              const tokenAfterCurrentCase = sourceCode.getTokenAfter(node);
              offsets.setDesiredOffsets([caseKeyword.range[1], tokenAfterCurrentCase.range[0]], caseKeyword, 1);
            }
          },
          TemplateLiteral(node) {
            node.expressions.forEach((expression, index) => {
              const previousQuasi = node.quasis[index];
              const nextQuasi = node.quasis[index + 1];
              const tokenToAlignFrom = previousQuasi.loc.start.line === previousQuasi.loc.end.line ? sourceCode.getFirstToken(previousQuasi) : null;
              offsets.setDesiredOffsets([previousQuasi.range[1], nextQuasi.range[0]], tokenToAlignFrom, 1);
              offsets.setDesiredOffset(sourceCode.getFirstToken(nextQuasi), tokenToAlignFrom, 0);
            });
          },
          VariableDeclaration(node) {
            let variableIndent = Object.prototype.hasOwnProperty.call(options.VariableDeclarator, node.kind) ? options.VariableDeclarator[node.kind] : DEFAULT_VARIABLE_INDENT;
            const firstToken = sourceCode.getFirstToken(node), lastToken = sourceCode.getLastToken(node);
            if (options.VariableDeclarator[node.kind] === "first") {
              if (node.declarations.length > 1) {
                addElementListIndent(
                  node.declarations,
                  firstToken,
                  lastToken,
                  "first"
                );
                return;
              }
              variableIndent = DEFAULT_VARIABLE_INDENT;
            }
            if (node.declarations[node.declarations.length - 1].loc.start.line > node.loc.start.line) {
              offsets.setDesiredOffsets(node.range, firstToken, variableIndent, true);
            } else {
              offsets.setDesiredOffsets(node.range, firstToken, variableIndent);
            }
            if (astUtils.isSemicolonToken(lastToken)) {
              offsets.ignoreToken(lastToken);
            }
          },
          VariableDeclarator(node) {
            if (node.init) {
              const equalOperator = sourceCode.getTokenBefore(node.init, astUtils.isNotOpeningParenToken);
              const tokenAfterOperator = sourceCode.getTokenAfter(equalOperator);
              offsets.ignoreToken(equalOperator);
              offsets.ignoreToken(tokenAfterOperator);
              offsets.setDesiredOffsets([tokenAfterOperator.range[0], node.range[1]], equalOperator, 1);
              offsets.setDesiredOffset(equalOperator, sourceCode.getLastToken(node.id), 0);
            }
          },
          "JSXAttribute[value]"(node) {
            const equalsToken = sourceCode.getFirstTokenBetween(node.name, node.value, (token) => token.type === "Punctuator" && token.value === "=");
            offsets.setDesiredOffsets([equalsToken.range[0], node.value.range[1]], sourceCode.getFirstToken(node.name), 1);
          },
          JSXElement(node) {
            if (node.closingElement) {
              addElementListIndent(node.children, sourceCode.getFirstToken(node.openingElement), sourceCode.getFirstToken(node.closingElement), 1);
            }
          },
          JSXOpeningElement(node) {
            const firstToken = sourceCode.getFirstToken(node);
            let closingToken;
            if (node.selfClosing) {
              closingToken = sourceCode.getLastToken(node, { skip: 1 });
              offsets.setDesiredOffset(sourceCode.getLastToken(node), closingToken, 0);
            } else {
              closingToken = sourceCode.getLastToken(node);
            }
            offsets.setDesiredOffsets(node.name.range, sourceCode.getFirstToken(node));
            addElementListIndent(node.attributes, firstToken, closingToken, 1);
          },
          JSXClosingElement(node) {
            const firstToken = sourceCode.getFirstToken(node);
            offsets.setDesiredOffsets(node.name.range, firstToken, 1);
          },
          JSXFragment(node) {
            const firstOpeningToken = sourceCode.getFirstToken(node.openingFragment);
            const firstClosingToken = sourceCode.getFirstToken(node.closingFragment);
            addElementListIndent(node.children, firstOpeningToken, firstClosingToken, 1);
          },
          JSXOpeningFragment(node) {
            const firstToken = sourceCode.getFirstToken(node);
            const closingToken = sourceCode.getLastToken(node);
            offsets.setDesiredOffsets(node.range, firstToken, 1);
            offsets.matchOffsetOf(firstToken, closingToken);
          },
          JSXClosingFragment(node) {
            const firstToken = sourceCode.getFirstToken(node);
            const slashToken = sourceCode.getLastToken(node, { skip: 1 });
            const closingToken = sourceCode.getLastToken(node);
            const tokenToMatch = astUtils.isTokenOnSameLine(slashToken, closingToken) ? slashToken : closingToken;
            offsets.setDesiredOffsets(node.range, firstToken, 1);
            offsets.matchOffsetOf(firstToken, tokenToMatch);
          },
          JSXExpressionContainer(node) {
            const openingCurly = sourceCode.getFirstToken(node);
            const closingCurly = sourceCode.getLastToken(node);
            offsets.setDesiredOffsets(
              [openingCurly.range[1], closingCurly.range[0]],
              openingCurly,
              1
            );
          },
          JSXSpreadAttribute(node) {
            const openingCurly = sourceCode.getFirstToken(node);
            const closingCurly = sourceCode.getLastToken(node);
            offsets.setDesiredOffsets(
              [openingCurly.range[1], closingCurly.range[0]],
              openingCurly,
              1
            );
          },
          "*"(node) {
            const firstToken = sourceCode.getFirstToken(node);
            if (firstToken && !ignoredNodeFirstTokens.has(firstToken)) {
              offsets.setDesiredOffsets(node.range, firstToken, 0);
            }
          }
        };
        const listenerCallQueue = [];
        const offsetListeners = {};
        for (const [selector, listener] of Object.entries(baseOffsetListeners)) {
          offsetListeners[selector] = (node) => listenerCallQueue.push({ listener, node });
        }
        const ignoredNodes = /* @__PURE__ */ new Set();
        function addToIgnoredNodes(node) {
          ignoredNodes.add(node);
          ignoredNodeFirstTokens.add(sourceCode.getFirstToken(node));
        }
        const ignoredNodeListeners = options.ignoredNodes.reduce(
          (listeners, ignoredSelector) => Object.assign(listeners, { [ignoredSelector]: addToIgnoredNodes }),
          {}
        );
        return Object.assign(
          offsetListeners,
          ignoredNodeListeners,
          {
            "*:exit"(node) {
              if (!KNOWN_NODES.has(node.type)) {
                addToIgnoredNodes(node);
              }
            },
            "Program:exit"() {
              if (options.ignoreComments) {
                sourceCode.getAllComments().forEach((comment) => offsets.ignoreToken(comment));
              }
              for (let i = 0; i < listenerCallQueue.length; i++) {
                const nodeInfo = listenerCallQueue[i];
                if (!ignoredNodes.has(nodeInfo.node)) {
                  nodeInfo.listener(nodeInfo.node);
                }
              }
              ignoredNodes.forEach(ignoreNode);
              addParensIndent(sourceCode.ast.tokens);
              const precedingTokens = /* @__PURE__ */ new WeakMap();
              for (let i = 0; i < sourceCode.ast.comments.length; i++) {
                const comment = sourceCode.ast.comments[i];
                const tokenOrCommentBefore = sourceCode.getTokenBefore(comment, { includeComments: true });
                const hasToken = precedingTokens.has(tokenOrCommentBefore) ? precedingTokens.get(tokenOrCommentBefore) : tokenOrCommentBefore;
                precedingTokens.set(comment, hasToken);
              }
              for (let i = 1; i < sourceCode.lines.length + 1; i++) {
                if (!tokenInfo.firstTokensByLineNumber.has(i)) {
                  continue;
                }
                const firstTokenOfLine = tokenInfo.firstTokensByLineNumber.get(i);
                if (firstTokenOfLine.loc.start.line !== i) {
                  continue;
                }
                if (astUtils.isCommentToken(firstTokenOfLine)) {
                  const tokenBefore = precedingTokens.get(firstTokenOfLine);
                  const tokenAfter = tokenBefore ? sourceCode.getTokenAfter(tokenBefore) : sourceCode.ast.tokens[0];
                  const mayAlignWithBefore = tokenBefore && !hasBlankLinesBetween(tokenBefore, firstTokenOfLine);
                  const mayAlignWithAfter = tokenAfter && !hasBlankLinesBetween(firstTokenOfLine, tokenAfter);
                  if (tokenAfter && astUtils.isSemicolonToken(tokenAfter) && !astUtils.isTokenOnSameLine(firstTokenOfLine, tokenAfter)) {
                    offsets.setDesiredOffset(firstTokenOfLine, tokenAfter, 0);
                  }
                  if (mayAlignWithBefore && validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(tokenBefore)) || mayAlignWithAfter && validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(tokenAfter))) {
                    continue;
                  }
                }
                if (validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(firstTokenOfLine))) {
                  continue;
                }
                report(firstTokenOfLine, offsets.getDesiredIndent(firstTokenOfLine));
              }
            }
          }
        );
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/indent-legacy.js
var require_indent_legacy = __commonJS({
  "../../node_modules/eslint/lib/rules/indent-legacy.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Enforce consistent indentation",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/indent-legacy"
        },
        deprecated: true,
        replacedBy: ["indent"],
        fixable: "whitespace",
        schema: [
          {
            oneOf: [
              {
                enum: ["tab"]
              },
              {
                type: "integer",
                minimum: 0
              }
            ]
          },
          {
            type: "object",
            properties: {
              SwitchCase: {
                type: "integer",
                minimum: 0
              },
              VariableDeclarator: {
                oneOf: [
                  {
                    type: "integer",
                    minimum: 0
                  },
                  {
                    type: "object",
                    properties: {
                      var: {
                        type: "integer",
                        minimum: 0
                      },
                      let: {
                        type: "integer",
                        minimum: 0
                      },
                      const: {
                        type: "integer",
                        minimum: 0
                      }
                    }
                  }
                ]
              },
              outerIIFEBody: {
                type: "integer",
                minimum: 0
              },
              MemberExpression: {
                type: "integer",
                minimum: 0
              },
              FunctionDeclaration: {
                type: "object",
                properties: {
                  parameters: {
                    oneOf: [
                      {
                        type: "integer",
                        minimum: 0
                      },
                      {
                        enum: ["first"]
                      }
                    ]
                  },
                  body: {
                    type: "integer",
                    minimum: 0
                  }
                }
              },
              FunctionExpression: {
                type: "object",
                properties: {
                  parameters: {
                    oneOf: [
                      {
                        type: "integer",
                        minimum: 0
                      },
                      {
                        enum: ["first"]
                      }
                    ]
                  },
                  body: {
                    type: "integer",
                    minimum: 0
                  }
                }
              },
              CallExpression: {
                type: "object",
                properties: {
                  parameters: {
                    oneOf: [
                      {
                        type: "integer",
                        minimum: 0
                      },
                      {
                        enum: ["first"]
                      }
                    ]
                  }
                }
              },
              ArrayExpression: {
                oneOf: [
                  {
                    type: "integer",
                    minimum: 0
                  },
                  {
                    enum: ["first"]
                  }
                ]
              },
              ObjectExpression: {
                oneOf: [
                  {
                    type: "integer",
                    minimum: 0
                  },
                  {
                    enum: ["first"]
                  }
                ]
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          expected: "Expected indentation of {{expected}} but found {{actual}}."
        }
      },
      create(context) {
        const DEFAULT_VARIABLE_INDENT = 1;
        const DEFAULT_PARAMETER_INDENT = null;
        const DEFAULT_FUNCTION_BODY_INDENT = 1;
        let indentType = "space";
        let indentSize = 4;
        const options = {
          SwitchCase: 0,
          VariableDeclarator: {
            var: DEFAULT_VARIABLE_INDENT,
            let: DEFAULT_VARIABLE_INDENT,
            const: DEFAULT_VARIABLE_INDENT
          },
          outerIIFEBody: null,
          FunctionDeclaration: {
            parameters: DEFAULT_PARAMETER_INDENT,
            body: DEFAULT_FUNCTION_BODY_INDENT
          },
          FunctionExpression: {
            parameters: DEFAULT_PARAMETER_INDENT,
            body: DEFAULT_FUNCTION_BODY_INDENT
          },
          CallExpression: {
            arguments: DEFAULT_PARAMETER_INDENT
          },
          ArrayExpression: 1,
          ObjectExpression: 1
        };
        const sourceCode = context.sourceCode;
        if (context.options.length) {
          if (context.options[0] === "tab") {
            indentSize = 1;
            indentType = "tab";
          } else if (typeof context.options[0] === "number") {
            indentSize = context.options[0];
            indentType = "space";
          }
          if (context.options[1]) {
            const opts = context.options[1];
            options.SwitchCase = opts.SwitchCase || 0;
            const variableDeclaratorRules = opts.VariableDeclarator;
            if (typeof variableDeclaratorRules === "number") {
              options.VariableDeclarator = {
                var: variableDeclaratorRules,
                let: variableDeclaratorRules,
                const: variableDeclaratorRules
              };
            } else if (typeof variableDeclaratorRules === "object") {
              Object.assign(options.VariableDeclarator, variableDeclaratorRules);
            }
            if (typeof opts.outerIIFEBody === "number") {
              options.outerIIFEBody = opts.outerIIFEBody;
            }
            if (typeof opts.MemberExpression === "number") {
              options.MemberExpression = opts.MemberExpression;
            }
            if (typeof opts.FunctionDeclaration === "object") {
              Object.assign(options.FunctionDeclaration, opts.FunctionDeclaration);
            }
            if (typeof opts.FunctionExpression === "object") {
              Object.assign(options.FunctionExpression, opts.FunctionExpression);
            }
            if (typeof opts.CallExpression === "object") {
              Object.assign(options.CallExpression, opts.CallExpression);
            }
            if (typeof opts.ArrayExpression === "number" || typeof opts.ArrayExpression === "string") {
              options.ArrayExpression = opts.ArrayExpression;
            }
            if (typeof opts.ObjectExpression === "number" || typeof opts.ObjectExpression === "string") {
              options.ObjectExpression = opts.ObjectExpression;
            }
          }
        }
        const caseIndentStore = {};
        function createErrorMessageData(expectedAmount, actualSpaces, actualTabs) {
          const expectedStatement = `${expectedAmount} ${indentType}${expectedAmount === 1 ? "" : "s"}`;
          const foundSpacesWord = `space${actualSpaces === 1 ? "" : "s"}`;
          const foundTabsWord = `tab${actualTabs === 1 ? "" : "s"}`;
          let foundStatement;
          if (actualSpaces > 0 && actualTabs > 0) {
            foundStatement = `${actualSpaces} ${foundSpacesWord} and ${actualTabs} ${foundTabsWord}`;
          } else if (actualSpaces > 0) {
            foundStatement = indentType === "space" ? actualSpaces : `${actualSpaces} ${foundSpacesWord}`;
          } else if (actualTabs > 0) {
            foundStatement = indentType === "tab" ? actualTabs : `${actualTabs} ${foundTabsWord}`;
          } else {
            foundStatement = "0";
          }
          return {
            expected: expectedStatement,
            actual: foundStatement
          };
        }
        function report(node, needed, gottenSpaces, gottenTabs, loc, isLastNodeCheck) {
          if (gottenSpaces && gottenTabs) {
            return;
          }
          const desiredIndent = (indentType === "space" ? " " : "	").repeat(needed);
          const textRange = isLastNodeCheck ? [node.range[1] - node.loc.end.column, node.range[1] - node.loc.end.column + gottenSpaces + gottenTabs] : [node.range[0] - node.loc.start.column, node.range[0] - node.loc.start.column + gottenSpaces + gottenTabs];
          context.report({
            node,
            loc,
            messageId: "expected",
            data: createErrorMessageData(needed, gottenSpaces, gottenTabs),
            fix: (fixer) => fixer.replaceTextRange(textRange, desiredIndent)
          });
        }
        function getNodeIndent(node, byLastLine) {
          const token = byLastLine ? sourceCode.getLastToken(node) : sourceCode.getFirstToken(node);
          const srcCharsBeforeNode = sourceCode.getText(token, token.loc.start.column).split("");
          const indentChars = srcCharsBeforeNode.slice(0, srcCharsBeforeNode.findIndex((char) => char !== " " && char !== "	"));
          const spaces = indentChars.filter((char) => char === " ").length;
          const tabs = indentChars.filter((char) => char === "	").length;
          return {
            space: spaces,
            tab: tabs,
            goodChar: indentType === "space" ? spaces : tabs,
            badChar: indentType === "space" ? tabs : spaces
          };
        }
        function isNodeFirstInLine(node, byEndLocation) {
          const firstToken = byEndLocation === true ? sourceCode.getLastToken(node, 1) : sourceCode.getTokenBefore(node), startLine = byEndLocation === true ? node.loc.end.line : node.loc.start.line, endLine = firstToken ? firstToken.loc.end.line : -1;
          return startLine !== endLine;
        }
        function checkNodeIndent(node, neededIndent) {
          const actualIndent = getNodeIndent(node, false);
          if (node.type !== "ArrayExpression" && node.type !== "ObjectExpression" && (actualIndent.goodChar !== neededIndent || actualIndent.badChar !== 0) && isNodeFirstInLine(node)) {
            report(node, neededIndent, actualIndent.space, actualIndent.tab);
          }
          if (node.type === "IfStatement" && node.alternate) {
            const elseToken = sourceCode.getTokenBefore(node.alternate);
            checkNodeIndent(elseToken, neededIndent);
            if (!isNodeFirstInLine(node.alternate)) {
              checkNodeIndent(node.alternate, neededIndent);
            }
          }
          if (node.type === "TryStatement" && node.handler) {
            const catchToken = sourceCode.getFirstToken(node.handler);
            checkNodeIndent(catchToken, neededIndent);
          }
          if (node.type === "TryStatement" && node.finalizer) {
            const finallyToken = sourceCode.getTokenBefore(node.finalizer);
            checkNodeIndent(finallyToken, neededIndent);
          }
          if (node.type === "DoWhileStatement") {
            const whileToken = sourceCode.getTokenAfter(node.body);
            checkNodeIndent(whileToken, neededIndent);
          }
        }
        function checkNodesIndent(nodes, indent) {
          nodes.forEach((node) => checkNodeIndent(node, indent));
        }
        function checkLastNodeLineIndent(node, lastLineIndent) {
          const lastToken = sourceCode.getLastToken(node);
          const endIndent = getNodeIndent(lastToken, true);
          if ((endIndent.goodChar !== lastLineIndent || endIndent.badChar !== 0) && isNodeFirstInLine(node, true)) {
            report(
              node,
              lastLineIndent,
              endIndent.space,
              endIndent.tab,
              { line: lastToken.loc.start.line, column: lastToken.loc.start.column },
              true
            );
          }
        }
        function checkLastReturnStatementLineIndent(node, firstLineIndent) {
          const lastToken = sourceCode.getLastToken(node, astUtils.isClosingParenToken);
          const textBeforeClosingParenthesis = sourceCode.getText(lastToken, lastToken.loc.start.column).slice(0, -1);
          if (textBeforeClosingParenthesis.trim()) {
            return;
          }
          const endIndent = getNodeIndent(lastToken, true);
          if (endIndent.goodChar !== firstLineIndent) {
            report(
              node,
              firstLineIndent,
              endIndent.space,
              endIndent.tab,
              { line: lastToken.loc.start.line, column: lastToken.loc.start.column },
              true
            );
          }
        }
        function checkFirstNodeLineIndent(node, firstLineIndent) {
          const startIndent = getNodeIndent(node, false);
          if ((startIndent.goodChar !== firstLineIndent || startIndent.badChar !== 0) && isNodeFirstInLine(node)) {
            report(
              node,
              firstLineIndent,
              startIndent.space,
              startIndent.tab,
              { line: node.loc.start.line, column: node.loc.start.column }
            );
          }
        }
        function getParentNodeByType(node, type, stopAtList) {
          let parent = node.parent;
          const stopAtSet = new Set(stopAtList || ["Program"]);
          while (parent.type !== type && !stopAtSet.has(parent.type) && parent.type !== "Program") {
            parent = parent.parent;
          }
          return parent.type === type ? parent : null;
        }
        function getVariableDeclaratorNode(node) {
          return getParentNodeByType(node, "VariableDeclarator");
        }
        function isNodeInVarOnTop(node, varNode) {
          return varNode && varNode.parent.loc.start.line === node.loc.start.line && varNode.parent.declarations.length > 1;
        }
        function isArgBeforeCalleeNodeMultiline(node) {
          const parent = node.parent;
          if (parent.arguments.length >= 2 && parent.arguments[1] === node) {
            return parent.arguments[0].loc.end.line > parent.arguments[0].loc.start.line;
          }
          return false;
        }
        function isOuterIIFE(node) {
          const parent = node.parent;
          let stmt = parent.parent;
          if (parent.type !== "CallExpression" || parent.callee !== node) {
            return false;
          }
          while (stmt.type === "UnaryExpression" && (stmt.operator === "!" || stmt.operator === "~" || stmt.operator === "+" || stmt.operator === "-") || stmt.type === "AssignmentExpression" || stmt.type === "LogicalExpression" || stmt.type === "SequenceExpression" || stmt.type === "VariableDeclarator") {
            stmt = stmt.parent;
          }
          return (stmt.type === "ExpressionStatement" || stmt.type === "VariableDeclaration") && stmt.parent && stmt.parent.type === "Program";
        }
        function checkIndentInFunctionBlock(node) {
          const calleeNode = node.parent;
          let indent;
          if (calleeNode.parent && (calleeNode.parent.type === "Property" || calleeNode.parent.type === "ArrayExpression")) {
            indent = getNodeIndent(calleeNode, false).goodChar;
          } else {
            indent = getNodeIndent(calleeNode).goodChar;
          }
          if (calleeNode.parent.type === "CallExpression") {
            const calleeParent = calleeNode.parent;
            if (calleeNode.type !== "FunctionExpression" && calleeNode.type !== "ArrowFunctionExpression") {
              if (calleeParent && calleeParent.loc.start.line < node.loc.start.line) {
                indent = getNodeIndent(calleeParent).goodChar;
              }
            } else {
              if (isArgBeforeCalleeNodeMultiline(calleeNode) && calleeParent.callee.loc.start.line === calleeParent.callee.loc.end.line && !isNodeFirstInLine(calleeNode)) {
                indent = getNodeIndent(calleeParent).goodChar;
              }
            }
          }
          let functionOffset = indentSize;
          if (options.outerIIFEBody !== null && isOuterIIFE(calleeNode)) {
            functionOffset = options.outerIIFEBody * indentSize;
          } else if (calleeNode.type === "FunctionExpression") {
            functionOffset = options.FunctionExpression.body * indentSize;
          } else if (calleeNode.type === "FunctionDeclaration") {
            functionOffset = options.FunctionDeclaration.body * indentSize;
          }
          indent += functionOffset;
          const parentVarNode = getVariableDeclaratorNode(node);
          if (parentVarNode && isNodeInVarOnTop(node, parentVarNode)) {
            indent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];
          }
          if (node.body.length > 0) {
            checkNodesIndent(node.body, indent);
          }
          checkLastNodeLineIndent(node, indent - functionOffset);
        }
        function isSingleLineNode(node) {
          const lastToken = sourceCode.getLastToken(node), startLine = node.loc.start.line, endLine = lastToken.loc.end.line;
          return startLine === endLine;
        }
        function checkIndentInArrayOrObjectBlock(node) {
          if (isSingleLineNode(node)) {
            return;
          }
          let elements = node.type === "ArrayExpression" ? node.elements : node.properties;
          elements = elements.filter((elem) => elem !== null);
          let nodeIndent;
          let elementsIndent;
          const parentVarNode = getVariableDeclaratorNode(node);
          if (isNodeFirstInLine(node)) {
            const parent = node.parent;
            nodeIndent = getNodeIndent(parent).goodChar;
            if (!parentVarNode || parentVarNode.loc.start.line !== node.loc.start.line) {
              if (parent.type !== "VariableDeclarator" || parentVarNode === parentVarNode.parent.declarations[0]) {
                if (parent.type === "VariableDeclarator" && parentVarNode.loc.start.line === parent.loc.start.line) {
                  nodeIndent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];
                } else if (parent.type === "ObjectExpression" || parent.type === "ArrayExpression") {
                  const parentElements = node.parent.type === "ObjectExpression" ? node.parent.properties : node.parent.elements;
                  if (parentElements[0] && parentElements[0].loc.start.line === parent.loc.start.line && parentElements[0].loc.end.line !== parent.loc.start.line) {
                  } else if (typeof options[parent.type] === "number") {
                    nodeIndent += options[parent.type] * indentSize;
                  } else {
                    nodeIndent = parentElements[0].loc.start.column;
                  }
                } else if (parent.type === "CallExpression" || parent.type === "NewExpression") {
                  if (typeof options.CallExpression.arguments === "number") {
                    nodeIndent += options.CallExpression.arguments * indentSize;
                  } else if (options.CallExpression.arguments === "first") {
                    if (parent.arguments.includes(node)) {
                      nodeIndent = parent.arguments[0].loc.start.column;
                    }
                  } else {
                    nodeIndent += indentSize;
                  }
                } else if (parent.type === "LogicalExpression" || parent.type === "ArrowFunctionExpression") {
                  nodeIndent += indentSize;
                }
              }
            }
            checkFirstNodeLineIndent(node, nodeIndent);
          } else {
            nodeIndent = getNodeIndent(node).goodChar;
          }
          if (options[node.type] === "first") {
            elementsIndent = elements.length ? elements[0].loc.start.column : 0;
          } else {
            elementsIndent = nodeIndent + indentSize * options[node.type];
          }
          if (isNodeInVarOnTop(node, parentVarNode)) {
            elementsIndent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];
          }
          checkNodesIndent(elements, elementsIndent);
          if (elements.length > 0) {
            if (elements[elements.length - 1].loc.end.line === node.loc.end.line) {
              return;
            }
          }
          checkLastNodeLineIndent(node, nodeIndent + (isNodeInVarOnTop(node, parentVarNode) ? options.VariableDeclarator[parentVarNode.parent.kind] * indentSize : 0));
        }
        function isNodeBodyBlock(node) {
          return node.type === "BlockStatement" || node.type === "ClassBody" || node.body && node.body.type === "BlockStatement" || node.consequent && node.consequent.type === "BlockStatement";
        }
        function blockIndentationCheck(node) {
          if (isSingleLineNode(node)) {
            return;
          }
          if (node.parent && (node.parent.type === "FunctionExpression" || node.parent.type === "FunctionDeclaration" || node.parent.type === "ArrowFunctionExpression")) {
            checkIndentInFunctionBlock(node);
            return;
          }
          let indent;
          let nodesToCheck = [];
          const statementsWithProperties = [
            "IfStatement",
            "WhileStatement",
            "ForStatement",
            "ForInStatement",
            "ForOfStatement",
            "DoWhileStatement",
            "ClassDeclaration",
            "TryStatement"
          ];
          if (node.parent && statementsWithProperties.includes(node.parent.type) && isNodeBodyBlock(node)) {
            indent = getNodeIndent(node.parent).goodChar;
          } else if (node.parent && node.parent.type === "CatchClause") {
            indent = getNodeIndent(node.parent.parent).goodChar;
          } else {
            indent = getNodeIndent(node).goodChar;
          }
          if (node.type === "IfStatement" && node.consequent.type !== "BlockStatement") {
            nodesToCheck = [node.consequent];
          } else if (Array.isArray(node.body)) {
            nodesToCheck = node.body;
          } else {
            nodesToCheck = [node.body];
          }
          if (nodesToCheck.length > 0) {
            checkNodesIndent(nodesToCheck, indent + indentSize);
          }
          if (node.type === "BlockStatement") {
            checkLastNodeLineIndent(node, indent);
          }
        }
        function filterOutSameLineVars(node) {
          return node.declarations.reduce((finalCollection, elem) => {
            const lastElem = finalCollection[finalCollection.length - 1];
            if (elem.loc.start.line !== node.loc.start.line && !lastElem || lastElem && lastElem.loc.start.line !== elem.loc.start.line) {
              finalCollection.push(elem);
            }
            return finalCollection;
          }, []);
        }
        function checkIndentInVariableDeclarations(node) {
          const elements = filterOutSameLineVars(node);
          const nodeIndent = getNodeIndent(node).goodChar;
          const lastElement = elements[elements.length - 1];
          const elementsIndent = nodeIndent + indentSize * options.VariableDeclarator[node.kind];
          checkNodesIndent(elements, elementsIndent);
          if (sourceCode.getLastToken(node).loc.end.line <= lastElement.loc.end.line) {
            return;
          }
          const tokenBeforeLastElement = sourceCode.getTokenBefore(lastElement);
          if (tokenBeforeLastElement.value === ",") {
            checkLastNodeLineIndent(node, getNodeIndent(tokenBeforeLastElement).goodChar);
          } else {
            checkLastNodeLineIndent(node, elementsIndent - indentSize);
          }
        }
        function blockLessNodes(node) {
          if (node.body.type !== "BlockStatement") {
            blockIndentationCheck(node);
          }
        }
        function expectedCaseIndent(node, providedSwitchIndent) {
          const switchNode = node.type === "SwitchStatement" ? node : node.parent;
          const switchIndent = typeof providedSwitchIndent === "undefined" ? getNodeIndent(switchNode).goodChar : providedSwitchIndent;
          let caseIndent;
          if (caseIndentStore[switchNode.loc.start.line]) {
            return caseIndentStore[switchNode.loc.start.line];
          }
          if (switchNode.cases.length > 0 && options.SwitchCase === 0) {
            caseIndent = switchIndent;
          } else {
            caseIndent = switchIndent + indentSize * options.SwitchCase;
          }
          caseIndentStore[switchNode.loc.start.line] = caseIndent;
          return caseIndent;
        }
        function isWrappedInParenthesis(node) {
          const regex = /^return\s*?\(\s*?\);*?/u;
          const statementWithoutArgument = sourceCode.getText(node).replace(
            sourceCode.getText(node.argument),
            ""
          );
          return regex.test(statementWithoutArgument);
        }
        return {
          Program(node) {
            if (node.body.length > 0) {
              checkNodesIndent(node.body, getNodeIndent(node).goodChar);
            }
          },
          ClassBody: blockIndentationCheck,
          BlockStatement: blockIndentationCheck,
          WhileStatement: blockLessNodes,
          ForStatement: blockLessNodes,
          ForInStatement: blockLessNodes,
          ForOfStatement: blockLessNodes,
          DoWhileStatement: blockLessNodes,
          IfStatement(node) {
            if (node.consequent.type !== "BlockStatement" && node.consequent.loc.start.line > node.loc.start.line) {
              blockIndentationCheck(node);
            }
          },
          VariableDeclaration(node) {
            if (node.declarations[node.declarations.length - 1].loc.start.line > node.declarations[0].loc.start.line) {
              checkIndentInVariableDeclarations(node);
            }
          },
          ObjectExpression(node) {
            checkIndentInArrayOrObjectBlock(node);
          },
          ArrayExpression(node) {
            checkIndentInArrayOrObjectBlock(node);
          },
          MemberExpression(node) {
            if (typeof options.MemberExpression === "undefined") {
              return;
            }
            if (isSingleLineNode(node)) {
              return;
            }
            if (getParentNodeByType(node, "VariableDeclarator", ["FunctionExpression", "ArrowFunctionExpression"])) {
              return;
            }
            if (getParentNodeByType(node, "AssignmentExpression", ["FunctionExpression"])) {
              return;
            }
            const propertyIndent = getNodeIndent(node).goodChar + indentSize * options.MemberExpression;
            const checkNodes = [node.property];
            const dot = sourceCode.getTokenBefore(node.property);
            if (dot.type === "Punctuator" && dot.value === ".") {
              checkNodes.push(dot);
            }
            checkNodesIndent(checkNodes, propertyIndent);
          },
          SwitchStatement(node) {
            const switchIndent = getNodeIndent(node).goodChar;
            const caseIndent = expectedCaseIndent(node, switchIndent);
            checkNodesIndent(node.cases, caseIndent);
            checkLastNodeLineIndent(node, switchIndent);
          },
          SwitchCase(node) {
            if (isSingleLineNode(node)) {
              return;
            }
            const caseIndent = expectedCaseIndent(node);
            checkNodesIndent(node.consequent, caseIndent + indentSize);
          },
          FunctionDeclaration(node) {
            if (isSingleLineNode(node)) {
              return;
            }
            if (options.FunctionDeclaration.parameters === "first" && node.params.length) {
              checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);
            } else if (options.FunctionDeclaration.parameters !== null) {
              checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionDeclaration.parameters);
            }
          },
          FunctionExpression(node) {
            if (isSingleLineNode(node)) {
              return;
            }
            if (options.FunctionExpression.parameters === "first" && node.params.length) {
              checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);
            } else if (options.FunctionExpression.parameters !== null) {
              checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionExpression.parameters);
            }
          },
          ReturnStatement(node) {
            if (isSingleLineNode(node)) {
              return;
            }
            const firstLineIndent = getNodeIndent(node).goodChar;
            if (isWrappedInParenthesis(node)) {
              checkLastReturnStatementLineIndent(node, firstLineIndent);
            } else {
              checkNodeIndent(node, firstLineIndent);
            }
          },
          CallExpression(node) {
            if (isSingleLineNode(node)) {
              return;
            }
            if (options.CallExpression.arguments === "first" && node.arguments.length) {
              checkNodesIndent(node.arguments.slice(1), node.arguments[0].loc.start.column);
            } else if (options.CallExpression.arguments !== null) {
              checkNodesIndent(node.arguments, getNodeIndent(node).goodChar + indentSize * options.CallExpression.arguments);
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/init-declarations.js
var require_init_declarations = __commonJS({
  "../../node_modules/eslint/lib/rules/init-declarations.js"(exports, module) {
    "use strict";
    function isForLoop(block) {
      return block.type === "ForInStatement" || block.type === "ForOfStatement" || block.type === "ForStatement";
    }
    function isInitialized(node) {
      const declaration = node.parent;
      const block = declaration.parent;
      if (isForLoop(block)) {
        if (block.type === "ForStatement") {
          return block.init === declaration;
        }
        return block.left === declaration;
      }
      return Boolean(node.init);
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Require or disallow initialization in variable declarations",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/init-declarations"
        },
        schema: {
          anyOf: [
            {
              type: "array",
              items: [
                {
                  enum: ["always"]
                }
              ],
              minItems: 0,
              maxItems: 1
            },
            {
              type: "array",
              items: [
                {
                  enum: ["never"]
                },
                {
                  type: "object",
                  properties: {
                    ignoreForLoopInit: {
                      type: "boolean"
                    }
                  },
                  additionalProperties: false
                }
              ],
              minItems: 0,
              maxItems: 2
            }
          ]
        },
        messages: {
          initialized: "Variable '{{idName}}' should be initialized on declaration.",
          notInitialized: "Variable '{{idName}}' should not be initialized on declaration."
        }
      },
      create(context) {
        const MODE_ALWAYS = "always", MODE_NEVER = "never";
        const mode = context.options[0] || MODE_ALWAYS;
        const params = context.options[1] || {};
        return {
          "VariableDeclaration:exit"(node) {
            const kind = node.kind, declarations = node.declarations;
            for (let i = 0; i < declarations.length; ++i) {
              const declaration = declarations[i], id = declaration.id, initialized = isInitialized(declaration), isIgnoredForLoop = params.ignoreForLoopInit && isForLoop(node.parent);
              let messageId = "";
              if (mode === MODE_ALWAYS && !initialized) {
                messageId = "initialized";
              } else if (mode === MODE_NEVER && kind !== "const" && initialized && !isIgnoredForLoop) {
                messageId = "notInitialized";
              }
              if (id.type === "Identifier" && messageId) {
                context.report({
                  node: declaration,
                  messageId,
                  data: {
                    idName: id.name
                  }
                });
              }
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/jsx-quotes.js
var require_jsx_quotes = __commonJS({
  "../../node_modules/eslint/lib/rules/jsx-quotes.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var QUOTE_SETTINGS = {
      "prefer-double": {
        quote: '"',
        description: "singlequote",
        convert(str) {
          return str.replace(/'/gu, '"');
        }
      },
      "prefer-single": {
        quote: "'",
        description: "doublequote",
        convert(str) {
          return str.replace(/"/gu, "'");
        }
      }
    };
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Enforce the consistent use of either double or single quotes in JSX attributes",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/jsx-quotes"
        },
        fixable: "whitespace",
        schema: [
          {
            enum: ["prefer-single", "prefer-double"]
          }
        ],
        messages: {
          unexpected: "Unexpected usage of {{description}}."
        }
      },
      create(context) {
        const quoteOption = context.options[0] || "prefer-double", setting = QUOTE_SETTINGS[quoteOption];
        function usesExpectedQuotes(node) {
          return node.value.includes(setting.quote) || astUtils.isSurroundedBy(node.raw, setting.quote);
        }
        return {
          JSXAttribute(node) {
            const attributeValue = node.value;
            if (attributeValue && astUtils.isStringLiteral(attributeValue) && !usesExpectedQuotes(attributeValue)) {
              context.report({
                node: attributeValue,
                messageId: "unexpected",
                data: {
                  description: setting.description
                },
                fix(fixer) {
                  return fixer.replaceText(attributeValue, setting.convert(attributeValue.raw));
                }
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/key-spacing.js
var require_key_spacing = __commonJS({
  "../../node_modules/eslint/lib/rules/key-spacing.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var { getGraphemeCount } = require_string_utils();
    function containsLineTerminator(str) {
      return astUtils.LINEBREAK_MATCHER.test(str);
    }
    function last(arr) {
      return arr[arr.length - 1];
    }
    function isSingleLine(node) {
      return node.loc.end.line === node.loc.start.line;
    }
    function isSingleLineProperties(properties) {
      const [firstProp] = properties, lastProp = last(properties);
      return firstProp.loc.start.line === lastProp.loc.end.line;
    }
    function initOptionProperty(toOptions, fromOptions) {
      toOptions.mode = fromOptions.mode || "strict";
      if (typeof fromOptions.beforeColon !== "undefined") {
        toOptions.beforeColon = +fromOptions.beforeColon;
      } else {
        toOptions.beforeColon = 0;
      }
      if (typeof fromOptions.afterColon !== "undefined") {
        toOptions.afterColon = +fromOptions.afterColon;
      } else {
        toOptions.afterColon = 1;
      }
      if (typeof fromOptions.align !== "undefined") {
        if (typeof fromOptions.align === "object") {
          toOptions.align = fromOptions.align;
        } else {
          toOptions.align = {
            on: fromOptions.align,
            mode: toOptions.mode,
            beforeColon: toOptions.beforeColon,
            afterColon: toOptions.afterColon
          };
        }
      }
      return toOptions;
    }
    function initOptions(toOptions, fromOptions) {
      if (typeof fromOptions.align === "object") {
        toOptions.align = initOptionProperty({}, fromOptions.align);
        toOptions.align.on = fromOptions.align.on || "colon";
        toOptions.align.mode = fromOptions.align.mode || "strict";
        toOptions.multiLine = initOptionProperty({}, fromOptions.multiLine || fromOptions);
        toOptions.singleLine = initOptionProperty({}, fromOptions.singleLine || fromOptions);
      } else {
        toOptions.multiLine = initOptionProperty({}, fromOptions.multiLine || fromOptions);
        toOptions.singleLine = initOptionProperty({}, fromOptions.singleLine || fromOptions);
        if (toOptions.multiLine.align) {
          toOptions.align = {
            on: toOptions.multiLine.align.on,
            mode: toOptions.multiLine.align.mode || toOptions.multiLine.mode,
            beforeColon: toOptions.multiLine.align.beforeColon,
            afterColon: toOptions.multiLine.align.afterColon
          };
        }
      }
      return toOptions;
    }
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Enforce consistent spacing between keys and values in object literal properties",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/key-spacing"
        },
        fixable: "whitespace",
        schema: [{
          anyOf: [
            {
              type: "object",
              properties: {
                align: {
                  anyOf: [
                    {
                      enum: ["colon", "value"]
                    },
                    {
                      type: "object",
                      properties: {
                        mode: {
                          enum: ["strict", "minimum"]
                        },
                        on: {
                          enum: ["colon", "value"]
                        },
                        beforeColon: {
                          type: "boolean"
                        },
                        afterColon: {
                          type: "boolean"
                        }
                      },
                      additionalProperties: false
                    }
                  ]
                },
                mode: {
                  enum: ["strict", "minimum"]
                },
                beforeColon: {
                  type: "boolean"
                },
                afterColon: {
                  type: "boolean"
                }
              },
              additionalProperties: false
            },
            {
              type: "object",
              properties: {
                singleLine: {
                  type: "object",
                  properties: {
                    mode: {
                      enum: ["strict", "minimum"]
                    },
                    beforeColon: {
                      type: "boolean"
                    },
                    afterColon: {
                      type: "boolean"
                    }
                  },
                  additionalProperties: false
                },
                multiLine: {
                  type: "object",
                  properties: {
                    align: {
                      anyOf: [
                        {
                          enum: ["colon", "value"]
                        },
                        {
                          type: "object",
                          properties: {
                            mode: {
                              enum: ["strict", "minimum"]
                            },
                            on: {
                              enum: ["colon", "value"]
                            },
                            beforeColon: {
                              type: "boolean"
                            },
                            afterColon: {
                              type: "boolean"
                            }
                          },
                          additionalProperties: false
                        }
                      ]
                    },
                    mode: {
                      enum: ["strict", "minimum"]
                    },
                    beforeColon: {
                      type: "boolean"
                    },
                    afterColon: {
                      type: "boolean"
                    }
                  },
                  additionalProperties: false
                }
              },
              additionalProperties: false
            },
            {
              type: "object",
              properties: {
                singleLine: {
                  type: "object",
                  properties: {
                    mode: {
                      enum: ["strict", "minimum"]
                    },
                    beforeColon: {
                      type: "boolean"
                    },
                    afterColon: {
                      type: "boolean"
                    }
                  },
                  additionalProperties: false
                },
                multiLine: {
                  type: "object",
                  properties: {
                    mode: {
                      enum: ["strict", "minimum"]
                    },
                    beforeColon: {
                      type: "boolean"
                    },
                    afterColon: {
                      type: "boolean"
                    }
                  },
                  additionalProperties: false
                },
                align: {
                  type: "object",
                  properties: {
                    mode: {
                      enum: ["strict", "minimum"]
                    },
                    on: {
                      enum: ["colon", "value"]
                    },
                    beforeColon: {
                      type: "boolean"
                    },
                    afterColon: {
                      type: "boolean"
                    }
                  },
                  additionalProperties: false
                }
              },
              additionalProperties: false
            }
          ]
        }],
        messages: {
          extraKey: "Extra space after {{computed}}key '{{key}}'.",
          extraValue: "Extra space before value for {{computed}}key '{{key}}'.",
          missingKey: "Missing space after {{computed}}key '{{key}}'.",
          missingValue: "Missing space before value for {{computed}}key '{{key}}'."
        }
      },
      create(context) {
        const options = context.options[0] || {}, ruleOptions = initOptions({}, options), multiLineOptions = ruleOptions.multiLine, singleLineOptions = ruleOptions.singleLine, alignmentOptions = ruleOptions.align || null;
        const sourceCode = context.sourceCode;
        function isKeyValueProperty(property) {
          return !(property.method || property.shorthand || property.kind !== "init" || property.type !== "Property");
        }
        function getNextColon(node) {
          return sourceCode.getTokenAfter(node, astUtils.isColonToken);
        }
        function getLastTokenBeforeColon(node) {
          const colonToken = getNextColon(node);
          return sourceCode.getTokenBefore(colonToken);
        }
        function getFirstTokenAfterColon(node) {
          const colonToken = getNextColon(node);
          return sourceCode.getTokenAfter(colonToken);
        }
        function continuesPropertyGroup(lastMember, candidate) {
          const groupEndLine = lastMember.loc.start.line, candidateValueStartLine = (isKeyValueProperty(candidate) ? getFirstTokenAfterColon(candidate.key) : candidate).loc.start.line;
          if (candidateValueStartLine - groupEndLine <= 1) {
            return true;
          }
          const leadingComments = sourceCode.getCommentsBefore(candidate);
          if (leadingComments.length && leadingComments[0].loc.start.line - groupEndLine <= 1 && candidateValueStartLine - last(leadingComments).loc.end.line <= 1) {
            for (let i = 1; i < leadingComments.length; i++) {
              if (leadingComments[i].loc.start.line - leadingComments[i - 1].loc.end.line > 1) {
                return false;
              }
            }
            return true;
          }
          return false;
        }
        function getKey(property) {
          const key = property.key;
          if (property.computed) {
            return sourceCode.getText().slice(key.range[0], key.range[1]);
          }
          return astUtils.getStaticPropertyName(property);
        }
        function report(property, side, whitespace, expected, mode) {
          const diff = whitespace.length - expected;
          if ((diff && mode === "strict" || diff < 0 && mode === "minimum" || diff > 0 && !expected && mode === "minimum") && !(expected && containsLineTerminator(whitespace))) {
            const nextColon = getNextColon(property.key), tokenBeforeColon = sourceCode.getTokenBefore(nextColon, { includeComments: true }), tokenAfterColon = sourceCode.getTokenAfter(nextColon, { includeComments: true }), isKeySide = side === "key", isExtra = diff > 0, diffAbs = Math.abs(diff), spaces = Array(diffAbs + 1).join(" ");
            const locStart = isKeySide ? tokenBeforeColon.loc.end : nextColon.loc.start;
            const locEnd = isKeySide ? nextColon.loc.start : tokenAfterColon.loc.start;
            const missingLoc = isKeySide ? tokenBeforeColon.loc : tokenAfterColon.loc;
            const loc = isExtra ? { start: locStart, end: locEnd } : missingLoc;
            let fix;
            if (isExtra) {
              let range;
              if (isKeySide) {
                range = [tokenBeforeColon.range[1], tokenBeforeColon.range[1] + diffAbs];
              } else {
                range = [tokenAfterColon.range[0] - diffAbs, tokenAfterColon.range[0]];
              }
              fix = function(fixer) {
                return fixer.removeRange(range);
              };
            } else {
              if (isKeySide) {
                fix = function(fixer) {
                  return fixer.insertTextAfter(tokenBeforeColon, spaces);
                };
              } else {
                fix = function(fixer) {
                  return fixer.insertTextBefore(tokenAfterColon, spaces);
                };
              }
            }
            let messageId = "";
            if (isExtra) {
              messageId = side === "key" ? "extraKey" : "extraValue";
            } else {
              messageId = side === "key" ? "missingKey" : "missingValue";
            }
            context.report({
              node: property[side],
              loc,
              messageId,
              data: {
                computed: property.computed ? "computed " : "",
                key: getKey(property)
              },
              fix
            });
          }
        }
        function getKeyWidth(property) {
          const startToken = sourceCode.getFirstToken(property);
          const endToken = getLastTokenBeforeColon(property.key);
          return getGraphemeCount(sourceCode.getText().slice(startToken.range[0], endToken.range[1]));
        }
        function getPropertyWhitespace(property) {
          const whitespace = /(\s*):(\s*)/u.exec(sourceCode.getText().slice(
            property.key.range[1],
            property.value.range[0]
          ));
          if (whitespace) {
            return {
              beforeColon: whitespace[1],
              afterColon: whitespace[2]
            };
          }
          return null;
        }
        function createGroups(node) {
          if (node.properties.length === 1) {
            return [node.properties];
          }
          return node.properties.reduce((groups, property) => {
            const currentGroup = last(groups), prev = last(currentGroup);
            if (!prev || continuesPropertyGroup(prev, property)) {
              currentGroup.push(property);
            } else {
              groups.push([property]);
            }
            return groups;
          }, [
            []
          ]);
        }
        function verifyGroupAlignment(properties) {
          const length = properties.length, widths = properties.map(getKeyWidth), align = alignmentOptions.on;
          let targetWidth = Math.max(...widths), beforeColon, afterColon, mode;
          if (alignmentOptions && length > 1) {
            beforeColon = alignmentOptions.beforeColon;
            afterColon = alignmentOptions.afterColon;
            mode = alignmentOptions.mode;
          } else {
            beforeColon = multiLineOptions.beforeColon;
            afterColon = multiLineOptions.afterColon;
            mode = alignmentOptions.mode;
          }
          targetWidth += align === "colon" ? beforeColon : afterColon;
          for (let i = 0; i < length; i++) {
            const property = properties[i];
            const whitespace = getPropertyWhitespace(property);
            if (whitespace) {
              const width = widths[i];
              if (align === "value") {
                report(property, "key", whitespace.beforeColon, beforeColon, mode);
                report(property, "value", whitespace.afterColon, targetWidth - width, mode);
              } else {
                report(property, "key", whitespace.beforeColon, targetWidth - width, mode);
                report(property, "value", whitespace.afterColon, afterColon, mode);
              }
            }
          }
        }
        function verifySpacing(node, lineOptions) {
          const actual = getPropertyWhitespace(node);
          if (actual) {
            report(node, "key", actual.beforeColon, lineOptions.beforeColon, lineOptions.mode);
            report(node, "value", actual.afterColon, lineOptions.afterColon, lineOptions.mode);
          }
        }
        function verifyListSpacing(properties, lineOptions) {
          const length = properties.length;
          for (let i = 0; i < length; i++) {
            verifySpacing(properties[i], lineOptions);
          }
        }
        function verifyAlignment(node) {
          createGroups(node).forEach((group) => {
            const properties = group.filter(isKeyValueProperty);
            if (properties.length > 0 && isSingleLineProperties(properties)) {
              verifyListSpacing(properties, multiLineOptions);
            } else {
              verifyGroupAlignment(properties);
            }
          });
        }
        if (alignmentOptions) {
          return {
            ObjectExpression(node) {
              if (isSingleLine(node)) {
                verifyListSpacing(node.properties.filter(isKeyValueProperty), singleLineOptions);
              } else {
                verifyAlignment(node);
              }
            }
          };
        }
        return {
          Property(node) {
            verifySpacing(node, isSingleLine(node.parent) ? singleLineOptions : multiLineOptions);
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/keyword-spacing.js
var require_keyword_spacing = __commonJS({
  "../../node_modules/eslint/lib/rules/keyword-spacing.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var keywords = require_keywords();
    var PREV_TOKEN = /^[)\]}>]$/u;
    var NEXT_TOKEN = /^(?:[([{<~!]|\+\+?|--?)$/u;
    var PREV_TOKEN_M = /^[)\]}>*]$/u;
    var NEXT_TOKEN_M = /^[{*]$/u;
    var TEMPLATE_OPEN_PAREN = /\$\{$/u;
    var TEMPLATE_CLOSE_PAREN = /^\}/u;
    var CHECK_TYPE = /^(?:JSXElement|RegularExpression|String|Template|PrivateIdentifier)$/u;
    var KEYS = keywords.concat(["as", "async", "await", "from", "get", "let", "of", "set", "yield"]);
    (function() {
      KEYS.sort();
      for (let i = 1; i < KEYS.length; ++i) {
        if (KEYS[i] === KEYS[i - 1]) {
          throw new Error(`Duplication was found in the keyword list: ${KEYS[i]}`);
        }
      }
    })();
    function isOpenParenOfTemplate(token) {
      return token.type === "Template" && TEMPLATE_OPEN_PAREN.test(token.value);
    }
    function isCloseParenOfTemplate(token) {
      return token.type === "Template" && TEMPLATE_CLOSE_PAREN.test(token.value);
    }
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Enforce consistent spacing before and after keywords",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/keyword-spacing"
        },
        fixable: "whitespace",
        schema: [
          {
            type: "object",
            properties: {
              before: { type: "boolean", default: true },
              after: { type: "boolean", default: true },
              overrides: {
                type: "object",
                properties: KEYS.reduce((retv, key) => {
                  retv[key] = {
                    type: "object",
                    properties: {
                      before: { type: "boolean" },
                      after: { type: "boolean" }
                    },
                    additionalProperties: false
                  };
                  return retv;
                }, {}),
                additionalProperties: false
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          expectedBefore: 'Expected space(s) before "{{value}}".',
          expectedAfter: 'Expected space(s) after "{{value}}".',
          unexpectedBefore: 'Unexpected space(s) before "{{value}}".',
          unexpectedAfter: 'Unexpected space(s) after "{{value}}".'
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        const tokensToIgnore = /* @__PURE__ */ new WeakSet();
        function expectSpaceBefore(token, pattern) {
          const prevToken = sourceCode.getTokenBefore(token);
          if (prevToken && (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) && !isOpenParenOfTemplate(prevToken) && !tokensToIgnore.has(prevToken) && astUtils.isTokenOnSameLine(prevToken, token) && !sourceCode.isSpaceBetweenTokens(prevToken, token)) {
            context.report({
              loc: token.loc,
              messageId: "expectedBefore",
              data: token,
              fix(fixer) {
                return fixer.insertTextBefore(token, " ");
              }
            });
          }
        }
        function unexpectSpaceBefore(token, pattern) {
          const prevToken = sourceCode.getTokenBefore(token);
          if (prevToken && (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) && !isOpenParenOfTemplate(prevToken) && !tokensToIgnore.has(prevToken) && astUtils.isTokenOnSameLine(prevToken, token) && sourceCode.isSpaceBetweenTokens(prevToken, token)) {
            context.report({
              loc: { start: prevToken.loc.end, end: token.loc.start },
              messageId: "unexpectedBefore",
              data: token,
              fix(fixer) {
                return fixer.removeRange([prevToken.range[1], token.range[0]]);
              }
            });
          }
        }
        function expectSpaceAfter(token, pattern) {
          const nextToken = sourceCode.getTokenAfter(token);
          if (nextToken && (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) && !isCloseParenOfTemplate(nextToken) && !tokensToIgnore.has(nextToken) && astUtils.isTokenOnSameLine(token, nextToken) && !sourceCode.isSpaceBetweenTokens(token, nextToken)) {
            context.report({
              loc: token.loc,
              messageId: "expectedAfter",
              data: token,
              fix(fixer) {
                return fixer.insertTextAfter(token, " ");
              }
            });
          }
        }
        function unexpectSpaceAfter(token, pattern) {
          const nextToken = sourceCode.getTokenAfter(token);
          if (nextToken && (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) && !isCloseParenOfTemplate(nextToken) && !tokensToIgnore.has(nextToken) && astUtils.isTokenOnSameLine(token, nextToken) && sourceCode.isSpaceBetweenTokens(token, nextToken)) {
            context.report({
              loc: { start: token.loc.end, end: nextToken.loc.start },
              messageId: "unexpectedAfter",
              data: token,
              fix(fixer) {
                return fixer.removeRange([token.range[1], nextToken.range[0]]);
              }
            });
          }
        }
        function parseOptions(options = {}) {
          const before = options.before !== false;
          const after = options.after !== false;
          const defaultValue = {
            before: before ? expectSpaceBefore : unexpectSpaceBefore,
            after: after ? expectSpaceAfter : unexpectSpaceAfter
          };
          const overrides = options && options.overrides || {};
          const retv = /* @__PURE__ */ Object.create(null);
          for (let i = 0; i < KEYS.length; ++i) {
            const key = KEYS[i];
            const override = overrides[key];
            if (override) {
              const thisBefore = "before" in override ? override.before : before;
              const thisAfter = "after" in override ? override.after : after;
              retv[key] = {
                before: thisBefore ? expectSpaceBefore : unexpectSpaceBefore,
                after: thisAfter ? expectSpaceAfter : unexpectSpaceAfter
              };
            } else {
              retv[key] = defaultValue;
            }
          }
          return retv;
        }
        const checkMethodMap = parseOptions(context.options[0]);
        function checkSpacingBefore(token, pattern) {
          checkMethodMap[token.value].before(token, pattern || PREV_TOKEN);
        }
        function checkSpacingAfter(token, pattern) {
          checkMethodMap[token.value].after(token, pattern || NEXT_TOKEN);
        }
        function checkSpacingAround(token) {
          checkSpacingBefore(token);
          checkSpacingAfter(token);
        }
        function checkSpacingAroundFirstToken(node) {
          const firstToken = node && sourceCode.getFirstToken(node);
          if (firstToken && firstToken.type === "Keyword") {
            checkSpacingAround(firstToken);
          }
        }
        function checkSpacingBeforeFirstToken(node) {
          const firstToken = node && sourceCode.getFirstToken(node);
          if (firstToken && firstToken.type === "Keyword") {
            checkSpacingBefore(firstToken);
          }
        }
        function checkSpacingAroundTokenBefore(node) {
          if (node) {
            const token = sourceCode.getTokenBefore(node, astUtils.isKeywordToken);
            checkSpacingAround(token);
          }
        }
        function checkSpacingForFunction(node) {
          const firstToken = node && sourceCode.getFirstToken(node);
          if (firstToken && (firstToken.type === "Keyword" && firstToken.value === "function" || firstToken.value === "async")) {
            checkSpacingBefore(firstToken);
          }
        }
        function checkSpacingForClass(node) {
          checkSpacingAroundFirstToken(node);
          checkSpacingAroundTokenBefore(node.superClass);
        }
        function checkSpacingForIfStatement(node) {
          checkSpacingAroundFirstToken(node);
          checkSpacingAroundTokenBefore(node.alternate);
        }
        function checkSpacingForTryStatement(node) {
          checkSpacingAroundFirstToken(node);
          checkSpacingAroundFirstToken(node.handler);
          checkSpacingAroundTokenBefore(node.finalizer);
        }
        function checkSpacingForDoWhileStatement(node) {
          checkSpacingAroundFirstToken(node);
          checkSpacingAroundTokenBefore(node.test);
        }
        function checkSpacingForForInStatement(node) {
          checkSpacingAroundFirstToken(node);
          const inToken = sourceCode.getTokenBefore(node.right, astUtils.isNotOpeningParenToken);
          const previousToken = sourceCode.getTokenBefore(inToken);
          if (previousToken.type !== "PrivateIdentifier") {
            checkSpacingBefore(inToken);
          }
          checkSpacingAfter(inToken);
        }
        function checkSpacingForForOfStatement(node) {
          if (node.await) {
            checkSpacingBefore(sourceCode.getFirstToken(node, 0));
            checkSpacingAfter(sourceCode.getFirstToken(node, 1));
          } else {
            checkSpacingAroundFirstToken(node);
          }
          const ofToken = sourceCode.getTokenBefore(node.right, astUtils.isNotOpeningParenToken);
          const previousToken = sourceCode.getTokenBefore(ofToken);
          if (previousToken.type !== "PrivateIdentifier") {
            checkSpacingBefore(ofToken);
          }
          checkSpacingAfter(ofToken);
        }
        function checkSpacingForModuleDeclaration(node) {
          const firstToken = sourceCode.getFirstToken(node);
          checkSpacingBefore(firstToken, PREV_TOKEN_M);
          checkSpacingAfter(firstToken, NEXT_TOKEN_M);
          if (node.type === "ExportDefaultDeclaration") {
            checkSpacingAround(sourceCode.getTokenAfter(firstToken));
          }
          if (node.type === "ExportAllDeclaration" && node.exported) {
            const asToken = sourceCode.getTokenBefore(node.exported);
            checkSpacingBefore(asToken, PREV_TOKEN_M);
            checkSpacingAfter(asToken, NEXT_TOKEN_M);
          }
          if (node.source) {
            const fromToken = sourceCode.getTokenBefore(node.source);
            checkSpacingBefore(fromToken, PREV_TOKEN_M);
            checkSpacingAfter(fromToken, NEXT_TOKEN_M);
          }
        }
        function checkSpacingForImportSpecifier(node) {
          if (node.imported.range[0] !== node.local.range[0]) {
            const asToken = sourceCode.getTokenBefore(node.local);
            checkSpacingBefore(asToken, PREV_TOKEN_M);
          }
        }
        function checkSpacingForExportSpecifier(node) {
          if (node.local.range[0] !== node.exported.range[0]) {
            const asToken = sourceCode.getTokenBefore(node.exported);
            checkSpacingBefore(asToken, PREV_TOKEN_M);
            checkSpacingAfter(asToken, NEXT_TOKEN_M);
          }
        }
        function checkSpacingForImportNamespaceSpecifier(node) {
          const asToken = sourceCode.getFirstToken(node, 1);
          checkSpacingBefore(asToken, PREV_TOKEN_M);
        }
        function checkSpacingForProperty(node) {
          if (node.static) {
            checkSpacingAroundFirstToken(node);
          }
          if (node.kind === "get" || node.kind === "set" || (node.method || node.type === "MethodDefinition") && node.value.async) {
            const token = sourceCode.getTokenBefore(
              node.key,
              (tok) => {
                switch (tok.value) {
                  case "get":
                  case "set":
                  case "async":
                    return true;
                  default:
                    return false;
                }
              }
            );
            if (!token) {
              throw new Error("Failed to find token get, set, or async beside method name");
            }
            checkSpacingAround(token);
          }
        }
        function checkSpacingForAwaitExpression(node) {
          checkSpacingBefore(sourceCode.getFirstToken(node));
        }
        return {
          // Statements
          DebuggerStatement: checkSpacingAroundFirstToken,
          WithStatement: checkSpacingAroundFirstToken,
          // Statements - Control flow
          BreakStatement: checkSpacingAroundFirstToken,
          ContinueStatement: checkSpacingAroundFirstToken,
          ReturnStatement: checkSpacingAroundFirstToken,
          ThrowStatement: checkSpacingAroundFirstToken,
          TryStatement: checkSpacingForTryStatement,
          // Statements - Choice
          IfStatement: checkSpacingForIfStatement,
          SwitchStatement: checkSpacingAroundFirstToken,
          SwitchCase: checkSpacingAroundFirstToken,
          // Statements - Loops
          DoWhileStatement: checkSpacingForDoWhileStatement,
          ForInStatement: checkSpacingForForInStatement,
          ForOfStatement: checkSpacingForForOfStatement,
          ForStatement: checkSpacingAroundFirstToken,
          WhileStatement: checkSpacingAroundFirstToken,
          // Statements - Declarations
          ClassDeclaration: checkSpacingForClass,
          ExportNamedDeclaration: checkSpacingForModuleDeclaration,
          ExportDefaultDeclaration: checkSpacingForModuleDeclaration,
          ExportAllDeclaration: checkSpacingForModuleDeclaration,
          FunctionDeclaration: checkSpacingForFunction,
          ImportDeclaration: checkSpacingForModuleDeclaration,
          VariableDeclaration: checkSpacingAroundFirstToken,
          // Expressions
          ArrowFunctionExpression: checkSpacingForFunction,
          AwaitExpression: checkSpacingForAwaitExpression,
          ClassExpression: checkSpacingForClass,
          FunctionExpression: checkSpacingForFunction,
          NewExpression: checkSpacingBeforeFirstToken,
          Super: checkSpacingBeforeFirstToken,
          ThisExpression: checkSpacingBeforeFirstToken,
          UnaryExpression: checkSpacingBeforeFirstToken,
          YieldExpression: checkSpacingBeforeFirstToken,
          // Others
          ImportSpecifier: checkSpacingForImportSpecifier,
          ExportSpecifier: checkSpacingForExportSpecifier,
          ImportNamespaceSpecifier: checkSpacingForImportNamespaceSpecifier,
          MethodDefinition: checkSpacingForProperty,
          PropertyDefinition: checkSpacingForProperty,
          StaticBlock: checkSpacingAroundFirstToken,
          Property: checkSpacingForProperty,
          // To avoid conflicts with `space-infix-ops`, e.g. `a > this.b`
          "BinaryExpression[operator='>']"(node) {
            const operatorToken = sourceCode.getTokenBefore(node.right, astUtils.isNotOpeningParenToken);
            tokensToIgnore.add(operatorToken);
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/line-comment-position.js
var require_line_comment_position = __commonJS({
  "../../node_modules/eslint/lib/rules/line-comment-position.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Enforce position of line comments",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/line-comment-position"
        },
        schema: [
          {
            oneOf: [
              {
                enum: ["above", "beside"]
              },
              {
                type: "object",
                properties: {
                  position: {
                    enum: ["above", "beside"]
                  },
                  ignorePattern: {
                    type: "string"
                  },
                  applyDefaultPatterns: {
                    type: "boolean"
                  },
                  applyDefaultIgnorePatterns: {
                    type: "boolean"
                  }
                },
                additionalProperties: false
              }
            ]
          }
        ],
        messages: {
          above: "Expected comment to be above code.",
          beside: "Expected comment to be beside code."
        }
      },
      create(context) {
        const options = context.options[0];
        let above, ignorePattern, applyDefaultIgnorePatterns = true;
        if (!options || typeof options === "string") {
          above = !options || options === "above";
        } else {
          above = !options.position || options.position === "above";
          ignorePattern = options.ignorePattern;
          if (Object.prototype.hasOwnProperty.call(options, "applyDefaultIgnorePatterns")) {
            applyDefaultIgnorePatterns = options.applyDefaultIgnorePatterns;
          } else {
            applyDefaultIgnorePatterns = options.applyDefaultPatterns !== false;
          }
        }
        const defaultIgnoreRegExp = astUtils.COMMENTS_IGNORE_PATTERN;
        const fallThroughRegExp = /^\s*falls?\s?through/u;
        const customIgnoreRegExp = new RegExp(ignorePattern, "u");
        const sourceCode = context.sourceCode;
        return {
          Program() {
            const comments = sourceCode.getAllComments();
            comments.filter((token) => token.type === "Line").forEach((node) => {
              if (applyDefaultIgnorePatterns && (defaultIgnoreRegExp.test(node.value) || fallThroughRegExp.test(node.value))) {
                return;
              }
              if (ignorePattern && customIgnoreRegExp.test(node.value)) {
                return;
              }
              const previous = sourceCode.getTokenBefore(node, { includeComments: true });
              const isOnSameLine = previous && previous.loc.end.line === node.loc.start.line;
              if (above) {
                if (isOnSameLine) {
                  context.report({
                    node,
                    messageId: "above"
                  });
                }
              } else {
                if (!isOnSameLine) {
                  context.report({
                    node,
                    messageId: "beside"
                  });
                }
              }
            });
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/linebreak-style.js
var require_linebreak_style = __commonJS({
  "../../node_modules/eslint/lib/rules/linebreak-style.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Enforce consistent linebreak style",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/linebreak-style"
        },
        fixable: "whitespace",
        schema: [
          {
            enum: ["unix", "windows"]
          }
        ],
        messages: {
          expectedLF: "Expected linebreaks to be 'LF' but found 'CRLF'.",
          expectedCRLF: "Expected linebreaks to be 'CRLF' but found 'LF'."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        function createFix(range, text) {
          return function(fixer) {
            return fixer.replaceTextRange(range, text);
          };
        }
        return {
          Program: function checkForLinebreakStyle(node) {
            const linebreakStyle = context.options[0] || "unix", expectedLF = linebreakStyle === "unix", expectedLFChars = expectedLF ? "\n" : "\r\n", source = sourceCode.getText(), pattern = astUtils.createGlobalLinebreakMatcher();
            let match;
            let i = 0;
            while ((match = pattern.exec(source)) !== null) {
              i++;
              if (match[0] === expectedLFChars) {
                continue;
              }
              const index = match.index;
              const range = [index, index + match[0].length];
              context.report({
                node,
                loc: {
                  start: {
                    line: i,
                    column: sourceCode.lines[i - 1].length
                  },
                  end: {
                    line: i + 1,
                    column: 0
                  }
                },
                messageId: expectedLF ? "expectedLF" : "expectedCRLF",
                fix: createFix(range, expectedLFChars)
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/lines-around-comment.js
var require_lines_around_comment = __commonJS({
  "../../node_modules/eslint/lib/rules/lines-around-comment.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    function getEmptyLineNums(lines) {
      const emptyLines = lines.map((line, i) => ({
        code: line.trim(),
        num: i + 1
      })).filter((line) => !line.code).map((line) => line.num);
      return emptyLines;
    }
    function getCommentLineNums(comments) {
      const lines = [];
      comments.forEach((token) => {
        const start = token.loc.start.line;
        const end = token.loc.end.line;
        lines.push(start, end);
      });
      return lines;
    }
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Require empty lines around comments",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/lines-around-comment"
        },
        fixable: "whitespace",
        schema: [
          {
            type: "object",
            properties: {
              beforeBlockComment: {
                type: "boolean",
                default: true
              },
              afterBlockComment: {
                type: "boolean",
                default: false
              },
              beforeLineComment: {
                type: "boolean",
                default: false
              },
              afterLineComment: {
                type: "boolean",
                default: false
              },
              allowBlockStart: {
                type: "boolean",
                default: false
              },
              allowBlockEnd: {
                type: "boolean",
                default: false
              },
              allowClassStart: {
                type: "boolean"
              },
              allowClassEnd: {
                type: "boolean"
              },
              allowObjectStart: {
                type: "boolean"
              },
              allowObjectEnd: {
                type: "boolean"
              },
              allowArrayStart: {
                type: "boolean"
              },
              allowArrayEnd: {
                type: "boolean"
              },
              ignorePattern: {
                type: "string"
              },
              applyDefaultIgnorePatterns: {
                type: "boolean"
              },
              afterHashbangComment: {
                type: "boolean",
                default: false
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          after: "Expected line after comment.",
          before: "Expected line before comment."
        }
      },
      create(context) {
        const options = Object.assign({}, context.options[0]);
        const ignorePattern = options.ignorePattern;
        const defaultIgnoreRegExp = astUtils.COMMENTS_IGNORE_PATTERN;
        const customIgnoreRegExp = new RegExp(ignorePattern, "u");
        const applyDefaultIgnorePatterns = options.applyDefaultIgnorePatterns !== false;
        options.beforeBlockComment = typeof options.beforeBlockComment !== "undefined" ? options.beforeBlockComment : true;
        const sourceCode = context.sourceCode;
        const lines = sourceCode.lines, numLines = lines.length + 1, comments = sourceCode.getAllComments(), commentLines = getCommentLineNums(comments), emptyLines = getEmptyLineNums(lines), commentAndEmptyLines = new Set(commentLines.concat(emptyLines));
        function codeAroundComment(token) {
          let currentToken = token;
          do {
            currentToken = sourceCode.getTokenBefore(currentToken, { includeComments: true });
          } while (currentToken && astUtils.isCommentToken(currentToken));
          if (currentToken && astUtils.isTokenOnSameLine(currentToken, token)) {
            return true;
          }
          currentToken = token;
          do {
            currentToken = sourceCode.getTokenAfter(currentToken, { includeComments: true });
          } while (currentToken && astUtils.isCommentToken(currentToken));
          if (currentToken && astUtils.isTokenOnSameLine(token, currentToken)) {
            return true;
          }
          return false;
        }
        function isParentNodeType(parent, nodeType) {
          return parent.type === nodeType || parent.body && parent.body.type === nodeType || parent.consequent && parent.consequent.type === nodeType;
        }
        function getParentNodeOfToken(token) {
          const node = sourceCode.getNodeByRangeIndex(token.range[0]);
          if (node && node.type === "StaticBlock") {
            const openingBrace = sourceCode.getFirstToken(node, { skip: 1 });
            return token.range[0] >= openingBrace.range[0] ? node : null;
          }
          return node;
        }
        function isCommentAtParentStart(token, nodeType) {
          const parent = getParentNodeOfToken(token);
          if (parent && isParentNodeType(parent, nodeType)) {
            let parentStartNodeOrToken = parent;
            if (parent.type === "StaticBlock") {
              parentStartNodeOrToken = sourceCode.getFirstToken(parent, { skip: 1 });
            } else if (parent.type === "SwitchStatement") {
              parentStartNodeOrToken = sourceCode.getTokenAfter(parent.discriminant, {
                filter: astUtils.isOpeningBraceToken
              });
            }
            return token.loc.start.line - parentStartNodeOrToken.loc.start.line === 1;
          }
          return false;
        }
        function isCommentAtParentEnd(token, nodeType) {
          const parent = getParentNodeOfToken(token);
          return !!parent && isParentNodeType(parent, nodeType) && parent.loc.end.line - token.loc.end.line === 1;
        }
        function isCommentAtBlockStart(token) {
          return isCommentAtParentStart(token, "ClassBody") || isCommentAtParentStart(token, "BlockStatement") || isCommentAtParentStart(token, "StaticBlock") || isCommentAtParentStart(token, "SwitchCase") || isCommentAtParentStart(token, "SwitchStatement");
        }
        function isCommentAtBlockEnd(token) {
          return isCommentAtParentEnd(token, "ClassBody") || isCommentAtParentEnd(token, "BlockStatement") || isCommentAtParentEnd(token, "StaticBlock") || isCommentAtParentEnd(token, "SwitchCase") || isCommentAtParentEnd(token, "SwitchStatement");
        }
        function isCommentAtClassStart(token) {
          return isCommentAtParentStart(token, "ClassBody");
        }
        function isCommentAtClassEnd(token) {
          return isCommentAtParentEnd(token, "ClassBody");
        }
        function isCommentAtObjectStart(token) {
          return isCommentAtParentStart(token, "ObjectExpression") || isCommentAtParentStart(token, "ObjectPattern");
        }
        function isCommentAtObjectEnd(token) {
          return isCommentAtParentEnd(token, "ObjectExpression") || isCommentAtParentEnd(token, "ObjectPattern");
        }
        function isCommentAtArrayStart(token) {
          return isCommentAtParentStart(token, "ArrayExpression") || isCommentAtParentStart(token, "ArrayPattern");
        }
        function isCommentAtArrayEnd(token) {
          return isCommentAtParentEnd(token, "ArrayExpression") || isCommentAtParentEnd(token, "ArrayPattern");
        }
        function checkForEmptyLine(token, opts) {
          if (applyDefaultIgnorePatterns && defaultIgnoreRegExp.test(token.value)) {
            return;
          }
          if (ignorePattern && customIgnoreRegExp.test(token.value)) {
            return;
          }
          let after = opts.after, before = opts.before;
          const prevLineNum = token.loc.start.line - 1, nextLineNum = token.loc.end.line + 1, commentIsNotAlone = codeAroundComment(token);
          const blockStartAllowed = options.allowBlockStart && isCommentAtBlockStart(token) && !(options.allowClassStart === false && isCommentAtClassStart(token)), blockEndAllowed = options.allowBlockEnd && isCommentAtBlockEnd(token) && !(options.allowClassEnd === false && isCommentAtClassEnd(token)), classStartAllowed = options.allowClassStart && isCommentAtClassStart(token), classEndAllowed = options.allowClassEnd && isCommentAtClassEnd(token), objectStartAllowed = options.allowObjectStart && isCommentAtObjectStart(token), objectEndAllowed = options.allowObjectEnd && isCommentAtObjectEnd(token), arrayStartAllowed = options.allowArrayStart && isCommentAtArrayStart(token), arrayEndAllowed = options.allowArrayEnd && isCommentAtArrayEnd(token);
          const exceptionStartAllowed = blockStartAllowed || classStartAllowed || objectStartAllowed || arrayStartAllowed;
          const exceptionEndAllowed = blockEndAllowed || classEndAllowed || objectEndAllowed || arrayEndAllowed;
          if (prevLineNum < 1) {
            before = false;
          }
          if (nextLineNum >= numLines) {
            after = false;
          }
          if (commentIsNotAlone) {
            return;
          }
          const previousTokenOrComment = sourceCode.getTokenBefore(token, { includeComments: true });
          const nextTokenOrComment = sourceCode.getTokenAfter(token, { includeComments: true });
          if (!exceptionStartAllowed && before && !commentAndEmptyLines.has(prevLineNum) && !(astUtils.isCommentToken(previousTokenOrComment) && astUtils.isTokenOnSameLine(previousTokenOrComment, token))) {
            const lineStart = token.range[0] - token.loc.start.column;
            const range = [lineStart, lineStart];
            context.report({
              node: token,
              messageId: "before",
              fix(fixer) {
                return fixer.insertTextBeforeRange(range, "\n");
              }
            });
          }
          if (!exceptionEndAllowed && after && !commentAndEmptyLines.has(nextLineNum) && !(astUtils.isCommentToken(nextTokenOrComment) && astUtils.isTokenOnSameLine(token, nextTokenOrComment))) {
            context.report({
              node: token,
              messageId: "after",
              fix(fixer) {
                return fixer.insertTextAfter(token, "\n");
              }
            });
          }
        }
        return {
          Program() {
            comments.forEach((token) => {
              if (token.type === "Line") {
                if (options.beforeLineComment || options.afterLineComment) {
                  checkForEmptyLine(token, {
                    after: options.afterLineComment,
                    before: options.beforeLineComment
                  });
                }
              } else if (token.type === "Block") {
                if (options.beforeBlockComment || options.afterBlockComment) {
                  checkForEmptyLine(token, {
                    after: options.afterBlockComment,
                    before: options.beforeBlockComment
                  });
                }
              } else if (token.type === "Shebang") {
                if (options.afterHashbangComment) {
                  checkForEmptyLine(token, {
                    after: options.afterHashbangComment,
                    before: false
                  });
                }
              }
            });
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/lines-around-directive.js
var require_lines_around_directive = __commonJS({
  "../../node_modules/eslint/lib/rules/lines-around-directive.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Require or disallow newlines around directives",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/lines-around-directive"
        },
        schema: [{
          oneOf: [
            {
              enum: ["always", "never"]
            },
            {
              type: "object",
              properties: {
                before: {
                  enum: ["always", "never"]
                },
                after: {
                  enum: ["always", "never"]
                }
              },
              additionalProperties: false,
              minProperties: 2
            }
          ]
        }],
        fixable: "whitespace",
        messages: {
          expected: 'Expected newline {{location}} "{{value}}" directive.',
          unexpected: 'Unexpected newline {{location}} "{{value}}" directive.'
        },
        deprecated: true,
        replacedBy: ["padding-line-between-statements"]
      },
      create(context) {
        const sourceCode = context.sourceCode;
        const config = context.options[0] || "always";
        const expectLineBefore = typeof config === "string" ? config : config.before;
        const expectLineAfter = typeof config === "string" ? config : config.after;
        function hasNewlineBefore(node) {
          const tokenBefore = sourceCode.getTokenBefore(node, { includeComments: true });
          const tokenLineBefore = tokenBefore ? tokenBefore.loc.end.line : 0;
          return node.loc.start.line - tokenLineBefore >= 2;
        }
        function getLastTokenOnLine(node) {
          const lastToken = sourceCode.getLastToken(node);
          const secondToLastToken = sourceCode.getTokenBefore(lastToken);
          return astUtils.isSemicolonToken(lastToken) && lastToken.loc.start.line > secondToLastToken.loc.end.line ? secondToLastToken : lastToken;
        }
        function hasNewlineAfter(node) {
          const lastToken = getLastTokenOnLine(node);
          const tokenAfter = sourceCode.getTokenAfter(lastToken, { includeComments: true });
          return tokenAfter.loc.start.line - lastToken.loc.end.line >= 2;
        }
        function reportError(node, location, expected) {
          context.report({
            node,
            messageId: expected ? "expected" : "unexpected",
            data: {
              value: node.expression.value,
              location
            },
            fix(fixer) {
              const lastToken = getLastTokenOnLine(node);
              if (expected) {
                return location === "before" ? fixer.insertTextBefore(node, "\n") : fixer.insertTextAfter(lastToken, "\n");
              }
              return fixer.removeRange(location === "before" ? [node.range[0] - 1, node.range[0]] : [lastToken.range[1], lastToken.range[1] + 1]);
            }
          });
        }
        function checkDirectives(node) {
          const directives = astUtils.getDirectivePrologue(node);
          if (!directives.length) {
            return;
          }
          const firstDirective = directives[0];
          const leadingComments = sourceCode.getCommentsBefore(firstDirective);
          if (leadingComments.length) {
            if (expectLineBefore === "always" && !hasNewlineBefore(firstDirective)) {
              reportError(firstDirective, "before", true);
            }
            if (expectLineBefore === "never" && hasNewlineBefore(firstDirective)) {
              reportError(firstDirective, "before", false);
            }
          } else if (node.type === "Program" && expectLineBefore === "never" && !leadingComments.length && hasNewlineBefore(firstDirective)) {
            reportError(firstDirective, "before", false);
          }
          const lastDirective = directives[directives.length - 1];
          const statements = node.type === "Program" ? node.body : node.body.body;
          if (lastDirective === statements[statements.length - 1] && !lastDirective.trailingComments) {
            return;
          }
          if (expectLineAfter === "always" && !hasNewlineAfter(lastDirective)) {
            reportError(lastDirective, "after", true);
          }
          if (expectLineAfter === "never" && hasNewlineAfter(lastDirective)) {
            reportError(lastDirective, "after", false);
          }
        }
        return {
          Program: checkDirectives,
          FunctionDeclaration: checkDirectives,
          FunctionExpression: checkDirectives,
          ArrowFunctionExpression: checkDirectives
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/lines-between-class-members.js
var require_lines_between_class_members = __commonJS({
  "../../node_modules/eslint/lib/rules/lines-between-class-members.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Require or disallow an empty line between class members",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/lines-between-class-members"
        },
        fixable: "whitespace",
        schema: [
          {
            enum: ["always", "never"]
          },
          {
            type: "object",
            properties: {
              exceptAfterSingleLine: {
                type: "boolean",
                default: false
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          never: "Unexpected blank line between class members.",
          always: "Expected blank line between class members."
        }
      },
      create(context) {
        const options = [];
        options[0] = context.options[0] || "always";
        options[1] = context.options[1] || { exceptAfterSingleLine: false };
        const sourceCode = context.sourceCode;
        function getBoundaryTokens(curNode, nextNode) {
          const lastToken = sourceCode.getLastToken(curNode);
          const prevToken = sourceCode.getTokenBefore(lastToken);
          const nextToken = sourceCode.getFirstToken(nextNode);
          const isSemicolonLessStyle = astUtils.isSemicolonToken(lastToken) && !astUtils.isTokenOnSameLine(prevToken, lastToken) && astUtils.isTokenOnSameLine(lastToken, nextToken);
          return isSemicolonLessStyle ? { curLast: prevToken, nextFirst: lastToken } : { curLast: lastToken, nextFirst: nextToken };
        }
        function findLastConsecutiveTokenAfter(prevLastToken, nextFirstToken, maxLine) {
          const after = sourceCode.getTokenAfter(prevLastToken, { includeComments: true });
          if (after !== nextFirstToken && after.loc.start.line - prevLastToken.loc.end.line <= maxLine) {
            return findLastConsecutiveTokenAfter(after, nextFirstToken, maxLine);
          }
          return prevLastToken;
        }
        function findFirstConsecutiveTokenBefore(nextFirstToken, prevLastToken, maxLine) {
          const before = sourceCode.getTokenBefore(nextFirstToken, { includeComments: true });
          if (before !== prevLastToken && nextFirstToken.loc.start.line - before.loc.end.line <= maxLine) {
            return findFirstConsecutiveTokenBefore(before, prevLastToken, maxLine);
          }
          return nextFirstToken;
        }
        function hasTokenOrCommentBetween(before, after) {
          return sourceCode.getTokensBetween(before, after, { includeComments: true }).length !== 0;
        }
        return {
          ClassBody(node) {
            const body = node.body;
            for (let i = 0; i < body.length - 1; i++) {
              const curFirst = sourceCode.getFirstToken(body[i]);
              const { curLast, nextFirst } = getBoundaryTokens(body[i], body[i + 1]);
              const isMulti = !astUtils.isTokenOnSameLine(curFirst, curLast);
              const skip = !isMulti && options[1].exceptAfterSingleLine;
              const beforePadding = findLastConsecutiveTokenAfter(curLast, nextFirst, 1);
              const afterPadding = findFirstConsecutiveTokenBefore(nextFirst, curLast, 1);
              const isPadded = afterPadding.loc.start.line - beforePadding.loc.end.line > 1;
              const hasTokenInPadding = hasTokenOrCommentBetween(beforePadding, afterPadding);
              const curLineLastToken = findLastConsecutiveTokenAfter(curLast, nextFirst, 0);
              if (options[0] === "always" && !skip && !isPadded || options[0] === "never" && isPadded) {
                context.report({
                  node: body[i + 1],
                  messageId: isPadded ? "never" : "always",
                  fix(fixer) {
                    if (hasTokenInPadding) {
                      return null;
                    }
                    return isPadded ? fixer.replaceTextRange([beforePadding.range[1], afterPadding.range[0]], "\n") : fixer.insertTextAfter(curLineLastToken, "\n");
                  }
                });
              }
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/logical-assignment-operators.js
var require_logical_assignment_operators = __commonJS({
  "../../node_modules/eslint/lib/rules/logical-assignment-operators.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var baseTypes = /* @__PURE__ */ new Set(["Identifier", "Super", "ThisExpression"]);
    function isUndefined(expression, scope) {
      if (expression.type === "Identifier" && expression.name === "undefined") {
        return astUtils.isReferenceToGlobalVariable(scope, expression);
      }
      return expression.type === "UnaryExpression" && expression.operator === "void" && expression.argument.type === "Literal" && expression.argument.value === 0;
    }
    function isReference(expression) {
      return expression.type === "Identifier" && expression.name !== "undefined" || expression.type === "MemberExpression";
    }
    function isImplicitNullishComparison(expression, scope) {
      if (expression.type !== "BinaryExpression" || expression.operator !== "==") {
        return false;
      }
      const reference = isReference(expression.left) ? "left" : "right";
      const nullish = reference === "left" ? "right" : "left";
      return isReference(expression[reference]) && (astUtils.isNullLiteral(expression[nullish]) || isUndefined(expression[nullish], scope));
    }
    function isDoubleComparison(expression) {
      return expression.type === "LogicalExpression" && expression.operator === "||" && expression.left.type === "BinaryExpression" && expression.left.operator === "===" && expression.right.type === "BinaryExpression" && expression.right.operator === "===";
    }
    function isExplicitNullishComparison(expression, scope) {
      if (!isDoubleComparison(expression)) {
        return false;
      }
      const leftReference = isReference(expression.left.left) ? "left" : "right";
      const leftNullish = leftReference === "left" ? "right" : "left";
      const rightReference = isReference(expression.right.left) ? "left" : "right";
      const rightNullish = rightReference === "left" ? "right" : "left";
      return astUtils.isSameReference(expression.left[leftReference], expression.right[rightReference]) && (astUtils.isNullLiteral(expression.left[leftNullish]) && isUndefined(expression.right[rightNullish], scope) || isUndefined(expression.left[leftNullish], scope) && astUtils.isNullLiteral(expression.right[rightNullish]));
    }
    function isBooleanCast(expression, scope) {
      return expression.type === "CallExpression" && expression.callee.name === "Boolean" && expression.arguments.length === 1 && astUtils.isReferenceToGlobalVariable(scope, expression.callee);
    }
    function getExistence(expression, scope) {
      const isNegated = expression.type === "UnaryExpression" && expression.operator === "!";
      const base = isNegated ? expression.argument : expression;
      switch (true) {
        case isReference(base):
          return { reference: base, operator: isNegated ? "||" : "&&" };
        case (base.type === "UnaryExpression" && base.operator === "!" && isReference(base.argument)):
          return { reference: base.argument, operator: "&&" };
        case (isBooleanCast(base, scope) && isReference(base.arguments[0])):
          return { reference: base.arguments[0], operator: isNegated ? "||" : "&&" };
        case isImplicitNullishComparison(expression, scope):
          return { reference: isReference(expression.left) ? expression.left : expression.right, operator: "??" };
        case isExplicitNullishComparison(expression, scope):
          return { reference: isReference(expression.left.left) ? expression.left.left : expression.left.right, operator: "??" };
        default:
          return null;
      }
    }
    function isInsideWithBlock(node) {
      if (node.type === "Program") {
        return false;
      }
      return node.parent.type === "WithStatement" && node.parent.body === node ? true : isInsideWithBlock(node.parent);
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Require or disallow logical assignment operator shorthand",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/logical-assignment-operators"
        },
        schema: {
          type: "array",
          oneOf: [{
            items: [
              { const: "always" },
              {
                type: "object",
                properties: {
                  enforceForIfStatements: {
                    type: "boolean"
                  }
                },
                additionalProperties: false
              }
            ],
            minItems: 0,
            // 0 for allowing passing no options
            maxItems: 2
          }, {
            items: [{ const: "never" }],
            minItems: 1,
            maxItems: 1
          }]
        },
        fixable: "code",
        hasSuggestions: true,
        messages: {
          assignment: "Assignment (=) can be replaced with operator assignment ({{operator}}).",
          useLogicalOperator: "Convert this assignment to use the operator {{ operator }}.",
          logical: "Logical expression can be replaced with an assignment ({{ operator }}).",
          convertLogical: "Replace this logical expression with an assignment with the operator {{ operator }}.",
          if: "'if' statement can be replaced with a logical operator assignment with operator {{ operator }}.",
          convertIf: "Replace this 'if' statement with a logical assignment with operator {{ operator }}.",
          unexpected: "Unexpected logical operator assignment ({{operator}}) shorthand.",
          separate: "Separate the logical assignment into an assignment with a logical operator."
        }
      },
      create(context) {
        const mode = context.options[0] === "never" ? "never" : "always";
        const checkIf = mode === "always" && context.options.length > 1 && context.options[1].enforceForIfStatements;
        const sourceCode = context.sourceCode;
        const isStrict = sourceCode.getScope(sourceCode.ast).isStrict;
        function cannotBeGetter(node) {
          return node.type === "Identifier" && (isStrict || !isInsideWithBlock(node));
        }
        function accessesSingleProperty(node) {
          if (!isStrict && isInsideWithBlock(node)) {
            return node.type === "Identifier";
          }
          return node.type === "MemberExpression" && baseTypes.has(node.object.type) && (!node.computed || node.property.type !== "MemberExpression" && node.property.type !== "ChainExpression");
        }
        function createConditionalFixer(descriptor, suggestion, shouldBeFixed) {
          if (shouldBeFixed) {
            return {
              ...descriptor,
              fix: suggestion.fix
            };
          }
          return {
            ...descriptor,
            suggest: [suggestion]
          };
        }
        function getOperatorToken(node) {
          return sourceCode.getFirstTokenBetween(node.left, node.right, (token) => token.value === node.operator);
        }
        if (mode === "never") {
          return {
            // foo ||= bar
            "AssignmentExpression"(assignment) {
              if (!astUtils.isLogicalAssignmentOperator(assignment.operator)) {
                return;
              }
              const descriptor = {
                messageId: "unexpected",
                node: assignment,
                data: { operator: assignment.operator }
              };
              const suggestion = {
                messageId: "separate",
                *fix(ruleFixer) {
                  if (sourceCode.getCommentsInside(assignment).length > 0) {
                    return;
                  }
                  const operatorToken = getOperatorToken(assignment);
                  yield ruleFixer.replaceText(operatorToken, "=");
                  const assignmentText = sourceCode.getText(assignment.left);
                  const operator = assignment.operator.slice(0, -1);
                  yield ruleFixer.insertTextAfter(operatorToken, ` ${assignmentText} ${operator}`);
                  const precedence = astUtils.getPrecedence(assignment.right) <= astUtils.getPrecedence({ type: "LogicalExpression", operator });
                  const mixed = assignment.operator === "??=" && astUtils.isLogicalExpression(assignment.right);
                  if (!astUtils.isParenthesised(sourceCode, assignment.right) && (precedence || mixed)) {
                    yield ruleFixer.insertTextBefore(assignment.right, "(");
                    yield ruleFixer.insertTextAfter(assignment.right, ")");
                  }
                }
              };
              context.report(createConditionalFixer(descriptor, suggestion, cannotBeGetter(assignment.left)));
            }
          };
        }
        return {
          // foo = foo || bar
          "AssignmentExpression[operator='='][right.type='LogicalExpression']"(assignment) {
            if (!astUtils.isSameReference(assignment.left, assignment.right.left)) {
              return;
            }
            const descriptor = {
              messageId: "assignment",
              node: assignment,
              data: { operator: `${assignment.right.operator}=` }
            };
            const suggestion = {
              messageId: "useLogicalOperator",
              data: { operator: `${assignment.right.operator}=` },
              *fix(ruleFixer) {
                if (sourceCode.getCommentsInside(assignment).length > 0) {
                  return;
                }
                const assignmentOperatorToken = getOperatorToken(assignment);
                yield ruleFixer.insertTextBefore(assignmentOperatorToken, assignment.right.operator);
                const logicalOperatorToken = getOperatorToken(assignment.right);
                const firstRightOperandToken = sourceCode.getTokenAfter(logicalOperatorToken);
                yield ruleFixer.removeRange([assignment.right.range[0], firstRightOperandToken.range[0]]);
              }
            };
            context.report(createConditionalFixer(descriptor, suggestion, cannotBeGetter(assignment.left)));
          },
          // foo || (foo = bar)
          'LogicalExpression[right.type="AssignmentExpression"][right.operator="="]'(logical) {
            if (isReference(logical.left) && astUtils.isSameReference(logical.left, logical.right.left)) {
              const descriptor = {
                messageId: "logical",
                node: logical,
                data: { operator: `${logical.operator}=` }
              };
              const suggestion = {
                messageId: "convertLogical",
                data: { operator: `${logical.operator}=` },
                *fix(ruleFixer) {
                  if (sourceCode.getCommentsInside(logical).length > 0) {
                    return;
                  }
                  const parentPrecedence = astUtils.getPrecedence(logical.parent);
                  const requiresOuterParenthesis = logical.parent.type !== "ExpressionStatement" && (parentPrecedence === -1 || astUtils.getPrecedence({ type: "AssignmentExpression" }) < parentPrecedence);
                  if (!astUtils.isParenthesised(sourceCode, logical) && requiresOuterParenthesis) {
                    yield ruleFixer.insertTextBefore(logical, "(");
                    yield ruleFixer.insertTextAfter(logical, ")");
                  }
                  yield ruleFixer.removeRange([logical.range[0], logical.right.range[0]]);
                  yield ruleFixer.removeRange([logical.right.range[1], logical.range[1]]);
                  const operatorToken = getOperatorToken(logical.right);
                  yield ruleFixer.insertTextBefore(operatorToken, logical.operator);
                }
              };
              const fix = cannotBeGetter(logical.left) || accessesSingleProperty(logical.left);
              context.report(createConditionalFixer(descriptor, suggestion, fix));
            }
          },
          // if (foo) foo = bar
          "IfStatement[alternate=null]"(ifNode) {
            if (!checkIf) {
              return;
            }
            const hasBody = ifNode.consequent.type === "BlockStatement";
            if (hasBody && ifNode.consequent.body.length !== 1) {
              return;
            }
            const body = hasBody ? ifNode.consequent.body[0] : ifNode.consequent;
            const scope = sourceCode.getScope(ifNode);
            const existence = getExistence(ifNode.test, scope);
            if (body.type === "ExpressionStatement" && body.expression.type === "AssignmentExpression" && body.expression.operator === "=" && existence !== null && astUtils.isSameReference(existence.reference, body.expression.left)) {
              const descriptor = {
                messageId: "if",
                node: ifNode,
                data: { operator: `${existence.operator}=` }
              };
              const suggestion = {
                messageId: "convertIf",
                data: { operator: `${existence.operator}=` },
                *fix(ruleFixer) {
                  if (sourceCode.getCommentsInside(ifNode).length > 0) {
                    return;
                  }
                  const firstBodyToken = sourceCode.getFirstToken(body);
                  const prevToken = sourceCode.getTokenBefore(ifNode);
                  if (prevToken !== null && prevToken.value !== ";" && prevToken.value !== "{" && firstBodyToken.type !== "Identifier" && firstBodyToken.type !== "Keyword") {
                    return;
                  }
                  const operatorToken = getOperatorToken(body.expression);
                  yield ruleFixer.insertTextBefore(operatorToken, existence.operator);
                  yield ruleFixer.removeRange([ifNode.range[0], body.range[0]]);
                  yield ruleFixer.removeRange([body.range[1], ifNode.range[1]]);
                  const nextToken = sourceCode.getTokenAfter(body.expression);
                  if (hasBody && (nextToken !== null && nextToken.value !== ";")) {
                    yield ruleFixer.insertTextAfter(ifNode, ";");
                  }
                }
              };
              const shouldBeFixed = cannotBeGetter(existence.reference) || ifNode.test.type !== "LogicalExpression" && accessesSingleProperty(existence.reference);
              context.report(createConditionalFixer(descriptor, suggestion, shouldBeFixed));
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/max-classes-per-file.js
var require_max_classes_per_file = __commonJS({
  "../../node_modules/eslint/lib/rules/max-classes-per-file.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Enforce a maximum number of classes per file",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/max-classes-per-file"
        },
        schema: [
          {
            oneOf: [
              {
                type: "integer",
                minimum: 1
              },
              {
                type: "object",
                properties: {
                  ignoreExpressions: {
                    type: "boolean"
                  },
                  max: {
                    type: "integer",
                    minimum: 1
                  }
                },
                additionalProperties: false
              }
            ]
          }
        ],
        messages: {
          maximumExceeded: "File has too many classes ({{ classCount }}). Maximum allowed is {{ max }}."
        }
      },
      create(context) {
        const [option = {}] = context.options;
        const [ignoreExpressions, max] = typeof option === "number" ? [false, option || 1] : [option.ignoreExpressions, option.max || 1];
        let classCount = 0;
        return {
          Program() {
            classCount = 0;
          },
          "Program:exit"(node) {
            if (classCount > max) {
              context.report({
                node,
                messageId: "maximumExceeded",
                data: {
                  classCount,
                  max
                }
              });
            }
          },
          "ClassDeclaration"() {
            classCount++;
          },
          "ClassExpression"() {
            if (!ignoreExpressions) {
              classCount++;
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/max-depth.js
var require_max_depth = __commonJS({
  "../../node_modules/eslint/lib/rules/max-depth.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Enforce a maximum depth that blocks can be nested",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/max-depth"
        },
        schema: [
          {
            oneOf: [
              {
                type: "integer",
                minimum: 0
              },
              {
                type: "object",
                properties: {
                  maximum: {
                    type: "integer",
                    minimum: 0
                  },
                  max: {
                    type: "integer",
                    minimum: 0
                  }
                },
                additionalProperties: false
              }
            ]
          }
        ],
        messages: {
          tooDeeply: "Blocks are nested too deeply ({{depth}}). Maximum allowed is {{maxDepth}}."
        }
      },
      create(context) {
        const functionStack = [], option = context.options[0];
        let maxDepth = 4;
        if (typeof option === "object" && (Object.prototype.hasOwnProperty.call(option, "maximum") || Object.prototype.hasOwnProperty.call(option, "max"))) {
          maxDepth = option.maximum || option.max;
        }
        if (typeof option === "number") {
          maxDepth = option;
        }
        function startFunction() {
          functionStack.push(0);
        }
        function endFunction() {
          functionStack.pop();
        }
        function pushBlock(node) {
          const len = ++functionStack[functionStack.length - 1];
          if (len > maxDepth) {
            context.report({ node, messageId: "tooDeeply", data: { depth: len, maxDepth } });
          }
        }
        function popBlock() {
          functionStack[functionStack.length - 1]--;
        }
        return {
          Program: startFunction,
          FunctionDeclaration: startFunction,
          FunctionExpression: startFunction,
          ArrowFunctionExpression: startFunction,
          StaticBlock: startFunction,
          IfStatement(node) {
            if (node.parent.type !== "IfStatement") {
              pushBlock(node);
            }
          },
          SwitchStatement: pushBlock,
          TryStatement: pushBlock,
          DoWhileStatement: pushBlock,
          WhileStatement: pushBlock,
          WithStatement: pushBlock,
          ForStatement: pushBlock,
          ForInStatement: pushBlock,
          ForOfStatement: pushBlock,
          "IfStatement:exit": popBlock,
          "SwitchStatement:exit": popBlock,
          "TryStatement:exit": popBlock,
          "DoWhileStatement:exit": popBlock,
          "WhileStatement:exit": popBlock,
          "WithStatement:exit": popBlock,
          "ForStatement:exit": popBlock,
          "ForInStatement:exit": popBlock,
          "ForOfStatement:exit": popBlock,
          "FunctionDeclaration:exit": endFunction,
          "FunctionExpression:exit": endFunction,
          "ArrowFunctionExpression:exit": endFunction,
          "StaticBlock:exit": endFunction,
          "Program:exit": endFunction
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/max-len.js
var require_max_len = __commonJS({
  "../../node_modules/eslint/lib/rules/max-len.js"(exports, module) {
    "use strict";
    var OPTIONS_SCHEMA = {
      type: "object",
      properties: {
        code: {
          type: "integer",
          minimum: 0
        },
        comments: {
          type: "integer",
          minimum: 0
        },
        tabWidth: {
          type: "integer",
          minimum: 0
        },
        ignorePattern: {
          type: "string"
        },
        ignoreComments: {
          type: "boolean"
        },
        ignoreStrings: {
          type: "boolean"
        },
        ignoreUrls: {
          type: "boolean"
        },
        ignoreTemplateLiterals: {
          type: "boolean"
        },
        ignoreRegExpLiterals: {
          type: "boolean"
        },
        ignoreTrailingComments: {
          type: "boolean"
        }
      },
      additionalProperties: false
    };
    var OPTIONS_OR_INTEGER_SCHEMA = {
      anyOf: [
        OPTIONS_SCHEMA,
        {
          type: "integer",
          minimum: 0
        }
      ]
    };
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Enforce a maximum line length",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/max-len"
        },
        schema: [
          OPTIONS_OR_INTEGER_SCHEMA,
          OPTIONS_OR_INTEGER_SCHEMA,
          OPTIONS_SCHEMA
        ],
        messages: {
          max: "This line has a length of {{lineLength}}. Maximum allowed is {{maxLength}}.",
          maxComment: "This line has a comment length of {{lineLength}}. Maximum allowed is {{maxCommentLength}}."
        }
      },
      create(context) {
        const URL_REGEXP = /[^:/?#]:\/\/[^?#]/u;
        const sourceCode = context.sourceCode;
        function computeLineLength(line, tabWidth2) {
          let extraCharacterCount = 0;
          line.replace(/\t/gu, (match, offset) => {
            const totalOffset = offset + extraCharacterCount, previousTabStopOffset = tabWidth2 ? totalOffset % tabWidth2 : 0, spaceCount = tabWidth2 - previousTabStopOffset;
            extraCharacterCount += spaceCount - 1;
          });
          return Array.from(line).length + extraCharacterCount;
        }
        const options = Object.assign({}, context.options[context.options.length - 1]);
        if (typeof context.options[0] === "number") {
          options.code = context.options[0];
        }
        if (typeof context.options[1] === "number") {
          options.tabWidth = context.options[1];
        }
        const maxLength = typeof options.code === "number" ? options.code : 80, tabWidth = typeof options.tabWidth === "number" ? options.tabWidth : 4, ignoreComments = !!options.ignoreComments, ignoreStrings = !!options.ignoreStrings, ignoreTemplateLiterals = !!options.ignoreTemplateLiterals, ignoreRegExpLiterals = !!options.ignoreRegExpLiterals, ignoreTrailingComments = !!options.ignoreTrailingComments || !!options.ignoreComments, ignoreUrls = !!options.ignoreUrls, maxCommentLength = options.comments;
        let ignorePattern = options.ignorePattern || null;
        if (ignorePattern) {
          ignorePattern = new RegExp(ignorePattern, "u");
        }
        function isTrailingComment(line, lineNumber, comment) {
          return comment && (comment.loc.start.line === lineNumber && lineNumber <= comment.loc.end.line) && (comment.loc.end.line > lineNumber || comment.loc.end.column === line.length);
        }
        function isFullLineComment(line, lineNumber, comment) {
          const start = comment.loc.start, end = comment.loc.end, isFirstTokenOnLine = !line.slice(0, comment.loc.start.column).trim();
          return comment && (start.line < lineNumber || start.line === lineNumber && isFirstTokenOnLine) && (end.line > lineNumber || end.line === lineNumber && end.column === line.length);
        }
        function isJSXEmptyExpressionInSingleLineContainer(node) {
          if (!node || !node.parent || node.type !== "JSXEmptyExpression" || node.parent.type !== "JSXExpressionContainer") {
            return false;
          }
          const parent = node.parent;
          return parent.loc.start.line === parent.loc.end.line;
        }
        function stripTrailingComment(line, comment) {
          return line.slice(0, comment.loc.start.column).replace(/\s+$/u, "");
        }
        function ensureArrayAndPush(object, key, value) {
          if (!Array.isArray(object[key])) {
            object[key] = [];
          }
          object[key].push(value);
        }
        function getAllStrings() {
          return sourceCode.ast.tokens.filter((token) => token.type === "String" || token.type === "JSXText" && sourceCode.getNodeByRangeIndex(token.range[0] - 1).type === "JSXAttribute");
        }
        function getAllTemplateLiterals() {
          return sourceCode.ast.tokens.filter((token) => token.type === "Template");
        }
        function getAllRegExpLiterals() {
          return sourceCode.ast.tokens.filter((token) => token.type === "RegularExpression");
        }
        function groupArrayByLineNumber(arr) {
          const obj = {};
          for (let i = 0; i < arr.length; i++) {
            const node = arr[i];
            for (let j = node.loc.start.line; j <= node.loc.end.line; ++j) {
              ensureArrayAndPush(obj, j, node);
            }
          }
          return obj;
        }
        function getAllComments() {
          const comments = [];
          sourceCode.getAllComments().forEach((commentNode) => {
            const containingNode = sourceCode.getNodeByRangeIndex(commentNode.range[0]);
            if (isJSXEmptyExpressionInSingleLineContainer(containingNode)) {
              if (comments[comments.length - 1] !== containingNode.parent) {
                comments.push(containingNode.parent);
              }
            } else {
              comments.push(commentNode);
            }
          });
          return comments;
        }
        function checkProgramForMaxLength(node) {
          const lines = sourceCode.lines, comments = ignoreComments || maxCommentLength || ignoreTrailingComments ? getAllComments() : [];
          let commentsIndex = 0;
          const strings = getAllStrings();
          const stringsByLine = groupArrayByLineNumber(strings);
          const templateLiterals = getAllTemplateLiterals();
          const templateLiteralsByLine = groupArrayByLineNumber(templateLiterals);
          const regExpLiterals = getAllRegExpLiterals();
          const regExpLiteralsByLine = groupArrayByLineNumber(regExpLiterals);
          lines.forEach((line, i) => {
            const lineNumber = i + 1;
            let lineIsComment = false;
            let textToMeasure;
            if (commentsIndex < comments.length) {
              let comment = null;
              do {
                comment = comments[++commentsIndex];
              } while (comment && comment.loc.start.line <= lineNumber);
              comment = comments[--commentsIndex];
              if (isFullLineComment(line, lineNumber, comment)) {
                lineIsComment = true;
                textToMeasure = line;
              } else if (ignoreTrailingComments && isTrailingComment(line, lineNumber, comment)) {
                textToMeasure = stripTrailingComment(line, comment);
                let lastIndex = commentsIndex;
                while (isTrailingComment(textToMeasure, lineNumber, comments[--lastIndex])) {
                  textToMeasure = stripTrailingComment(textToMeasure, comments[lastIndex]);
                }
              } else {
                textToMeasure = line;
              }
            } else {
              textToMeasure = line;
            }
            if (ignorePattern && ignorePattern.test(textToMeasure) || ignoreUrls && URL_REGEXP.test(textToMeasure) || ignoreStrings && stringsByLine[lineNumber] || ignoreTemplateLiterals && templateLiteralsByLine[lineNumber] || ignoreRegExpLiterals && regExpLiteralsByLine[lineNumber]) {
              return;
            }
            const lineLength = computeLineLength(textToMeasure, tabWidth);
            const commentLengthApplies = lineIsComment && maxCommentLength;
            if (lineIsComment && ignoreComments) {
              return;
            }
            const loc = {
              start: {
                line: lineNumber,
                column: 0
              },
              end: {
                line: lineNumber,
                column: textToMeasure.length
              }
            };
            if (commentLengthApplies) {
              if (lineLength > maxCommentLength) {
                context.report({
                  node,
                  loc,
                  messageId: "maxComment",
                  data: {
                    lineLength,
                    maxCommentLength
                  }
                });
              }
            } else if (lineLength > maxLength) {
              context.report({
                node,
                loc,
                messageId: "max",
                data: {
                  lineLength,
                  maxLength
                }
              });
            }
          });
        }
        return {
          Program: checkProgramForMaxLength
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/max-lines.js
var require_max_lines = __commonJS({
  "../../node_modules/eslint/lib/rules/max-lines.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    function range(start, end) {
      return [...Array(end - start).keys()].map((x) => x + start);
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Enforce a maximum number of lines per file",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/max-lines"
        },
        schema: [
          {
            oneOf: [
              {
                type: "integer",
                minimum: 0
              },
              {
                type: "object",
                properties: {
                  max: {
                    type: "integer",
                    minimum: 0
                  },
                  skipComments: {
                    type: "boolean"
                  },
                  skipBlankLines: {
                    type: "boolean"
                  }
                },
                additionalProperties: false
              }
            ]
          }
        ],
        messages: {
          exceed: "File has too many lines ({{actual}}). Maximum allowed is {{max}}."
        }
      },
      create(context) {
        const option = context.options[0];
        let max = 300;
        if (typeof option === "object" && Object.prototype.hasOwnProperty.call(option, "max")) {
          max = option.max;
        } else if (typeof option === "number") {
          max = option;
        }
        const skipComments = option && option.skipComments;
        const skipBlankLines = option && option.skipBlankLines;
        const sourceCode = context.sourceCode;
        function isCommentNodeType(token) {
          return token && (token.type === "Block" || token.type === "Line");
        }
        function getLinesWithoutCode(comment) {
          let start = comment.loc.start.line;
          let end = comment.loc.end.line;
          let token;
          token = comment;
          do {
            token = sourceCode.getTokenBefore(token, {
              includeComments: true
            });
          } while (isCommentNodeType(token));
          if (token && astUtils.isTokenOnSameLine(token, comment)) {
            start += 1;
          }
          token = comment;
          do {
            token = sourceCode.getTokenAfter(token, {
              includeComments: true
            });
          } while (isCommentNodeType(token));
          if (token && astUtils.isTokenOnSameLine(comment, token)) {
            end -= 1;
          }
          if (start <= end) {
            return range(start, end + 1);
          }
          return [];
        }
        return {
          "Program:exit"() {
            let lines = sourceCode.lines.map((text, i) => ({
              lineNumber: i + 1,
              text
            }));
            if (lines.length > 1 && lines[lines.length - 1].text === "") {
              lines.pop();
            }
            if (skipBlankLines) {
              lines = lines.filter((l) => l.text.trim() !== "");
            }
            if (skipComments) {
              const comments = sourceCode.getAllComments();
              const commentLines = new Set(comments.flatMap(getLinesWithoutCode));
              lines = lines.filter(
                (l) => !commentLines.has(l.lineNumber)
              );
            }
            if (lines.length > max) {
              const loc = {
                start: {
                  line: lines[max].lineNumber,
                  column: 0
                },
                end: {
                  line: sourceCode.lines.length,
                  column: sourceCode.lines[sourceCode.lines.length - 1].length
                }
              };
              context.report({
                loc,
                messageId: "exceed",
                data: {
                  max,
                  actual: lines.length
                }
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/max-lines-per-function.js
var require_max_lines_per_function = __commonJS({
  "../../node_modules/eslint/lib/rules/max-lines-per-function.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var { upperCaseFirst } = require_string_utils();
    var OPTIONS_SCHEMA = {
      type: "object",
      properties: {
        max: {
          type: "integer",
          minimum: 0
        },
        skipComments: {
          type: "boolean"
        },
        skipBlankLines: {
          type: "boolean"
        },
        IIFEs: {
          type: "boolean"
        }
      },
      additionalProperties: false
    };
    var OPTIONS_OR_INTEGER_SCHEMA = {
      oneOf: [
        OPTIONS_SCHEMA,
        {
          type: "integer",
          minimum: 1
        }
      ]
    };
    function getCommentLineNumbers(comments) {
      const map = /* @__PURE__ */ new Map();
      comments.forEach((comment) => {
        for (let i = comment.loc.start.line; i <= comment.loc.end.line; i++) {
          map.set(i, comment);
        }
      });
      return map;
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Enforce a maximum number of lines of code in a function",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/max-lines-per-function"
        },
        schema: [
          OPTIONS_OR_INTEGER_SCHEMA
        ],
        messages: {
          exceed: "{{name}} has too many lines ({{lineCount}}). Maximum allowed is {{maxLines}}."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        const lines = sourceCode.lines;
        const option = context.options[0];
        let maxLines = 50;
        let skipComments = false;
        let skipBlankLines = false;
        let IIFEs = false;
        if (typeof option === "object") {
          maxLines = typeof option.max === "number" ? option.max : 50;
          skipComments = !!option.skipComments;
          skipBlankLines = !!option.skipBlankLines;
          IIFEs = !!option.IIFEs;
        } else if (typeof option === "number") {
          maxLines = option;
        }
        const commentLineNumbers = getCommentLineNumbers(sourceCode.getAllComments());
        function isFullLineComment(line, lineNumber, comment) {
          const start = comment.loc.start, end = comment.loc.end, isFirstTokenOnLine = start.line === lineNumber && !line.slice(0, start.column).trim(), isLastTokenOnLine = end.line === lineNumber && !line.slice(end.column).trim();
          return comment && (start.line < lineNumber || isFirstTokenOnLine) && (end.line > lineNumber || isLastTokenOnLine);
        }
        function isIIFE(node) {
          return (node.type === "FunctionExpression" || node.type === "ArrowFunctionExpression") && node.parent && node.parent.type === "CallExpression" && node.parent.callee === node;
        }
        function isEmbedded(node) {
          if (!node.parent) {
            return false;
          }
          if (node !== node.parent.value) {
            return false;
          }
          if (node.parent.type === "MethodDefinition") {
            return true;
          }
          if (node.parent.type === "Property") {
            return node.parent.method === true || node.parent.kind === "get" || node.parent.kind === "set";
          }
          return false;
        }
        function processFunction(funcNode) {
          const node = isEmbedded(funcNode) ? funcNode.parent : funcNode;
          if (!IIFEs && isIIFE(node)) {
            return;
          }
          let lineCount = 0;
          for (let i = node.loc.start.line - 1; i < node.loc.end.line; ++i) {
            const line = lines[i];
            if (skipComments) {
              if (commentLineNumbers.has(i + 1) && isFullLineComment(line, i + 1, commentLineNumbers.get(i + 1))) {
                continue;
              }
            }
            if (skipBlankLines) {
              if (line.match(/^\s*$/u)) {
                continue;
              }
            }
            lineCount++;
          }
          if (lineCount > maxLines) {
            const name = upperCaseFirst(astUtils.getFunctionNameWithKind(funcNode));
            context.report({
              node,
              messageId: "exceed",
              data: { name, lineCount, maxLines }
            });
          }
        }
        return {
          FunctionDeclaration: processFunction,
          FunctionExpression: processFunction,
          ArrowFunctionExpression: processFunction
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/max-nested-callbacks.js
var require_max_nested_callbacks = __commonJS({
  "../../node_modules/eslint/lib/rules/max-nested-callbacks.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Enforce a maximum depth that callbacks can be nested",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/max-nested-callbacks"
        },
        schema: [
          {
            oneOf: [
              {
                type: "integer",
                minimum: 0
              },
              {
                type: "object",
                properties: {
                  maximum: {
                    type: "integer",
                    minimum: 0
                  },
                  max: {
                    type: "integer",
                    minimum: 0
                  }
                },
                additionalProperties: false
              }
            ]
          }
        ],
        messages: {
          exceed: "Too many nested callbacks ({{num}}). Maximum allowed is {{max}}."
        }
      },
      create(context) {
        const option = context.options[0];
        let THRESHOLD = 10;
        if (typeof option === "object" && (Object.prototype.hasOwnProperty.call(option, "maximum") || Object.prototype.hasOwnProperty.call(option, "max"))) {
          THRESHOLD = option.maximum || option.max;
        } else if (typeof option === "number") {
          THRESHOLD = option;
        }
        const callbackStack = [];
        function checkFunction(node) {
          const parent = node.parent;
          if (parent.type === "CallExpression") {
            callbackStack.push(node);
          }
          if (callbackStack.length > THRESHOLD) {
            const opts = { num: callbackStack.length, max: THRESHOLD };
            context.report({ node, messageId: "exceed", data: opts });
          }
        }
        function popStack() {
          callbackStack.pop();
        }
        return {
          ArrowFunctionExpression: checkFunction,
          "ArrowFunctionExpression:exit": popStack,
          FunctionExpression: checkFunction,
          "FunctionExpression:exit": popStack
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/max-params.js
var require_max_params = __commonJS({
  "../../node_modules/eslint/lib/rules/max-params.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var { upperCaseFirst } = require_string_utils();
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Enforce a maximum number of parameters in function definitions",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/max-params"
        },
        schema: [
          {
            oneOf: [
              {
                type: "integer",
                minimum: 0
              },
              {
                type: "object",
                properties: {
                  maximum: {
                    type: "integer",
                    minimum: 0
                  },
                  max: {
                    type: "integer",
                    minimum: 0
                  }
                },
                additionalProperties: false
              }
            ]
          }
        ],
        messages: {
          exceed: "{{name}} has too many parameters ({{count}}). Maximum allowed is {{max}}."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        const option = context.options[0];
        let numParams = 3;
        if (typeof option === "object" && (Object.prototype.hasOwnProperty.call(option, "maximum") || Object.prototype.hasOwnProperty.call(option, "max"))) {
          numParams = option.maximum || option.max;
        }
        if (typeof option === "number") {
          numParams = option;
        }
        function checkFunction(node) {
          if (node.params.length > numParams) {
            context.report({
              loc: astUtils.getFunctionHeadLoc(node, sourceCode),
              node,
              messageId: "exceed",
              data: {
                name: upperCaseFirst(astUtils.getFunctionNameWithKind(node)),
                count: node.params.length,
                max: numParams
              }
            });
          }
        }
        return {
          FunctionDeclaration: checkFunction,
          ArrowFunctionExpression: checkFunction,
          FunctionExpression: checkFunction
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/max-statements.js
var require_max_statements = __commonJS({
  "../../node_modules/eslint/lib/rules/max-statements.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var { upperCaseFirst } = require_string_utils();
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Enforce a maximum number of statements allowed in function blocks",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/max-statements"
        },
        schema: [
          {
            oneOf: [
              {
                type: "integer",
                minimum: 0
              },
              {
                type: "object",
                properties: {
                  maximum: {
                    type: "integer",
                    minimum: 0
                  },
                  max: {
                    type: "integer",
                    minimum: 0
                  }
                },
                additionalProperties: false
              }
            ]
          },
          {
            type: "object",
            properties: {
              ignoreTopLevelFunctions: {
                type: "boolean"
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          exceed: "{{name}} has too many statements ({{count}}). Maximum allowed is {{max}}."
        }
      },
      create(context) {
        const functionStack = [], option = context.options[0], ignoreTopLevelFunctions = context.options[1] && context.options[1].ignoreTopLevelFunctions || false, topLevelFunctions = [];
        let maxStatements = 10;
        if (typeof option === "object" && (Object.prototype.hasOwnProperty.call(option, "maximum") || Object.prototype.hasOwnProperty.call(option, "max"))) {
          maxStatements = option.maximum || option.max;
        } else if (typeof option === "number") {
          maxStatements = option;
        }
        function reportIfTooManyStatements(node, count, max) {
          if (count > max) {
            const name = upperCaseFirst(astUtils.getFunctionNameWithKind(node));
            context.report({
              node,
              messageId: "exceed",
              data: { name, count, max }
            });
          }
        }
        function startFunction() {
          functionStack.push(0);
        }
        function endFunction(node) {
          const count = functionStack.pop();
          if (node.type === "StaticBlock") {
            return;
          }
          if (ignoreTopLevelFunctions && functionStack.length === 0) {
            topLevelFunctions.push({ node, count });
          } else {
            reportIfTooManyStatements(node, count, maxStatements);
          }
        }
        function countStatements(node) {
          functionStack[functionStack.length - 1] += node.body.length;
        }
        return {
          FunctionDeclaration: startFunction,
          FunctionExpression: startFunction,
          ArrowFunctionExpression: startFunction,
          StaticBlock: startFunction,
          BlockStatement: countStatements,
          "FunctionDeclaration:exit": endFunction,
          "FunctionExpression:exit": endFunction,
          "ArrowFunctionExpression:exit": endFunction,
          "StaticBlock:exit": endFunction,
          "Program:exit"() {
            if (topLevelFunctions.length === 1) {
              return;
            }
            topLevelFunctions.forEach((element) => {
              const count = element.count;
              const node = element.node;
              reportIfTooManyStatements(node, count, maxStatements);
            });
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/max-statements-per-line.js
var require_max_statements_per_line = __commonJS({
  "../../node_modules/eslint/lib/rules/max-statements-per-line.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Enforce a maximum number of statements allowed per line",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/max-statements-per-line"
        },
        schema: [
          {
            type: "object",
            properties: {
              max: {
                type: "integer",
                minimum: 1,
                default: 1
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          exceed: "This line has {{numberOfStatementsOnThisLine}} {{statements}}. Maximum allowed is {{maxStatementsPerLine}}."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode, options = context.options[0] || {}, maxStatementsPerLine = typeof options.max !== "undefined" ? options.max : 1;
        let lastStatementLine = 0, numberOfStatementsOnThisLine = 0, firstExtraStatement;
        const SINGLE_CHILD_ALLOWED = /^(?:(?:DoWhile|For|ForIn|ForOf|If|Labeled|While)Statement|Export(?:Default|Named)Declaration)$/u;
        function reportFirstExtraStatementAndClear() {
          if (firstExtraStatement) {
            context.report({
              node: firstExtraStatement,
              messageId: "exceed",
              data: {
                numberOfStatementsOnThisLine,
                maxStatementsPerLine,
                statements: numberOfStatementsOnThisLine === 1 ? "statement" : "statements"
              }
            });
          }
          firstExtraStatement = null;
        }
        function getActualLastToken(node) {
          return sourceCode.getLastToken(node, astUtils.isNotSemicolonToken);
        }
        function enterStatement(node) {
          const line = node.loc.start.line;
          if (SINGLE_CHILD_ALLOWED.test(node.parent.type) && node.parent.alternate !== node) {
            return;
          }
          if (line === lastStatementLine) {
            numberOfStatementsOnThisLine += 1;
          } else {
            reportFirstExtraStatementAndClear();
            numberOfStatementsOnThisLine = 1;
            lastStatementLine = line;
          }
          if (numberOfStatementsOnThisLine === maxStatementsPerLine + 1) {
            firstExtraStatement = firstExtraStatement || node;
          }
        }
        function leaveStatement(node) {
          const line = getActualLastToken(node).loc.end.line;
          if (line !== lastStatementLine) {
            reportFirstExtraStatementAndClear();
            numberOfStatementsOnThisLine = 1;
            lastStatementLine = line;
          }
        }
        return {
          BreakStatement: enterStatement,
          ClassDeclaration: enterStatement,
          ContinueStatement: enterStatement,
          DebuggerStatement: enterStatement,
          DoWhileStatement: enterStatement,
          ExpressionStatement: enterStatement,
          ForInStatement: enterStatement,
          ForOfStatement: enterStatement,
          ForStatement: enterStatement,
          FunctionDeclaration: enterStatement,
          IfStatement: enterStatement,
          ImportDeclaration: enterStatement,
          LabeledStatement: enterStatement,
          ReturnStatement: enterStatement,
          SwitchStatement: enterStatement,
          ThrowStatement: enterStatement,
          TryStatement: enterStatement,
          VariableDeclaration: enterStatement,
          WhileStatement: enterStatement,
          WithStatement: enterStatement,
          ExportNamedDeclaration: enterStatement,
          ExportDefaultDeclaration: enterStatement,
          ExportAllDeclaration: enterStatement,
          "BreakStatement:exit": leaveStatement,
          "ClassDeclaration:exit": leaveStatement,
          "ContinueStatement:exit": leaveStatement,
          "DebuggerStatement:exit": leaveStatement,
          "DoWhileStatement:exit": leaveStatement,
          "ExpressionStatement:exit": leaveStatement,
          "ForInStatement:exit": leaveStatement,
          "ForOfStatement:exit": leaveStatement,
          "ForStatement:exit": leaveStatement,
          "FunctionDeclaration:exit": leaveStatement,
          "IfStatement:exit": leaveStatement,
          "ImportDeclaration:exit": leaveStatement,
          "LabeledStatement:exit": leaveStatement,
          "ReturnStatement:exit": leaveStatement,
          "SwitchStatement:exit": leaveStatement,
          "ThrowStatement:exit": leaveStatement,
          "TryStatement:exit": leaveStatement,
          "VariableDeclaration:exit": leaveStatement,
          "WhileStatement:exit": leaveStatement,
          "WithStatement:exit": leaveStatement,
          "ExportNamedDeclaration:exit": leaveStatement,
          "ExportDefaultDeclaration:exit": leaveStatement,
          "ExportAllDeclaration:exit": leaveStatement,
          "Program:exit": reportFirstExtraStatementAndClear
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/multiline-comment-style.js
var require_multiline_comment_style = __commonJS({
  "../../node_modules/eslint/lib/rules/multiline-comment-style.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Enforce a particular style for multiline comments",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/multiline-comment-style"
        },
        fixable: "whitespace",
        schema: {
          anyOf: [
            {
              type: "array",
              items: [
                {
                  enum: ["starred-block", "bare-block"]
                }
              ],
              additionalItems: false
            },
            {
              type: "array",
              items: [
                {
                  enum: ["separate-lines"]
                },
                {
                  type: "object",
                  properties: {
                    checkJSDoc: {
                      type: "boolean"
                    }
                  },
                  additionalProperties: false
                }
              ],
              additionalItems: false
            }
          ]
        },
        messages: {
          expectedBlock: "Expected a block comment instead of consecutive line comments.",
          expectedBareBlock: "Expected a block comment without padding stars.",
          startNewline: "Expected a linebreak after '/*'.",
          endNewline: "Expected a linebreak before '*/'.",
          missingStar: "Expected a '*' at the start of this line.",
          alignment: "Expected this line to be aligned with the start of the comment.",
          expectedLines: "Expected multiple line comments instead of a block comment."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        const option = context.options[0] || "starred-block";
        const params = context.options[1] || {};
        const checkJSDoc = !!params.checkJSDoc;
        function isStarredCommentLine(line) {
          return /^\s*\*/u.test(line);
        }
        function isStarredBlockComment([firstComment]) {
          if (firstComment.type !== "Block") {
            return false;
          }
          const lines = firstComment.value.split(astUtils.LINEBREAK_MATCHER);
          return lines.length > 0 && lines.every((line, i) => (i === 0 || i === lines.length - 1 ? /^\s*$/u : /^\s*\*/u).test(line));
        }
        function isJSDocComment([firstComment]) {
          if (firstComment.type !== "Block") {
            return false;
          }
          const lines = firstComment.value.split(astUtils.LINEBREAK_MATCHER);
          return /^\*\s*$/u.test(lines[0]) && lines.slice(1, -1).every((line) => /^\s* /u.test(line)) && /^\s*$/u.test(lines[lines.length - 1]);
        }
        function processSeparateLineComments(commentGroup) {
          const allLinesHaveLeadingSpace = commentGroup.map(({ value }) => value).filter((line) => line.trim().length).every((line) => line.startsWith(" "));
          return commentGroup.map(({ value }) => allLinesHaveLeadingSpace ? value.replace(/^ /u, "") : value);
        }
        function processStarredBlockComment(comment) {
          const lines = comment.value.split(astUtils.LINEBREAK_MATCHER).filter((line, i, linesArr) => !(i === 0 || i === linesArr.length - 1)).map((line) => line.replace(/^\s*$/u, ""));
          const allLinesHaveLeadingSpace = lines.map((line) => line.replace(/\s*\*/u, "")).filter((line) => line.trim().length).every((line) => line.startsWith(" "));
          return lines.map((line) => line.replace(allLinesHaveLeadingSpace ? /\s*\* ?/u : /\s*\*/u, ""));
        }
        function processBareBlockComment(comment) {
          const lines = comment.value.split(astUtils.LINEBREAK_MATCHER).map((line) => line.replace(/^\s*$/u, ""));
          const leadingWhitespace = `${sourceCode.text.slice(comment.range[0] - comment.loc.start.column, comment.range[0])}   `;
          let offset = "";
          for (const [i, line] of lines.entries()) {
            if (!line.trim().length || i === 0) {
              continue;
            }
            const [, lineOffset] = line.match(/^(\s*\*?\s*)/u);
            if (lineOffset.length < leadingWhitespace.length) {
              const newOffset = leadingWhitespace.slice(lineOffset.length - leadingWhitespace.length);
              if (newOffset.length > offset.length) {
                offset = newOffset;
              }
            }
          }
          return lines.map((line) => {
            const match = line.match(/^(\s*\*?\s*)(.*)/u);
            const [, lineOffset, lineContents] = match;
            if (lineOffset.length > leadingWhitespace.length) {
              return `${lineOffset.slice(leadingWhitespace.length - (offset.length + lineOffset.length))}${lineContents}`;
            }
            if (lineOffset.length < leadingWhitespace.length) {
              return `${lineOffset.slice(leadingWhitespace.length)}${lineContents}`;
            }
            return lineContents;
          });
        }
        function getCommentLines(commentGroup) {
          const [firstComment] = commentGroup;
          if (firstComment.type === "Line") {
            return processSeparateLineComments(commentGroup);
          }
          if (isStarredBlockComment(commentGroup)) {
            return processStarredBlockComment(firstComment);
          }
          return processBareBlockComment(firstComment);
        }
        function getInitialOffset(comment) {
          return sourceCode.text.slice(comment.range[0] - comment.loc.start.column, comment.range[0]);
        }
        function convertToStarredBlock(firstComment, commentLinesList) {
          const initialOffset = getInitialOffset(firstComment);
          return `/*
${commentLinesList.map((line) => `${initialOffset} * ${line}`).join("\n")}
${initialOffset} */`;
        }
        function convertToSeparateLines(firstComment, commentLinesList) {
          return commentLinesList.map((line) => `// ${line}`).join(`
${getInitialOffset(firstComment)}`);
        }
        function convertToBlock(firstComment, commentLinesList) {
          return `/* ${commentLinesList.join(`
${getInitialOffset(firstComment)}   `)} */`;
        }
        const commentGroupCheckers = {
          "starred-block"(commentGroup) {
            const [firstComment] = commentGroup;
            const commentLines = getCommentLines(commentGroup);
            if (commentLines.some((value) => value.includes("*/"))) {
              return;
            }
            if (commentGroup.length > 1) {
              context.report({
                loc: {
                  start: firstComment.loc.start,
                  end: commentGroup[commentGroup.length - 1].loc.end
                },
                messageId: "expectedBlock",
                fix(fixer) {
                  const range = [firstComment.range[0], commentGroup[commentGroup.length - 1].range[1]];
                  return commentLines.some((value) => value.startsWith("/")) ? null : fixer.replaceTextRange(range, convertToStarredBlock(firstComment, commentLines));
                }
              });
            } else {
              const lines = firstComment.value.split(astUtils.LINEBREAK_MATCHER);
              const expectedLeadingWhitespace = getInitialOffset(firstComment);
              const expectedLinePrefix = `${expectedLeadingWhitespace} *`;
              if (!/^\*?\s*$/u.test(lines[0])) {
                const start = firstComment.value.startsWith("*") ? firstComment.range[0] + 1 : firstComment.range[0];
                context.report({
                  loc: {
                    start: firstComment.loc.start,
                    end: { line: firstComment.loc.start.line, column: firstComment.loc.start.column + 2 }
                  },
                  messageId: "startNewline",
                  fix: (fixer) => fixer.insertTextAfterRange([start, start + 2], `
${expectedLinePrefix}`)
                });
              }
              if (!/^\s*$/u.test(lines[lines.length - 1])) {
                context.report({
                  loc: {
                    start: { line: firstComment.loc.end.line, column: firstComment.loc.end.column - 2 },
                    end: firstComment.loc.end
                  },
                  messageId: "endNewline",
                  fix: (fixer) => fixer.replaceTextRange([firstComment.range[1] - 2, firstComment.range[1]], `
${expectedLinePrefix}/`)
                });
              }
              for (let lineNumber = firstComment.loc.start.line + 1; lineNumber <= firstComment.loc.end.line; lineNumber++) {
                const lineText = sourceCode.lines[lineNumber - 1];
                const errorType = isStarredCommentLine(lineText) ? "alignment" : "missingStar";
                if (!lineText.startsWith(expectedLinePrefix)) {
                  context.report({
                    loc: {
                      start: { line: lineNumber, column: 0 },
                      end: { line: lineNumber, column: lineText.length }
                    },
                    messageId: errorType,
                    fix(fixer) {
                      const lineStartIndex = sourceCode.getIndexFromLoc({ line: lineNumber, column: 0 });
                      if (errorType === "alignment") {
                        const [, commentTextPrefix2 = ""] = lineText.match(/^(\s*\*)/u) || [];
                        const commentTextStartIndex2 = lineStartIndex + commentTextPrefix2.length;
                        return fixer.replaceTextRange([lineStartIndex, commentTextStartIndex2], expectedLinePrefix);
                      }
                      const [, commentTextPrefix = ""] = lineText.match(/^(\s*)/u) || [];
                      const commentTextStartIndex = lineStartIndex + commentTextPrefix.length;
                      let offset;
                      for (const [idx, line] of lines.entries()) {
                        if (!/\S+/u.test(line)) {
                          continue;
                        }
                        const lineTextToAlignWith = sourceCode.lines[firstComment.loc.start.line - 1 + idx];
                        const [, prefix = "", initialOffset = ""] = lineTextToAlignWith.match(/^(\s*(?:\/?\*)?(\s*))/u) || [];
                        offset = `${commentTextPrefix.slice(prefix.length)}${initialOffset}`;
                        if (/^\s*\//u.test(lineText) && offset.length === 0) {
                          offset += " ";
                        }
                        break;
                      }
                      return fixer.replaceTextRange([lineStartIndex, commentTextStartIndex], `${expectedLinePrefix}${offset}`);
                    }
                  });
                }
              }
            }
          },
          "separate-lines"(commentGroup) {
            const [firstComment] = commentGroup;
            const isJSDoc = isJSDocComment(commentGroup);
            if (firstComment.type !== "Block" || !checkJSDoc && isJSDoc) {
              return;
            }
            let commentLines = getCommentLines(commentGroup);
            if (isJSDoc) {
              commentLines = commentLines.slice(1, commentLines.length - 1);
            }
            const tokenAfter = sourceCode.getTokenAfter(firstComment, { includeComments: true });
            if (tokenAfter && firstComment.loc.end.line === tokenAfter.loc.start.line) {
              return;
            }
            context.report({
              loc: {
                start: firstComment.loc.start,
                end: { line: firstComment.loc.start.line, column: firstComment.loc.start.column + 2 }
              },
              messageId: "expectedLines",
              fix(fixer) {
                return fixer.replaceText(firstComment, convertToSeparateLines(firstComment, commentLines));
              }
            });
          },
          "bare-block"(commentGroup) {
            if (isJSDocComment(commentGroup)) {
              return;
            }
            const [firstComment] = commentGroup;
            const commentLines = getCommentLines(commentGroup);
            if (firstComment.type === "Line" && commentLines.length > 1 && !commentLines.some((value) => value.includes("*/"))) {
              context.report({
                loc: {
                  start: firstComment.loc.start,
                  end: commentGroup[commentGroup.length - 1].loc.end
                },
                messageId: "expectedBlock",
                fix(fixer) {
                  return fixer.replaceTextRange(
                    [firstComment.range[0], commentGroup[commentGroup.length - 1].range[1]],
                    convertToBlock(firstComment, commentLines)
                  );
                }
              });
            }
            if (isStarredBlockComment(commentGroup)) {
              context.report({
                loc: {
                  start: firstComment.loc.start,
                  end: { line: firstComment.loc.start.line, column: firstComment.loc.start.column + 2 }
                },
                messageId: "expectedBareBlock",
                fix(fixer) {
                  return fixer.replaceText(firstComment, convertToBlock(firstComment, commentLines));
                }
              });
            }
          }
        };
        return {
          Program() {
            return sourceCode.getAllComments().filter((comment) => comment.type !== "Shebang").filter((comment) => !astUtils.COMMENTS_IGNORE_PATTERN.test(comment.value)).filter((comment) => {
              const tokenBefore = sourceCode.getTokenBefore(comment, { includeComments: true });
              return !tokenBefore || tokenBefore.loc.end.line < comment.loc.start.line;
            }).reduce((commentGroups, comment, index, commentList) => {
              const tokenBefore = sourceCode.getTokenBefore(comment, { includeComments: true });
              if (comment.type === "Line" && index && commentList[index - 1].type === "Line" && tokenBefore && tokenBefore.loc.end.line === comment.loc.start.line - 1 && tokenBefore === commentList[index - 1]) {
                commentGroups[commentGroups.length - 1].push(comment);
              } else {
                commentGroups.push([comment]);
              }
              return commentGroups;
            }, []).filter((commentGroup) => !(commentGroup.length === 1 && commentGroup[0].loc.start.line === commentGroup[0].loc.end.line)).forEach(commentGroupCheckers[option]);
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/multiline-ternary.js
var require_multiline_ternary = __commonJS({
  "../../node_modules/eslint/lib/rules/multiline-ternary.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Enforce newlines between operands of ternary expressions",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/multiline-ternary"
        },
        schema: [
          {
            enum: ["always", "always-multiline", "never"]
          }
        ],
        messages: {
          expectedTestCons: "Expected newline between test and consequent of ternary expression.",
          expectedConsAlt: "Expected newline between consequent and alternate of ternary expression.",
          unexpectedTestCons: "Unexpected newline between test and consequent of ternary expression.",
          unexpectedConsAlt: "Unexpected newline between consequent and alternate of ternary expression."
        },
        fixable: "whitespace"
      },
      create(context) {
        const sourceCode = context.sourceCode;
        const option = context.options[0];
        const multiline = option !== "never";
        const allowSingleLine = option === "always-multiline";
        return {
          ConditionalExpression(node) {
            const questionToken = sourceCode.getTokenAfter(node.test, astUtils.isNotClosingParenToken);
            const colonToken = sourceCode.getTokenAfter(node.consequent, astUtils.isNotClosingParenToken);
            const firstTokenOfTest = sourceCode.getFirstToken(node);
            const lastTokenOfTest = sourceCode.getTokenBefore(questionToken);
            const firstTokenOfConsequent = sourceCode.getTokenAfter(questionToken);
            const lastTokenOfConsequent = sourceCode.getTokenBefore(colonToken);
            const firstTokenOfAlternate = sourceCode.getTokenAfter(colonToken);
            const areTestAndConsequentOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfTest, firstTokenOfConsequent);
            const areConsequentAndAlternateOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfConsequent, firstTokenOfAlternate);
            const hasComments = !!sourceCode.getCommentsInside(node).length;
            if (!multiline) {
              if (!areTestAndConsequentOnSameLine) {
                context.report({
                  node: node.test,
                  loc: {
                    start: firstTokenOfTest.loc.start,
                    end: lastTokenOfTest.loc.end
                  },
                  messageId: "unexpectedTestCons",
                  fix(fixer) {
                    if (hasComments) {
                      return null;
                    }
                    const fixers = [];
                    const areTestAndQuestionOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfTest, questionToken);
                    const areQuestionAndConsOnSameLine = astUtils.isTokenOnSameLine(questionToken, firstTokenOfConsequent);
                    if (!areTestAndQuestionOnSameLine) {
                      fixers.push(fixer.removeRange([lastTokenOfTest.range[1], questionToken.range[0]]));
                    }
                    if (!areQuestionAndConsOnSameLine) {
                      fixers.push(fixer.removeRange([questionToken.range[1], firstTokenOfConsequent.range[0]]));
                    }
                    return fixers;
                  }
                });
              }
              if (!areConsequentAndAlternateOnSameLine) {
                context.report({
                  node: node.consequent,
                  loc: {
                    start: firstTokenOfConsequent.loc.start,
                    end: lastTokenOfConsequent.loc.end
                  },
                  messageId: "unexpectedConsAlt",
                  fix(fixer) {
                    if (hasComments) {
                      return null;
                    }
                    const fixers = [];
                    const areConsAndColonOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfConsequent, colonToken);
                    const areColonAndAltOnSameLine = astUtils.isTokenOnSameLine(colonToken, firstTokenOfAlternate);
                    if (!areConsAndColonOnSameLine) {
                      fixers.push(fixer.removeRange([lastTokenOfConsequent.range[1], colonToken.range[0]]));
                    }
                    if (!areColonAndAltOnSameLine) {
                      fixers.push(fixer.removeRange([colonToken.range[1], firstTokenOfAlternate.range[0]]));
                    }
                    return fixers;
                  }
                });
              }
            } else {
              if (allowSingleLine && node.loc.start.line === node.loc.end.line) {
                return;
              }
              if (areTestAndConsequentOnSameLine) {
                context.report({
                  node: node.test,
                  loc: {
                    start: firstTokenOfTest.loc.start,
                    end: lastTokenOfTest.loc.end
                  },
                  messageId: "expectedTestCons",
                  fix: (fixer) => hasComments ? null : fixer.replaceTextRange(
                    [
                      lastTokenOfTest.range[1],
                      questionToken.range[0]
                    ],
                    "\n"
                  )
                });
              }
              if (areConsequentAndAlternateOnSameLine) {
                context.report({
                  node: node.consequent,
                  loc: {
                    start: firstTokenOfConsequent.loc.start,
                    end: lastTokenOfConsequent.loc.end
                  },
                  messageId: "expectedConsAlt",
                  fix: (fixer) => hasComments ? null : fixer.replaceTextRange(
                    [
                      lastTokenOfConsequent.range[1],
                      colonToken.range[0]
                    ],
                    "\n"
                  )
                });
              }
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/new-cap.js
var require_new_cap = __commonJS({
  "../../node_modules/eslint/lib/rules/new-cap.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var CAPS_ALLOWED = [
      "Array",
      "Boolean",
      "Date",
      "Error",
      "Function",
      "Number",
      "Object",
      "RegExp",
      "String",
      "Symbol",
      "BigInt"
    ];
    function checkArray(obj, key, fallback) {
      if (Object.prototype.hasOwnProperty.call(obj, key) && !Array.isArray(obj[key])) {
        throw new TypeError(`${key}, if provided, must be an Array`);
      }
      return obj[key] || fallback;
    }
    function invert(map, key) {
      map[key] = true;
      return map;
    }
    function calculateCapIsNewExceptions(config) {
      let capIsNewExceptions = checkArray(config, "capIsNewExceptions", CAPS_ALLOWED);
      if (capIsNewExceptions !== CAPS_ALLOWED) {
        capIsNewExceptions = capIsNewExceptions.concat(CAPS_ALLOWED);
      }
      return capIsNewExceptions.reduce(invert, {});
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Require constructor names to begin with a capital letter",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/new-cap"
        },
        schema: [
          {
            type: "object",
            properties: {
              newIsCap: {
                type: "boolean",
                default: true
              },
              capIsNew: {
                type: "boolean",
                default: true
              },
              newIsCapExceptions: {
                type: "array",
                items: {
                  type: "string"
                }
              },
              newIsCapExceptionPattern: {
                type: "string"
              },
              capIsNewExceptions: {
                type: "array",
                items: {
                  type: "string"
                }
              },
              capIsNewExceptionPattern: {
                type: "string"
              },
              properties: {
                type: "boolean",
                default: true
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          upper: "A function with a name starting with an uppercase letter should only be used as a constructor.",
          lower: "A constructor name should not start with a lowercase letter."
        }
      },
      create(context) {
        const config = Object.assign({}, context.options[0]);
        config.newIsCap = config.newIsCap !== false;
        config.capIsNew = config.capIsNew !== false;
        const skipProperties = config.properties === false;
        const newIsCapExceptions = checkArray(config, "newIsCapExceptions", []).reduce(invert, {});
        const newIsCapExceptionPattern = config.newIsCapExceptionPattern ? new RegExp(config.newIsCapExceptionPattern, "u") : null;
        const capIsNewExceptions = calculateCapIsNewExceptions(config);
        const capIsNewExceptionPattern = config.capIsNewExceptionPattern ? new RegExp(config.capIsNewExceptionPattern, "u") : null;
        const listeners = {};
        const sourceCode = context.sourceCode;
        function extractNameFromExpression(node) {
          return node.callee.type === "Identifier" ? node.callee.name : astUtils.getStaticPropertyName(node.callee) || "";
        }
        function getCap(str) {
          const firstChar = str.charAt(0);
          const firstCharLower = firstChar.toLowerCase();
          const firstCharUpper = firstChar.toUpperCase();
          if (firstCharLower === firstCharUpper) {
            return "non-alpha";
          }
          if (firstChar === firstCharLower) {
            return "lower";
          }
          return "upper";
        }
        function isCapAllowed(allowedMap, node, calleeName, pattern) {
          const sourceText = sourceCode.getText(node.callee);
          if (allowedMap[calleeName] || allowedMap[sourceText]) {
            return true;
          }
          if (pattern && pattern.test(sourceText)) {
            return true;
          }
          const callee = astUtils.skipChainExpression(node.callee);
          if (calleeName === "UTC" && callee.type === "MemberExpression") {
            return callee.object.type === "Identifier" && callee.object.name === "Date";
          }
          return skipProperties && callee.type === "MemberExpression";
        }
        function report(node, messageId) {
          let callee = astUtils.skipChainExpression(node.callee);
          if (callee.type === "MemberExpression") {
            callee = callee.property;
          }
          context.report({ node, loc: callee.loc, messageId });
        }
        if (config.newIsCap) {
          listeners.NewExpression = function(node) {
            const constructorName = extractNameFromExpression(node);
            if (constructorName) {
              const capitalization = getCap(constructorName);
              const isAllowed = capitalization !== "lower" || isCapAllowed(newIsCapExceptions, node, constructorName, newIsCapExceptionPattern);
              if (!isAllowed) {
                report(node, "lower");
              }
            }
          };
        }
        if (config.capIsNew) {
          listeners.CallExpression = function(node) {
            const calleeName = extractNameFromExpression(node);
            if (calleeName) {
              const capitalization = getCap(calleeName);
              const isAllowed = capitalization !== "upper" || isCapAllowed(capIsNewExceptions, node, calleeName, capIsNewExceptionPattern);
              if (!isAllowed) {
                report(node, "upper");
              }
            }
          };
        }
        return listeners;
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/new-parens.js
var require_new_parens = __commonJS({
  "../../node_modules/eslint/lib/rules/new-parens.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Enforce or disallow parentheses when invoking a constructor with no arguments",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/new-parens"
        },
        fixable: "code",
        schema: [
          {
            enum: ["always", "never"]
          }
        ],
        messages: {
          missing: "Missing '()' invoking a constructor.",
          unnecessary: "Unnecessary '()' invoking a constructor with no arguments."
        }
      },
      create(context) {
        const options = context.options;
        const always = options[0] !== "never";
        const sourceCode = context.sourceCode;
        return {
          NewExpression(node) {
            if (node.arguments.length !== 0) {
              return;
            }
            const lastToken = sourceCode.getLastToken(node);
            const hasLastParen = lastToken && astUtils.isClosingParenToken(lastToken);
            const hasParens = hasLastParen && astUtils.isOpeningParenToken(sourceCode.getTokenBefore(lastToken)) && node.callee.range[1] < node.range[1];
            if (always) {
              if (!hasParens) {
                context.report({
                  node,
                  messageId: "missing",
                  fix: (fixer) => fixer.insertTextAfter(node, "()")
                });
              }
            } else {
              if (hasParens) {
                context.report({
                  node,
                  messageId: "unnecessary",
                  fix: (fixer) => [
                    fixer.remove(sourceCode.getTokenBefore(lastToken)),
                    fixer.remove(lastToken),
                    fixer.insertTextBefore(node, "("),
                    fixer.insertTextAfter(node, ")")
                  ]
                });
              }
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/newline-after-var.js
var require_newline_after_var = __commonJS({
  "../../node_modules/eslint/lib/rules/newline-after-var.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Require or disallow an empty line after variable declarations",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/newline-after-var"
        },
        schema: [
          {
            enum: ["never", "always"]
          }
        ],
        fixable: "whitespace",
        messages: {
          expected: "Expected blank line after variable declarations.",
          unexpected: "Unexpected blank line after variable declarations."
        },
        deprecated: true,
        replacedBy: ["padding-line-between-statements"]
      },
      create(context) {
        const sourceCode = context.sourceCode;
        const mode = context.options[0] === "never" ? "never" : "always";
        const commentEndLine = sourceCode.getAllComments().reduce((result, token) => {
          result[token.loc.start.line] = token.loc.end.line;
          return result;
        }, {});
        function getLastToken(node) {
          const lastToken = sourceCode.getLastToken(node);
          if (lastToken.type === "Punctuator" && lastToken.value === ";") {
            const prevToken = sourceCode.getTokenBefore(lastToken);
            if (prevToken.loc.end.line !== lastToken.loc.start.line) {
              return prevToken;
            }
          }
          return lastToken;
        }
        function isVar(keyword) {
          return keyword === "var" || keyword === "let" || keyword === "const";
        }
        function isForTypeSpecifier(keyword) {
          return keyword === "ForStatement" || keyword === "ForInStatement" || keyword === "ForOfStatement";
        }
        function isExportSpecifier(nodeType) {
          return nodeType === "ExportNamedDeclaration" || nodeType === "ExportSpecifier" || nodeType === "ExportDefaultDeclaration" || nodeType === "ExportAllDeclaration";
        }
        function isLastNode(node) {
          const token = sourceCode.getTokenAfter(node);
          return !token || token.type === "Punctuator" && token.value === "}";
        }
        function getLastCommentLineOfBlock(commentStartLine) {
          const currentCommentEnd = commentEndLine[commentStartLine];
          return commentEndLine[currentCommentEnd + 1] ? getLastCommentLineOfBlock(currentCommentEnd + 1) : currentCommentEnd;
        }
        function hasBlankLineAfterComment(token, commentStartLine) {
          return token.loc.start.line > getLastCommentLineOfBlock(commentStartLine) + 1;
        }
        function checkForBlankLine(node) {
          const lastToken = getLastToken(node), nextToken = lastToken === sourceCode.getLastToken(node) ? sourceCode.getTokenAfter(node) : sourceCode.getLastToken(node), nextLineNum = lastToken.loc.end.line + 1;
          if (!nextToken) {
            return;
          }
          if (isForTypeSpecifier(node.parent.type)) {
            return;
          }
          if (isExportSpecifier(node.parent.type)) {
            return;
          }
          if (nextToken.type === "Keyword" && isVar(nextToken.value)) {
            return;
          }
          if (isLastNode(node)) {
            return;
          }
          const noNextLineToken = nextToken.loc.start.line > nextLineNum;
          const hasNextLineComment = typeof commentEndLine[nextLineNum] !== "undefined";
          if (mode === "never" && noNextLineToken && !hasNextLineComment) {
            context.report({
              node,
              messageId: "unexpected",
              fix(fixer) {
                const linesBetween = sourceCode.getText().slice(lastToken.range[1], nextToken.range[0]).split(astUtils.LINEBREAK_MATCHER);
                return fixer.replaceTextRange([lastToken.range[1], nextToken.range[0]], `${linesBetween.slice(0, -1).join("")}
${linesBetween[linesBetween.length - 1]}`);
              }
            });
          }
          if (mode === "always" && (!noNextLineToken || hasNextLineComment && !hasBlankLineAfterComment(nextToken, nextLineNum))) {
            context.report({
              node,
              messageId: "expected",
              fix(fixer) {
                if ((noNextLineToken ? getLastCommentLineOfBlock(nextLineNum) : lastToken.loc.end.line) === nextToken.loc.start.line) {
                  return fixer.insertTextBefore(nextToken, "\n\n");
                }
                return fixer.insertTextBeforeRange([nextToken.range[0] - nextToken.loc.start.column, nextToken.range[1]], "\n");
              }
            });
          }
        }
        return {
          VariableDeclaration: checkForBlankLine
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/newline-before-return.js
var require_newline_before_return = __commonJS({
  "../../node_modules/eslint/lib/rules/newline-before-return.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Require an empty line before `return` statements",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/newline-before-return"
        },
        fixable: "whitespace",
        schema: [],
        messages: {
          expected: "Expected newline before return statement."
        },
        deprecated: true,
        replacedBy: ["padding-line-between-statements"]
      },
      create(context) {
        const sourceCode = context.sourceCode;
        function isPrecededByTokens(node, testTokens) {
          const tokenBefore = sourceCode.getTokenBefore(node);
          return testTokens.includes(tokenBefore.value);
        }
        function isFirstNode(node) {
          const parentType = node.parent.type;
          if (node.parent.body) {
            return Array.isArray(node.parent.body) ? node.parent.body[0] === node : node.parent.body === node;
          }
          if (parentType === "IfStatement") {
            return isPrecededByTokens(node, ["else", ")"]);
          }
          if (parentType === "DoWhileStatement") {
            return isPrecededByTokens(node, ["do"]);
          }
          if (parentType === "SwitchCase") {
            return isPrecededByTokens(node, [":"]);
          }
          return isPrecededByTokens(node, [")"]);
        }
        function calcCommentLines(node, lineNumTokenBefore) {
          const comments = sourceCode.getCommentsBefore(node);
          let numLinesComments = 0;
          if (!comments.length) {
            return numLinesComments;
          }
          comments.forEach((comment) => {
            numLinesComments++;
            if (comment.type === "Block") {
              numLinesComments += comment.loc.end.line - comment.loc.start.line;
            }
            if (comment.loc.start.line === lineNumTokenBefore) {
              numLinesComments--;
            }
            if (comment.loc.end.line === node.loc.start.line) {
              numLinesComments--;
            }
          });
          return numLinesComments;
        }
        function getLineNumberOfTokenBefore(node) {
          const tokenBefore = sourceCode.getTokenBefore(node);
          let lineNumTokenBefore;
          if (tokenBefore) {
            lineNumTokenBefore = tokenBefore.loc.end.line;
          } else {
            lineNumTokenBefore = 0;
          }
          return lineNumTokenBefore;
        }
        function hasNewlineBefore(node) {
          const lineNumNode = node.loc.start.line;
          const lineNumTokenBefore = getLineNumberOfTokenBefore(node);
          const commentLines = calcCommentLines(node, lineNumTokenBefore);
          return lineNumNode - lineNumTokenBefore - commentLines > 1;
        }
        function canFix(node) {
          const leadingComments = sourceCode.getCommentsBefore(node);
          const lastLeadingComment = leadingComments[leadingComments.length - 1];
          const tokenBefore = sourceCode.getTokenBefore(node);
          if (leadingComments.length === 0) {
            return true;
          }
          if (lastLeadingComment.loc.end.line === tokenBefore.loc.end.line && lastLeadingComment.loc.end.line !== node.loc.start.line) {
            return true;
          }
          return false;
        }
        return {
          ReturnStatement(node) {
            if (!isFirstNode(node) && !hasNewlineBefore(node)) {
              context.report({
                node,
                messageId: "expected",
                fix(fixer) {
                  if (canFix(node)) {
                    const tokenBefore = sourceCode.getTokenBefore(node);
                    const newlines = node.loc.start.line === tokenBefore.loc.end.line ? "\n\n" : "\n";
                    return fixer.insertTextBefore(node, newlines);
                  }
                  return null;
                }
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/newline-per-chained-call.js
var require_newline_per_chained_call = __commonJS({
  "../../node_modules/eslint/lib/rules/newline-per-chained-call.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Require a newline after each call in a method chain",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/newline-per-chained-call"
        },
        fixable: "whitespace",
        schema: [{
          type: "object",
          properties: {
            ignoreChainWithDepth: {
              type: "integer",
              minimum: 1,
              maximum: 10,
              default: 2
            }
          },
          additionalProperties: false
        }],
        messages: {
          expected: "Expected line break before `{{callee}}`."
        }
      },
      create(context) {
        const options = context.options[0] || {}, ignoreChainWithDepth = options.ignoreChainWithDepth || 2;
        const sourceCode = context.sourceCode;
        function getPrefix(node) {
          if (node.computed) {
            if (node.optional) {
              return "?.[";
            }
            return "[";
          }
          if (node.optional) {
            return "?.";
          }
          return ".";
        }
        function getPropertyText(node) {
          const prefix = getPrefix(node);
          const lines = sourceCode.getText(node.property).split(astUtils.LINEBREAK_MATCHER);
          const suffix = node.computed && lines.length === 1 ? "]" : "";
          return prefix + lines[0] + suffix;
        }
        return {
          "CallExpression:exit"(node) {
            const callee = astUtils.skipChainExpression(node.callee);
            if (callee.type !== "MemberExpression") {
              return;
            }
            let parent = astUtils.skipChainExpression(callee.object);
            let depth = 1;
            while (parent && parent.callee) {
              depth += 1;
              parent = astUtils.skipChainExpression(astUtils.skipChainExpression(parent.callee).object);
            }
            if (depth > ignoreChainWithDepth && astUtils.isTokenOnSameLine(callee.object, callee.property)) {
              const firstTokenAfterObject = sourceCode.getTokenAfter(callee.object, astUtils.isNotClosingParenToken);
              context.report({
                node: callee.property,
                loc: {
                  start: firstTokenAfterObject.loc.start,
                  end: callee.loc.end
                },
                messageId: "expected",
                data: {
                  callee: getPropertyText(callee)
                },
                fix(fixer) {
                  return fixer.insertTextBefore(firstTokenAfterObject, "\n");
                }
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-alert.js
var require_no_alert = __commonJS({
  "../../node_modules/eslint/lib/rules/no-alert.js"(exports, module) {
    "use strict";
    var {
      getStaticPropertyName: getPropertyName,
      getVariableByName,
      skipChainExpression
    } = require_ast_utils2();
    function isProhibitedIdentifier(name) {
      return /^(alert|confirm|prompt)$/u.test(name);
    }
    function findReference(scope, node) {
      const references = scope.references.filter((reference) => reference.identifier.range[0] === node.range[0] && reference.identifier.range[1] === node.range[1]);
      if (references.length === 1) {
        return references[0];
      }
      return null;
    }
    function isShadowed(scope, node) {
      const reference = findReference(scope, node);
      return reference && reference.resolved && reference.resolved.defs.length > 0;
    }
    function isGlobalThisReferenceOrGlobalWindow(scope, node) {
      if (scope.type === "global" && node.type === "ThisExpression") {
        return true;
      }
      if (node.type === "Identifier" && (node.name === "window" || node.name === "globalThis" && getVariableByName(scope, "globalThis"))) {
        return !isShadowed(scope, node);
      }
      return false;
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow the use of `alert`, `confirm`, and `prompt`",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-alert"
        },
        schema: [],
        messages: {
          unexpected: "Unexpected {{name}}."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        return {
          CallExpression(node) {
            const callee = skipChainExpression(node.callee), currentScope = sourceCode.getScope(node);
            if (callee.type === "Identifier") {
              const name = callee.name;
              if (!isShadowed(currentScope, callee) && isProhibitedIdentifier(callee.name)) {
                context.report({
                  node,
                  messageId: "unexpected",
                  data: { name }
                });
              }
            } else if (callee.type === "MemberExpression" && isGlobalThisReferenceOrGlobalWindow(currentScope, callee.object)) {
              const name = getPropertyName(callee);
              if (isProhibitedIdentifier(name)) {
                context.report({
                  node,
                  messageId: "unexpected",
                  data: { name }
                });
              }
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-array-constructor.js
var require_no_array_constructor = __commonJS({
  "../../node_modules/eslint/lib/rules/no-array-constructor.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow `Array` constructors",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-array-constructor"
        },
        schema: [],
        messages: {
          preferLiteral: "The array literal notation [] is preferable."
        }
      },
      create(context) {
        function check(node) {
          if (node.arguments.length !== 1 && node.callee.type === "Identifier" && node.callee.name === "Array") {
            context.report({ node, messageId: "preferLiteral" });
          }
        }
        return {
          CallExpression: check,
          NewExpression: check
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-async-promise-executor.js
var require_no_async_promise_executor = __commonJS({
  "../../node_modules/eslint/lib/rules/no-async-promise-executor.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow using an async function as a Promise executor",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-async-promise-executor"
        },
        fixable: null,
        schema: [],
        messages: {
          async: "Promise executor functions should not be async."
        }
      },
      create(context) {
        return {
          "NewExpression[callee.name='Promise'][arguments.0.async=true]"(node) {
            context.report({
              node: context.sourceCode.getFirstToken(node.arguments[0], (token) => token.value === "async"),
              messageId: "async"
            });
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-await-in-loop.js
var require_no_await_in_loop = __commonJS({
  "../../node_modules/eslint/lib/rules/no-await-in-loop.js"(exports, module) {
    "use strict";
    function isBoundary(node) {
      const t = node.type;
      return t === "FunctionDeclaration" || t === "FunctionExpression" || t === "ArrowFunctionExpression" || /*
       * Don't report the await expressions on for-await-of loop since it's
       * asynchronous iteration intentionally.
       */
      t === "ForOfStatement" && node.await === true;
    }
    function isLooped(node, parent) {
      switch (parent.type) {
        case "ForStatement":
          return node === parent.test || node === parent.update || node === parent.body;
        case "ForOfStatement":
        case "ForInStatement":
          return node === parent.body;
        case "WhileStatement":
        case "DoWhileStatement":
          return node === parent.test || node === parent.body;
        default:
          return false;
      }
    }
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow `await` inside of loops",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-await-in-loop"
        },
        schema: [],
        messages: {
          unexpectedAwait: "Unexpected `await` inside a loop."
        }
      },
      create(context) {
        function validate(awaitNode) {
          if (awaitNode.type === "ForOfStatement" && !awaitNode.await) {
            return;
          }
          let node = awaitNode;
          let parent = node.parent;
          while (parent && !isBoundary(parent)) {
            if (isLooped(node, parent)) {
              context.report({
                node: awaitNode,
                messageId: "unexpectedAwait"
              });
              return;
            }
            node = parent;
            parent = parent.parent;
          }
        }
        return {
          AwaitExpression: validate,
          ForOfStatement: validate
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-bitwise.js
var require_no_bitwise = __commonJS({
  "../../node_modules/eslint/lib/rules/no-bitwise.js"(exports, module) {
    "use strict";
    var BITWISE_OPERATORS = [
      "^",
      "|",
      "&",
      "<<",
      ">>",
      ">>>",
      "^=",
      "|=",
      "&=",
      "<<=",
      ">>=",
      ">>>=",
      "~"
    ];
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow bitwise operators",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-bitwise"
        },
        schema: [
          {
            type: "object",
            properties: {
              allow: {
                type: "array",
                items: {
                  enum: BITWISE_OPERATORS
                },
                uniqueItems: true
              },
              int32Hint: {
                type: "boolean",
                default: false
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          unexpected: "Unexpected use of '{{operator}}'."
        }
      },
      create(context) {
        const options = context.options[0] || {};
        const allowed = options.allow || [];
        const int32Hint = options.int32Hint === true;
        function report(node) {
          context.report({ node, messageId: "unexpected", data: { operator: node.operator } });
        }
        function hasBitwiseOperator(node) {
          return BITWISE_OPERATORS.includes(node.operator);
        }
        function allowedOperator(node) {
          return allowed.includes(node.operator);
        }
        function isInt32Hint(node) {
          return int32Hint && node.operator === "|" && node.right && node.right.type === "Literal" && node.right.value === 0;
        }
        function checkNodeForBitwiseOperator(node) {
          if (hasBitwiseOperator(node) && !allowedOperator(node) && !isInt32Hint(node)) {
            report(node);
          }
        }
        return {
          AssignmentExpression: checkNodeForBitwiseOperator,
          BinaryExpression: checkNodeForBitwiseOperator,
          UnaryExpression: checkNodeForBitwiseOperator
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-buffer-constructor.js
var require_no_buffer_constructor = __commonJS({
  "../../node_modules/eslint/lib/rules/no-buffer-constructor.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        deprecated: true,
        replacedBy: [],
        type: "problem",
        docs: {
          description: "Disallow use of the `Buffer()` constructor",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-buffer-constructor"
        },
        schema: [],
        messages: {
          deprecated: "{{expr}} is deprecated. Use Buffer.from(), Buffer.alloc(), or Buffer.allocUnsafe() instead."
        }
      },
      create(context) {
        return {
          "CallExpression[callee.name='Buffer'], NewExpression[callee.name='Buffer']"(node) {
            context.report({
              node,
              messageId: "deprecated",
              data: { expr: node.type === "CallExpression" ? "Buffer()" : "new Buffer()" }
            });
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-caller.js
var require_no_caller = __commonJS({
  "../../node_modules/eslint/lib/rules/no-caller.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow the use of `arguments.caller` or `arguments.callee`",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-caller"
        },
        schema: [],
        messages: {
          unexpected: "Avoid arguments.{{prop}}."
        }
      },
      create(context) {
        return {
          MemberExpression(node) {
            const objectName = node.object.name, propertyName = node.property.name;
            if (objectName === "arguments" && !node.computed && propertyName && propertyName.match(/^calle[er]$/u)) {
              context.report({ node, messageId: "unexpected", data: { prop: propertyName } });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-case-declarations.js
var require_no_case_declarations = __commonJS({
  "../../node_modules/eslint/lib/rules/no-case-declarations.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow lexical declarations in case clauses",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-case-declarations"
        },
        schema: [],
        messages: {
          unexpected: "Unexpected lexical declaration in case block."
        }
      },
      create(context) {
        function isLexicalDeclaration(node) {
          switch (node.type) {
            case "FunctionDeclaration":
            case "ClassDeclaration":
              return true;
            case "VariableDeclaration":
              return node.kind !== "var";
            default:
              return false;
          }
        }
        return {
          SwitchCase(node) {
            for (let i = 0; i < node.consequent.length; i++) {
              const statement = node.consequent[i];
              if (isLexicalDeclaration(statement)) {
                context.report({
                  node: statement,
                  messageId: "unexpected"
                });
              }
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-catch-shadow.js
var require_no_catch_shadow = __commonJS({
  "../../node_modules/eslint/lib/rules/no-catch-shadow.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow `catch` clause parameters from shadowing variables in the outer scope",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-catch-shadow"
        },
        replacedBy: ["no-shadow"],
        deprecated: true,
        schema: [],
        messages: {
          mutable: "Value of '{{name}}' may be overwritten in IE 8 and earlier."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        function paramIsShadowing(scope, name) {
          return astUtils.getVariableByName(scope, name) !== null;
        }
        return {
          "CatchClause[param!=null]"(node) {
            let scope = sourceCode.getScope(node);
            if (scope.block === node) {
              scope = scope.upper;
            }
            if (paramIsShadowing(scope, node.param.name)) {
              context.report({ node, messageId: "mutable", data: { name: node.param.name } });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-class-assign.js
var require_no_class_assign = __commonJS({
  "../../node_modules/eslint/lib/rules/no-class-assign.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow reassigning class members",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-class-assign"
        },
        schema: [],
        messages: {
          class: "'{{name}}' is a class."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        function checkVariable(variable) {
          astUtils.getModifyingReferences(variable.references).forEach((reference) => {
            context.report({ node: reference.identifier, messageId: "class", data: { name: reference.identifier.name } });
          });
        }
        function checkForClass(node) {
          sourceCode.getDeclaredVariables(node).forEach(checkVariable);
        }
        return {
          ClassDeclaration: checkForClass,
          ClassExpression: checkForClass
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-compare-neg-zero.js
var require_no_compare_neg_zero = __commonJS({
  "../../node_modules/eslint/lib/rules/no-compare-neg-zero.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow comparing against -0",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-compare-neg-zero"
        },
        fixable: null,
        schema: [],
        messages: {
          unexpected: "Do not use the '{{operator}}' operator to compare against -0."
        }
      },
      create(context) {
        function isNegZero(node) {
          return node.type === "UnaryExpression" && node.operator === "-" && node.argument.type === "Literal" && node.argument.value === 0;
        }
        const OPERATORS_TO_CHECK = /* @__PURE__ */ new Set([">", ">=", "<", "<=", "==", "===", "!=", "!=="]);
        return {
          BinaryExpression(node) {
            if (OPERATORS_TO_CHECK.has(node.operator)) {
              if (isNegZero(node.left) || isNegZero(node.right)) {
                context.report({
                  node,
                  messageId: "unexpected",
                  data: { operator: node.operator }
                });
              }
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-cond-assign.js
var require_no_cond_assign = __commonJS({
  "../../node_modules/eslint/lib/rules/no-cond-assign.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var TEST_CONDITION_PARENT_TYPES = /* @__PURE__ */ new Set(["IfStatement", "WhileStatement", "DoWhileStatement", "ForStatement", "ConditionalExpression"]);
    var NODE_DESCRIPTIONS = {
      DoWhileStatement: "a 'do...while' statement",
      ForStatement: "a 'for' statement",
      IfStatement: "an 'if' statement",
      WhileStatement: "a 'while' statement"
    };
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow assignment operators in conditional expressions",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-cond-assign"
        },
        schema: [
          {
            enum: ["except-parens", "always"]
          }
        ],
        messages: {
          unexpected: "Unexpected assignment within {{type}}.",
          // must match JSHint's error message
          missing: "Expected a conditional expression and instead saw an assignment."
        }
      },
      create(context) {
        const prohibitAssign = context.options[0] || "except-parens";
        const sourceCode = context.sourceCode;
        function isConditionalTestExpression(node) {
          return node.parent && TEST_CONDITION_PARENT_TYPES.has(node.parent.type) && node === node.parent.test;
        }
        function findConditionalAncestor(node) {
          let currentAncestor = node;
          do {
            if (isConditionalTestExpression(currentAncestor)) {
              return currentAncestor.parent;
            }
          } while ((currentAncestor = currentAncestor.parent) && !astUtils.isFunction(currentAncestor));
          return null;
        }
        function isParenthesisedTwice(node) {
          const previousToken = sourceCode.getTokenBefore(node, 1), nextToken = sourceCode.getTokenAfter(node, 1);
          return astUtils.isParenthesised(sourceCode, node) && previousToken && astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] && astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];
        }
        function testForAssign(node) {
          if (node.test && node.test.type === "AssignmentExpression" && (node.type === "ForStatement" ? !astUtils.isParenthesised(sourceCode, node.test) : !isParenthesisedTwice(node.test))) {
            context.report({
              node: node.test,
              messageId: "missing"
            });
          }
        }
        function testForConditionalAncestor(node) {
          const ancestor = findConditionalAncestor(node);
          if (ancestor) {
            context.report({
              node,
              messageId: "unexpected",
              data: {
                type: NODE_DESCRIPTIONS[ancestor.type] || ancestor.type
              }
            });
          }
        }
        if (prohibitAssign === "always") {
          return {
            AssignmentExpression: testForConditionalAncestor
          };
        }
        return {
          DoWhileStatement: testForAssign,
          ForStatement: testForAssign,
          IfStatement: testForAssign,
          WhileStatement: testForAssign,
          ConditionalExpression: testForAssign
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-confusing-arrow.js
var require_no_confusing_arrow = __commonJS({
  "../../node_modules/eslint/lib/rules/no-confusing-arrow.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    function isConditional(node) {
      return node && node.type === "ConditionalExpression";
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow arrow functions where they could be confused with comparisons",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-confusing-arrow"
        },
        fixable: "code",
        schema: [{
          type: "object",
          properties: {
            allowParens: { type: "boolean", default: true },
            onlyOneSimpleParam: { type: "boolean", default: false }
          },
          additionalProperties: false
        }],
        messages: {
          confusing: "Arrow function used ambiguously with a conditional expression."
        }
      },
      create(context) {
        const config = context.options[0] || {};
        const allowParens = config.allowParens || config.allowParens === void 0;
        const onlyOneSimpleParam = config.onlyOneSimpleParam;
        const sourceCode = context.sourceCode;
        function checkArrowFunc(node) {
          const body = node.body;
          if (isConditional(body) && !(allowParens && astUtils.isParenthesised(sourceCode, body)) && !(onlyOneSimpleParam && !(node.params.length === 1 && node.params[0].type === "Identifier"))) {
            context.report({
              node,
              messageId: "confusing",
              fix(fixer) {
                return allowParens && fixer.replaceText(node.body, `(${sourceCode.getText(node.body)})`);
              }
            });
          }
        }
        return {
          ArrowFunctionExpression: checkArrowFunc
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-console.js
var require_no_console = __commonJS({
  "../../node_modules/eslint/lib/rules/no-console.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow the use of `console`",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-console"
        },
        schema: [
          {
            type: "object",
            properties: {
              allow: {
                type: "array",
                items: {
                  type: "string"
                },
                minItems: 1,
                uniqueItems: true
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          unexpected: "Unexpected console statement."
        }
      },
      create(context) {
        const options = context.options[0] || {};
        const allowed = options.allow || [];
        const sourceCode = context.sourceCode;
        function isConsole(reference) {
          const id = reference.identifier;
          return id && id.name === "console";
        }
        function isAllowed(node) {
          const propertyName = astUtils.getStaticPropertyName(node);
          return propertyName && allowed.includes(propertyName);
        }
        function isMemberAccessExceptAllowed(reference) {
          const node = reference.identifier;
          const parent = node.parent;
          return parent.type === "MemberExpression" && parent.object === node && !isAllowed(parent);
        }
        function report(reference) {
          const node = reference.identifier.parent;
          context.report({
            node,
            loc: node.loc,
            messageId: "unexpected"
          });
        }
        return {
          "Program:exit"(node) {
            const scope = sourceCode.getScope(node);
            const consoleVar = astUtils.getVariableByName(scope, "console");
            const shadowed = consoleVar && consoleVar.defs.length > 0;
            const references = consoleVar ? consoleVar.references : scope.through.filter(isConsole);
            if (!shadowed) {
              references.filter(isMemberAccessExceptAllowed).forEach(report);
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-const-assign.js
var require_no_const_assign = __commonJS({
  "../../node_modules/eslint/lib/rules/no-const-assign.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow reassigning `const` variables",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-const-assign"
        },
        schema: [],
        messages: {
          const: "'{{name}}' is constant."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        function checkVariable(variable) {
          astUtils.getModifyingReferences(variable.references).forEach((reference) => {
            context.report({ node: reference.identifier, messageId: "const", data: { name: reference.identifier.name } });
          });
        }
        return {
          VariableDeclaration(node) {
            if (node.kind === "const") {
              sourceCode.getDeclaredVariables(node).forEach(checkVariable);
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-constant-binary-expression.js
var require_no_constant_binary_expression = __commonJS({
  "../../node_modules/eslint/lib/rules/no-constant-binary-expression.js"(exports, module) {
    "use strict";
    var globals = require_globals2();
    var { isNullLiteral, isConstant, isReferenceToGlobalVariable, isLogicalAssignmentOperator } = require_ast_utils2();
    var NUMERIC_OR_STRING_BINARY_OPERATORS = /* @__PURE__ */ new Set(["+", "-", "*", "/", "%", "|", "^", "&", "**", "<<", ">>", ">>>"]);
    function isNullOrUndefined(scope, node) {
      return isNullLiteral(node) || node.type === "Identifier" && node.name === "undefined" && isReferenceToGlobalVariable(scope, node) || node.type === "UnaryExpression" && node.operator === "void";
    }
    function hasConstantNullishness(scope, node, nonNullish) {
      if (nonNullish && isNullOrUndefined(scope, node)) {
        return false;
      }
      switch (node.type) {
        case "ObjectExpression":
        case "ArrayExpression":
        case "ArrowFunctionExpression":
        case "FunctionExpression":
        case "ClassExpression":
        case "NewExpression":
        case "Literal":
        case "TemplateLiteral":
        case "UpdateExpression":
        case "BinaryExpression":
          return true;
        case "CallExpression": {
          if (node.callee.type !== "Identifier") {
            return false;
          }
          const functionName = node.callee.name;
          return (functionName === "Boolean" || functionName === "String" || functionName === "Number") && isReferenceToGlobalVariable(scope, node.callee);
        }
        case "LogicalExpression": {
          return node.operator === "??" && hasConstantNullishness(scope, node.right, true);
        }
        case "AssignmentExpression":
          if (node.operator === "=") {
            return hasConstantNullishness(scope, node.right, nonNullish);
          }
          if (isLogicalAssignmentOperator(node.operator)) {
            return false;
          }
          return true;
        case "UnaryExpression":
          return true;
        case "SequenceExpression": {
          const last = node.expressions[node.expressions.length - 1];
          return hasConstantNullishness(scope, last, nonNullish);
        }
        case "Identifier":
          return node.name === "undefined" && isReferenceToGlobalVariable(scope, node);
        case "JSXElement":
        case "JSXFragment":
          return false;
        default:
          return false;
      }
    }
    function isStaticBoolean(scope, node) {
      switch (node.type) {
        case "Literal":
          return typeof node.value === "boolean";
        case "CallExpression":
          return node.callee.type === "Identifier" && node.callee.name === "Boolean" && isReferenceToGlobalVariable(scope, node.callee) && (node.arguments.length === 0 || isConstant(scope, node.arguments[0], true));
        case "UnaryExpression":
          return node.operator === "!" && isConstant(scope, node.argument, true);
        default:
          return false;
      }
    }
    function hasConstantLooseBooleanComparison(scope, node) {
      switch (node.type) {
        case "ObjectExpression":
        case "ClassExpression":
          return true;
        case "ArrayExpression": {
          const nonSpreadElements = node.elements.filter((e) => (
            // Elements can be `null` in sparse arrays: `[,,]`;
            e !== null && e.type !== "SpreadElement"
          ));
          return node.elements.length === 0 || nonSpreadElements.length > 1;
        }
        case "ArrowFunctionExpression":
        case "FunctionExpression":
          return true;
        case "UnaryExpression":
          if (node.operator === "void" || // Always returns `undefined`
          node.operator === "typeof") {
            return true;
          }
          if (node.operator === "!") {
            return isConstant(scope, node.argument, true);
          }
          return false;
        case "NewExpression":
          return false;
        case "CallExpression": {
          if (node.callee.type === "Identifier" && node.callee.name === "Boolean" && isReferenceToGlobalVariable(scope, node.callee)) {
            return node.arguments.length === 0 || isConstant(scope, node.arguments[0], true);
          }
          return false;
        }
        case "Literal":
          return true;
        case "Identifier":
          return node.name === "undefined" && isReferenceToGlobalVariable(scope, node);
        case "TemplateLiteral":
          return node.expressions.length === 0;
        case "AssignmentExpression":
          if (node.operator === "=") {
            return hasConstantLooseBooleanComparison(scope, node.right);
          }
          return false;
        case "SequenceExpression": {
          const last = node.expressions[node.expressions.length - 1];
          return hasConstantLooseBooleanComparison(scope, last);
        }
        case "JSXElement":
        case "JSXFragment":
          return false;
        default:
          return false;
      }
    }
    function hasConstantStrictBooleanComparison(scope, node) {
      switch (node.type) {
        case "ObjectExpression":
        case "ArrayExpression":
        case "ArrowFunctionExpression":
        case "FunctionExpression":
        case "ClassExpression":
        case "NewExpression":
        case "TemplateLiteral":
        case "Literal":
        case "UpdateExpression":
          return true;
        case "BinaryExpression":
          return NUMERIC_OR_STRING_BINARY_OPERATORS.has(node.operator);
        case "UnaryExpression": {
          if (node.operator === "delete") {
            return false;
          }
          if (node.operator === "!") {
            return isConstant(scope, node.argument, true);
          }
          return true;
        }
        case "SequenceExpression": {
          const last = node.expressions[node.expressions.length - 1];
          return hasConstantStrictBooleanComparison(scope, last);
        }
        case "Identifier":
          return node.name === "undefined" && isReferenceToGlobalVariable(scope, node);
        case "AssignmentExpression":
          if (node.operator === "=") {
            return hasConstantStrictBooleanComparison(scope, node.right);
          }
          if (isLogicalAssignmentOperator(node.operator)) {
            return false;
          }
          return true;
        case "CallExpression": {
          if (node.callee.type !== "Identifier") {
            return false;
          }
          const functionName = node.callee.name;
          if ((functionName === "String" || functionName === "Number") && isReferenceToGlobalVariable(scope, node.callee)) {
            return true;
          }
          if (functionName === "Boolean" && isReferenceToGlobalVariable(scope, node.callee)) {
            return node.arguments.length === 0 || isConstant(scope, node.arguments[0], true);
          }
          return false;
        }
        case "JSXElement":
        case "JSXFragment":
          return false;
        default:
          return false;
      }
    }
    function isAlwaysNew(scope, node) {
      switch (node.type) {
        case "ObjectExpression":
        case "ArrayExpression":
        case "ArrowFunctionExpression":
        case "FunctionExpression":
        case "ClassExpression":
          return true;
        case "NewExpression": {
          if (node.callee.type !== "Identifier") {
            return false;
          }
          return Object.hasOwnProperty.call(globals.builtin, node.callee.name) && isReferenceToGlobalVariable(scope, node.callee);
        }
        case "Literal":
          return typeof node.regex === "object";
        case "SequenceExpression": {
          const last = node.expressions[node.expressions.length - 1];
          return isAlwaysNew(scope, last);
        }
        case "AssignmentExpression":
          if (node.operator === "=") {
            return isAlwaysNew(scope, node.right);
          }
          return false;
        case "ConditionalExpression":
          return isAlwaysNew(scope, node.consequent) && isAlwaysNew(scope, node.alternate);
        case "JSXElement":
        case "JSXFragment":
          return false;
        default:
          return false;
      }
    }
    function findBinaryExpressionConstantOperand(scope, a, b, operator) {
      if (operator === "==" || operator === "!=") {
        if (isNullOrUndefined(scope, a) && hasConstantNullishness(scope, b, false) || isStaticBoolean(scope, a) && hasConstantLooseBooleanComparison(scope, b)) {
          return b;
        }
      } else if (operator === "===" || operator === "!==") {
        if (isNullOrUndefined(scope, a) && hasConstantNullishness(scope, b, false) || isStaticBoolean(scope, a) && hasConstantStrictBooleanComparison(scope, b)) {
          return b;
        }
      }
      return null;
    }
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow expressions where the operation doesn't affect the value",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-constant-binary-expression"
        },
        schema: [],
        messages: {
          constantBinaryOperand: "Unexpected constant binary expression. Compares constantly with the {{otherSide}}-hand side of the `{{operator}}`.",
          constantShortCircuit: "Unexpected constant {{property}} on the left-hand side of a `{{operator}}` expression.",
          alwaysNew: "Unexpected comparison to newly constructed object. These two values can never be equal.",
          bothAlwaysNew: "Unexpected comparison of two newly constructed objects. These two values can never be equal."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        return {
          LogicalExpression(node) {
            const { operator, left } = node;
            const scope = sourceCode.getScope(node);
            if ((operator === "&&" || operator === "||") && isConstant(scope, left, true)) {
              context.report({ node: left, messageId: "constantShortCircuit", data: { property: "truthiness", operator } });
            } else if (operator === "??" && hasConstantNullishness(scope, left, false)) {
              context.report({ node: left, messageId: "constantShortCircuit", data: { property: "nullishness", operator } });
            }
          },
          BinaryExpression(node) {
            const scope = sourceCode.getScope(node);
            const { right, left, operator } = node;
            const rightConstantOperand = findBinaryExpressionConstantOperand(scope, left, right, operator);
            const leftConstantOperand = findBinaryExpressionConstantOperand(scope, right, left, operator);
            if (rightConstantOperand) {
              context.report({ node: rightConstantOperand, messageId: "constantBinaryOperand", data: { operator, otherSide: "left" } });
            } else if (leftConstantOperand) {
              context.report({ node: leftConstantOperand, messageId: "constantBinaryOperand", data: { operator, otherSide: "right" } });
            } else if (operator === "===" || operator === "!==") {
              if (isAlwaysNew(scope, left)) {
                context.report({ node: left, messageId: "alwaysNew" });
              } else if (isAlwaysNew(scope, right)) {
                context.report({ node: right, messageId: "alwaysNew" });
              }
            } else if (operator === "==" || operator === "!=") {
              if (isAlwaysNew(scope, left) && isAlwaysNew(scope, right)) {
                context.report({ node: left, messageId: "bothAlwaysNew" });
              }
            }
          }
          /*
           * In theory we could handle short-circuiting assignment operators,
           * for some constant values, but that would require walking the
           * scope to find the value of the variable being assigned. This is
           * dependant on https://github.com/eslint/eslint/issues/13776
           *
           * AssignmentExpression() {},
           */
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-constant-condition.js
var require_no_constant_condition = __commonJS({
  "../../node_modules/eslint/lib/rules/no-constant-condition.js"(exports, module) {
    "use strict";
    var { isConstant } = require_ast_utils2();
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow constant expressions in conditions",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-constant-condition"
        },
        schema: [
          {
            type: "object",
            properties: {
              checkLoops: {
                type: "boolean",
                default: true
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          unexpected: "Unexpected constant condition."
        }
      },
      create(context) {
        const options = context.options[0] || {}, checkLoops = options.checkLoops !== false, loopSetStack = [];
        const sourceCode = context.sourceCode;
        let loopsInCurrentScope = /* @__PURE__ */ new Set();
        function trackConstantConditionLoop(node) {
          if (node.test && isConstant(sourceCode.getScope(node), node.test, true)) {
            loopsInCurrentScope.add(node);
          }
        }
        function checkConstantConditionLoopInSet(node) {
          if (loopsInCurrentScope.has(node)) {
            loopsInCurrentScope.delete(node);
            context.report({ node: node.test, messageId: "unexpected" });
          }
        }
        function reportIfConstant(node) {
          if (node.test && isConstant(sourceCode.getScope(node), node.test, true)) {
            context.report({ node: node.test, messageId: "unexpected" });
          }
        }
        function enterFunction() {
          loopSetStack.push(loopsInCurrentScope);
          loopsInCurrentScope = /* @__PURE__ */ new Set();
        }
        function exitFunction() {
          loopsInCurrentScope = loopSetStack.pop();
        }
        function checkLoop(node) {
          if (checkLoops) {
            trackConstantConditionLoop(node);
          }
        }
        return {
          ConditionalExpression: reportIfConstant,
          IfStatement: reportIfConstant,
          WhileStatement: checkLoop,
          "WhileStatement:exit": checkConstantConditionLoopInSet,
          DoWhileStatement: checkLoop,
          "DoWhileStatement:exit": checkConstantConditionLoopInSet,
          ForStatement: checkLoop,
          "ForStatement > .test": (node) => checkLoop(node.parent),
          "ForStatement:exit": checkConstantConditionLoopInSet,
          FunctionDeclaration: enterFunction,
          "FunctionDeclaration:exit": exitFunction,
          FunctionExpression: enterFunction,
          "FunctionExpression:exit": exitFunction,
          YieldExpression: () => loopsInCurrentScope.clear()
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-constructor-return.js
var require_no_constructor_return = __commonJS({
  "../../node_modules/eslint/lib/rules/no-constructor-return.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow returning value from constructor",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-constructor-return"
        },
        schema: {},
        fixable: null,
        messages: {
          unexpected: "Unexpected return statement in constructor."
        }
      },
      create(context) {
        const stack = [];
        return {
          onCodePathStart(_, node) {
            stack.push(node);
          },
          onCodePathEnd() {
            stack.pop();
          },
          ReturnStatement(node) {
            const last = stack[stack.length - 1];
            if (!last.parent) {
              return;
            }
            if (last.parent.type === "MethodDefinition" && last.parent.kind === "constructor" && (node.parent.parent === last || node.argument)) {
              context.report({
                node,
                messageId: "unexpected"
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-continue.js
var require_no_continue = __commonJS({
  "../../node_modules/eslint/lib/rules/no-continue.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow `continue` statements",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-continue"
        },
        schema: [],
        messages: {
          unexpected: "Unexpected use of continue statement."
        }
      },
      create(context) {
        return {
          ContinueStatement(node) {
            context.report({ node, messageId: "unexpected" });
          }
        };
      }
    };
  }
});

// ../../node_modules/@eslint-community/regexpp/index.js
var require_regexpp = __commonJS({
  "../../node_modules/@eslint-community/regexpp/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ast = /* @__PURE__ */ Object.freeze({
      __proto__: null
    });
    var largeIdStartRanges = void 0;
    var largeIdContinueRanges = void 0;
    function isIdStart(cp) {
      if (cp < 65)
        return false;
      if (cp < 91)
        return true;
      if (cp < 97)
        return false;
      if (cp < 123)
        return true;
      return isLargeIdStart(cp);
    }
    function isIdContinue(cp) {
      if (cp < 48)
        return false;
      if (cp < 58)
        return true;
      if (cp < 65)
        return false;
      if (cp < 91)
        return true;
      if (cp === 95)
        return true;
      if (cp < 97)
        return false;
      if (cp < 123)
        return true;
      return isLargeIdStart(cp) || isLargeIdContinue(cp);
    }
    function isLargeIdStart(cp) {
      return isInRange(cp, largeIdStartRanges !== null && largeIdStartRanges !== void 0 ? largeIdStartRanges : largeIdStartRanges = initLargeIdStartRanges());
    }
    function isLargeIdContinue(cp) {
      return isInRange(cp, largeIdContinueRanges !== null && largeIdContinueRanges !== void 0 ? largeIdContinueRanges : largeIdContinueRanges = initLargeIdContinueRanges());
    }
    function initLargeIdStartRanges() {
      return restoreRanges("4q 0 b 0 5 0 6 m 2 u 2 cp 5 b f 4 8 0 2 0 3m 4 2 1 3 3 2 0 7 0 2 2 2 0 2 j 2 2a 2 3u 9 4l 2 11 3 0 7 14 20 q 5 3 1a 16 10 1 2 2q 2 0 g 1 8 1 b 2 3 0 h 0 2 t u 2g c 0 p w a 1 5 0 6 l 5 0 a 0 4 0 o o 8 a 6 n 2 5 i 15 1n 1h 4 0 j 0 8 9 g f 5 7 3 1 3 l 2 6 2 0 4 3 4 0 h 0 e 1 2 2 f 1 b 0 9 5 5 1 3 l 2 6 2 1 2 1 2 1 w 3 2 0 k 2 h 8 2 2 2 l 2 6 2 1 2 4 4 0 j 0 g 1 o 0 c 7 3 1 3 l 2 6 2 1 2 4 4 0 v 1 2 2 g 0 i 0 2 5 4 2 2 3 4 1 2 0 2 1 4 1 4 2 4 b n 0 1h 7 2 2 2 m 2 f 4 0 r 2 3 0 3 1 v 0 5 7 2 2 2 m 2 9 2 4 4 0 w 1 2 1 g 1 i 8 2 2 2 14 3 0 h 0 6 2 9 2 p 5 6 h 4 n 2 8 2 0 3 6 1n 1b 2 1 d 6 1n 1 2 0 2 4 2 n 2 0 2 9 2 1 a 0 3 4 2 0 m 3 x 0 1s 7 2 z s 4 38 16 l 0 h 5 5 3 4 0 4 1 8 2 5 c d 0 i 11 2 0 6 0 3 16 2 98 2 3 3 6 2 0 2 3 3 14 2 3 3 w 2 3 3 6 2 0 2 3 3 e 2 1k 2 3 3 1u 12 f h 2d 3 5 4 h7 3 g 2 p 6 22 4 a 8 h e i f h f c 2 2 g 1f 10 0 5 0 1w 2g 8 14 2 0 6 1x b u 1e t 3 4 c 17 5 p 1j m a 1g 2b 0 2m 1a i 7 1j t e 1 b 17 r z 16 2 b z 3 8 8 16 3 2 16 3 2 5 2 1 4 0 6 5b 1t 7p 3 5 3 11 3 5 3 7 2 0 2 0 2 0 2 u 3 1g 2 6 2 0 4 2 2 6 4 3 3 5 5 c 6 2 2 6 39 0 e 0 h c 2u 0 5 0 3 9 2 0 3 5 7 0 2 0 2 0 2 f 3 3 6 4 5 0 i 14 22g 6c 7 3 4 1 d 11 2 0 6 0 3 1j 8 0 h m a 6 2 6 2 6 2 6 2 6 2 6 2 6 2 6 fb 2 q 8 8 4 3 4 5 2d 5 4 2 2h 2 3 6 16 2 2l i v 1d f e9 533 1t h3g 1w 19 3 7g 4 f b 1 l 1a h u 3 27 14 8 3 2u 3 1r 6 1 2 0 2 4 p f 2 2 2 3 2 m u 1f f 1d 1r 5 4 0 2 1 c r b m q s 8 1a t 0 h 4 2 9 b 4 2 14 o 2 2 7 l m 4 0 4 1d 2 0 4 1 3 4 3 0 2 0 p 2 3 a 8 2 d 5 3 5 3 5 a 6 2 6 2 16 2 d 7 36 u 8mb d m 5 1c 6it a5 3 2x 13 6 d 4 6 0 2 9 2 c 2 4 2 0 2 1 2 1 2 2z y a2 j 1r 3 1h 15 b 39 4 2 3q 11 p 7 p c 2g 4 5 3 5 3 5 3 2 10 b 2 p 2 i 2 1 2 e 3 d z 3e 1y 1g 7g s 4 1c 1c v e t 6 11 b t 3 z 5 7 2 4 17 4d j z 5 z 5 13 9 1f d a 2 e 2 6 2 1 2 a 2 e 2 6 2 1 1w 8m a l b 7 p 5 2 15 2 8 1y 5 3 0 2 17 2 1 4 0 3 m b m a u 1u i 2 1 b l b p 1z 1j 7 1 1t 0 g 3 2 2 2 s 17 s 4 s 10 7 2 r s 1h b l b i e h 33 20 1k 1e e 1e e z 9p 15 7 1 27 s b 0 9 l 17 h 1b k s m d 1g 1m 1 3 0 e 18 x o r z u 0 3 0 9 y 4 0 d 1b f 3 m 0 2 0 10 h 2 o k 1 1s 6 2 0 2 3 2 e 2 9 8 1a 13 7 3 1 3 l 2 6 2 1 2 4 4 0 j 0 d 4 4f 1g j 3 l 2 v 1b l 1 2 0 55 1a 16 3 11 1b l 0 1o 16 e 0 20 q 12 6 56 17 39 1r w 7 3 0 3 7 2 1 2 n g 0 2 0 2n 7 3 12 h 0 2 0 t 0 b 13 8 0 m 0 c 19 k 0 j 20 7c 8 2 10 i 0 1e t 35 6 2 1 2 11 m 0 q 5 2 1 2 v f 0 94 i g 0 2 c 2 x 3h 0 28 pl 2v 32 i 5f 219 2o g tr i 5 33u g6 6nu fs 8 u i 26 i t j 1b h 3 w k 6 i j5 1r 3l 22 6 0 1v c 1t 1 2 0 t 4qf 9 yd 17 8 6w8 3 2 6 2 1 2 82 g 0 u 2 3 0 f 3 9 az 1s5 2y 6 c 4 8 8 9 4mf 2c 2 1y 2 1 3 0 3 1 3 3 2 b 2 0 2 6 2 1s 2 3 3 7 2 6 2 r 2 3 2 4 2 0 4 6 2 9f 3 o 2 o 2 u 2 o 2 u 2 o 2 u 2 o 2 u 2 o 2 7 1f9 u 7 5 7a 1p 43 18 b 6 h 0 8y t j 17 dh r l1 6 2 3 2 1 2 e 2 5g 1o 1v 8 0 xh 3 2 q 2 1 2 0 3 0 2 9 2 3 2 0 2 0 7 0 5 0 2 0 2 0 2 2 2 1 2 0 3 0 2 0 2 0 2 0 2 0 2 1 2 0 3 3 2 6 2 3 2 3 2 0 2 9 2 g 6 2 2 4 2 g 3et wyn x 37d 7 65 3 4g1 f 5rk 2e8 f1 15v 3t6 6 38f");
    }
    function initLargeIdContinueRanges() {
      return restoreRanges("53 0 g9 33 o 0 70 4 7e 18 2 0 2 1 2 1 2 0 21 a 1d u 7 0 2u 6 3 5 3 1 2 3 3 9 o 0 v q 2k a g 9 y 8 a 0 p 3 2 8 2 2 2 4 18 2 1p 7 17 n 2 w 1j 2 2 h 2 6 b 1 3 9 i 2 1l 0 2 6 3 1 3 2 a 0 b 1 3 9 f 0 3 2 1l 0 2 4 5 1 3 2 4 0 l b 4 0 c 2 1l 0 2 7 2 2 2 2 l 1 3 9 b 5 2 2 1l 0 2 6 3 1 3 2 8 2 b 1 3 9 j 0 1o 4 4 2 2 3 a 0 f 9 h 4 1k 0 2 6 2 2 2 3 8 1 c 1 3 9 i 2 1l 0 2 6 2 2 2 3 8 1 c 1 3 9 4 0 d 3 1k 1 2 6 2 2 2 3 a 0 b 1 3 9 i 2 1z 0 5 5 2 0 2 7 7 9 3 1 1q 0 3 6 d 7 2 9 2g 0 3 8 c 6 2 9 1r 1 7 9 c 0 2 0 2 0 5 1 1e j 2 1 6 a 2 z a 0 2t j 2 9 d 3 5 2 2 2 3 6 4 3 e b 2 e jk 2 a 8 pt 3 t 2 u 1 v 1 1t v a 0 3 9 y 2 2 a 40 0 3b b 5 b b 9 3l a 1p 4 1m 9 2 s 3 a 7 9 n d 2 f 1e 4 1c g c 9 i 8 d 2 v c 3 9 19 d 1d j 9 9 7 9 3b 2 2 k 5 0 7 0 3 2 5j 1r g0 1 k 0 3g c 5 0 4 b 2db 2 3y 0 2p v ff 5 2y 1 n7q 9 1y 0 5 9 x 1 29 1 7l 0 4 0 5 0 o 4 5 0 2c 1 1f h b 9 7 h e a t 7 q c 19 3 1c d g 9 c 0 b 9 1c d d 0 9 1 3 9 y 2 1f 0 2 2 3 1 6 1 2 0 16 4 6 1 6l 7 2 1 3 9 fmt 0 ki f h f 4 1 p 2 5d 9 12 0 ji 0 6b 0 46 4 86 9 120 2 2 1 6 3 15 2 5 0 4m 1 fy 3 9 9 aa 1 29 2 1z a 1e 3 3f 2 1i e w a 3 1 b 3 1a a 8 0 1a 9 7 2 11 d 2 9 6 1 19 0 d 2 1d d 9 3 2 b 2b b 7 0 3 0 4e b 6 9 7 3 1k 1 2 6 3 1 3 2 a 0 b 1 3 6 4 4 5d h a 9 5 0 2a j d 9 5y 6 3 8 s 1 2b g g 9 2a c 9 9 2c e 5 9 6r e 4m 9 1z 5 2 1 3 3 2 0 2 1 d 9 3c 6 3 6 4 0 t 9 15 6 2 3 9 0 a a 1b f ba 7 2 7 h 9 1l l 2 d 3f 5 4 0 2 1 2 6 2 0 9 9 1d 4 2 1 2 4 9 9 96 3 a 1 2 0 1d 6 4 4 e 9 44n 0 7 e aob 9 2f 9 13 4 1o 6 q 9 s6 0 2 1i 8 3 2a 0 c 1 f58 1 3mq 19 3 m f3 4 4 5 9 7 3 6 v 3 45 2 13e 1d e9 1i 5 1d 9 0 f 0 n 4 2 e 11t 6 2 g 3 6 2 1 2 4 2t 0 4h 6 a 9 9x 0 1q d dv d rb 6 32 6 6 9 3o7 9 gvt3 6n");
    }
    function isInRange(cp, ranges) {
      let l = 0, r = ranges.length / 2 | 0, i = 0, min = 0, max = 0;
      while (l < r) {
        i = (l + r) / 2 | 0;
        min = ranges[2 * i];
        max = ranges[2 * i + 1];
        if (cp < min) {
          r = i;
        } else if (cp > max) {
          l = i + 1;
        } else {
          return true;
        }
      }
      return false;
    }
    function restoreRanges(data) {
      let last = 0;
      return data.split(" ").map((s) => last += parseInt(s, 36) | 0);
    }
    var DataSet = class {
      constructor(raw2018, raw2019, raw2020, raw2021, raw2022, raw2023, raw2024) {
        this._raw2018 = raw2018;
        this._raw2019 = raw2019;
        this._raw2020 = raw2020;
        this._raw2021 = raw2021;
        this._raw2022 = raw2022;
        this._raw2023 = raw2023;
        this._raw2024 = raw2024;
      }
      get es2018() {
        var _a;
        return (_a = this._set2018) !== null && _a !== void 0 ? _a : this._set2018 = new Set(this._raw2018.split(" "));
      }
      get es2019() {
        var _a;
        return (_a = this._set2019) !== null && _a !== void 0 ? _a : this._set2019 = new Set(this._raw2019.split(" "));
      }
      get es2020() {
        var _a;
        return (_a = this._set2020) !== null && _a !== void 0 ? _a : this._set2020 = new Set(this._raw2020.split(" "));
      }
      get es2021() {
        var _a;
        return (_a = this._set2021) !== null && _a !== void 0 ? _a : this._set2021 = new Set(this._raw2021.split(" "));
      }
      get es2022() {
        var _a;
        return (_a = this._set2022) !== null && _a !== void 0 ? _a : this._set2022 = new Set(this._raw2022.split(" "));
      }
      get es2023() {
        var _a;
        return (_a = this._set2023) !== null && _a !== void 0 ? _a : this._set2023 = new Set(this._raw2023.split(" "));
      }
      get es2024() {
        var _a;
        return (_a = this._set2024) !== null && _a !== void 0 ? _a : this._set2024 = new Set(this._raw2024.split(" "));
      }
    };
    var gcNameSet = /* @__PURE__ */ new Set(["General_Category", "gc"]);
    var scNameSet = /* @__PURE__ */ new Set(["Script", "Script_Extensions", "sc", "scx"]);
    var gcValueSets = new DataSet("C Cased_Letter Cc Cf Close_Punctuation Cn Co Combining_Mark Connector_Punctuation Control Cs Currency_Symbol Dash_Punctuation Decimal_Number Enclosing_Mark Final_Punctuation Format Initial_Punctuation L LC Letter Letter_Number Line_Separator Ll Lm Lo Lowercase_Letter Lt Lu M Mark Math_Symbol Mc Me Mn Modifier_Letter Modifier_Symbol N Nd Nl No Nonspacing_Mark Number Open_Punctuation Other Other_Letter Other_Number Other_Punctuation Other_Symbol P Paragraph_Separator Pc Pd Pe Pf Pi Po Private_Use Ps Punctuation S Sc Separator Sk Sm So Space_Separator Spacing_Mark Surrogate Symbol Titlecase_Letter Unassigned Uppercase_Letter Z Zl Zp Zs cntrl digit punct", "", "", "", "", "", "");
    var scValueSets = new DataSet("Adlam Adlm Aghb Ahom Anatolian_Hieroglyphs Arab Arabic Armenian Armi Armn Avestan Avst Bali Balinese Bamu Bamum Bass Bassa_Vah Batak Batk Beng Bengali Bhaiksuki Bhks Bopo Bopomofo Brah Brahmi Brai Braille Bugi Buginese Buhd Buhid Cakm Canadian_Aboriginal Cans Cari Carian Caucasian_Albanian Chakma Cham Cher Cherokee Common Copt Coptic Cprt Cuneiform Cypriot Cyrillic Cyrl Deseret Deva Devanagari Dsrt Dupl Duployan Egyp Egyptian_Hieroglyphs Elba Elbasan Ethi Ethiopic Geor Georgian Glag Glagolitic Gonm Goth Gothic Gran Grantha Greek Grek Gujarati Gujr Gurmukhi Guru Han Hang Hangul Hani Hano Hanunoo Hatr Hatran Hebr Hebrew Hira Hiragana Hluw Hmng Hung Imperial_Aramaic Inherited Inscriptional_Pahlavi Inscriptional_Parthian Ital Java Javanese Kaithi Kali Kana Kannada Katakana Kayah_Li Khar Kharoshthi Khmer Khmr Khoj Khojki Khudawadi Knda Kthi Lana Lao Laoo Latin Latn Lepc Lepcha Limb Limbu Lina Linb Linear_A Linear_B Lisu Lyci Lycian Lydi Lydian Mahajani Mahj Malayalam Mand Mandaic Mani Manichaean Marc Marchen Masaram_Gondi Meetei_Mayek Mend Mende_Kikakui Merc Mero Meroitic_Cursive Meroitic_Hieroglyphs Miao Mlym Modi Mong Mongolian Mro Mroo Mtei Mult Multani Myanmar Mymr Nabataean Narb Nbat New_Tai_Lue Newa Nko Nkoo Nshu Nushu Ogam Ogham Ol_Chiki Olck Old_Hungarian Old_Italic Old_North_Arabian Old_Permic Old_Persian Old_South_Arabian Old_Turkic Oriya Orkh Orya Osage Osge Osma Osmanya Pahawh_Hmong Palm Palmyrene Pau_Cin_Hau Pauc Perm Phag Phags_Pa Phli Phlp Phnx Phoenician Plrd Prti Psalter_Pahlavi Qaac Qaai Rejang Rjng Runic Runr Samaritan Samr Sarb Saur Saurashtra Sgnw Sharada Shavian Shaw Shrd Sidd Siddham SignWriting Sind Sinh Sinhala Sora Sora_Sompeng Soyo Soyombo Sund Sundanese Sylo Syloti_Nagri Syrc Syriac Tagalog Tagb Tagbanwa Tai_Le Tai_Tham Tai_Viet Takr Takri Tale Talu Tamil Taml Tang Tangut Tavt Telu Telugu Tfng Tglg Thaa Thaana Thai Tibetan Tibt Tifinagh Tirh Tirhuta Ugar Ugaritic Vai Vaii Wara Warang_Citi Xpeo Xsux Yi Yiii Zanabazar_Square Zanb Zinh Zyyy", "Dogr Dogra Gong Gunjala_Gondi Hanifi_Rohingya Maka Makasar Medefaidrin Medf Old_Sogdian Rohg Sogd Sogdian Sogo", "Elym Elymaic Hmnp Nand Nandinagari Nyiakeng_Puachue_Hmong Wancho Wcho", "Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi", "Cpmn Cypro_Minoan Old_Uyghur Ougr Tangsa Tnsa Toto Vith Vithkuqi", "Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz", "");
    var binPropertySets = new DataSet("AHex ASCII ASCII_Hex_Digit Alpha Alphabetic Any Assigned Bidi_C Bidi_Control Bidi_M Bidi_Mirrored CI CWCF CWCM CWKCF CWL CWT CWU Case_Ignorable Cased Changes_When_Casefolded Changes_When_Casemapped Changes_When_Lowercased Changes_When_NFKC_Casefolded Changes_When_Titlecased Changes_When_Uppercased DI Dash Default_Ignorable_Code_Point Dep Deprecated Dia Diacritic Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Ext Extender Gr_Base Gr_Ext Grapheme_Base Grapheme_Extend Hex Hex_Digit IDC IDS IDSB IDST IDS_Binary_Operator IDS_Trinary_Operator ID_Continue ID_Start Ideo Ideographic Join_C Join_Control LOE Logical_Order_Exception Lower Lowercase Math NChar Noncharacter_Code_Point Pat_Syn Pat_WS Pattern_Syntax Pattern_White_Space QMark Quotation_Mark RI Radical Regional_Indicator SD STerm Sentence_Terminal Soft_Dotted Term Terminal_Punctuation UIdeo Unified_Ideograph Upper Uppercase VS Variation_Selector White_Space XIDC XIDS XID_Continue XID_Start space", "Extended_Pictographic", "", "EBase EComp EMod EPres ExtPict", "", "", "");
    function isValidUnicodeProperty(version, name, value) {
      if (gcNameSet.has(name)) {
        return version >= 2018 && gcValueSets.es2018.has(value);
      }
      if (scNameSet.has(name)) {
        return version >= 2018 && scValueSets.es2018.has(value) || version >= 2019 && scValueSets.es2019.has(value) || version >= 2020 && scValueSets.es2020.has(value) || version >= 2021 && scValueSets.es2021.has(value) || version >= 2022 && scValueSets.es2022.has(value) || version >= 2023 && scValueSets.es2023.has(value);
      }
      return false;
    }
    function isValidLoneUnicodeProperty(version, value) {
      return version >= 2018 && binPropertySets.es2018.has(value) || version >= 2019 && binPropertySets.es2019.has(value) || version >= 2021 && binPropertySets.es2021.has(value);
    }
    var BACKSPACE = 8;
    var CHARACTER_TABULATION = 9;
    var LINE_FEED = 10;
    var LINE_TABULATION = 11;
    var FORM_FEED = 12;
    var CARRIAGE_RETURN = 13;
    var EXCLAMATION_MARK = 33;
    var DOLLAR_SIGN = 36;
    var LEFT_PARENTHESIS = 40;
    var RIGHT_PARENTHESIS = 41;
    var ASTERISK = 42;
    var PLUS_SIGN = 43;
    var COMMA = 44;
    var HYPHEN_MINUS = 45;
    var FULL_STOP = 46;
    var SOLIDUS = 47;
    var DIGIT_ZERO = 48;
    var DIGIT_ONE = 49;
    var DIGIT_SEVEN = 55;
    var DIGIT_NINE = 57;
    var COLON = 58;
    var LESS_THAN_SIGN = 60;
    var EQUALS_SIGN = 61;
    var GREATER_THAN_SIGN = 62;
    var QUESTION_MARK = 63;
    var LATIN_CAPITAL_LETTER_A = 65;
    var LATIN_CAPITAL_LETTER_B = 66;
    var LATIN_CAPITAL_LETTER_D = 68;
    var LATIN_CAPITAL_LETTER_F = 70;
    var LATIN_CAPITAL_LETTER_P = 80;
    var LATIN_CAPITAL_LETTER_S = 83;
    var LATIN_CAPITAL_LETTER_W = 87;
    var LATIN_CAPITAL_LETTER_Z = 90;
    var LOW_LINE = 95;
    var LATIN_SMALL_LETTER_A = 97;
    var LATIN_SMALL_LETTER_B = 98;
    var LATIN_SMALL_LETTER_C = 99;
    var LATIN_SMALL_LETTER_D = 100;
    var LATIN_SMALL_LETTER_F = 102;
    var LATIN_SMALL_LETTER_G = 103;
    var LATIN_SMALL_LETTER_I = 105;
    var LATIN_SMALL_LETTER_K = 107;
    var LATIN_SMALL_LETTER_M = 109;
    var LATIN_SMALL_LETTER_N = 110;
    var LATIN_SMALL_LETTER_P = 112;
    var LATIN_SMALL_LETTER_R = 114;
    var LATIN_SMALL_LETTER_S = 115;
    var LATIN_SMALL_LETTER_T = 116;
    var LATIN_SMALL_LETTER_U = 117;
    var LATIN_SMALL_LETTER_V = 118;
    var LATIN_SMALL_LETTER_W = 119;
    var LATIN_SMALL_LETTER_X = 120;
    var LATIN_SMALL_LETTER_Y = 121;
    var LATIN_SMALL_LETTER_Z = 122;
    var LEFT_SQUARE_BRACKET = 91;
    var REVERSE_SOLIDUS = 92;
    var RIGHT_SQUARE_BRACKET = 93;
    var CIRCUMFLEX_ACCENT = 94;
    var LEFT_CURLY_BRACKET = 123;
    var VERTICAL_LINE = 124;
    var RIGHT_CURLY_BRACKET = 125;
    var ZERO_WIDTH_NON_JOINER = 8204;
    var ZERO_WIDTH_JOINER = 8205;
    var LINE_SEPARATOR = 8232;
    var PARAGRAPH_SEPARATOR = 8233;
    var MIN_CODE_POINT = 0;
    var MAX_CODE_POINT = 1114111;
    function isLatinLetter(code) {
      return code >= LATIN_CAPITAL_LETTER_A && code <= LATIN_CAPITAL_LETTER_Z || code >= LATIN_SMALL_LETTER_A && code <= LATIN_SMALL_LETTER_Z;
    }
    function isDecimalDigit(code) {
      return code >= DIGIT_ZERO && code <= DIGIT_NINE;
    }
    function isOctalDigit(code) {
      return code >= DIGIT_ZERO && code <= DIGIT_SEVEN;
    }
    function isHexDigit(code) {
      return code >= DIGIT_ZERO && code <= DIGIT_NINE || code >= LATIN_CAPITAL_LETTER_A && code <= LATIN_CAPITAL_LETTER_F || code >= LATIN_SMALL_LETTER_A && code <= LATIN_SMALL_LETTER_F;
    }
    function isLineTerminator(code) {
      return code === LINE_FEED || code === CARRIAGE_RETURN || code === LINE_SEPARATOR || code === PARAGRAPH_SEPARATOR;
    }
    function isValidUnicode(code) {
      return code >= MIN_CODE_POINT && code <= MAX_CODE_POINT;
    }
    function digitToInt(code) {
      if (code >= LATIN_SMALL_LETTER_A && code <= LATIN_SMALL_LETTER_F) {
        return code - LATIN_SMALL_LETTER_A + 10;
      }
      if (code >= LATIN_CAPITAL_LETTER_A && code <= LATIN_CAPITAL_LETTER_F) {
        return code - LATIN_CAPITAL_LETTER_A + 10;
      }
      return code - DIGIT_ZERO;
    }
    function isLeadSurrogate(code) {
      return code >= 55296 && code <= 56319;
    }
    function isTrailSurrogate(code) {
      return code >= 56320 && code <= 57343;
    }
    function combineSurrogatePair(lead, trail) {
      return (lead - 55296) * 1024 + (trail - 56320) + 65536;
    }
    var legacyImpl = {
      at(s, end, i) {
        return i < end ? s.charCodeAt(i) : -1;
      },
      width(c) {
        return 1;
      }
    };
    var unicodeImpl = {
      at(s, end, i) {
        return i < end ? s.codePointAt(i) : -1;
      },
      width(c) {
        return c > 65535 ? 2 : 1;
      }
    };
    var Reader = class {
      constructor() {
        this._impl = legacyImpl;
        this._s = "";
        this._i = 0;
        this._end = 0;
        this._cp1 = -1;
        this._w1 = 1;
        this._cp2 = -1;
        this._w2 = 1;
        this._cp3 = -1;
        this._w3 = 1;
        this._cp4 = -1;
      }
      get source() {
        return this._s;
      }
      get index() {
        return this._i;
      }
      get currentCodePoint() {
        return this._cp1;
      }
      get nextCodePoint() {
        return this._cp2;
      }
      get nextCodePoint2() {
        return this._cp3;
      }
      get nextCodePoint3() {
        return this._cp4;
      }
      reset(source, start, end, uFlag) {
        this._impl = uFlag ? unicodeImpl : legacyImpl;
        this._s = source;
        this._end = end;
        this.rewind(start);
      }
      rewind(index) {
        const impl = this._impl;
        this._i = index;
        this._cp1 = impl.at(this._s, this._end, index);
        this._w1 = impl.width(this._cp1);
        this._cp2 = impl.at(this._s, this._end, index + this._w1);
        this._w2 = impl.width(this._cp2);
        this._cp3 = impl.at(this._s, this._end, index + this._w1 + this._w2);
        this._w3 = impl.width(this._cp3);
        this._cp4 = impl.at(this._s, this._end, index + this._w1 + this._w2 + this._w3);
      }
      advance() {
        if (this._cp1 !== -1) {
          const impl = this._impl;
          this._i += this._w1;
          this._cp1 = this._cp2;
          this._w1 = this._w2;
          this._cp2 = this._cp3;
          this._w2 = impl.width(this._cp2);
          this._cp3 = this._cp4;
          this._w3 = impl.width(this._cp3);
          this._cp4 = impl.at(this._s, this._end, this._i + this._w1 + this._w2 + this._w3);
        }
      }
      eat(cp) {
        if (this._cp1 === cp) {
          this.advance();
          return true;
        }
        return false;
      }
      eat2(cp1, cp2) {
        if (this._cp1 === cp1 && this._cp2 === cp2) {
          this.advance();
          this.advance();
          return true;
        }
        return false;
      }
      eat3(cp1, cp2, cp3) {
        if (this._cp1 === cp1 && this._cp2 === cp2 && this._cp3 === cp3) {
          this.advance();
          this.advance();
          this.advance();
          return true;
        }
        return false;
      }
    };
    var RegExpSyntaxError = class extends SyntaxError {
      constructor(source, uFlag, index, message) {
        if (source) {
          if (!source.startsWith("/")) {
            source = `/${source}/${uFlag ? "u" : ""}`;
          }
          source = `: ${source}`;
        }
        super(`Invalid regular expression${source}: ${message}`);
        this.index = index;
      }
    };
    function isSyntaxCharacter(cp) {
      return cp === CIRCUMFLEX_ACCENT || cp === DOLLAR_SIGN || cp === REVERSE_SOLIDUS || cp === FULL_STOP || cp === ASTERISK || cp === PLUS_SIGN || cp === QUESTION_MARK || cp === LEFT_PARENTHESIS || cp === RIGHT_PARENTHESIS || cp === LEFT_SQUARE_BRACKET || cp === RIGHT_SQUARE_BRACKET || cp === LEFT_CURLY_BRACKET || cp === RIGHT_CURLY_BRACKET || cp === VERTICAL_LINE;
    }
    function isRegExpIdentifierStart(cp) {
      return isIdStart(cp) || cp === DOLLAR_SIGN || cp === LOW_LINE;
    }
    function isRegExpIdentifierPart(cp) {
      return isIdContinue(cp) || cp === DOLLAR_SIGN || cp === LOW_LINE || cp === ZERO_WIDTH_NON_JOINER || cp === ZERO_WIDTH_JOINER;
    }
    function isUnicodePropertyNameCharacter(cp) {
      return isLatinLetter(cp) || cp === LOW_LINE;
    }
    function isUnicodePropertyValueCharacter(cp) {
      return isUnicodePropertyNameCharacter(cp) || isDecimalDigit(cp);
    }
    var RegExpValidator = class {
      constructor(options) {
        this._reader = new Reader();
        this._uFlag = false;
        this._nFlag = false;
        this._lastIntValue = 0;
        this._lastMinValue = 0;
        this._lastMaxValue = 0;
        this._lastStrValue = "";
        this._lastKeyValue = "";
        this._lastValValue = "";
        this._lastAssertionIsQuantifiable = false;
        this._numCapturingParens = 0;
        this._groupNames = /* @__PURE__ */ new Set();
        this._backreferenceNames = /* @__PURE__ */ new Set();
        this._options = options !== null && options !== void 0 ? options : {};
      }
      validateLiteral(source, start = 0, end = source.length) {
        this._uFlag = this._nFlag = false;
        this.reset(source, start, end);
        this.onLiteralEnter(start);
        if (this.eat(SOLIDUS) && this.eatRegExpBody() && this.eat(SOLIDUS)) {
          const flagStart = this.index;
          const uFlag = source.includes("u", flagStart);
          this.validateFlags(source, flagStart, end);
          this.validatePattern(source, start + 1, flagStart - 1, uFlag);
        } else if (start >= end) {
          this.raise("Empty");
        } else {
          const c = String.fromCodePoint(this.currentCodePoint);
          this.raise(`Unexpected character '${c}'`);
        }
        this.onLiteralLeave(start, end);
      }
      validateFlags(source, start = 0, end = source.length) {
        const existingFlags = /* @__PURE__ */ new Set();
        let global2 = false;
        let ignoreCase = false;
        let multiline = false;
        let sticky = false;
        let unicode = false;
        let dotAll = false;
        let hasIndices = false;
        for (let i = start; i < end; ++i) {
          const flag = source.charCodeAt(i);
          if (existingFlags.has(flag)) {
            this.raise(`Duplicated flag '${source[i]}'`);
          }
          existingFlags.add(flag);
          if (flag === LATIN_SMALL_LETTER_G) {
            global2 = true;
          } else if (flag === LATIN_SMALL_LETTER_I) {
            ignoreCase = true;
          } else if (flag === LATIN_SMALL_LETTER_M) {
            multiline = true;
          } else if (flag === LATIN_SMALL_LETTER_U && this.ecmaVersion >= 2015) {
            unicode = true;
          } else if (flag === LATIN_SMALL_LETTER_Y && this.ecmaVersion >= 2015) {
            sticky = true;
          } else if (flag === LATIN_SMALL_LETTER_S && this.ecmaVersion >= 2018) {
            dotAll = true;
          } else if (flag === LATIN_SMALL_LETTER_D && this.ecmaVersion >= 2022) {
            hasIndices = true;
          } else {
            this.raise(`Invalid flag '${source[i]}'`);
          }
        }
        this.onRegExpFlags(start, end, {
          global: global2,
          ignoreCase,
          multiline,
          unicode,
          sticky,
          dotAll,
          hasIndices
        });
      }
      validatePattern(source, start = 0, end = source.length, uFlag = false) {
        this._uFlag = uFlag && this.ecmaVersion >= 2015;
        this._nFlag = uFlag && this.ecmaVersion >= 2018 || Boolean(this._options.strict && this.ecmaVersion >= 2023);
        this.reset(source, start, end);
        this.consumePattern();
        if (!this._nFlag && this.ecmaVersion >= 2018 && this._groupNames.size > 0) {
          this._nFlag = true;
          this.rewind(start);
          this.consumePattern();
        }
      }
      get strict() {
        return Boolean(this._options.strict) || this._uFlag;
      }
      get ecmaVersion() {
        var _a;
        return (_a = this._options.ecmaVersion) !== null && _a !== void 0 ? _a : 2023;
      }
      onLiteralEnter(start) {
        if (this._options.onLiteralEnter) {
          this._options.onLiteralEnter(start);
        }
      }
      onLiteralLeave(start, end) {
        if (this._options.onLiteralLeave) {
          this._options.onLiteralLeave(start, end);
        }
      }
      onRegExpFlags(start, end, flags) {
        if (this._options.onRegExpFlags) {
          this._options.onRegExpFlags(start, end, flags);
        }
        if (this._options.onFlags) {
          this._options.onFlags(start, end, flags.global, flags.ignoreCase, flags.multiline, flags.unicode, flags.sticky, flags.dotAll, flags.hasIndices);
        }
      }
      onPatternEnter(start) {
        if (this._options.onPatternEnter) {
          this._options.onPatternEnter(start);
        }
      }
      onPatternLeave(start, end) {
        if (this._options.onPatternLeave) {
          this._options.onPatternLeave(start, end);
        }
      }
      onDisjunctionEnter(start) {
        if (this._options.onDisjunctionEnter) {
          this._options.onDisjunctionEnter(start);
        }
      }
      onDisjunctionLeave(start, end) {
        if (this._options.onDisjunctionLeave) {
          this._options.onDisjunctionLeave(start, end);
        }
      }
      onAlternativeEnter(start, index) {
        if (this._options.onAlternativeEnter) {
          this._options.onAlternativeEnter(start, index);
        }
      }
      onAlternativeLeave(start, end, index) {
        if (this._options.onAlternativeLeave) {
          this._options.onAlternativeLeave(start, end, index);
        }
      }
      onGroupEnter(start) {
        if (this._options.onGroupEnter) {
          this._options.onGroupEnter(start);
        }
      }
      onGroupLeave(start, end) {
        if (this._options.onGroupLeave) {
          this._options.onGroupLeave(start, end);
        }
      }
      onCapturingGroupEnter(start, name) {
        if (this._options.onCapturingGroupEnter) {
          this._options.onCapturingGroupEnter(start, name);
        }
      }
      onCapturingGroupLeave(start, end, name) {
        if (this._options.onCapturingGroupLeave) {
          this._options.onCapturingGroupLeave(start, end, name);
        }
      }
      onQuantifier(start, end, min, max, greedy) {
        if (this._options.onQuantifier) {
          this._options.onQuantifier(start, end, min, max, greedy);
        }
      }
      onLookaroundAssertionEnter(start, kind, negate) {
        if (this._options.onLookaroundAssertionEnter) {
          this._options.onLookaroundAssertionEnter(start, kind, negate);
        }
      }
      onLookaroundAssertionLeave(start, end, kind, negate) {
        if (this._options.onLookaroundAssertionLeave) {
          this._options.onLookaroundAssertionLeave(start, end, kind, negate);
        }
      }
      onEdgeAssertion(start, end, kind) {
        if (this._options.onEdgeAssertion) {
          this._options.onEdgeAssertion(start, end, kind);
        }
      }
      onWordBoundaryAssertion(start, end, kind, negate) {
        if (this._options.onWordBoundaryAssertion) {
          this._options.onWordBoundaryAssertion(start, end, kind, negate);
        }
      }
      onAnyCharacterSet(start, end, kind) {
        if (this._options.onAnyCharacterSet) {
          this._options.onAnyCharacterSet(start, end, kind);
        }
      }
      onEscapeCharacterSet(start, end, kind, negate) {
        if (this._options.onEscapeCharacterSet) {
          this._options.onEscapeCharacterSet(start, end, kind, negate);
        }
      }
      onUnicodePropertyCharacterSet(start, end, kind, key, value, negate) {
        if (this._options.onUnicodePropertyCharacterSet) {
          this._options.onUnicodePropertyCharacterSet(start, end, kind, key, value, negate);
        }
      }
      onCharacter(start, end, value) {
        if (this._options.onCharacter) {
          this._options.onCharacter(start, end, value);
        }
      }
      onBackreference(start, end, ref) {
        if (this._options.onBackreference) {
          this._options.onBackreference(start, end, ref);
        }
      }
      onCharacterClassEnter(start, negate) {
        if (this._options.onCharacterClassEnter) {
          this._options.onCharacterClassEnter(start, negate);
        }
      }
      onCharacterClassLeave(start, end, negate) {
        if (this._options.onCharacterClassLeave) {
          this._options.onCharacterClassLeave(start, end, negate);
        }
      }
      onCharacterClassRange(start, end, min, max) {
        if (this._options.onCharacterClassRange) {
          this._options.onCharacterClassRange(start, end, min, max);
        }
      }
      get source() {
        return this._reader.source;
      }
      get index() {
        return this._reader.index;
      }
      get currentCodePoint() {
        return this._reader.currentCodePoint;
      }
      get nextCodePoint() {
        return this._reader.nextCodePoint;
      }
      get nextCodePoint2() {
        return this._reader.nextCodePoint2;
      }
      get nextCodePoint3() {
        return this._reader.nextCodePoint3;
      }
      reset(source, start, end) {
        this._reader.reset(source, start, end, this._uFlag);
      }
      rewind(index) {
        this._reader.rewind(index);
      }
      advance() {
        this._reader.advance();
      }
      eat(cp) {
        return this._reader.eat(cp);
      }
      eat2(cp1, cp2) {
        return this._reader.eat2(cp1, cp2);
      }
      eat3(cp1, cp2, cp3) {
        return this._reader.eat3(cp1, cp2, cp3);
      }
      raise(message) {
        throw new RegExpSyntaxError(this.source, this._uFlag, this.index, message);
      }
      eatRegExpBody() {
        const start = this.index;
        let inClass = false;
        let escaped = false;
        for (; ; ) {
          const cp = this.currentCodePoint;
          if (cp === -1 || isLineTerminator(cp)) {
            const kind = inClass ? "character class" : "regular expression";
            this.raise(`Unterminated ${kind}`);
          }
          if (escaped) {
            escaped = false;
          } else if (cp === REVERSE_SOLIDUS) {
            escaped = true;
          } else if (cp === LEFT_SQUARE_BRACKET) {
            inClass = true;
          } else if (cp === RIGHT_SQUARE_BRACKET) {
            inClass = false;
          } else if (cp === SOLIDUS && !inClass || cp === ASTERISK && this.index === start) {
            break;
          }
          this.advance();
        }
        return this.index !== start;
      }
      consumePattern() {
        const start = this.index;
        this._numCapturingParens = this.countCapturingParens();
        this._groupNames.clear();
        this._backreferenceNames.clear();
        this.onPatternEnter(start);
        this.consumeDisjunction();
        const cp = this.currentCodePoint;
        if (this.currentCodePoint !== -1) {
          if (cp === RIGHT_PARENTHESIS) {
            this.raise("Unmatched ')'");
          }
          if (cp === REVERSE_SOLIDUS) {
            this.raise("\\ at end of pattern");
          }
          if (cp === RIGHT_SQUARE_BRACKET || cp === RIGHT_CURLY_BRACKET) {
            this.raise("Lone quantifier brackets");
          }
          const c = String.fromCodePoint(cp);
          this.raise(`Unexpected character '${c}'`);
        }
        for (const name of this._backreferenceNames) {
          if (!this._groupNames.has(name)) {
            this.raise("Invalid named capture referenced");
          }
        }
        this.onPatternLeave(start, this.index);
      }
      countCapturingParens() {
        const start = this.index;
        let inClass = false;
        let escaped = false;
        let count = 0;
        let cp = 0;
        while ((cp = this.currentCodePoint) !== -1) {
          if (escaped) {
            escaped = false;
          } else if (cp === REVERSE_SOLIDUS) {
            escaped = true;
          } else if (cp === LEFT_SQUARE_BRACKET) {
            inClass = true;
          } else if (cp === RIGHT_SQUARE_BRACKET) {
            inClass = false;
          } else if (cp === LEFT_PARENTHESIS && !inClass && (this.nextCodePoint !== QUESTION_MARK || this.nextCodePoint2 === LESS_THAN_SIGN && this.nextCodePoint3 !== EQUALS_SIGN && this.nextCodePoint3 !== EXCLAMATION_MARK)) {
            count += 1;
          }
          this.advance();
        }
        this.rewind(start);
        return count;
      }
      consumeDisjunction() {
        const start = this.index;
        let i = 0;
        this.onDisjunctionEnter(start);
        do {
          this.consumeAlternative(i++);
        } while (this.eat(VERTICAL_LINE));
        if (this.consumeQuantifier(true)) {
          this.raise("Nothing to repeat");
        }
        if (this.eat(LEFT_CURLY_BRACKET)) {
          this.raise("Lone quantifier brackets");
        }
        this.onDisjunctionLeave(start, this.index);
      }
      consumeAlternative(i) {
        const start = this.index;
        this.onAlternativeEnter(start, i);
        while (this.currentCodePoint !== -1 && this.consumeTerm()) {
        }
        this.onAlternativeLeave(start, this.index, i);
      }
      consumeTerm() {
        if (this._uFlag || this.strict) {
          return this.consumeAssertion() || this.consumeAtom() && this.consumeOptionalQuantifier();
        }
        return this.consumeAssertion() && (!this._lastAssertionIsQuantifiable || this.consumeOptionalQuantifier()) || this.consumeExtendedAtom() && this.consumeOptionalQuantifier();
      }
      consumeOptionalQuantifier() {
        this.consumeQuantifier();
        return true;
      }
      consumeAssertion() {
        const start = this.index;
        this._lastAssertionIsQuantifiable = false;
        if (this.eat(CIRCUMFLEX_ACCENT)) {
          this.onEdgeAssertion(start, this.index, "start");
          return true;
        }
        if (this.eat(DOLLAR_SIGN)) {
          this.onEdgeAssertion(start, this.index, "end");
          return true;
        }
        if (this.eat2(REVERSE_SOLIDUS, LATIN_CAPITAL_LETTER_B)) {
          this.onWordBoundaryAssertion(start, this.index, "word", true);
          return true;
        }
        if (this.eat2(REVERSE_SOLIDUS, LATIN_SMALL_LETTER_B)) {
          this.onWordBoundaryAssertion(start, this.index, "word", false);
          return true;
        }
        if (this.eat2(LEFT_PARENTHESIS, QUESTION_MARK)) {
          const lookbehind = this.ecmaVersion >= 2018 && this.eat(LESS_THAN_SIGN);
          let negate = false;
          if (this.eat(EQUALS_SIGN) || (negate = this.eat(EXCLAMATION_MARK))) {
            const kind = lookbehind ? "lookbehind" : "lookahead";
            this.onLookaroundAssertionEnter(start, kind, negate);
            this.consumeDisjunction();
            if (!this.eat(RIGHT_PARENTHESIS)) {
              this.raise("Unterminated group");
            }
            this._lastAssertionIsQuantifiable = !lookbehind && !this.strict;
            this.onLookaroundAssertionLeave(start, this.index, kind, negate);
            return true;
          }
          this.rewind(start);
        }
        return false;
      }
      consumeQuantifier(noConsume = false) {
        const start = this.index;
        let min = 0;
        let max = 0;
        let greedy = false;
        if (this.eat(ASTERISK)) {
          min = 0;
          max = Number.POSITIVE_INFINITY;
        } else if (this.eat(PLUS_SIGN)) {
          min = 1;
          max = Number.POSITIVE_INFINITY;
        } else if (this.eat(QUESTION_MARK)) {
          min = 0;
          max = 1;
        } else if (this.eatBracedQuantifier(noConsume)) {
          min = this._lastMinValue;
          max = this._lastMaxValue;
        } else {
          return false;
        }
        greedy = !this.eat(QUESTION_MARK);
        if (!noConsume) {
          this.onQuantifier(start, this.index, min, max, greedy);
        }
        return true;
      }
      eatBracedQuantifier(noError) {
        const start = this.index;
        if (this.eat(LEFT_CURLY_BRACKET)) {
          this._lastMinValue = 0;
          this._lastMaxValue = Number.POSITIVE_INFINITY;
          if (this.eatDecimalDigits()) {
            this._lastMinValue = this._lastMaxValue = this._lastIntValue;
            if (this.eat(COMMA)) {
              this._lastMaxValue = this.eatDecimalDigits() ? this._lastIntValue : Number.POSITIVE_INFINITY;
            }
            if (this.eat(RIGHT_CURLY_BRACKET)) {
              if (!noError && this._lastMaxValue < this._lastMinValue) {
                this.raise("numbers out of order in {} quantifier");
              }
              return true;
            }
          }
          if (!noError && (this._uFlag || this.strict)) {
            this.raise("Incomplete quantifier");
          }
          this.rewind(start);
        }
        return false;
      }
      consumeAtom() {
        return this.consumePatternCharacter() || this.consumeDot() || this.consumeReverseSolidusAtomEscape() || this.consumeCharacterClass() || this.consumeUncapturingGroup() || this.consumeCapturingGroup();
      }
      consumeDot() {
        if (this.eat(FULL_STOP)) {
          this.onAnyCharacterSet(this.index - 1, this.index, "any");
          return true;
        }
        return false;
      }
      consumeReverseSolidusAtomEscape() {
        const start = this.index;
        if (this.eat(REVERSE_SOLIDUS)) {
          if (this.consumeAtomEscape()) {
            return true;
          }
          this.rewind(start);
        }
        return false;
      }
      consumeUncapturingGroup() {
        const start = this.index;
        if (this.eat3(LEFT_PARENTHESIS, QUESTION_MARK, COLON)) {
          this.onGroupEnter(start);
          this.consumeDisjunction();
          if (!this.eat(RIGHT_PARENTHESIS)) {
            this.raise("Unterminated group");
          }
          this.onGroupLeave(start, this.index);
          return true;
        }
        return false;
      }
      consumeCapturingGroup() {
        const start = this.index;
        if (this.eat(LEFT_PARENTHESIS)) {
          let name = null;
          if (this.ecmaVersion >= 2018) {
            if (this.consumeGroupSpecifier()) {
              name = this._lastStrValue;
            }
          } else if (this.currentCodePoint === QUESTION_MARK) {
            this.raise("Invalid group");
          }
          this.onCapturingGroupEnter(start, name);
          this.consumeDisjunction();
          if (!this.eat(RIGHT_PARENTHESIS)) {
            this.raise("Unterminated group");
          }
          this.onCapturingGroupLeave(start, this.index, name);
          return true;
        }
        return false;
      }
      consumeExtendedAtom() {
        return this.consumeDot() || this.consumeReverseSolidusAtomEscape() || this.consumeReverseSolidusFollowedByC() || this.consumeCharacterClass() || this.consumeUncapturingGroup() || this.consumeCapturingGroup() || this.consumeInvalidBracedQuantifier() || this.consumeExtendedPatternCharacter();
      }
      consumeReverseSolidusFollowedByC() {
        const start = this.index;
        if (this.currentCodePoint === REVERSE_SOLIDUS && this.nextCodePoint === LATIN_SMALL_LETTER_C) {
          this._lastIntValue = this.currentCodePoint;
          this.advance();
          this.onCharacter(start, this.index, REVERSE_SOLIDUS);
          return true;
        }
        return false;
      }
      consumeInvalidBracedQuantifier() {
        if (this.eatBracedQuantifier(true)) {
          this.raise("Nothing to repeat");
        }
        return false;
      }
      consumePatternCharacter() {
        const start = this.index;
        const cp = this.currentCodePoint;
        if (cp !== -1 && !isSyntaxCharacter(cp)) {
          this.advance();
          this.onCharacter(start, this.index, cp);
          return true;
        }
        return false;
      }
      consumeExtendedPatternCharacter() {
        const start = this.index;
        const cp = this.currentCodePoint;
        if (cp !== -1 && cp !== CIRCUMFLEX_ACCENT && cp !== DOLLAR_SIGN && cp !== REVERSE_SOLIDUS && cp !== FULL_STOP && cp !== ASTERISK && cp !== PLUS_SIGN && cp !== QUESTION_MARK && cp !== LEFT_PARENTHESIS && cp !== RIGHT_PARENTHESIS && cp !== LEFT_SQUARE_BRACKET && cp !== VERTICAL_LINE) {
          this.advance();
          this.onCharacter(start, this.index, cp);
          return true;
        }
        return false;
      }
      consumeGroupSpecifier() {
        if (this.eat(QUESTION_MARK)) {
          if (this.eatGroupName()) {
            if (!this._groupNames.has(this._lastStrValue)) {
              this._groupNames.add(this._lastStrValue);
              return true;
            }
            this.raise("Duplicate capture group name");
          }
          this.raise("Invalid group");
        }
        return false;
      }
      consumeAtomEscape() {
        if (this.consumeBackreference() || this.consumeCharacterClassEscape() || this.consumeCharacterEscape() || this._nFlag && this.consumeKGroupName()) {
          return true;
        }
        if (this.strict || this._uFlag) {
          this.raise("Invalid escape");
        }
        return false;
      }
      consumeBackreference() {
        const start = this.index;
        if (this.eatDecimalEscape()) {
          const n = this._lastIntValue;
          if (n <= this._numCapturingParens) {
            this.onBackreference(start - 1, this.index, n);
            return true;
          }
          if (this.strict || this._uFlag) {
            this.raise("Invalid escape");
          }
          this.rewind(start);
        }
        return false;
      }
      consumeCharacterClassEscape() {
        const start = this.index;
        if (this.eat(LATIN_SMALL_LETTER_D)) {
          this._lastIntValue = -1;
          this.onEscapeCharacterSet(start - 1, this.index, "digit", false);
          return true;
        }
        if (this.eat(LATIN_CAPITAL_LETTER_D)) {
          this._lastIntValue = -1;
          this.onEscapeCharacterSet(start - 1, this.index, "digit", true);
          return true;
        }
        if (this.eat(LATIN_SMALL_LETTER_S)) {
          this._lastIntValue = -1;
          this.onEscapeCharacterSet(start - 1, this.index, "space", false);
          return true;
        }
        if (this.eat(LATIN_CAPITAL_LETTER_S)) {
          this._lastIntValue = -1;
          this.onEscapeCharacterSet(start - 1, this.index, "space", true);
          return true;
        }
        if (this.eat(LATIN_SMALL_LETTER_W)) {
          this._lastIntValue = -1;
          this.onEscapeCharacterSet(start - 1, this.index, "word", false);
          return true;
        }
        if (this.eat(LATIN_CAPITAL_LETTER_W)) {
          this._lastIntValue = -1;
          this.onEscapeCharacterSet(start - 1, this.index, "word", true);
          return true;
        }
        let negate = false;
        if (this._uFlag && this.ecmaVersion >= 2018 && (this.eat(LATIN_SMALL_LETTER_P) || (negate = this.eat(LATIN_CAPITAL_LETTER_P)))) {
          this._lastIntValue = -1;
          if (this.eat(LEFT_CURLY_BRACKET) && this.eatUnicodePropertyValueExpression() && this.eat(RIGHT_CURLY_BRACKET)) {
            this.onUnicodePropertyCharacterSet(start - 1, this.index, "property", this._lastKeyValue, this._lastValValue || null, negate);
            return true;
          }
          this.raise("Invalid property name");
        }
        return false;
      }
      consumeCharacterEscape() {
        const start = this.index;
        if (this.eatControlEscape() || this.eatCControlLetter() || this.eatZero() || this.eatHexEscapeSequence() || this.eatRegExpUnicodeEscapeSequence() || !this.strict && !this._uFlag && this.eatLegacyOctalEscapeSequence() || this.eatIdentityEscape()) {
          this.onCharacter(start - 1, this.index, this._lastIntValue);
          return true;
        }
        return false;
      }
      consumeKGroupName() {
        const start = this.index;
        if (this.eat(LATIN_SMALL_LETTER_K)) {
          if (this.eatGroupName()) {
            const groupName = this._lastStrValue;
            this._backreferenceNames.add(groupName);
            this.onBackreference(start - 1, this.index, groupName);
            return true;
          }
          this.raise("Invalid named reference");
        }
        return false;
      }
      consumeCharacterClass() {
        const start = this.index;
        if (this.eat(LEFT_SQUARE_BRACKET)) {
          const negate = this.eat(CIRCUMFLEX_ACCENT);
          this.onCharacterClassEnter(start, negate);
          this.consumeClassRanges();
          if (!this.eat(RIGHT_SQUARE_BRACKET)) {
            this.raise("Unterminated character class");
          }
          this.onCharacterClassLeave(start, this.index, negate);
          return true;
        }
        return false;
      }
      consumeClassRanges() {
        const strict = this.strict || this._uFlag;
        for (; ; ) {
          const rangeStart = this.index;
          if (!this.consumeClassAtom()) {
            break;
          }
          const min = this._lastIntValue;
          if (!this.eat(HYPHEN_MINUS)) {
            continue;
          }
          this.onCharacter(this.index - 1, this.index, HYPHEN_MINUS);
          if (!this.consumeClassAtom()) {
            break;
          }
          const max = this._lastIntValue;
          if (min === -1 || max === -1) {
            if (strict) {
              this.raise("Invalid character class");
            }
            continue;
          }
          if (min > max) {
            this.raise("Range out of order in character class");
          }
          this.onCharacterClassRange(rangeStart, this.index, min, max);
        }
      }
      consumeClassAtom() {
        const start = this.index;
        const cp = this.currentCodePoint;
        if (cp !== -1 && cp !== REVERSE_SOLIDUS && cp !== RIGHT_SQUARE_BRACKET) {
          this.advance();
          this._lastIntValue = cp;
          this.onCharacter(start, this.index, this._lastIntValue);
          return true;
        }
        if (this.eat(REVERSE_SOLIDUS)) {
          if (this.consumeClassEscape()) {
            return true;
          }
          if (!this.strict && this.currentCodePoint === LATIN_SMALL_LETTER_C) {
            this._lastIntValue = REVERSE_SOLIDUS;
            this.onCharacter(start, this.index, this._lastIntValue);
            return true;
          }
          if (this.strict || this._uFlag) {
            this.raise("Invalid escape");
          }
          this.rewind(start);
        }
        return false;
      }
      consumeClassEscape() {
        const start = this.index;
        if (this.eat(LATIN_SMALL_LETTER_B)) {
          this._lastIntValue = BACKSPACE;
          this.onCharacter(start - 1, this.index, this._lastIntValue);
          return true;
        }
        if (this._uFlag && this.eat(HYPHEN_MINUS)) {
          this._lastIntValue = HYPHEN_MINUS;
          this.onCharacter(start - 1, this.index, this._lastIntValue);
          return true;
        }
        let cp = 0;
        if (!this.strict && !this._uFlag && this.currentCodePoint === LATIN_SMALL_LETTER_C && (isDecimalDigit(cp = this.nextCodePoint) || cp === LOW_LINE)) {
          this.advance();
          this.advance();
          this._lastIntValue = cp % 32;
          this.onCharacter(start - 1, this.index, this._lastIntValue);
          return true;
        }
        return this.consumeCharacterClassEscape() || this.consumeCharacterEscape();
      }
      eatGroupName() {
        if (this.eat(LESS_THAN_SIGN)) {
          if (this.eatRegExpIdentifierName() && this.eat(GREATER_THAN_SIGN)) {
            return true;
          }
          this.raise("Invalid capture group name");
        }
        return false;
      }
      eatRegExpIdentifierName() {
        if (this.eatRegExpIdentifierStart()) {
          this._lastStrValue = String.fromCodePoint(this._lastIntValue);
          while (this.eatRegExpIdentifierPart()) {
            this._lastStrValue += String.fromCodePoint(this._lastIntValue);
          }
          return true;
        }
        return false;
      }
      eatRegExpIdentifierStart() {
        const start = this.index;
        const forceUFlag = !this._uFlag && this.ecmaVersion >= 2020;
        let cp = this.currentCodePoint;
        this.advance();
        if (cp === REVERSE_SOLIDUS && this.eatRegExpUnicodeEscapeSequence(forceUFlag)) {
          cp = this._lastIntValue;
        } else if (forceUFlag && isLeadSurrogate(cp) && isTrailSurrogate(this.currentCodePoint)) {
          cp = combineSurrogatePair(cp, this.currentCodePoint);
          this.advance();
        }
        if (isRegExpIdentifierStart(cp)) {
          this._lastIntValue = cp;
          return true;
        }
        if (this.index !== start) {
          this.rewind(start);
        }
        return false;
      }
      eatRegExpIdentifierPart() {
        const start = this.index;
        const forceUFlag = !this._uFlag && this.ecmaVersion >= 2020;
        let cp = this.currentCodePoint;
        this.advance();
        if (cp === REVERSE_SOLIDUS && this.eatRegExpUnicodeEscapeSequence(forceUFlag)) {
          cp = this._lastIntValue;
        } else if (forceUFlag && isLeadSurrogate(cp) && isTrailSurrogate(this.currentCodePoint)) {
          cp = combineSurrogatePair(cp, this.currentCodePoint);
          this.advance();
        }
        if (isRegExpIdentifierPart(cp)) {
          this._lastIntValue = cp;
          return true;
        }
        if (this.index !== start) {
          this.rewind(start);
        }
        return false;
      }
      eatCControlLetter() {
        const start = this.index;
        if (this.eat(LATIN_SMALL_LETTER_C)) {
          if (this.eatControlLetter()) {
            return true;
          }
          this.rewind(start);
        }
        return false;
      }
      eatZero() {
        if (this.currentCodePoint === DIGIT_ZERO && !isDecimalDigit(this.nextCodePoint)) {
          this._lastIntValue = 0;
          this.advance();
          return true;
        }
        return false;
      }
      eatControlEscape() {
        if (this.eat(LATIN_SMALL_LETTER_F)) {
          this._lastIntValue = FORM_FEED;
          return true;
        }
        if (this.eat(LATIN_SMALL_LETTER_N)) {
          this._lastIntValue = LINE_FEED;
          return true;
        }
        if (this.eat(LATIN_SMALL_LETTER_R)) {
          this._lastIntValue = CARRIAGE_RETURN;
          return true;
        }
        if (this.eat(LATIN_SMALL_LETTER_T)) {
          this._lastIntValue = CHARACTER_TABULATION;
          return true;
        }
        if (this.eat(LATIN_SMALL_LETTER_V)) {
          this._lastIntValue = LINE_TABULATION;
          return true;
        }
        return false;
      }
      eatControlLetter() {
        const cp = this.currentCodePoint;
        if (isLatinLetter(cp)) {
          this.advance();
          this._lastIntValue = cp % 32;
          return true;
        }
        return false;
      }
      eatRegExpUnicodeEscapeSequence(forceUFlag = false) {
        const start = this.index;
        const uFlag = forceUFlag || this._uFlag;
        if (this.eat(LATIN_SMALL_LETTER_U)) {
          if (uFlag && this.eatRegExpUnicodeSurrogatePairEscape() || this.eatFixedHexDigits(4) || uFlag && this.eatRegExpUnicodeCodePointEscape()) {
            return true;
          }
          if (this.strict || uFlag) {
            this.raise("Invalid unicode escape");
          }
          this.rewind(start);
        }
        return false;
      }
      eatRegExpUnicodeSurrogatePairEscape() {
        const start = this.index;
        if (this.eatFixedHexDigits(4)) {
          const lead = this._lastIntValue;
          if (isLeadSurrogate(lead) && this.eat(REVERSE_SOLIDUS) && this.eat(LATIN_SMALL_LETTER_U) && this.eatFixedHexDigits(4)) {
            const trail = this._lastIntValue;
            if (isTrailSurrogate(trail)) {
              this._lastIntValue = combineSurrogatePair(lead, trail);
              return true;
            }
          }
          this.rewind(start);
        }
        return false;
      }
      eatRegExpUnicodeCodePointEscape() {
        const start = this.index;
        if (this.eat(LEFT_CURLY_BRACKET) && this.eatHexDigits() && this.eat(RIGHT_CURLY_BRACKET) && isValidUnicode(this._lastIntValue)) {
          return true;
        }
        this.rewind(start);
        return false;
      }
      eatIdentityEscape() {
        const cp = this.currentCodePoint;
        if (this.isValidIdentityEscape(cp)) {
          this._lastIntValue = cp;
          this.advance();
          return true;
        }
        return false;
      }
      isValidIdentityEscape(cp) {
        if (cp === -1) {
          return false;
        }
        if (this._uFlag) {
          return isSyntaxCharacter(cp) || cp === SOLIDUS;
        }
        if (this.strict) {
          return !isIdContinue(cp);
        }
        if (this._nFlag) {
          return !(cp === LATIN_SMALL_LETTER_C || cp === LATIN_SMALL_LETTER_K);
        }
        return cp !== LATIN_SMALL_LETTER_C;
      }
      eatDecimalEscape() {
        this._lastIntValue = 0;
        let cp = this.currentCodePoint;
        if (cp >= DIGIT_ONE && cp <= DIGIT_NINE) {
          do {
            this._lastIntValue = 10 * this._lastIntValue + (cp - DIGIT_ZERO);
            this.advance();
          } while ((cp = this.currentCodePoint) >= DIGIT_ZERO && cp <= DIGIT_NINE);
          return true;
        }
        return false;
      }
      eatUnicodePropertyValueExpression() {
        const start = this.index;
        if (this.eatUnicodePropertyName() && this.eat(EQUALS_SIGN)) {
          this._lastKeyValue = this._lastStrValue;
          if (this.eatUnicodePropertyValue()) {
            this._lastValValue = this._lastStrValue;
            if (isValidUnicodeProperty(this.ecmaVersion, this._lastKeyValue, this._lastValValue)) {
              return true;
            }
            this.raise("Invalid property name");
          }
        }
        this.rewind(start);
        if (this.eatLoneUnicodePropertyNameOrValue()) {
          const nameOrValue = this._lastStrValue;
          if (isValidUnicodeProperty(this.ecmaVersion, "General_Category", nameOrValue)) {
            this._lastKeyValue = "General_Category";
            this._lastValValue = nameOrValue;
            return true;
          }
          if (isValidLoneUnicodeProperty(this.ecmaVersion, nameOrValue)) {
            this._lastKeyValue = nameOrValue;
            this._lastValValue = "";
            return true;
          }
          this.raise("Invalid property name");
        }
        return false;
      }
      eatUnicodePropertyName() {
        this._lastStrValue = "";
        while (isUnicodePropertyNameCharacter(this.currentCodePoint)) {
          this._lastStrValue += String.fromCodePoint(this.currentCodePoint);
          this.advance();
        }
        return this._lastStrValue !== "";
      }
      eatUnicodePropertyValue() {
        this._lastStrValue = "";
        while (isUnicodePropertyValueCharacter(this.currentCodePoint)) {
          this._lastStrValue += String.fromCodePoint(this.currentCodePoint);
          this.advance();
        }
        return this._lastStrValue !== "";
      }
      eatLoneUnicodePropertyNameOrValue() {
        return this.eatUnicodePropertyValue();
      }
      eatHexEscapeSequence() {
        const start = this.index;
        if (this.eat(LATIN_SMALL_LETTER_X)) {
          if (this.eatFixedHexDigits(2)) {
            return true;
          }
          if (this._uFlag || this.strict) {
            this.raise("Invalid escape");
          }
          this.rewind(start);
        }
        return false;
      }
      eatDecimalDigits() {
        const start = this.index;
        this._lastIntValue = 0;
        while (isDecimalDigit(this.currentCodePoint)) {
          this._lastIntValue = 10 * this._lastIntValue + digitToInt(this.currentCodePoint);
          this.advance();
        }
        return this.index !== start;
      }
      eatHexDigits() {
        const start = this.index;
        this._lastIntValue = 0;
        while (isHexDigit(this.currentCodePoint)) {
          this._lastIntValue = 16 * this._lastIntValue + digitToInt(this.currentCodePoint);
          this.advance();
        }
        return this.index !== start;
      }
      eatLegacyOctalEscapeSequence() {
        if (this.eatOctalDigit()) {
          const n1 = this._lastIntValue;
          if (this.eatOctalDigit()) {
            const n2 = this._lastIntValue;
            if (n1 <= 3 && this.eatOctalDigit()) {
              this._lastIntValue = n1 * 64 + n2 * 8 + this._lastIntValue;
            } else {
              this._lastIntValue = n1 * 8 + n2;
            }
          } else {
            this._lastIntValue = n1;
          }
          return true;
        }
        return false;
      }
      eatOctalDigit() {
        const cp = this.currentCodePoint;
        if (isOctalDigit(cp)) {
          this.advance();
          this._lastIntValue = cp - DIGIT_ZERO;
          return true;
        }
        this._lastIntValue = 0;
        return false;
      }
      eatFixedHexDigits(length) {
        const start = this.index;
        this._lastIntValue = 0;
        for (let i = 0; i < length; ++i) {
          const cp = this.currentCodePoint;
          if (!isHexDigit(cp)) {
            this.rewind(start);
            return false;
          }
          this._lastIntValue = 16 * this._lastIntValue + digitToInt(cp);
          this.advance();
        }
        return true;
      }
    };
    var DUMMY_PATTERN = {};
    var DUMMY_FLAGS = {};
    var DUMMY_CAPTURING_GROUP = {};
    var RegExpParserState = class {
      constructor(options) {
        var _a;
        this._node = DUMMY_PATTERN;
        this._flags = DUMMY_FLAGS;
        this._backreferences = [];
        this._capturingGroups = [];
        this.source = "";
        this.strict = Boolean(options === null || options === void 0 ? void 0 : options.strict);
        this.ecmaVersion = (_a = options === null || options === void 0 ? void 0 : options.ecmaVersion) !== null && _a !== void 0 ? _a : 2023;
      }
      get pattern() {
        if (this._node.type !== "Pattern") {
          throw new Error("UnknownError");
        }
        return this._node;
      }
      get flags() {
        if (this._flags.type !== "Flags") {
          throw new Error("UnknownError");
        }
        return this._flags;
      }
      onRegExpFlags(start, end, { global: global2, ignoreCase, multiline, unicode, sticky, dotAll, hasIndices }) {
        this._flags = {
          type: "Flags",
          parent: null,
          start,
          end,
          raw: this.source.slice(start, end),
          global: global2,
          ignoreCase,
          multiline,
          unicode,
          sticky,
          dotAll,
          hasIndices
        };
      }
      onPatternEnter(start) {
        this._node = {
          type: "Pattern",
          parent: null,
          start,
          end: start,
          raw: "",
          alternatives: []
        };
        this._backreferences.length = 0;
        this._capturingGroups.length = 0;
      }
      onPatternLeave(start, end) {
        this._node.end = end;
        this._node.raw = this.source.slice(start, end);
        for (const reference of this._backreferences) {
          const ref = reference.ref;
          const group = typeof ref === "number" ? this._capturingGroups[ref - 1] : this._capturingGroups.find((g) => g.name === ref);
          reference.resolved = group;
          group.references.push(reference);
        }
      }
      onAlternativeEnter(start) {
        const parent = this._node;
        if (parent.type !== "Assertion" && parent.type !== "CapturingGroup" && parent.type !== "Group" && parent.type !== "Pattern") {
          throw new Error("UnknownError");
        }
        this._node = {
          type: "Alternative",
          parent,
          start,
          end: start,
          raw: "",
          elements: []
        };
        parent.alternatives.push(this._node);
      }
      onAlternativeLeave(start, end) {
        const node = this._node;
        if (node.type !== "Alternative") {
          throw new Error("UnknownError");
        }
        node.end = end;
        node.raw = this.source.slice(start, end);
        this._node = node.parent;
      }
      onGroupEnter(start) {
        const parent = this._node;
        if (parent.type !== "Alternative") {
          throw new Error("UnknownError");
        }
        this._node = {
          type: "Group",
          parent,
          start,
          end: start,
          raw: "",
          alternatives: []
        };
        parent.elements.push(this._node);
      }
      onGroupLeave(start, end) {
        const node = this._node;
        if (node.type !== "Group" || node.parent.type !== "Alternative") {
          throw new Error("UnknownError");
        }
        node.end = end;
        node.raw = this.source.slice(start, end);
        this._node = node.parent;
      }
      onCapturingGroupEnter(start, name) {
        const parent = this._node;
        if (parent.type !== "Alternative") {
          throw new Error("UnknownError");
        }
        this._node = {
          type: "CapturingGroup",
          parent,
          start,
          end: start,
          raw: "",
          name,
          alternatives: [],
          references: []
        };
        parent.elements.push(this._node);
        this._capturingGroups.push(this._node);
      }
      onCapturingGroupLeave(start, end) {
        const node = this._node;
        if (node.type !== "CapturingGroup" || node.parent.type !== "Alternative") {
          throw new Error("UnknownError");
        }
        node.end = end;
        node.raw = this.source.slice(start, end);
        this._node = node.parent;
      }
      onQuantifier(start, end, min, max, greedy) {
        const parent = this._node;
        if (parent.type !== "Alternative") {
          throw new Error("UnknownError");
        }
        const element = parent.elements.pop();
        if (element == null || element.type === "Quantifier" || element.type === "Assertion" && element.kind !== "lookahead") {
          throw new Error("UnknownError");
        }
        const node = {
          type: "Quantifier",
          parent,
          start: element.start,
          end,
          raw: this.source.slice(element.start, end),
          min,
          max,
          greedy,
          element
        };
        parent.elements.push(node);
        element.parent = node;
      }
      onLookaroundAssertionEnter(start, kind, negate) {
        const parent = this._node;
        if (parent.type !== "Alternative") {
          throw new Error("UnknownError");
        }
        const node = this._node = {
          type: "Assertion",
          parent,
          start,
          end: start,
          raw: "",
          kind,
          negate,
          alternatives: []
        };
        parent.elements.push(node);
      }
      onLookaroundAssertionLeave(start, end) {
        const node = this._node;
        if (node.type !== "Assertion" || node.parent.type !== "Alternative") {
          throw new Error("UnknownError");
        }
        node.end = end;
        node.raw = this.source.slice(start, end);
        this._node = node.parent;
      }
      onEdgeAssertion(start, end, kind) {
        const parent = this._node;
        if (parent.type !== "Alternative") {
          throw new Error("UnknownError");
        }
        parent.elements.push({
          type: "Assertion",
          parent,
          start,
          end,
          raw: this.source.slice(start, end),
          kind
        });
      }
      onWordBoundaryAssertion(start, end, kind, negate) {
        const parent = this._node;
        if (parent.type !== "Alternative") {
          throw new Error("UnknownError");
        }
        parent.elements.push({
          type: "Assertion",
          parent,
          start,
          end,
          raw: this.source.slice(start, end),
          kind,
          negate
        });
      }
      onAnyCharacterSet(start, end, kind) {
        const parent = this._node;
        if (parent.type !== "Alternative") {
          throw new Error("UnknownError");
        }
        parent.elements.push({
          type: "CharacterSet",
          parent,
          start,
          end,
          raw: this.source.slice(start, end),
          kind
        });
      }
      onEscapeCharacterSet(start, end, kind, negate) {
        const parent = this._node;
        if (parent.type !== "Alternative" && parent.type !== "CharacterClass") {
          throw new Error("UnknownError");
        }
        parent.elements.push({
          type: "CharacterSet",
          parent,
          start,
          end,
          raw: this.source.slice(start, end),
          kind,
          negate
        });
      }
      onUnicodePropertyCharacterSet(start, end, kind, key, value, negate) {
        const parent = this._node;
        if (parent.type !== "Alternative" && parent.type !== "CharacterClass") {
          throw new Error("UnknownError");
        }
        parent.elements.push({
          type: "CharacterSet",
          parent,
          start,
          end,
          raw: this.source.slice(start, end),
          kind,
          key,
          value,
          negate
        });
      }
      onCharacter(start, end, value) {
        const parent = this._node;
        if (parent.type !== "Alternative" && parent.type !== "CharacterClass") {
          throw new Error("UnknownError");
        }
        parent.elements.push({
          type: "Character",
          parent,
          start,
          end,
          raw: this.source.slice(start, end),
          value
        });
      }
      onBackreference(start, end, ref) {
        const parent = this._node;
        if (parent.type !== "Alternative") {
          throw new Error("UnknownError");
        }
        const node = {
          type: "Backreference",
          parent,
          start,
          end,
          raw: this.source.slice(start, end),
          ref,
          resolved: DUMMY_CAPTURING_GROUP
        };
        parent.elements.push(node);
        this._backreferences.push(node);
      }
      onCharacterClassEnter(start, negate) {
        const parent = this._node;
        if (parent.type !== "Alternative") {
          throw new Error("UnknownError");
        }
        this._node = {
          type: "CharacterClass",
          parent,
          start,
          end: start,
          raw: "",
          negate,
          elements: []
        };
        parent.elements.push(this._node);
      }
      onCharacterClassLeave(start, end) {
        const node = this._node;
        if (node.type !== "CharacterClass" || node.parent.type !== "Alternative") {
          throw new Error("UnknownError");
        }
        node.end = end;
        node.raw = this.source.slice(start, end);
        this._node = node.parent;
      }
      onCharacterClassRange(start, end) {
        const parent = this._node;
        if (parent.type !== "CharacterClass") {
          throw new Error("UnknownError");
        }
        const elements = parent.elements;
        const max = elements.pop();
        const hyphen = elements.pop();
        const min = elements.pop();
        if (!min || !max || !hyphen || min.type !== "Character" || max.type !== "Character" || hyphen.type !== "Character" || hyphen.value !== HYPHEN_MINUS) {
          throw new Error("UnknownError");
        }
        const node = {
          type: "CharacterClassRange",
          parent,
          start,
          end,
          raw: this.source.slice(start, end),
          min,
          max
        };
        min.parent = node;
        max.parent = node;
        elements.push(node);
      }
    };
    var RegExpParser = class {
      constructor(options) {
        this._state = new RegExpParserState(options);
        this._validator = new RegExpValidator(this._state);
      }
      parseLiteral(source, start = 0, end = source.length) {
        this._state.source = source;
        this._validator.validateLiteral(source, start, end);
        const pattern = this._state.pattern;
        const flags = this._state.flags;
        const literal = {
          type: "RegExpLiteral",
          parent: null,
          start,
          end,
          raw: source,
          pattern,
          flags
        };
        pattern.parent = literal;
        flags.parent = literal;
        return literal;
      }
      parseFlags(source, start = 0, end = source.length) {
        this._state.source = source;
        this._validator.validateFlags(source, start, end);
        return this._state.flags;
      }
      parsePattern(source, start = 0, end = source.length, uFlag = false) {
        this._state.source = source;
        this._validator.validatePattern(source, start, end, uFlag);
        return this._state.pattern;
      }
    };
    var RegExpVisitor = class {
      constructor(handlers) {
        this._handlers = handlers;
      }
      visit(node) {
        switch (node.type) {
          case "Alternative":
            this.visitAlternative(node);
            break;
          case "Assertion":
            this.visitAssertion(node);
            break;
          case "Backreference":
            this.visitBackreference(node);
            break;
          case "CapturingGroup":
            this.visitCapturingGroup(node);
            break;
          case "Character":
            this.visitCharacter(node);
            break;
          case "CharacterClass":
            this.visitCharacterClass(node);
            break;
          case "CharacterClassRange":
            this.visitCharacterClassRange(node);
            break;
          case "CharacterSet":
            this.visitCharacterSet(node);
            break;
          case "Flags":
            this.visitFlags(node);
            break;
          case "Group":
            this.visitGroup(node);
            break;
          case "Pattern":
            this.visitPattern(node);
            break;
          case "Quantifier":
            this.visitQuantifier(node);
            break;
          case "RegExpLiteral":
            this.visitRegExpLiteral(node);
            break;
          default:
            throw new Error(`Unknown type: ${node.type}`);
        }
      }
      visitAlternative(node) {
        if (this._handlers.onAlternativeEnter) {
          this._handlers.onAlternativeEnter(node);
        }
        node.elements.forEach(this.visit, this);
        if (this._handlers.onAlternativeLeave) {
          this._handlers.onAlternativeLeave(node);
        }
      }
      visitAssertion(node) {
        if (this._handlers.onAssertionEnter) {
          this._handlers.onAssertionEnter(node);
        }
        if (node.kind === "lookahead" || node.kind === "lookbehind") {
          node.alternatives.forEach(this.visit, this);
        }
        if (this._handlers.onAssertionLeave) {
          this._handlers.onAssertionLeave(node);
        }
      }
      visitBackreference(node) {
        if (this._handlers.onBackreferenceEnter) {
          this._handlers.onBackreferenceEnter(node);
        }
        if (this._handlers.onBackreferenceLeave) {
          this._handlers.onBackreferenceLeave(node);
        }
      }
      visitCapturingGroup(node) {
        if (this._handlers.onCapturingGroupEnter) {
          this._handlers.onCapturingGroupEnter(node);
        }
        node.alternatives.forEach(this.visit, this);
        if (this._handlers.onCapturingGroupLeave) {
          this._handlers.onCapturingGroupLeave(node);
        }
      }
      visitCharacter(node) {
        if (this._handlers.onCharacterEnter) {
          this._handlers.onCharacterEnter(node);
        }
        if (this._handlers.onCharacterLeave) {
          this._handlers.onCharacterLeave(node);
        }
      }
      visitCharacterClass(node) {
        if (this._handlers.onCharacterClassEnter) {
          this._handlers.onCharacterClassEnter(node);
        }
        node.elements.forEach(this.visit, this);
        if (this._handlers.onCharacterClassLeave) {
          this._handlers.onCharacterClassLeave(node);
        }
      }
      visitCharacterClassRange(node) {
        if (this._handlers.onCharacterClassRangeEnter) {
          this._handlers.onCharacterClassRangeEnter(node);
        }
        this.visitCharacter(node.min);
        this.visitCharacter(node.max);
        if (this._handlers.onCharacterClassRangeLeave) {
          this._handlers.onCharacterClassRangeLeave(node);
        }
      }
      visitCharacterSet(node) {
        if (this._handlers.onCharacterSetEnter) {
          this._handlers.onCharacterSetEnter(node);
        }
        if (this._handlers.onCharacterSetLeave) {
          this._handlers.onCharacterSetLeave(node);
        }
      }
      visitFlags(node) {
        if (this._handlers.onFlagsEnter) {
          this._handlers.onFlagsEnter(node);
        }
        if (this._handlers.onFlagsLeave) {
          this._handlers.onFlagsLeave(node);
        }
      }
      visitGroup(node) {
        if (this._handlers.onGroupEnter) {
          this._handlers.onGroupEnter(node);
        }
        node.alternatives.forEach(this.visit, this);
        if (this._handlers.onGroupLeave) {
          this._handlers.onGroupLeave(node);
        }
      }
      visitPattern(node) {
        if (this._handlers.onPatternEnter) {
          this._handlers.onPatternEnter(node);
        }
        node.alternatives.forEach(this.visit, this);
        if (this._handlers.onPatternLeave) {
          this._handlers.onPatternLeave(node);
        }
      }
      visitQuantifier(node) {
        if (this._handlers.onQuantifierEnter) {
          this._handlers.onQuantifierEnter(node);
        }
        this.visit(node.element);
        if (this._handlers.onQuantifierLeave) {
          this._handlers.onQuantifierLeave(node);
        }
      }
      visitRegExpLiteral(node) {
        if (this._handlers.onRegExpLiteralEnter) {
          this._handlers.onRegExpLiteralEnter(node);
        }
        this.visitPattern(node.pattern);
        this.visitFlags(node.flags);
        if (this._handlers.onRegExpLiteralLeave) {
          this._handlers.onRegExpLiteralLeave(node);
        }
      }
    };
    function parseRegExpLiteral(source, options) {
      return new RegExpParser(options).parseLiteral(String(source));
    }
    function validateRegExpLiteral(source, options) {
      new RegExpValidator(options).validateLiteral(source);
    }
    function visitRegExpAST(node, handlers) {
      new RegExpVisitor(handlers).visit(node);
    }
    exports.AST = ast;
    exports.RegExpParser = RegExpParser;
    exports.RegExpValidator = RegExpValidator;
    exports.parseRegExpLiteral = parseRegExpLiteral;
    exports.validateRegExpLiteral = validateRegExpLiteral;
    exports.visitRegExpAST = visitRegExpAST;
  }
});

// ../../node_modules/eslint/lib/rules/no-control-regex.js
var require_no_control_regex = __commonJS({
  "../../node_modules/eslint/lib/rules/no-control-regex.js"(exports, module) {
    "use strict";
    var RegExpValidator = require_regexpp().RegExpValidator;
    var collector = new class {
      constructor() {
        this._source = "";
        this._controlChars = [];
        this._validator = new RegExpValidator(this);
      }
      onPatternEnter() {
        this._controlChars = [];
      }
      onCharacter(start, end, cp) {
        if (cp >= 0 && cp <= 31 && (this._source.codePointAt(start) === cp || this._source.slice(start, end).startsWith("\\x") || this._source.slice(start, end).startsWith("\\u"))) {
          this._controlChars.push(`\\x${`0${cp.toString(16)}`.slice(-2)}`);
        }
      }
      collectControlChars(regexpStr, flags) {
        const uFlag = typeof flags === "string" && flags.includes("u");
        try {
          this._source = regexpStr;
          this._validator.validatePattern(regexpStr, void 0, void 0, uFlag);
        } catch {
        }
        return this._controlChars;
      }
    }();
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow control characters in regular expressions",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-control-regex"
        },
        schema: [],
        messages: {
          unexpected: "Unexpected control character(s) in regular expression: {{controlChars}}."
        }
      },
      create(context) {
        function getRegExp(node) {
          if (node.regex) {
            return node.regex;
          }
          if (typeof node.value === "string" && (node.parent.type === "NewExpression" || node.parent.type === "CallExpression") && node.parent.callee.type === "Identifier" && node.parent.callee.name === "RegExp" && node.parent.arguments[0] === node) {
            const pattern = node.value;
            const flags = node.parent.arguments.length > 1 && node.parent.arguments[1].type === "Literal" && typeof node.parent.arguments[1].value === "string" ? node.parent.arguments[1].value : null;
            return { pattern, flags };
          }
          return null;
        }
        return {
          Literal(node) {
            const regExp = getRegExp(node);
            if (regExp) {
              const { pattern, flags } = regExp;
              const controlCharacters = collector.collectControlChars(pattern, flags);
              if (controlCharacters.length > 0) {
                context.report({
                  node,
                  messageId: "unexpected",
                  data: {
                    controlChars: controlCharacters.join(", ")
                  }
                });
              }
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-debugger.js
var require_no_debugger = __commonJS({
  "../../node_modules/eslint/lib/rules/no-debugger.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow the use of `debugger`",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-debugger"
        },
        fixable: null,
        schema: [],
        messages: {
          unexpected: "Unexpected 'debugger' statement."
        }
      },
      create(context) {
        return {
          DebuggerStatement(node) {
            context.report({
              node,
              messageId: "unexpected"
            });
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-delete-var.js
var require_no_delete_var = __commonJS({
  "../../node_modules/eslint/lib/rules/no-delete-var.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow deleting variables",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-delete-var"
        },
        schema: [],
        messages: {
          unexpected: "Variables should not be deleted."
        }
      },
      create(context) {
        return {
          UnaryExpression(node) {
            if (node.operator === "delete" && node.argument.type === "Identifier") {
              context.report({ node, messageId: "unexpected" });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-div-regex.js
var require_no_div_regex = __commonJS({
  "../../node_modules/eslint/lib/rules/no-div-regex.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow equal signs explicitly at the beginning of regular expressions",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-div-regex"
        },
        fixable: "code",
        schema: [],
        messages: {
          unexpected: "A regular expression literal can be confused with '/='."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        return {
          Literal(node) {
            const token = sourceCode.getFirstToken(node);
            if (token.type === "RegularExpression" && token.value[1] === "=") {
              context.report({
                node,
                messageId: "unexpected",
                fix(fixer) {
                  return fixer.replaceTextRange([token.range[0] + 1, token.range[0] + 2], "[=]");
                }
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-dupe-args.js
var require_no_dupe_args = __commonJS({
  "../../node_modules/eslint/lib/rules/no-dupe-args.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow duplicate arguments in `function` definitions",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-dupe-args"
        },
        schema: [],
        messages: {
          unexpected: "Duplicate param '{{name}}'."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        function isParameter(def) {
          return def.type === "Parameter";
        }
        function checkParams(node) {
          const variables = sourceCode.getDeclaredVariables(node);
          for (let i = 0; i < variables.length; ++i) {
            const variable = variables[i];
            const defs = variable.defs.filter(isParameter);
            if (defs.length >= 2) {
              context.report({
                node,
                messageId: "unexpected",
                data: { name: variable.name }
              });
            }
          }
        }
        return {
          FunctionDeclaration: checkParams,
          FunctionExpression: checkParams
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-dupe-class-members.js
var require_no_dupe_class_members = __commonJS({
  "../../node_modules/eslint/lib/rules/no-dupe-class-members.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow duplicate class members",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-dupe-class-members"
        },
        schema: [],
        messages: {
          unexpected: "Duplicate name '{{name}}'."
        }
      },
      create(context) {
        let stack = [];
        function getState(name, isStatic) {
          const stateMap = stack[stack.length - 1];
          const key = `$${name}`;
          if (!stateMap[key]) {
            stateMap[key] = {
              nonStatic: { init: false, get: false, set: false },
              static: { init: false, get: false, set: false }
            };
          }
          return stateMap[key][isStatic ? "static" : "nonStatic"];
        }
        return {
          // Initializes the stack of state of member declarations.
          Program() {
            stack = [];
          },
          // Initializes state of member declarations for the class.
          ClassBody() {
            stack.push(/* @__PURE__ */ Object.create(null));
          },
          // Disposes the state for the class.
          "ClassBody:exit"() {
            stack.pop();
          },
          // Reports the node if its name has been declared already.
          "MethodDefinition, PropertyDefinition"(node) {
            const name = astUtils.getStaticPropertyName(node);
            const kind = node.type === "MethodDefinition" ? node.kind : "field";
            if (name === null || kind === "constructor") {
              return;
            }
            const state = getState(name, node.static);
            let isDuplicate = false;
            if (kind === "get") {
              isDuplicate = state.init || state.get;
              state.get = true;
            } else if (kind === "set") {
              isDuplicate = state.init || state.set;
              state.set = true;
            } else {
              isDuplicate = state.init || state.get || state.set;
              state.init = true;
            }
            if (isDuplicate) {
              context.report({ node, messageId: "unexpected", data: { name } });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-dupe-else-if.js
var require_no_dupe_else_if = __commonJS({
  "../../node_modules/eslint/lib/rules/no-dupe-else-if.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    function isSubsetByComparator(comparator, arrA, arrB) {
      return arrA.every((a) => arrB.some((b) => comparator(a, b)));
    }
    function splitByLogicalOperator(operator, node) {
      if (node.type === "LogicalExpression" && node.operator === operator) {
        return [...splitByLogicalOperator(operator, node.left), ...splitByLogicalOperator(operator, node.right)];
      }
      return [node];
    }
    var splitByOr = splitByLogicalOperator.bind(null, "||");
    var splitByAnd = splitByLogicalOperator.bind(null, "&&");
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow duplicate conditions in if-else-if chains",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-dupe-else-if"
        },
        schema: [],
        messages: {
          unexpected: "This branch can never execute. Its condition is a duplicate or covered by previous conditions in the if-else-if chain."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        function equal(a, b) {
          if (a.type !== b.type) {
            return false;
          }
          if (a.type === "LogicalExpression" && (a.operator === "||" || a.operator === "&&") && a.operator === b.operator) {
            return equal(a.left, b.left) && equal(a.right, b.right) || equal(a.left, b.right) && equal(a.right, b.left);
          }
          return astUtils.equalTokens(a, b, sourceCode);
        }
        const isSubset = isSubsetByComparator.bind(null, equal);
        return {
          IfStatement(node) {
            const test = node.test, conditionsToCheck = test.type === "LogicalExpression" && test.operator === "&&" ? [test, ...splitByAnd(test)] : [test];
            let current = node, listToCheck = conditionsToCheck.map((c) => splitByOr(c).map(splitByAnd));
            while (current.parent && current.parent.type === "IfStatement" && current.parent.alternate === current) {
              current = current.parent;
              const currentOrOperands = splitByOr(current.test).map(splitByAnd);
              listToCheck = listToCheck.map((orOperands) => orOperands.filter(
                (orOperand) => !currentOrOperands.some((currentOrOperand) => isSubset(currentOrOperand, orOperand))
              ));
              if (listToCheck.some((orOperands) => orOperands.length === 0)) {
                context.report({ node: test, messageId: "unexpected" });
                break;
              }
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-dupe-keys.js
var require_no_dupe_keys = __commonJS({
  "../../node_modules/eslint/lib/rules/no-dupe-keys.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var GET_KIND = /^(?:init|get)$/u;
    var SET_KIND = /^(?:init|set)$/u;
    var ObjectInfo = class {
      /**
       * @param {ObjectInfo|null} upper The information of the outer object.
       * @param {ASTNode} node The ObjectExpression node of this information.
       */
      constructor(upper, node) {
        this.upper = upper;
        this.node = node;
        this.properties = /* @__PURE__ */ new Map();
      }
      /**
       * Gets the information of the given Property node.
       * @param {ASTNode} node The Property node to get.
       * @returns {{get: boolean, set: boolean}} The information of the property.
       */
      getPropertyInfo(node) {
        const name = astUtils.getStaticPropertyName(node);
        if (!this.properties.has(name)) {
          this.properties.set(name, { get: false, set: false });
        }
        return this.properties.get(name);
      }
      /**
       * Checks whether the given property has been defined already or not.
       * @param {ASTNode} node The Property node to check.
       * @returns {boolean} `true` if the property has been defined.
       */
      isPropertyDefined(node) {
        const entry = this.getPropertyInfo(node);
        return GET_KIND.test(node.kind) && entry.get || SET_KIND.test(node.kind) && entry.set;
      }
      /**
       * Defines the given property.
       * @param {ASTNode} node The Property node to define.
       * @returns {void}
       */
      defineProperty(node) {
        const entry = this.getPropertyInfo(node);
        if (GET_KIND.test(node.kind)) {
          entry.get = true;
        }
        if (SET_KIND.test(node.kind)) {
          entry.set = true;
        }
      }
    };
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow duplicate keys in object literals",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-dupe-keys"
        },
        schema: [],
        messages: {
          unexpected: "Duplicate key '{{name}}'."
        }
      },
      create(context) {
        let info = null;
        return {
          ObjectExpression(node) {
            info = new ObjectInfo(info, node);
          },
          "ObjectExpression:exit"() {
            info = info.upper;
          },
          Property(node) {
            const name = astUtils.getStaticPropertyName(node);
            if (node.parent.type !== "ObjectExpression") {
              return;
            }
            if (name === null) {
              return;
            }
            if (info.isPropertyDefined(node)) {
              context.report({
                node: info.node,
                loc: node.key.loc,
                messageId: "unexpected",
                data: { name }
              });
            }
            info.defineProperty(node);
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-duplicate-case.js
var require_no_duplicate_case = __commonJS({
  "../../node_modules/eslint/lib/rules/no-duplicate-case.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow duplicate case labels",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-duplicate-case"
        },
        schema: [],
        messages: {
          unexpected: "Duplicate case label."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        function equal(a, b) {
          if (a.type !== b.type) {
            return false;
          }
          return astUtils.equalTokens(a, b, sourceCode);
        }
        return {
          SwitchStatement(node) {
            const previousTests = [];
            for (const switchCase of node.cases) {
              if (switchCase.test) {
                const test = switchCase.test;
                if (previousTests.some((previousTest) => equal(previousTest, test))) {
                  context.report({ node: switchCase, messageId: "unexpected" });
                } else {
                  previousTests.push(test);
                }
              }
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-duplicate-imports.js
var require_no_duplicate_imports = __commonJS({
  "../../node_modules/eslint/lib/rules/no-duplicate-imports.js"(exports, module) {
    "use strict";
    var NAMED_TYPES = ["ImportSpecifier", "ExportSpecifier"];
    var NAMESPACE_TYPES = [
      "ImportNamespaceSpecifier",
      "ExportNamespaceSpecifier"
    ];
    function isImportExportSpecifier(importExportType, type) {
      const arrayToCheck = type === "named" ? NAMED_TYPES : NAMESPACE_TYPES;
      return arrayToCheck.includes(importExportType);
    }
    function getImportExportType(node) {
      if (node.specifiers && node.specifiers.length > 0) {
        const nodeSpecifiers = node.specifiers;
        const index = nodeSpecifiers.findIndex(
          ({ type }) => isImportExportSpecifier(type, "named") || isImportExportSpecifier(type, "namespace")
        );
        const i = index > -1 ? index : 0;
        return nodeSpecifiers[i].type;
      }
      if (node.type === "ExportAllDeclaration") {
        if (node.exported) {
          return "ExportNamespaceSpecifier";
        }
        return "ExportAll";
      }
      return "SideEffectImport";
    }
    function isImportExportCanBeMerged(node1, node2) {
      const importExportType1 = getImportExportType(node1);
      const importExportType2 = getImportExportType(node2);
      if (importExportType1 === "ExportAll" && importExportType2 !== "ExportAll" && importExportType2 !== "SideEffectImport" || importExportType1 !== "ExportAll" && importExportType1 !== "SideEffectImport" && importExportType2 === "ExportAll") {
        return false;
      }
      if (isImportExportSpecifier(importExportType1, "namespace") && isImportExportSpecifier(importExportType2, "named") || isImportExportSpecifier(importExportType2, "namespace") && isImportExportSpecifier(importExportType1, "named")) {
        return false;
      }
      return true;
    }
    function shouldReportImportExport(node, previousNodes) {
      let i = 0;
      while (i < previousNodes.length) {
        if (isImportExportCanBeMerged(node, previousNodes[i])) {
          return true;
        }
        i++;
      }
      return false;
    }
    function getNodesByDeclarationType(nodes, type) {
      return nodes.filter(({ declarationType }) => declarationType === type).map(({ node }) => node);
    }
    function getModule(node) {
      if (node && node.source && node.source.value) {
        return node.source.value.trim();
      }
      return "";
    }
    function checkAndReport(context, node, modules, declarationType, includeExports) {
      const module2 = getModule(node);
      if (modules.has(module2)) {
        const previousNodes = modules.get(module2);
        const messagesIds = [];
        const importNodes = getNodesByDeclarationType(previousNodes, "import");
        let exportNodes;
        if (includeExports) {
          exportNodes = getNodesByDeclarationType(previousNodes, "export");
        }
        if (declarationType === "import") {
          if (shouldReportImportExport(node, importNodes)) {
            messagesIds.push("import");
          }
          if (includeExports) {
            if (shouldReportImportExport(node, exportNodes)) {
              messagesIds.push("importAs");
            }
          }
        } else if (declarationType === "export") {
          if (shouldReportImportExport(node, exportNodes)) {
            messagesIds.push("export");
          }
          if (shouldReportImportExport(node, importNodes)) {
            messagesIds.push("exportAs");
          }
        }
        messagesIds.forEach((messageId) => context.report({
          node,
          messageId,
          data: {
            module: module2
          }
        }));
      }
    }
    function handleImportsExports(context, modules, declarationType, includeExports) {
      return function(node) {
        const module2 = getModule(node);
        if (module2) {
          checkAndReport(
            context,
            node,
            modules,
            declarationType,
            includeExports
          );
          const currentNode = { node, declarationType };
          let nodes = [currentNode];
          if (modules.has(module2)) {
            const previousNodes = modules.get(module2);
            nodes = [...previousNodes, currentNode];
          }
          modules.set(module2, nodes);
        }
      };
    }
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow duplicate module imports",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-duplicate-imports"
        },
        schema: [
          {
            type: "object",
            properties: {
              includeExports: {
                type: "boolean",
                default: false
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          import: "'{{module}}' import is duplicated.",
          importAs: "'{{module}}' import is duplicated as export.",
          export: "'{{module}}' export is duplicated.",
          exportAs: "'{{module}}' export is duplicated as import."
        }
      },
      create(context) {
        const includeExports = (context.options[0] || {}).includeExports, modules = /* @__PURE__ */ new Map();
        const handlers = {
          ImportDeclaration: handleImportsExports(
            context,
            modules,
            "import",
            includeExports
          )
        };
        if (includeExports) {
          handlers.ExportNamedDeclaration = handleImportsExports(
            context,
            modules,
            "export",
            includeExports
          );
          handlers.ExportAllDeclaration = handleImportsExports(
            context,
            modules,
            "export",
            includeExports
          );
        }
        return handlers;
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/utils/fix-tracker.js
var require_fix_tracker = __commonJS({
  "../../node_modules/eslint/lib/rules/utils/fix-tracker.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var FixTracker = class {
      /**
       * Create a new FixTracker.
       * @param {ruleFixer} fixer A ruleFixer instance.
       * @param {SourceCode} sourceCode A SourceCode object for the current code.
       */
      constructor(fixer, sourceCode) {
        this.fixer = fixer;
        this.sourceCode = sourceCode;
        this.retainedRange = null;
      }
      /**
       * Mark the given range as "retained", meaning that other fixes may not
       * may not modify this region in the same pass.
       * @param {int[]} range The range to retain.
       * @returns {FixTracker} The same RuleFixer, for chained calls.
       */
      retainRange(range) {
        this.retainedRange = range;
        return this;
      }
      /**
       * Given a node, find the function containing it (or the entire program) and
       * mark it as retained, meaning that other fixes may not modify it in this
       * pass. This is useful for avoiding conflicts in fixes that modify control
       * flow.
       * @param {ASTNode} node The node to use as a starting point.
       * @returns {FixTracker} The same RuleFixer, for chained calls.
       */
      retainEnclosingFunction(node) {
        const functionNode = astUtils.getUpperFunction(node);
        return this.retainRange(functionNode ? functionNode.range : this.sourceCode.ast.range);
      }
      /**
       * Given a node or token, find the token before and afterward, and mark that
       * range as retained, meaning that other fixes may not modify it in this
       * pass. This is useful for avoiding conflicts in fixes that make a small
       * change to the code where the AST should not be changed.
       * @param {ASTNode|Token} nodeOrToken The node or token to use as a starting
       *      point. The token to the left and right are use in the range.
       * @returns {FixTracker} The same RuleFixer, for chained calls.
       */
      retainSurroundingTokens(nodeOrToken) {
        const tokenBefore = this.sourceCode.getTokenBefore(nodeOrToken) || nodeOrToken;
        const tokenAfter = this.sourceCode.getTokenAfter(nodeOrToken) || nodeOrToken;
        return this.retainRange([tokenBefore.range[0], tokenAfter.range[1]]);
      }
      /**
       * Create a fix command that replaces the given range with the given text,
       * accounting for any retained ranges.
       * @param {int[]} range The range to remove in the fix.
       * @param {string} text The text to insert in place of the range.
       * @returns {Object} The fix command.
       */
      replaceTextRange(range, text) {
        let actualRange;
        if (this.retainedRange) {
          actualRange = [
            Math.min(this.retainedRange[0], range[0]),
            Math.max(this.retainedRange[1], range[1])
          ];
        } else {
          actualRange = range;
        }
        return this.fixer.replaceTextRange(
          actualRange,
          this.sourceCode.text.slice(actualRange[0], range[0]) + text + this.sourceCode.text.slice(range[1], actualRange[1])
        );
      }
      /**
       * Create a fix command that removes the given node or token, accounting for
       * any retained ranges.
       * @param {ASTNode|Token} nodeOrToken The node or token to remove.
       * @returns {Object} The fix command.
       */
      remove(nodeOrToken) {
        return this.replaceTextRange(nodeOrToken.range, "");
      }
    };
    module.exports = FixTracker;
  }
});

// ../../node_modules/eslint/lib/rules/no-else-return.js
var require_no_else_return = __commonJS({
  "../../node_modules/eslint/lib/rules/no-else-return.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var FixTracker = require_fix_tracker();
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow `else` blocks after `return` statements in `if` statements",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-else-return"
        },
        schema: [{
          type: "object",
          properties: {
            allowElseIf: {
              type: "boolean",
              default: true
            }
          },
          additionalProperties: false
        }],
        fixable: "code",
        messages: {
          unexpected: "Unnecessary 'else' after 'return'."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        function isSafeToDeclare(names, scope) {
          if (names.length === 0) {
            return true;
          }
          const functionScope = scope.variableScope;
          const declaredVariables = scope.variables.filter(({ defs }) => defs.length > 0);
          if (declaredVariables.some(({ name }) => names.includes(name))) {
            return false;
          }
          if (scope !== functionScope && scope.upper.type === "catch") {
            if (scope.upper.variables.some(({ name }) => names.includes(name))) {
              return false;
            }
          }
          const usedImplicitVariables = scope.variables.filter(({ defs, references }) => defs.length === 0 && references.length > 0);
          if (usedImplicitVariables.some(({ name }) => names.includes(name))) {
            return false;
          }
          if (scope.through.some((t) => names.includes(t.identifier.name))) {
            return false;
          }
          if (scope !== functionScope) {
            const scopeNodeRange = scope.block.range;
            const variablesToCheck = functionScope.variables.filter(({ name }) => names.includes(name));
            if (variablesToCheck.some((v) => v.defs.some(({ node: { range } }) => scopeNodeRange[0] <= range[0] && range[1] <= scopeNodeRange[1]))) {
              return false;
            }
          }
          return true;
        }
        function isSafeFromNameCollisions(node, scope) {
          if (node.type === "FunctionDeclaration") {
            return false;
          }
          if (node.type !== "BlockStatement") {
            return true;
          }
          const elseBlockScope = scope.childScopes.find(({ block }) => block === node);
          if (!elseBlockScope) {
            return true;
          }
          const namesToCheck = elseBlockScope.variables.map(({ name }) => name);
          return isSafeToDeclare(namesToCheck, scope);
        }
        function displayReport(elseNode) {
          const currentScope = sourceCode.getScope(elseNode.parent);
          context.report({
            node: elseNode,
            messageId: "unexpected",
            fix(fixer) {
              if (!isSafeFromNameCollisions(elseNode, currentScope)) {
                return null;
              }
              const startToken = sourceCode.getFirstToken(elseNode);
              const elseToken = sourceCode.getTokenBefore(startToken);
              const source = sourceCode.getText(elseNode);
              const lastIfToken = sourceCode.getTokenBefore(elseToken);
              let fixedSource, firstTokenOfElseBlock;
              if (startToken.type === "Punctuator" && startToken.value === "{") {
                firstTokenOfElseBlock = sourceCode.getTokenAfter(startToken);
              } else {
                firstTokenOfElseBlock = startToken;
              }
              const ifBlockMaybeUnsafe = elseNode.parent.consequent.type !== "BlockStatement" && lastIfToken.value !== ";";
              const elseBlockUnsafe = /^[([/+`-]/u.test(firstTokenOfElseBlock.value);
              if (ifBlockMaybeUnsafe && elseBlockUnsafe) {
                return null;
              }
              const endToken = sourceCode.getLastToken(elseNode);
              const lastTokenOfElseBlock = sourceCode.getTokenBefore(endToken);
              if (lastTokenOfElseBlock.value !== ";") {
                const nextToken = sourceCode.getTokenAfter(endToken);
                const nextTokenUnsafe = nextToken && /^[([/+`-]/u.test(nextToken.value);
                const nextTokenOnSameLine = nextToken && nextToken.loc.start.line === lastTokenOfElseBlock.loc.start.line;
                if (nextTokenUnsafe || nextTokenOnSameLine && nextToken.value !== "}") {
                  return null;
                }
              }
              if (startToken.type === "Punctuator" && startToken.value === "{") {
                fixedSource = source.slice(1, -1);
              } else {
                fixedSource = source;
              }
              return new FixTracker(fixer, sourceCode).retainEnclosingFunction(elseNode).replaceTextRange([elseToken.range[0], elseNode.range[1]], fixedSource);
            }
          });
        }
        function checkForReturn(node) {
          return node.type === "ReturnStatement";
        }
        function naiveHasReturn(node) {
          if (node.type === "BlockStatement") {
            const body = node.body, lastChildNode = body[body.length - 1];
            return lastChildNode && checkForReturn(lastChildNode);
          }
          return checkForReturn(node);
        }
        function hasElse(node) {
          return node.alternate && node.consequent;
        }
        function checkForIf(node) {
          return node.type === "IfStatement" && hasElse(node) && naiveHasReturn(node.alternate) && naiveHasReturn(node.consequent);
        }
        function checkForReturnOrIf(node) {
          return checkForReturn(node) || checkForIf(node);
        }
        function alwaysReturns(node) {
          if (node.type === "BlockStatement") {
            return node.body.some(checkForReturnOrIf);
          }
          return checkForReturnOrIf(node);
        }
        function checkIfWithoutElse(node) {
          const parent = node.parent;
          if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) {
            return;
          }
          const consequents = [];
          let alternate;
          for (let currentNode = node; currentNode.type === "IfStatement"; currentNode = currentNode.alternate) {
            if (!currentNode.alternate) {
              return;
            }
            consequents.push(currentNode.consequent);
            alternate = currentNode.alternate;
          }
          if (consequents.every(alwaysReturns)) {
            displayReport(alternate);
          }
        }
        function checkIfWithElse(node) {
          const parent = node.parent;
          if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) {
            return;
          }
          const alternate = node.alternate;
          if (alternate && alwaysReturns(node.consequent)) {
            displayReport(alternate);
          }
        }
        const allowElseIf = !(context.options[0] && context.options[0].allowElseIf === false);
        return {
          "IfStatement:exit": allowElseIf ? checkIfWithoutElse : checkIfWithElse
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-empty.js
var require_no_empty = __commonJS({
  "../../node_modules/eslint/lib/rules/no-empty.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        hasSuggestions: true,
        type: "suggestion",
        docs: {
          description: "Disallow empty block statements",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-empty"
        },
        schema: [
          {
            type: "object",
            properties: {
              allowEmptyCatch: {
                type: "boolean",
                default: false
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          unexpected: "Empty {{type}} statement.",
          suggestComment: "Add comment inside empty {{type}} statement."
        }
      },
      create(context) {
        const options = context.options[0] || {}, allowEmptyCatch = options.allowEmptyCatch || false;
        const sourceCode = context.sourceCode;
        return {
          BlockStatement(node) {
            if (node.body.length !== 0) {
              return;
            }
            if (astUtils.isFunction(node.parent)) {
              return;
            }
            if (allowEmptyCatch && node.parent.type === "CatchClause") {
              return;
            }
            if (sourceCode.getCommentsInside(node).length > 0) {
              return;
            }
            context.report({
              node,
              messageId: "unexpected",
              data: { type: "block" },
              suggest: [
                {
                  messageId: "suggestComment",
                  data: { type: "block" },
                  fix(fixer) {
                    const range = [node.range[0] + 1, node.range[1] - 1];
                    return fixer.replaceTextRange(range, " /* empty */ ");
                  }
                }
              ]
            });
          },
          SwitchStatement(node) {
            if (typeof node.cases === "undefined" || node.cases.length === 0) {
              context.report({ node, messageId: "unexpected", data: { type: "switch" } });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-empty-character-class.js
var require_no_empty_character_class = __commonJS({
  "../../node_modules/eslint/lib/rules/no-empty-character-class.js"(exports, module) {
    "use strict";
    var regex = /^([^\\[]|\\.|\[([^\\\]]|\\.)+\])*$/u;
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow empty character classes in regular expressions",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-empty-character-class"
        },
        schema: [],
        messages: {
          unexpected: "Empty class."
        }
      },
      create(context) {
        return {
          "Literal[regex]"(node) {
            if (!regex.test(node.regex.pattern)) {
              context.report({ node, messageId: "unexpected" });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-empty-function.js
var require_no_empty_function = __commonJS({
  "../../node_modules/eslint/lib/rules/no-empty-function.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var ALLOW_OPTIONS = Object.freeze([
      "functions",
      "arrowFunctions",
      "generatorFunctions",
      "methods",
      "generatorMethods",
      "getters",
      "setters",
      "constructors",
      "asyncFunctions",
      "asyncMethods"
    ]);
    function getKind(node) {
      const parent = node.parent;
      let kind = "";
      if (node.type === "ArrowFunctionExpression") {
        return "arrowFunctions";
      }
      if (parent.type === "Property") {
        if (parent.kind === "get") {
          return "getters";
        }
        if (parent.kind === "set") {
          return "setters";
        }
        kind = parent.method ? "methods" : "functions";
      } else if (parent.type === "MethodDefinition") {
        if (parent.kind === "get") {
          return "getters";
        }
        if (parent.kind === "set") {
          return "setters";
        }
        if (parent.kind === "constructor") {
          return "constructors";
        }
        kind = "methods";
      } else {
        kind = "functions";
      }
      let prefix = "";
      if (node.generator) {
        prefix = "generator";
      } else if (node.async) {
        prefix = "async";
      } else {
        return kind;
      }
      return prefix + kind[0].toUpperCase() + kind.slice(1);
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow empty functions",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-empty-function"
        },
        schema: [
          {
            type: "object",
            properties: {
              allow: {
                type: "array",
                items: { enum: ALLOW_OPTIONS },
                uniqueItems: true
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          unexpected: "Unexpected empty {{name}}."
        }
      },
      create(context) {
        const options = context.options[0] || {};
        const allowed = options.allow || [];
        const sourceCode = context.sourceCode;
        function reportIfEmpty(node) {
          const kind = getKind(node);
          const name = astUtils.getFunctionNameWithKind(node);
          const innerComments = sourceCode.getTokens(node.body, {
            includeComments: true,
            filter: astUtils.isCommentToken
          });
          if (!allowed.includes(kind) && node.body.type === "BlockStatement" && node.body.body.length === 0 && innerComments.length === 0) {
            context.report({
              node,
              loc: node.body.loc,
              messageId: "unexpected",
              data: { name }
            });
          }
        }
        return {
          ArrowFunctionExpression: reportIfEmpty,
          FunctionDeclaration: reportIfEmpty,
          FunctionExpression: reportIfEmpty
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-empty-pattern.js
var require_no_empty_pattern = __commonJS({
  "../../node_modules/eslint/lib/rules/no-empty-pattern.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow empty destructuring patterns",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-empty-pattern"
        },
        schema: [],
        messages: {
          unexpected: "Unexpected empty {{type}} pattern."
        }
      },
      create(context) {
        return {
          ObjectPattern(node) {
            if (node.properties.length === 0) {
              context.report({ node, messageId: "unexpected", data: { type: "object" } });
            }
          },
          ArrayPattern(node) {
            if (node.elements.length === 0) {
              context.report({ node, messageId: "unexpected", data: { type: "array" } });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-empty-static-block.js
var require_no_empty_static_block = __commonJS({
  "../../node_modules/eslint/lib/rules/no-empty-static-block.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow empty static blocks",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-empty-static-block"
        },
        schema: [],
        messages: {
          unexpected: "Unexpected empty static block."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        return {
          StaticBlock(node) {
            if (node.body.length === 0) {
              const closingBrace = sourceCode.getLastToken(node);
              if (sourceCode.getCommentsBefore(closingBrace).length === 0) {
                context.report({
                  node,
                  messageId: "unexpected"
                });
              }
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-eq-null.js
var require_no_eq_null = __commonJS({
  "../../node_modules/eslint/lib/rules/no-eq-null.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow `null` comparisons without type-checking operators",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-eq-null"
        },
        schema: [],
        messages: {
          unexpected: "Use '===' to compare with null."
        }
      },
      create(context) {
        return {
          BinaryExpression(node) {
            const badOperator = node.operator === "==" || node.operator === "!=";
            if (node.right.type === "Literal" && node.right.raw === "null" && badOperator || node.left.type === "Literal" && node.left.raw === "null" && badOperator) {
              context.report({ node, messageId: "unexpected" });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-eval.js
var require_no_eval = __commonJS({
  "../../node_modules/eslint/lib/rules/no-eval.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var candidatesOfGlobalObject = Object.freeze([
      "global",
      "window",
      "globalThis"
    ]);
    function isMember(node, name) {
      return astUtils.isSpecificMemberAccess(node, null, name);
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow the use of `eval()`",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-eval"
        },
        schema: [
          {
            type: "object",
            properties: {
              allowIndirect: { type: "boolean", default: false }
            },
            additionalProperties: false
          }
        ],
        messages: {
          unexpected: "eval can be harmful."
        }
      },
      create(context) {
        const allowIndirect = Boolean(
          context.options[0] && context.options[0].allowIndirect
        );
        const sourceCode = context.sourceCode;
        let funcInfo = null;
        function enterThisScope(node) {
          const strict = sourceCode.getScope(node).isStrict;
          funcInfo = {
            upper: funcInfo,
            node,
            strict,
            isTopLevelOfScript: false,
            defaultThis: false,
            initialized: strict
          };
        }
        function exitThisScope() {
          funcInfo = funcInfo.upper;
        }
        function report(node) {
          const parent = node.parent;
          const locationNode = node.type === "MemberExpression" ? node.property : node;
          const reportNode = parent.type === "CallExpression" && parent.callee === node ? parent : node;
          context.report({
            node: reportNode,
            loc: locationNode.loc,
            messageId: "unexpected"
          });
        }
        function reportAccessingEvalViaGlobalObject(globalScope) {
          for (let i = 0; i < candidatesOfGlobalObject.length; ++i) {
            const name = candidatesOfGlobalObject[i];
            const variable = astUtils.getVariableByName(globalScope, name);
            if (!variable) {
              continue;
            }
            const references = variable.references;
            for (let j = 0; j < references.length; ++j) {
              const identifier = references[j].identifier;
              let node = identifier.parent;
              while (isMember(node, name)) {
                node = node.parent;
              }
              if (isMember(node, "eval")) {
                report(node);
              }
            }
          }
        }
        function reportAccessingEval(globalScope) {
          const variable = astUtils.getVariableByName(globalScope, "eval");
          if (!variable) {
            return;
          }
          const references = variable.references;
          for (let i = 0; i < references.length; ++i) {
            const reference = references[i];
            const id = reference.identifier;
            if (id.name === "eval" && !astUtils.isCallee(id)) {
              report(id);
            }
          }
        }
        if (allowIndirect) {
          return {
            "CallExpression:exit"(node) {
              const callee = node.callee;
              if (!node.optional && astUtils.isSpecificId(callee, "eval")) {
                report(callee);
              }
            }
          };
        }
        return {
          "CallExpression:exit"(node) {
            const callee = node.callee;
            if (astUtils.isSpecificId(callee, "eval")) {
              report(callee);
            }
          },
          Program(node) {
            const scope = sourceCode.getScope(node), features = context.parserOptions.ecmaFeatures || {}, strict = scope.isStrict || node.sourceType === "module" || features.globalReturn && scope.childScopes[0].isStrict, isTopLevelOfScript = node.sourceType !== "module" && !features.globalReturn;
            funcInfo = {
              upper: null,
              node,
              strict,
              isTopLevelOfScript,
              defaultThis: true,
              initialized: true
            };
          },
          "Program:exit"(node) {
            const globalScope = sourceCode.getScope(node);
            exitThisScope();
            reportAccessingEval(globalScope);
            reportAccessingEvalViaGlobalObject(globalScope);
          },
          FunctionDeclaration: enterThisScope,
          "FunctionDeclaration:exit": exitThisScope,
          FunctionExpression: enterThisScope,
          "FunctionExpression:exit": exitThisScope,
          "PropertyDefinition > *.value": enterThisScope,
          "PropertyDefinition > *.value:exit": exitThisScope,
          StaticBlock: enterThisScope,
          "StaticBlock:exit": exitThisScope,
          ThisExpression(node) {
            if (!isMember(node.parent, "eval")) {
              return;
            }
            if (!funcInfo.initialized) {
              funcInfo.initialized = true;
              funcInfo.defaultThis = astUtils.isDefaultThisBinding(
                funcInfo.node,
                sourceCode
              );
            }
            if (funcInfo.isTopLevelOfScript || !funcInfo.strict && funcInfo.defaultThis) {
              report(node.parent);
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-ex-assign.js
var require_no_ex_assign = __commonJS({
  "../../node_modules/eslint/lib/rules/no-ex-assign.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow reassigning exceptions in `catch` clauses",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-ex-assign"
        },
        schema: [],
        messages: {
          unexpected: "Do not assign to the exception parameter."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        function checkVariable(variable) {
          astUtils.getModifyingReferences(variable.references).forEach((reference) => {
            context.report({ node: reference.identifier, messageId: "unexpected" });
          });
        }
        return {
          CatchClause(node) {
            sourceCode.getDeclaredVariables(node).forEach(checkVariable);
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-extend-native.js
var require_no_extend_native = __commonJS({
  "../../node_modules/eslint/lib/rules/no-extend-native.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var globals = require_globals2();
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow extending native types",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-extend-native"
        },
        schema: [
          {
            type: "object",
            properties: {
              exceptions: {
                type: "array",
                items: {
                  type: "string"
                },
                uniqueItems: true
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          unexpected: "{{builtin}} prototype is read only, properties should not be added."
        }
      },
      create(context) {
        const config = context.options[0] || {};
        const sourceCode = context.sourceCode;
        const exceptions = new Set(config.exceptions || []);
        const modifiedBuiltins = new Set(
          Object.keys(globals.builtin).filter((builtin) => builtin[0].toUpperCase() === builtin[0]).filter((builtin) => !exceptions.has(builtin))
        );
        function reportNode(node, builtin) {
          context.report({
            node,
            messageId: "unexpected",
            data: {
              builtin
            }
          });
        }
        function isPrototypePropertyAccessed(identifierNode) {
          return Boolean(
            identifierNode && identifierNode.parent && identifierNode.parent.type === "MemberExpression" && identifierNode.parent.object === identifierNode && astUtils.getStaticPropertyName(identifierNode.parent) === "prototype"
          );
        }
        function isAssigningToPropertyOf(node) {
          return node.parent.type === "MemberExpression" && node.parent.object === node && node.parent.parent.type === "AssignmentExpression" && node.parent.parent.left === node.parent;
        }
        function isInDefinePropertyCall(node) {
          return node.parent.type === "CallExpression" && node.parent.arguments[0] === node && astUtils.isSpecificMemberAccess(node.parent.callee, "Object", /^definePropert(?:y|ies)$/u);
        }
        function checkAndReportPrototypeExtension(identifierNode) {
          if (!isPrototypePropertyAccessed(identifierNode)) {
            return;
          }
          const prototypeNode = identifierNode.parent.parent.type === "ChainExpression" ? identifierNode.parent.parent : identifierNode.parent;
          if (isAssigningToPropertyOf(prototypeNode)) {
            reportNode(prototypeNode.parent.parent, identifierNode.name);
          } else if (isInDefinePropertyCall(prototypeNode)) {
            reportNode(prototypeNode.parent, identifierNode.name);
          }
        }
        return {
          "Program:exit"(node) {
            const globalScope = sourceCode.getScope(node);
            modifiedBuiltins.forEach((builtin) => {
              const builtinVar = globalScope.set.get(builtin);
              if (builtinVar && builtinVar.references) {
                builtinVar.references.map((ref) => ref.identifier).forEach(checkAndReportPrototypeExtension);
              }
            });
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-extra-bind.js
var require_no_extra_bind = __commonJS({
  "../../node_modules/eslint/lib/rules/no-extra-bind.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var SIDE_EFFECT_FREE_NODE_TYPES = /* @__PURE__ */ new Set(["Literal", "Identifier", "ThisExpression", "FunctionExpression"]);
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow unnecessary calls to `.bind()`",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-extra-bind"
        },
        schema: [],
        fixable: "code",
        messages: {
          unexpected: "The function binding is unnecessary."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        let scopeInfo = null;
        function isSideEffectFree(node) {
          return SIDE_EFFECT_FREE_NODE_TYPES.has(node.type);
        }
        function report(node) {
          const memberNode = node.parent;
          const callNode = memberNode.parent.type === "ChainExpression" ? memberNode.parent.parent : memberNode.parent;
          context.report({
            node: callNode,
            messageId: "unexpected",
            loc: memberNode.property.loc,
            fix(fixer) {
              if (!isSideEffectFree(callNode.arguments[0])) {
                return null;
              }
              const tokenPairs = [
                [
                  // `.`, `?.`, or `[` token.
                  sourceCode.getTokenAfter(
                    memberNode.object,
                    astUtils.isNotClosingParenToken
                  ),
                  // property name or `]` token.
                  sourceCode.getLastToken(memberNode)
                ],
                [
                  // `?.` or `(` token of arguments.
                  sourceCode.getTokenAfter(
                    memberNode,
                    astUtils.isNotClosingParenToken
                  ),
                  // `)` token of arguments.
                  sourceCode.getLastToken(callNode)
                ]
              ];
              const firstTokenToRemove = tokenPairs[0][0];
              const lastTokenToRemove = tokenPairs[1][1];
              if (sourceCode.commentsExistBetween(firstTokenToRemove, lastTokenToRemove)) {
                return null;
              }
              return tokenPairs.map(([start, end]) => fixer.removeRange([start.range[0], end.range[1]]));
            }
          });
        }
        function isCalleeOfBindMethod(node) {
          if (!astUtils.isSpecificMemberAccess(node.parent, null, "bind")) {
            return false;
          }
          const bindNode = node.parent.parent.type === "ChainExpression" ? node.parent.parent : node.parent;
          return bindNode.parent.type === "CallExpression" && bindNode.parent.callee === bindNode && bindNode.parent.arguments.length === 1 && bindNode.parent.arguments[0].type !== "SpreadElement";
        }
        function enterFunction(node) {
          scopeInfo = {
            isBound: isCalleeOfBindMethod(node),
            thisFound: false,
            upper: scopeInfo
          };
        }
        function exitFunction(node) {
          if (scopeInfo.isBound && !scopeInfo.thisFound) {
            report(node);
          }
          scopeInfo = scopeInfo.upper;
        }
        function exitArrowFunction(node) {
          if (isCalleeOfBindMethod(node)) {
            report(node);
          }
        }
        function markAsThisFound() {
          if (scopeInfo) {
            scopeInfo.thisFound = true;
          }
        }
        return {
          "ArrowFunctionExpression:exit": exitArrowFunction,
          FunctionDeclaration: enterFunction,
          "FunctionDeclaration:exit": exitFunction,
          FunctionExpression: enterFunction,
          "FunctionExpression:exit": exitFunction,
          ThisExpression: markAsThisFound
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-extra-boolean-cast.js
var require_no_extra_boolean_cast = __commonJS({
  "../../node_modules/eslint/lib/rules/no-extra-boolean-cast.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var eslintUtils = require_eslint_utils();
    var precedence = astUtils.getPrecedence;
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow unnecessary boolean casts",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-extra-boolean-cast"
        },
        schema: [{
          type: "object",
          properties: {
            enforceForLogicalOperands: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }],
        fixable: "code",
        messages: {
          unexpectedCall: "Redundant Boolean call.",
          unexpectedNegation: "Redundant double negation."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        const BOOLEAN_NODE_TYPES = /* @__PURE__ */ new Set([
          "IfStatement",
          "DoWhileStatement",
          "WhileStatement",
          "ConditionalExpression",
          "ForStatement"
        ]);
        function isBooleanFunctionOrConstructorCall(node) {
          return (node.type === "CallExpression" || node.type === "NewExpression") && node.callee.type === "Identifier" && node.callee.name === "Boolean";
        }
        function isLogicalContext(node) {
          return node.type === "LogicalExpression" && (node.operator === "||" || node.operator === "&&") && (context.options.length && context.options[0].enforceForLogicalOperands === true);
        }
        function isInBooleanContext(node) {
          return isBooleanFunctionOrConstructorCall(node.parent) && node === node.parent.arguments[0] || BOOLEAN_NODE_TYPES.has(node.parent.type) && node === node.parent.test || // !<bool>
          node.parent.type === "UnaryExpression" && node.parent.operator === "!";
        }
        function isInFlaggedContext(node) {
          if (node.parent.type === "ChainExpression") {
            return isInFlaggedContext(node.parent);
          }
          return isInBooleanContext(node) || isLogicalContext(node.parent) && // For nested logical statements
          isInFlaggedContext(node.parent);
        }
        function hasCommentsInside(node) {
          return Boolean(sourceCode.getCommentsInside(node).length);
        }
        function isParenthesized(node) {
          return eslintUtils.isParenthesized(1, node, sourceCode);
        }
        function needsParens(previousNode, node) {
          if (previousNode.parent.type === "ChainExpression") {
            return needsParens(previousNode.parent, node);
          }
          if (isParenthesized(previousNode)) {
            return false;
          }
          const parent = previousNode.parent;
          switch (parent.type) {
            case "CallExpression":
            case "NewExpression":
              return node.type === "SequenceExpression";
            case "IfStatement":
            case "DoWhileStatement":
            case "WhileStatement":
            case "ForStatement":
              return false;
            case "ConditionalExpression":
              return precedence(node) <= precedence(parent);
            case "UnaryExpression":
              return precedence(node) < precedence(parent);
            case "LogicalExpression":
              if (astUtils.isMixedLogicalAndCoalesceExpressions(node, parent)) {
                return true;
              }
              if (previousNode === parent.left) {
                return precedence(node) < precedence(parent);
              }
              return precedence(node) <= precedence(parent);
            default:
              throw new Error(`Unexpected parent type: ${parent.type}`);
          }
        }
        return {
          UnaryExpression(node) {
            const parent = node.parent;
            if (node.operator !== "!" || parent.type !== "UnaryExpression" || parent.operator !== "!") {
              return;
            }
            if (isInFlaggedContext(parent)) {
              context.report({
                node: parent,
                messageId: "unexpectedNegation",
                fix(fixer) {
                  if (hasCommentsInside(parent)) {
                    return null;
                  }
                  if (needsParens(parent, node.argument)) {
                    return fixer.replaceText(parent, `(${sourceCode.getText(node.argument)})`);
                  }
                  let prefix = "";
                  const tokenBefore = sourceCode.getTokenBefore(parent);
                  const firstReplacementToken = sourceCode.getFirstToken(node.argument);
                  if (tokenBefore && tokenBefore.range[1] === parent.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, firstReplacementToken)) {
                    prefix = " ";
                  }
                  return fixer.replaceText(parent, prefix + sourceCode.getText(node.argument));
                }
              });
            }
          },
          CallExpression(node) {
            if (node.callee.type !== "Identifier" || node.callee.name !== "Boolean") {
              return;
            }
            if (isInFlaggedContext(node)) {
              context.report({
                node,
                messageId: "unexpectedCall",
                fix(fixer) {
                  const parent = node.parent;
                  if (node.arguments.length === 0) {
                    if (parent.type === "UnaryExpression" && parent.operator === "!") {
                      if (hasCommentsInside(parent)) {
                        return null;
                      }
                      const replacement = "true";
                      let prefix = "";
                      const tokenBefore = sourceCode.getTokenBefore(parent);
                      if (tokenBefore && tokenBefore.range[1] === parent.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, replacement)) {
                        prefix = " ";
                      }
                      return fixer.replaceText(parent, prefix + replacement);
                    }
                    if (hasCommentsInside(node)) {
                      return null;
                    }
                    return fixer.replaceText(node, "false");
                  }
                  if (node.arguments.length === 1) {
                    const argument = node.arguments[0];
                    if (argument.type === "SpreadElement" || hasCommentsInside(node)) {
                      return null;
                    }
                    if (needsParens(node, argument)) {
                      return fixer.replaceText(node, `(${sourceCode.getText(argument)})`);
                    }
                    return fixer.replaceText(node, sourceCode.getText(argument));
                  }
                  return null;
                }
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-extra-label.js
var require_no_extra_label = __commonJS({
  "../../node_modules/eslint/lib/rules/no-extra-label.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow unnecessary labels",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-extra-label"
        },
        schema: [],
        fixable: "code",
        messages: {
          unexpected: "This label '{{name}}' is unnecessary."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        let scopeInfo = null;
        function enterBreakableStatement(node) {
          scopeInfo = {
            label: node.parent.type === "LabeledStatement" ? node.parent.label : null,
            breakable: true,
            upper: scopeInfo
          };
        }
        function exitBreakableStatement() {
          scopeInfo = scopeInfo.upper;
        }
        function enterLabeledStatement(node) {
          if (!astUtils.isBreakableStatement(node.body)) {
            scopeInfo = {
              label: node.label,
              breakable: false,
              upper: scopeInfo
            };
          }
        }
        function exitLabeledStatement(node) {
          if (!astUtils.isBreakableStatement(node.body)) {
            scopeInfo = scopeInfo.upper;
          }
        }
        function reportIfUnnecessary(node) {
          if (!node.label) {
            return;
          }
          const labelNode = node.label;
          for (let info = scopeInfo; info !== null; info = info.upper) {
            if (info.breakable || info.label && info.label.name === labelNode.name) {
              if (info.breakable && info.label && info.label.name === labelNode.name) {
                context.report({
                  node: labelNode,
                  messageId: "unexpected",
                  data: labelNode,
                  fix(fixer) {
                    const breakOrContinueToken = sourceCode.getFirstToken(node);
                    if (sourceCode.commentsExistBetween(breakOrContinueToken, labelNode)) {
                      return null;
                    }
                    return fixer.removeRange([breakOrContinueToken.range[1], labelNode.range[1]]);
                  }
                });
              }
              return;
            }
          }
        }
        return {
          WhileStatement: enterBreakableStatement,
          "WhileStatement:exit": exitBreakableStatement,
          DoWhileStatement: enterBreakableStatement,
          "DoWhileStatement:exit": exitBreakableStatement,
          ForStatement: enterBreakableStatement,
          "ForStatement:exit": exitBreakableStatement,
          ForInStatement: enterBreakableStatement,
          "ForInStatement:exit": exitBreakableStatement,
          ForOfStatement: enterBreakableStatement,
          "ForOfStatement:exit": exitBreakableStatement,
          SwitchStatement: enterBreakableStatement,
          "SwitchStatement:exit": exitBreakableStatement,
          LabeledStatement: enterLabeledStatement,
          "LabeledStatement:exit": exitLabeledStatement,
          BreakStatement: reportIfUnnecessary,
          ContinueStatement: reportIfUnnecessary
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-extra-parens.js
var require_no_extra_parens = __commonJS({
  "../../node_modules/eslint/lib/rules/no-extra-parens.js"(exports, module) {
    "use strict";
    var { isParenthesized: isParenthesizedRaw } = require_eslint_utils();
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Disallow unnecessary parentheses",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-extra-parens"
        },
        fixable: "code",
        schema: {
          anyOf: [
            {
              type: "array",
              items: [
                {
                  enum: ["functions"]
                }
              ],
              minItems: 0,
              maxItems: 1
            },
            {
              type: "array",
              items: [
                {
                  enum: ["all"]
                },
                {
                  type: "object",
                  properties: {
                    conditionalAssign: { type: "boolean" },
                    ternaryOperandBinaryExpressions: { type: "boolean" },
                    nestedBinaryExpressions: { type: "boolean" },
                    returnAssign: { type: "boolean" },
                    ignoreJSX: { enum: ["none", "all", "single-line", "multi-line"] },
                    enforceForArrowConditionals: { type: "boolean" },
                    enforceForSequenceExpressions: { type: "boolean" },
                    enforceForNewInMemberExpressions: { type: "boolean" },
                    enforceForFunctionPrototypeMethods: { type: "boolean" },
                    allowParensAfterCommentPattern: { type: "string" }
                  },
                  additionalProperties: false
                }
              ],
              minItems: 0,
              maxItems: 2
            }
          ]
        },
        messages: {
          unexpected: "Unnecessary parentheses around expression."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        const tokensToIgnore = /* @__PURE__ */ new WeakSet();
        const precedence = astUtils.getPrecedence;
        const ALL_NODES = context.options[0] !== "functions";
        const EXCEPT_COND_ASSIGN = ALL_NODES && context.options[1] && context.options[1].conditionalAssign === false;
        const EXCEPT_COND_TERNARY = ALL_NODES && context.options[1] && context.options[1].ternaryOperandBinaryExpressions === false;
        const NESTED_BINARY = ALL_NODES && context.options[1] && context.options[1].nestedBinaryExpressions === false;
        const EXCEPT_RETURN_ASSIGN = ALL_NODES && context.options[1] && context.options[1].returnAssign === false;
        const IGNORE_JSX = ALL_NODES && context.options[1] && context.options[1].ignoreJSX;
        const IGNORE_ARROW_CONDITIONALS = ALL_NODES && context.options[1] && context.options[1].enforceForArrowConditionals === false;
        const IGNORE_SEQUENCE_EXPRESSIONS = ALL_NODES && context.options[1] && context.options[1].enforceForSequenceExpressions === false;
        const IGNORE_NEW_IN_MEMBER_EXPR = ALL_NODES && context.options[1] && context.options[1].enforceForNewInMemberExpressions === false;
        const IGNORE_FUNCTION_PROTOTYPE_METHODS = ALL_NODES && context.options[1] && context.options[1].enforceForFunctionPrototypeMethods === false;
        const ALLOW_PARENS_AFTER_COMMENT_PATTERN = ALL_NODES && context.options[1] && context.options[1].allowParensAfterCommentPattern;
        const PRECEDENCE_OF_ASSIGNMENT_EXPR = precedence({ type: "AssignmentExpression" });
        const PRECEDENCE_OF_UPDATE_EXPR = precedence({ type: "UpdateExpression" });
        let reportsBuffer;
        function isImmediateFunctionPrototypeMethodCall(node) {
          const callNode = astUtils.skipChainExpression(node);
          if (callNode.type !== "CallExpression") {
            return false;
          }
          const callee = astUtils.skipChainExpression(callNode.callee);
          return callee.type === "MemberExpression" && callee.object.type === "FunctionExpression" && ["call", "apply"].includes(astUtils.getStaticPropertyName(callee));
        }
        function ruleApplies(node) {
          if (node.type === "JSXElement" || node.type === "JSXFragment") {
            const isSingleLine = node.loc.start.line === node.loc.end.line;
            switch (IGNORE_JSX) {
              case "all":
                return false;
              case "multi-line":
                return isSingleLine;
              case "single-line":
                return !isSingleLine;
              case "none":
                break;
            }
          }
          if (node.type === "SequenceExpression" && IGNORE_SEQUENCE_EXPRESSIONS) {
            return false;
          }
          if (isImmediateFunctionPrototypeMethodCall(node) && IGNORE_FUNCTION_PROTOTYPE_METHODS) {
            return false;
          }
          return ALL_NODES || node.type === "FunctionExpression" || node.type === "ArrowFunctionExpression";
        }
        function isParenthesised(node) {
          return isParenthesizedRaw(1, node, sourceCode);
        }
        function isParenthesisedTwice(node) {
          return isParenthesizedRaw(2, node, sourceCode);
        }
        function hasExcessParens(node) {
          return ruleApplies(node) && isParenthesised(node);
        }
        function hasDoubleExcessParens(node) {
          return ruleApplies(node) && isParenthesisedTwice(node);
        }
        function hasExcessParensWithPrecedence(node, precedenceLowerLimit) {
          if (ruleApplies(node) && isParenthesised(node)) {
            if (precedence(node) >= precedenceLowerLimit || isParenthesisedTwice(node)) {
              return true;
            }
          }
          return false;
        }
        function isCondAssignException(node) {
          return EXCEPT_COND_ASSIGN && node.test.type === "AssignmentExpression";
        }
        function isInReturnStatement(node) {
          for (let currentNode = node; currentNode; currentNode = currentNode.parent) {
            if (currentNode.type === "ReturnStatement" || currentNode.type === "ArrowFunctionExpression" && currentNode.body.type !== "BlockStatement") {
              return true;
            }
          }
          return false;
        }
        function isNewExpressionWithParens(newExpression) {
          const lastToken = sourceCode.getLastToken(newExpression);
          const penultimateToken = sourceCode.getTokenBefore(lastToken);
          return newExpression.arguments.length > 0 || // The expression should end with its own parens, e.g., new new foo() is not a new expression with parens
          astUtils.isOpeningParenToken(penultimateToken) && astUtils.isClosingParenToken(lastToken) && newExpression.callee.range[1] < newExpression.range[1];
        }
        function containsAssignment(node) {
          if (node.type === "AssignmentExpression") {
            return true;
          }
          if (node.type === "ConditionalExpression" && (node.consequent.type === "AssignmentExpression" || node.alternate.type === "AssignmentExpression")) {
            return true;
          }
          if (node.left && node.left.type === "AssignmentExpression" || node.right && node.right.type === "AssignmentExpression") {
            return true;
          }
          return false;
        }
        function isReturnAssignException(node) {
          if (!EXCEPT_RETURN_ASSIGN || !isInReturnStatement(node)) {
            return false;
          }
          if (node.type === "ReturnStatement") {
            return node.argument && containsAssignment(node.argument);
          }
          if (node.type === "ArrowFunctionExpression" && node.body.type !== "BlockStatement") {
            return containsAssignment(node.body);
          }
          return containsAssignment(node);
        }
        function hasExcessParensNoLineTerminator(token, node) {
          if (token.loc.end.line === node.loc.start.line) {
            return hasExcessParens(node);
          }
          return hasDoubleExcessParens(node);
        }
        function requiresLeadingSpace(node) {
          const leftParenToken = sourceCode.getTokenBefore(node);
          const tokenBeforeLeftParen = sourceCode.getTokenBefore(leftParenToken, { includeComments: true });
          const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParenToken, { includeComments: true });
          return tokenBeforeLeftParen && tokenBeforeLeftParen.range[1] === leftParenToken.range[0] && leftParenToken.range[1] === tokenAfterLeftParen.range[0] && !astUtils.canTokensBeAdjacent(tokenBeforeLeftParen, tokenAfterLeftParen);
        }
        function requiresTrailingSpace(node) {
          const nextTwoTokens = sourceCode.getTokensAfter(node, { count: 2 });
          const rightParenToken = nextTwoTokens[0];
          const tokenAfterRightParen = nextTwoTokens[1];
          const tokenBeforeRightParen = sourceCode.getLastToken(node);
          return rightParenToken && tokenAfterRightParen && !sourceCode.isSpaceBetweenTokens(rightParenToken, tokenAfterRightParen) && !astUtils.canTokensBeAdjacent(tokenBeforeRightParen, tokenAfterRightParen);
        }
        function isIIFE(node) {
          const maybeCallNode = astUtils.skipChainExpression(node);
          return maybeCallNode.type === "CallExpression" && maybeCallNode.callee.type === "FunctionExpression";
        }
        function canBeAssignmentTarget(node) {
          return node && (node.type === "Identifier" || node.type === "MemberExpression");
        }
        function isFixable(node) {
          if (node.type !== "Literal" || typeof node.value !== "string") {
            return true;
          }
          if (isParenthesisedTwice(node)) {
            return true;
          }
          return !astUtils.isTopLevelExpressionStatement(node.parent);
        }
        function report(node) {
          const leftParenToken = sourceCode.getTokenBefore(node);
          const rightParenToken = sourceCode.getTokenAfter(node);
          if (!isParenthesisedTwice(node)) {
            if (tokensToIgnore.has(sourceCode.getFirstToken(node))) {
              return;
            }
            if (isIIFE(node) && !isParenthesised(node.callee)) {
              return;
            }
            if (ALLOW_PARENS_AFTER_COMMENT_PATTERN) {
              const commentsBeforeLeftParenToken = sourceCode.getCommentsBefore(leftParenToken);
              const totalCommentsBeforeLeftParenTokenCount = commentsBeforeLeftParenToken.length;
              const ignorePattern = new RegExp(ALLOW_PARENS_AFTER_COMMENT_PATTERN, "u");
              if (totalCommentsBeforeLeftParenTokenCount > 0 && ignorePattern.test(commentsBeforeLeftParenToken[totalCommentsBeforeLeftParenTokenCount - 1].value)) {
                return;
              }
            }
          }
          function finishReport() {
            context.report({
              node,
              loc: leftParenToken.loc,
              messageId: "unexpected",
              fix: isFixable(node) ? (fixer) => {
                const parenthesizedSource = sourceCode.text.slice(leftParenToken.range[1], rightParenToken.range[0]);
                return fixer.replaceTextRange([
                  leftParenToken.range[0],
                  rightParenToken.range[1]
                ], (requiresLeadingSpace(node) ? " " : "") + parenthesizedSource + (requiresTrailingSpace(node) ? " " : ""));
              } : null
            });
          }
          if (reportsBuffer) {
            reportsBuffer.reports.push({ node, finishReport });
            return;
          }
          finishReport();
        }
        function checkArgumentWithPrecedence(node) {
          if (hasExcessParensWithPrecedence(node.argument, precedence(node))) {
            report(node.argument);
          }
        }
        function doesMemberExpressionContainCallExpression(node) {
          let currentNode = node.object;
          let currentNodeType = node.object.type;
          while (currentNodeType === "MemberExpression") {
            currentNode = currentNode.object;
            currentNodeType = currentNode.type;
          }
          return currentNodeType === "CallExpression";
        }
        function checkCallNew(node) {
          const callee = node.callee;
          if (hasExcessParensWithPrecedence(callee, precedence(node))) {
            if (hasDoubleExcessParens(callee) || !(isIIFE(node) || // (new A)(); new (new A)();
            callee.type === "NewExpression" && !isNewExpressionWithParens(callee) && !(node.type === "NewExpression" && !isNewExpressionWithParens(node)) || // new (a().b)(); new (a.b().c);
            node.type === "NewExpression" && callee.type === "MemberExpression" && doesMemberExpressionContainCallExpression(callee) || // (a?.b)(); (a?.())();
            !node.optional && callee.type === "ChainExpression")) {
              report(node.callee);
            }
          }
          node.arguments.filter((arg) => hasExcessParensWithPrecedence(arg, PRECEDENCE_OF_ASSIGNMENT_EXPR)).forEach(report);
        }
        function checkBinaryLogical(node) {
          const prec = precedence(node);
          const leftPrecedence = precedence(node.left);
          const rightPrecedence = precedence(node.right);
          const isExponentiation = node.operator === "**";
          const shouldSkipLeft = NESTED_BINARY && (node.left.type === "BinaryExpression" || node.left.type === "LogicalExpression");
          const shouldSkipRight = NESTED_BINARY && (node.right.type === "BinaryExpression" || node.right.type === "LogicalExpression");
          if (!shouldSkipLeft && hasExcessParens(node.left)) {
            if (!(["AwaitExpression", "UnaryExpression"].includes(node.left.type) && isExponentiation) && !astUtils.isMixedLogicalAndCoalesceExpressions(node.left, node) && (leftPrecedence > prec || leftPrecedence === prec && !isExponentiation) || isParenthesisedTwice(node.left)) {
              report(node.left);
            }
          }
          if (!shouldSkipRight && hasExcessParens(node.right)) {
            if (!astUtils.isMixedLogicalAndCoalesceExpressions(node.right, node) && (rightPrecedence > prec || rightPrecedence === prec && isExponentiation) || isParenthesisedTwice(node.right)) {
              report(node.right);
            }
          }
        }
        function checkClass(node) {
          if (!node.superClass) {
            return;
          }
          const hasExtraParens = precedence(node.superClass) > PRECEDENCE_OF_UPDATE_EXPR ? hasExcessParens(node.superClass) : hasDoubleExcessParens(node.superClass);
          if (hasExtraParens) {
            report(node.superClass);
          }
        }
        function checkSpreadOperator(node) {
          if (hasExcessParensWithPrecedence(node.argument, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {
            report(node.argument);
          }
        }
        function checkExpressionOrExportStatement(node) {
          const firstToken = isParenthesised(node) ? sourceCode.getTokenBefore(node) : sourceCode.getFirstToken(node);
          const secondToken = sourceCode.getTokenAfter(firstToken, astUtils.isNotOpeningParenToken);
          const thirdToken = secondToken ? sourceCode.getTokenAfter(secondToken) : null;
          const tokenAfterClosingParens = secondToken ? sourceCode.getTokenAfter(secondToken, astUtils.isNotClosingParenToken) : null;
          if (astUtils.isOpeningParenToken(firstToken) && (astUtils.isOpeningBraceToken(secondToken) || secondToken.type === "Keyword" && (secondToken.value === "function" || secondToken.value === "class" || secondToken.value === "let" && tokenAfterClosingParens && (astUtils.isOpeningBracketToken(tokenAfterClosingParens) || tokenAfterClosingParens.type === "Identifier")) || secondToken && secondToken.type === "Identifier" && secondToken.value === "async" && thirdToken && thirdToken.type === "Keyword" && thirdToken.value === "function")) {
            tokensToIgnore.add(secondToken);
          }
          const hasExtraParens = node.parent.type === "ExportDefaultDeclaration" ? hasExcessParensWithPrecedence(node, PRECEDENCE_OF_ASSIGNMENT_EXPR) : hasExcessParens(node);
          if (hasExtraParens) {
            report(node);
          }
        }
        function pathToAncestor(node, ancestor) {
          const path = [node];
          let currentNode = node;
          while (currentNode !== ancestor) {
            currentNode = currentNode.parent;
            if (currentNode === null) {
              throw new Error("Nodes are not in the ancestor-descendant relationship.");
            }
            path.push(currentNode);
          }
          return path;
        }
        function pathToDescendant(node, descendant) {
          return pathToAncestor(descendant, node).reverse();
        }
        function isSafelyEnclosingInExpression(node, child) {
          switch (node.type) {
            case "ArrayExpression":
            case "ArrayPattern":
            case "BlockStatement":
            case "ObjectExpression":
            case "ObjectPattern":
            case "TemplateLiteral":
              return true;
            case "ArrowFunctionExpression":
            case "FunctionExpression":
              return node.params.includes(child);
            case "CallExpression":
            case "NewExpression":
              return node.arguments.includes(child);
            case "MemberExpression":
              return node.computed && node.property === child;
            case "ConditionalExpression":
              return node.consequent === child;
            default:
              return false;
          }
        }
        function startNewReportsBuffering() {
          reportsBuffer = {
            upper: reportsBuffer,
            inExpressionNodes: [],
            reports: []
          };
        }
        function endCurrentReportsBuffering() {
          const { upper, inExpressionNodes, reports } = reportsBuffer;
          if (upper) {
            upper.inExpressionNodes.push(...inExpressionNodes);
            upper.reports.push(...reports);
          } else {
            reports.forEach(({ finishReport }) => finishReport());
          }
          reportsBuffer = upper;
        }
        function isInCurrentReportsBuffer(node) {
          return reportsBuffer.reports.some((r) => r.node === node);
        }
        function removeFromCurrentReportsBuffer(node) {
          reportsBuffer.reports = reportsBuffer.reports.filter((r) => r.node !== node);
        }
        function isMemberExpInNewCallee(node) {
          if (node.type === "MemberExpression") {
            return node.parent.type === "NewExpression" && node.parent.callee === node ? true : node.parent.object === node && isMemberExpInNewCallee(node.parent);
          }
          return false;
        }
        function isAnonymousFunctionAssignmentException({ left, operator, right }) {
          if (left.type === "Identifier" && ["=", "&&=", "||=", "??="].includes(operator)) {
            const rhsType = right.type;
            if (rhsType === "ArrowFunctionExpression") {
              return true;
            }
            if ((rhsType === "FunctionExpression" || rhsType === "ClassExpression") && !right.id) {
              return true;
            }
          }
          return false;
        }
        return {
          ArrayExpression(node) {
            node.elements.filter((e) => e && hasExcessParensWithPrecedence(e, PRECEDENCE_OF_ASSIGNMENT_EXPR)).forEach(report);
          },
          ArrayPattern(node) {
            node.elements.filter((e) => canBeAssignmentTarget(e) && hasExcessParens(e)).forEach(report);
          },
          ArrowFunctionExpression(node) {
            if (isReturnAssignException(node)) {
              return;
            }
            if (node.body.type === "ConditionalExpression" && IGNORE_ARROW_CONDITIONALS) {
              return;
            }
            if (node.body.type !== "BlockStatement") {
              const firstBodyToken = sourceCode.getFirstToken(node.body, astUtils.isNotOpeningParenToken);
              const tokenBeforeFirst = sourceCode.getTokenBefore(firstBodyToken);
              if (astUtils.isOpeningParenToken(tokenBeforeFirst) && astUtils.isOpeningBraceToken(firstBodyToken)) {
                tokensToIgnore.add(firstBodyToken);
              }
              if (hasExcessParensWithPrecedence(node.body, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {
                report(node.body);
              }
            }
          },
          AssignmentExpression(node) {
            if (canBeAssignmentTarget(node.left) && hasExcessParens(node.left) && (!isAnonymousFunctionAssignmentException(node) || isParenthesisedTwice(node.left))) {
              report(node.left);
            }
            if (!isReturnAssignException(node) && hasExcessParensWithPrecedence(node.right, precedence(node))) {
              report(node.right);
            }
          },
          BinaryExpression(node) {
            if (reportsBuffer && node.operator === "in") {
              reportsBuffer.inExpressionNodes.push(node);
            }
            checkBinaryLogical(node);
          },
          CallExpression: checkCallNew,
          ConditionalExpression(node) {
            if (isReturnAssignException(node)) {
              return;
            }
            const availableTypes = /* @__PURE__ */ new Set(["BinaryExpression", "LogicalExpression"]);
            if (!(EXCEPT_COND_TERNARY && availableTypes.has(node.test.type)) && !isCondAssignException(node) && hasExcessParensWithPrecedence(node.test, precedence({ type: "LogicalExpression", operator: "||" }))) {
              report(node.test);
            }
            if (!(EXCEPT_COND_TERNARY && availableTypes.has(node.consequent.type)) && hasExcessParensWithPrecedence(node.consequent, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {
              report(node.consequent);
            }
            if (!(EXCEPT_COND_TERNARY && availableTypes.has(node.alternate.type)) && hasExcessParensWithPrecedence(node.alternate, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {
              report(node.alternate);
            }
          },
          DoWhileStatement(node) {
            if (hasExcessParens(node.test) && !isCondAssignException(node)) {
              report(node.test);
            }
          },
          ExportDefaultDeclaration: (node) => checkExpressionOrExportStatement(node.declaration),
          ExpressionStatement: (node) => checkExpressionOrExportStatement(node.expression),
          ForInStatement(node) {
            if (node.left.type !== "VariableDeclaration") {
              const firstLeftToken = sourceCode.getFirstToken(node.left, astUtils.isNotOpeningParenToken);
              if (firstLeftToken.value === "let" && astUtils.isOpeningBracketToken(
                sourceCode.getTokenAfter(firstLeftToken, astUtils.isNotClosingParenToken)
              )) {
                tokensToIgnore.add(firstLeftToken);
              }
            }
            if (hasExcessParens(node.left)) {
              report(node.left);
            }
            if (hasExcessParens(node.right)) {
              report(node.right);
            }
          },
          ForOfStatement(node) {
            if (node.left.type !== "VariableDeclaration") {
              const firstLeftToken = sourceCode.getFirstToken(node.left, astUtils.isNotOpeningParenToken);
              if (firstLeftToken.value === "let") {
                tokensToIgnore.add(firstLeftToken);
              }
            }
            if (hasExcessParens(node.left)) {
              report(node.left);
            }
            if (hasExcessParensWithPrecedence(node.right, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {
              report(node.right);
            }
          },
          ForStatement(node) {
            if (node.test && hasExcessParens(node.test) && !isCondAssignException(node)) {
              report(node.test);
            }
            if (node.update && hasExcessParens(node.update)) {
              report(node.update);
            }
            if (node.init) {
              if (node.init.type !== "VariableDeclaration") {
                const firstToken = sourceCode.getFirstToken(node.init, astUtils.isNotOpeningParenToken);
                if (firstToken.value === "let" && astUtils.isOpeningBracketToken(
                  sourceCode.getTokenAfter(firstToken, astUtils.isNotClosingParenToken)
                )) {
                  tokensToIgnore.add(firstToken);
                }
              }
              startNewReportsBuffering();
              if (hasExcessParens(node.init)) {
                report(node.init);
              }
            }
          },
          "ForStatement > *.init:exit"(node) {
            if (reportsBuffer.reports.length) {
              reportsBuffer.inExpressionNodes.forEach((inExpressionNode) => {
                const path = pathToDescendant(node, inExpressionNode);
                let nodeToExclude;
                for (let i = 0; i < path.length; i++) {
                  const pathNode = path[i];
                  if (i < path.length - 1) {
                    const nextPathNode = path[i + 1];
                    if (isSafelyEnclosingInExpression(pathNode, nextPathNode)) {
                      return;
                    }
                  }
                  if (isParenthesised(pathNode)) {
                    if (isInCurrentReportsBuffer(pathNode)) {
                      if (isParenthesisedTwice(pathNode)) {
                        return;
                      }
                      if (!nodeToExclude) {
                        nodeToExclude = pathNode;
                      }
                    } else {
                      return;
                    }
                  }
                }
                removeFromCurrentReportsBuffer(nodeToExclude);
              });
            }
            endCurrentReportsBuffering();
          },
          IfStatement(node) {
            if (hasExcessParens(node.test) && !isCondAssignException(node)) {
              report(node.test);
            }
          },
          ImportExpression(node) {
            const { source } = node;
            if (source.type === "SequenceExpression") {
              if (hasDoubleExcessParens(source)) {
                report(source);
              }
            } else if (hasExcessParens(source)) {
              report(source);
            }
          },
          LogicalExpression: checkBinaryLogical,
          MemberExpression(node) {
            const shouldAllowWrapOnce = isMemberExpInNewCallee(node) && doesMemberExpressionContainCallExpression(node);
            const nodeObjHasExcessParens = shouldAllowWrapOnce ? hasDoubleExcessParens(node.object) : hasExcessParens(node.object) && !(isImmediateFunctionPrototypeMethodCall(node.parent) && node.parent.callee === node && IGNORE_FUNCTION_PROTOTYPE_METHODS);
            if (nodeObjHasExcessParens && precedence(node.object) >= precedence(node) && (node.computed || !(astUtils.isDecimalInteger(node.object) || // RegExp literal is allowed to have parens (#1589)
            node.object.type === "Literal" && node.object.regex))) {
              report(node.object);
            }
            if (nodeObjHasExcessParens && node.object.type === "CallExpression") {
              report(node.object);
            }
            if (nodeObjHasExcessParens && !IGNORE_NEW_IN_MEMBER_EXPR && node.object.type === "NewExpression" && isNewExpressionWithParens(node.object)) {
              report(node.object);
            }
            if (nodeObjHasExcessParens && node.optional && node.object.type === "ChainExpression") {
              report(node.object);
            }
            if (node.computed && hasExcessParens(node.property)) {
              report(node.property);
            }
          },
          "MethodDefinition[computed=true]"(node) {
            if (hasExcessParensWithPrecedence(node.key, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {
              report(node.key);
            }
          },
          NewExpression: checkCallNew,
          ObjectExpression(node) {
            node.properties.filter((property) => property.value && hasExcessParensWithPrecedence(property.value, PRECEDENCE_OF_ASSIGNMENT_EXPR)).forEach((property) => report(property.value));
          },
          ObjectPattern(node) {
            node.properties.filter((property) => {
              const value = property.value;
              return canBeAssignmentTarget(value) && hasExcessParens(value);
            }).forEach((property) => report(property.value));
          },
          Property(node) {
            if (node.computed) {
              const { key } = node;
              if (key && hasExcessParensWithPrecedence(key, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {
                report(key);
              }
            }
          },
          PropertyDefinition(node) {
            if (node.computed && hasExcessParensWithPrecedence(node.key, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {
              report(node.key);
            }
            if (node.value && hasExcessParensWithPrecedence(node.value, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {
              report(node.value);
            }
          },
          RestElement(node) {
            const argument = node.argument;
            if (canBeAssignmentTarget(argument) && hasExcessParens(argument)) {
              report(argument);
            }
          },
          ReturnStatement(node) {
            const returnToken = sourceCode.getFirstToken(node);
            if (isReturnAssignException(node)) {
              return;
            }
            if (node.argument && hasExcessParensNoLineTerminator(returnToken, node.argument) && // RegExp literal is allowed to have parens (#1589)
            !(node.argument.type === "Literal" && node.argument.regex)) {
              report(node.argument);
            }
          },
          SequenceExpression(node) {
            const precedenceOfNode = precedence(node);
            node.expressions.filter((e) => hasExcessParensWithPrecedence(e, precedenceOfNode)).forEach(report);
          },
          SwitchCase(node) {
            if (node.test && hasExcessParens(node.test)) {
              report(node.test);
            }
          },
          SwitchStatement(node) {
            if (hasExcessParens(node.discriminant)) {
              report(node.discriminant);
            }
          },
          ThrowStatement(node) {
            const throwToken = sourceCode.getFirstToken(node);
            if (hasExcessParensNoLineTerminator(throwToken, node.argument)) {
              report(node.argument);
            }
          },
          UnaryExpression: checkArgumentWithPrecedence,
          UpdateExpression(node) {
            if (node.prefix) {
              checkArgumentWithPrecedence(node);
            } else {
              const { argument } = node;
              const operatorToken = sourceCode.getLastToken(node);
              if (argument.loc.end.line === operatorToken.loc.start.line) {
                checkArgumentWithPrecedence(node);
              } else {
                if (hasDoubleExcessParens(argument)) {
                  report(argument);
                }
              }
            }
          },
          AwaitExpression: checkArgumentWithPrecedence,
          VariableDeclarator(node) {
            if (node.init && hasExcessParensWithPrecedence(node.init, PRECEDENCE_OF_ASSIGNMENT_EXPR) && // RegExp literal is allowed to have parens (#1589)
            !(node.init.type === "Literal" && node.init.regex)) {
              report(node.init);
            }
          },
          WhileStatement(node) {
            if (hasExcessParens(node.test) && !isCondAssignException(node)) {
              report(node.test);
            }
          },
          WithStatement(node) {
            if (hasExcessParens(node.object)) {
              report(node.object);
            }
          },
          YieldExpression(node) {
            if (node.argument) {
              const yieldToken = sourceCode.getFirstToken(node);
              if (precedence(node.argument) >= precedence(node) && hasExcessParensNoLineTerminator(yieldToken, node.argument) || hasDoubleExcessParens(node.argument)) {
                report(node.argument);
              }
            }
          },
          ClassDeclaration: checkClass,
          ClassExpression: checkClass,
          SpreadElement: checkSpreadOperator,
          SpreadProperty: checkSpreadOperator,
          ExperimentalSpreadProperty: checkSpreadOperator,
          TemplateLiteral(node) {
            node.expressions.filter((e) => e && hasExcessParens(e)).forEach(report);
          },
          AssignmentPattern(node) {
            const { left, right } = node;
            if (canBeAssignmentTarget(left) && hasExcessParens(left)) {
              report(left);
            }
            if (right && hasExcessParensWithPrecedence(right, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {
              report(right);
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-extra-semi.js
var require_no_extra_semi = __commonJS({
  "../../node_modules/eslint/lib/rules/no-extra-semi.js"(exports, module) {
    "use strict";
    var FixTracker = require_fix_tracker();
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow unnecessary semicolons",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-extra-semi"
        },
        fixable: "code",
        schema: [],
        messages: {
          unexpected: "Unnecessary semicolon."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        function isFixable(nodeOrToken) {
          const nextToken = sourceCode.getTokenAfter(nodeOrToken);
          if (!nextToken || nextToken.type !== "String") {
            return true;
          }
          const stringNode = sourceCode.getNodeByRangeIndex(nextToken.range[0]);
          return !astUtils.isTopLevelExpressionStatement(stringNode.parent);
        }
        function report(nodeOrToken) {
          context.report({
            node: nodeOrToken,
            messageId: "unexpected",
            fix: isFixable(nodeOrToken) ? (fixer) => (
              /*
               * Expand the replacement range to include the surrounding
               * tokens to avoid conflicting with semi.
               * https://github.com/eslint/eslint/issues/7928
               */
              new FixTracker(fixer, context.sourceCode).retainSurroundingTokens(nodeOrToken).remove(nodeOrToken)
            ) : null
          });
        }
        function checkForPartOfClassBody(firstToken) {
          for (let token = firstToken; token.type === "Punctuator" && !astUtils.isClosingBraceToken(token); token = sourceCode.getTokenAfter(token)) {
            if (astUtils.isSemicolonToken(token)) {
              report(token);
            }
          }
        }
        return {
          /**
           * Reports this empty statement, except if the parent node is a loop.
           * @param {Node} node A EmptyStatement node to be reported.
           * @returns {void}
           */
          EmptyStatement(node) {
            const parent = node.parent, allowedParentTypes = [
              "ForStatement",
              "ForInStatement",
              "ForOfStatement",
              "WhileStatement",
              "DoWhileStatement",
              "IfStatement",
              "LabeledStatement",
              "WithStatement"
            ];
            if (!allowedParentTypes.includes(parent.type)) {
              report(node);
            }
          },
          /**
           * Checks tokens from the head of this class body to the first MethodDefinition or the end of this class body.
           * @param {Node} node A ClassBody node to check.
           * @returns {void}
           */
          ClassBody(node) {
            checkForPartOfClassBody(sourceCode.getFirstToken(node, 1));
          },
          /**
           * Checks tokens from this MethodDefinition to the next MethodDefinition or the end of this class body.
           * @param {Node} node A MethodDefinition node of the start point.
           * @returns {void}
           */
          "MethodDefinition, PropertyDefinition, StaticBlock"(node) {
            checkForPartOfClassBody(sourceCode.getTokenAfter(node));
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-fallthrough.js
var require_no_fallthrough = __commonJS({
  "../../node_modules/eslint/lib/rules/no-fallthrough.js"(exports, module) {
    "use strict";
    var { directivesPattern } = require_directives();
    var DEFAULT_FALLTHROUGH_COMMENT = /falls?\s?through/iu;
    function isFallThroughComment(comment, fallthroughCommentPattern) {
      return fallthroughCommentPattern.test(comment) && !directivesPattern.test(comment.trim());
    }
    function hasFallthroughComment(caseWhichFallsThrough, subsequentCase, context, fallthroughCommentPattern) {
      const sourceCode = context.sourceCode;
      if (caseWhichFallsThrough.consequent.length === 1 && caseWhichFallsThrough.consequent[0].type === "BlockStatement") {
        const trailingCloseBrace = sourceCode.getLastToken(caseWhichFallsThrough.consequent[0]);
        const commentInBlock = sourceCode.getCommentsBefore(trailingCloseBrace).pop();
        if (commentInBlock && isFallThroughComment(commentInBlock.value, fallthroughCommentPattern)) {
          return true;
        }
      }
      const comment = sourceCode.getCommentsBefore(subsequentCase).pop();
      return Boolean(comment && isFallThroughComment(comment.value, fallthroughCommentPattern));
    }
    function isReachable(segment) {
      return segment.reachable;
    }
    function hasBlankLinesBetween(node, token) {
      return token.loc.start.line > node.loc.end.line + 1;
    }
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow fallthrough of `case` statements",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-fallthrough"
        },
        schema: [
          {
            type: "object",
            properties: {
              commentPattern: {
                type: "string",
                default: ""
              },
              allowEmptyCase: {
                type: "boolean",
                default: false
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          case: "Expected a 'break' statement before 'case'.",
          default: "Expected a 'break' statement before 'default'."
        }
      },
      create(context) {
        const options = context.options[0] || {};
        let currentCodePath = null;
        const sourceCode = context.sourceCode;
        const allowEmptyCase = options.allowEmptyCase || false;
        let fallthroughCase = null;
        let fallthroughCommentPattern = null;
        if (options.commentPattern) {
          fallthroughCommentPattern = new RegExp(options.commentPattern, "u");
        } else {
          fallthroughCommentPattern = DEFAULT_FALLTHROUGH_COMMENT;
        }
        return {
          onCodePathStart(codePath) {
            currentCodePath = codePath;
          },
          onCodePathEnd() {
            currentCodePath = currentCodePath.upper;
          },
          SwitchCase(node) {
            if (fallthroughCase && !hasFallthroughComment(fallthroughCase, node, context, fallthroughCommentPattern)) {
              context.report({
                messageId: node.test ? "case" : "default",
                node
              });
            }
            fallthroughCase = null;
          },
          "SwitchCase:exit"(node) {
            const nextToken = sourceCode.getTokenAfter(node);
            if (currentCodePath.currentSegments.some(isReachable) && (node.consequent.length > 0 || !allowEmptyCase && hasBlankLinesBetween(node, nextToken)) && node.parent.cases[node.parent.cases.length - 1] !== node) {
              fallthroughCase = node;
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-floating-decimal.js
var require_no_floating_decimal = __commonJS({
  "../../node_modules/eslint/lib/rules/no-floating-decimal.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow leading or trailing decimal points in numeric literals",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-floating-decimal"
        },
        schema: [],
        fixable: "code",
        messages: {
          leading: "A leading decimal point can be confused with a dot.",
          trailing: "A trailing decimal point can be confused with a dot."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        return {
          Literal(node) {
            if (typeof node.value === "number") {
              if (node.raw.startsWith(".")) {
                context.report({
                  node,
                  messageId: "leading",
                  fix(fixer) {
                    const tokenBefore = sourceCode.getTokenBefore(node);
                    const needsSpaceBefore = tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, `0${node.raw}`);
                    return fixer.insertTextBefore(node, needsSpaceBefore ? " 0" : "0");
                  }
                });
              }
              if (node.raw.indexOf(".") === node.raw.length - 1) {
                context.report({
                  node,
                  messageId: "trailing",
                  fix: (fixer) => fixer.insertTextAfter(node, "0")
                });
              }
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-func-assign.js
var require_no_func_assign = __commonJS({
  "../../node_modules/eslint/lib/rules/no-func-assign.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow reassigning `function` declarations",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-func-assign"
        },
        schema: [],
        messages: {
          isAFunction: "'{{name}}' is a function."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        function checkReference(references) {
          astUtils.getModifyingReferences(references).forEach((reference) => {
            context.report({
              node: reference.identifier,
              messageId: "isAFunction",
              data: {
                name: reference.identifier.name
              }
            });
          });
        }
        function checkVariable(variable) {
          if (variable.defs[0].type === "FunctionName") {
            checkReference(variable.references);
          }
        }
        function checkForFunction(node) {
          sourceCode.getDeclaredVariables(node).forEach(checkVariable);
        }
        return {
          FunctionDeclaration: checkForFunction,
          FunctionExpression: checkForFunction
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-global-assign.js
var require_no_global_assign = __commonJS({
  "../../node_modules/eslint/lib/rules/no-global-assign.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow assignments to native objects or read-only global variables",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-global-assign"
        },
        schema: [
          {
            type: "object",
            properties: {
              exceptions: {
                type: "array",
                items: { type: "string" },
                uniqueItems: true
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          globalShouldNotBeModified: "Read-only global '{{name}}' should not be modified."
        }
      },
      create(context) {
        const config = context.options[0];
        const sourceCode = context.sourceCode;
        const exceptions = config && config.exceptions || [];
        function checkReference(reference, index, references) {
          const identifier = reference.identifier;
          if (reference.init === false && reference.isWrite() && /*
           * Destructuring assignments can have multiple default value,
           * so possibly there are multiple writeable references for the same identifier.
           */
          (index === 0 || references[index - 1].identifier !== identifier)) {
            context.report({
              node: identifier,
              messageId: "globalShouldNotBeModified",
              data: {
                name: identifier.name
              }
            });
          }
        }
        function checkVariable(variable) {
          if (variable.writeable === false && !exceptions.includes(variable.name)) {
            variable.references.forEach(checkReference);
          }
        }
        return {
          Program(node) {
            const globalScope = sourceCode.getScope(node);
            globalScope.variables.forEach(checkVariable);
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-implicit-coercion.js
var require_no_implicit_coercion = __commonJS({
  "../../node_modules/eslint/lib/rules/no-implicit-coercion.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var INDEX_OF_PATTERN = /^(?:i|lastI)ndexOf$/u;
    var ALLOWABLE_OPERATORS = ["~", "!!", "+", "*"];
    function parseOptions(options) {
      return {
        boolean: "boolean" in options ? options.boolean : true,
        number: "number" in options ? options.number : true,
        string: "string" in options ? options.string : true,
        disallowTemplateShorthand: "disallowTemplateShorthand" in options ? options.disallowTemplateShorthand : false,
        allow: options.allow || []
      };
    }
    function isDoubleLogicalNegating(node) {
      return node.operator === "!" && node.argument.type === "UnaryExpression" && node.argument.operator === "!";
    }
    function isBinaryNegatingOfIndexOf(node) {
      if (node.operator !== "~") {
        return false;
      }
      const callNode = astUtils.skipChainExpression(node.argument);
      return callNode.type === "CallExpression" && astUtils.isSpecificMemberAccess(callNode.callee, null, INDEX_OF_PATTERN);
    }
    function isMultiplyByOne(node) {
      return node.operator === "*" && (node.left.type === "Literal" && node.left.value === 1 || node.right.type === "Literal" && node.right.value === 1);
    }
    function isMultiplyByFractionOfOne(node, sourceCode) {
      return node.type === "BinaryExpression" && node.operator === "*" && (node.right.type === "Literal" && node.right.value === 1) && node.parent.type === "BinaryExpression" && node.parent.operator === "/" && node.parent.left === node && !astUtils.isParenthesised(sourceCode, node);
    }
    function isNumeric(node) {
      return node.type === "Literal" && typeof node.value === "number" || node.type === "CallExpression" && (node.callee.name === "Number" || node.callee.name === "parseInt" || node.callee.name === "parseFloat");
    }
    function getNonNumericOperand(node) {
      const left = node.left, right = node.right;
      if (right.type !== "BinaryExpression" && !isNumeric(right)) {
        return right;
      }
      if (left.type !== "BinaryExpression" && !isNumeric(left)) {
        return left;
      }
      return null;
    }
    function isStringType(node) {
      return astUtils.isStringLiteral(node) || node.type === "CallExpression" && node.callee.type === "Identifier" && node.callee.name === "String";
    }
    function isEmptyString(node) {
      return astUtils.isStringLiteral(node) && (node.value === "" || node.type === "TemplateLiteral" && node.quasis.length === 1 && node.quasis[0].value.cooked === "");
    }
    function isConcatWithEmptyString(node) {
      return node.operator === "+" && (isEmptyString(node.left) && !isStringType(node.right) || isEmptyString(node.right) && !isStringType(node.left));
    }
    function isAppendEmptyString(node) {
      return node.operator === "+=" && isEmptyString(node.right);
    }
    function getNonEmptyOperand(node) {
      return isEmptyString(node.left) ? node.right : node.left;
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow shorthand type conversions",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-implicit-coercion"
        },
        fixable: "code",
        schema: [{
          type: "object",
          properties: {
            boolean: {
              type: "boolean",
              default: true
            },
            number: {
              type: "boolean",
              default: true
            },
            string: {
              type: "boolean",
              default: true
            },
            disallowTemplateShorthand: {
              type: "boolean",
              default: false
            },
            allow: {
              type: "array",
              items: {
                enum: ALLOWABLE_OPERATORS
              },
              uniqueItems: true
            }
          },
          additionalProperties: false
        }],
        messages: {
          useRecommendation: "use `{{recommendation}}` instead."
        }
      },
      create(context) {
        const options = parseOptions(context.options[0] || {});
        const sourceCode = context.sourceCode;
        function report(node, recommendation, shouldFix) {
          context.report({
            node,
            messageId: "useRecommendation",
            data: {
              recommendation
            },
            fix(fixer) {
              if (!shouldFix) {
                return null;
              }
              const tokenBefore = sourceCode.getTokenBefore(node);
              if (tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, recommendation)) {
                return fixer.replaceText(node, ` ${recommendation}`);
              }
              return fixer.replaceText(node, recommendation);
            }
          });
        }
        return {
          UnaryExpression(node) {
            let operatorAllowed;
            operatorAllowed = options.allow.includes("!!");
            if (!operatorAllowed && options.boolean && isDoubleLogicalNegating(node)) {
              const recommendation = `Boolean(${sourceCode.getText(node.argument.argument)})`;
              report(node, recommendation, true);
            }
            operatorAllowed = options.allow.includes("~");
            if (!operatorAllowed && options.boolean && isBinaryNegatingOfIndexOf(node)) {
              const comparison = node.argument.type === "ChainExpression" ? ">= 0" : "!== -1";
              const recommendation = `${sourceCode.getText(node.argument)} ${comparison}`;
              report(node, recommendation, false);
            }
            operatorAllowed = options.allow.includes("+");
            if (!operatorAllowed && options.number && node.operator === "+" && !isNumeric(node.argument)) {
              const recommendation = `Number(${sourceCode.getText(node.argument)})`;
              report(node, recommendation, true);
            }
          },
          // Use `:exit` to prevent double reporting
          "BinaryExpression:exit"(node) {
            let operatorAllowed;
            operatorAllowed = options.allow.includes("*");
            const nonNumericOperand = !operatorAllowed && options.number && isMultiplyByOne(node) && !isMultiplyByFractionOfOne(node, sourceCode) && getNonNumericOperand(node);
            if (nonNumericOperand) {
              const recommendation = `Number(${sourceCode.getText(nonNumericOperand)})`;
              report(node, recommendation, true);
            }
            operatorAllowed = options.allow.includes("+");
            if (!operatorAllowed && options.string && isConcatWithEmptyString(node)) {
              const recommendation = `String(${sourceCode.getText(getNonEmptyOperand(node))})`;
              report(node, recommendation, true);
            }
          },
          AssignmentExpression(node) {
            const operatorAllowed = options.allow.includes("+");
            if (!operatorAllowed && options.string && isAppendEmptyString(node)) {
              const code = sourceCode.getText(getNonEmptyOperand(node));
              const recommendation = `${code} = String(${code})`;
              report(node, recommendation, true);
            }
          },
          TemplateLiteral(node) {
            if (!options.disallowTemplateShorthand) {
              return;
            }
            if (node.parent.type === "TaggedTemplateExpression") {
              return;
            }
            if (node.expressions.length !== 1) {
              return;
            }
            if (node.quasis[0].value.cooked !== "") {
              return;
            }
            if (node.quasis[1].value.cooked !== "") {
              return;
            }
            if (isStringType(node.expressions[0])) {
              return;
            }
            const code = sourceCode.getText(node.expressions[0]);
            const recommendation = `String(${code})`;
            report(node, recommendation, true);
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-implicit-globals.js
var require_no_implicit_globals = __commonJS({
  "../../node_modules/eslint/lib/rules/no-implicit-globals.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow declarations in the global scope",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-implicit-globals"
        },
        schema: [{
          type: "object",
          properties: {
            lexicalBindings: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }],
        messages: {
          globalNonLexicalBinding: "Unexpected {{kind}} declaration in the global scope, wrap in an IIFE for a local variable, assign as global property for a global variable.",
          globalLexicalBinding: "Unexpected {{kind}} declaration in the global scope, wrap in a block or in an IIFE.",
          globalVariableLeak: "Global variable leak, declare the variable if it is intended to be local.",
          assignmentToReadonlyGlobal: "Unexpected assignment to read-only global variable.",
          redeclarationOfReadonlyGlobal: "Unexpected redeclaration of read-only global variable."
        }
      },
      create(context) {
        const checkLexicalBindings = context.options[0] && context.options[0].lexicalBindings === true;
        const sourceCode = context.sourceCode;
        function report(node, messageId, kind) {
          context.report({
            node,
            messageId,
            data: {
              kind
            }
          });
        }
        return {
          Program(node) {
            const scope = sourceCode.getScope(node);
            scope.variables.forEach((variable) => {
              const isReadonlyEslintGlobalVariable = variable.writeable === false;
              const isWritableEslintGlobalVariable = variable.writeable === true;
              if (isWritableEslintGlobalVariable) {
                return;
              }
              if (variable.eslintExported) {
                return;
              }
              variable.defs.forEach((def) => {
                const defNode = def.node;
                if (def.type === "FunctionName" || def.type === "Variable" && def.parent.kind === "var") {
                  if (isReadonlyEslintGlobalVariable) {
                    report(defNode, "redeclarationOfReadonlyGlobal");
                  } else {
                    report(
                      defNode,
                      "globalNonLexicalBinding",
                      def.type === "FunctionName" ? "function" : `'${def.parent.kind}'`
                    );
                  }
                }
                if (checkLexicalBindings) {
                  if (def.type === "ClassName" || def.type === "Variable" && (def.parent.kind === "let" || def.parent.kind === "const")) {
                    if (isReadonlyEslintGlobalVariable) {
                      report(defNode, "redeclarationOfReadonlyGlobal");
                    } else {
                      report(
                        defNode,
                        "globalLexicalBinding",
                        def.type === "ClassName" ? "class" : `'${def.parent.kind}'`
                      );
                    }
                  }
                }
              });
            });
            scope.implicit.variables.forEach((variable) => {
              const scopeVariable = scope.set.get(variable.name);
              let messageId;
              if (scopeVariable) {
                if (scopeVariable.writeable) {
                  return;
                }
                messageId = "assignmentToReadonlyGlobal";
              } else {
                messageId = "globalVariableLeak";
              }
              variable.defs.forEach((def) => {
                report(def.node, messageId);
              });
            });
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-implied-eval.js
var require_no_implied_eval = __commonJS({
  "../../node_modules/eslint/lib/rules/no-implied-eval.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var { getStaticValue } = require_eslint_utils();
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow the use of `eval()`-like methods",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-implied-eval"
        },
        schema: [],
        messages: {
          impliedEval: "Implied eval. Consider passing a function instead of a string."
        }
      },
      create(context) {
        const GLOBAL_CANDIDATES = Object.freeze(["global", "window", "globalThis"]);
        const EVAL_LIKE_FUNC_PATTERN = /^(?:set(?:Interval|Timeout)|execScript)$/u;
        const sourceCode = context.sourceCode;
        function isEvaluatedString(node) {
          if (node.type === "Literal" && typeof node.value === "string" || node.type === "TemplateLiteral") {
            return true;
          }
          if (node.type === "BinaryExpression" && node.operator === "+") {
            return isEvaluatedString(node.left) || isEvaluatedString(node.right);
          }
          return false;
        }
        function reportImpliedEvalCallExpression(node) {
          const [firstArgument] = node.arguments;
          if (firstArgument) {
            const staticValue = getStaticValue(firstArgument, sourceCode.getScope(node));
            const isStaticString = staticValue && typeof staticValue.value === "string";
            const isString = isStaticString || isEvaluatedString(firstArgument);
            if (isString) {
              context.report({
                node,
                messageId: "impliedEval"
              });
            }
          }
        }
        function reportImpliedEvalViaGlobal(globalVar) {
          const { references, name } = globalVar;
          references.forEach((ref) => {
            const identifier = ref.identifier;
            let node = identifier.parent;
            while (astUtils.isSpecificMemberAccess(node, null, name)) {
              node = node.parent;
            }
            if (astUtils.isSpecificMemberAccess(node, null, EVAL_LIKE_FUNC_PATTERN)) {
              const calleeNode = node.parent.type === "ChainExpression" ? node.parent : node;
              const parent = calleeNode.parent;
              if (parent.type === "CallExpression" && parent.callee === calleeNode) {
                reportImpliedEvalCallExpression(parent);
              }
            }
          });
        }
        return {
          CallExpression(node) {
            if (astUtils.isSpecificId(node.callee, EVAL_LIKE_FUNC_PATTERN)) {
              reportImpliedEvalCallExpression(node);
            }
          },
          "Program:exit"(node) {
            const globalScope = sourceCode.getScope(node);
            GLOBAL_CANDIDATES.map((candidate) => astUtils.getVariableByName(globalScope, candidate)).filter((globalVar) => !!globalVar && globalVar.defs.length === 0).forEach(reportImpliedEvalViaGlobal);
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-import-assign.js
var require_no_import_assign = __commonJS({
  "../../node_modules/eslint/lib/rules/no-import-assign.js"(exports, module) {
    "use strict";
    var { findVariable } = require_eslint_utils();
    var astUtils = require_ast_utils2();
    var WellKnownMutationFunctions = {
      Object: /^(?:assign|definePropert(?:y|ies)|freeze|setPrototypeOf)$/u,
      Reflect: /^(?:(?:define|delete)Property|set(?:PrototypeOf)?)$/u
    };
    function isAssignmentLeft(node) {
      const { parent } = node;
      return parent.type === "AssignmentExpression" && parent.left === node || // Destructuring assignments
      parent.type === "ArrayPattern" || parent.type === "Property" && parent.value === node && parent.parent.type === "ObjectPattern" || parent.type === "RestElement" || parent.type === "AssignmentPattern" && parent.left === node;
    }
    function isOperandOfMutationUnaryOperator(node) {
      const argumentNode = node.parent.type === "ChainExpression" ? node.parent : node;
      const { parent } = argumentNode;
      return parent.type === "UpdateExpression" && parent.argument === argumentNode || parent.type === "UnaryExpression" && parent.operator === "delete" && parent.argument === argumentNode;
    }
    function isIterationVariable(node) {
      const { parent } = node;
      return parent.type === "ForInStatement" && parent.left === node || parent.type === "ForOfStatement" && parent.left === node;
    }
    function isArgumentOfWellKnownMutationFunction(node, scope) {
      const { parent } = node;
      if (parent.type !== "CallExpression" || parent.arguments[0] !== node) {
        return false;
      }
      const callee = astUtils.skipChainExpression(parent.callee);
      if (!astUtils.isSpecificMemberAccess(callee, "Object", WellKnownMutationFunctions.Object) && !astUtils.isSpecificMemberAccess(callee, "Reflect", WellKnownMutationFunctions.Reflect)) {
        return false;
      }
      const variable = findVariable(scope, callee.object);
      return variable !== null && variable.scope.type === "global";
    }
    function isMemberWrite(id, scope) {
      const { parent } = id;
      return parent.type === "MemberExpression" && parent.object === id && (isAssignmentLeft(parent) || isOperandOfMutationUnaryOperator(parent) || isIterationVariable(parent)) || isArgumentOfWellKnownMutationFunction(id, scope);
    }
    function getWriteNode(id) {
      let node = id.parent;
      while (node && node.type !== "AssignmentExpression" && node.type !== "UpdateExpression" && node.type !== "UnaryExpression" && node.type !== "CallExpression" && node.type !== "ForInStatement" && node.type !== "ForOfStatement") {
        node = node.parent;
      }
      return node || id;
    }
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow assigning to imported bindings",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-import-assign"
        },
        schema: [],
        messages: {
          readonly: "'{{name}}' is read-only.",
          readonlyMember: "The members of '{{name}}' are read-only."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        return {
          ImportDeclaration(node) {
            const scope = sourceCode.getScope(node);
            for (const variable of sourceCode.getDeclaredVariables(node)) {
              const shouldCheckMembers = variable.defs.some(
                (d) => d.node.type === "ImportNamespaceSpecifier"
              );
              let prevIdNode = null;
              for (const reference of variable.references) {
                const idNode = reference.identifier;
                if (idNode === prevIdNode) {
                  continue;
                }
                prevIdNode = idNode;
                if (reference.isWrite()) {
                  context.report({
                    node: getWriteNode(idNode),
                    messageId: "readonly",
                    data: { name: idNode.name }
                  });
                } else if (shouldCheckMembers && isMemberWrite(idNode, scope)) {
                  context.report({
                    node: getWriteNode(idNode),
                    messageId: "readonlyMember",
                    data: { name: idNode.name }
                  });
                }
              }
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-inline-comments.js
var require_no_inline_comments = __commonJS({
  "../../node_modules/eslint/lib/rules/no-inline-comments.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow inline comments after code",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-inline-comments"
        },
        schema: [
          {
            type: "object",
            properties: {
              ignorePattern: {
                type: "string"
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          unexpectedInlineComment: "Unexpected comment inline with code."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        const options = context.options[0];
        let customIgnoreRegExp;
        if (options && options.ignorePattern) {
          customIgnoreRegExp = new RegExp(options.ignorePattern, "u");
        }
        function testCodeAroundComment(node) {
          const startLine = String(sourceCode.lines[node.loc.start.line - 1]), endLine = String(sourceCode.lines[node.loc.end.line - 1]), preamble = startLine.slice(0, node.loc.start.column).trim(), postamble = endLine.slice(node.loc.end.column).trim(), isPreambleEmpty = !preamble, isPostambleEmpty = !postamble;
          if (isPreambleEmpty && isPostambleEmpty) {
            return;
          }
          if (customIgnoreRegExp && customIgnoreRegExp.test(node.value)) {
            return;
          }
          if ((isPreambleEmpty || preamble === "{") && (isPostambleEmpty || postamble === "}")) {
            const enclosingNode = sourceCode.getNodeByRangeIndex(node.range[0]);
            if (enclosingNode && enclosingNode.type === "JSXEmptyExpression") {
              return;
            }
          }
          if (astUtils.isDirectiveComment(node)) {
            return;
          }
          context.report({
            node,
            messageId: "unexpectedInlineComment"
          });
        }
        return {
          Program() {
            sourceCode.getAllComments().filter((token) => token.type !== "Shebang").forEach(testCodeAroundComment);
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-inner-declarations.js
var require_no_inner_declarations = __commonJS({
  "../../node_modules/eslint/lib/rules/no-inner-declarations.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var validParent = /* @__PURE__ */ new Set(["Program", "StaticBlock", "ExportNamedDeclaration", "ExportDefaultDeclaration"]);
    var validBlockStatementParent = /* @__PURE__ */ new Set(["FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"]);
    function getAllowedBodyDescription(node) {
      let { parent } = node;
      while (parent) {
        if (parent.type === "StaticBlock") {
          return "class static block body";
        }
        if (astUtils.isFunction(parent)) {
          return "function body";
        }
        ({ parent } = parent);
      }
      return "program";
    }
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow variable or `function` declarations in nested blocks",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-inner-declarations"
        },
        schema: [
          {
            enum: ["functions", "both"]
          }
        ],
        messages: {
          moveDeclToRoot: "Move {{type}} declaration to {{body}} root."
        }
      },
      create(context) {
        function check(node) {
          const parent = node.parent;
          if (parent.type === "BlockStatement" && validBlockStatementParent.has(parent.parent.type)) {
            return;
          }
          if (validParent.has(parent.type)) {
            return;
          }
          context.report({
            node,
            messageId: "moveDeclToRoot",
            data: {
              type: node.type === "FunctionDeclaration" ? "function" : "variable",
              body: getAllowedBodyDescription(node)
            }
          });
        }
        return {
          FunctionDeclaration: check,
          VariableDeclaration(node) {
            if (context.options[0] === "both" && node.kind === "var") {
              check(node);
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-invalid-regexp.js
var require_no_invalid_regexp = __commonJS({
  "../../node_modules/eslint/lib/rules/no-invalid-regexp.js"(exports, module) {
    "use strict";
    var RegExpValidator = require_regexpp().RegExpValidator;
    var validator = new RegExpValidator();
    var validFlags = /[dgimsuy]/gu;
    var undefined1 = void 0;
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow invalid regular expression strings in `RegExp` constructors",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-invalid-regexp"
        },
        schema: [{
          type: "object",
          properties: {
            allowConstructorFlags: {
              type: "array",
              items: {
                type: "string"
              }
            }
          },
          additionalProperties: false
        }],
        messages: {
          regexMessage: "{{message}}."
        }
      },
      create(context) {
        const options = context.options[0];
        let allowedFlags = null;
        if (options && options.allowConstructorFlags) {
          const temp = options.allowConstructorFlags.join("").replace(validFlags, "");
          if (temp) {
            allowedFlags = new RegExp(`[${temp}]`, "giu");
          }
        }
        function report(node, message) {
          context.report({
            node,
            messageId: "regexMessage",
            data: { message }
          });
        }
        function isString(node) {
          return node && node.type === "Literal" && typeof node.value === "string";
        }
        function getFlags(node) {
          if (node.arguments.length < 2) {
            return "";
          }
          if (isString(node.arguments[1])) {
            return node.arguments[1].value;
          }
          return null;
        }
        function validateRegExpPattern(pattern, uFlag) {
          try {
            validator.validatePattern(pattern, undefined1, undefined1, uFlag);
            return null;
          } catch (err) {
            return err.message;
          }
        }
        function validateRegExpFlags(flags) {
          if (!flags) {
            return null;
          }
          try {
            validator.validateFlags(flags);
            return null;
          } catch {
            return `Invalid flags supplied to RegExp constructor '${flags}'`;
          }
        }
        return {
          "CallExpression, NewExpression"(node) {
            if (node.callee.type !== "Identifier" || node.callee.name !== "RegExp") {
              return;
            }
            let flags = getFlags(node);
            if (flags && allowedFlags) {
              flags = flags.replace(allowedFlags, "");
            }
            let message = validateRegExpFlags(flags);
            if (message) {
              report(node, message);
              return;
            }
            if (!isString(node.arguments[0])) {
              return;
            }
            const pattern = node.arguments[0].value;
            message = // If flags are unknown, report the regex only if its pattern is invalid both with and without the "u" flag
            flags === null ? validateRegExpPattern(pattern, true) && validateRegExpPattern(pattern, false) : validateRegExpPattern(pattern, flags.includes("u"));
            if (message) {
              report(node, message);
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-invalid-this.js
var require_no_invalid_this = __commonJS({
  "../../node_modules/eslint/lib/rules/no-invalid-this.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    function isCodePathWithLexicalThis(codePath, node) {
      return codePath.origin === "function" && node.type === "ArrowFunctionExpression";
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow use of `this` in contexts where the value of `this` is `undefined`",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-invalid-this"
        },
        schema: [
          {
            type: "object",
            properties: {
              capIsConstructor: {
                type: "boolean",
                default: true
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          unexpectedThis: "Unexpected 'this'."
        }
      },
      create(context) {
        const options = context.options[0] || {};
        const capIsConstructor = options.capIsConstructor !== false;
        const stack = [], sourceCode = context.sourceCode;
        stack.getCurrent = function() {
          const current = this[this.length - 1];
          if (!current.init) {
            current.init = true;
            current.valid = !astUtils.isDefaultThisBinding(
              current.node,
              sourceCode,
              { capIsConstructor }
            );
          }
          return current;
        };
        return {
          onCodePathStart(codePath, node) {
            if (isCodePathWithLexicalThis(codePath, node)) {
              return;
            }
            if (codePath.origin === "program") {
              const scope = sourceCode.getScope(node);
              const features = context.parserOptions.ecmaFeatures || {};
              stack.push({
                init: true,
                node,
                valid: !(node.sourceType === "module" || features.globalReturn && scope.childScopes[0].isStrict)
              });
              return;
            }
            stack.push({
              init: !sourceCode.getScope(node).isStrict,
              node,
              valid: true
            });
          },
          onCodePathEnd(codePath, node) {
            if (isCodePathWithLexicalThis(codePath, node)) {
              return;
            }
            stack.pop();
          },
          // Reports if `this` of the current context is invalid.
          ThisExpression(node) {
            const current = stack.getCurrent();
            if (current && !current.valid) {
              context.report({
                node,
                messageId: "unexpectedThis"
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-irregular-whitespace.js
var require_no_irregular_whitespace = __commonJS({
  "../../node_modules/eslint/lib/rules/no-irregular-whitespace.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var ALL_IRREGULARS = /[\f\v\u0085\ufeff\u00a0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u202f\u205f\u3000\u2028\u2029]/u;
    var IRREGULAR_WHITESPACE = /[\f\v\u0085\ufeff\u00a0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u202f\u205f\u3000]+/mgu;
    var IRREGULAR_LINE_TERMINATORS = /[\u2028\u2029]/mgu;
    var LINE_BREAK = astUtils.createGlobalLinebreakMatcher();
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow irregular whitespace",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-irregular-whitespace"
        },
        schema: [
          {
            type: "object",
            properties: {
              skipComments: {
                type: "boolean",
                default: false
              },
              skipStrings: {
                type: "boolean",
                default: true
              },
              skipTemplates: {
                type: "boolean",
                default: false
              },
              skipRegExps: {
                type: "boolean",
                default: false
              },
              skipJSXText: {
                type: "boolean",
                default: false
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          noIrregularWhitespace: "Irregular whitespace not allowed."
        }
      },
      create(context) {
        let errors = [];
        const options = context.options[0] || {};
        const skipComments = !!options.skipComments;
        const skipStrings = options.skipStrings !== false;
        const skipRegExps = !!options.skipRegExps;
        const skipTemplates = !!options.skipTemplates;
        const skipJSXText = !!options.skipJSXText;
        const sourceCode = context.sourceCode;
        const commentNodes = sourceCode.getAllComments();
        function removeWhitespaceError(node) {
          const locStart = node.loc.start;
          const locEnd = node.loc.end;
          errors = errors.filter(({ loc: { start: errorLocStart } }) => errorLocStart.line < locStart.line || errorLocStart.line === locStart.line && errorLocStart.column < locStart.column || errorLocStart.line === locEnd.line && errorLocStart.column >= locEnd.column || errorLocStart.line > locEnd.line);
        }
        function removeInvalidNodeErrorsInLiteral(node) {
          const shouldCheckStrings = skipStrings && typeof node.value === "string";
          const shouldCheckRegExps = skipRegExps && Boolean(node.regex);
          if (shouldCheckStrings || shouldCheckRegExps) {
            if (ALL_IRREGULARS.test(node.raw)) {
              removeWhitespaceError(node);
            }
          }
        }
        function removeInvalidNodeErrorsInTemplateLiteral(node) {
          if (typeof node.value.raw === "string") {
            if (ALL_IRREGULARS.test(node.value.raw)) {
              removeWhitespaceError(node);
            }
          }
        }
        function removeInvalidNodeErrorsInComment(node) {
          if (ALL_IRREGULARS.test(node.value)) {
            removeWhitespaceError(node);
          }
        }
        function removeInvalidNodeErrorsInJSXText(node) {
          if (ALL_IRREGULARS.test(node.raw)) {
            removeWhitespaceError(node);
          }
        }
        function checkForIrregularWhitespace(node) {
          const sourceLines = sourceCode.lines;
          sourceLines.forEach((sourceLine, lineIndex) => {
            const lineNumber = lineIndex + 1;
            let match;
            while ((match = IRREGULAR_WHITESPACE.exec(sourceLine)) !== null) {
              errors.push({
                node,
                messageId: "noIrregularWhitespace",
                loc: {
                  start: {
                    line: lineNumber,
                    column: match.index
                  },
                  end: {
                    line: lineNumber,
                    column: match.index + match[0].length
                  }
                }
              });
            }
          });
        }
        function checkForIrregularLineTerminators(node) {
          const source = sourceCode.getText(), sourceLines = sourceCode.lines, linebreaks = source.match(LINE_BREAK);
          let lastLineIndex = -1, match;
          while ((match = IRREGULAR_LINE_TERMINATORS.exec(source)) !== null) {
            const lineIndex = linebreaks.indexOf(match[0], lastLineIndex + 1) || 0;
            errors.push({
              node,
              messageId: "noIrregularWhitespace",
              loc: {
                start: {
                  line: lineIndex + 1,
                  column: sourceLines[lineIndex].length
                },
                end: {
                  line: lineIndex + 2,
                  column: 0
                }
              }
            });
            lastLineIndex = lineIndex;
          }
        }
        function noop() {
        }
        const nodes = {};
        if (ALL_IRREGULARS.test(sourceCode.getText())) {
          nodes.Program = function(node) {
            checkForIrregularWhitespace(node);
            checkForIrregularLineTerminators(node);
          };
          nodes.Literal = removeInvalidNodeErrorsInLiteral;
          nodes.TemplateElement = skipTemplates ? removeInvalidNodeErrorsInTemplateLiteral : noop;
          nodes.JSXText = skipJSXText ? removeInvalidNodeErrorsInJSXText : noop;
          nodes["Program:exit"] = function() {
            if (skipComments) {
              commentNodes.forEach(removeInvalidNodeErrorsInComment);
            }
            errors.forEach((error) => context.report(error));
          };
        } else {
          nodes.Program = noop;
        }
        return nodes;
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-iterator.js
var require_no_iterator = __commonJS({
  "../../node_modules/eslint/lib/rules/no-iterator.js"(exports, module) {
    "use strict";
    var { getStaticPropertyName } = require_ast_utils2();
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow the use of the `__iterator__` property",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-iterator"
        },
        schema: [],
        messages: {
          noIterator: "Reserved name '__iterator__'."
        }
      },
      create(context) {
        return {
          MemberExpression(node) {
            if (getStaticPropertyName(node) === "__iterator__") {
              context.report({
                node,
                messageId: "noIterator"
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-label-var.js
var require_no_label_var = __commonJS({
  "../../node_modules/eslint/lib/rules/no-label-var.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow labels that share a name with a variable",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-label-var"
        },
        schema: [],
        messages: {
          identifierClashWithLabel: "Found identifier with same name as label."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        function findIdentifier(scope, name) {
          return astUtils.getVariableByName(scope, name) !== null;
        }
        return {
          LabeledStatement(node) {
            const scope = sourceCode.getScope(node);
            if (findIdentifier(scope, node.label.name)) {
              context.report({
                node,
                messageId: "identifierClashWithLabel"
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-labels.js
var require_no_labels = __commonJS({
  "../../node_modules/eslint/lib/rules/no-labels.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow labeled statements",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-labels"
        },
        schema: [
          {
            type: "object",
            properties: {
              allowLoop: {
                type: "boolean",
                default: false
              },
              allowSwitch: {
                type: "boolean",
                default: false
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          unexpectedLabel: "Unexpected labeled statement.",
          unexpectedLabelInBreak: "Unexpected label in break statement.",
          unexpectedLabelInContinue: "Unexpected label in continue statement."
        }
      },
      create(context) {
        const options = context.options[0];
        const allowLoop = options && options.allowLoop;
        const allowSwitch = options && options.allowSwitch;
        let scopeInfo = null;
        function getBodyKind(node) {
          if (astUtils.isLoop(node)) {
            return "loop";
          }
          if (node.type === "SwitchStatement") {
            return "switch";
          }
          return "other";
        }
        function isAllowed(kind) {
          switch (kind) {
            case "loop":
              return allowLoop;
            case "switch":
              return allowSwitch;
            default:
              return false;
          }
        }
        function getKind(label) {
          let info = scopeInfo;
          while (info) {
            if (info.label === label) {
              return info.kind;
            }
            info = info.upper;
          }
          return "other";
        }
        return {
          LabeledStatement(node) {
            scopeInfo = {
              label: node.label.name,
              kind: getBodyKind(node.body),
              upper: scopeInfo
            };
          },
          "LabeledStatement:exit"(node) {
            if (!isAllowed(scopeInfo.kind)) {
              context.report({
                node,
                messageId: "unexpectedLabel"
              });
            }
            scopeInfo = scopeInfo.upper;
          },
          BreakStatement(node) {
            if (node.label && !isAllowed(getKind(node.label.name))) {
              context.report({
                node,
                messageId: "unexpectedLabelInBreak"
              });
            }
          },
          ContinueStatement(node) {
            if (node.label && !isAllowed(getKind(node.label.name))) {
              context.report({
                node,
                messageId: "unexpectedLabelInContinue"
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-lone-blocks.js
var require_no_lone_blocks = __commonJS({
  "../../node_modules/eslint/lib/rules/no-lone-blocks.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow unnecessary nested blocks",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-lone-blocks"
        },
        schema: [],
        messages: {
          redundantBlock: "Block is redundant.",
          redundantNestedBlock: "Nested block is redundant."
        }
      },
      create(context) {
        const loneBlocks = [];
        let ruleDef;
        const sourceCode = context.sourceCode;
        function report(node) {
          const messageId = node.parent.type === "BlockStatement" || node.parent.type === "StaticBlock" ? "redundantNestedBlock" : "redundantBlock";
          context.report({
            node,
            messageId
          });
        }
        function isLoneBlock(node) {
          return node.parent.type === "BlockStatement" || node.parent.type === "StaticBlock" || node.parent.type === "Program" || // Don't report blocks in switch cases if the block is the only statement of the case.
          node.parent.type === "SwitchCase" && !(node.parent.consequent[0] === node && node.parent.consequent.length === 1);
        }
        function markLoneBlock(node) {
          if (loneBlocks.length === 0) {
            return;
          }
          const block = node.parent;
          if (loneBlocks[loneBlocks.length - 1] === block) {
            loneBlocks.pop();
          }
        }
        ruleDef = {
          BlockStatement(node) {
            if (isLoneBlock(node)) {
              report(node);
            }
          }
        };
        if (context.languageOptions.ecmaVersion >= 2015) {
          ruleDef = {
            BlockStatement(node) {
              if (isLoneBlock(node)) {
                loneBlocks.push(node);
              }
            },
            "BlockStatement:exit"(node) {
              if (loneBlocks.length > 0 && loneBlocks[loneBlocks.length - 1] === node) {
                loneBlocks.pop();
                report(node);
              } else if ((node.parent.type === "BlockStatement" || node.parent.type === "StaticBlock") && node.parent.body.length === 1) {
                report(node);
              }
            }
          };
          ruleDef.VariableDeclaration = function(node) {
            if (node.kind === "let" || node.kind === "const") {
              markLoneBlock(node);
            }
          };
          ruleDef.FunctionDeclaration = function(node) {
            if (sourceCode.getScope(node).isStrict) {
              markLoneBlock(node);
            }
          };
          ruleDef.ClassDeclaration = markLoneBlock;
        }
        return ruleDef;
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-lonely-if.js
var require_no_lonely_if = __commonJS({
  "../../node_modules/eslint/lib/rules/no-lonely-if.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow `if` statements as the only statement in `else` blocks",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-lonely-if"
        },
        schema: [],
        fixable: "code",
        messages: {
          unexpectedLonelyIf: "Unexpected if as the only statement in an else block."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        return {
          IfStatement(node) {
            const parent = node.parent, grandparent = parent.parent;
            if (parent && parent.type === "BlockStatement" && parent.body.length === 1 && grandparent && grandparent.type === "IfStatement" && parent === grandparent.alternate) {
              context.report({
                node,
                messageId: "unexpectedLonelyIf",
                fix(fixer) {
                  const openingElseCurly = sourceCode.getFirstToken(parent);
                  const closingElseCurly = sourceCode.getLastToken(parent);
                  const elseKeyword = sourceCode.getTokenBefore(openingElseCurly);
                  const tokenAfterElseBlock = sourceCode.getTokenAfter(closingElseCurly);
                  const lastIfToken = sourceCode.getLastToken(node.consequent);
                  const sourceText = sourceCode.getText();
                  if (sourceText.slice(
                    openingElseCurly.range[1],
                    node.range[0]
                  ).trim() || sourceText.slice(node.range[1], closingElseCurly.range[0]).trim()) {
                    return null;
                  }
                  if (node.consequent.type !== "BlockStatement" && lastIfToken.value !== ";" && tokenAfterElseBlock && (node.consequent.loc.end.line === tokenAfterElseBlock.loc.start.line || /^[([/+`-]/u.test(tokenAfterElseBlock.value) || lastIfToken.value === "++" || lastIfToken.value === "--")) {
                    return null;
                  }
                  return fixer.replaceTextRange(
                    [openingElseCurly.range[0], closingElseCurly.range[1]],
                    (elseKeyword.range[1] === openingElseCurly.range[0] ? " " : "") + sourceCode.getText(node)
                  );
                }
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-loop-func.js
var require_no_loop_func = __commonJS({
  "../../node_modules/eslint/lib/rules/no-loop-func.js"(exports, module) {
    "use strict";
    function getContainingLoopNode(node) {
      for (let currentNode = node; currentNode.parent; currentNode = currentNode.parent) {
        const parent = currentNode.parent;
        switch (parent.type) {
          case "WhileStatement":
          case "DoWhileStatement":
            return parent;
          case "ForStatement":
            if (parent.init !== currentNode) {
              return parent;
            }
            break;
          case "ForInStatement":
          case "ForOfStatement":
            if (parent.right !== currentNode) {
              return parent;
            }
            break;
          case "ArrowFunctionExpression":
          case "FunctionExpression":
          case "FunctionDeclaration":
            return null;
          default:
            break;
        }
      }
      return null;
    }
    function getTopLoopNode(node, excludedNode) {
      const border = excludedNode ? excludedNode.range[1] : 0;
      let retv = node;
      let containingLoopNode = node;
      while (containingLoopNode && containingLoopNode.range[0] >= border) {
        retv = containingLoopNode;
        containingLoopNode = getContainingLoopNode(containingLoopNode);
      }
      return retv;
    }
    function isSafe(loopNode, reference) {
      const variable = reference.resolved;
      const definition = variable && variable.defs[0];
      const declaration = definition && definition.parent;
      const kind = declaration && declaration.type === "VariableDeclaration" ? declaration.kind : "";
      if (kind === "const") {
        return true;
      }
      if (kind === "let" && declaration.range[0] > loopNode.range[0] && declaration.range[1] < loopNode.range[1]) {
        return true;
      }
      const border = getTopLoopNode(
        loopNode,
        kind === "let" ? declaration : null
      ).range[0];
      function isSafeReference(upperRef) {
        const id = upperRef.identifier;
        return !upperRef.isWrite() || variable.scope.variableScope === upperRef.from.variableScope && id.range[0] < border;
      }
      return Boolean(variable) && variable.references.every(isSafeReference);
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow function declarations that contain unsafe references inside loop statements",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-loop-func"
        },
        schema: [],
        messages: {
          unsafeRefs: "Function declared in a loop contains unsafe references to variable(s) {{ varNames }}."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        function checkForLoops(node) {
          const loopNode = getContainingLoopNode(node);
          if (!loopNode) {
            return;
          }
          const references = sourceCode.getScope(node).through;
          const unsafeRefs = references.filter((r) => !isSafe(loopNode, r)).map((r) => r.identifier.name);
          if (unsafeRefs.length > 0) {
            context.report({
              node,
              messageId: "unsafeRefs",
              data: { varNames: `'${unsafeRefs.join("', '")}'` }
            });
          }
        }
        return {
          ArrowFunctionExpression: checkForLoops,
          FunctionExpression: checkForLoops,
          FunctionDeclaration: checkForLoops
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-loss-of-precision.js
var require_no_loss_of_precision = __commonJS({
  "../../node_modules/eslint/lib/rules/no-loss-of-precision.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow literal numbers that lose precision",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-loss-of-precision"
        },
        schema: [],
        messages: {
          noLossOfPrecision: "This number literal will lose precision at runtime."
        }
      },
      create(context) {
        function isNumber(node) {
          return typeof node.value === "number";
        }
        function getRaw(node) {
          return node.raw.replace(/_/gu, "");
        }
        function isBaseTen(node) {
          const prefixes = ["0x", "0X", "0b", "0B", "0o", "0O"];
          return prefixes.every((prefix) => !node.raw.startsWith(prefix)) && !/^0[0-7]+$/u.test(node.raw);
        }
        function notBaseTenLosesPrecision(node) {
          const rawString = getRaw(node).toUpperCase();
          let base = 0;
          if (rawString.startsWith("0B")) {
            base = 2;
          } else if (rawString.startsWith("0X")) {
            base = 16;
          } else {
            base = 8;
          }
          return !rawString.endsWith(node.value.toString(base).toUpperCase());
        }
        function addDecimalPointToNumber(stringNumber) {
          return `${stringNumber[0]}.${stringNumber.slice(1)}`;
        }
        function removeLeadingZeros(numberAsString) {
          for (let i = 0; i < numberAsString.length; i++) {
            if (numberAsString[i] !== "0") {
              return numberAsString.slice(i);
            }
          }
          return numberAsString;
        }
        function removeTrailingZeros(numberAsString) {
          for (let i = numberAsString.length - 1; i >= 0; i--) {
            if (numberAsString[i] !== "0") {
              return numberAsString.slice(0, i + 1);
            }
          }
          return numberAsString;
        }
        function normalizeInteger(stringInteger) {
          const significantDigits = removeTrailingZeros(removeLeadingZeros(stringInteger));
          return {
            magnitude: stringInteger.startsWith("0") ? stringInteger.length - 2 : stringInteger.length - 1,
            coefficient: addDecimalPointToNumber(significantDigits)
          };
        }
        function normalizeFloat(stringFloat) {
          const trimmedFloat = removeLeadingZeros(stringFloat);
          if (trimmedFloat.startsWith(".")) {
            const decimalDigits = trimmedFloat.slice(1);
            const significantDigits = removeLeadingZeros(decimalDigits);
            return {
              magnitude: significantDigits.length - decimalDigits.length - 1,
              coefficient: addDecimalPointToNumber(significantDigits)
            };
          }
          return {
            magnitude: trimmedFloat.indexOf(".") - 1,
            coefficient: addDecimalPointToNumber(trimmedFloat.replace(".", ""))
          };
        }
        function convertNumberToScientificNotation(stringNumber) {
          const splitNumber = stringNumber.replace("E", "e").split("e");
          const originalCoefficient = splitNumber[0];
          const normalizedNumber = stringNumber.includes(".") ? normalizeFloat(originalCoefficient) : normalizeInteger(originalCoefficient);
          const normalizedCoefficient = normalizedNumber.coefficient;
          const magnitude = splitNumber.length > 1 ? parseInt(splitNumber[1], 10) + normalizedNumber.magnitude : normalizedNumber.magnitude;
          return `${normalizedCoefficient}e${magnitude}`;
        }
        function baseTenLosesPrecision(node) {
          const normalizedRawNumber = convertNumberToScientificNotation(getRaw(node));
          const requestedPrecision = normalizedRawNumber.split("e")[0].replace(".", "").length;
          if (requestedPrecision > 100) {
            return true;
          }
          const storedNumber = node.value.toPrecision(requestedPrecision);
          const normalizedStoredNumber = convertNumberToScientificNotation(storedNumber);
          return normalizedRawNumber !== normalizedStoredNumber;
        }
        function losesPrecision(node) {
          return isBaseTen(node) ? baseTenLosesPrecision(node) : notBaseTenLosesPrecision(node);
        }
        return {
          Literal(node) {
            if (node.value && isNumber(node) && losesPrecision(node)) {
              context.report({
                messageId: "noLossOfPrecision",
                node
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-magic-numbers.js
var require_no_magic_numbers = __commonJS({
  "../../node_modules/eslint/lib/rules/no-magic-numbers.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var MAX_ARRAY_LENGTH = 2 ** 32 - 1;
    function normalizeIgnoreValue(x) {
      if (typeof x === "string") {
        return BigInt(x.slice(0, -1));
      }
      return x;
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow magic numbers",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-magic-numbers"
        },
        schema: [{
          type: "object",
          properties: {
            detectObjects: {
              type: "boolean",
              default: false
            },
            enforceConst: {
              type: "boolean",
              default: false
            },
            ignore: {
              type: "array",
              items: {
                anyOf: [
                  { type: "number" },
                  { type: "string", pattern: "^[+-]?(?:0|[1-9][0-9]*)n$" }
                ]
              },
              uniqueItems: true
            },
            ignoreArrayIndexes: {
              type: "boolean",
              default: false
            },
            ignoreDefaultValues: {
              type: "boolean",
              default: false
            },
            ignoreClassFieldInitialValues: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }],
        messages: {
          useConst: "Number constants declarations must use 'const'.",
          noMagic: "No magic number: {{raw}}."
        }
      },
      create(context) {
        const config = context.options[0] || {}, detectObjects = !!config.detectObjects, enforceConst = !!config.enforceConst, ignore = new Set((config.ignore || []).map(normalizeIgnoreValue)), ignoreArrayIndexes = !!config.ignoreArrayIndexes, ignoreDefaultValues = !!config.ignoreDefaultValues, ignoreClassFieldInitialValues = !!config.ignoreClassFieldInitialValues;
        const okTypes = detectObjects ? [] : ["ObjectExpression", "Property", "AssignmentExpression"];
        function isIgnoredValue(value) {
          return ignore.has(value);
        }
        function isDefaultValue(fullNumberNode) {
          const parent = fullNumberNode.parent;
          return parent.type === "AssignmentPattern" && parent.right === fullNumberNode;
        }
        function isClassFieldInitialValue(fullNumberNode) {
          const parent = fullNumberNode.parent;
          return parent.type === "PropertyDefinition" && parent.value === fullNumberNode;
        }
        function isParseIntRadix(fullNumberNode) {
          const parent = fullNumberNode.parent;
          return parent.type === "CallExpression" && fullNumberNode === parent.arguments[1] && (astUtils.isSpecificId(parent.callee, "parseInt") || astUtils.isSpecificMemberAccess(parent.callee, "Number", "parseInt"));
        }
        function isJSXNumber(fullNumberNode) {
          return fullNumberNode.parent.type.indexOf("JSX") === 0;
        }
        function isArrayIndex(fullNumberNode, value) {
          const parent = fullNumberNode.parent;
          return parent.type === "MemberExpression" && parent.property === fullNumberNode && (Number.isInteger(value) || typeof value === "bigint") && value >= 0 && value < MAX_ARRAY_LENGTH;
        }
        return {
          Literal(node) {
            if (!astUtils.isNumericLiteral(node)) {
              return;
            }
            let fullNumberNode;
            let value;
            let raw;
            if (node.parent.type === "UnaryExpression" && node.parent.operator === "-") {
              fullNumberNode = node.parent;
              value = -node.value;
              raw = `-${node.raw}`;
            } else {
              fullNumberNode = node;
              value = node.value;
              raw = node.raw;
            }
            const parent = fullNumberNode.parent;
            if (isIgnoredValue(value) || ignoreDefaultValues && isDefaultValue(fullNumberNode) || ignoreClassFieldInitialValues && isClassFieldInitialValue(fullNumberNode) || isParseIntRadix(fullNumberNode) || isJSXNumber(fullNumberNode) || ignoreArrayIndexes && isArrayIndex(fullNumberNode, value)) {
              return;
            }
            if (parent.type === "VariableDeclarator") {
              if (enforceConst && parent.parent.kind !== "const") {
                context.report({
                  node: fullNumberNode,
                  messageId: "useConst"
                });
              }
            } else if (!okTypes.includes(parent.type) || parent.type === "AssignmentExpression" && parent.left.type === "Identifier") {
              context.report({
                node: fullNumberNode,
                messageId: "noMagic",
                data: {
                  raw
                }
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/utils/unicode/is-combining-character.js
var require_is_combining_character = __commonJS({
  "../../node_modules/eslint/lib/rules/utils/unicode/is-combining-character.js"(exports, module) {
    "use strict";
    module.exports = function isCombiningCharacter(codePoint) {
      return /^[\p{Mc}\p{Me}\p{Mn}]$/u.test(String.fromCodePoint(codePoint));
    };
  }
});

// ../../node_modules/eslint/lib/rules/utils/unicode/is-emoji-modifier.js
var require_is_emoji_modifier = __commonJS({
  "../../node_modules/eslint/lib/rules/utils/unicode/is-emoji-modifier.js"(exports, module) {
    "use strict";
    module.exports = function isEmojiModifier(code) {
      return code >= 127995 && code <= 127999;
    };
  }
});

// ../../node_modules/eslint/lib/rules/utils/unicode/is-regional-indicator-symbol.js
var require_is_regional_indicator_symbol = __commonJS({
  "../../node_modules/eslint/lib/rules/utils/unicode/is-regional-indicator-symbol.js"(exports, module) {
    "use strict";
    module.exports = function isRegionalIndicatorSymbol(code) {
      return code >= 127462 && code <= 127487;
    };
  }
});

// ../../node_modules/eslint/lib/rules/utils/unicode/is-surrogate-pair.js
var require_is_surrogate_pair = __commonJS({
  "../../node_modules/eslint/lib/rules/utils/unicode/is-surrogate-pair.js"(exports, module) {
    "use strict";
    module.exports = function isSurrogatePair(lead, tail) {
      return lead >= 55296 && lead < 56320 && tail >= 56320 && tail < 57344;
    };
  }
});

// ../../node_modules/eslint/lib/rules/utils/unicode/index.js
var require_unicode = __commonJS({
  "../../node_modules/eslint/lib/rules/utils/unicode/index.js"(exports, module) {
    "use strict";
    module.exports = {
      isCombiningCharacter: require_is_combining_character(),
      isEmojiModifier: require_is_emoji_modifier(),
      isRegionalIndicatorSymbol: require_is_regional_indicator_symbol(),
      isSurrogatePair: require_is_surrogate_pair()
    };
  }
});

// ../../node_modules/eslint/lib/rules/utils/regular-expressions.js
var require_regular_expressions = __commonJS({
  "../../node_modules/eslint/lib/rules/utils/regular-expressions.js"(exports, module) {
    "use strict";
    var { RegExpValidator } = require_regexpp();
    var REGEXPP_LATEST_ECMA_VERSION = 2022;
    function isValidWithUnicodeFlag(ecmaVersion, pattern) {
      if (ecmaVersion <= 5) {
        return false;
      }
      const validator = new RegExpValidator({
        ecmaVersion: Math.min(ecmaVersion, REGEXPP_LATEST_ECMA_VERSION)
      });
      try {
        validator.validatePattern(
          pattern,
          void 0,
          void 0,
          /* uFlag = */
          true
        );
      } catch {
        return false;
      }
      return true;
    }
    module.exports = {
      isValidWithUnicodeFlag,
      REGEXPP_LATEST_ECMA_VERSION
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-misleading-character-class.js
var require_no_misleading_character_class = __commonJS({
  "../../node_modules/eslint/lib/rules/no-misleading-character-class.js"(exports, module) {
    "use strict";
    var { CALL, CONSTRUCT, ReferenceTracker, getStringIfConstant } = require_eslint_utils();
    var { RegExpParser, visitRegExpAST } = require_regexpp();
    var { isCombiningCharacter, isEmojiModifier, isRegionalIndicatorSymbol, isSurrogatePair } = require_unicode();
    var astUtils = require_ast_utils2();
    var { isValidWithUnicodeFlag } = require_regular_expressions();
    function* iterateCharacterSequence(nodes) {
      let seq = [];
      for (const node of nodes) {
        switch (node.type) {
          case "Character":
            seq.push(node.value);
            break;
          case "CharacterClassRange":
            seq.push(node.min.value);
            yield seq;
            seq = [node.max.value];
            break;
          case "CharacterSet":
            if (seq.length > 0) {
              yield seq;
              seq = [];
            }
            break;
        }
      }
      if (seq.length > 0) {
        yield seq;
      }
    }
    var hasCharacterSequence = {
      surrogatePairWithoutUFlag(chars) {
        return chars.some((c, i) => i !== 0 && isSurrogatePair(chars[i - 1], c));
      },
      combiningClass(chars) {
        return chars.some((c, i) => i !== 0 && isCombiningCharacter(c) && !isCombiningCharacter(chars[i - 1]));
      },
      emojiModifier(chars) {
        return chars.some((c, i) => i !== 0 && isEmojiModifier(c) && !isEmojiModifier(chars[i - 1]));
      },
      regionalIndicatorSymbol(chars) {
        return chars.some((c, i) => i !== 0 && isRegionalIndicatorSymbol(c) && isRegionalIndicatorSymbol(chars[i - 1]));
      },
      zwj(chars) {
        const lastIndex = chars.length - 1;
        return chars.some((c, i) => i !== 0 && i !== lastIndex && c === 8205 && chars[i - 1] !== 8205 && chars[i + 1] !== 8205);
      }
    };
    var kinds = Object.keys(hasCharacterSequence);
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow characters which are made with multiple code points in character class syntax",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-misleading-character-class"
        },
        hasSuggestions: true,
        schema: [],
        messages: {
          surrogatePairWithoutUFlag: "Unexpected surrogate pair in character class. Use 'u' flag.",
          combiningClass: "Unexpected combined character in character class.",
          emojiModifier: "Unexpected modified Emoji in character class.",
          regionalIndicatorSymbol: "Unexpected national flag in character class.",
          zwj: "Unexpected joined character sequence in character class.",
          suggestUnicodeFlag: "Add unicode 'u' flag to regex."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        const parser = new RegExpParser();
        function verify(node, pattern, flags, unicodeFixer) {
          let patternNode;
          try {
            patternNode = parser.parsePattern(
              pattern,
              0,
              pattern.length,
              flags.includes("u")
            );
          } catch {
            return;
          }
          const foundKinds = /* @__PURE__ */ new Set();
          visitRegExpAST(patternNode, {
            onCharacterClassEnter(ccNode) {
              for (const chars of iterateCharacterSequence(ccNode.elements)) {
                for (const kind of kinds) {
                  if (hasCharacterSequence[kind](chars)) {
                    foundKinds.add(kind);
                  }
                }
              }
            }
          });
          for (const kind of foundKinds) {
            let suggest;
            if (kind === "surrogatePairWithoutUFlag") {
              suggest = [{
                messageId: "suggestUnicodeFlag",
                fix: unicodeFixer
              }];
            }
            context.report({
              node,
              messageId: kind,
              suggest
            });
          }
        }
        return {
          "Literal[regex]"(node) {
            verify(node, node.regex.pattern, node.regex.flags, (fixer) => {
              if (!isValidWithUnicodeFlag(context.languageOptions.ecmaVersion, node.regex.pattern)) {
                return null;
              }
              return fixer.insertTextAfter(node, "u");
            });
          },
          "Program"(node) {
            const scope = sourceCode.getScope(node);
            const tracker = new ReferenceTracker(scope);
            for (const { node: refNode } of tracker.iterateGlobalReferences({
              RegExp: { [CALL]: true, [CONSTRUCT]: true }
            })) {
              const [patternNode, flagsNode] = refNode.arguments;
              const pattern = getStringIfConstant(patternNode, scope);
              const flags = getStringIfConstant(flagsNode, scope);
              if (typeof pattern === "string") {
                verify(refNode, pattern, flags || "", (fixer) => {
                  if (!isValidWithUnicodeFlag(context.languageOptions.ecmaVersion, pattern)) {
                    return null;
                  }
                  if (refNode.arguments.length === 1) {
                    const penultimateToken = sourceCode.getLastToken(refNode, { skip: 1 });
                    return fixer.insertTextAfter(
                      penultimateToken,
                      astUtils.isCommaToken(penultimateToken) ? ' "u",' : ', "u"'
                    );
                  }
                  if (flagsNode.type === "Literal" && typeof flagsNode.value === "string" || flagsNode.type === "TemplateLiteral") {
                    const range = [flagsNode.range[0], flagsNode.range[1] - 1];
                    return fixer.insertTextAfterRange(range, "u");
                  }
                  return null;
                });
              }
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-mixed-operators.js
var require_no_mixed_operators = __commonJS({
  "../../node_modules/eslint/lib/rules/no-mixed-operators.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var ARITHMETIC_OPERATORS = ["+", "-", "*", "/", "%", "**"];
    var BITWISE_OPERATORS = ["&", "|", "^", "~", "<<", ">>", ">>>"];
    var COMPARISON_OPERATORS = ["==", "!=", "===", "!==", ">", ">=", "<", "<="];
    var LOGICAL_OPERATORS = ["&&", "||"];
    var RELATIONAL_OPERATORS = ["in", "instanceof"];
    var TERNARY_OPERATOR = ["?:"];
    var COALESCE_OPERATOR = ["??"];
    var ALL_OPERATORS = [].concat(
      ARITHMETIC_OPERATORS,
      BITWISE_OPERATORS,
      COMPARISON_OPERATORS,
      LOGICAL_OPERATORS,
      RELATIONAL_OPERATORS,
      TERNARY_OPERATOR,
      COALESCE_OPERATOR
    );
    var DEFAULT_GROUPS = [
      ARITHMETIC_OPERATORS,
      BITWISE_OPERATORS,
      COMPARISON_OPERATORS,
      LOGICAL_OPERATORS,
      RELATIONAL_OPERATORS
    ];
    var TARGET_NODE_TYPE = /^(?:Binary|Logical|Conditional)Expression$/u;
    function normalizeOptions(options = {}) {
      const hasGroups = options.groups && options.groups.length > 0;
      const groups = hasGroups ? options.groups : DEFAULT_GROUPS;
      const allowSamePrecedence = options.allowSamePrecedence !== false;
      return {
        groups,
        allowSamePrecedence
      };
    }
    function includesBothInAGroup(groups, left, right) {
      return groups.some((group) => group.includes(left) && group.includes(right));
    }
    function getChildNode(node) {
      return node.type === "ConditionalExpression" ? node.test : node.left;
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow mixed binary operators",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-mixed-operators"
        },
        schema: [
          {
            type: "object",
            properties: {
              groups: {
                type: "array",
                items: {
                  type: "array",
                  items: { enum: ALL_OPERATORS },
                  minItems: 2,
                  uniqueItems: true
                },
                uniqueItems: true
              },
              allowSamePrecedence: {
                type: "boolean",
                default: true
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          unexpectedMixedOperator: "Unexpected mix of '{{leftOperator}}' and '{{rightOperator}}'. Use parentheses to clarify the intended order of operations."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        const options = normalizeOptions(context.options[0]);
        function shouldIgnore(node) {
          const a = node;
          const b = node.parent;
          return !includesBothInAGroup(options.groups, a.operator, b.type === "ConditionalExpression" ? "?:" : b.operator) || options.allowSamePrecedence && astUtils.getPrecedence(a) === astUtils.getPrecedence(b);
        }
        function isMixedWithParent(node) {
          return node.operator !== node.parent.operator && !astUtils.isParenthesised(sourceCode, node);
        }
        function getOperatorToken(node) {
          return sourceCode.getTokenAfter(getChildNode(node), astUtils.isNotClosingParenToken);
        }
        function reportBothOperators(node) {
          const parent = node.parent;
          const left = getChildNode(parent) === node ? node : parent;
          const right = getChildNode(parent) !== node ? node : parent;
          const data = {
            leftOperator: left.operator || "?:",
            rightOperator: right.operator || "?:"
          };
          context.report({
            node: left,
            loc: getOperatorToken(left).loc,
            messageId: "unexpectedMixedOperator",
            data
          });
          context.report({
            node: right,
            loc: getOperatorToken(right).loc,
            messageId: "unexpectedMixedOperator",
            data
          });
        }
        function check(node) {
          if (TARGET_NODE_TYPE.test(node.parent.type) && isMixedWithParent(node) && !shouldIgnore(node)) {
            reportBothOperators(node);
          }
        }
        return {
          BinaryExpression: check,
          LogicalExpression: check
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-mixed-requires.js
var require_no_mixed_requires = __commonJS({
  "../../node_modules/eslint/lib/rules/no-mixed-requires.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        deprecated: true,
        replacedBy: [],
        type: "suggestion",
        docs: {
          description: "Disallow `require` calls to be mixed with regular variable declarations",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-mixed-requires"
        },
        schema: [
          {
            oneOf: [
              {
                type: "boolean"
              },
              {
                type: "object",
                properties: {
                  grouping: {
                    type: "boolean"
                  },
                  allowCall: {
                    type: "boolean"
                  }
                },
                additionalProperties: false
              }
            ]
          }
        ],
        messages: {
          noMixRequire: "Do not mix 'require' and other declarations.",
          noMixCoreModuleFileComputed: "Do not mix core, module, file and computed requires."
        }
      },
      create(context) {
        const options = context.options[0];
        let grouping = false, allowCall = false;
        if (typeof options === "object") {
          grouping = options.grouping;
          allowCall = options.allowCall;
        } else {
          grouping = !!options;
        }
        function getBuiltinModules() {
          return [
            "assert",
            "buffer",
            "child_process",
            "cluster",
            "crypto",
            "dgram",
            "dns",
            "domain",
            "events",
            "fs",
            "http",
            "https",
            "net",
            "os",
            "path",
            "punycode",
            "querystring",
            "readline",
            "repl",
            "smalloc",
            "stream",
            "string_decoder",
            "tls",
            "tty",
            "url",
            "util",
            "v8",
            "vm",
            "zlib"
          ];
        }
        const BUILTIN_MODULES = getBuiltinModules();
        const DECL_REQUIRE = "require", DECL_UNINITIALIZED = "uninitialized", DECL_OTHER = "other";
        const REQ_CORE = "core", REQ_FILE = "file", REQ_MODULE = "module", REQ_COMPUTED = "computed";
        function getDeclarationType(initExpression) {
          if (!initExpression) {
            return DECL_UNINITIALIZED;
          }
          if (initExpression.type === "CallExpression" && initExpression.callee.type === "Identifier" && initExpression.callee.name === "require") {
            return DECL_REQUIRE;
          }
          if (allowCall && initExpression.type === "CallExpression" && initExpression.callee.type === "CallExpression") {
            return getDeclarationType(initExpression.callee);
          }
          if (initExpression.type === "MemberExpression") {
            return getDeclarationType(initExpression.object);
          }
          return DECL_OTHER;
        }
        function inferModuleType(initExpression) {
          if (initExpression.type === "MemberExpression") {
            return inferModuleType(initExpression.object);
          }
          if (initExpression.arguments.length === 0) {
            return REQ_COMPUTED;
          }
          const arg = initExpression.arguments[0];
          if (arg.type !== "Literal" || typeof arg.value !== "string") {
            return REQ_COMPUTED;
          }
          if (BUILTIN_MODULES.includes(arg.value)) {
            return REQ_CORE;
          }
          if (/^\.{0,2}\//u.test(arg.value)) {
            return REQ_FILE;
          }
          return REQ_MODULE;
        }
        function isMixed(declarations) {
          const contains = {};
          declarations.forEach((declaration) => {
            const type = getDeclarationType(declaration.init);
            contains[type] = true;
          });
          return !!(contains[DECL_REQUIRE] && (contains[DECL_UNINITIALIZED] || contains[DECL_OTHER]));
        }
        function isGrouped(declarations) {
          const found = {};
          declarations.forEach((declaration) => {
            if (getDeclarationType(declaration.init) === DECL_REQUIRE) {
              found[inferModuleType(declaration.init)] = true;
            }
          });
          return Object.keys(found).length <= 1;
        }
        return {
          VariableDeclaration(node) {
            if (isMixed(node.declarations)) {
              context.report({
                node,
                messageId: "noMixRequire"
              });
            } else if (grouping && !isGrouped(node.declarations)) {
              context.report({
                node,
                messageId: "noMixCoreModuleFileComputed"
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-mixed-spaces-and-tabs.js
var require_no_mixed_spaces_and_tabs = __commonJS({
  "../../node_modules/eslint/lib/rules/no-mixed-spaces-and-tabs.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Disallow mixed spaces and tabs for indentation",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-mixed-spaces-and-tabs"
        },
        schema: [
          {
            enum: ["smart-tabs", true, false]
          }
        ],
        messages: {
          mixedSpacesAndTabs: "Mixed spaces and tabs."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        let smartTabs;
        switch (context.options[0]) {
          case true:
          case "smart-tabs":
            smartTabs = true;
            break;
          default:
            smartTabs = false;
        }
        return {
          "Program:exit"(node) {
            const lines = sourceCode.lines, comments = sourceCode.getAllComments(), ignoredCommentLines = /* @__PURE__ */ new Set();
            comments.forEach((comment) => {
              for (let i = comment.loc.start.line + 1; i <= comment.loc.end.line; i++) {
                ignoredCommentLines.add(i);
              }
            });
            let regex = /^(?=( +|\t+))\1(?:\t| )/u;
            if (smartTabs) {
              regex = /^(?=(\t*))\1(?=( +))\2\t/u;
            }
            lines.forEach((line, i) => {
              const match = regex.exec(line);
              if (match) {
                const lineNumber = i + 1;
                const loc = {
                  start: {
                    line: lineNumber,
                    column: match[0].length - 2
                  },
                  end: {
                    line: lineNumber,
                    column: match[0].length
                  }
                };
                if (!ignoredCommentLines.has(lineNumber)) {
                  const containingNode = sourceCode.getNodeByRangeIndex(sourceCode.getIndexFromLoc(loc.start));
                  if (!(containingNode && ["Literal", "TemplateElement"].includes(containingNode.type))) {
                    context.report({
                      node,
                      loc,
                      messageId: "mixedSpacesAndTabs"
                    });
                  }
                }
              }
            });
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-multi-assign.js
var require_no_multi_assign = __commonJS({
  "../../node_modules/eslint/lib/rules/no-multi-assign.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow use of chained assignment expressions",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-multi-assign"
        },
        schema: [{
          type: "object",
          properties: {
            ignoreNonDeclaration: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }],
        messages: {
          unexpectedChain: "Unexpected chained assignment."
        }
      },
      create(context) {
        const options = context.options[0] || {
          ignoreNonDeclaration: false
        };
        const selectors = [
          "VariableDeclarator > AssignmentExpression.init",
          "PropertyDefinition > AssignmentExpression.value"
        ];
        if (!options.ignoreNonDeclaration) {
          selectors.push("AssignmentExpression > AssignmentExpression.right");
        }
        return {
          [selectors](node) {
            context.report({
              node,
              messageId: "unexpectedChain"
            });
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-multi-spaces.js
var require_no_multi_spaces = __commonJS({
  "../../node_modules/eslint/lib/rules/no-multi-spaces.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Disallow multiple spaces",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-multi-spaces"
        },
        fixable: "whitespace",
        schema: [
          {
            type: "object",
            properties: {
              exceptions: {
                type: "object",
                patternProperties: {
                  "^([A-Z][a-z]*)+$": {
                    type: "boolean"
                  }
                },
                additionalProperties: false
              },
              ignoreEOLComments: {
                type: "boolean",
                default: false
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          multipleSpaces: "Multiple spaces found before '{{displayValue}}'."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        const options = context.options[0] || {};
        const ignoreEOLComments = options.ignoreEOLComments;
        const exceptions = Object.assign({ Property: true }, options.exceptions);
        const hasExceptions = Object.keys(exceptions).some((key) => exceptions[key]);
        function formatReportedCommentValue(token) {
          const valueLines = token.value.split("\n");
          const value = valueLines[0];
          const formattedValue = `${value.slice(0, 12)}...`;
          return valueLines.length === 1 && value.length <= 12 ? value : formattedValue;
        }
        return {
          Program() {
            sourceCode.tokensAndComments.forEach((leftToken, leftIndex, tokensAndComments) => {
              if (leftIndex === tokensAndComments.length - 1) {
                return;
              }
              const rightToken = tokensAndComments[leftIndex + 1];
              if (!sourceCode.text.slice(leftToken.range[1], rightToken.range[0]).includes("  ") || leftToken.loc.end.line < rightToken.loc.start.line) {
                return;
              }
              if (ignoreEOLComments && astUtils.isCommentToken(rightToken) && (leftIndex === tokensAndComments.length - 2 || rightToken.loc.end.line < tokensAndComments[leftIndex + 2].loc.start.line)) {
                return;
              }
              if (hasExceptions) {
                const parentNode = sourceCode.getNodeByRangeIndex(rightToken.range[0] - 1);
                if (parentNode && exceptions[parentNode.type]) {
                  return;
                }
              }
              let displayValue;
              if (rightToken.type === "Block") {
                displayValue = `/*${formatReportedCommentValue(rightToken)}*/`;
              } else if (rightToken.type === "Line") {
                displayValue = `//${formatReportedCommentValue(rightToken)}`;
              } else {
                displayValue = rightToken.value;
              }
              context.report({
                node: rightToken,
                loc: { start: leftToken.loc.end, end: rightToken.loc.start },
                messageId: "multipleSpaces",
                data: { displayValue },
                fix: (fixer) => fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], " ")
              });
            });
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-multi-str.js
var require_no_multi_str = __commonJS({
  "../../node_modules/eslint/lib/rules/no-multi-str.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow multiline strings",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-multi-str"
        },
        schema: [],
        messages: {
          multilineString: "Multiline support is limited to browsers supporting ES5 only."
        }
      },
      create(context) {
        function isJSXElement(node) {
          return node.type.indexOf("JSX") === 0;
        }
        return {
          Literal(node) {
            if (astUtils.LINEBREAK_MATCHER.test(node.raw) && !isJSXElement(node.parent)) {
              context.report({
                node,
                messageId: "multilineString"
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-multiple-empty-lines.js
var require_no_multiple_empty_lines = __commonJS({
  "../../node_modules/eslint/lib/rules/no-multiple-empty-lines.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Disallow multiple empty lines",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-multiple-empty-lines"
        },
        fixable: "whitespace",
        schema: [
          {
            type: "object",
            properties: {
              max: {
                type: "integer",
                minimum: 0
              },
              maxEOF: {
                type: "integer",
                minimum: 0
              },
              maxBOF: {
                type: "integer",
                minimum: 0
              }
            },
            required: ["max"],
            additionalProperties: false
          }
        ],
        messages: {
          blankBeginningOfFile: "Too many blank lines at the beginning of file. Max of {{max}} allowed.",
          blankEndOfFile: "Too many blank lines at the end of file. Max of {{max}} allowed.",
          consecutiveBlank: "More than {{max}} blank {{pluralizedLines}} not allowed."
        }
      },
      create(context) {
        let max = 2, maxEOF = max, maxBOF = max;
        if (context.options.length) {
          max = context.options[0].max;
          maxEOF = typeof context.options[0].maxEOF !== "undefined" ? context.options[0].maxEOF : max;
          maxBOF = typeof context.options[0].maxBOF !== "undefined" ? context.options[0].maxBOF : max;
        }
        const sourceCode = context.sourceCode;
        const allLines = sourceCode.lines[sourceCode.lines.length - 1] === "" ? sourceCode.lines.slice(0, -1) : sourceCode.lines;
        const templateLiteralLines = /* @__PURE__ */ new Set();
        return {
          TemplateLiteral(node) {
            node.quasis.forEach((literalPart) => {
              for (let ignoredLine = literalPart.loc.start.line; ignoredLine < literalPart.loc.end.line; ignoredLine++) {
                templateLiteralLines.add(ignoredLine);
              }
            });
          },
          "Program:exit"(node) {
            return allLines.reduce((nonEmptyLineNumbers, line, index) => {
              if (line.trim() || templateLiteralLines.has(index + 1)) {
                nonEmptyLineNumbers.push(index + 1);
              }
              return nonEmptyLineNumbers;
            }, []).concat(allLines.length + 1).reduce((lastLineNumber, lineNumber) => {
              let messageId, maxAllowed;
              if (lastLineNumber === 0) {
                messageId = "blankBeginningOfFile";
                maxAllowed = maxBOF;
              } else if (lineNumber === allLines.length + 1) {
                messageId = "blankEndOfFile";
                maxAllowed = maxEOF;
              } else {
                messageId = "consecutiveBlank";
                maxAllowed = max;
              }
              if (lineNumber - lastLineNumber - 1 > maxAllowed) {
                context.report({
                  node,
                  loc: {
                    start: { line: lastLineNumber + maxAllowed + 1, column: 0 },
                    end: { line: lineNumber, column: 0 }
                  },
                  messageId,
                  data: {
                    max: maxAllowed,
                    pluralizedLines: maxAllowed === 1 ? "line" : "lines"
                  },
                  fix(fixer) {
                    const rangeStart = sourceCode.getIndexFromLoc({ line: lastLineNumber + 1, column: 0 });
                    const lineNumberAfterRemovedLines = lineNumber - maxAllowed;
                    const rangeEnd = lineNumberAfterRemovedLines <= allLines.length ? sourceCode.getIndexFromLoc({ line: lineNumberAfterRemovedLines, column: 0 }) : sourceCode.text.length;
                    return fixer.removeRange([rangeStart, rangeEnd]);
                  }
                });
              }
              return lineNumber;
            }, 0);
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-native-reassign.js
var require_no_native_reassign = __commonJS({
  "../../node_modules/eslint/lib/rules/no-native-reassign.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow assignments to native objects or read-only global variables",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-native-reassign"
        },
        deprecated: true,
        replacedBy: ["no-global-assign"],
        schema: [
          {
            type: "object",
            properties: {
              exceptions: {
                type: "array",
                items: { type: "string" },
                uniqueItems: true
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          nativeReassign: "Read-only global '{{name}}' should not be modified."
        }
      },
      create(context) {
        const config = context.options[0];
        const exceptions = config && config.exceptions || [];
        const sourceCode = context.sourceCode;
        function checkReference(reference, index, references) {
          const identifier = reference.identifier;
          if (reference.init === false && reference.isWrite() && /*
           * Destructuring assignments can have multiple default value,
           * so possibly there are multiple writeable references for the same identifier.
           */
          (index === 0 || references[index - 1].identifier !== identifier)) {
            context.report({
              node: identifier,
              messageId: "nativeReassign",
              data: identifier
            });
          }
        }
        function checkVariable(variable) {
          if (variable.writeable === false && !exceptions.includes(variable.name)) {
            variable.references.forEach(checkReference);
          }
        }
        return {
          Program(node) {
            const globalScope = sourceCode.getScope(node);
            globalScope.variables.forEach(checkVariable);
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-negated-condition.js
var require_no_negated_condition = __commonJS({
  "../../node_modules/eslint/lib/rules/no-negated-condition.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow negated conditions",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-negated-condition"
        },
        schema: [],
        messages: {
          unexpectedNegated: "Unexpected negated condition."
        }
      },
      create(context) {
        function hasElseWithoutCondition(node) {
          return node.alternate && node.alternate.type !== "IfStatement";
        }
        function isNegatedUnaryExpression(test) {
          return test.type === "UnaryExpression" && test.operator === "!";
        }
        function isNegatedBinaryExpression(test) {
          return test.type === "BinaryExpression" && (test.operator === "!=" || test.operator === "!==");
        }
        function isNegatedIf(node) {
          return isNegatedUnaryExpression(node.test) || isNegatedBinaryExpression(node.test);
        }
        return {
          IfStatement(node) {
            if (!hasElseWithoutCondition(node)) {
              return;
            }
            if (isNegatedIf(node)) {
              context.report({
                node,
                messageId: "unexpectedNegated"
              });
            }
          },
          ConditionalExpression(node) {
            if (isNegatedIf(node)) {
              context.report({
                node,
                messageId: "unexpectedNegated"
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-negated-in-lhs.js
var require_no_negated_in_lhs = __commonJS({
  "../../node_modules/eslint/lib/rules/no-negated-in-lhs.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow negating the left operand in `in` expressions",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-negated-in-lhs"
        },
        replacedBy: ["no-unsafe-negation"],
        deprecated: true,
        schema: [],
        messages: {
          negatedLHS: "The 'in' expression's left operand is negated."
        }
      },
      create(context) {
        return {
          BinaryExpression(node) {
            if (node.operator === "in" && node.left.type === "UnaryExpression" && node.left.operator === "!") {
              context.report({ node, messageId: "negatedLHS" });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-nested-ternary.js
var require_no_nested_ternary = __commonJS({
  "../../node_modules/eslint/lib/rules/no-nested-ternary.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow nested ternary expressions",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-nested-ternary"
        },
        schema: [],
        messages: {
          noNestedTernary: "Do not nest ternary expressions."
        }
      },
      create(context) {
        return {
          ConditionalExpression(node) {
            if (node.alternate.type === "ConditionalExpression" || node.consequent.type === "ConditionalExpression") {
              context.report({
                node,
                messageId: "noNestedTernary"
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-new.js
var require_no_new = __commonJS({
  "../../node_modules/eslint/lib/rules/no-new.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow `new` operators outside of assignments or comparisons",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-new"
        },
        schema: [],
        messages: {
          noNewStatement: "Do not use 'new' for side effects."
        }
      },
      create(context) {
        return {
          "ExpressionStatement > NewExpression"(node) {
            context.report({
              node: node.parent,
              messageId: "noNewStatement"
            });
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-new-func.js
var require_no_new_func = __commonJS({
  "../../node_modules/eslint/lib/rules/no-new-func.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var callMethods = /* @__PURE__ */ new Set(["apply", "bind", "call"]);
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow `new` operators with the `Function` object",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-new-func"
        },
        schema: [],
        messages: {
          noFunctionConstructor: "The Function constructor is eval."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        return {
          "Program:exit"(node) {
            const globalScope = sourceCode.getScope(node);
            const variable = globalScope.set.get("Function");
            if (variable && variable.defs.length === 0) {
              variable.references.forEach((ref) => {
                const idNode = ref.identifier;
                const { parent } = idNode;
                let evalNode;
                if (parent) {
                  if (idNode === parent.callee && (parent.type === "NewExpression" || parent.type === "CallExpression")) {
                    evalNode = parent;
                  } else if (parent.type === "MemberExpression" && idNode === parent.object && callMethods.has(astUtils.getStaticPropertyName(parent))) {
                    const maybeCallee = parent.parent.type === "ChainExpression" ? parent.parent : parent;
                    if (maybeCallee.parent.type === "CallExpression" && maybeCallee.parent.callee === maybeCallee) {
                      evalNode = maybeCallee.parent;
                    }
                  }
                }
                if (evalNode) {
                  context.report({
                    node: evalNode,
                    messageId: "noFunctionConstructor"
                  });
                }
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-new-native-nonconstructor.js
var require_no_new_native_nonconstructor = __commonJS({
  "../../node_modules/eslint/lib/rules/no-new-native-nonconstructor.js"(exports, module) {
    "use strict";
    var nonConstructorGlobalFunctionNames = ["Symbol", "BigInt"];
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow `new` operators with global non-constructor functions",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-new-native-nonconstructor"
        },
        schema: [],
        messages: {
          noNewNonconstructor: "`{{name}}` cannot be called as a constructor."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        return {
          "Program:exit"(node) {
            const globalScope = sourceCode.getScope(node);
            for (const nonConstructorName of nonConstructorGlobalFunctionNames) {
              const variable = globalScope.set.get(nonConstructorName);
              if (variable && variable.defs.length === 0) {
                variable.references.forEach((ref) => {
                  const idNode = ref.identifier;
                  const parent = idNode.parent;
                  if (parent && parent.type === "NewExpression" && parent.callee === idNode) {
                    context.report({
                      node: idNode,
                      messageId: "noNewNonconstructor",
                      data: { name: nonConstructorName }
                    });
                  }
                });
              }
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-new-object.js
var require_no_new_object = __commonJS({
  "../../node_modules/eslint/lib/rules/no-new-object.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow `Object` constructors",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-new-object"
        },
        schema: [],
        messages: {
          preferLiteral: "The object literal notation {} is preferable."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        return {
          NewExpression(node) {
            const variable = astUtils.getVariableByName(
              sourceCode.getScope(node),
              node.callee.name
            );
            if (variable && variable.identifiers.length > 0) {
              return;
            }
            if (node.callee.name === "Object") {
              context.report({
                node,
                messageId: "preferLiteral"
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-new-require.js
var require_no_new_require = __commonJS({
  "../../node_modules/eslint/lib/rules/no-new-require.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        deprecated: true,
        replacedBy: [],
        type: "suggestion",
        docs: {
          description: "Disallow `new` operators with calls to `require`",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-new-require"
        },
        schema: [],
        messages: {
          noNewRequire: "Unexpected use of new with require."
        }
      },
      create(context) {
        return {
          NewExpression(node) {
            if (node.callee.type === "Identifier" && node.callee.name === "require") {
              context.report({
                node,
                messageId: "noNewRequire"
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-new-symbol.js
var require_no_new_symbol = __commonJS({
  "../../node_modules/eslint/lib/rules/no-new-symbol.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow `new` operators with the `Symbol` object",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-new-symbol"
        },
        schema: [],
        messages: {
          noNewSymbol: "`Symbol` cannot be called as a constructor."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        return {
          "Program:exit"(node) {
            const globalScope = sourceCode.getScope(node);
            const variable = globalScope.set.get("Symbol");
            if (variable && variable.defs.length === 0) {
              variable.references.forEach((ref) => {
                const idNode = ref.identifier;
                const parent = idNode.parent;
                if (parent && parent.type === "NewExpression" && parent.callee === idNode) {
                  context.report({
                    node: idNode,
                    messageId: "noNewSymbol"
                  });
                }
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-new-wrappers.js
var require_no_new_wrappers = __commonJS({
  "../../node_modules/eslint/lib/rules/no-new-wrappers.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow `new` operators with the `String`, `Number`, and `Boolean` objects",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-new-wrappers"
        },
        schema: [],
        messages: {
          noConstructor: "Do not use {{fn}} as a constructor."
        }
      },
      create(context) {
        return {
          NewExpression(node) {
            const wrapperObjects = ["String", "Number", "Boolean"];
            if (wrapperObjects.includes(node.callee.name)) {
              context.report({
                node,
                messageId: "noConstructor",
                data: { fn: node.callee.name }
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-nonoctal-decimal-escape.js
var require_no_nonoctal_decimal_escape = __commonJS({
  "../../node_modules/eslint/lib/rules/no-nonoctal-decimal-escape.js"(exports, module) {
    "use strict";
    var QUICK_TEST_REGEX = /\\[89]/u;
    function getUnicodeEscape(character) {
      return `\\u${character.charCodeAt(0).toString(16).padStart(4, "0")}`;
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow `\\8` and `\\9` escape sequences in string literals",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-nonoctal-decimal-escape"
        },
        hasSuggestions: true,
        schema: [],
        messages: {
          decimalEscape: "Don't use '{{decimalEscape}}' escape sequence.",
          // suggestions
          refactor: "Replace '{{original}}' with '{{replacement}}'. This maintains the current functionality.",
          escapeBackslash: "Replace '{{original}}' with '{{replacement}}' to include the actual backslash character."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        function createSuggestion(messageId, range, replacement) {
          return {
            messageId,
            data: {
              original: sourceCode.getText().slice(...range),
              replacement
            },
            fix(fixer) {
              return fixer.replaceTextRange(range, replacement);
            }
          };
        }
        return {
          Literal(node) {
            if (typeof node.value !== "string") {
              return;
            }
            if (!QUICK_TEST_REGEX.test(node.raw)) {
              return;
            }
            const regex = /(?:[^\\]|(?<previousEscape>\\.))*?(?<decimalEscape>\\[89])/suy;
            let match;
            while (match = regex.exec(node.raw)) {
              const { previousEscape, decimalEscape } = match.groups;
              const decimalEscapeRangeEnd = node.range[0] + match.index + match[0].length;
              const decimalEscapeRangeStart = decimalEscapeRangeEnd - decimalEscape.length;
              const decimalEscapeRange = [decimalEscapeRangeStart, decimalEscapeRangeEnd];
              const suggest = [];
              if (previousEscape === "\\0") {
                suggest.push(
                  createSuggestion(
                    // "\0\8" -> "\u00008"
                    "refactor",
                    [decimalEscapeRangeStart - previousEscape.length, decimalEscapeRangeEnd],
                    `${getUnicodeEscape("\0")}${decimalEscape[1]}`
                  ),
                  createSuggestion(
                    // "\8" -> "\u0038"
                    "refactor",
                    decimalEscapeRange,
                    getUnicodeEscape(decimalEscape[1])
                  )
                );
              } else {
                suggest.push(
                  createSuggestion(
                    // "\8" -> "8"
                    "refactor",
                    decimalEscapeRange,
                    decimalEscape[1]
                  )
                );
              }
              suggest.push(
                createSuggestion(
                  // "\8" -> "\\8"
                  "escapeBackslash",
                  decimalEscapeRange,
                  `\\${decimalEscape}`
                )
              );
              context.report({
                node,
                loc: {
                  start: sourceCode.getLocFromIndex(decimalEscapeRangeStart),
                  end: sourceCode.getLocFromIndex(decimalEscapeRangeEnd)
                },
                messageId: "decimalEscape",
                data: {
                  decimalEscape
                },
                suggest
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-obj-calls.js
var require_no_obj_calls = __commonJS({
  "../../node_modules/eslint/lib/rules/no-obj-calls.js"(exports, module) {
    "use strict";
    var { CALL, CONSTRUCT, ReferenceTracker } = require_eslint_utils();
    var getPropertyName = require_ast_utils2().getStaticPropertyName;
    var nonCallableGlobals = ["Atomics", "JSON", "Math", "Reflect", "Intl"];
    function getReportNodeName(node) {
      if (node.type === "ChainExpression") {
        return getReportNodeName(node.expression);
      }
      if (node.type === "MemberExpression") {
        return getPropertyName(node);
      }
      return node.name;
    }
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow calling global object properties as functions",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-obj-calls"
        },
        schema: [],
        messages: {
          unexpectedCall: "'{{name}}' is not a function.",
          unexpectedRefCall: "'{{name}}' is reference to '{{ref}}', which is not a function."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        return {
          Program(node) {
            const scope = sourceCode.getScope(node);
            const tracker = new ReferenceTracker(scope);
            const traceMap = {};
            for (const g of nonCallableGlobals) {
              traceMap[g] = {
                [CALL]: true,
                [CONSTRUCT]: true
              };
            }
            for (const { node: refNode, path } of tracker.iterateGlobalReferences(traceMap)) {
              const name = getReportNodeName(refNode.callee);
              const ref = path[0];
              const messageId = name === ref ? "unexpectedCall" : "unexpectedRefCall";
              context.report({ node: refNode, messageId, data: { name, ref } });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-octal.js
var require_no_octal = __commonJS({
  "../../node_modules/eslint/lib/rules/no-octal.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow octal literals",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-octal"
        },
        schema: [],
        messages: {
          noOctal: "Octal literals should not be used."
        }
      },
      create(context) {
        return {
          Literal(node) {
            if (typeof node.value === "number" && /^0[0-9]/u.test(node.raw)) {
              context.report({
                node,
                messageId: "noOctal"
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-octal-escape.js
var require_no_octal_escape = __commonJS({
  "../../node_modules/eslint/lib/rules/no-octal-escape.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow octal escape sequences in string literals",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-octal-escape"
        },
        schema: [],
        messages: {
          octalEscapeSequence: "Don't use octal: '\\{{sequence}}'. Use '\\u....' instead."
        }
      },
      create(context) {
        return {
          Literal(node) {
            if (typeof node.value !== "string") {
              return;
            }
            const match = node.raw.match(
              /^(?:[^\\]|\\.)*?\\([0-3][0-7]{1,2}|[4-7][0-7]|0(?=[89])|[1-7])/su
            );
            if (match) {
              context.report({
                node,
                messageId: "octalEscapeSequence",
                data: { sequence: match[1] }
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-param-reassign.js
var require_no_param_reassign = __commonJS({
  "../../node_modules/eslint/lib/rules/no-param-reassign.js"(exports, module) {
    "use strict";
    var stopNodePattern = /(?:Statement|Declaration|Function(?:Expression)?|Program)$/u;
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow reassigning `function` parameters",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-param-reassign"
        },
        schema: [
          {
            oneOf: [
              {
                type: "object",
                properties: {
                  props: {
                    enum: [false]
                  }
                },
                additionalProperties: false
              },
              {
                type: "object",
                properties: {
                  props: {
                    enum: [true]
                  },
                  ignorePropertyModificationsFor: {
                    type: "array",
                    items: {
                      type: "string"
                    },
                    uniqueItems: true
                  },
                  ignorePropertyModificationsForRegex: {
                    type: "array",
                    items: {
                      type: "string"
                    },
                    uniqueItems: true
                  }
                },
                additionalProperties: false
              }
            ]
          }
        ],
        messages: {
          assignmentToFunctionParam: "Assignment to function parameter '{{name}}'.",
          assignmentToFunctionParamProp: "Assignment to property of function parameter '{{name}}'."
        }
      },
      create(context) {
        const props = context.options[0] && context.options[0].props;
        const ignoredPropertyAssignmentsFor = context.options[0] && context.options[0].ignorePropertyModificationsFor || [];
        const ignoredPropertyAssignmentsForRegex = context.options[0] && context.options[0].ignorePropertyModificationsForRegex || [];
        const sourceCode = context.sourceCode;
        function isModifyingProp(reference) {
          let node = reference.identifier;
          let parent = node.parent;
          while (parent && (!stopNodePattern.test(parent.type) || parent.type === "ForInStatement" || parent.type === "ForOfStatement")) {
            switch (parent.type) {
              case "AssignmentExpression":
                return parent.left === node;
              case "UpdateExpression":
                return true;
              case "UnaryExpression":
                if (parent.operator === "delete") {
                  return true;
                }
                break;
              case "ForInStatement":
              case "ForOfStatement":
                if (parent.left === node) {
                  return true;
                }
                return false;
              case "CallExpression":
                if (parent.callee !== node) {
                  return false;
                }
                break;
              case "MemberExpression":
                if (parent.property === node) {
                  return false;
                }
                break;
              case "Property":
                if (parent.key === node) {
                  return false;
                }
                break;
              case "ConditionalExpression":
                if (parent.test === node) {
                  return false;
                }
                break;
            }
            node = parent;
            parent = node.parent;
          }
          return false;
        }
        function isIgnoredPropertyAssignment(identifierName) {
          return ignoredPropertyAssignmentsFor.includes(identifierName) || ignoredPropertyAssignmentsForRegex.some((ignored) => new RegExp(ignored, "u").test(identifierName));
        }
        function checkReference(reference, index, references) {
          const identifier = reference.identifier;
          if (identifier && !reference.init && /*
           * Destructuring assignments can have multiple default value,
           * so possibly there are multiple writeable references for the same identifier.
           */
          (index === 0 || references[index - 1].identifier !== identifier)) {
            if (reference.isWrite()) {
              context.report({
                node: identifier,
                messageId: "assignmentToFunctionParam",
                data: { name: identifier.name }
              });
            } else if (props && isModifyingProp(reference) && !isIgnoredPropertyAssignment(identifier.name)) {
              context.report({
                node: identifier,
                messageId: "assignmentToFunctionParamProp",
                data: { name: identifier.name }
              });
            }
          }
        }
        function checkVariable(variable) {
          if (variable.defs[0].type === "Parameter") {
            variable.references.forEach(checkReference);
          }
        }
        function checkForFunction(node) {
          sourceCode.getDeclaredVariables(node).forEach(checkVariable);
        }
        return {
          // `:exit` is needed for the `node.parent` property of identifier nodes.
          "FunctionDeclaration:exit": checkForFunction,
          "FunctionExpression:exit": checkForFunction,
          "ArrowFunctionExpression:exit": checkForFunction
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-path-concat.js
var require_no_path_concat = __commonJS({
  "../../node_modules/eslint/lib/rules/no-path-concat.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        deprecated: true,
        replacedBy: [],
        type: "suggestion",
        docs: {
          description: "Disallow string concatenation with `__dirname` and `__filename`",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-path-concat"
        },
        schema: [],
        messages: {
          usePathFunctions: "Use path.join() or path.resolve() instead of + to create paths."
        }
      },
      create(context) {
        const MATCHER = /^__(?:dir|file)name$/u;
        return {
          BinaryExpression(node) {
            const left = node.left, right = node.right;
            if (node.operator === "+" && (left.type === "Identifier" && MATCHER.test(left.name) || right.type === "Identifier" && MATCHER.test(right.name))) {
              context.report({
                node,
                messageId: "usePathFunctions"
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-plusplus.js
var require_no_plusplus = __commonJS({
  "../../node_modules/eslint/lib/rules/no-plusplus.js"(exports, module) {
    "use strict";
    function isForStatementUpdate(node) {
      const parent = node.parent;
      return parent.type === "ForStatement" && parent.update === node;
    }
    function isForLoopAfterthought(node) {
      const parent = node.parent;
      if (parent.type === "SequenceExpression") {
        return isForLoopAfterthought(parent);
      }
      return isForStatementUpdate(node);
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow the unary operators `++` and `--`",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-plusplus"
        },
        schema: [
          {
            type: "object",
            properties: {
              allowForLoopAfterthoughts: {
                type: "boolean",
                default: false
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          unexpectedUnaryOp: "Unary operator '{{operator}}' used."
        }
      },
      create(context) {
        const config = context.options[0];
        let allowForLoopAfterthoughts = false;
        if (typeof config === "object") {
          allowForLoopAfterthoughts = config.allowForLoopAfterthoughts === true;
        }
        return {
          UpdateExpression(node) {
            if (allowForLoopAfterthoughts && isForLoopAfterthought(node)) {
              return;
            }
            context.report({
              node,
              messageId: "unexpectedUnaryOp",
              data: {
                operator: node.operator
              }
            });
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-process-env.js
var require_no_process_env = __commonJS({
  "../../node_modules/eslint/lib/rules/no-process-env.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        deprecated: true,
        replacedBy: [],
        type: "suggestion",
        docs: {
          description: "Disallow the use of `process.env`",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-process-env"
        },
        schema: [],
        messages: {
          unexpectedProcessEnv: "Unexpected use of process.env."
        }
      },
      create(context) {
        return {
          MemberExpression(node) {
            const objectName = node.object.name, propertyName = node.property.name;
            if (objectName === "process" && !node.computed && propertyName && propertyName === "env") {
              context.report({ node, messageId: "unexpectedProcessEnv" });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-process-exit.js
var require_no_process_exit = __commonJS({
  "../../node_modules/eslint/lib/rules/no-process-exit.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        deprecated: true,
        replacedBy: [],
        type: "suggestion",
        docs: {
          description: "Disallow the use of `process.exit()`",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-process-exit"
        },
        schema: [],
        messages: {
          noProcessExit: "Don't use process.exit(); throw an error instead."
        }
      },
      create(context) {
        return {
          "CallExpression > MemberExpression.callee[object.name = 'process'][property.name = 'exit']"(node) {
            context.report({ node: node.parent, messageId: "noProcessExit" });
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-promise-executor-return.js
var require_no_promise_executor_return = __commonJS({
  "../../node_modules/eslint/lib/rules/no-promise-executor-return.js"(exports, module) {
    "use strict";
    var { findVariable } = require_eslint_utils();
    var functionTypesToCheck = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "FunctionExpression"]);
    function isGlobalReference(node, scope) {
      const variable = findVariable(scope, node);
      return variable !== null && variable.scope.type === "global" && variable.defs.length === 0;
    }
    function getOuterScope(scope) {
      const upper = scope.upper;
      if (upper.type === "function-expression-name") {
        return upper.upper;
      }
      return upper;
    }
    function isPromiseExecutor(node, scope) {
      const parent = node.parent;
      return parent.type === "NewExpression" && parent.arguments[0] === node && parent.callee.type === "Identifier" && parent.callee.name === "Promise" && isGlobalReference(parent.callee, getOuterScope(scope));
    }
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow returning values from Promise executor functions",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-promise-executor-return"
        },
        schema: [],
        messages: {
          returnsValue: "Return values from promise executor functions cannot be read."
        }
      },
      create(context) {
        let funcInfo = null;
        const sourceCode = context.sourceCode;
        function report(node) {
          context.report({ node, messageId: "returnsValue" });
        }
        return {
          onCodePathStart(_, node) {
            funcInfo = {
              upper: funcInfo,
              shouldCheck: functionTypesToCheck.has(node.type) && isPromiseExecutor(node, sourceCode.getScope(node))
            };
            if (funcInfo.shouldCheck && node.type === "ArrowFunctionExpression" && node.expression) {
              report(node.body);
            }
          },
          onCodePathEnd() {
            funcInfo = funcInfo.upper;
          },
          ReturnStatement(node) {
            if (funcInfo.shouldCheck && node.argument) {
              report(node);
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-proto.js
var require_no_proto = __commonJS({
  "../../node_modules/eslint/lib/rules/no-proto.js"(exports, module) {
    "use strict";
    var { getStaticPropertyName } = require_ast_utils2();
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow the use of the `__proto__` property",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-proto"
        },
        schema: [],
        messages: {
          unexpectedProto: "The '__proto__' property is deprecated."
        }
      },
      create(context) {
        return {
          MemberExpression(node) {
            if (getStaticPropertyName(node) === "__proto__") {
              context.report({ node, messageId: "unexpectedProto" });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-prototype-builtins.js
var require_no_prototype_builtins = __commonJS({
  "../../node_modules/eslint/lib/rules/no-prototype-builtins.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow calling some `Object.prototype` methods directly on objects",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-prototype-builtins"
        },
        schema: [],
        messages: {
          prototypeBuildIn: "Do not access Object.prototype method '{{prop}}' from target object."
        }
      },
      create(context) {
        const DISALLOWED_PROPS = /* @__PURE__ */ new Set([
          "hasOwnProperty",
          "isPrototypeOf",
          "propertyIsEnumerable"
        ]);
        function disallowBuiltIns(node) {
          const callee = astUtils.skipChainExpression(node.callee);
          if (callee.type !== "MemberExpression") {
            return;
          }
          const propName = astUtils.getStaticPropertyName(callee);
          if (propName !== null && DISALLOWED_PROPS.has(propName)) {
            context.report({
              messageId: "prototypeBuildIn",
              loc: callee.property.loc,
              data: { prop: propName },
              node
            });
          }
        }
        return {
          CallExpression: disallowBuiltIns
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-redeclare.js
var require_no_redeclare = __commonJS({
  "../../node_modules/eslint/lib/rules/no-redeclare.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow variable redeclaration",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-redeclare"
        },
        messages: {
          redeclared: "'{{id}}' is already defined.",
          redeclaredAsBuiltin: "'{{id}}' is already defined as a built-in global variable.",
          redeclaredBySyntax: "'{{id}}' is already defined by a variable declaration."
        },
        schema: [
          {
            type: "object",
            properties: {
              builtinGlobals: { type: "boolean", default: true }
            },
            additionalProperties: false
          }
        ]
      },
      create(context) {
        const options = {
          builtinGlobals: Boolean(
            context.options.length === 0 || context.options[0].builtinGlobals
          )
        };
        const sourceCode = context.sourceCode;
        function* iterateDeclarations(variable) {
          if (options.builtinGlobals && (variable.eslintImplicitGlobalSetting === "readonly" || variable.eslintImplicitGlobalSetting === "writable")) {
            yield { type: "builtin" };
          }
          for (const id of variable.identifiers) {
            yield { type: "syntax", node: id, loc: id.loc };
          }
          if (variable.eslintExplicitGlobalComments) {
            for (const comment of variable.eslintExplicitGlobalComments) {
              yield {
                type: "comment",
                node: comment,
                loc: astUtils.getNameLocationInGlobalDirectiveComment(
                  sourceCode,
                  comment,
                  variable.name
                )
              };
            }
          }
        }
        function findVariablesInScope(scope) {
          for (const variable of scope.variables) {
            const [
              declaration,
              ...extraDeclarations
            ] = iterateDeclarations(variable);
            if (extraDeclarations.length === 0) {
              continue;
            }
            const detailMessageId = declaration.type === "builtin" ? "redeclaredAsBuiltin" : "redeclaredBySyntax";
            const data = { id: variable.name };
            for (const { type, node, loc } of extraDeclarations) {
              const messageId = type === declaration.type ? "redeclared" : detailMessageId;
              context.report({ node, loc, messageId, data });
            }
          }
        }
        function checkForBlock(node) {
          const scope = sourceCode.getScope(node);
          if (scope.block === node) {
            findVariablesInScope(scope);
          }
        }
        return {
          Program(node) {
            const scope = sourceCode.getScope(node);
            findVariablesInScope(scope);
            if (scope.type === "global" && scope.childScopes[0] && // The special scope's block is the Program node.
            scope.block === scope.childScopes[0].block) {
              findVariablesInScope(scope.childScopes[0]);
            }
          },
          FunctionDeclaration: checkForBlock,
          FunctionExpression: checkForBlock,
          ArrowFunctionExpression: checkForBlock,
          StaticBlock: checkForBlock,
          BlockStatement: checkForBlock,
          ForStatement: checkForBlock,
          ForInStatement: checkForBlock,
          ForOfStatement: checkForBlock,
          SwitchStatement: checkForBlock
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-regex-spaces.js
var require_no_regex_spaces = __commonJS({
  "../../node_modules/eslint/lib/rules/no-regex-spaces.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var regexpp = require_regexpp();
    var regExpParser = new regexpp.RegExpParser();
    var DOUBLE_SPACE = / {2}/u;
    function isString(node) {
      return node && node.type === "Literal" && typeof node.value === "string";
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow multiple spaces in regular expressions",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-regex-spaces"
        },
        schema: [],
        fixable: "code",
        messages: {
          multipleSpaces: "Spaces are hard to count. Use {{{length}}}."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        function checkRegex(nodeToReport, pattern, rawPattern, rawPatternStartRange, flags) {
          if (!DOUBLE_SPACE.test(rawPattern)) {
            return;
          }
          const characterClassNodes = [];
          let regExpAST;
          try {
            regExpAST = regExpParser.parsePattern(pattern, 0, pattern.length, flags.includes("u"));
          } catch {
            return;
          }
          regexpp.visitRegExpAST(regExpAST, {
            onCharacterClassEnter(ccNode) {
              characterClassNodes.push(ccNode);
            }
          });
          const spacesPattern = /( {2,})(?: [+*{?]|[^+*{?]|$)/gu;
          let match;
          while (match = spacesPattern.exec(pattern)) {
            const { 1: { length }, index } = match;
            if (characterClassNodes.every(({ start, end }) => index < start || end <= index)) {
              context.report({
                node: nodeToReport,
                messageId: "multipleSpaces",
                data: { length },
                fix(fixer) {
                  if (pattern !== rawPattern) {
                    return null;
                  }
                  return fixer.replaceTextRange(
                    [rawPatternStartRange + index, rawPatternStartRange + index + length],
                    ` {${length}}`
                  );
                }
              });
              return;
            }
          }
        }
        function checkLiteral(node) {
          if (node.regex) {
            const pattern = node.regex.pattern;
            const rawPattern = node.raw.slice(1, node.raw.lastIndexOf("/"));
            const rawPatternStartRange = node.range[0] + 1;
            const flags = node.regex.flags;
            checkRegex(
              node,
              pattern,
              rawPattern,
              rawPatternStartRange,
              flags
            );
          }
        }
        function checkFunction(node) {
          const scope = sourceCode.getScope(node);
          const regExpVar = astUtils.getVariableByName(scope, "RegExp");
          const shadowed = regExpVar && regExpVar.defs.length > 0;
          const patternNode = node.arguments[0];
          const flagsNode = node.arguments[1];
          if (node.callee.type === "Identifier" && node.callee.name === "RegExp" && isString(patternNode) && !shadowed) {
            const pattern = patternNode.value;
            const rawPattern = patternNode.raw.slice(1, -1);
            const rawPatternStartRange = patternNode.range[0] + 1;
            const flags = isString(flagsNode) ? flagsNode.value : "";
            checkRegex(
              node,
              pattern,
              rawPattern,
              rawPatternStartRange,
              flags
            );
          }
        }
        return {
          Literal: checkLiteral,
          CallExpression: checkFunction,
          NewExpression: checkFunction
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-restricted-exports.js
var require_no_restricted_exports = __commonJS({
  "../../node_modules/eslint/lib/rules/no-restricted-exports.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow specified names in exports",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-restricted-exports"
        },
        schema: [{
          anyOf: [
            {
              type: "object",
              properties: {
                restrictedNamedExports: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  uniqueItems: true
                }
              },
              additionalProperties: false
            },
            {
              type: "object",
              properties: {
                restrictedNamedExports: {
                  type: "array",
                  items: {
                    type: "string",
                    pattern: "^(?!default$)"
                  },
                  uniqueItems: true
                },
                restrictDefaultExports: {
                  type: "object",
                  properties: {
                    // Allow/Disallow `export default foo; export default 42; export default function foo() {}` format
                    direct: {
                      type: "boolean"
                    },
                    // Allow/Disallow `export { foo as default };` declarations
                    named: {
                      type: "boolean"
                    },
                    //  Allow/Disallow `export { default } from "mod"; export { default as default } from "mod";` declarations
                    defaultFrom: {
                      type: "boolean"
                    },
                    //  Allow/Disallow `export { foo as default } from "mod";` declarations
                    namedFrom: {
                      type: "boolean"
                    },
                    //  Allow/Disallow `export * as default from "mod"`; declarations
                    namespaceFrom: {
                      type: "boolean"
                    }
                  },
                  additionalProperties: false
                }
              },
              additionalProperties: false
            }
          ]
        }],
        messages: {
          restrictedNamed: "'{{name}}' is restricted from being used as an exported name.",
          restrictedDefault: "Exporting 'default' is restricted."
        }
      },
      create(context) {
        const restrictedNames = new Set(context.options[0] && context.options[0].restrictedNamedExports);
        const restrictDefaultExports = context.options[0] && context.options[0].restrictDefaultExports;
        const sourceCode = context.sourceCode;
        function checkExportedName(node) {
          const name = astUtils.getModuleExportName(node);
          if (restrictedNames.has(name)) {
            context.report({
              node,
              messageId: "restrictedNamed",
              data: { name }
            });
            return;
          }
          if (name === "default") {
            if (node.parent.type === "ExportAllDeclaration") {
              if (restrictDefaultExports && restrictDefaultExports.namespaceFrom) {
                context.report({
                  node,
                  messageId: "restrictedDefault"
                });
              }
            } else {
              const isSourceSpecified = !!node.parent.parent.source;
              const specifierLocalName = astUtils.getModuleExportName(node.parent.local);
              if (!isSourceSpecified && restrictDefaultExports && restrictDefaultExports.named) {
                context.report({
                  node,
                  messageId: "restrictedDefault"
                });
                return;
              }
              if (isSourceSpecified && restrictDefaultExports) {
                if (specifierLocalName === "default" && restrictDefaultExports.defaultFrom || specifierLocalName !== "default" && restrictDefaultExports.namedFrom) {
                  context.report({
                    node,
                    messageId: "restrictedDefault"
                  });
                }
              }
            }
          }
        }
        return {
          ExportAllDeclaration(node) {
            if (node.exported) {
              checkExportedName(node.exported);
            }
          },
          ExportDefaultDeclaration(node) {
            if (restrictDefaultExports && restrictDefaultExports.direct) {
              context.report({
                node,
                messageId: "restrictedDefault"
              });
            }
          },
          ExportNamedDeclaration(node) {
            const declaration = node.declaration;
            if (declaration) {
              if (declaration.type === "FunctionDeclaration" || declaration.type === "ClassDeclaration") {
                checkExportedName(declaration.id);
              } else if (declaration.type === "VariableDeclaration") {
                sourceCode.getDeclaredVariables(declaration).map((v) => v.defs.find((d) => d.parent === declaration)).map((d) => d.name).forEach(checkExportedName);
              }
            } else {
              node.specifiers.map((s) => s.exported).forEach(checkExportedName);
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-restricted-globals.js
var require_no_restricted_globals = __commonJS({
  "../../node_modules/eslint/lib/rules/no-restricted-globals.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow specified global variables",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-restricted-globals"
        },
        schema: {
          type: "array",
          items: {
            oneOf: [
              {
                type: "string"
              },
              {
                type: "object",
                properties: {
                  name: { type: "string" },
                  message: { type: "string" }
                },
                required: ["name"],
                additionalProperties: false
              }
            ]
          },
          uniqueItems: true,
          minItems: 0
        },
        messages: {
          defaultMessage: "Unexpected use of '{{name}}'.",
          // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
          customMessage: "Unexpected use of '{{name}}'. {{customMessage}}"
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        if (context.options.length === 0) {
          return {};
        }
        const restrictedGlobalMessages = context.options.reduce((memo, option) => {
          if (typeof option === "string") {
            memo[option] = null;
          } else {
            memo[option.name] = option.message;
          }
          return memo;
        }, {});
        function reportReference(reference) {
          const name = reference.identifier.name, customMessage = restrictedGlobalMessages[name], messageId = customMessage ? "customMessage" : "defaultMessage";
          context.report({
            node: reference.identifier,
            messageId,
            data: {
              name,
              customMessage
            }
          });
        }
        function isRestricted(name) {
          return Object.prototype.hasOwnProperty.call(restrictedGlobalMessages, name);
        }
        return {
          Program(node) {
            const scope = sourceCode.getScope(node);
            scope.variables.forEach((variable) => {
              if (!variable.defs.length && isRestricted(variable.name)) {
                variable.references.forEach(reportReference);
              }
            });
            scope.through.forEach((reference) => {
              if (isRestricted(reference.identifier.name)) {
                reportReference(reference);
              }
            });
          }
        };
      }
    };
  }
});

// ../../node_modules/ignore/index.js
var require_ignore = __commonJS({
  "../../node_modules/ignore/index.js"(exports, module) {
    function makeArray(subject) {
      return Array.isArray(subject) ? subject : [subject];
    }
    var EMPTY = "";
    var SPACE = " ";
    var ESCAPE = "\\";
    var REGEX_TEST_BLANK_LINE = /^\s+$/;
    var REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\]|^)\\$/;
    var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
    var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
    var REGEX_SPLITALL_CRLF = /\r?\n/g;
    var REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;
    var SLASH = "/";
    var TMP_KEY_IGNORE = "node-ignore";
    if (typeof Symbol !== "undefined") {
      TMP_KEY_IGNORE = Symbol.for("node-ignore");
    }
    var KEY_IGNORE = TMP_KEY_IGNORE;
    var define2 = (object, key, value) => Object.defineProperty(object, key, { value });
    var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
    var RETURN_FALSE = () => false;
    var sanitizeRange = (range) => range.replace(
      REGEX_REGEXP_RANGE,
      (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY
    );
    var cleanRangeBackSlash = (slashes) => {
      const { length } = slashes;
      return slashes.slice(0, length - length % 2);
    };
    var REPLACERS = [
      // > Trailing spaces are ignored unless they are quoted with backslash ("\")
      [
        // (a\ ) -> (a )
        // (a  ) -> (a)
        // (a \ ) -> (a  )
        /\\?\s+$/,
        (match) => match.indexOf("\\") === 0 ? SPACE : EMPTY
      ],
      // replace (\ ) with ' '
      [
        /\\\s/g,
        () => SPACE
      ],
      // Escape metacharacters
      // which is written down by users but means special for regular expressions.
      // > There are 12 characters with special meanings:
      // > - the backslash \,
      // > - the caret ^,
      // > - the dollar sign $,
      // > - the period or dot .,
      // > - the vertical bar or pipe symbol |,
      // > - the question mark ?,
      // > - the asterisk or star *,
      // > - the plus sign +,
      // > - the opening parenthesis (,
      // > - the closing parenthesis ),
      // > - and the opening square bracket [,
      // > - the opening curly brace {,
      // > These special characters are often called "metacharacters".
      [
        /[\\$.|*+(){^]/g,
        (match) => `\\${match}`
      ],
      [
        // > a question mark (?) matches a single character
        /(?!\\)\?/g,
        () => "[^/]"
      ],
      // leading slash
      [
        // > A leading slash matches the beginning of the pathname.
        // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
        // A leading slash matches the beginning of the pathname
        /^\//,
        () => "^"
      ],
      // replace special metacharacter slash after the leading slash
      [
        /\//g,
        () => "\\/"
      ],
      [
        // > A leading "**" followed by a slash means match in all directories.
        // > For example, "**/foo" matches file or directory "foo" anywhere,
        // > the same as pattern "foo".
        // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
        // >   under directory "foo".
        // Notice that the '*'s have been replaced as '\\*'
        /^\^*\\\*\\\*\\\//,
        // '**/foo' <-> 'foo'
        () => "^(?:.*\\/)?"
      ],
      // starting
      [
        // there will be no leading '/'
        //   (which has been replaced by section "leading slash")
        // If starts with '**', adding a '^' to the regular expression also works
        /^(?=[^^])/,
        function startingReplacer() {
          return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
        }
      ],
      // two globstars
      [
        // Use lookahead assertions so that we could match more than one `'/**'`
        /\\\/\\\*\\\*(?=\\\/|$)/g,
        // Zero, one or several directories
        // should not use '*', or it will be replaced by the next replacer
        // Check if it is not the last `'/**'`
        (_, index, str) => index + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
      ],
      // normal intermediate wildcards
      [
        // Never replace escaped '*'
        // ignore rule '\*' will match the path '*'
        // 'abc.*/' -> go
        // 'abc.*'  -> skip this rule,
        //    coz trailing single wildcard will be handed by [trailing wildcard]
        /(^|[^\\]+)(\\\*)+(?=.+)/g,
        // '*.js' matches '.js'
        // '*.js' doesn't match 'abc'
        (_, p1, p2) => {
          const unescaped = p2.replace(/\\\*/g, "[^\\/]*");
          return p1 + unescaped;
        }
      ],
      [
        // unescape, revert step 3 except for back slash
        // For example, if a user escape a '\\*',
        // after step 3, the result will be '\\\\\\*'
        /\\\\\\(?=[$.|*+(){^])/g,
        () => ESCAPE
      ],
      [
        // '\\\\' -> '\\'
        /\\\\/g,
        () => ESCAPE
      ],
      [
        // > The range notation, e.g. [a-zA-Z],
        // > can be used to match one of the characters in a range.
        // `\` is escaped by step 3
        /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
        (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === "]" ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : "[]" : "[]"
      ],
      // ending
      [
        // 'js' will not match 'js.'
        // 'ab' will not match 'abc'
        /(?:[^*])$/,
        // WTF!
        // https://git-scm.com/docs/gitignore
        // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
        // which re-fixes #24, #38
        // > If there is a separator at the end of the pattern then the pattern
        // > will only match directories, otherwise the pattern can match both
        // > files and directories.
        // 'js*' will not match 'a.js'
        // 'js/' will not match 'a.js'
        // 'js' will match 'a.js' and 'a.js/'
        (match) => /\/$/.test(match) ? `${match}$` : `${match}(?=$|\\/$)`
      ],
      // trailing wildcard
      [
        /(\^|\\\/)?\\\*$/,
        (_, p1) => {
          const prefix = p1 ? `${p1}[^/]+` : "[^/]*";
          return `${prefix}(?=$|\\/$)`;
        }
      ]
    ];
    var regexCache = /* @__PURE__ */ Object.create(null);
    var makeRegex = (pattern, ignoreCase) => {
      let source = regexCache[pattern];
      if (!source) {
        source = REPLACERS.reduce(
          (prev, current) => prev.replace(current[0], current[1].bind(pattern)),
          pattern
        );
        regexCache[pattern] = source;
      }
      return ignoreCase ? new RegExp(source, "i") : new RegExp(source);
    };
    var isString = (subject) => typeof subject === "string";
    var checkPattern = (pattern) => pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern) && pattern.indexOf("#") !== 0;
    var splitPattern = (pattern) => pattern.split(REGEX_SPLITALL_CRLF);
    var IgnoreRule = class {
      constructor(origin, pattern, negative, regex) {
        this.origin = origin;
        this.pattern = pattern;
        this.negative = negative;
        this.regex = regex;
      }
    };
    var createRule = (pattern, ignoreCase) => {
      const origin = pattern;
      let negative = false;
      if (pattern.indexOf("!") === 0) {
        negative = true;
        pattern = pattern.substr(1);
      }
      pattern = pattern.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
      const regex = makeRegex(pattern, ignoreCase);
      return new IgnoreRule(
        origin,
        pattern,
        negative,
        regex
      );
    };
    var throwError = (message, Ctor) => {
      throw new Ctor(message);
    };
    var checkPath = (path, originalPath, doThrow) => {
      if (!isString(path)) {
        return doThrow(
          `path must be a string, but got \`${originalPath}\``,
          TypeError
        );
      }
      if (!path) {
        return doThrow(`path must not be empty`, TypeError);
      }
      if (checkPath.isNotRelative(path)) {
        const r = "`path.relative()`d";
        return doThrow(
          `path should be a ${r} string, but got "${originalPath}"`,
          RangeError
        );
      }
      return true;
    };
    var isNotRelative = (path) => REGEX_TEST_INVALID_PATH.test(path);
    checkPath.isNotRelative = isNotRelative;
    checkPath.convert = (p) => p;
    var Ignore = class {
      constructor({
        ignorecase = true,
        ignoreCase = ignorecase,
        allowRelativePaths = false
      } = {}) {
        define2(this, KEY_IGNORE, true);
        this._rules = [];
        this._ignoreCase = ignoreCase;
        this._allowRelativePaths = allowRelativePaths;
        this._initCache();
      }
      _initCache() {
        this._ignoreCache = /* @__PURE__ */ Object.create(null);
        this._testCache = /* @__PURE__ */ Object.create(null);
      }
      _addPattern(pattern) {
        if (pattern && pattern[KEY_IGNORE]) {
          this._rules = this._rules.concat(pattern._rules);
          this._added = true;
          return;
        }
        if (checkPattern(pattern)) {
          const rule = createRule(pattern, this._ignoreCase);
          this._added = true;
          this._rules.push(rule);
        }
      }
      // @param {Array<string> | string | Ignore} pattern
      add(pattern) {
        this._added = false;
        makeArray(
          isString(pattern) ? splitPattern(pattern) : pattern
        ).forEach(this._addPattern, this);
        if (this._added) {
          this._initCache();
        }
        return this;
      }
      // legacy
      addPattern(pattern) {
        return this.add(pattern);
      }
      //          |           ignored : unignored
      // negative |   0:0   |   0:1   |   1:0   |   1:1
      // -------- | ------- | ------- | ------- | --------
      //     0    |  TEST   |  TEST   |  SKIP   |    X
      //     1    |  TESTIF |  SKIP   |  TEST   |    X
      // - SKIP: always skip
      // - TEST: always test
      // - TESTIF: only test if checkUnignored
      // - X: that never happen
      // @param {boolean} whether should check if the path is unignored,
      //   setting `checkUnignored` to `false` could reduce additional
      //   path matching.
      // @returns {TestResult} true if a file is ignored
      _testOne(path, checkUnignored) {
        let ignored = false;
        let unignored = false;
        this._rules.forEach((rule) => {
          const { negative } = rule;
          if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
            return;
          }
          const matched = rule.regex.test(path);
          if (matched) {
            ignored = !negative;
            unignored = negative;
          }
        });
        return {
          ignored,
          unignored
        };
      }
      // @returns {TestResult}
      _test(originalPath, cache, checkUnignored, slices) {
        const path = originalPath && checkPath.convert(originalPath);
        checkPath(
          path,
          originalPath,
          this._allowRelativePaths ? RETURN_FALSE : throwError
        );
        return this._t(path, cache, checkUnignored, slices);
      }
      _t(path, cache, checkUnignored, slices) {
        if (path in cache) {
          return cache[path];
        }
        if (!slices) {
          slices = path.split(SLASH);
        }
        slices.pop();
        if (!slices.length) {
          return cache[path] = this._testOne(path, checkUnignored);
        }
        const parent = this._t(
          slices.join(SLASH) + SLASH,
          cache,
          checkUnignored,
          slices
        );
        return cache[path] = parent.ignored ? parent : this._testOne(path, checkUnignored);
      }
      ignores(path) {
        return this._test(path, this._ignoreCache, false).ignored;
      }
      createFilter() {
        return (path) => !this.ignores(path);
      }
      filter(paths) {
        return makeArray(paths).filter(this.createFilter());
      }
      // @returns {TestResult}
      test(path) {
        return this._test(path, this._testCache, true);
      }
    };
    var factory = (options) => new Ignore(options);
    var isPathValid = (path) => checkPath(path && checkPath.convert(path), path, RETURN_FALSE);
    factory.isPathValid = isPathValid;
    factory.default = factory;
    module.exports = factory;
    if (
      // Detect `process` so that it can run in browsers.
      typeof process !== "undefined" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")
    ) {
      const makePosix = (str) => /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, "/");
      checkPath.convert = makePosix;
      const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
      checkPath.isNotRelative = (path) => REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path) || isNotRelative(path);
    }
  }
});

// ../../node_modules/eslint/lib/rules/no-restricted-imports.js
var require_no_restricted_imports = __commonJS({
  "../../node_modules/eslint/lib/rules/no-restricted-imports.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var ignore = require_ignore();
    var arrayOfStringsOrObjects = {
      type: "array",
      items: {
        anyOf: [
          { type: "string" },
          {
            type: "object",
            properties: {
              name: { type: "string" },
              message: {
                type: "string",
                minLength: 1
              },
              importNames: {
                type: "array",
                items: {
                  type: "string"
                }
              }
            },
            additionalProperties: false,
            required: ["name"]
          }
        ]
      },
      uniqueItems: true
    };
    var arrayOfStringsOrObjectPatterns = {
      anyOf: [
        {
          type: "array",
          items: {
            type: "string"
          },
          uniqueItems: true
        },
        {
          type: "array",
          items: {
            type: "object",
            properties: {
              importNames: {
                type: "array",
                items: {
                  type: "string"
                },
                minItems: 1,
                uniqueItems: true
              },
              group: {
                type: "array",
                items: {
                  type: "string"
                },
                minItems: 1,
                uniqueItems: true
              },
              message: {
                type: "string",
                minLength: 1
              },
              caseSensitive: {
                type: "boolean"
              }
            },
            additionalProperties: false,
            required: ["group"]
          },
          uniqueItems: true
        }
      ]
    };
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow specified modules when loaded by `import`",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-restricted-imports"
        },
        messages: {
          path: "'{{importSource}}' import is restricted from being used.",
          // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
          pathWithCustomMessage: "'{{importSource}}' import is restricted from being used. {{customMessage}}",
          patterns: "'{{importSource}}' import is restricted from being used by a pattern.",
          // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
          patternWithCustomMessage: "'{{importSource}}' import is restricted from being used by a pattern. {{customMessage}}",
          patternAndImportName: "'{{importName}}' import from '{{importSource}}' is restricted from being used by a pattern.",
          // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
          patternAndImportNameWithCustomMessage: "'{{importName}}' import from '{{importSource}}' is restricted from being used by a pattern. {{customMessage}}",
          patternAndEverything: "* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted from being used by a pattern.",
          // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
          patternAndEverythingWithCustomMessage: "* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted from being used by a pattern. {{customMessage}}",
          everything: "* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted.",
          // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
          everythingWithCustomMessage: "* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted. {{customMessage}}",
          importName: "'{{importName}}' import from '{{importSource}}' is restricted.",
          // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
          importNameWithCustomMessage: "'{{importName}}' import from '{{importSource}}' is restricted. {{customMessage}}"
        },
        schema: {
          anyOf: [
            arrayOfStringsOrObjects,
            {
              type: "array",
              items: [{
                type: "object",
                properties: {
                  paths: arrayOfStringsOrObjects,
                  patterns: arrayOfStringsOrObjectPatterns
                },
                additionalProperties: false
              }],
              additionalItems: false
            }
          ]
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        const options = Array.isArray(context.options) ? context.options : [];
        const isPathAndPatternsObject = typeof options[0] === "object" && (Object.prototype.hasOwnProperty.call(options[0], "paths") || Object.prototype.hasOwnProperty.call(options[0], "patterns"));
        const restrictedPaths = (isPathAndPatternsObject ? options[0].paths : context.options) || [];
        const restrictedPathMessages = restrictedPaths.reduce((memo, importSource) => {
          if (typeof importSource === "string") {
            memo[importSource] = { message: null };
          } else {
            memo[importSource.name] = {
              message: importSource.message,
              importNames: importSource.importNames
            };
          }
          return memo;
        }, {});
        let restrictedPatterns = (isPathAndPatternsObject ? options[0].patterns : []) || [];
        if (restrictedPatterns.length > 0 && typeof restrictedPatterns[0] === "string") {
          restrictedPatterns = [{ group: restrictedPatterns }];
        }
        const restrictedPatternGroups = restrictedPatterns.map(({ group, message, caseSensitive, importNames }) => ({
          matcher: ignore({ allowRelativePaths: true, ignorecase: !caseSensitive }).add(group),
          customMessage: message,
          importNames
        }));
        if (Object.keys(restrictedPaths).length === 0 && restrictedPatternGroups.length === 0) {
          return {};
        }
        function checkRestrictedPathAndReport(importSource, importNames, node) {
          if (!Object.prototype.hasOwnProperty.call(restrictedPathMessages, importSource)) {
            return;
          }
          const customMessage = restrictedPathMessages[importSource].message;
          const restrictedImportNames = restrictedPathMessages[importSource].importNames;
          if (restrictedImportNames) {
            if (importNames.has("*")) {
              const specifierData = importNames.get("*")[0];
              context.report({
                node,
                messageId: customMessage ? "everythingWithCustomMessage" : "everything",
                loc: specifierData.loc,
                data: {
                  importSource,
                  importNames: restrictedImportNames,
                  customMessage
                }
              });
            }
            restrictedImportNames.forEach((importName) => {
              if (importNames.has(importName)) {
                const specifiers = importNames.get(importName);
                specifiers.forEach((specifier) => {
                  context.report({
                    node,
                    messageId: customMessage ? "importNameWithCustomMessage" : "importName",
                    loc: specifier.loc,
                    data: {
                      importSource,
                      customMessage,
                      importName
                    }
                  });
                });
              }
            });
          } else {
            context.report({
              node,
              messageId: customMessage ? "pathWithCustomMessage" : "path",
              data: {
                importSource,
                customMessage
              }
            });
          }
        }
        function reportPathForPatterns(node, group, importNames) {
          const importSource = node.source.value.trim();
          const customMessage = group.customMessage;
          const restrictedImportNames = group.importNames;
          if (!restrictedImportNames) {
            context.report({
              node,
              messageId: customMessage ? "patternWithCustomMessage" : "patterns",
              data: {
                importSource,
                customMessage
              }
            });
            return;
          }
          if (importNames.has("*")) {
            const specifierData = importNames.get("*")[0];
            context.report({
              node,
              messageId: customMessage ? "patternAndEverythingWithCustomMessage" : "patternAndEverything",
              loc: specifierData.loc,
              data: {
                importSource,
                importNames: restrictedImportNames,
                customMessage
              }
            });
          }
          restrictedImportNames.forEach((importName) => {
            if (!importNames.has(importName)) {
              return;
            }
            const specifiers = importNames.get(importName);
            specifiers.forEach((specifier) => {
              context.report({
                node,
                messageId: customMessage ? "patternAndImportNameWithCustomMessage" : "patternAndImportName",
                loc: specifier.loc,
                data: {
                  importSource,
                  customMessage,
                  importName
                }
              });
            });
          });
        }
        function isRestrictedPattern(importSource, group) {
          return group.matcher.ignores(importSource);
        }
        function checkNode(node) {
          const importSource = node.source.value.trim();
          const importNames = /* @__PURE__ */ new Map();
          if (node.type === "ExportAllDeclaration") {
            const starToken = sourceCode.getFirstToken(node, 1);
            importNames.set("*", [{ loc: starToken.loc }]);
          } else if (node.specifiers) {
            for (const specifier of node.specifiers) {
              let name;
              const specifierData = { loc: specifier.loc };
              if (specifier.type === "ImportDefaultSpecifier") {
                name = "default";
              } else if (specifier.type === "ImportNamespaceSpecifier") {
                name = "*";
              } else if (specifier.imported) {
                name = astUtils.getModuleExportName(specifier.imported);
              } else if (specifier.local) {
                name = astUtils.getModuleExportName(specifier.local);
              }
              if (typeof name === "string") {
                if (importNames.has(name)) {
                  importNames.get(name).push(specifierData);
                } else {
                  importNames.set(name, [specifierData]);
                }
              }
            }
          }
          checkRestrictedPathAndReport(importSource, importNames, node);
          restrictedPatternGroups.forEach((group) => {
            if (isRestrictedPattern(importSource, group)) {
              reportPathForPatterns(node, group, importNames);
            }
          });
        }
        return {
          ImportDeclaration: checkNode,
          ExportNamedDeclaration(node) {
            if (node.source) {
              checkNode(node);
            }
          },
          ExportAllDeclaration: checkNode
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-restricted-modules.js
var require_no_restricted_modules = __commonJS({
  "../../node_modules/eslint/lib/rules/no-restricted-modules.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var ignore = require_ignore();
    var arrayOfStrings = {
      type: "array",
      items: { type: "string" },
      uniqueItems: true
    };
    var arrayOfStringsOrObjects = {
      type: "array",
      items: {
        anyOf: [
          { type: "string" },
          {
            type: "object",
            properties: {
              name: { type: "string" },
              message: {
                type: "string",
                minLength: 1
              }
            },
            additionalProperties: false,
            required: ["name"]
          }
        ]
      },
      uniqueItems: true
    };
    module.exports = {
      meta: {
        deprecated: true,
        replacedBy: [],
        type: "suggestion",
        docs: {
          description: "Disallow specified modules when loaded by `require`",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-restricted-modules"
        },
        schema: {
          anyOf: [
            arrayOfStringsOrObjects,
            {
              type: "array",
              items: {
                type: "object",
                properties: {
                  paths: arrayOfStringsOrObjects,
                  patterns: arrayOfStrings
                },
                additionalProperties: false
              },
              additionalItems: false
            }
          ]
        },
        messages: {
          defaultMessage: "'{{name}}' module is restricted from being used.",
          // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
          customMessage: "'{{name}}' module is restricted from being used. {{customMessage}}",
          patternMessage: "'{{name}}' module is restricted from being used by a pattern."
        }
      },
      create(context) {
        const options = Array.isArray(context.options) ? context.options : [];
        const isPathAndPatternsObject = typeof options[0] === "object" && (Object.prototype.hasOwnProperty.call(options[0], "paths") || Object.prototype.hasOwnProperty.call(options[0], "patterns"));
        const restrictedPaths = (isPathAndPatternsObject ? options[0].paths : context.options) || [];
        const restrictedPatterns = (isPathAndPatternsObject ? options[0].patterns : []) || [];
        const restrictedPathMessages = restrictedPaths.reduce((memo, importName) => {
          if (typeof importName === "string") {
            memo[importName] = null;
          } else {
            memo[importName.name] = importName.message;
          }
          return memo;
        }, {});
        if (Object.keys(restrictedPaths).length === 0 && restrictedPatterns.length === 0) {
          return {};
        }
        const ig = ignore({ allowRelativePaths: true }).add(restrictedPatterns);
        function isStringLiteral(node) {
          return node && node.type === "Literal" && typeof node.value === "string";
        }
        function isRequireCall(node) {
          return node.callee.type === "Identifier" && node.callee.name === "require";
        }
        function getFirstArgumentString(node) {
          if (isStringLiteral(node)) {
            return node.value.trim();
          }
          if (astUtils.isStaticTemplateLiteral(node)) {
            return node.quasis[0].value.cooked.trim();
          }
          return null;
        }
        function reportPath(node, name) {
          const customMessage = restrictedPathMessages[name];
          const messageId = customMessage ? "customMessage" : "defaultMessage";
          context.report({
            node,
            messageId,
            data: {
              name,
              customMessage
            }
          });
        }
        function isRestrictedPath(name) {
          return Object.prototype.hasOwnProperty.call(restrictedPathMessages, name);
        }
        return {
          CallExpression(node) {
            if (isRequireCall(node)) {
              if (node.arguments.length) {
                const name = getFirstArgumentString(node.arguments[0]);
                if (name) {
                  if (isRestrictedPath(name)) {
                    reportPath(node, name);
                  }
                  if (restrictedPatterns.length > 0 && ig.ignores(name)) {
                    context.report({
                      node,
                      messageId: "patternMessage",
                      data: { name }
                    });
                  }
                }
              }
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-restricted-properties.js
var require_no_restricted_properties = __commonJS({
  "../../node_modules/eslint/lib/rules/no-restricted-properties.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow certain properties on certain objects",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-restricted-properties"
        },
        schema: {
          type: "array",
          items: {
            anyOf: [
              // `object` and `property` are both optional, but at least one of them must be provided.
              {
                type: "object",
                properties: {
                  object: {
                    type: "string"
                  },
                  property: {
                    type: "string"
                  },
                  message: {
                    type: "string"
                  }
                },
                additionalProperties: false,
                required: ["object"]
              },
              {
                type: "object",
                properties: {
                  object: {
                    type: "string"
                  },
                  property: {
                    type: "string"
                  },
                  message: {
                    type: "string"
                  }
                },
                additionalProperties: false,
                required: ["property"]
              }
            ]
          },
          uniqueItems: true
        },
        messages: {
          // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
          restrictedObjectProperty: "'{{objectName}}.{{propertyName}}' is restricted from being used.{{message}}",
          // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
          restrictedProperty: "'{{propertyName}}' is restricted from being used.{{message}}"
        }
      },
      create(context) {
        const restrictedCalls = context.options;
        if (restrictedCalls.length === 0) {
          return {};
        }
        const restrictedProperties = /* @__PURE__ */ new Map();
        const globallyRestrictedObjects = /* @__PURE__ */ new Map();
        const globallyRestrictedProperties = /* @__PURE__ */ new Map();
        restrictedCalls.forEach((option) => {
          const objectName = option.object;
          const propertyName = option.property;
          if (typeof objectName === "undefined") {
            globallyRestrictedProperties.set(propertyName, { message: option.message });
          } else if (typeof propertyName === "undefined") {
            globallyRestrictedObjects.set(objectName, { message: option.message });
          } else {
            if (!restrictedProperties.has(objectName)) {
              restrictedProperties.set(objectName, /* @__PURE__ */ new Map());
            }
            restrictedProperties.get(objectName).set(propertyName, {
              message: option.message
            });
          }
        });
        function checkPropertyAccess(node, objectName, propertyName) {
          if (propertyName === null) {
            return;
          }
          const matchedObject = restrictedProperties.get(objectName);
          const matchedObjectProperty = matchedObject ? matchedObject.get(propertyName) : globallyRestrictedObjects.get(objectName);
          const globalMatchedProperty = globallyRestrictedProperties.get(propertyName);
          if (matchedObjectProperty) {
            const message = matchedObjectProperty.message ? ` ${matchedObjectProperty.message}` : "";
            context.report({
              node,
              messageId: "restrictedObjectProperty",
              data: {
                objectName,
                propertyName,
                message
              }
            });
          } else if (globalMatchedProperty) {
            const message = globalMatchedProperty.message ? ` ${globalMatchedProperty.message}` : "";
            context.report({
              node,
              messageId: "restrictedProperty",
              data: {
                propertyName,
                message
              }
            });
          }
        }
        function checkDestructuringAssignment(node) {
          if (node.right.type === "Identifier") {
            const objectName = node.right.name;
            if (node.left.type === "ObjectPattern") {
              node.left.properties.forEach((property) => {
                checkPropertyAccess(node.left, objectName, astUtils.getStaticPropertyName(property));
              });
            }
          }
        }
        return {
          MemberExpression(node) {
            checkPropertyAccess(node, node.object && node.object.name, astUtils.getStaticPropertyName(node));
          },
          VariableDeclarator(node) {
            if (node.init && node.init.type === "Identifier") {
              const objectName = node.init.name;
              if (node.id.type === "ObjectPattern") {
                node.id.properties.forEach((property) => {
                  checkPropertyAccess(node.id, objectName, astUtils.getStaticPropertyName(property));
                });
              }
            }
          },
          AssignmentExpression: checkDestructuringAssignment,
          AssignmentPattern: checkDestructuringAssignment
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-restricted-syntax.js
var require_no_restricted_syntax = __commonJS({
  "../../node_modules/eslint/lib/rules/no-restricted-syntax.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow specified syntax",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-restricted-syntax"
        },
        schema: {
          type: "array",
          items: {
            oneOf: [
              {
                type: "string"
              },
              {
                type: "object",
                properties: {
                  selector: { type: "string" },
                  message: { type: "string" }
                },
                required: ["selector"],
                additionalProperties: false
              }
            ]
          },
          uniqueItems: true,
          minItems: 0
        },
        messages: {
          // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
          restrictedSyntax: "{{message}}"
        }
      },
      create(context) {
        return context.options.reduce((result, selectorOrObject) => {
          const isStringFormat = typeof selectorOrObject === "string";
          const hasCustomMessage = !isStringFormat && Boolean(selectorOrObject.message);
          const selector = isStringFormat ? selectorOrObject : selectorOrObject.selector;
          const message = hasCustomMessage ? selectorOrObject.message : `Using '${selector}' is not allowed.`;
          return Object.assign(result, {
            [selector](node) {
              context.report({
                node,
                messageId: "restrictedSyntax",
                data: { message }
              });
            }
          });
        }, {});
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-return-assign.js
var require_no_return_assign = __commonJS({
  "../../node_modules/eslint/lib/rules/no-return-assign.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var SENTINEL_TYPE = /^(?:[a-zA-Z]+?Statement|ArrowFunctionExpression|FunctionExpression|ClassExpression)$/u;
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow assignment operators in `return` statements",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-return-assign"
        },
        schema: [
          {
            enum: ["except-parens", "always"]
          }
        ],
        messages: {
          returnAssignment: "Return statement should not contain assignment.",
          arrowAssignment: "Arrow function should not return assignment."
        }
      },
      create(context) {
        const always = (context.options[0] || "except-parens") !== "except-parens";
        const sourceCode = context.sourceCode;
        return {
          AssignmentExpression(node) {
            if (!always && astUtils.isParenthesised(sourceCode, node)) {
              return;
            }
            let currentChild = node;
            let parent = currentChild.parent;
            while (parent && !SENTINEL_TYPE.test(parent.type)) {
              currentChild = parent;
              parent = parent.parent;
            }
            if (parent && parent.type === "ReturnStatement") {
              context.report({
                node: parent,
                messageId: "returnAssignment"
              });
            } else if (parent && parent.type === "ArrowFunctionExpression" && parent.body === currentChild) {
              context.report({
                node: parent,
                messageId: "arrowAssignment"
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-return-await.js
var require_no_return_await = __commonJS({
  "../../node_modules/eslint/lib/rules/no-return-await.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        hasSuggestions: true,
        type: "suggestion",
        docs: {
          description: "Disallow unnecessary `return await`",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-return-await"
        },
        fixable: null,
        schema: [],
        messages: {
          removeAwait: "Remove redundant `await`.",
          redundantUseOfAwait: "Redundant use of `await` on a return value."
        }
      },
      create(context) {
        function reportUnnecessaryAwait(node) {
          context.report({
            node: context.sourceCode.getFirstToken(node),
            loc: node.loc,
            messageId: "redundantUseOfAwait",
            suggest: [
              {
                messageId: "removeAwait",
                fix(fixer) {
                  const sourceCode = context.sourceCode;
                  const [awaitToken, tokenAfterAwait] = sourceCode.getFirstTokens(node, 2);
                  const areAwaitAndAwaitedExpressionOnTheSameLine = awaitToken.loc.start.line === tokenAfterAwait.loc.start.line;
                  if (!areAwaitAndAwaitedExpressionOnTheSameLine) {
                    return null;
                  }
                  const [startOfAwait, endOfAwait] = awaitToken.range;
                  const characterAfterAwait = sourceCode.text[endOfAwait];
                  const trimLength = characterAfterAwait === " " ? 1 : 0;
                  const range = [startOfAwait, endOfAwait + trimLength];
                  return fixer.removeRange(range);
                }
              }
            ]
          });
        }
        function hasErrorHandler(node) {
          let ancestor = node;
          while (!astUtils.isFunction(ancestor) && ancestor.type !== "Program") {
            if (ancestor.parent.type === "TryStatement" && (ancestor === ancestor.parent.block || ancestor === ancestor.parent.handler && ancestor.parent.finalizer)) {
              return true;
            }
            ancestor = ancestor.parent;
          }
          return false;
        }
        function isInTailCallPosition(node) {
          if (node.parent.type === "ArrowFunctionExpression") {
            return true;
          }
          if (node.parent.type === "ReturnStatement") {
            return !hasErrorHandler(node.parent);
          }
          if (node.parent.type === "ConditionalExpression" && (node === node.parent.consequent || node === node.parent.alternate)) {
            return isInTailCallPosition(node.parent);
          }
          if (node.parent.type === "LogicalExpression" && node === node.parent.right) {
            return isInTailCallPosition(node.parent);
          }
          if (node.parent.type === "SequenceExpression" && node === node.parent.expressions[node.parent.expressions.length - 1]) {
            return isInTailCallPosition(node.parent);
          }
          return false;
        }
        return {
          AwaitExpression(node) {
            if (isInTailCallPosition(node) && !hasErrorHandler(node)) {
              reportUnnecessaryAwait(node);
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-script-url.js
var require_no_script_url = __commonJS({
  "../../node_modules/eslint/lib/rules/no-script-url.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow `javascript:` urls",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-script-url"
        },
        schema: [],
        messages: {
          unexpectedScriptURL: "Script URL is a form of eval."
        }
      },
      create(context) {
        function check(node) {
          const value = astUtils.getStaticStringValue(node);
          if (typeof value === "string" && value.toLowerCase().indexOf("javascript:") === 0) {
            context.report({ node, messageId: "unexpectedScriptURL" });
          }
        }
        return {
          Literal(node) {
            if (node.value && typeof node.value === "string") {
              check(node);
            }
          },
          TemplateLiteral(node) {
            if (!(node.parent && node.parent.type === "TaggedTemplateExpression")) {
              check(node);
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-self-assign.js
var require_no_self_assign = __commonJS({
  "../../node_modules/eslint/lib/rules/no-self-assign.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var SPACES = /\s+/gu;
    function eachSelfAssignment(left, right, props, report) {
      if (!left || !right) {
      } else if (left.type === "Identifier" && right.type === "Identifier" && left.name === right.name) {
        report(right);
      } else if (left.type === "ArrayPattern" && right.type === "ArrayExpression") {
        const end = Math.min(left.elements.length, right.elements.length);
        for (let i = 0; i < end; ++i) {
          const leftElement = left.elements[i];
          const rightElement = right.elements[i];
          if (leftElement && leftElement.type === "RestElement" && i < right.elements.length - 1) {
            break;
          }
          eachSelfAssignment(leftElement, rightElement, props, report);
          if (rightElement && rightElement.type === "SpreadElement") {
            break;
          }
        }
      } else if (left.type === "RestElement" && right.type === "SpreadElement") {
        eachSelfAssignment(left.argument, right.argument, props, report);
      } else if (left.type === "ObjectPattern" && right.type === "ObjectExpression" && right.properties.length >= 1) {
        let startJ = 0;
        for (let i = right.properties.length - 1; i >= 0; --i) {
          const propType = right.properties[i].type;
          if (propType === "SpreadElement" || propType === "ExperimentalSpreadProperty") {
            startJ = i + 1;
            break;
          }
        }
        for (let i = 0; i < left.properties.length; ++i) {
          for (let j = startJ; j < right.properties.length; ++j) {
            eachSelfAssignment(
              left.properties[i],
              right.properties[j],
              props,
              report
            );
          }
        }
      } else if (left.type === "Property" && right.type === "Property" && right.kind === "init" && !right.method) {
        const leftName = astUtils.getStaticPropertyName(left);
        if (leftName !== null && leftName === astUtils.getStaticPropertyName(right)) {
          eachSelfAssignment(left.value, right.value, props, report);
        }
      } else if (props && astUtils.skipChainExpression(left).type === "MemberExpression" && astUtils.skipChainExpression(right).type === "MemberExpression" && astUtils.isSameReference(left, right)) {
        report(right);
      }
    }
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow assignments where both sides are exactly the same",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-self-assign"
        },
        schema: [
          {
            type: "object",
            properties: {
              props: {
                type: "boolean",
                default: true
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          selfAssignment: "'{{name}}' is assigned to itself."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        const [{ props = true } = {}] = context.options;
        function report(node) {
          context.report({
            node,
            messageId: "selfAssignment",
            data: {
              name: sourceCode.getText(node).replace(SPACES, "")
            }
          });
        }
        return {
          AssignmentExpression(node) {
            if (["=", "&&=", "||=", "??="].includes(node.operator)) {
              eachSelfAssignment(node.left, node.right, props, report);
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-self-compare.js
var require_no_self_compare = __commonJS({
  "../../node_modules/eslint/lib/rules/no-self-compare.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow comparisons where both sides are exactly the same",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-self-compare"
        },
        schema: [],
        messages: {
          comparingToSelf: "Comparing to itself is potentially pointless."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        function hasSameTokens(nodeA, nodeB) {
          const tokensA = sourceCode.getTokens(nodeA);
          const tokensB = sourceCode.getTokens(nodeB);
          return tokensA.length === tokensB.length && tokensA.every((token, index) => token.type === tokensB[index].type && token.value === tokensB[index].value);
        }
        return {
          BinaryExpression(node) {
            const operators = /* @__PURE__ */ new Set(["===", "==", "!==", "!=", ">", "<", ">=", "<="]);
            if (operators.has(node.operator) && hasSameTokens(node.left, node.right)) {
              context.report({ node, messageId: "comparingToSelf" });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-sequences.js
var require_no_sequences = __commonJS({
  "../../node_modules/eslint/lib/rules/no-sequences.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var DEFAULT_OPTIONS = {
      allowInParentheses: true
    };
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow comma operators",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-sequences"
        },
        schema: [{
          properties: {
            allowInParentheses: {
              type: "boolean",
              default: true
            }
          },
          additionalProperties: false
        }],
        messages: {
          unexpectedCommaExpression: "Unexpected use of comma operator."
        }
      },
      create(context) {
        const options = Object.assign({}, DEFAULT_OPTIONS, context.options[0]);
        const sourceCode = context.sourceCode;
        const parenthesized = {
          DoWhileStatement: "test",
          IfStatement: "test",
          SwitchStatement: "discriminant",
          WhileStatement: "test",
          WithStatement: "object",
          ArrowFunctionExpression: "body"
          /*
           * Omitting CallExpression - commas are parsed as argument separators
           * Omitting NewExpression - commas are parsed as argument separators
           * Omitting ForInStatement - parts aren't individually parenthesised
           * Omitting ForStatement - parts aren't individually parenthesised
           */
        };
        function requiresExtraParens(node) {
          return node.parent && parenthesized[node.parent.type] && node === node.parent[parenthesized[node.parent.type]];
        }
        function isParenthesised(node) {
          return astUtils.isParenthesised(sourceCode, node);
        }
        function isParenthesisedTwice(node) {
          const previousToken = sourceCode.getTokenBefore(node, 1), nextToken = sourceCode.getTokenAfter(node, 1);
          return isParenthesised(node) && previousToken && nextToken && astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] && astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];
        }
        return {
          SequenceExpression(node) {
            if (node.parent.type === "ForStatement" && (node === node.parent.init || node === node.parent.update)) {
              return;
            }
            if (options.allowInParentheses) {
              if (requiresExtraParens(node)) {
                if (isParenthesisedTwice(node)) {
                  return;
                }
              } else {
                if (isParenthesised(node)) {
                  return;
                }
              }
            }
            const firstCommaToken = sourceCode.getTokenAfter(node.expressions[0], astUtils.isCommaToken);
            context.report({ node, loc: firstCommaToken.loc, messageId: "unexpectedCommaExpression" });
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-setter-return.js
var require_no_setter_return = __commonJS({
  "../../node_modules/eslint/lib/rules/no-setter-return.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var { findVariable } = require_eslint_utils();
    function isGlobalReference(node, scope) {
      const variable = findVariable(scope, node);
      return variable !== null && variable.scope.type === "global" && variable.defs.length === 0;
    }
    function isArgumentOfGlobalMethodCall(node, scope, objectName, methodName, index) {
      const callNode = node.parent;
      return callNode.type === "CallExpression" && callNode.arguments[index] === node && astUtils.isSpecificMemberAccess(callNode.callee, objectName, methodName) && isGlobalReference(astUtils.skipChainExpression(callNode.callee).object, scope);
    }
    function isPropertyDescriptor(node, scope) {
      if (isArgumentOfGlobalMethodCall(node, scope, "Object", "defineProperty", 2) || isArgumentOfGlobalMethodCall(node, scope, "Reflect", "defineProperty", 2)) {
        return true;
      }
      const parent = node.parent;
      if (parent.type === "Property" && parent.value === node) {
        const grandparent = parent.parent;
        if (grandparent.type === "ObjectExpression" && (isArgumentOfGlobalMethodCall(grandparent, scope, "Object", "create", 1) || isArgumentOfGlobalMethodCall(grandparent, scope, "Object", "defineProperties", 1))) {
          return true;
        }
      }
      return false;
    }
    function isSetter(node, scope) {
      const parent = node.parent;
      if ((parent.type === "Property" || parent.type === "MethodDefinition") && parent.kind === "set" && parent.value === node) {
        return true;
      }
      if (parent.type === "Property" && parent.value === node && astUtils.getStaticPropertyName(parent) === "set" && parent.parent.type === "ObjectExpression" && isPropertyDescriptor(parent.parent, scope)) {
        return true;
      }
      return false;
    }
    function getOuterScope(scope) {
      const upper = scope.upper;
      if (upper.type === "function-expression-name") {
        return upper.upper;
      }
      return upper;
    }
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow returning values from setters",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-setter-return"
        },
        schema: [],
        messages: {
          returnsValue: "Setter cannot return a value."
        }
      },
      create(context) {
        let funcInfo = null;
        const sourceCode = context.sourceCode;
        function enterFunction(node) {
          const outerScope = getOuterScope(sourceCode.getScope(node));
          funcInfo = {
            upper: funcInfo,
            isSetter: isSetter(node, outerScope)
          };
        }
        function exitFunction() {
          funcInfo = funcInfo.upper;
        }
        function report(node) {
          context.report({ node, messageId: "returnsValue" });
        }
        return {
          /*
           * Function declarations cannot be setters, but we still have to track them in the `funcInfo` stack to avoid
           * false positives, because a ReturnStatement node can belong to a function declaration inside a setter.
           *
           * Note: A previously declared function can be referenced and actually used as a setter in a property descriptor,
           * but that's out of scope for this rule.
           */
          FunctionDeclaration: enterFunction,
          FunctionExpression: enterFunction,
          ArrowFunctionExpression(node) {
            enterFunction(node);
            if (funcInfo.isSetter && node.expression) {
              report(node.body);
            }
          },
          "FunctionDeclaration:exit": exitFunction,
          "FunctionExpression:exit": exitFunction,
          "ArrowFunctionExpression:exit": exitFunction,
          ReturnStatement(node) {
            if (funcInfo && funcInfo.isSetter && node.argument) {
              report(node);
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-shadow.js
var require_no_shadow = __commonJS({
  "../../node_modules/eslint/lib/rules/no-shadow.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var FUNC_EXPR_NODE_TYPES = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "FunctionExpression"]);
    var CALL_EXPR_NODE_TYPE = /* @__PURE__ */ new Set(["CallExpression"]);
    var FOR_IN_OF_TYPE = /^For(?:In|Of)Statement$/u;
    var SENTINEL_TYPE = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/u;
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow variable declarations from shadowing variables declared in the outer scope",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-shadow"
        },
        schema: [
          {
            type: "object",
            properties: {
              builtinGlobals: { type: "boolean", default: false },
              hoist: { enum: ["all", "functions", "never"], default: "functions" },
              allow: {
                type: "array",
                items: {
                  type: "string"
                }
              },
              ignoreOnInitialization: { type: "boolean", default: false }
            },
            additionalProperties: false
          }
        ],
        messages: {
          noShadow: "'{{name}}' is already declared in the upper scope on line {{shadowedLine}} column {{shadowedColumn}}.",
          noShadowGlobal: "'{{name}}' is already a global variable."
        }
      },
      create(context) {
        const options = {
          builtinGlobals: context.options[0] && context.options[0].builtinGlobals,
          hoist: context.options[0] && context.options[0].hoist || "functions",
          allow: context.options[0] && context.options[0].allow || [],
          ignoreOnInitialization: context.options[0] && context.options[0].ignoreOnInitialization
        };
        const sourceCode = context.sourceCode;
        function isInRange(node, location) {
          return node && node.range[0] <= location && location <= node.range[1];
        }
        function findSelfOrAncestor(node, match) {
          let currentNode = node;
          while (currentNode && !match(currentNode)) {
            currentNode = currentNode.parent;
          }
          return currentNode;
        }
        function getOuterScope(scope) {
          const upper = scope.upper;
          if (upper.type === "function-expression-name") {
            return upper.upper;
          }
          return upper;
        }
        function isInitPatternNode(variable, shadowedVariable) {
          const outerDef = shadowedVariable.defs[0];
          if (!outerDef) {
            return false;
          }
          const { variableScope } = variable.scope;
          if (!(FUNC_EXPR_NODE_TYPES.has(variableScope.block.type) && getOuterScope(variableScope) === shadowedVariable.scope)) {
            return false;
          }
          const fun = variableScope.block;
          const { parent } = fun;
          const callExpression = findSelfOrAncestor(
            parent,
            (node2) => CALL_EXPR_NODE_TYPE.has(node2.type)
          );
          if (!callExpression) {
            return false;
          }
          let node = outerDef.name;
          const location = callExpression.range[1];
          while (node) {
            if (node.type === "VariableDeclarator") {
              if (isInRange(node.init, location)) {
                return true;
              }
              if (FOR_IN_OF_TYPE.test(node.parent.parent.type) && isInRange(node.parent.parent.right, location)) {
                return true;
              }
              break;
            } else if (node.type === "AssignmentPattern") {
              if (isInRange(node.right, location)) {
                return true;
              }
            } else if (SENTINEL_TYPE.test(node.type)) {
              break;
            }
            node = node.parent;
          }
          return false;
        }
        function isAllowed(variable) {
          return options.allow.includes(variable.name);
        }
        function isDuplicatedClassNameVariable(variable) {
          const block = variable.scope.block;
          return block.type === "ClassDeclaration" && block.id === variable.identifiers[0];
        }
        function isOnInitializer(variable, scopeVar) {
          const outerScope = scopeVar.scope;
          const outerDef = scopeVar.defs[0];
          const outer = outerDef && outerDef.parent && outerDef.parent.range;
          const innerScope = variable.scope;
          const innerDef = variable.defs[0];
          const inner = innerDef && innerDef.name.range;
          return outer && inner && outer[0] < inner[0] && inner[1] < outer[1] && (innerDef.type === "FunctionName" && innerDef.node.type === "FunctionExpression" || innerDef.node.type === "ClassExpression") && outerScope === innerScope.upper;
        }
        function getNameRange(variable) {
          const def = variable.defs[0];
          return def && def.name.range;
        }
        function getDeclaredLocation(variable) {
          const identifier = variable.identifiers[0];
          let obj;
          if (identifier) {
            obj = {
              global: false,
              line: identifier.loc.start.line,
              column: identifier.loc.start.column + 1
            };
          } else {
            obj = {
              global: true
            };
          }
          return obj;
        }
        function isInTdz(variable, scopeVar) {
          const outerDef = scopeVar.defs[0];
          const inner = getNameRange(variable);
          const outer = getNameRange(scopeVar);
          return inner && outer && inner[1] < outer[0] && // Excepts FunctionDeclaration if is {"hoist":"function"}.
          (options.hoist !== "functions" || !outerDef || outerDef.node.type !== "FunctionDeclaration");
        }
        function checkForShadows(scope) {
          const variables = scope.variables;
          for (let i = 0; i < variables.length; ++i) {
            const variable = variables[i];
            if (variable.identifiers.length === 0 || isDuplicatedClassNameVariable(variable) || isAllowed(variable)) {
              continue;
            }
            const shadowed = astUtils.getVariableByName(scope.upper, variable.name);
            if (shadowed && (shadowed.identifiers.length > 0 || options.builtinGlobals && "writeable" in shadowed) && !isOnInitializer(variable, shadowed) && !(options.ignoreOnInitialization && isInitPatternNode(variable, shadowed)) && !(options.hoist !== "all" && isInTdz(variable, shadowed))) {
              const location = getDeclaredLocation(shadowed);
              const messageId = location.global ? "noShadowGlobal" : "noShadow";
              const data = { name: variable.name };
              if (!location.global) {
                data.shadowedLine = location.line;
                data.shadowedColumn = location.column;
              }
              context.report({
                node: variable.identifiers[0],
                messageId,
                data
              });
            }
          }
        }
        return {
          "Program:exit"(node) {
            const globalScope = sourceCode.getScope(node);
            const stack = globalScope.childScopes.slice();
            while (stack.length) {
              const scope = stack.pop();
              stack.push(...scope.childScopes);
              checkForShadows(scope);
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-shadow-restricted-names.js
var require_no_shadow_restricted_names = __commonJS({
  "../../node_modules/eslint/lib/rules/no-shadow-restricted-names.js"(exports, module) {
    "use strict";
    function safelyShadowsUndefined(variable) {
      return variable.name === "undefined" && variable.references.every((ref) => !ref.isWrite()) && variable.defs.every((def) => def.node.type === "VariableDeclarator" && def.node.init === null);
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow identifiers from shadowing restricted names",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-shadow-restricted-names"
        },
        schema: [],
        messages: {
          shadowingRestrictedName: "Shadowing of global property '{{name}}'."
        }
      },
      create(context) {
        const RESTRICTED = /* @__PURE__ */ new Set(["undefined", "NaN", "Infinity", "arguments", "eval"]);
        const sourceCode = context.sourceCode;
        return {
          "VariableDeclaration, :function, CatchClause"(node) {
            for (const variable of sourceCode.getDeclaredVariables(node)) {
              if (variable.defs.length > 0 && RESTRICTED.has(variable.name) && !safelyShadowsUndefined(variable)) {
                context.report({
                  node: variable.defs[0].name,
                  messageId: "shadowingRestrictedName",
                  data: {
                    name: variable.name
                  }
                });
              }
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-spaced-func.js
var require_no_spaced_func = __commonJS({
  "../../node_modules/eslint/lib/rules/no-spaced-func.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Disallow spacing between function identifiers and their applications (deprecated)",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-spaced-func"
        },
        deprecated: true,
        replacedBy: ["func-call-spacing"],
        fixable: "whitespace",
        schema: [],
        messages: {
          noSpacedFunction: "Unexpected space between function name and paren."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        function detectOpenSpaces(node) {
          const lastCalleeToken = sourceCode.getLastToken(node.callee);
          let prevToken = lastCalleeToken, parenToken = sourceCode.getTokenAfter(lastCalleeToken);
          while (parenToken && parenToken.range[1] < node.range[1] && parenToken.value !== "(") {
            prevToken = parenToken;
            parenToken = sourceCode.getTokenAfter(parenToken);
          }
          if (parenToken && parenToken.range[1] < node.range[1] && sourceCode.isSpaceBetweenTokens(prevToken, parenToken)) {
            context.report({
              node,
              loc: lastCalleeToken.loc.start,
              messageId: "noSpacedFunction",
              fix(fixer) {
                return fixer.removeRange([prevToken.range[1], parenToken.range[0]]);
              }
            });
          }
        }
        return {
          CallExpression: detectOpenSpaces,
          NewExpression: detectOpenSpaces
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-sparse-arrays.js
var require_no_sparse_arrays = __commonJS({
  "../../node_modules/eslint/lib/rules/no-sparse-arrays.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow sparse arrays",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-sparse-arrays"
        },
        schema: [],
        messages: {
          unexpectedSparseArray: "Unexpected comma in middle of array."
        }
      },
      create(context) {
        return {
          ArrayExpression(node) {
            const emptySpot = node.elements.includes(null);
            if (emptySpot) {
              context.report({ node, messageId: "unexpectedSparseArray" });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-sync.js
var require_no_sync = __commonJS({
  "../../node_modules/eslint/lib/rules/no-sync.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        deprecated: true,
        replacedBy: [],
        type: "suggestion",
        docs: {
          description: "Disallow synchronous methods",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-sync"
        },
        schema: [
          {
            type: "object",
            properties: {
              allowAtRootLevel: {
                type: "boolean",
                default: false
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          noSync: "Unexpected sync method: '{{propertyName}}'."
        }
      },
      create(context) {
        const selector = context.options[0] && context.options[0].allowAtRootLevel ? ":function MemberExpression[property.name=/.*Sync$/]" : "MemberExpression[property.name=/.*Sync$/]";
        return {
          [selector](node) {
            context.report({
              node,
              messageId: "noSync",
              data: {
                propertyName: node.property.name
              }
            });
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-tabs.js
var require_no_tabs = __commonJS({
  "../../node_modules/eslint/lib/rules/no-tabs.js"(exports, module) {
    "use strict";
    var tabRegex = /\t+/gu;
    var anyNonWhitespaceRegex = /\S/u;
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Disallow all tabs",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-tabs"
        },
        schema: [{
          type: "object",
          properties: {
            allowIndentationTabs: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }],
        messages: {
          unexpectedTab: "Unexpected tab character."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        const allowIndentationTabs = context.options && context.options[0] && context.options[0].allowIndentationTabs;
        return {
          Program(node) {
            sourceCode.getLines().forEach((line, index) => {
              let match;
              while ((match = tabRegex.exec(line)) !== null) {
                if (allowIndentationTabs && !anyNonWhitespaceRegex.test(line.slice(0, match.index))) {
                  continue;
                }
                context.report({
                  node,
                  loc: {
                    start: {
                      line: index + 1,
                      column: match.index
                    },
                    end: {
                      line: index + 1,
                      column: match.index + match[0].length
                    }
                  },
                  messageId: "unexpectedTab"
                });
              }
            });
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-template-curly-in-string.js
var require_no_template_curly_in_string = __commonJS({
  "../../node_modules/eslint/lib/rules/no-template-curly-in-string.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow template literal placeholder syntax in regular strings",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-template-curly-in-string"
        },
        schema: [],
        messages: {
          unexpectedTemplateExpression: "Unexpected template string expression."
        }
      },
      create(context) {
        const regex = /\$\{[^}]+\}/u;
        return {
          Literal(node) {
            if (typeof node.value === "string" && regex.test(node.value)) {
              context.report({
                node,
                messageId: "unexpectedTemplateExpression"
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-ternary.js
var require_no_ternary = __commonJS({
  "../../node_modules/eslint/lib/rules/no-ternary.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow ternary operators",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-ternary"
        },
        schema: [],
        messages: {
          noTernaryOperator: "Ternary operator used."
        }
      },
      create(context) {
        return {
          ConditionalExpression(node) {
            context.report({ node, messageId: "noTernaryOperator" });
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-this-before-super.js
var require_no_this_before_super = __commonJS({
  "../../node_modules/eslint/lib/rules/no-this-before-super.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    function isConstructorFunction(node) {
      return node.type === "FunctionExpression" && node.parent.type === "MethodDefinition" && node.parent.kind === "constructor";
    }
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow `this`/`super` before calling `super()` in constructors",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-this-before-super"
        },
        schema: [],
        messages: {
          noBeforeSuper: "'{{kind}}' is not allowed before 'super()'."
        }
      },
      create(context) {
        let funcInfo = null;
        let segInfoMap = /* @__PURE__ */ Object.create(null);
        function isCalled(segment) {
          return !segment.reachable || segInfoMap[segment.id].superCalled;
        }
        function isInConstructorOfDerivedClass() {
          return Boolean(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends);
        }
        function isBeforeCallOfSuper() {
          return isInConstructorOfDerivedClass() && !funcInfo.codePath.currentSegments.every(isCalled);
        }
        function setInvalid(node) {
          const segments = funcInfo.codePath.currentSegments;
          for (let i = 0; i < segments.length; ++i) {
            const segment = segments[i];
            if (segment.reachable) {
              segInfoMap[segment.id].invalidNodes.push(node);
            }
          }
        }
        function setSuperCalled() {
          const segments = funcInfo.codePath.currentSegments;
          for (let i = 0; i < segments.length; ++i) {
            const segment = segments[i];
            if (segment.reachable) {
              segInfoMap[segment.id].superCalled = true;
            }
          }
        }
        return {
          /**
           * Adds information of a constructor into the stack.
           * @param {CodePath} codePath A code path which was started.
           * @param {ASTNode} node The current node.
           * @returns {void}
           */
          onCodePathStart(codePath, node) {
            if (isConstructorFunction(node)) {
              const classNode = node.parent.parent.parent;
              funcInfo = {
                upper: funcInfo,
                isConstructor: true,
                hasExtends: Boolean(
                  classNode.superClass && !astUtils.isNullOrUndefined(classNode.superClass)
                ),
                codePath
              };
            } else {
              funcInfo = {
                upper: funcInfo,
                isConstructor: false,
                hasExtends: false,
                codePath
              };
            }
          },
          /**
           * Removes the top of stack item.
           *
           * And this traverses all segments of this code path then reports every
           * invalid node.
           * @param {CodePath} codePath A code path which was ended.
           * @returns {void}
           */
          onCodePathEnd(codePath) {
            const isDerivedClass = funcInfo.hasExtends;
            funcInfo = funcInfo.upper;
            if (!isDerivedClass) {
              return;
            }
            codePath.traverseSegments((segment, controller) => {
              const info = segInfoMap[segment.id];
              for (let i = 0; i < info.invalidNodes.length; ++i) {
                const invalidNode = info.invalidNodes[i];
                context.report({
                  messageId: "noBeforeSuper",
                  node: invalidNode,
                  data: {
                    kind: invalidNode.type === "Super" ? "super" : "this"
                  }
                });
              }
              if (info.superCalled) {
                controller.skip();
              }
            });
          },
          /**
           * Initialize information of a given code path segment.
           * @param {CodePathSegment} segment A code path segment to initialize.
           * @returns {void}
           */
          onCodePathSegmentStart(segment) {
            if (!isInConstructorOfDerivedClass()) {
              return;
            }
            segInfoMap[segment.id] = {
              superCalled: segment.prevSegments.length > 0 && segment.prevSegments.every(isCalled),
              invalidNodes: []
            };
          },
          /**
           * Update information of the code path segment when a code path was
           * looped.
           * @param {CodePathSegment} fromSegment The code path segment of the
           *      end of a loop.
           * @param {CodePathSegment} toSegment A code path segment of the head
           *      of a loop.
           * @returns {void}
           */
          onCodePathSegmentLoop(fromSegment, toSegment) {
            if (!isInConstructorOfDerivedClass()) {
              return;
            }
            funcInfo.codePath.traverseSegments(
              { first: toSegment, last: fromSegment },
              (segment, controller) => {
                const info = segInfoMap[segment.id];
                if (info.superCalled) {
                  info.invalidNodes = [];
                  controller.skip();
                } else if (segment.prevSegments.length > 0 && segment.prevSegments.every(isCalled)) {
                  info.superCalled = true;
                  info.invalidNodes = [];
                }
              }
            );
          },
          /**
           * Reports if this is before `super()`.
           * @param {ASTNode} node A target node.
           * @returns {void}
           */
          ThisExpression(node) {
            if (isBeforeCallOfSuper()) {
              setInvalid(node);
            }
          },
          /**
           * Reports if this is before `super()`.
           * @param {ASTNode} node A target node.
           * @returns {void}
           */
          Super(node) {
            if (!astUtils.isCallee(node) && isBeforeCallOfSuper()) {
              setInvalid(node);
            }
          },
          /**
           * Marks `super()` called.
           * @param {ASTNode} node A target node.
           * @returns {void}
           */
          "CallExpression:exit"(node) {
            if (node.callee.type === "Super" && isBeforeCallOfSuper()) {
              setSuperCalled();
            }
          },
          /**
           * Resets state.
           * @returns {void}
           */
          "Program:exit"() {
            segInfoMap = /* @__PURE__ */ Object.create(null);
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-throw-literal.js
var require_no_throw_literal = __commonJS({
  "../../node_modules/eslint/lib/rules/no-throw-literal.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow throwing literals as exceptions",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-throw-literal"
        },
        schema: [],
        messages: {
          object: "Expected an error object to be thrown.",
          undef: "Do not throw undefined."
        }
      },
      create(context) {
        return {
          ThrowStatement(node) {
            if (!astUtils.couldBeError(node.argument)) {
              context.report({ node, messageId: "object" });
            } else if (node.argument.type === "Identifier") {
              if (node.argument.name === "undefined") {
                context.report({ node, messageId: "undef" });
              }
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-trailing-spaces.js
var require_no_trailing_spaces = __commonJS({
  "../../node_modules/eslint/lib/rules/no-trailing-spaces.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Disallow trailing whitespace at the end of lines",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-trailing-spaces"
        },
        fixable: "whitespace",
        schema: [
          {
            type: "object",
            properties: {
              skipBlankLines: {
                type: "boolean",
                default: false
              },
              ignoreComments: {
                type: "boolean",
                default: false
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          trailingSpace: "Trailing spaces not allowed."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        const BLANK_CLASS = "[ 	\xA0\u2000-\u200B\u3000]", SKIP_BLANK = `^${BLANK_CLASS}*$`, NONBLANK = `${BLANK_CLASS}+$`;
        const options = context.options[0] || {}, skipBlankLines = options.skipBlankLines || false, ignoreComments = options.ignoreComments || false;
        function report(node, location, fixRange) {
          context.report({
            node,
            loc: location,
            messageId: "trailingSpace",
            fix(fixer) {
              return fixer.removeRange(fixRange);
            }
          });
        }
        function getCommentLineNumbers(comments) {
          const lines = /* @__PURE__ */ new Set();
          comments.forEach((comment) => {
            const endLine = comment.type === "Block" ? comment.loc.end.line - 1 : comment.loc.end.line;
            for (let i = comment.loc.start.line; i <= endLine; i++) {
              lines.add(i);
            }
          });
          return lines;
        }
        return {
          Program: function checkTrailingSpaces(node) {
            const re = new RegExp(NONBLANK, "u"), skipMatch = new RegExp(SKIP_BLANK, "u"), lines = sourceCode.lines, linebreaks = sourceCode.getText().match(astUtils.createGlobalLinebreakMatcher()), comments = sourceCode.getAllComments(), commentLineNumbers = getCommentLineNumbers(comments);
            let totalLength = 0, fixRange = [];
            for (let i = 0, ii = lines.length; i < ii; i++) {
              const lineNumber = i + 1;
              const linebreakLength = linebreaks && linebreaks[i] ? linebreaks[i].length : 1;
              const lineLength = lines[i].length + linebreakLength;
              const matches = re.exec(lines[i]);
              if (matches) {
                const location = {
                  start: {
                    line: lineNumber,
                    column: matches.index
                  },
                  end: {
                    line: lineNumber,
                    column: lineLength - linebreakLength
                  }
                };
                const rangeStart = totalLength + location.start.column;
                const rangeEnd = totalLength + location.end.column;
                const containingNode = sourceCode.getNodeByRangeIndex(rangeStart);
                if (containingNode && containingNode.type === "TemplateElement" && rangeStart > containingNode.parent.range[0] && rangeEnd < containingNode.parent.range[1]) {
                  totalLength += lineLength;
                  continue;
                }
                if (skipBlankLines && skipMatch.test(lines[i])) {
                  totalLength += lineLength;
                  continue;
                }
                fixRange = [rangeStart, rangeEnd];
                if (!ignoreComments || !commentLineNumbers.has(lineNumber)) {
                  report(node, location, fixRange);
                }
              }
              totalLength += lineLength;
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-undef.js
var require_no_undef = __commonJS({
  "../../node_modules/eslint/lib/rules/no-undef.js"(exports, module) {
    "use strict";
    function hasTypeOfOperator(node) {
      const parent = node.parent;
      return parent.type === "UnaryExpression" && parent.operator === "typeof";
    }
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow the use of undeclared variables unless mentioned in `/*global */` comments",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-undef"
        },
        schema: [
          {
            type: "object",
            properties: {
              typeof: {
                type: "boolean",
                default: false
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          undef: "'{{name}}' is not defined."
        }
      },
      create(context) {
        const options = context.options[0];
        const considerTypeOf = options && options.typeof === true || false;
        const sourceCode = context.sourceCode;
        return {
          "Program:exit"(node) {
            const globalScope = sourceCode.getScope(node);
            globalScope.through.forEach((ref) => {
              const identifier = ref.identifier;
              if (!considerTypeOf && hasTypeOfOperator(identifier)) {
                return;
              }
              context.report({
                node: identifier,
                messageId: "undef",
                data: identifier
              });
            });
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-undef-init.js
var require_no_undef_init = __commonJS({
  "../../node_modules/eslint/lib/rules/no-undef-init.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow initializing variables to `undefined`",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-undef-init"
        },
        schema: [],
        fixable: "code",
        messages: {
          unnecessaryUndefinedInit: "It's not necessary to initialize '{{name}}' to undefined."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        return {
          VariableDeclarator(node) {
            const name = sourceCode.getText(node.id), init = node.init && node.init.name, scope = sourceCode.getScope(node), undefinedVar = astUtils.getVariableByName(scope, "undefined"), shadowed = undefinedVar && undefinedVar.defs.length > 0, lastToken = sourceCode.getLastToken(node);
            if (init === "undefined" && node.parent.kind !== "const" && !shadowed) {
              context.report({
                node,
                messageId: "unnecessaryUndefinedInit",
                data: { name },
                fix(fixer) {
                  if (node.parent.kind === "var") {
                    return null;
                  }
                  if (node.id.type === "ArrayPattern" || node.id.type === "ObjectPattern") {
                    return null;
                  }
                  if (sourceCode.commentsExistBetween(node.id, lastToken)) {
                    return null;
                  }
                  return fixer.removeRange([node.id.range[1], node.range[1]]);
                }
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-undefined.js
var require_no_undefined = __commonJS({
  "../../node_modules/eslint/lib/rules/no-undefined.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow the use of `undefined` as an identifier",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-undefined"
        },
        schema: [],
        messages: {
          unexpectedUndefined: "Unexpected use of undefined."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        function report(node) {
          context.report({
            node,
            messageId: "unexpectedUndefined"
          });
        }
        function checkScope(scope) {
          const undefinedVar = scope.set.get("undefined");
          if (!undefinedVar) {
            return;
          }
          const references = undefinedVar.references;
          const defs = undefinedVar.defs;
          references.filter((ref) => !ref.init).forEach((ref) => report(ref.identifier));
          defs.forEach((def) => report(def.name));
        }
        return {
          "Program:exit"(node) {
            const globalScope = sourceCode.getScope(node);
            const stack = [globalScope];
            while (stack.length) {
              const scope = stack.pop();
              stack.push(...scope.childScopes);
              checkScope(scope);
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-underscore-dangle.js
var require_no_underscore_dangle = __commonJS({
  "../../node_modules/eslint/lib/rules/no-underscore-dangle.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow dangling underscores in identifiers",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-underscore-dangle"
        },
        schema: [
          {
            type: "object",
            properties: {
              allow: {
                type: "array",
                items: {
                  type: "string"
                }
              },
              allowAfterThis: {
                type: "boolean",
                default: false
              },
              allowAfterSuper: {
                type: "boolean",
                default: false
              },
              allowAfterThisConstructor: {
                type: "boolean",
                default: false
              },
              enforceInMethodNames: {
                type: "boolean",
                default: false
              },
              allowFunctionParams: {
                type: "boolean",
                default: true
              },
              enforceInClassFields: {
                type: "boolean",
                default: false
              },
              allowInArrayDestructuring: {
                type: "boolean",
                default: true
              },
              allowInObjectDestructuring: {
                type: "boolean",
                default: true
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          unexpectedUnderscore: "Unexpected dangling '_' in '{{identifier}}'."
        }
      },
      create(context) {
        const options = context.options[0] || {};
        const ALLOWED_VARIABLES = options.allow ? options.allow : [];
        const allowAfterThis = typeof options.allowAfterThis !== "undefined" ? options.allowAfterThis : false;
        const allowAfterSuper = typeof options.allowAfterSuper !== "undefined" ? options.allowAfterSuper : false;
        const allowAfterThisConstructor = typeof options.allowAfterThisConstructor !== "undefined" ? options.allowAfterThisConstructor : false;
        const enforceInMethodNames = typeof options.enforceInMethodNames !== "undefined" ? options.enforceInMethodNames : false;
        const enforceInClassFields = typeof options.enforceInClassFields !== "undefined" ? options.enforceInClassFields : false;
        const allowFunctionParams = typeof options.allowFunctionParams !== "undefined" ? options.allowFunctionParams : true;
        const allowInArrayDestructuring = typeof options.allowInArrayDestructuring !== "undefined" ? options.allowInArrayDestructuring : true;
        const allowInObjectDestructuring = typeof options.allowInObjectDestructuring !== "undefined" ? options.allowInObjectDestructuring : true;
        const sourceCode = context.sourceCode;
        function isAllowed(identifier) {
          return ALLOWED_VARIABLES.includes(identifier);
        }
        function hasDanglingUnderscore(identifier) {
          const len = identifier.length;
          return identifier !== "_" && (identifier[0] === "_" || identifier[len - 1] === "_");
        }
        function isSpecialCaseIdentifierForMemberExpression(identifier) {
          return identifier === "__proto__";
        }
        function isSpecialCaseIdentifierInVariableExpression(identifier) {
          return identifier === "_";
        }
        function isThisConstructorReference(node) {
          return node.object.type === "MemberExpression" && node.object.property.name === "constructor" && node.object.object.type === "ThisExpression";
        }
        function checkForDanglingUnderscoreInFunctionParameters(node) {
          if (!allowFunctionParams) {
            node.params.forEach((param) => {
              const { type } = param;
              let nodeToCheck;
              if (type === "RestElement") {
                nodeToCheck = param.argument;
              } else if (type === "AssignmentPattern") {
                nodeToCheck = param.left;
              } else {
                nodeToCheck = param;
              }
              if (nodeToCheck.type === "Identifier") {
                const identifier = nodeToCheck.name;
                if (hasDanglingUnderscore(identifier) && !isAllowed(identifier)) {
                  context.report({
                    node: param,
                    messageId: "unexpectedUnderscore",
                    data: {
                      identifier
                    }
                  });
                }
              }
            });
          }
        }
        function checkForDanglingUnderscoreInFunction(node) {
          if (node.type === "FunctionDeclaration" && node.id) {
            const identifier = node.id.name;
            if (typeof identifier !== "undefined" && hasDanglingUnderscore(identifier) && !isAllowed(identifier)) {
              context.report({
                node,
                messageId: "unexpectedUnderscore",
                data: {
                  identifier
                }
              });
            }
          }
          checkForDanglingUnderscoreInFunctionParameters(node);
        }
        function checkForDanglingUnderscoreInVariableExpression(node) {
          sourceCode.getDeclaredVariables(node).forEach((variable) => {
            const definition = variable.defs.find((def) => def.node === node);
            const identifierNode = definition.name;
            const identifier = identifierNode.name;
            let parent = identifierNode.parent;
            while (!["VariableDeclarator", "ArrayPattern", "ObjectPattern"].includes(parent.type)) {
              parent = parent.parent;
            }
            if (hasDanglingUnderscore(identifier) && !isSpecialCaseIdentifierInVariableExpression(identifier) && !isAllowed(identifier) && !(allowInArrayDestructuring && parent.type === "ArrayPattern") && !(allowInObjectDestructuring && parent.type === "ObjectPattern")) {
              context.report({
                node,
                messageId: "unexpectedUnderscore",
                data: {
                  identifier
                }
              });
            }
          });
        }
        function checkForDanglingUnderscoreInMemberExpression(node) {
          const identifier = node.property.name, isMemberOfThis = node.object.type === "ThisExpression", isMemberOfSuper = node.object.type === "Super", isMemberOfThisConstructor = isThisConstructorReference(node);
          if (typeof identifier !== "undefined" && hasDanglingUnderscore(identifier) && !(isMemberOfThis && allowAfterThis) && !(isMemberOfSuper && allowAfterSuper) && !(isMemberOfThisConstructor && allowAfterThisConstructor) && !isSpecialCaseIdentifierForMemberExpression(identifier) && !isAllowed(identifier)) {
            context.report({
              node,
              messageId: "unexpectedUnderscore",
              data: {
                identifier
              }
            });
          }
        }
        function checkForDanglingUnderscoreInMethod(node) {
          const identifier = node.key.name;
          const isMethod = node.type === "MethodDefinition" || node.type === "Property" && node.method;
          if (typeof identifier !== "undefined" && enforceInMethodNames && isMethod && hasDanglingUnderscore(identifier) && !isAllowed(identifier)) {
            context.report({
              node,
              messageId: "unexpectedUnderscore",
              data: {
                identifier: node.key.type === "PrivateIdentifier" ? `#${identifier}` : identifier
              }
            });
          }
        }
        function checkForDanglingUnderscoreInClassField(node) {
          const identifier = node.key.name;
          if (typeof identifier !== "undefined" && hasDanglingUnderscore(identifier) && enforceInClassFields && !isAllowed(identifier)) {
            context.report({
              node,
              messageId: "unexpectedUnderscore",
              data: {
                identifier: node.key.type === "PrivateIdentifier" ? `#${identifier}` : identifier
              }
            });
          }
        }
        return {
          FunctionDeclaration: checkForDanglingUnderscoreInFunction,
          VariableDeclarator: checkForDanglingUnderscoreInVariableExpression,
          MemberExpression: checkForDanglingUnderscoreInMemberExpression,
          MethodDefinition: checkForDanglingUnderscoreInMethod,
          PropertyDefinition: checkForDanglingUnderscoreInClassField,
          Property: checkForDanglingUnderscoreInMethod,
          FunctionExpression: checkForDanglingUnderscoreInFunction,
          ArrowFunctionExpression: checkForDanglingUnderscoreInFunction
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-unexpected-multiline.js
var require_no_unexpected_multiline = __commonJS({
  "../../node_modules/eslint/lib/rules/no-unexpected-multiline.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow confusing multiline expressions",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-unexpected-multiline"
        },
        schema: [],
        messages: {
          function: "Unexpected newline between function and ( of function call.",
          property: "Unexpected newline between object and [ of property access.",
          taggedTemplate: "Unexpected newline between template tag and template literal.",
          division: "Unexpected newline between numerator and division operator."
        }
      },
      create(context) {
        const REGEX_FLAG_MATCHER = /^[gimsuy]+$/u;
        const sourceCode = context.sourceCode;
        function checkForBreakAfter(node, messageId) {
          const openParen = sourceCode.getTokenAfter(node, astUtils.isNotClosingParenToken);
          const nodeExpressionEnd = sourceCode.getTokenBefore(openParen);
          if (openParen.loc.start.line !== nodeExpressionEnd.loc.end.line) {
            context.report({
              node,
              loc: openParen.loc,
              messageId
            });
          }
        }
        return {
          MemberExpression(node) {
            if (!node.computed || node.optional) {
              return;
            }
            checkForBreakAfter(node.object, "property");
          },
          TaggedTemplateExpression(node) {
            const { quasi } = node;
            const tokenBefore = sourceCode.getTokenBefore(quasi);
            if (tokenBefore.loc.end.line !== quasi.loc.start.line) {
              context.report({
                node,
                loc: {
                  start: quasi.loc.start,
                  end: {
                    line: quasi.loc.start.line,
                    column: quasi.loc.start.column + 1
                  }
                },
                messageId: "taggedTemplate"
              });
            }
          },
          CallExpression(node) {
            if (node.arguments.length === 0 || node.optional) {
              return;
            }
            checkForBreakAfter(node.callee, "function");
          },
          "BinaryExpression[operator='/'] > BinaryExpression[operator='/'].left"(node) {
            const secondSlash = sourceCode.getTokenAfter(node, (token) => token.value === "/");
            const tokenAfterOperator = sourceCode.getTokenAfter(secondSlash);
            if (tokenAfterOperator.type === "Identifier" && REGEX_FLAG_MATCHER.test(tokenAfterOperator.value) && secondSlash.range[1] === tokenAfterOperator.range[0]) {
              checkForBreakAfter(node.left, "division");
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-unmodified-loop-condition.js
var require_no_unmodified_loop_condition = __commonJS({
  "../../node_modules/eslint/lib/rules/no-unmodified-loop-condition.js"(exports, module) {
    "use strict";
    var Traverser = require_traverser();
    var astUtils = require_ast_utils2();
    var SENTINEL_PATTERN = /(?:(?:Call|Class|Function|Member|New|Yield)Expression|Statement|Declaration)$/u;
    var LOOP_PATTERN = /^(?:DoWhile|For|While)Statement$/u;
    var GROUP_PATTERN = /^(?:BinaryExpression|ConditionalExpression)$/u;
    var SKIP_PATTERN = /^(?:ArrowFunction|Class|Function)Expression$/u;
    var DYNAMIC_PATTERN = /^(?:Call|Member|New|TaggedTemplate|Yield)Expression$/u;
    function isWriteReference(reference) {
      if (reference.init) {
        const def = reference.resolved && reference.resolved.defs[0];
        if (!def || def.type !== "Variable" || def.parent.kind !== "var") {
          return false;
        }
      }
      return reference.isWrite();
    }
    function isUnmodified(condition) {
      return !condition.modified;
    }
    function isUnmodifiedAndNotBelongToGroup(condition) {
      return !(condition.modified || condition.group);
    }
    function isInRange(node, reference) {
      const or = node.range;
      const ir = reference.identifier.range;
      return or[0] <= ir[0] && ir[1] <= or[1];
    }
    var isInLoop = {
      WhileStatement: isInRange,
      DoWhileStatement: isInRange,
      ForStatement(node, reference) {
        return isInRange(node, reference) && !(node.init && isInRange(node.init, reference));
      }
    };
    function getEncloseFunctionDeclaration(reference) {
      let node = reference.identifier;
      while (node) {
        if (node.type === "FunctionDeclaration") {
          return node.id ? node : null;
        }
        node = node.parent;
      }
      return null;
    }
    function updateModifiedFlag(conditions, modifiers) {
      for (let i = 0; i < conditions.length; ++i) {
        const condition = conditions[i];
        for (let j = 0; !condition.modified && j < modifiers.length; ++j) {
          const modifier = modifiers[j];
          let funcNode, funcVar;
          const inLoop = condition.isInLoop(modifier) || Boolean(
            (funcNode = getEncloseFunctionDeclaration(modifier)) && (funcVar = astUtils.getVariableByName(modifier.from.upper, funcNode.id.name)) && funcVar.references.some(condition.isInLoop)
          );
          condition.modified = inLoop;
        }
      }
    }
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow unmodified loop conditions",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-unmodified-loop-condition"
        },
        schema: [],
        messages: {
          loopConditionNotModified: "'{{name}}' is not modified in this loop."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        let groupMap = null;
        function report(condition) {
          const node = condition.reference.identifier;
          context.report({
            node,
            messageId: "loopConditionNotModified",
            data: node
          });
        }
        function registerConditionsToGroup(conditions) {
          for (let i = 0; i < conditions.length; ++i) {
            const condition = conditions[i];
            if (condition.group) {
              let group = groupMap.get(condition.group);
              if (!group) {
                group = [];
                groupMap.set(condition.group, group);
              }
              group.push(condition);
            }
          }
        }
        function checkConditionsInGroup(conditions) {
          if (conditions.every(isUnmodified)) {
            conditions.forEach(report);
          }
        }
        function hasDynamicExpressions(root) {
          let retv = false;
          Traverser.traverse(root, {
            visitorKeys: sourceCode.visitorKeys,
            enter(node) {
              if (DYNAMIC_PATTERN.test(node.type)) {
                retv = true;
                this.break();
              } else if (SKIP_PATTERN.test(node.type)) {
                this.skip();
              }
            }
          });
          return retv;
        }
        function toLoopCondition(reference) {
          if (reference.init) {
            return null;
          }
          let group = null;
          let child = reference.identifier;
          let node = child.parent;
          while (node) {
            if (SENTINEL_PATTERN.test(node.type)) {
              if (LOOP_PATTERN.test(node.type) && node.test === child) {
                return {
                  reference,
                  group,
                  isInLoop: isInLoop[node.type].bind(null, node),
                  modified: false
                };
              }
              break;
            }
            if (GROUP_PATTERN.test(node.type)) {
              if (hasDynamicExpressions(node)) {
                break;
              } else {
                group = node;
              }
            }
            child = node;
            node = node.parent;
          }
          return null;
        }
        function checkReferences(variable) {
          const conditions = variable.references.map(toLoopCondition).filter(Boolean);
          if (conditions.length === 0) {
            return;
          }
          registerConditionsToGroup(conditions);
          const modifiers = variable.references.filter(isWriteReference);
          if (modifiers.length > 0) {
            updateModifiedFlag(conditions, modifiers);
          }
          conditions.filter(isUnmodifiedAndNotBelongToGroup).forEach(report);
        }
        return {
          "Program:exit"(node) {
            const queue = [sourceCode.getScope(node)];
            groupMap = /* @__PURE__ */ new Map();
            let scope;
            while (scope = queue.pop()) {
              queue.push(...scope.childScopes);
              scope.variables.forEach(checkReferences);
            }
            groupMap.forEach(checkConditionsInGroup);
            groupMap = null;
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-unneeded-ternary.js
var require_no_unneeded_ternary = __commonJS({
  "../../node_modules/eslint/lib/rules/no-unneeded-ternary.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var BOOLEAN_OPERATORS = /* @__PURE__ */ new Set(["==", "===", "!=", "!==", ">", ">=", "<", "<=", "in", "instanceof"]);
    var OPERATOR_INVERSES = {
      "==": "!=",
      "!=": "==",
      "===": "!==",
      "!==": "==="
      // Operators like < and >= are not true inverses, since both will return false with NaN.
    };
    var OR_PRECEDENCE = astUtils.getPrecedence({ type: "LogicalExpression", operator: "||" });
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow ternary operators when simpler alternatives exist",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-unneeded-ternary"
        },
        schema: [
          {
            type: "object",
            properties: {
              defaultAssignment: {
                type: "boolean",
                default: true
              }
            },
            additionalProperties: false
          }
        ],
        fixable: "code",
        messages: {
          unnecessaryConditionalExpression: "Unnecessary use of boolean literals in conditional expression.",
          unnecessaryConditionalAssignment: "Unnecessary use of conditional expression for default assignment."
        }
      },
      create(context) {
        const options = context.options[0] || {};
        const defaultAssignment = options.defaultAssignment !== false;
        const sourceCode = context.sourceCode;
        function isBooleanLiteral(node) {
          return node.type === "Literal" && typeof node.value === "boolean";
        }
        function invertExpression(node) {
          if (node.type === "BinaryExpression" && Object.prototype.hasOwnProperty.call(OPERATOR_INVERSES, node.operator)) {
            const operatorToken = sourceCode.getFirstTokenBetween(
              node.left,
              node.right,
              (token) => token.value === node.operator
            );
            const text = sourceCode.getText();
            return text.slice(
              node.range[0],
              operatorToken.range[0]
            ) + OPERATOR_INVERSES[node.operator] + text.slice(operatorToken.range[1], node.range[1]);
          }
          if (astUtils.getPrecedence(node) < astUtils.getPrecedence({ type: "UnaryExpression" })) {
            return `!(${astUtils.getParenthesisedText(sourceCode, node)})`;
          }
          return `!${astUtils.getParenthesisedText(sourceCode, node)}`;
        }
        function isBooleanExpression(node) {
          return node.type === "BinaryExpression" && BOOLEAN_OPERATORS.has(node.operator) || node.type === "UnaryExpression" && node.operator === "!";
        }
        function matchesDefaultAssignment(node) {
          return node.test.type === "Identifier" && node.consequent.type === "Identifier" && node.test.name === node.consequent.name;
        }
        return {
          ConditionalExpression(node) {
            if (isBooleanLiteral(node.alternate) && isBooleanLiteral(node.consequent)) {
              context.report({
                node,
                messageId: "unnecessaryConditionalExpression",
                fix(fixer) {
                  if (node.consequent.value === node.alternate.value) {
                    return node.test.type === "Identifier" ? fixer.replaceText(node, node.consequent.value.toString()) : null;
                  }
                  if (node.alternate.value) {
                    return fixer.replaceText(node, invertExpression(node.test));
                  }
                  return fixer.replaceText(node, isBooleanExpression(node.test) ? astUtils.getParenthesisedText(sourceCode, node.test) : `!${invertExpression(node.test)}`);
                }
              });
            } else if (!defaultAssignment && matchesDefaultAssignment(node)) {
              context.report({
                node,
                messageId: "unnecessaryConditionalAssignment",
                fix(fixer) {
                  const shouldParenthesizeAlternate = (astUtils.getPrecedence(node.alternate) < OR_PRECEDENCE || astUtils.isCoalesceExpression(node.alternate)) && !astUtils.isParenthesised(sourceCode, node.alternate);
                  const alternateText = shouldParenthesizeAlternate ? `(${sourceCode.getText(node.alternate)})` : astUtils.getParenthesisedText(sourceCode, node.alternate);
                  const testText = astUtils.getParenthesisedText(sourceCode, node.test);
                  return fixer.replaceText(node, `${testText} || ${alternateText}`);
                }
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-unreachable.js
var require_no_unreachable = __commonJS({
  "../../node_modules/eslint/lib/rules/no-unreachable.js"(exports, module) {
    "use strict";
    function isInitialized(node) {
      return Boolean(node.init);
    }
    function isUnreachable(segment) {
      return !segment.reachable;
    }
    var ConsecutiveRange = class {
      constructor(sourceCode) {
        this.sourceCode = sourceCode;
        this.startNode = null;
        this.endNode = null;
      }
      /**
       * The location object of this range.
       * @type {Object}
       */
      get location() {
        return {
          start: this.startNode.loc.start,
          end: this.endNode.loc.end
        };
      }
      /**
       * `true` if this range is empty.
       * @type {boolean}
       */
      get isEmpty() {
        return !(this.startNode && this.endNode);
      }
      /**
       * Checks whether the given node is inside of this range.
       * @param {ASTNode|Token} node The node to check.
       * @returns {boolean} `true` if the node is inside of this range.
       */
      contains(node) {
        return node.range[0] >= this.startNode.range[0] && node.range[1] <= this.endNode.range[1];
      }
      /**
       * Checks whether the given node is consecutive to this range.
       * @param {ASTNode} node The node to check.
       * @returns {boolean} `true` if the node is consecutive to this range.
       */
      isConsecutive(node) {
        return this.contains(this.sourceCode.getTokenBefore(node));
      }
      /**
       * Merges the given node to this range.
       * @param {ASTNode} node The node to merge.
       * @returns {void}
       */
      merge(node) {
        this.endNode = node;
      }
      /**
       * Resets this range by the given node or null.
       * @param {ASTNode|null} node The node to reset, or null.
       * @returns {void}
       */
      reset(node) {
        this.startNode = this.endNode = node;
      }
    };
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow unreachable code after `return`, `throw`, `continue`, and `break` statements",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-unreachable"
        },
        schema: [],
        messages: {
          unreachableCode: "Unreachable code."
        }
      },
      create(context) {
        let currentCodePath = null;
        let constructorInfo = null;
        const range = new ConsecutiveRange(context.sourceCode);
        function reportIfUnreachable(node) {
          let nextNode = null;
          if (node && (node.type === "PropertyDefinition" || currentCodePath.currentSegments.every(isUnreachable))) {
            if (range.isEmpty) {
              range.reset(node);
              return;
            }
            if (range.contains(node)) {
              return;
            }
            if (range.isConsecutive(node)) {
              range.merge(node);
              return;
            }
            nextNode = node;
          }
          if (!range.isEmpty) {
            context.report({
              messageId: "unreachableCode",
              loc: range.location,
              node: range.startNode
            });
          }
          range.reset(nextNode);
        }
        return {
          // Manages the current code path.
          onCodePathStart(codePath) {
            currentCodePath = codePath;
          },
          onCodePathEnd() {
            currentCodePath = currentCodePath.upper;
          },
          // Registers for all statement nodes (excludes FunctionDeclaration).
          BlockStatement: reportIfUnreachable,
          BreakStatement: reportIfUnreachable,
          ClassDeclaration: reportIfUnreachable,
          ContinueStatement: reportIfUnreachable,
          DebuggerStatement: reportIfUnreachable,
          DoWhileStatement: reportIfUnreachable,
          ExpressionStatement: reportIfUnreachable,
          ForInStatement: reportIfUnreachable,
          ForOfStatement: reportIfUnreachable,
          ForStatement: reportIfUnreachable,
          IfStatement: reportIfUnreachable,
          ImportDeclaration: reportIfUnreachable,
          LabeledStatement: reportIfUnreachable,
          ReturnStatement: reportIfUnreachable,
          SwitchStatement: reportIfUnreachable,
          ThrowStatement: reportIfUnreachable,
          TryStatement: reportIfUnreachable,
          VariableDeclaration(node) {
            if (node.kind !== "var" || node.declarations.some(isInitialized)) {
              reportIfUnreachable(node);
            }
          },
          WhileStatement: reportIfUnreachable,
          WithStatement: reportIfUnreachable,
          ExportNamedDeclaration: reportIfUnreachable,
          ExportDefaultDeclaration: reportIfUnreachable,
          ExportAllDeclaration: reportIfUnreachable,
          "Program:exit"() {
            reportIfUnreachable();
          },
          /*
           * Instance fields defined in a subclass are never created if the constructor of the subclass
           * doesn't call `super()`, so their definitions are unreachable code.
           */
          "MethodDefinition[kind='constructor']"() {
            constructorInfo = {
              upper: constructorInfo,
              hasSuperCall: false
            };
          },
          "MethodDefinition[kind='constructor']:exit"(node) {
            const { hasSuperCall } = constructorInfo;
            constructorInfo = constructorInfo.upper;
            if (!node.value.body) {
              return;
            }
            const classDefinition = node.parent.parent;
            if (classDefinition.superClass && !hasSuperCall) {
              for (const element of classDefinition.body.body) {
                if (element.type === "PropertyDefinition" && !element.static) {
                  reportIfUnreachable(element);
                }
              }
            }
          },
          "CallExpression > Super.callee"() {
            if (constructorInfo) {
              constructorInfo.hasSuperCall = true;
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-unreachable-loop.js
var require_no_unreachable_loop = __commonJS({
  "../../node_modules/eslint/lib/rules/no-unreachable-loop.js"(exports, module) {
    "use strict";
    var allLoopTypes = ["WhileStatement", "DoWhileStatement", "ForStatement", "ForInStatement", "ForOfStatement"];
    function isLoopingTarget(node) {
      const parent = node.parent;
      if (parent) {
        switch (parent.type) {
          case "WhileStatement":
            return node === parent.test;
          case "DoWhileStatement":
            return node === parent.body;
          case "ForStatement":
            return node === (parent.update || parent.test || parent.body);
          case "ForInStatement":
          case "ForOfStatement":
            return node === parent.left;
        }
      }
      return false;
    }
    function getDifference(arrA, arrB) {
      return arrA.filter((a) => !arrB.includes(a));
    }
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow loops with a body that allows only one iteration",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-unreachable-loop"
        },
        schema: [{
          type: "object",
          properties: {
            ignore: {
              type: "array",
              items: {
                enum: allLoopTypes
              },
              uniqueItems: true
            }
          },
          additionalProperties: false
        }],
        messages: {
          invalid: "Invalid loop. Its body allows only one iteration."
        }
      },
      create(context) {
        const ignoredLoopTypes = context.options[0] && context.options[0].ignore || [], loopTypesToCheck = getDifference(allLoopTypes, ignoredLoopTypes), loopSelector = loopTypesToCheck.join(","), loopsByTargetSegments = /* @__PURE__ */ new Map(), loopsToReport = /* @__PURE__ */ new Set();
        let currentCodePath = null;
        return {
          onCodePathStart(codePath) {
            currentCodePath = codePath;
          },
          onCodePathEnd() {
            currentCodePath = currentCodePath.upper;
          },
          [loopSelector](node) {
            if (currentCodePath.currentSegments.some((segment) => segment.reachable)) {
              loopsToReport.add(node);
            }
          },
          onCodePathSegmentStart(segment, node) {
            if (isLoopingTarget(node)) {
              const loop = node.parent;
              loopsByTargetSegments.set(segment, loop);
            }
          },
          onCodePathSegmentLoop(_, toSegment, node) {
            const loop = loopsByTargetSegments.get(toSegment);
            if (node === loop || node.type === "ContinueStatement") {
              loopsToReport.delete(loop);
            }
          },
          "Program:exit"() {
            loopsToReport.forEach(
              (node) => context.report({ node, messageId: "invalid" })
            );
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-unsafe-finally.js
var require_no_unsafe_finally = __commonJS({
  "../../node_modules/eslint/lib/rules/no-unsafe-finally.js"(exports, module) {
    "use strict";
    var SENTINEL_NODE_TYPE_RETURN_THROW = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression)$/u;
    var SENTINEL_NODE_TYPE_BREAK = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|DoWhileStatement|WhileStatement|ForOfStatement|ForInStatement|ForStatement|SwitchStatement)$/u;
    var SENTINEL_NODE_TYPE_CONTINUE = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|DoWhileStatement|WhileStatement|ForOfStatement|ForInStatement|ForStatement)$/u;
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow control flow statements in `finally` blocks",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-unsafe-finally"
        },
        schema: [],
        messages: {
          unsafeUsage: "Unsafe usage of {{nodeType}}."
        }
      },
      create(context) {
        function isFinallyBlock(node) {
          return node.parent.type === "TryStatement" && node.parent.finalizer === node;
        }
        function isInFinallyBlock(node, label) {
          let labelInside = false;
          let sentinelNodeType;
          if (node.type === "BreakStatement" && !node.label) {
            sentinelNodeType = SENTINEL_NODE_TYPE_BREAK;
          } else if (node.type === "ContinueStatement") {
            sentinelNodeType = SENTINEL_NODE_TYPE_CONTINUE;
          } else {
            sentinelNodeType = SENTINEL_NODE_TYPE_RETURN_THROW;
          }
          for (let currentNode = node; currentNode && !sentinelNodeType.test(currentNode.type); currentNode = currentNode.parent) {
            if (currentNode.parent.label && label && currentNode.parent.label.name === label.name) {
              labelInside = true;
            }
            if (isFinallyBlock(currentNode)) {
              if (label && labelInside) {
                return false;
              }
              return true;
            }
          }
          return false;
        }
        function check(node) {
          if (isInFinallyBlock(node, node.label)) {
            context.report({
              messageId: "unsafeUsage",
              data: {
                nodeType: node.type
              },
              node,
              line: node.loc.line,
              column: node.loc.column
            });
          }
        }
        return {
          ReturnStatement: check,
          ThrowStatement: check,
          BreakStatement: check,
          ContinueStatement: check
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-unsafe-negation.js
var require_no_unsafe_negation = __commonJS({
  "../../node_modules/eslint/lib/rules/no-unsafe-negation.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    function isInOrInstanceOfOperator(op) {
      return op === "in" || op === "instanceof";
    }
    function isOrderingRelationalOperator(op) {
      return op === "<" || op === ">" || op === ">=" || op === "<=";
    }
    function isNegation(node) {
      return node.type === "UnaryExpression" && node.operator === "!";
    }
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow negating the left operand of relational operators",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-unsafe-negation"
        },
        hasSuggestions: true,
        schema: [
          {
            type: "object",
            properties: {
              enforceForOrderingRelations: {
                type: "boolean",
                default: false
              }
            },
            additionalProperties: false
          }
        ],
        fixable: null,
        messages: {
          unexpected: "Unexpected negating the left operand of '{{operator}}' operator.",
          suggestNegatedExpression: "Negate '{{operator}}' expression instead of its left operand. This changes the current behavior.",
          suggestParenthesisedNegation: "Wrap negation in '()' to make the intention explicit. This preserves the current behavior."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        const options = context.options[0] || {};
        const enforceForOrderingRelations = options.enforceForOrderingRelations === true;
        return {
          BinaryExpression(node) {
            const operator = node.operator;
            const orderingRelationRuleApplies = enforceForOrderingRelations && isOrderingRelationalOperator(operator);
            if ((isInOrInstanceOfOperator(operator) || orderingRelationRuleApplies) && isNegation(node.left) && !astUtils.isParenthesised(sourceCode, node.left)) {
              context.report({
                node,
                loc: node.left.loc,
                messageId: "unexpected",
                data: { operator },
                suggest: [
                  {
                    messageId: "suggestNegatedExpression",
                    data: { operator },
                    fix(fixer) {
                      const negationToken = sourceCode.getFirstToken(node.left);
                      const fixRange = [negationToken.range[1], node.range[1]];
                      const text = sourceCode.text.slice(fixRange[0], fixRange[1]);
                      return fixer.replaceTextRange(fixRange, `(${text})`);
                    }
                  },
                  {
                    messageId: "suggestParenthesisedNegation",
                    fix(fixer) {
                      return fixer.replaceText(node.left, `(${sourceCode.getText(node.left)})`);
                    }
                  }
                ]
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-unsafe-optional-chaining.js
var require_no_unsafe_optional_chaining = __commonJS({
  "../../node_modules/eslint/lib/rules/no-unsafe-optional-chaining.js"(exports, module) {
    "use strict";
    var UNSAFE_ARITHMETIC_OPERATORS = /* @__PURE__ */ new Set(["+", "-", "/", "*", "%", "**"]);
    var UNSAFE_ASSIGNMENT_OPERATORS = /* @__PURE__ */ new Set(["+=", "-=", "/=", "*=", "%=", "**="]);
    var UNSAFE_RELATIONAL_OPERATORS = /* @__PURE__ */ new Set(["in", "instanceof"]);
    function isDestructuringPattern(node) {
      return node.type === "ObjectPattern" || node.type === "ArrayPattern";
    }
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow use of optional chaining in contexts where the `undefined` value is not allowed",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-unsafe-optional-chaining"
        },
        schema: [{
          type: "object",
          properties: {
            disallowArithmeticOperators: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }],
        fixable: null,
        messages: {
          unsafeOptionalChain: "Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.",
          unsafeArithmetic: "Unsafe arithmetic operation on optional chaining. It can result in NaN."
        }
      },
      create(context) {
        const options = context.options[0] || {};
        const disallowArithmeticOperators = options.disallowArithmeticOperators || false;
        function reportUnsafeUsage(node) {
          context.report({
            messageId: "unsafeOptionalChain",
            node
          });
        }
        function reportUnsafeArithmetic(node) {
          context.report({
            messageId: "unsafeArithmetic",
            node
          });
        }
        function checkUndefinedShortCircuit(node, reportFunc) {
          if (!node) {
            return;
          }
          switch (node.type) {
            case "LogicalExpression":
              if (node.operator === "||" || node.operator === "??") {
                checkUndefinedShortCircuit(node.right, reportFunc);
              } else if (node.operator === "&&") {
                checkUndefinedShortCircuit(node.left, reportFunc);
                checkUndefinedShortCircuit(node.right, reportFunc);
              }
              break;
            case "SequenceExpression":
              checkUndefinedShortCircuit(
                node.expressions[node.expressions.length - 1],
                reportFunc
              );
              break;
            case "ConditionalExpression":
              checkUndefinedShortCircuit(node.consequent, reportFunc);
              checkUndefinedShortCircuit(node.alternate, reportFunc);
              break;
            case "AwaitExpression":
              checkUndefinedShortCircuit(node.argument, reportFunc);
              break;
            case "ChainExpression":
              reportFunc(node);
              break;
            default:
              break;
          }
        }
        function checkUnsafeUsage(node) {
          checkUndefinedShortCircuit(node, reportUnsafeUsage);
        }
        function checkUnsafeArithmetic(node) {
          checkUndefinedShortCircuit(node, reportUnsafeArithmetic);
        }
        return {
          "AssignmentExpression, AssignmentPattern"(node) {
            if (isDestructuringPattern(node.left)) {
              checkUnsafeUsage(node.right);
            }
          },
          "ClassDeclaration, ClassExpression"(node) {
            checkUnsafeUsage(node.superClass);
          },
          CallExpression(node) {
            if (!node.optional) {
              checkUnsafeUsage(node.callee);
            }
          },
          NewExpression(node) {
            checkUnsafeUsage(node.callee);
          },
          VariableDeclarator(node) {
            if (isDestructuringPattern(node.id)) {
              checkUnsafeUsage(node.init);
            }
          },
          MemberExpression(node) {
            if (!node.optional) {
              checkUnsafeUsage(node.object);
            }
          },
          TaggedTemplateExpression(node) {
            checkUnsafeUsage(node.tag);
          },
          ForOfStatement(node) {
            checkUnsafeUsage(node.right);
          },
          SpreadElement(node) {
            if (node.parent && node.parent.type !== "ObjectExpression") {
              checkUnsafeUsage(node.argument);
            }
          },
          BinaryExpression(node) {
            if (UNSAFE_RELATIONAL_OPERATORS.has(node.operator)) {
              checkUnsafeUsage(node.right);
            }
            if (disallowArithmeticOperators && UNSAFE_ARITHMETIC_OPERATORS.has(node.operator)) {
              checkUnsafeArithmetic(node.right);
              checkUnsafeArithmetic(node.left);
            }
          },
          WithStatement(node) {
            checkUnsafeUsage(node.object);
          },
          UnaryExpression(node) {
            if (disallowArithmeticOperators && UNSAFE_ARITHMETIC_OPERATORS.has(node.operator)) {
              checkUnsafeArithmetic(node.argument);
            }
          },
          AssignmentExpression(node) {
            if (disallowArithmeticOperators && UNSAFE_ASSIGNMENT_OPERATORS.has(node.operator)) {
              checkUnsafeArithmetic(node.right);
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-unused-expressions.js
var require_no_unused_expressions = __commonJS({
  "../../node_modules/eslint/lib/rules/no-unused-expressions.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    function alwaysTrue() {
      return true;
    }
    function alwaysFalse() {
      return false;
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow unused expressions",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-unused-expressions"
        },
        schema: [
          {
            type: "object",
            properties: {
              allowShortCircuit: {
                type: "boolean",
                default: false
              },
              allowTernary: {
                type: "boolean",
                default: false
              },
              allowTaggedTemplates: {
                type: "boolean",
                default: false
              },
              enforceForJSX: {
                type: "boolean",
                default: false
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          unusedExpression: "Expected an assignment or function call and instead saw an expression."
        }
      },
      create(context) {
        const config = context.options[0] || {}, allowShortCircuit = config.allowShortCircuit || false, allowTernary = config.allowTernary || false, allowTaggedTemplates = config.allowTaggedTemplates || false, enforceForJSX = config.enforceForJSX || false;
        function looksLikeDirective(node) {
          return node.type === "ExpressionStatement" && node.expression.type === "Literal" && typeof node.expression.value === "string";
        }
        function takeWhile(predicate, list) {
          for (let i = 0; i < list.length; ++i) {
            if (!predicate(list[i])) {
              return list.slice(0, i);
            }
          }
          return list.slice();
        }
        function directives(node) {
          return takeWhile(looksLikeDirective, node.body);
        }
        function isDirective(node) {
          return astUtils.isTopLevelExpressionStatement(node) && directives(node.parent).includes(node);
        }
        const Checker = Object.assign(/* @__PURE__ */ Object.create(null), {
          isDisallowed(node) {
            return (Checker[node.type] || alwaysFalse)(node);
          },
          ArrayExpression: alwaysTrue,
          ArrowFunctionExpression: alwaysTrue,
          BinaryExpression: alwaysTrue,
          ChainExpression(node) {
            return Checker.isDisallowed(node.expression);
          },
          ClassExpression: alwaysTrue,
          ConditionalExpression(node) {
            if (allowTernary) {
              return Checker.isDisallowed(node.consequent) || Checker.isDisallowed(node.alternate);
            }
            return true;
          },
          FunctionExpression: alwaysTrue,
          Identifier: alwaysTrue,
          JSXElement() {
            return enforceForJSX;
          },
          JSXFragment() {
            return enforceForJSX;
          },
          Literal: alwaysTrue,
          LogicalExpression(node) {
            if (allowShortCircuit) {
              return Checker.isDisallowed(node.right);
            }
            return true;
          },
          MemberExpression: alwaysTrue,
          MetaProperty: alwaysTrue,
          ObjectExpression: alwaysTrue,
          SequenceExpression: alwaysTrue,
          TaggedTemplateExpression() {
            return !allowTaggedTemplates;
          },
          TemplateLiteral: alwaysTrue,
          ThisExpression: alwaysTrue,
          UnaryExpression(node) {
            return node.operator !== "void" && node.operator !== "delete";
          }
        });
        return {
          ExpressionStatement(node) {
            if (Checker.isDisallowed(node.expression) && !isDirective(node)) {
              context.report({ node, messageId: "unusedExpression" });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-unused-labels.js
var require_no_unused_labels = __commonJS({
  "../../node_modules/eslint/lib/rules/no-unused-labels.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow unused labels",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-unused-labels"
        },
        schema: [],
        fixable: "code",
        messages: {
          unused: "'{{name}}:' is defined but never used."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        let scopeInfo = null;
        function enterLabeledScope(node) {
          scopeInfo = {
            label: node.label.name,
            used: false,
            upper: scopeInfo
          };
        }
        function isFixable(node) {
          if (sourceCode.getTokenAfter(node.label, { includeComments: true }) !== sourceCode.getTokenBefore(node.body, { includeComments: true })) {
            return false;
          }
          let ancestor = node.parent;
          while (ancestor.type === "LabeledStatement") {
            ancestor = ancestor.parent;
          }
          if (ancestor.type === "Program" || ancestor.type === "BlockStatement" && astUtils.isFunction(ancestor.parent)) {
            const { body } = node;
            if (body.type === "ExpressionStatement" && (body.expression.type === "Literal" && typeof body.expression.value === "string" || astUtils.isStaticTemplateLiteral(body.expression))) {
              return false;
            }
          }
          return true;
        }
        function exitLabeledScope(node) {
          if (!scopeInfo.used) {
            context.report({
              node: node.label,
              messageId: "unused",
              data: node.label,
              fix: isFixable(node) ? (fixer) => fixer.removeRange([node.range[0], node.body.range[0]]) : null
            });
          }
          scopeInfo = scopeInfo.upper;
        }
        function markAsUsed(node) {
          if (!node.label) {
            return;
          }
          const label = node.label.name;
          let info = scopeInfo;
          while (info) {
            if (info.label === label) {
              info.used = true;
              break;
            }
            info = info.upper;
          }
        }
        return {
          LabeledStatement: enterLabeledScope,
          "LabeledStatement:exit": exitLabeledScope,
          BreakStatement: markAsUsed,
          ContinueStatement: markAsUsed
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-unused-private-class-members.js
var require_no_unused_private_class_members = __commonJS({
  "../../node_modules/eslint/lib/rules/no-unused-private-class-members.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow unused private class members",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-unused-private-class-members"
        },
        schema: [],
        messages: {
          unusedPrivateClassMember: "'{{classMemberName}}' is defined but never used."
        }
      },
      create(context) {
        const trackedClasses = [];
        function isWriteOnlyAssignment(privateIdentifierNode) {
          const parentStatement = privateIdentifierNode.parent.parent;
          const isAssignmentExpression = parentStatement.type === "AssignmentExpression";
          if (!isAssignmentExpression && parentStatement.type !== "ForInStatement" && parentStatement.type !== "ForOfStatement" && parentStatement.type !== "AssignmentPattern") {
            return false;
          }
          if (parentStatement.left !== privateIdentifierNode.parent) {
            return false;
          }
          if (isAssignmentExpression && parentStatement.operator !== "=") {
            return parentStatement.parent.type === "ExpressionStatement";
          }
          return true;
        }
        return {
          // Collect all declared members up front and assume they are all unused
          ClassBody(classBodyNode) {
            const privateMembers = /* @__PURE__ */ new Map();
            trackedClasses.unshift(privateMembers);
            for (const bodyMember of classBodyNode.body) {
              if (bodyMember.type === "PropertyDefinition" || bodyMember.type === "MethodDefinition") {
                if (bodyMember.key.type === "PrivateIdentifier") {
                  privateMembers.set(bodyMember.key.name, {
                    declaredNode: bodyMember,
                    isAccessor: bodyMember.type === "MethodDefinition" && (bodyMember.kind === "set" || bodyMember.kind === "get")
                  });
                }
              }
            }
          },
          /*
           * Process all usages of the private identifier and remove a member from
           * `declaredAndUnusedPrivateMembers` if we deem it used.
           */
          PrivateIdentifier(privateIdentifierNode) {
            const classBody = trackedClasses.find((classProperties) => classProperties.has(privateIdentifierNode.name));
            if (!classBody) {
              return;
            }
            const memberDefinition = classBody.get(privateIdentifierNode.name);
            if (memberDefinition.isUsed) {
              return;
            }
            if (privateIdentifierNode.parent.type === "PropertyDefinition" || privateIdentifierNode.parent.type === "MethodDefinition") {
              return;
            }
            if (memberDefinition.isAccessor) {
              memberDefinition.isUsed = true;
              return;
            }
            if (isWriteOnlyAssignment(privateIdentifierNode)) {
              return;
            }
            const wrappingExpressionType = privateIdentifierNode.parent.parent.type;
            const parentOfWrappingExpressionType = privateIdentifierNode.parent.parent.parent.type;
            if (wrappingExpressionType === "UpdateExpression" && parentOfWrappingExpressionType === "ExpressionStatement") {
              return;
            }
            if (wrappingExpressionType === "Property" && parentOfWrappingExpressionType === "ObjectPattern" && privateIdentifierNode.parent.parent.value === privateIdentifierNode.parent) {
              return;
            }
            if (wrappingExpressionType === "RestElement") {
              return;
            }
            if (wrappingExpressionType === "ArrayPattern") {
              return;
            }
            memberDefinition.isUsed = true;
          },
          /*
           * Post-process the class members and report any remaining members.
           * Since private members can only be accessed in the current class context,
           * we can safely assume that all usages are within the current class body.
           */
          "ClassBody:exit"() {
            const unusedPrivateMembers = trackedClasses.shift();
            for (const [classMemberName, { declaredNode, isUsed }] of unusedPrivateMembers.entries()) {
              if (isUsed) {
                continue;
              }
              context.report({
                node: declaredNode,
                loc: declaredNode.key.loc,
                messageId: "unusedPrivateClassMember",
                data: {
                  classMemberName: `#${classMemberName}`
                }
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-unused-vars.js
var require_no_unused_vars = __commonJS({
  "../../node_modules/eslint/lib/rules/no-unused-vars.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow unused variables",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-unused-vars"
        },
        schema: [
          {
            oneOf: [
              {
                enum: ["all", "local"]
              },
              {
                type: "object",
                properties: {
                  vars: {
                    enum: ["all", "local"]
                  },
                  varsIgnorePattern: {
                    type: "string"
                  },
                  args: {
                    enum: ["all", "after-used", "none"]
                  },
                  ignoreRestSiblings: {
                    type: "boolean"
                  },
                  argsIgnorePattern: {
                    type: "string"
                  },
                  caughtErrors: {
                    enum: ["all", "none"]
                  },
                  caughtErrorsIgnorePattern: {
                    type: "string"
                  },
                  destructuredArrayIgnorePattern: {
                    type: "string"
                  }
                },
                additionalProperties: false
              }
            ]
          }
        ],
        messages: {
          unusedVar: "'{{varName}}' is {{action}} but never used{{additional}}."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        const REST_PROPERTY_TYPE = /^(?:RestElement|(?:Experimental)?RestProperty)$/u;
        const config = {
          vars: "all",
          args: "after-used",
          ignoreRestSiblings: false,
          caughtErrors: "none"
        };
        const firstOption = context.options[0];
        if (firstOption) {
          if (typeof firstOption === "string") {
            config.vars = firstOption;
          } else {
            config.vars = firstOption.vars || config.vars;
            config.args = firstOption.args || config.args;
            config.ignoreRestSiblings = firstOption.ignoreRestSiblings || config.ignoreRestSiblings;
            config.caughtErrors = firstOption.caughtErrors || config.caughtErrors;
            if (firstOption.varsIgnorePattern) {
              config.varsIgnorePattern = new RegExp(firstOption.varsIgnorePattern, "u");
            }
            if (firstOption.argsIgnorePattern) {
              config.argsIgnorePattern = new RegExp(firstOption.argsIgnorePattern, "u");
            }
            if (firstOption.caughtErrorsIgnorePattern) {
              config.caughtErrorsIgnorePattern = new RegExp(firstOption.caughtErrorsIgnorePattern, "u");
            }
            if (firstOption.destructuredArrayIgnorePattern) {
              config.destructuredArrayIgnorePattern = new RegExp(firstOption.destructuredArrayIgnorePattern, "u");
            }
          }
        }
        function getDefinedMessageData(unusedVar) {
          const defType = unusedVar.defs && unusedVar.defs[0] && unusedVar.defs[0].type;
          let type;
          let pattern;
          if (defType === "CatchClause" && config.caughtErrorsIgnorePattern) {
            type = "args";
            pattern = config.caughtErrorsIgnorePattern.toString();
          } else if (defType === "Parameter" && config.argsIgnorePattern) {
            type = "args";
            pattern = config.argsIgnorePattern.toString();
          } else if (defType !== "Parameter" && config.varsIgnorePattern) {
            type = "vars";
            pattern = config.varsIgnorePattern.toString();
          }
          const additional = type ? `. Allowed unused ${type} must match ${pattern}` : "";
          return {
            varName: unusedVar.name,
            action: "defined",
            additional
          };
        }
        function getAssignedMessageData(unusedVar) {
          const def = unusedVar.defs[0];
          let additional = "";
          if (config.destructuredArrayIgnorePattern && def && def.name.parent.type === "ArrayPattern") {
            additional = `. Allowed unused elements of array destructuring patterns must match ${config.destructuredArrayIgnorePattern.toString()}`;
          } else if (config.varsIgnorePattern) {
            additional = `. Allowed unused vars must match ${config.varsIgnorePattern.toString()}`;
          }
          return {
            varName: unusedVar.name,
            action: "assigned a value",
            additional
          };
        }
        const STATEMENT_TYPE = /(?:Statement|Declaration)$/u;
        function isExported(variable) {
          const definition = variable.defs[0];
          if (definition) {
            let node = definition.node;
            if (node.type === "VariableDeclarator") {
              node = node.parent;
            } else if (definition.type === "Parameter") {
              return false;
            }
            return node.parent.type.indexOf("Export") === 0;
          }
          return false;
        }
        function hasRestSibling(node) {
          return node.type === "Property" && node.parent.type === "ObjectPattern" && REST_PROPERTY_TYPE.test(node.parent.properties[node.parent.properties.length - 1].type);
        }
        function hasRestSpreadSibling(variable) {
          if (config.ignoreRestSiblings) {
            const hasRestSiblingDefinition = variable.defs.some((def) => hasRestSibling(def.name.parent));
            const hasRestSiblingReference = variable.references.some((ref) => hasRestSibling(ref.identifier.parent));
            return hasRestSiblingDefinition || hasRestSiblingReference;
          }
          return false;
        }
        function isReadRef(ref) {
          return ref.isRead();
        }
        function isSelfReference(ref, nodes) {
          let scope = ref.from;
          while (scope) {
            if (nodes.includes(scope.block)) {
              return true;
            }
            scope = scope.upper;
          }
          return false;
        }
        function getFunctionDefinitions(variable) {
          const functionDefinitions = [];
          variable.defs.forEach((def) => {
            const { type, node } = def;
            if (type === "FunctionName") {
              functionDefinitions.push(node);
            }
            if (type === "Variable" && node.init && (node.init.type === "FunctionExpression" || node.init.type === "ArrowFunctionExpression")) {
              functionDefinitions.push(node.init);
            }
          });
          return functionDefinitions;
        }
        function isInside(inner, outer) {
          return inner.range[0] >= outer.range[0] && inner.range[1] <= outer.range[1];
        }
        function isUnusedExpression(node) {
          const parent = node.parent;
          if (parent.type === "ExpressionStatement") {
            return true;
          }
          if (parent.type === "SequenceExpression") {
            const isLastExpression = parent.expressions[parent.expressions.length - 1] === node;
            if (!isLastExpression) {
              return true;
            }
            return isUnusedExpression(parent);
          }
          return false;
        }
        function getRhsNode(ref, prevRhsNode) {
          const id = ref.identifier;
          const parent = id.parent;
          const refScope = ref.from.variableScope;
          const varScope = ref.resolved.scope.variableScope;
          const canBeUsedLater = refScope !== varScope || astUtils.isInLoop(id);
          if (prevRhsNode && isInside(id, prevRhsNode)) {
            return prevRhsNode;
          }
          if (parent.type === "AssignmentExpression" && isUnusedExpression(parent) && id === parent.left && !canBeUsedLater) {
            return parent.right;
          }
          return null;
        }
        function isStorableFunction(funcNode, rhsNode) {
          let node = funcNode;
          let parent = funcNode.parent;
          while (parent && isInside(parent, rhsNode)) {
            switch (parent.type) {
              case "SequenceExpression":
                if (parent.expressions[parent.expressions.length - 1] !== node) {
                  return false;
                }
                break;
              case "CallExpression":
              case "NewExpression":
                return parent.callee !== node;
              case "AssignmentExpression":
              case "TaggedTemplateExpression":
              case "YieldExpression":
                return true;
              default:
                if (STATEMENT_TYPE.test(parent.type)) {
                  return true;
                }
            }
            node = parent;
            parent = parent.parent;
          }
          return false;
        }
        function isInsideOfStorableFunction(id, rhsNode) {
          const funcNode = astUtils.getUpperFunction(id);
          return funcNode && isInside(funcNode, rhsNode) && isStorableFunction(funcNode, rhsNode);
        }
        function isReadForItself(ref, rhsNode) {
          const id = ref.identifier;
          const parent = id.parent;
          return ref.isRead() && // self update. e.g. `a += 1`, `a++`
          (parent.type === "AssignmentExpression" && parent.left === id && isUnusedExpression(parent) && !astUtils.isLogicalAssignmentOperator(parent.operator) || parent.type === "UpdateExpression" && isUnusedExpression(parent) || // in RHS of an assignment for itself. e.g. `a = a + 1`
          rhsNode && isInside(id, rhsNode) && !isInsideOfStorableFunction(id, rhsNode));
        }
        function isForInOfRef(ref) {
          let target = ref.identifier.parent;
          if (target.type === "VariableDeclarator") {
            target = target.parent.parent;
          }
          if (target.type !== "ForInStatement" && target.type !== "ForOfStatement") {
            return false;
          }
          if (target.body.type === "BlockStatement") {
            target = target.body.body[0];
          } else {
            target = target.body;
          }
          if (!target) {
            return false;
          }
          return target.type === "ReturnStatement";
        }
        function isUsedVariable(variable) {
          const functionNodes = getFunctionDefinitions(variable), isFunctionDefinition = functionNodes.length > 0;
          let rhsNode = null;
          return variable.references.some((ref) => {
            if (isForInOfRef(ref)) {
              return true;
            }
            const forItself = isReadForItself(ref, rhsNode);
            rhsNode = getRhsNode(ref, rhsNode);
            return isReadRef(ref) && !forItself && !(isFunctionDefinition && isSelfReference(ref, functionNodes));
          });
        }
        function isAfterLastUsedArg(variable) {
          const def = variable.defs[0];
          const params = sourceCode.getDeclaredVariables(def.node);
          const posteriorParams = params.slice(params.indexOf(variable) + 1);
          return !posteriorParams.some((v) => v.references.length > 0 || v.eslintUsed);
        }
        function collectUnusedVariables(scope, unusedVars) {
          const variables = scope.variables;
          const childScopes = scope.childScopes;
          let i, l;
          if (scope.type !== "global" || config.vars === "all") {
            for (i = 0, l = variables.length; i < l; ++i) {
              const variable = variables[i];
              if (scope.type === "class" && scope.block.id === variable.identifiers[0]) {
                continue;
              }
              if (scope.functionExpressionScope || variable.eslintUsed) {
                continue;
              }
              if (scope.type === "function" && variable.name === "arguments" && variable.identifiers.length === 0) {
                continue;
              }
              const def = variable.defs[0];
              if (def) {
                const type = def.type;
                const refUsedInArrayPatterns = variable.references.some((ref) => ref.identifier.parent.type === "ArrayPattern");
                if ((def.name.parent.type === "ArrayPattern" || refUsedInArrayPatterns) && config.destructuredArrayIgnorePattern && config.destructuredArrayIgnorePattern.test(def.name.name)) {
                  continue;
                }
                if (type === "CatchClause") {
                  if (config.caughtErrors === "none") {
                    continue;
                  }
                  if (config.caughtErrorsIgnorePattern && config.caughtErrorsIgnorePattern.test(def.name.name)) {
                    continue;
                  }
                }
                if (type === "Parameter") {
                  if ((def.node.parent.type === "Property" || def.node.parent.type === "MethodDefinition") && def.node.parent.kind === "set") {
                    continue;
                  }
                  if (config.args === "none") {
                    continue;
                  }
                  if (config.argsIgnorePattern && config.argsIgnorePattern.test(def.name.name)) {
                    continue;
                  }
                  if (config.args === "after-used" && astUtils.isFunction(def.name.parent) && !isAfterLastUsedArg(variable)) {
                    continue;
                  }
                } else {
                  if (config.varsIgnorePattern && config.varsIgnorePattern.test(def.name.name)) {
                    continue;
                  }
                }
              }
              if (!isUsedVariable(variable) && !isExported(variable) && !hasRestSpreadSibling(variable)) {
                unusedVars.push(variable);
              }
            }
          }
          for (i = 0, l = childScopes.length; i < l; ++i) {
            collectUnusedVariables(childScopes[i], unusedVars);
          }
          return unusedVars;
        }
        return {
          "Program:exit"(programNode) {
            const unusedVars = collectUnusedVariables(sourceCode.getScope(programNode), []);
            for (let i = 0, l = unusedVars.length; i < l; ++i) {
              const unusedVar = unusedVars[i];
              if (unusedVar.defs.length > 0) {
                const writeReferences = unusedVar.references.filter((ref) => ref.isWrite() && ref.from.variableScope === unusedVar.scope.variableScope);
                let referenceToReport;
                if (writeReferences.length > 0) {
                  referenceToReport = writeReferences[writeReferences.length - 1];
                }
                context.report({
                  node: referenceToReport ? referenceToReport.identifier : unusedVar.identifiers[0],
                  messageId: "unusedVar",
                  data: unusedVar.references.some((ref) => ref.isWrite()) ? getAssignedMessageData(unusedVar) : getDefinedMessageData(unusedVar)
                });
              } else if (unusedVar.eslintExplicitGlobalComments) {
                const directiveComment = unusedVar.eslintExplicitGlobalComments[0];
                context.report({
                  node: programNode,
                  loc: astUtils.getNameLocationInGlobalDirectiveComment(sourceCode, directiveComment, unusedVar.name),
                  messageId: "unusedVar",
                  data: getDefinedMessageData(unusedVar)
                });
              }
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-use-before-define.js
var require_no_use_before_define = __commonJS({
  "../../node_modules/eslint/lib/rules/no-use-before-define.js"(exports, module) {
    "use strict";
    var SENTINEL_TYPE = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/u;
    var FOR_IN_OF_TYPE = /^For(?:In|Of)Statement$/u;
    function parseOptions(options) {
      let functions = true;
      let classes = true;
      let variables = true;
      let allowNamedExports = false;
      if (typeof options === "string") {
        functions = options !== "nofunc";
      } else if (typeof options === "object" && options !== null) {
        functions = options.functions !== false;
        classes = options.classes !== false;
        variables = options.variables !== false;
        allowNamedExports = !!options.allowNamedExports;
      }
      return { functions, classes, variables, allowNamedExports };
    }
    function isInRange(node, location) {
      return node && node.range[0] <= location && location <= node.range[1];
    }
    function isInClassStaticInitializerRange(node, location) {
      return node.body.some((classMember) => classMember.type === "StaticBlock" && isInRange(classMember, location) || classMember.type === "PropertyDefinition" && classMember.static && classMember.value && isInRange(classMember.value, location));
    }
    function isClassStaticInitializerScope(scope) {
      if (scope.type === "class-static-block") {
        return true;
      }
      if (scope.type === "class-field-initializer") {
        const propertyDefinition = scope.block.parent;
        return propertyDefinition.static;
      }
      return false;
    }
    function isFromSeparateExecutionContext(reference) {
      const variable = reference.resolved;
      let scope = reference.from;
      while (variable.scope.variableScope !== scope.variableScope) {
        if (isClassStaticInitializerScope(scope.variableScope)) {
          scope = scope.variableScope.upper;
        } else {
          return true;
        }
      }
      return false;
    }
    function isEvaluatedDuringInitialization(reference) {
      if (isFromSeparateExecutionContext(reference)) {
        return false;
      }
      const location = reference.identifier.range[1];
      const definition = reference.resolved.defs[0];
      if (definition.type === "ClassName") {
        const classDefinition = definition.node;
        return isInRange(classDefinition, location) && /*
         * Class binding is initialized before running static initializers.
         * For example, `class C { static foo = C; static { bar = C; } }` is valid.
         */
        !isInClassStaticInitializerRange(classDefinition.body, location);
      }
      let node = definition.name.parent;
      while (node) {
        if (node.type === "VariableDeclarator") {
          if (isInRange(node.init, location)) {
            return true;
          }
          if (FOR_IN_OF_TYPE.test(node.parent.parent.type) && isInRange(node.parent.parent.right, location)) {
            return true;
          }
          break;
        } else if (node.type === "AssignmentPattern") {
          if (isInRange(node.right, location)) {
            return true;
          }
        } else if (SENTINEL_TYPE.test(node.type)) {
          break;
        }
        node = node.parent;
      }
      return false;
    }
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow the use of variables before they are defined",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-use-before-define"
        },
        schema: [
          {
            oneOf: [
              {
                enum: ["nofunc"]
              },
              {
                type: "object",
                properties: {
                  functions: { type: "boolean" },
                  classes: { type: "boolean" },
                  variables: { type: "boolean" },
                  allowNamedExports: { type: "boolean" }
                },
                additionalProperties: false
              }
            ]
          }
        ],
        messages: {
          usedBeforeDefined: "'{{name}}' was used before it was defined."
        }
      },
      create(context) {
        const options = parseOptions(context.options[0]);
        const sourceCode = context.sourceCode;
        function shouldCheck(reference) {
          if (reference.init) {
            return false;
          }
          const { identifier } = reference;
          if (options.allowNamedExports && identifier.parent.type === "ExportSpecifier" && identifier.parent.local === identifier) {
            return false;
          }
          const variable = reference.resolved;
          if (!variable || variable.defs.length === 0) {
            return false;
          }
          const definitionType = variable.defs[0].type;
          if (!options.functions && definitionType === "FunctionName") {
            return false;
          }
          if ((!options.variables && definitionType === "Variable" || !options.classes && definitionType === "ClassName") && // don't skip checking the reference if it's in the same execution context, because of TDZ
          isFromSeparateExecutionContext(reference)) {
            return false;
          }
          return true;
        }
        function checkReferencesInScope(scope) {
          scope.references.filter(shouldCheck).forEach((reference) => {
            const variable = reference.resolved;
            const definitionIdentifier = variable.defs[0].name;
            if (reference.identifier.range[1] < definitionIdentifier.range[1] || isEvaluatedDuringInitialization(reference)) {
              context.report({
                node: reference.identifier,
                messageId: "usedBeforeDefined",
                data: reference.identifier
              });
            }
          });
          scope.childScopes.forEach(checkReferencesInScope);
        }
        return {
          Program(node) {
            checkReferencesInScope(sourceCode.getScope(node));
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-useless-backreference.js
var require_no_useless_backreference = __commonJS({
  "../../node_modules/eslint/lib/rules/no-useless-backreference.js"(exports, module) {
    "use strict";
    var { CALL, CONSTRUCT, ReferenceTracker, getStringIfConstant } = require_eslint_utils();
    var { RegExpParser, visitRegExpAST } = require_regexpp();
    var parser = new RegExpParser();
    function getPathToRoot(node) {
      const path = [];
      let current = node;
      do {
        path.push(current);
        current = current.parent;
      } while (current);
      return path;
    }
    function isLookaround(node) {
      return node.type === "Assertion" && (node.kind === "lookahead" || node.kind === "lookbehind");
    }
    function isNegativeLookaround(node) {
      return isLookaround(node) && node.negate;
    }
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow useless backreferences in regular expressions",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-useless-backreference"
        },
        schema: [],
        messages: {
          nested: "Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' from within that group.",
          forward: "Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which appears later in the pattern.",
          backward: "Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which appears before in the same lookbehind.",
          disjunctive: "Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which is in another alternative.",
          intoNegativeLookaround: "Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which is in a negative lookaround."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        function checkRegex(node, pattern, flags) {
          let regExpAST;
          try {
            regExpAST = parser.parsePattern(pattern, 0, pattern.length, flags.includes("u"));
          } catch {
            return;
          }
          visitRegExpAST(regExpAST, {
            onBackreferenceEnter(bref) {
              const group = bref.resolved, brefPath = getPathToRoot(bref), groupPath = getPathToRoot(group);
              let messageId = null;
              if (brefPath.includes(group)) {
                messageId = "nested";
              } else {
                let i = brefPath.length - 1, j = groupPath.length - 1;
                do {
                  i--;
                  j--;
                } while (brefPath[i] === groupPath[j]);
                const indexOfLowestCommonAncestor = j + 1, groupCut = groupPath.slice(0, indexOfLowestCommonAncestor), commonPath = groupPath.slice(indexOfLowestCommonAncestor), lowestCommonLookaround = commonPath.find(isLookaround), isMatchingBackward = lowestCommonLookaround && lowestCommonLookaround.kind === "lookbehind";
                if (!isMatchingBackward && bref.end <= group.start) {
                  messageId = "forward";
                } else if (isMatchingBackward && group.end <= bref.start) {
                  messageId = "backward";
                } else if (groupCut[groupCut.length - 1].type === "Alternative") {
                  messageId = "disjunctive";
                } else if (groupCut.some(isNegativeLookaround)) {
                  messageId = "intoNegativeLookaround";
                }
              }
              if (messageId) {
                context.report({
                  node,
                  messageId,
                  data: {
                    bref: bref.raw,
                    group: group.raw
                  }
                });
              }
            }
          });
        }
        return {
          "Literal[regex]"(node) {
            const { pattern, flags } = node.regex;
            checkRegex(node, pattern, flags);
          },
          Program(node) {
            const scope = sourceCode.getScope(node), tracker = new ReferenceTracker(scope), traceMap = {
              RegExp: {
                [CALL]: true,
                [CONSTRUCT]: true
              }
            };
            for (const { node: refNode } of tracker.iterateGlobalReferences(traceMap)) {
              const [patternNode, flagsNode] = refNode.arguments, pattern = getStringIfConstant(patternNode, scope), flags = getStringIfConstant(flagsNode, scope);
              if (typeof pattern === "string") {
                checkRegex(refNode, pattern, flags || "");
              }
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-useless-call.js
var require_no_useless_call = __commonJS({
  "../../node_modules/eslint/lib/rules/no-useless-call.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    function isCallOrNonVariadicApply(node) {
      const callee = astUtils.skipChainExpression(node.callee);
      return callee.type === "MemberExpression" && callee.property.type === "Identifier" && callee.computed === false && (callee.property.name === "call" && node.arguments.length >= 1 || callee.property.name === "apply" && node.arguments.length === 2 && node.arguments[1].type === "ArrayExpression");
    }
    function isValidThisArg(expectedThis, thisArg, sourceCode) {
      if (!expectedThis) {
        return astUtils.isNullOrUndefined(thisArg);
      }
      return astUtils.equalTokens(expectedThis, thisArg, sourceCode);
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow unnecessary calls to `.call()` and `.apply()`",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-useless-call"
        },
        schema: [],
        messages: {
          unnecessaryCall: "Unnecessary '.{{name}}()'."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        return {
          CallExpression(node) {
            if (!isCallOrNonVariadicApply(node)) {
              return;
            }
            const callee = astUtils.skipChainExpression(node.callee);
            const applied = astUtils.skipChainExpression(callee.object);
            const expectedThis = applied.type === "MemberExpression" ? applied.object : null;
            const thisArg = node.arguments[0];
            if (isValidThisArg(expectedThis, thisArg, sourceCode)) {
              context.report({ node, messageId: "unnecessaryCall", data: { name: callee.property.name } });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-useless-catch.js
var require_no_useless_catch = __commonJS({
  "../../node_modules/eslint/lib/rules/no-useless-catch.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow unnecessary `catch` clauses",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-useless-catch"
        },
        schema: [],
        messages: {
          unnecessaryCatchClause: "Unnecessary catch clause.",
          unnecessaryCatch: "Unnecessary try/catch wrapper."
        }
      },
      create(context) {
        return {
          CatchClause(node) {
            if (node.param && node.param.type === "Identifier" && node.body.body.length && node.body.body[0].type === "ThrowStatement" && node.body.body[0].argument.type === "Identifier" && node.body.body[0].argument.name === node.param.name) {
              if (node.parent.finalizer) {
                context.report({
                  node,
                  messageId: "unnecessaryCatchClause"
                });
              } else {
                context.report({
                  node: node.parent,
                  messageId: "unnecessaryCatch"
                });
              }
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-useless-computed-key.js
var require_no_useless_computed_key = __commonJS({
  "../../node_modules/eslint/lib/rules/no-useless-computed-key.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    function hasUselessComputedKey(node) {
      if (!node.computed) {
        return false;
      }
      const { key } = node;
      if (key.type !== "Literal") {
        return false;
      }
      const { value } = key;
      if (typeof value !== "number" && typeof value !== "string") {
        return false;
      }
      switch (node.type) {
        case "Property":
          return value !== "__proto__";
        case "PropertyDefinition":
          if (node.static) {
            return value !== "constructor" && value !== "prototype";
          }
          return value !== "constructor";
        case "MethodDefinition":
          if (node.static) {
            return value !== "prototype";
          }
          return value !== "constructor";
        default:
          throw new Error(`Unexpected node type: ${node.type}`);
      }
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow unnecessary computed property keys in objects and classes",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-useless-computed-key"
        },
        schema: [{
          type: "object",
          properties: {
            enforceForClassMembers: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }],
        fixable: "code",
        messages: {
          unnecessarilyComputedProperty: "Unnecessarily computed property [{{property}}] found."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        const enforceForClassMembers = context.options[0] && context.options[0].enforceForClassMembers;
        function check(node) {
          if (hasUselessComputedKey(node)) {
            const { key } = node;
            context.report({
              node,
              messageId: "unnecessarilyComputedProperty",
              data: { property: sourceCode.getText(key) },
              fix(fixer) {
                const leftSquareBracket = sourceCode.getTokenBefore(key, astUtils.isOpeningBracketToken);
                const rightSquareBracket = sourceCode.getTokenAfter(key, astUtils.isClosingBracketToken);
                if (sourceCode.commentsExistBetween(leftSquareBracket, rightSquareBracket)) {
                  return null;
                }
                const tokenBeforeLeftBracket = sourceCode.getTokenBefore(leftSquareBracket);
                const needsSpaceBeforeKey = tokenBeforeLeftBracket.range[1] === leftSquareBracket.range[0] && !astUtils.canTokensBeAdjacent(tokenBeforeLeftBracket, sourceCode.getFirstToken(key));
                const replacementKey = (needsSpaceBeforeKey ? " " : "") + key.raw;
                return fixer.replaceTextRange([leftSquareBracket.range[0], rightSquareBracket.range[1]], replacementKey);
              }
            });
          }
        }
        function noop() {
        }
        return {
          Property: check,
          MethodDefinition: enforceForClassMembers ? check : noop,
          PropertyDefinition: enforceForClassMembers ? check : noop
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-useless-concat.js
var require_no_useless_concat = __commonJS({
  "../../node_modules/eslint/lib/rules/no-useless-concat.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    function isConcatenation(node) {
      return node.type === "BinaryExpression" && node.operator === "+";
    }
    function isConcatOperatorToken(token) {
      return token.value === "+" && token.type === "Punctuator";
    }
    function getLeft(node) {
      let left = node.left;
      while (isConcatenation(left)) {
        left = left.right;
      }
      return left;
    }
    function getRight(node) {
      let right = node.right;
      while (isConcatenation(right)) {
        right = right.left;
      }
      return right;
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow unnecessary concatenation of literals or template literals",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-useless-concat"
        },
        schema: [],
        messages: {
          unexpectedConcat: "Unexpected string concatenation of literals."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        return {
          BinaryExpression(node) {
            if (node.operator !== "+") {
              return;
            }
            const left = getLeft(node);
            const right = getRight(node);
            if (astUtils.isStringLiteral(left) && astUtils.isStringLiteral(right) && astUtils.isTokenOnSameLine(left, right)) {
              const operatorToken = sourceCode.getFirstTokenBetween(left, right, isConcatOperatorToken);
              context.report({
                node,
                loc: operatorToken.loc,
                messageId: "unexpectedConcat"
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-useless-constructor.js
var require_no_useless_constructor = __commonJS({
  "../../node_modules/eslint/lib/rules/no-useless-constructor.js"(exports, module) {
    "use strict";
    function isSingleSuperCall(body) {
      return body.length === 1 && body[0].type === "ExpressionStatement" && body[0].expression.type === "CallExpression" && body[0].expression.callee.type === "Super";
    }
    function isSimple(node) {
      return node.type === "Identifier" || node.type === "RestElement";
    }
    function isSpreadArguments(superArgs) {
      return superArgs.length === 1 && superArgs[0].type === "SpreadElement" && superArgs[0].argument.type === "Identifier" && superArgs[0].argument.name === "arguments";
    }
    function isValidIdentifierPair(ctorParam, superArg) {
      return ctorParam.type === "Identifier" && superArg.type === "Identifier" && ctorParam.name === superArg.name;
    }
    function isValidRestSpreadPair(ctorParam, superArg) {
      return ctorParam.type === "RestElement" && superArg.type === "SpreadElement" && isValidIdentifierPair(ctorParam.argument, superArg.argument);
    }
    function isValidPair(ctorParam, superArg) {
      return isValidIdentifierPair(ctorParam, superArg) || isValidRestSpreadPair(ctorParam, superArg);
    }
    function isPassingThrough(ctorParams, superArgs) {
      if (ctorParams.length !== superArgs.length) {
        return false;
      }
      for (let i = 0; i < ctorParams.length; ++i) {
        if (!isValidPair(ctorParams[i], superArgs[i])) {
          return false;
        }
      }
      return true;
    }
    function isRedundantSuperCall(body, ctorParams) {
      return isSingleSuperCall(body) && ctorParams.every(isSimple) && (isSpreadArguments(body[0].expression.arguments) || isPassingThrough(ctorParams, body[0].expression.arguments));
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow unnecessary constructors",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-useless-constructor"
        },
        schema: [],
        messages: {
          noUselessConstructor: "Useless constructor."
        }
      },
      create(context) {
        function checkForConstructor(node) {
          if (node.kind !== "constructor") {
            return;
          }
          if (!node.value.body) {
            return;
          }
          const body = node.value.body.body;
          const ctorParams = node.value.params;
          const superClass = node.parent.parent.superClass;
          if (superClass ? isRedundantSuperCall(body, ctorParams) : body.length === 0) {
            context.report({
              node,
              messageId: "noUselessConstructor"
            });
          }
        }
        return {
          MethodDefinition: checkForConstructor
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-useless-escape.js
var require_no_useless_escape = __commonJS({
  "../../node_modules/eslint/lib/rules/no-useless-escape.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    function union(setA, setB) {
      return new Set(function* () {
        yield* setA;
        yield* setB;
      }());
    }
    var VALID_STRING_ESCAPES = union(new Set("\\nrvtbfux"), astUtils.LINEBREAKS);
    var REGEX_GENERAL_ESCAPES = new Set("\\bcdDfnpPrsStvwWxu0123456789]");
    var REGEX_NON_CHARCLASS_ESCAPES = union(REGEX_GENERAL_ESCAPES, new Set("^/.$*+?[{}|()Bk"));
    function parseRegExp(regExpText) {
      const charList = [];
      regExpText.split("").reduce((state, char, index) => {
        if (!state.escapeNextChar) {
          if (char === "\\") {
            return Object.assign(state, { escapeNextChar: true });
          }
          if (char === "[" && !state.inCharClass) {
            return Object.assign(state, { inCharClass: true, startingCharClass: true });
          }
          if (char === "]" && state.inCharClass) {
            if (charList.length && charList[charList.length - 1].inCharClass) {
              charList[charList.length - 1].endsCharClass = true;
            }
            return Object.assign(state, { inCharClass: false, startingCharClass: false });
          }
        }
        charList.push({
          text: char,
          index,
          escaped: state.escapeNextChar,
          inCharClass: state.inCharClass,
          startsCharClass: state.startingCharClass,
          endsCharClass: false
        });
        return Object.assign(state, { escapeNextChar: false, startingCharClass: false });
      }, { escapeNextChar: false, inCharClass: false, startingCharClass: false });
      return charList;
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow unnecessary escape characters",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-useless-escape"
        },
        hasSuggestions: true,
        messages: {
          unnecessaryEscape: "Unnecessary escape character: \\{{character}}.",
          removeEscape: "Remove the `\\`. This maintains the current functionality.",
          removeEscapeDoNotKeepSemantics: "Remove the `\\` if it was inserted by mistake.",
          escapeBackslash: "Replace the `\\` with `\\\\` to include the actual backslash character."
        },
        schema: []
      },
      create(context) {
        const sourceCode = context.sourceCode;
        function report(node, startOffset, character) {
          const rangeStart = node.range[0] + startOffset;
          const range = [rangeStart, rangeStart + 1];
          const start = sourceCode.getLocFromIndex(rangeStart);
          context.report({
            node,
            loc: {
              start,
              end: { line: start.line, column: start.column + 1 }
            },
            messageId: "unnecessaryEscape",
            data: { character },
            suggest: [
              {
                // Removing unnecessary `\` characters in a directive is not guaranteed to maintain functionality.
                messageId: astUtils.isDirective(node.parent) ? "removeEscapeDoNotKeepSemantics" : "removeEscape",
                fix(fixer) {
                  return fixer.removeRange(range);
                }
              },
              {
                messageId: "escapeBackslash",
                fix(fixer) {
                  return fixer.insertTextBeforeRange(range, "\\");
                }
              }
            ]
          });
        }
        function validateString(node, match) {
          const isTemplateElement = node.type === "TemplateElement";
          const escapedChar = match[0][1];
          let isUnnecessaryEscape = !VALID_STRING_ESCAPES.has(escapedChar);
          let isQuoteEscape;
          if (isTemplateElement) {
            isQuoteEscape = escapedChar === "`";
            if (escapedChar === "$") {
              isUnnecessaryEscape = match.input[match.index + 2] !== "{";
            } else if (escapedChar === "{") {
              isUnnecessaryEscape = match.input[match.index - 1] !== "$";
            }
          } else {
            isQuoteEscape = escapedChar === node.raw[0];
          }
          if (isUnnecessaryEscape && !isQuoteEscape) {
            report(node, match.index, match[0].slice(1));
          }
        }
        function check(node) {
          const isTemplateElement = node.type === "TemplateElement";
          if (isTemplateElement && node.parent && node.parent.parent && node.parent.parent.type === "TaggedTemplateExpression" && node.parent === node.parent.parent.quasi) {
            return;
          }
          if (typeof node.value === "string" || isTemplateElement) {
            if (node.parent.type === "JSXAttribute" || node.parent.type === "JSXElement" || node.parent.type === "JSXFragment") {
              return;
            }
            const value = isTemplateElement ? sourceCode.getText(node) : node.raw;
            const pattern = /\\[^\d]/gu;
            let match;
            while (match = pattern.exec(value)) {
              validateString(node, match);
            }
          } else if (node.regex) {
            parseRegExp(node.regex.pattern).filter((charInfo) => !(charInfo.text === "-" && charInfo.inCharClass && !charInfo.startsCharClass && !charInfo.endsCharClass)).filter((charInfo) => !(charInfo.text === "^" && charInfo.startsCharClass)).filter((charInfo) => charInfo.escaped).filter((charInfo) => !(charInfo.inCharClass ? REGEX_GENERAL_ESCAPES : REGEX_NON_CHARCLASS_ESCAPES).has(charInfo.text)).forEach((charInfo) => report(node, charInfo.index, charInfo.text));
          }
        }
        return {
          Literal: check,
          TemplateElement: check
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-useless-rename.js
var require_no_useless_rename = __commonJS({
  "../../node_modules/eslint/lib/rules/no-useless-rename.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow renaming import, export, and destructured assignments to the same name",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-useless-rename"
        },
        fixable: "code",
        schema: [
          {
            type: "object",
            properties: {
              ignoreDestructuring: { type: "boolean", default: false },
              ignoreImport: { type: "boolean", default: false },
              ignoreExport: { type: "boolean", default: false }
            },
            additionalProperties: false
          }
        ],
        messages: {
          unnecessarilyRenamed: "{{type}} {{name}} unnecessarily renamed."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode, options = context.options[0] || {}, ignoreDestructuring = options.ignoreDestructuring === true, ignoreImport = options.ignoreImport === true, ignoreExport = options.ignoreExport === true;
        function reportError(node, initial, type) {
          const name = initial.type === "Identifier" ? initial.name : initial.value;
          return context.report({
            node,
            messageId: "unnecessarilyRenamed",
            data: {
              name,
              type
            },
            fix(fixer) {
              const replacementNode = node.type === "Property" ? node.value : node.local;
              if (sourceCode.getCommentsInside(node).length > sourceCode.getCommentsInside(replacementNode).length) {
                return null;
              }
              if (replacementNode.type === "AssignmentPattern" && astUtils.isParenthesised(sourceCode, replacementNode.left)) {
                return null;
              }
              return fixer.replaceText(node, sourceCode.getText(replacementNode));
            }
          });
        }
        function checkDestructured(node) {
          if (ignoreDestructuring) {
            return;
          }
          for (const property of node.properties) {
            if (property.type !== "Property" || property.shorthand || property.computed) {
              continue;
            }
            const key = property.key.type === "Identifier" && property.key.name || property.key.type === "Literal" && property.key.value;
            const renamedKey = property.value.type === "AssignmentPattern" ? property.value.left.name : property.value.name;
            if (key === renamedKey) {
              reportError(property, property.key, "Destructuring assignment");
            }
          }
        }
        function checkImport(node) {
          if (ignoreImport) {
            return;
          }
          if (node.imported.range[0] !== node.local.range[0] && astUtils.getModuleExportName(node.imported) === node.local.name) {
            reportError(node, node.imported, "Import");
          }
        }
        function checkExport(node) {
          if (ignoreExport) {
            return;
          }
          if (node.local.range[0] !== node.exported.range[0] && astUtils.getModuleExportName(node.local) === astUtils.getModuleExportName(node.exported)) {
            reportError(node, node.local, "Export");
          }
        }
        return {
          ObjectPattern: checkDestructured,
          ImportSpecifier: checkImport,
          ExportSpecifier: checkExport
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-useless-return.js
var require_no_useless_return = __commonJS({
  "../../node_modules/eslint/lib/rules/no-useless-return.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var FixTracker = require_fix_tracker();
    function remove(array, element) {
      const index = array.indexOf(element);
      if (index !== -1) {
        array.splice(index, 1);
      }
    }
    function isRemovable(node) {
      return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);
    }
    function isInFinally(node) {
      for (let currentNode = node; currentNode && currentNode.parent && !astUtils.isFunction(currentNode); currentNode = currentNode.parent) {
        if (currentNode.parent.type === "TryStatement" && currentNode.parent.finalizer === currentNode) {
          return true;
        }
      }
      return false;
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow redundant return statements",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-useless-return"
        },
        fixable: "code",
        schema: [],
        messages: {
          unnecessaryReturn: "Unnecessary return statement."
        }
      },
      create(context) {
        const segmentInfoMap = /* @__PURE__ */ new WeakMap();
        const sourceCode = context.sourceCode;
        let scopeInfo = null;
        function isReturned(segment) {
          const info = segmentInfoMap.get(segment);
          return !info || info.returned;
        }
        function getUselessReturns(uselessReturns, prevSegments, providedTraversedSegments) {
          const traversedSegments = providedTraversedSegments || /* @__PURE__ */ new WeakSet();
          for (const segment of prevSegments) {
            if (!segment.reachable) {
              if (!traversedSegments.has(segment)) {
                traversedSegments.add(segment);
                getUselessReturns(
                  uselessReturns,
                  segment.allPrevSegments.filter(isReturned),
                  traversedSegments
                );
              }
              continue;
            }
            uselessReturns.push(...segmentInfoMap.get(segment).uselessReturns);
          }
          return uselessReturns;
        }
        function markReturnStatementsOnSegmentAsUsed(segment, usedUnreachableSegments) {
          if (!segment.reachable) {
            usedUnreachableSegments.add(segment);
            segment.allPrevSegments.filter(isReturned).filter((prevSegment) => !usedUnreachableSegments.has(prevSegment)).forEach((prevSegment) => markReturnStatementsOnSegmentAsUsed(prevSegment, usedUnreachableSegments));
            return;
          }
          const info = segmentInfoMap.get(segment);
          info.uselessReturns = info.uselessReturns.filter((node) => {
            if (scopeInfo.traversedTryBlockStatements && scopeInfo.traversedTryBlockStatements.length > 0) {
              const returnInitialRange = node.range[0];
              const returnFinalRange = node.range[1];
              const areBlocksInRange = scopeInfo.traversedTryBlockStatements.some((tryBlockStatement) => {
                const blockInitialRange = tryBlockStatement.range[0];
                const blockFinalRange = tryBlockStatement.range[1];
                return returnInitialRange >= blockInitialRange && returnFinalRange <= blockFinalRange;
              });
              if (areBlocksInRange) {
                return true;
              }
            }
            remove(scopeInfo.uselessReturns, node);
            return false;
          });
        }
        function markReturnStatementsOnCurrentSegmentsAsUsed() {
          scopeInfo.codePath.currentSegments.forEach((segment) => markReturnStatementsOnSegmentAsUsed(segment, /* @__PURE__ */ new Set()));
        }
        return {
          // Makes and pushes a new scope information.
          onCodePathStart(codePath) {
            scopeInfo = {
              upper: scopeInfo,
              uselessReturns: [],
              traversedTryBlockStatements: [],
              codePath
            };
          },
          // Reports useless return statements if exist.
          onCodePathEnd() {
            for (const node of scopeInfo.uselessReturns) {
              context.report({
                node,
                loc: node.loc,
                messageId: "unnecessaryReturn",
                fix(fixer) {
                  if (isRemovable(node) && !sourceCode.getCommentsInside(node).length) {
                    return new FixTracker(fixer, sourceCode).retainEnclosingFunction(node).remove(node);
                  }
                  return null;
                }
              });
            }
            scopeInfo = scopeInfo.upper;
          },
          /*
           * Initializes segments.
           * NOTE: This event is notified for only reachable segments.
           */
          onCodePathSegmentStart(segment) {
            const info = {
              uselessReturns: getUselessReturns([], segment.allPrevSegments),
              returned: false
            };
            segmentInfoMap.set(segment, info);
          },
          // Adds ReturnStatement node to check whether it's useless or not.
          ReturnStatement(node) {
            if (node.argument) {
              markReturnStatementsOnCurrentSegmentsAsUsed();
            }
            if (node.argument || astUtils.isInLoop(node) || isInFinally(node) || // Ignore `return` statements in unreachable places (https://github.com/eslint/eslint/issues/11647).
            !scopeInfo.codePath.currentSegments.some((s) => s.reachable)) {
              return;
            }
            for (const segment of scopeInfo.codePath.currentSegments) {
              const info = segmentInfoMap.get(segment);
              if (info) {
                info.uselessReturns.push(node);
                info.returned = true;
              }
            }
            scopeInfo.uselessReturns.push(node);
          },
          "TryStatement > BlockStatement.block:exit"(node) {
            scopeInfo.traversedTryBlockStatements.push(node);
          },
          "TryStatement:exit"() {
            scopeInfo.traversedTryBlockStatements.pop();
          },
          /*
           * Registers for all statement nodes except FunctionDeclaration, BlockStatement, BreakStatement.
           * Removes return statements of the current segments from the useless return statement list.
           */
          ClassDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
          ContinueStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
          DebuggerStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
          DoWhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
          EmptyStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
          ExpressionStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
          ForInStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
          ForOfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
          ForStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
          IfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
          ImportDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
          LabeledStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
          SwitchStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
          ThrowStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
          TryStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
          VariableDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
          WhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
          WithStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
          ExportNamedDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
          ExportDefaultDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
          ExportAllDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-var.js
var require_no_var = __commonJS({
  "../../node_modules/eslint/lib/rules/no-var.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    function isGlobal(variable) {
      return Boolean(variable.scope) && variable.scope.type === "global";
    }
    function getEnclosingFunctionScope(scope) {
      let currentScope = scope;
      while (currentScope.type !== "function" && currentScope.type !== "global") {
        currentScope = currentScope.upper;
      }
      return currentScope;
    }
    function isReferencedInClosure(variable) {
      const enclosingFunctionScope = getEnclosingFunctionScope(variable.scope);
      return variable.references.some((reference) => getEnclosingFunctionScope(reference.from) !== enclosingFunctionScope);
    }
    function isLoopAssignee(node) {
      return (node.parent.type === "ForOfStatement" || node.parent.type === "ForInStatement") && node === node.parent.left;
    }
    function isDeclarationInitialized(node) {
      return node.declarations.every((declarator) => declarator.init !== null);
    }
    var SCOPE_NODE_TYPE = /^(?:Program|BlockStatement|SwitchStatement|ForStatement|ForInStatement|ForOfStatement)$/u;
    function getScopeNode(node) {
      for (let currentNode = node; currentNode; currentNode = currentNode.parent) {
        if (SCOPE_NODE_TYPE.test(currentNode.type)) {
          return currentNode;
        }
      }
      return null;
    }
    function isRedeclared(variable) {
      return variable.defs.length >= 2;
    }
    function isUsedFromOutsideOf(scopeNode) {
      function isOutsideOfScope(reference) {
        const scope = scopeNode.range;
        const id = reference.identifier.range;
        return id[0] < scope[0] || id[1] > scope[1];
      }
      return function(variable) {
        return variable.references.some(isOutsideOfScope);
      };
    }
    function hasReferenceInTDZ(node) {
      const initStart = node.range[0];
      const initEnd = node.range[1];
      return (variable) => {
        const id = variable.defs[0].name;
        const idStart = id.range[0];
        const defaultValue = id.parent.type === "AssignmentPattern" ? id.parent.right : null;
        const defaultStart = defaultValue && defaultValue.range[0];
        const defaultEnd = defaultValue && defaultValue.range[1];
        return variable.references.some((reference) => {
          const start = reference.identifier.range[0];
          const end = reference.identifier.range[1];
          return !reference.init && (start < idStart || defaultValue !== null && start >= defaultStart && end <= defaultEnd || !astUtils.isFunction(node) && start >= initStart && end <= initEnd);
        });
      };
    }
    function hasNameDisallowedForLetDeclarations(variable) {
      return variable.name === "let";
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Require `let` or `const` instead of `var`",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-var"
        },
        schema: [],
        fixable: "code",
        messages: {
          unexpectedVar: "Unexpected var, use let or const instead."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        function hasSelfReferenceInTDZ(declarator) {
          if (!declarator.init) {
            return false;
          }
          const variables = sourceCode.getDeclaredVariables(declarator);
          return variables.some(hasReferenceInTDZ(declarator.init));
        }
        function canFix(node) {
          const variables = sourceCode.getDeclaredVariables(node);
          const scopeNode = getScopeNode(node);
          if (node.parent.type === "SwitchCase" || node.declarations.some(hasSelfReferenceInTDZ) || variables.some(isGlobal) || variables.some(isRedeclared) || variables.some(isUsedFromOutsideOf(scopeNode)) || variables.some(hasNameDisallowedForLetDeclarations)) {
            return false;
          }
          if (astUtils.isInLoop(node)) {
            if (variables.some(isReferencedInClosure)) {
              return false;
            }
            if (!isLoopAssignee(node) && !isDeclarationInitialized(node)) {
              return false;
            }
          }
          if (!isLoopAssignee(node) && !(node.parent.type === "ForStatement" && node.parent.init === node) && !astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {
            return false;
          }
          return true;
        }
        function report(node) {
          context.report({
            node,
            messageId: "unexpectedVar",
            fix(fixer) {
              const varToken = sourceCode.getFirstToken(node, { filter: (t) => t.value === "var" });
              return canFix(node) ? fixer.replaceText(varToken, "let") : null;
            }
          });
        }
        return {
          "VariableDeclaration:exit"(node) {
            if (node.kind === "var") {
              report(node);
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-void.js
var require_no_void = __commonJS({
  "../../node_modules/eslint/lib/rules/no-void.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow `void` operators",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-void"
        },
        messages: {
          noVoid: "Expected 'undefined' and instead saw 'void'."
        },
        schema: [
          {
            type: "object",
            properties: {
              allowAsStatement: {
                type: "boolean",
                default: false
              }
            },
            additionalProperties: false
          }
        ]
      },
      create(context) {
        const allowAsStatement = context.options[0] && context.options[0].allowAsStatement;
        return {
          'UnaryExpression[operator="void"]'(node) {
            if (allowAsStatement && node.parent && node.parent.type === "ExpressionStatement") {
              return;
            }
            context.report({
              node,
              messageId: "noVoid"
            });
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-warning-comments.js
var require_no_warning_comments = __commonJS({
  "../../node_modules/eslint/lib/rules/no-warning-comments.js"(exports, module) {
    "use strict";
    var escapeRegExp = require_escape_string_regexp();
    var astUtils = require_ast_utils2();
    var CHAR_LIMIT = 40;
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow specified warning terms in comments",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-warning-comments"
        },
        schema: [
          {
            type: "object",
            properties: {
              terms: {
                type: "array",
                items: {
                  type: "string"
                }
              },
              location: {
                enum: ["start", "anywhere"]
              },
              decoration: {
                type: "array",
                items: {
                  type: "string",
                  pattern: "^\\S$"
                },
                minItems: 1,
                uniqueItems: true
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          unexpectedComment: "Unexpected '{{matchedTerm}}' comment: '{{comment}}'."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode, configuration = context.options[0] || {}, warningTerms = configuration.terms || ["todo", "fixme", "xxx"], location = configuration.location || "start", decoration = [...configuration.decoration || []].join(""), selfConfigRegEx = /\bno-warning-comments\b/u;
        function convertToRegExp(term) {
          const escaped = escapeRegExp(term);
          const escapedDecoration = escapeRegExp(decoration);
          const wordBoundary = "\\b";
          let prefix = "";
          if (location === "start") {
            prefix = `^[\\s${escapedDecoration}]*`;
          } else if (/^\w/u.test(term)) {
            prefix = wordBoundary;
          }
          const suffix = /\w$/u.test(term) ? wordBoundary : "";
          const flags = "iu";
          return new RegExp(`${prefix}${escaped}${suffix}`, flags);
        }
        const warningRegExps = warningTerms.map(convertToRegExp);
        function commentContainsWarningTerm(comment) {
          const matches = [];
          warningRegExps.forEach((regex, index) => {
            if (regex.test(comment)) {
              matches.push(warningTerms[index]);
            }
          });
          return matches;
        }
        function checkComment(node) {
          const comment = node.value;
          if (astUtils.isDirectiveComment(node) && selfConfigRegEx.test(comment)) {
            return;
          }
          const matches = commentContainsWarningTerm(comment);
          matches.forEach((matchedTerm) => {
            let commentToDisplay = "";
            let truncated = false;
            for (const c of comment.trim().split(/\s+/u)) {
              const tmp = commentToDisplay ? `${commentToDisplay} ${c}` : c;
              if (tmp.length <= CHAR_LIMIT) {
                commentToDisplay = tmp;
              } else {
                truncated = true;
                break;
              }
            }
            context.report({
              node,
              messageId: "unexpectedComment",
              data: {
                matchedTerm,
                comment: `${commentToDisplay}${truncated ? "..." : ""}`
              }
            });
          });
        }
        return {
          Program() {
            const comments = sourceCode.getAllComments();
            comments.filter((token) => token.type !== "Shebang").forEach(checkComment);
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-whitespace-before-property.js
var require_no_whitespace_before_property = __commonJS({
  "../../node_modules/eslint/lib/rules/no-whitespace-before-property.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Disallow whitespace before properties",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/no-whitespace-before-property"
        },
        fixable: "whitespace",
        schema: [],
        messages: {
          unexpectedWhitespace: "Unexpected whitespace before property {{propName}}."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        function reportError(node, leftToken, rightToken) {
          context.report({
            node,
            messageId: "unexpectedWhitespace",
            data: {
              propName: sourceCode.getText(node.property)
            },
            fix(fixer) {
              let replacementText = "";
              if (!node.computed && !node.optional && astUtils.isDecimalInteger(node.object)) {
                return null;
              }
              if (sourceCode.commentsExistBetween(leftToken, rightToken)) {
                return null;
              }
              if (node.optional) {
                replacementText = "?.";
              } else if (!node.computed) {
                replacementText = ".";
              }
              return fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], replacementText);
            }
          });
        }
        return {
          MemberExpression(node) {
            let rightToken;
            let leftToken;
            if (!astUtils.isTokenOnSameLine(node.object, node.property)) {
              return;
            }
            if (node.computed) {
              rightToken = sourceCode.getTokenBefore(node.property, astUtils.isOpeningBracketToken);
              leftToken = sourceCode.getTokenBefore(rightToken, node.optional ? 1 : 0);
            } else {
              rightToken = sourceCode.getFirstToken(node.property);
              leftToken = sourceCode.getTokenBefore(rightToken, 1);
            }
            if (sourceCode.isSpaceBetweenTokens(leftToken, rightToken)) {
              reportError(node, leftToken, rightToken);
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/no-with.js
var require_no_with = __commonJS({
  "../../node_modules/eslint/lib/rules/no-with.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow `with` statements",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/no-with"
        },
        schema: [],
        messages: {
          unexpectedWith: "Unexpected use of 'with' statement."
        }
      },
      create(context) {
        return {
          WithStatement(node) {
            context.report({ node, messageId: "unexpectedWith" });
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/nonblock-statement-body-position.js
var require_nonblock_statement_body_position = __commonJS({
  "../../node_modules/eslint/lib/rules/nonblock-statement-body-position.js"(exports, module) {
    "use strict";
    var POSITION_SCHEMA = { enum: ["beside", "below", "any"] };
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Enforce the location of single-line statements",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/nonblock-statement-body-position"
        },
        fixable: "whitespace",
        schema: [
          POSITION_SCHEMA,
          {
            properties: {
              overrides: {
                properties: {
                  if: POSITION_SCHEMA,
                  else: POSITION_SCHEMA,
                  while: POSITION_SCHEMA,
                  do: POSITION_SCHEMA,
                  for: POSITION_SCHEMA
                },
                additionalProperties: false
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          expectNoLinebreak: "Expected no linebreak before this statement.",
          expectLinebreak: "Expected a linebreak before this statement."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        function getOption(keywordName) {
          return context.options[1] && context.options[1].overrides && context.options[1].overrides[keywordName] || context.options[0] || "beside";
        }
        function validateStatement(node, keywordName) {
          const option = getOption(keywordName);
          if (node.type === "BlockStatement" || option === "any") {
            return;
          }
          const tokenBefore = sourceCode.getTokenBefore(node);
          if (tokenBefore.loc.end.line === node.loc.start.line && option === "below") {
            context.report({
              node,
              messageId: "expectLinebreak",
              fix: (fixer) => fixer.insertTextBefore(node, "\n")
            });
          } else if (tokenBefore.loc.end.line !== node.loc.start.line && option === "beside") {
            context.report({
              node,
              messageId: "expectNoLinebreak",
              fix(fixer) {
                if (sourceCode.getText().slice(tokenBefore.range[1], node.range[0]).trim()) {
                  return null;
                }
                return fixer.replaceTextRange([tokenBefore.range[1], node.range[0]], " ");
              }
            });
          }
        }
        return {
          IfStatement(node) {
            validateStatement(node.consequent, "if");
            if (node.alternate && node.alternate.type !== "IfStatement") {
              validateStatement(node.alternate, "else");
            }
          },
          WhileStatement: (node) => validateStatement(node.body, "while"),
          DoWhileStatement: (node) => validateStatement(node.body, "do"),
          ForStatement: (node) => validateStatement(node.body, "for"),
          ForInStatement: (node) => validateStatement(node.body, "for"),
          ForOfStatement: (node) => validateStatement(node.body, "for")
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/object-curly-newline.js
var require_object_curly_newline = __commonJS({
  "../../node_modules/eslint/lib/rules/object-curly-newline.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var OPTION_VALUE = {
      oneOf: [
        {
          enum: ["always", "never"]
        },
        {
          type: "object",
          properties: {
            multiline: {
              type: "boolean"
            },
            minProperties: {
              type: "integer",
              minimum: 0
            },
            consistent: {
              type: "boolean"
            }
          },
          additionalProperties: false,
          minProperties: 1
        }
      ]
    };
    function normalizeOptionValue(value) {
      let multiline = false;
      let minProperties = Number.POSITIVE_INFINITY;
      let consistent = false;
      if (value) {
        if (value === "always") {
          minProperties = 0;
        } else if (value === "never") {
          minProperties = Number.POSITIVE_INFINITY;
        } else {
          multiline = Boolean(value.multiline);
          minProperties = value.minProperties || Number.POSITIVE_INFINITY;
          consistent = Boolean(value.consistent);
        }
      } else {
        consistent = true;
      }
      return { multiline, minProperties, consistent };
    }
    function isObject(value) {
      return typeof value === "object" && value !== null;
    }
    function isNodeSpecificOption(option) {
      return isObject(option) || typeof option === "string";
    }
    function normalizeOptions(options) {
      if (isObject(options) && Object.values(options).some(isNodeSpecificOption)) {
        return {
          ObjectExpression: normalizeOptionValue(options.ObjectExpression),
          ObjectPattern: normalizeOptionValue(options.ObjectPattern),
          ImportDeclaration: normalizeOptionValue(options.ImportDeclaration),
          ExportNamedDeclaration: normalizeOptionValue(options.ExportDeclaration)
        };
      }
      const value = normalizeOptionValue(options);
      return { ObjectExpression: value, ObjectPattern: value, ImportDeclaration: value, ExportNamedDeclaration: value };
    }
    function areLineBreaksRequired(node, options, first, last) {
      let objectProperties;
      if (node.type === "ObjectExpression" || node.type === "ObjectPattern") {
        objectProperties = node.properties;
      } else {
        objectProperties = node.specifiers.filter((s) => s.type === "ImportSpecifier" || s.type === "ExportSpecifier");
      }
      return objectProperties.length >= options.minProperties || options.multiline && objectProperties.length > 0 && first.loc.start.line !== last.loc.end.line;
    }
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Enforce consistent line breaks after opening and before closing braces",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/object-curly-newline"
        },
        fixable: "whitespace",
        schema: [
          {
            oneOf: [
              OPTION_VALUE,
              {
                type: "object",
                properties: {
                  ObjectExpression: OPTION_VALUE,
                  ObjectPattern: OPTION_VALUE,
                  ImportDeclaration: OPTION_VALUE,
                  ExportDeclaration: OPTION_VALUE
                },
                additionalProperties: false,
                minProperties: 1
              }
            ]
          }
        ],
        messages: {
          unexpectedLinebreakBeforeClosingBrace: "Unexpected line break before this closing brace.",
          unexpectedLinebreakAfterOpeningBrace: "Unexpected line break after this opening brace.",
          expectedLinebreakBeforeClosingBrace: "Expected a line break before this closing brace.",
          expectedLinebreakAfterOpeningBrace: "Expected a line break after this opening brace."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        const normalizedOptions = normalizeOptions(context.options[0]);
        function check(node) {
          const options = normalizedOptions[node.type];
          if (node.type === "ImportDeclaration" && !node.specifiers.some((specifier) => specifier.type === "ImportSpecifier") || node.type === "ExportNamedDeclaration" && !node.specifiers.some((specifier) => specifier.type === "ExportSpecifier")) {
            return;
          }
          const openBrace = sourceCode.getFirstToken(node, (token) => token.value === "{");
          let closeBrace;
          if (node.typeAnnotation) {
            closeBrace = sourceCode.getTokenBefore(node.typeAnnotation);
          } else {
            closeBrace = sourceCode.getLastToken(node, (token) => token.value === "}");
          }
          let first = sourceCode.getTokenAfter(openBrace, { includeComments: true });
          let last = sourceCode.getTokenBefore(closeBrace, { includeComments: true });
          const needsLineBreaks = areLineBreaksRequired(node, options, first, last);
          const hasCommentsFirstToken = astUtils.isCommentToken(first);
          const hasCommentsLastToken = astUtils.isCommentToken(last);
          first = sourceCode.getTokenAfter(openBrace);
          last = sourceCode.getTokenBefore(closeBrace);
          if (needsLineBreaks) {
            if (astUtils.isTokenOnSameLine(openBrace, first)) {
              context.report({
                messageId: "expectedLinebreakAfterOpeningBrace",
                node,
                loc: openBrace.loc,
                fix(fixer) {
                  if (hasCommentsFirstToken) {
                    return null;
                  }
                  return fixer.insertTextAfter(openBrace, "\n");
                }
              });
            }
            if (astUtils.isTokenOnSameLine(last, closeBrace)) {
              context.report({
                messageId: "expectedLinebreakBeforeClosingBrace",
                node,
                loc: closeBrace.loc,
                fix(fixer) {
                  if (hasCommentsLastToken) {
                    return null;
                  }
                  return fixer.insertTextBefore(closeBrace, "\n");
                }
              });
            }
          } else {
            const consistent = options.consistent;
            const hasLineBreakBetweenOpenBraceAndFirst = !astUtils.isTokenOnSameLine(openBrace, first);
            const hasLineBreakBetweenCloseBraceAndLast = !astUtils.isTokenOnSameLine(last, closeBrace);
            if (!consistent && hasLineBreakBetweenOpenBraceAndFirst || consistent && hasLineBreakBetweenOpenBraceAndFirst && !hasLineBreakBetweenCloseBraceAndLast) {
              context.report({
                messageId: "unexpectedLinebreakAfterOpeningBrace",
                node,
                loc: openBrace.loc,
                fix(fixer) {
                  if (hasCommentsFirstToken) {
                    return null;
                  }
                  return fixer.removeRange([
                    openBrace.range[1],
                    first.range[0]
                  ]);
                }
              });
            }
            if (!consistent && hasLineBreakBetweenCloseBraceAndLast || consistent && !hasLineBreakBetweenOpenBraceAndFirst && hasLineBreakBetweenCloseBraceAndLast) {
              context.report({
                messageId: "unexpectedLinebreakBeforeClosingBrace",
                node,
                loc: closeBrace.loc,
                fix(fixer) {
                  if (hasCommentsLastToken) {
                    return null;
                  }
                  return fixer.removeRange([
                    last.range[1],
                    closeBrace.range[0]
                  ]);
                }
              });
            }
          }
        }
        return {
          ObjectExpression: check,
          ObjectPattern: check,
          ImportDeclaration: check,
          ExportNamedDeclaration: check
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/object-curly-spacing.js
var require_object_curly_spacing = __commonJS({
  "../../node_modules/eslint/lib/rules/object-curly-spacing.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Enforce consistent spacing inside braces",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/object-curly-spacing"
        },
        fixable: "whitespace",
        schema: [
          {
            enum: ["always", "never"]
          },
          {
            type: "object",
            properties: {
              arraysInObjects: {
                type: "boolean"
              },
              objectsInObjects: {
                type: "boolean"
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          requireSpaceBefore: "A space is required before '{{token}}'.",
          requireSpaceAfter: "A space is required after '{{token}}'.",
          unexpectedSpaceBefore: "There should be no space before '{{token}}'.",
          unexpectedSpaceAfter: "There should be no space after '{{token}}'."
        }
      },
      create(context) {
        const spaced = context.options[0] === "always", sourceCode = context.sourceCode;
        function isOptionSet(option) {
          return context.options[1] ? context.options[1][option] === !spaced : false;
        }
        const options = {
          spaced,
          arraysInObjectsException: isOptionSet("arraysInObjects"),
          objectsInObjectsException: isOptionSet("objectsInObjects")
        };
        function reportNoBeginningSpace(node, token) {
          const nextToken = context.sourceCode.getTokenAfter(token, { includeComments: true });
          context.report({
            node,
            loc: { start: token.loc.end, end: nextToken.loc.start },
            messageId: "unexpectedSpaceAfter",
            data: {
              token: token.value
            },
            fix(fixer) {
              return fixer.removeRange([token.range[1], nextToken.range[0]]);
            }
          });
        }
        function reportNoEndingSpace(node, token) {
          const previousToken = context.sourceCode.getTokenBefore(token, { includeComments: true });
          context.report({
            node,
            loc: { start: previousToken.loc.end, end: token.loc.start },
            messageId: "unexpectedSpaceBefore",
            data: {
              token: token.value
            },
            fix(fixer) {
              return fixer.removeRange([previousToken.range[1], token.range[0]]);
            }
          });
        }
        function reportRequiredBeginningSpace(node, token) {
          context.report({
            node,
            loc: token.loc,
            messageId: "requireSpaceAfter",
            data: {
              token: token.value
            },
            fix(fixer) {
              return fixer.insertTextAfter(token, " ");
            }
          });
        }
        function reportRequiredEndingSpace(node, token) {
          context.report({
            node,
            loc: token.loc,
            messageId: "requireSpaceBefore",
            data: {
              token: token.value
            },
            fix(fixer) {
              return fixer.insertTextBefore(token, " ");
            }
          });
        }
        function validateBraceSpacing(node, first, second, penultimate, last) {
          if (astUtils.isTokenOnSameLine(first, second)) {
            const firstSpaced = sourceCode.isSpaceBetweenTokens(first, second);
            if (options.spaced && !firstSpaced) {
              reportRequiredBeginningSpace(node, first);
            }
            if (!options.spaced && firstSpaced && second.type !== "Line") {
              reportNoBeginningSpace(node, first);
            }
          }
          if (astUtils.isTokenOnSameLine(penultimate, last)) {
            const shouldCheckPenultimate = options.arraysInObjectsException && astUtils.isClosingBracketToken(penultimate) || options.objectsInObjectsException && astUtils.isClosingBraceToken(penultimate);
            const penultimateType = shouldCheckPenultimate && sourceCode.getNodeByRangeIndex(penultimate.range[0]).type;
            const closingCurlyBraceMustBeSpaced = options.arraysInObjectsException && penultimateType === "ArrayExpression" || options.objectsInObjectsException && (penultimateType === "ObjectExpression" || penultimateType === "ObjectPattern") ? !options.spaced : options.spaced;
            const lastSpaced = sourceCode.isSpaceBetweenTokens(penultimate, last);
            if (closingCurlyBraceMustBeSpaced && !lastSpaced) {
              reportRequiredEndingSpace(node, last);
            }
            if (!closingCurlyBraceMustBeSpaced && lastSpaced) {
              reportNoEndingSpace(node, last);
            }
          }
        }
        function getClosingBraceOfObject(node) {
          const lastProperty = node.properties[node.properties.length - 1];
          return sourceCode.getTokenAfter(lastProperty, astUtils.isClosingBraceToken);
        }
        function checkForObject(node) {
          if (node.properties.length === 0) {
            return;
          }
          const first = sourceCode.getFirstToken(node), last = getClosingBraceOfObject(node), second = sourceCode.getTokenAfter(first, { includeComments: true }), penultimate = sourceCode.getTokenBefore(last, { includeComments: true });
          validateBraceSpacing(node, first, second, penultimate, last);
        }
        function checkForImport(node) {
          if (node.specifiers.length === 0) {
            return;
          }
          let firstSpecifier = node.specifiers[0];
          const lastSpecifier = node.specifiers[node.specifiers.length - 1];
          if (lastSpecifier.type !== "ImportSpecifier") {
            return;
          }
          if (firstSpecifier.type !== "ImportSpecifier") {
            firstSpecifier = node.specifiers[1];
          }
          const first = sourceCode.getTokenBefore(firstSpecifier), last = sourceCode.getTokenAfter(lastSpecifier, astUtils.isNotCommaToken), second = sourceCode.getTokenAfter(first, { includeComments: true }), penultimate = sourceCode.getTokenBefore(last, { includeComments: true });
          validateBraceSpacing(node, first, second, penultimate, last);
        }
        function checkForExport(node) {
          if (node.specifiers.length === 0) {
            return;
          }
          const firstSpecifier = node.specifiers[0], lastSpecifier = node.specifiers[node.specifiers.length - 1], first = sourceCode.getTokenBefore(firstSpecifier), last = sourceCode.getTokenAfter(lastSpecifier, astUtils.isNotCommaToken), second = sourceCode.getTokenAfter(first, { includeComments: true }), penultimate = sourceCode.getTokenBefore(last, { includeComments: true });
          validateBraceSpacing(node, first, second, penultimate, last);
        }
        return {
          // var {x} = y;
          ObjectPattern: checkForObject,
          // var y = {x: 'y'}
          ObjectExpression: checkForObject,
          // import {y} from 'x';
          ImportDeclaration: checkForImport,
          // export {name} from 'yo';
          ExportNamedDeclaration: checkForExport
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/object-property-newline.js
var require_object_property_newline = __commonJS({
  "../../node_modules/eslint/lib/rules/object-property-newline.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Enforce placing object properties on separate lines",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/object-property-newline"
        },
        schema: [
          {
            type: "object",
            properties: {
              allowAllPropertiesOnSameLine: {
                type: "boolean",
                default: false
              },
              allowMultiplePropertiesPerLine: {
                // Deprecated
                type: "boolean",
                default: false
              }
            },
            additionalProperties: false
          }
        ],
        fixable: "whitespace",
        messages: {
          propertiesOnNewlineAll: "Object properties must go on a new line if they aren't all on the same line.",
          propertiesOnNewline: "Object properties must go on a new line."
        }
      },
      create(context) {
        const allowSameLine = context.options[0] && (context.options[0].allowAllPropertiesOnSameLine || context.options[0].allowMultiplePropertiesPerLine);
        const messageId = allowSameLine ? "propertiesOnNewlineAll" : "propertiesOnNewline";
        const sourceCode = context.sourceCode;
        return {
          ObjectExpression(node) {
            if (allowSameLine) {
              if (node.properties.length > 1) {
                const firstTokenOfFirstProperty = sourceCode.getFirstToken(node.properties[0]);
                const lastTokenOfLastProperty = sourceCode.getLastToken(node.properties[node.properties.length - 1]);
                if (firstTokenOfFirstProperty.loc.end.line === lastTokenOfLastProperty.loc.start.line) {
                  return;
                }
              }
            }
            for (let i = 1; i < node.properties.length; i++) {
              const lastTokenOfPreviousProperty = sourceCode.getLastToken(node.properties[i - 1]);
              const firstTokenOfCurrentProperty = sourceCode.getFirstToken(node.properties[i]);
              if (lastTokenOfPreviousProperty.loc.end.line === firstTokenOfCurrentProperty.loc.start.line) {
                context.report({
                  node,
                  loc: firstTokenOfCurrentProperty.loc,
                  messageId,
                  fix(fixer) {
                    const comma = sourceCode.getTokenBefore(firstTokenOfCurrentProperty);
                    const rangeAfterComma = [comma.range[1], firstTokenOfCurrentProperty.range[0]];
                    if (sourceCode.text.slice(rangeAfterComma[0], rangeAfterComma[1]).trim()) {
                      return null;
                    }
                    return fixer.replaceTextRange(rangeAfterComma, "\n");
                  }
                });
              }
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/object-shorthand.js
var require_object_shorthand = __commonJS({
  "../../node_modules/eslint/lib/rules/object-shorthand.js"(exports, module) {
    "use strict";
    var OPTIONS = {
      always: "always",
      never: "never",
      methods: "methods",
      properties: "properties",
      consistent: "consistent",
      consistentAsNeeded: "consistent-as-needed"
    };
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Require or disallow method and property shorthand syntax for object literals",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/object-shorthand"
        },
        fixable: "code",
        schema: {
          anyOf: [
            {
              type: "array",
              items: [
                {
                  enum: ["always", "methods", "properties", "never", "consistent", "consistent-as-needed"]
                }
              ],
              minItems: 0,
              maxItems: 1
            },
            {
              type: "array",
              items: [
                {
                  enum: ["always", "methods", "properties"]
                },
                {
                  type: "object",
                  properties: {
                    avoidQuotes: {
                      type: "boolean"
                    }
                  },
                  additionalProperties: false
                }
              ],
              minItems: 0,
              maxItems: 2
            },
            {
              type: "array",
              items: [
                {
                  enum: ["always", "methods"]
                },
                {
                  type: "object",
                  properties: {
                    ignoreConstructors: {
                      type: "boolean"
                    },
                    methodsIgnorePattern: {
                      type: "string"
                    },
                    avoidQuotes: {
                      type: "boolean"
                    },
                    avoidExplicitReturnArrows: {
                      type: "boolean"
                    }
                  },
                  additionalProperties: false
                }
              ],
              minItems: 0,
              maxItems: 2
            }
          ]
        },
        messages: {
          expectedAllPropertiesShorthanded: "Expected shorthand for all properties.",
          expectedLiteralMethodLongform: "Expected longform method syntax for string literal keys.",
          expectedPropertyShorthand: "Expected property shorthand.",
          expectedPropertyLongform: "Expected longform property syntax.",
          expectedMethodShorthand: "Expected method shorthand.",
          expectedMethodLongform: "Expected longform method syntax.",
          unexpectedMix: "Unexpected mix of shorthand and non-shorthand properties."
        }
      },
      create(context) {
        const APPLY = context.options[0] || OPTIONS.always;
        const APPLY_TO_METHODS = APPLY === OPTIONS.methods || APPLY === OPTIONS.always;
        const APPLY_TO_PROPS = APPLY === OPTIONS.properties || APPLY === OPTIONS.always;
        const APPLY_NEVER = APPLY === OPTIONS.never;
        const APPLY_CONSISTENT = APPLY === OPTIONS.consistent;
        const APPLY_CONSISTENT_AS_NEEDED = APPLY === OPTIONS.consistentAsNeeded;
        const PARAMS = context.options[1] || {};
        const IGNORE_CONSTRUCTORS = PARAMS.ignoreConstructors;
        const METHODS_IGNORE_PATTERN = PARAMS.methodsIgnorePattern ? new RegExp(PARAMS.methodsIgnorePattern, "u") : null;
        const AVOID_QUOTES = PARAMS.avoidQuotes;
        const AVOID_EXPLICIT_RETURN_ARROWS = !!PARAMS.avoidExplicitReturnArrows;
        const sourceCode = context.sourceCode;
        const CTOR_PREFIX_REGEX = /[^_$0-9]/u;
        function isConstructor(name) {
          const match = CTOR_PREFIX_REGEX.exec(name);
          if (!match) {
            return false;
          }
          const firstChar = name.charAt(match.index);
          return firstChar === firstChar.toUpperCase();
        }
        function canHaveShorthand(property) {
          return property.kind !== "set" && property.kind !== "get" && property.type !== "SpreadElement" && property.type !== "SpreadProperty" && property.type !== "ExperimentalSpreadProperty";
        }
        function isStringLiteral(node) {
          return node.type === "Literal" && typeof node.value === "string";
        }
        function isShorthand(property) {
          return property.shorthand || property.method;
        }
        function isRedundant(property) {
          const value = property.value;
          if (value.type === "FunctionExpression") {
            return !value.id;
          }
          if (value.type === "Identifier") {
            return astUtils.getStaticPropertyName(property) === value.name;
          }
          return false;
        }
        function checkConsistency(node, checkRedundancy) {
          const properties = node.properties.filter(canHaveShorthand);
          if (properties.length > 0) {
            const shorthandProperties = properties.filter(isShorthand);
            if (shorthandProperties.length !== properties.length) {
              if (shorthandProperties.length > 0) {
                context.report({ node, messageId: "unexpectedMix" });
              } else if (checkRedundancy) {
                const canAlwaysUseShorthand = properties.every(isRedundant);
                if (canAlwaysUseShorthand) {
                  context.report({ node, messageId: "expectedAllPropertiesShorthanded" });
                }
              }
            }
          }
        }
        function makeFunctionShorthand(fixer, node) {
          const firstKeyToken = node.computed ? sourceCode.getFirstToken(node, astUtils.isOpeningBracketToken) : sourceCode.getFirstToken(node.key);
          const lastKeyToken = node.computed ? sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isClosingBracketToken) : sourceCode.getLastToken(node.key);
          const keyText = sourceCode.text.slice(firstKeyToken.range[0], lastKeyToken.range[1]);
          let keyPrefix = "";
          if (sourceCode.commentsExistBetween(lastKeyToken, node.value)) {
            return null;
          }
          if (node.value.async) {
            keyPrefix += "async ";
          }
          if (node.value.generator) {
            keyPrefix += "*";
          }
          const fixRange = [firstKeyToken.range[0], node.range[1]];
          const methodPrefix = keyPrefix + keyText;
          if (node.value.type === "FunctionExpression") {
            const functionToken = sourceCode.getTokens(node.value).find((token) => token.type === "Keyword" && token.value === "function");
            const tokenBeforeParams2 = node.value.generator ? sourceCode.getTokenAfter(functionToken) : functionToken;
            return fixer.replaceTextRange(
              fixRange,
              methodPrefix + sourceCode.text.slice(tokenBeforeParams2.range[1], node.value.range[1])
            );
          }
          const arrowToken = sourceCode.getTokenBefore(node.value.body, astUtils.isArrowToken);
          const fnBody = sourceCode.text.slice(arrowToken.range[1], node.value.range[1]);
          let shouldAddParensAroundParameters = false;
          let tokenBeforeParams;
          if (node.value.params.length === 0) {
            tokenBeforeParams = sourceCode.getFirstToken(node.value, astUtils.isOpeningParenToken);
          } else {
            tokenBeforeParams = sourceCode.getTokenBefore(node.value.params[0]);
          }
          if (node.value.params.length === 1) {
            const hasParen = astUtils.isOpeningParenToken(tokenBeforeParams);
            const isTokenOutsideNode = tokenBeforeParams.range[0] < node.range[0];
            shouldAddParensAroundParameters = !hasParen || isTokenOutsideNode;
          }
          const sliceStart = shouldAddParensAroundParameters ? node.value.params[0].range[0] : tokenBeforeParams.range[0];
          const sliceEnd = sourceCode.getTokenBefore(arrowToken).range[1];
          const oldParamText = sourceCode.text.slice(sliceStart, sliceEnd);
          const newParamText = shouldAddParensAroundParameters ? `(${oldParamText})` : oldParamText;
          return fixer.replaceTextRange(
            fixRange,
            methodPrefix + newParamText + fnBody
          );
        }
        function makeFunctionLongform(fixer, node) {
          const firstKeyToken = node.computed ? sourceCode.getTokens(node).find((token) => token.value === "[") : sourceCode.getFirstToken(node.key);
          const lastKeyToken = node.computed ? sourceCode.getTokensBetween(node.key, node.value).find((token) => token.value === "]") : sourceCode.getLastToken(node.key);
          const keyText = sourceCode.text.slice(firstKeyToken.range[0], lastKeyToken.range[1]);
          let functionHeader = "function";
          if (node.value.async) {
            functionHeader = `async ${functionHeader}`;
          }
          if (node.value.generator) {
            functionHeader = `${functionHeader}*`;
          }
          return fixer.replaceTextRange([node.range[0], lastKeyToken.range[1]], `${keyText}: ${functionHeader}`);
        }
        const lexicalScopeStack = [];
        const arrowsWithLexicalIdentifiers = /* @__PURE__ */ new WeakSet();
        const argumentsIdentifiers = /* @__PURE__ */ new WeakSet();
        function enterFunction(node) {
          lexicalScopeStack.unshift(/* @__PURE__ */ new Set());
          sourceCode.getScope(node).variables.filter((variable) => variable.name === "arguments").forEach((variable) => {
            variable.references.map((ref) => ref.identifier).forEach((identifier) => argumentsIdentifiers.add(identifier));
          });
        }
        function exitFunction() {
          lexicalScopeStack.shift();
        }
        function reportLexicalIdentifier() {
          lexicalScopeStack[0].forEach((arrowFunction) => arrowsWithLexicalIdentifiers.add(arrowFunction));
        }
        return {
          Program: enterFunction,
          FunctionDeclaration: enterFunction,
          FunctionExpression: enterFunction,
          "Program:exit": exitFunction,
          "FunctionDeclaration:exit": exitFunction,
          "FunctionExpression:exit": exitFunction,
          ArrowFunctionExpression(node) {
            lexicalScopeStack[0].add(node);
          },
          "ArrowFunctionExpression:exit"(node) {
            lexicalScopeStack[0].delete(node);
          },
          ThisExpression: reportLexicalIdentifier,
          Super: reportLexicalIdentifier,
          MetaProperty(node) {
            if (node.meta.name === "new" && node.property.name === "target") {
              reportLexicalIdentifier();
            }
          },
          Identifier(node) {
            if (argumentsIdentifiers.has(node)) {
              reportLexicalIdentifier();
            }
          },
          ObjectExpression(node) {
            if (APPLY_CONSISTENT) {
              checkConsistency(node, false);
            } else if (APPLY_CONSISTENT_AS_NEEDED) {
              checkConsistency(node, true);
            }
          },
          "Property:exit"(node) {
            const isConciseProperty = node.method || node.shorthand;
            if (node.parent.type === "ObjectPattern") {
              return;
            }
            if (node.kind === "get" || node.kind === "set") {
              return;
            }
            if (node.computed && node.value.type !== "FunctionExpression" && node.value.type !== "ArrowFunctionExpression") {
              return;
            }
            if (isConciseProperty) {
              if (node.method && (APPLY_NEVER || AVOID_QUOTES && isStringLiteral(node.key))) {
                const messageId = APPLY_NEVER ? "expectedMethodLongform" : "expectedLiteralMethodLongform";
                context.report({
                  node,
                  messageId,
                  fix: (fixer) => makeFunctionLongform(fixer, node)
                });
              } else if (APPLY_NEVER) {
                context.report({
                  node,
                  messageId: "expectedPropertyLongform",
                  fix: (fixer) => fixer.insertTextAfter(node.key, `: ${node.key.name}`)
                });
              }
            } else if (APPLY_TO_METHODS && !node.value.id && (node.value.type === "FunctionExpression" || node.value.type === "ArrowFunctionExpression")) {
              if (IGNORE_CONSTRUCTORS && node.key.type === "Identifier" && isConstructor(node.key.name)) {
                return;
              }
              if (METHODS_IGNORE_PATTERN) {
                const propertyName = astUtils.getStaticPropertyName(node);
                if (propertyName !== null && METHODS_IGNORE_PATTERN.test(propertyName)) {
                  return;
                }
              }
              if (AVOID_QUOTES && isStringLiteral(node.key)) {
                return;
              }
              if (node.value.type === "FunctionExpression" || node.value.type === "ArrowFunctionExpression" && node.value.body.type === "BlockStatement" && AVOID_EXPLICIT_RETURN_ARROWS && !arrowsWithLexicalIdentifiers.has(node.value)) {
                context.report({
                  node,
                  messageId: "expectedMethodShorthand",
                  fix: (fixer) => makeFunctionShorthand(fixer, node)
                });
              }
            } else if (node.value.type === "Identifier" && node.key.name === node.value.name && APPLY_TO_PROPS) {
              context.report({
                node,
                messageId: "expectedPropertyShorthand",
                fix(fixer) {
                  return fixer.replaceText(node, node.value.name);
                }
              });
            } else if (node.value.type === "Identifier" && node.key.type === "Literal" && node.key.value === node.value.name && APPLY_TO_PROPS) {
              if (AVOID_QUOTES) {
                return;
              }
              context.report({
                node,
                messageId: "expectedPropertyShorthand",
                fix(fixer) {
                  return fixer.replaceText(node, node.value.name);
                }
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/one-var.js
var require_one_var = __commonJS({
  "../../node_modules/eslint/lib/rules/one-var.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    function isInStatementList(node) {
      return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Enforce variables to be declared either together or separately in functions",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/one-var"
        },
        fixable: "code",
        schema: [
          {
            oneOf: [
              {
                enum: ["always", "never", "consecutive"]
              },
              {
                type: "object",
                properties: {
                  separateRequires: {
                    type: "boolean"
                  },
                  var: {
                    enum: ["always", "never", "consecutive"]
                  },
                  let: {
                    enum: ["always", "never", "consecutive"]
                  },
                  const: {
                    enum: ["always", "never", "consecutive"]
                  }
                },
                additionalProperties: false
              },
              {
                type: "object",
                properties: {
                  initialized: {
                    enum: ["always", "never", "consecutive"]
                  },
                  uninitialized: {
                    enum: ["always", "never", "consecutive"]
                  }
                },
                additionalProperties: false
              }
            ]
          }
        ],
        messages: {
          combineUninitialized: "Combine this with the previous '{{type}}' statement with uninitialized variables.",
          combineInitialized: "Combine this with the previous '{{type}}' statement with initialized variables.",
          splitUninitialized: "Split uninitialized '{{type}}' declarations into multiple statements.",
          splitInitialized: "Split initialized '{{type}}' declarations into multiple statements.",
          splitRequires: "Split requires to be separated into a single block.",
          combine: "Combine this with the previous '{{type}}' statement.",
          split: "Split '{{type}}' declarations into multiple statements."
        }
      },
      create(context) {
        const MODE_ALWAYS = "always";
        const MODE_NEVER = "never";
        const MODE_CONSECUTIVE = "consecutive";
        const mode = context.options[0] || MODE_ALWAYS;
        const options = {};
        if (typeof mode === "string") {
          options.var = { uninitialized: mode, initialized: mode };
          options.let = { uninitialized: mode, initialized: mode };
          options.const = { uninitialized: mode, initialized: mode };
        } else if (typeof mode === "object") {
          options.separateRequires = !!mode.separateRequires;
          options.var = { uninitialized: mode.var, initialized: mode.var };
          options.let = { uninitialized: mode.let, initialized: mode.let };
          options.const = { uninitialized: mode.const, initialized: mode.const };
          if (Object.prototype.hasOwnProperty.call(mode, "uninitialized")) {
            options.var.uninitialized = mode.uninitialized;
            options.let.uninitialized = mode.uninitialized;
            options.const.uninitialized = mode.uninitialized;
          }
          if (Object.prototype.hasOwnProperty.call(mode, "initialized")) {
            options.var.initialized = mode.initialized;
            options.let.initialized = mode.initialized;
            options.const.initialized = mode.initialized;
          }
        }
        const sourceCode = context.sourceCode;
        const functionStack = [];
        const blockStack = [];
        function startBlock() {
          blockStack.push({
            let: { initialized: false, uninitialized: false },
            const: { initialized: false, uninitialized: false }
          });
        }
        function startFunction() {
          functionStack.push({ initialized: false, uninitialized: false });
          startBlock();
        }
        function endBlock() {
          blockStack.pop();
        }
        function endFunction() {
          functionStack.pop();
          endBlock();
        }
        function isRequire(decl) {
          return decl.init && decl.init.type === "CallExpression" && decl.init.callee.name === "require";
        }
        function recordTypes(statementType, declarations, currentScope) {
          for (let i = 0; i < declarations.length; i++) {
            if (declarations[i].init === null) {
              if (options[statementType] && options[statementType].uninitialized === MODE_ALWAYS) {
                currentScope.uninitialized = true;
              }
            } else {
              if (options[statementType] && options[statementType].initialized === MODE_ALWAYS) {
                if (options.separateRequires && isRequire(declarations[i])) {
                  currentScope.required = true;
                } else {
                  currentScope.initialized = true;
                }
              }
            }
          }
        }
        function getCurrentScope(statementType) {
          let currentScope;
          if (statementType === "var") {
            currentScope = functionStack[functionStack.length - 1];
          } else if (statementType === "let") {
            currentScope = blockStack[blockStack.length - 1].let;
          } else if (statementType === "const") {
            currentScope = blockStack[blockStack.length - 1].const;
          }
          return currentScope;
        }
        function countDeclarations(declarations) {
          const counts = { uninitialized: 0, initialized: 0 };
          for (let i = 0; i < declarations.length; i++) {
            if (declarations[i].init === null) {
              counts.uninitialized++;
            } else {
              counts.initialized++;
            }
          }
          return counts;
        }
        function hasOnlyOneStatement(statementType, declarations) {
          const declarationCounts = countDeclarations(declarations);
          const currentOptions = options[statementType] || {};
          const currentScope = getCurrentScope(statementType);
          const hasRequires = declarations.some(isRequire);
          if (currentOptions.uninitialized === MODE_ALWAYS && currentOptions.initialized === MODE_ALWAYS) {
            if (currentScope.uninitialized || currentScope.initialized) {
              if (!hasRequires) {
                return false;
              }
            }
          }
          if (declarationCounts.uninitialized > 0) {
            if (currentOptions.uninitialized === MODE_ALWAYS && currentScope.uninitialized) {
              return false;
            }
          }
          if (declarationCounts.initialized > 0) {
            if (currentOptions.initialized === MODE_ALWAYS && currentScope.initialized) {
              if (!hasRequires) {
                return false;
              }
            }
          }
          if (currentScope.required && hasRequires) {
            return false;
          }
          recordTypes(statementType, declarations, currentScope);
          return true;
        }
        function joinDeclarations(declarations) {
          const declaration = declarations[0];
          const body = Array.isArray(declaration.parent.parent.body) ? declaration.parent.parent.body : [];
          const currentIndex = body.findIndex((node) => node.range[0] === declaration.parent.range[0]);
          const previousNode = body[currentIndex - 1];
          return (fixer) => {
            const type = sourceCode.getTokenBefore(declaration);
            const prevSemi = sourceCode.getTokenBefore(type);
            const res = [];
            if (previousNode && previousNode.kind === sourceCode.getText(type)) {
              if (prevSemi.value === ";") {
                res.push(fixer.replaceText(prevSemi, ","));
              } else {
                res.push(fixer.insertTextAfter(prevSemi, ","));
              }
              res.push(fixer.replaceText(type, ""));
            }
            return res;
          };
        }
        function splitDeclarations(declaration) {
          const { parent } = declaration;
          if (!isInStatementList(parent.type === "ExportNamedDeclaration" ? parent : declaration)) {
            return null;
          }
          return (fixer) => declaration.declarations.map((declarator) => {
            const tokenAfterDeclarator = sourceCode.getTokenAfter(declarator);
            if (tokenAfterDeclarator === null) {
              return null;
            }
            const afterComma = sourceCode.getTokenAfter(tokenAfterDeclarator, { includeComments: true });
            if (tokenAfterDeclarator.value !== ",") {
              return null;
            }
            const exportPlacement = declaration.parent.type === "ExportNamedDeclaration" ? "export " : "";
            if (afterComma.range[0] === tokenAfterDeclarator.range[1]) {
              return fixer.replaceText(tokenAfterDeclarator, `; ${exportPlacement}${declaration.kind} `);
            }
            if (afterComma.loc.start.line > tokenAfterDeclarator.loc.end.line || afterComma.type === "Line" || afterComma.type === "Block") {
              let lastComment = afterComma;
              while (lastComment.type === "Line" || lastComment.type === "Block") {
                lastComment = sourceCode.getTokenAfter(lastComment, { includeComments: true });
              }
              return fixer.replaceTextRange(
                [tokenAfterDeclarator.range[0], lastComment.range[0]],
                `;${sourceCode.text.slice(tokenAfterDeclarator.range[1], lastComment.range[0])}${exportPlacement}${declaration.kind} `
              );
            }
            return fixer.replaceText(tokenAfterDeclarator, `; ${exportPlacement}${declaration.kind}`);
          }).filter((x) => x);
        }
        function checkVariableDeclaration(node) {
          const parent = node.parent;
          const type = node.kind;
          if (!options[type]) {
            return;
          }
          const declarations = node.declarations;
          const declarationCounts = countDeclarations(declarations);
          const mixedRequires = declarations.some(isRequire) && !declarations.every(isRequire);
          if (options[type].initialized === MODE_ALWAYS) {
            if (options.separateRequires && mixedRequires) {
              context.report({
                node,
                messageId: "splitRequires"
              });
            }
          }
          const nodeIndex = parent.body && parent.body.length > 0 && parent.body.indexOf(node) || 0;
          if (nodeIndex > 0) {
            const previousNode = parent.body[nodeIndex - 1];
            const isPreviousNodeDeclaration = previousNode.type === "VariableDeclaration";
            const declarationsWithPrevious = declarations.concat(previousNode.declarations || []);
            if (isPreviousNodeDeclaration && previousNode.kind === type && !(declarationsWithPrevious.some(isRequire) && !declarationsWithPrevious.every(isRequire))) {
              const previousDeclCounts = countDeclarations(previousNode.declarations);
              if (options[type].initialized === MODE_CONSECUTIVE && options[type].uninitialized === MODE_CONSECUTIVE) {
                context.report({
                  node,
                  messageId: "combine",
                  data: {
                    type
                  },
                  fix: joinDeclarations(declarations)
                });
              } else if (options[type].initialized === MODE_CONSECUTIVE && declarationCounts.initialized > 0 && previousDeclCounts.initialized > 0) {
                context.report({
                  node,
                  messageId: "combineInitialized",
                  data: {
                    type
                  },
                  fix: joinDeclarations(declarations)
                });
              } else if (options[type].uninitialized === MODE_CONSECUTIVE && declarationCounts.uninitialized > 0 && previousDeclCounts.uninitialized > 0) {
                context.report({
                  node,
                  messageId: "combineUninitialized",
                  data: {
                    type
                  },
                  fix: joinDeclarations(declarations)
                });
              }
            }
          }
          if (!hasOnlyOneStatement(type, declarations)) {
            if (options[type].initialized === MODE_ALWAYS && options[type].uninitialized === MODE_ALWAYS) {
              context.report({
                node,
                messageId: "combine",
                data: {
                  type
                },
                fix: joinDeclarations(declarations)
              });
            } else {
              if (options[type].initialized === MODE_ALWAYS && declarationCounts.initialized > 0) {
                context.report({
                  node,
                  messageId: "combineInitialized",
                  data: {
                    type
                  },
                  fix: joinDeclarations(declarations)
                });
              }
              if (options[type].uninitialized === MODE_ALWAYS && declarationCounts.uninitialized > 0) {
                if (node.parent.left === node && (node.parent.type === "ForInStatement" || node.parent.type === "ForOfStatement")) {
                  return;
                }
                context.report({
                  node,
                  messageId: "combineUninitialized",
                  data: {
                    type
                  },
                  fix: joinDeclarations(declarations)
                });
              }
            }
          }
          if (parent.type !== "ForStatement" || parent.init !== node) {
            const totalDeclarations = declarationCounts.uninitialized + declarationCounts.initialized;
            if (totalDeclarations > 1) {
              if (options[type].initialized === MODE_NEVER && options[type].uninitialized === MODE_NEVER) {
                context.report({
                  node,
                  messageId: "split",
                  data: {
                    type
                  },
                  fix: splitDeclarations(node)
                });
              } else if (options[type].initialized === MODE_NEVER && declarationCounts.initialized > 0) {
                context.report({
                  node,
                  messageId: "splitInitialized",
                  data: {
                    type
                  },
                  fix: splitDeclarations(node)
                });
              } else if (options[type].uninitialized === MODE_NEVER && declarationCounts.uninitialized > 0) {
                context.report({
                  node,
                  messageId: "splitUninitialized",
                  data: {
                    type
                  },
                  fix: splitDeclarations(node)
                });
              }
            }
          }
        }
        return {
          Program: startFunction,
          FunctionDeclaration: startFunction,
          FunctionExpression: startFunction,
          ArrowFunctionExpression: startFunction,
          StaticBlock: startFunction,
          // StaticBlock creates a new scope for `var` variables
          BlockStatement: startBlock,
          ForStatement: startBlock,
          ForInStatement: startBlock,
          ForOfStatement: startBlock,
          SwitchStatement: startBlock,
          VariableDeclaration: checkVariableDeclaration,
          "ForStatement:exit": endBlock,
          "ForOfStatement:exit": endBlock,
          "ForInStatement:exit": endBlock,
          "SwitchStatement:exit": endBlock,
          "BlockStatement:exit": endBlock,
          "Program:exit": endFunction,
          "FunctionDeclaration:exit": endFunction,
          "FunctionExpression:exit": endFunction,
          "ArrowFunctionExpression:exit": endFunction,
          "StaticBlock:exit": endFunction
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/one-var-declaration-per-line.js
var require_one_var_declaration_per_line = __commonJS({
  "../../node_modules/eslint/lib/rules/one-var-declaration-per-line.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Require or disallow newlines around variable declarations",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/one-var-declaration-per-line"
        },
        schema: [
          {
            enum: ["always", "initializations"]
          }
        ],
        fixable: "whitespace",
        messages: {
          expectVarOnNewline: "Expected variable declaration to be on a new line."
        }
      },
      create(context) {
        const always = context.options[0] === "always";
        function isForTypeSpecifier(keyword) {
          return keyword === "ForStatement" || keyword === "ForInStatement" || keyword === "ForOfStatement";
        }
        function checkForNewLine(node) {
          if (isForTypeSpecifier(node.parent.type)) {
            return;
          }
          const declarations = node.declarations;
          let prev;
          declarations.forEach((current) => {
            if (prev && prev.loc.end.line === current.loc.start.line) {
              if (always || prev.init || current.init) {
                context.report({
                  node,
                  messageId: "expectVarOnNewline",
                  loc: current.loc,
                  fix: (fixer) => fixer.insertTextBefore(current, "\n")
                });
              }
            }
            prev = current;
          });
        }
        return {
          VariableDeclaration: checkForNewLine
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/operator-assignment.js
var require_operator_assignment = __commonJS({
  "../../node_modules/eslint/lib/rules/operator-assignment.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    function isCommutativeOperatorWithShorthand(operator) {
      return ["*", "&", "^", "|"].includes(operator);
    }
    function isNonCommutativeOperatorWithShorthand(operator) {
      return ["+", "-", "/", "%", "<<", ">>", ">>>", "**"].includes(operator);
    }
    function canBeFixed(node) {
      return node.type === "Identifier" || node.type === "MemberExpression" && (node.object.type === "Identifier" || node.object.type === "ThisExpression") && (!node.computed || node.property.type === "Literal");
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Require or disallow assignment operator shorthand where possible",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/operator-assignment"
        },
        schema: [
          {
            enum: ["always", "never"]
          }
        ],
        fixable: "code",
        messages: {
          replaced: "Assignment (=) can be replaced with operator assignment ({{operator}}).",
          unexpected: "Unexpected operator assignment ({{operator}}) shorthand."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        function getOperatorToken(node) {
          return sourceCode.getFirstTokenBetween(node.left, node.right, (token) => token.value === node.operator);
        }
        function verify(node) {
          if (node.operator !== "=" || node.right.type !== "BinaryExpression") {
            return;
          }
          const left = node.left;
          const expr = node.right;
          const operator = expr.operator;
          if (isCommutativeOperatorWithShorthand(operator) || isNonCommutativeOperatorWithShorthand(operator)) {
            const replacementOperator = `${operator}=`;
            if (astUtils.isSameReference(left, expr.left, true)) {
              context.report({
                node,
                messageId: "replaced",
                data: { operator: replacementOperator },
                fix(fixer) {
                  if (canBeFixed(left) && canBeFixed(expr.left)) {
                    const equalsToken = getOperatorToken(node);
                    const operatorToken = getOperatorToken(expr);
                    const leftText = sourceCode.getText().slice(node.range[0], equalsToken.range[0]);
                    const rightText = sourceCode.getText().slice(operatorToken.range[1], node.right.range[1]);
                    if (sourceCode.commentsExistBetween(equalsToken, operatorToken)) {
                      return null;
                    }
                    return fixer.replaceText(node, `${leftText}${replacementOperator}${rightText}`);
                  }
                  return null;
                }
              });
            } else if (astUtils.isSameReference(left, expr.right, true) && isCommutativeOperatorWithShorthand(operator)) {
              context.report({
                node,
                messageId: "replaced",
                data: { operator: replacementOperator }
              });
            }
          }
        }
        function prohibit(node) {
          if (node.operator !== "=" && !astUtils.isLogicalAssignmentOperator(node.operator)) {
            context.report({
              node,
              messageId: "unexpected",
              data: { operator: node.operator },
              fix(fixer) {
                if (canBeFixed(node.left)) {
                  const firstToken = sourceCode.getFirstToken(node);
                  const operatorToken = getOperatorToken(node);
                  const leftText = sourceCode.getText().slice(node.range[0], operatorToken.range[0]);
                  const newOperator = node.operator.slice(0, -1);
                  let rightText;
                  if (sourceCode.commentsExistBetween(firstToken, operatorToken)) {
                    return null;
                  }
                  if (astUtils.getPrecedence(node.right) <= astUtils.getPrecedence({ type: "BinaryExpression", operator: newOperator }) && !astUtils.isParenthesised(sourceCode, node.right)) {
                    rightText = `${sourceCode.text.slice(operatorToken.range[1], node.right.range[0])}(${sourceCode.getText(node.right)})`;
                  } else {
                    const tokenAfterOperator = sourceCode.getTokenAfter(operatorToken, { includeComments: true });
                    let rightTextPrefix = "";
                    if (operatorToken.range[1] === tokenAfterOperator.range[0] && !astUtils.canTokensBeAdjacent({ type: "Punctuator", value: newOperator }, tokenAfterOperator)) {
                      rightTextPrefix = " ";
                    }
                    rightText = `${rightTextPrefix}${sourceCode.text.slice(operatorToken.range[1], node.range[1])}`;
                  }
                  return fixer.replaceText(node, `${leftText}= ${leftText}${newOperator}${rightText}`);
                }
                return null;
              }
            });
          }
        }
        return {
          AssignmentExpression: context.options[0] !== "never" ? verify : prohibit
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/operator-linebreak.js
var require_operator_linebreak = __commonJS({
  "../../node_modules/eslint/lib/rules/operator-linebreak.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Enforce consistent linebreak style for operators",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/operator-linebreak"
        },
        schema: [
          {
            enum: ["after", "before", "none", null]
          },
          {
            type: "object",
            properties: {
              overrides: {
                type: "object",
                additionalProperties: {
                  enum: ["after", "before", "none", "ignore"]
                }
              }
            },
            additionalProperties: false
          }
        ],
        fixable: "code",
        messages: {
          operatorAtBeginning: "'{{operator}}' should be placed at the beginning of the line.",
          operatorAtEnd: "'{{operator}}' should be placed at the end of the line.",
          badLinebreak: "Bad line breaking before and after '{{operator}}'.",
          noLinebreak: "There should be no line break before or after '{{operator}}'."
        }
      },
      create(context) {
        const usedDefaultGlobal = !context.options[0];
        const globalStyle = context.options[0] || "after";
        const options = context.options[1] || {};
        const styleOverrides = options.overrides ? Object.assign({}, options.overrides) : {};
        if (usedDefaultGlobal && !styleOverrides["?"]) {
          styleOverrides["?"] = "before";
        }
        if (usedDefaultGlobal && !styleOverrides[":"]) {
          styleOverrides[":"] = "before";
        }
        const sourceCode = context.sourceCode;
        function getFixer(operatorToken, desiredStyle) {
          return (fixer) => {
            const tokenBefore = sourceCode.getTokenBefore(operatorToken);
            const tokenAfter = sourceCode.getTokenAfter(operatorToken);
            const textBefore = sourceCode.text.slice(tokenBefore.range[1], operatorToken.range[0]);
            const textAfter = sourceCode.text.slice(operatorToken.range[1], tokenAfter.range[0]);
            const hasLinebreakBefore = !astUtils.isTokenOnSameLine(tokenBefore, operatorToken);
            const hasLinebreakAfter = !astUtils.isTokenOnSameLine(operatorToken, tokenAfter);
            let newTextBefore, newTextAfter;
            if (hasLinebreakBefore !== hasLinebreakAfter && desiredStyle !== "none") {
              if (sourceCode.getTokenBefore(operatorToken, { includeComments: true }) !== tokenBefore && sourceCode.getTokenAfter(operatorToken, { includeComments: true }) !== tokenAfter) {
                return null;
              }
              newTextBefore = textAfter;
              newTextAfter = textBefore;
            } else {
              const LINEBREAK_REGEX = astUtils.createGlobalLinebreakMatcher();
              newTextBefore = desiredStyle === "before" || textBefore.trim() ? textBefore : textBefore.replace(LINEBREAK_REGEX, "");
              newTextAfter = desiredStyle === "after" || textAfter.trim() ? textAfter : textAfter.replace(LINEBREAK_REGEX, "");
              if (newTextBefore === textBefore && newTextAfter === textAfter) {
                return null;
              }
            }
            if (newTextAfter === "" && tokenAfter.type === "Punctuator" && "+-".includes(operatorToken.value) && tokenAfter.value === operatorToken.value) {
              newTextAfter += " ";
            }
            return fixer.replaceTextRange([tokenBefore.range[1], tokenAfter.range[0]], newTextBefore + operatorToken.value + newTextAfter);
          };
        }
        function validateNode(node, rightSide, operator) {
          const operatorToken = sourceCode.getTokenBefore(rightSide, (token) => token.value === operator);
          const leftToken = sourceCode.getTokenBefore(operatorToken);
          const rightToken = sourceCode.getTokenAfter(operatorToken);
          const operatorStyleOverride = styleOverrides[operator];
          const style = operatorStyleOverride || globalStyle;
          const fix = getFixer(operatorToken, style);
          if (astUtils.isTokenOnSameLine(leftToken, operatorToken) && astUtils.isTokenOnSameLine(operatorToken, rightToken)) {
          } else if (operatorStyleOverride !== "ignore" && !astUtils.isTokenOnSameLine(leftToken, operatorToken) && !astUtils.isTokenOnSameLine(operatorToken, rightToken)) {
            context.report({
              node,
              loc: operatorToken.loc,
              messageId: "badLinebreak",
              data: {
                operator
              },
              fix
            });
          } else if (style === "before" && astUtils.isTokenOnSameLine(leftToken, operatorToken)) {
            context.report({
              node,
              loc: operatorToken.loc,
              messageId: "operatorAtBeginning",
              data: {
                operator
              },
              fix
            });
          } else if (style === "after" && astUtils.isTokenOnSameLine(operatorToken, rightToken)) {
            context.report({
              node,
              loc: operatorToken.loc,
              messageId: "operatorAtEnd",
              data: {
                operator
              },
              fix
            });
          } else if (style === "none") {
            context.report({
              node,
              loc: operatorToken.loc,
              messageId: "noLinebreak",
              data: {
                operator
              },
              fix
            });
          }
        }
        function validateBinaryExpression(node) {
          validateNode(node, node.right, node.operator);
        }
        return {
          BinaryExpression: validateBinaryExpression,
          LogicalExpression: validateBinaryExpression,
          AssignmentExpression: validateBinaryExpression,
          VariableDeclarator(node) {
            if (node.init) {
              validateNode(node, node.init, "=");
            }
          },
          PropertyDefinition(node) {
            if (node.value) {
              validateNode(node, node.value, "=");
            }
          },
          ConditionalExpression(node) {
            validateNode(node, node.consequent, "?");
            validateNode(node, node.alternate, ":");
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/padded-blocks.js
var require_padded_blocks = __commonJS({
  "../../node_modules/eslint/lib/rules/padded-blocks.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Require or disallow padding within blocks",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/padded-blocks"
        },
        fixable: "whitespace",
        schema: [
          {
            oneOf: [
              {
                enum: ["always", "never"]
              },
              {
                type: "object",
                properties: {
                  blocks: {
                    enum: ["always", "never"]
                  },
                  switches: {
                    enum: ["always", "never"]
                  },
                  classes: {
                    enum: ["always", "never"]
                  }
                },
                additionalProperties: false,
                minProperties: 1
              }
            ]
          },
          {
            type: "object",
            properties: {
              allowSingleLineBlocks: {
                type: "boolean"
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          alwaysPadBlock: "Block must be padded by blank lines.",
          neverPadBlock: "Block must not be padded by blank lines."
        }
      },
      create(context) {
        const options = {};
        const typeOptions = context.options[0] || "always";
        const exceptOptions = context.options[1] || {};
        if (typeof typeOptions === "string") {
          const shouldHavePadding = typeOptions === "always";
          options.blocks = shouldHavePadding;
          options.switches = shouldHavePadding;
          options.classes = shouldHavePadding;
        } else {
          if (Object.prototype.hasOwnProperty.call(typeOptions, "blocks")) {
            options.blocks = typeOptions.blocks === "always";
          }
          if (Object.prototype.hasOwnProperty.call(typeOptions, "switches")) {
            options.switches = typeOptions.switches === "always";
          }
          if (Object.prototype.hasOwnProperty.call(typeOptions, "classes")) {
            options.classes = typeOptions.classes === "always";
          }
        }
        if (Object.prototype.hasOwnProperty.call(exceptOptions, "allowSingleLineBlocks")) {
          options.allowSingleLineBlocks = exceptOptions.allowSingleLineBlocks === true;
        }
        const sourceCode = context.sourceCode;
        function getOpenBrace(node) {
          if (node.type === "SwitchStatement") {
            return sourceCode.getTokenBefore(node.cases[0]);
          }
          if (node.type === "StaticBlock") {
            return sourceCode.getFirstToken(node, { skip: 1 });
          }
          return sourceCode.getFirstToken(node);
        }
        function isComment(node) {
          return node.type === "Line" || node.type === "Block";
        }
        function isPaddingBetweenTokens(first, second) {
          return second.loc.start.line - first.loc.end.line >= 2;
        }
        function getFirstBlockToken(token) {
          let prev, first = token;
          do {
            prev = first;
            first = sourceCode.getTokenAfter(first, { includeComments: true });
          } while (isComment(first) && first.loc.start.line === prev.loc.end.line);
          return first;
        }
        function getLastBlockToken(token) {
          let last = token, next;
          do {
            next = last;
            last = sourceCode.getTokenBefore(last, { includeComments: true });
          } while (isComment(last) && last.loc.end.line === next.loc.start.line);
          return last;
        }
        function requirePaddingFor(node) {
          switch (node.type) {
            case "BlockStatement":
            case "StaticBlock":
              return options.blocks;
            case "SwitchStatement":
              return options.switches;
            case "ClassBody":
              return options.classes;
            default:
              throw new Error("unreachable");
          }
        }
        function checkPadding(node) {
          const openBrace = getOpenBrace(node), firstBlockToken = getFirstBlockToken(openBrace), tokenBeforeFirst = sourceCode.getTokenBefore(firstBlockToken, { includeComments: true }), closeBrace = sourceCode.getLastToken(node), lastBlockToken = getLastBlockToken(closeBrace), tokenAfterLast = sourceCode.getTokenAfter(lastBlockToken, { includeComments: true }), blockHasTopPadding = isPaddingBetweenTokens(tokenBeforeFirst, firstBlockToken), blockHasBottomPadding = isPaddingBetweenTokens(lastBlockToken, tokenAfterLast);
          if (options.allowSingleLineBlocks && astUtils.isTokenOnSameLine(tokenBeforeFirst, tokenAfterLast)) {
            return;
          }
          if (requirePaddingFor(node)) {
            if (!blockHasTopPadding) {
              context.report({
                node,
                loc: {
                  start: tokenBeforeFirst.loc.start,
                  end: firstBlockToken.loc.start
                },
                fix(fixer) {
                  return fixer.insertTextAfter(tokenBeforeFirst, "\n");
                },
                messageId: "alwaysPadBlock"
              });
            }
            if (!blockHasBottomPadding) {
              context.report({
                node,
                loc: {
                  end: tokenAfterLast.loc.start,
                  start: lastBlockToken.loc.end
                },
                fix(fixer) {
                  return fixer.insertTextBefore(tokenAfterLast, "\n");
                },
                messageId: "alwaysPadBlock"
              });
            }
          } else {
            if (blockHasTopPadding) {
              context.report({
                node,
                loc: {
                  start: tokenBeforeFirst.loc.start,
                  end: firstBlockToken.loc.start
                },
                fix(fixer) {
                  return fixer.replaceTextRange([tokenBeforeFirst.range[1], firstBlockToken.range[0] - firstBlockToken.loc.start.column], "\n");
                },
                messageId: "neverPadBlock"
              });
            }
            if (blockHasBottomPadding) {
              context.report({
                node,
                loc: {
                  end: tokenAfterLast.loc.start,
                  start: lastBlockToken.loc.end
                },
                messageId: "neverPadBlock",
                fix(fixer) {
                  return fixer.replaceTextRange([lastBlockToken.range[1], tokenAfterLast.range[0] - tokenAfterLast.loc.start.column], "\n");
                }
              });
            }
          }
        }
        const rule = {};
        if (Object.prototype.hasOwnProperty.call(options, "switches")) {
          rule.SwitchStatement = function(node) {
            if (node.cases.length === 0) {
              return;
            }
            checkPadding(node);
          };
        }
        if (Object.prototype.hasOwnProperty.call(options, "blocks")) {
          rule.BlockStatement = function(node) {
            if (node.body.length === 0) {
              return;
            }
            checkPadding(node);
          };
          rule.StaticBlock = rule.BlockStatement;
        }
        if (Object.prototype.hasOwnProperty.call(options, "classes")) {
          rule.ClassBody = function(node) {
            if (node.body.length === 0) {
              return;
            }
            checkPadding(node);
          };
        }
        return rule;
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/padding-line-between-statements.js
var require_padding_line_between_statements = __commonJS({
  "../../node_modules/eslint/lib/rules/padding-line-between-statements.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var LT = `[${Array.from(astUtils.LINEBREAKS).join("")}]`;
    var PADDING_LINE_SEQUENCE = new RegExp(
      String.raw`^(\s*?${LT})\s*${LT}(\s*;?)$`,
      "u"
    );
    var CJS_EXPORT = /^(?:module\s*\.\s*)?exports(?:\s*\.|\s*\[|$)/u;
    var CJS_IMPORT = /^require\(/u;
    function newKeywordTester(keyword) {
      return {
        test: (node, sourceCode) => sourceCode.getFirstToken(node).value === keyword
      };
    }
    function newSinglelineKeywordTester(keyword) {
      return {
        test: (node, sourceCode) => node.loc.start.line === node.loc.end.line && sourceCode.getFirstToken(node).value === keyword
      };
    }
    function newMultilineKeywordTester(keyword) {
      return {
        test: (node, sourceCode) => node.loc.start.line !== node.loc.end.line && sourceCode.getFirstToken(node).value === keyword
      };
    }
    function newNodeTypeTester(type) {
      return {
        test: (node) => node.type === type
      };
    }
    function isIIFEStatement(node) {
      if (node.type === "ExpressionStatement") {
        let call = astUtils.skipChainExpression(node.expression);
        if (call.type === "UnaryExpression") {
          call = astUtils.skipChainExpression(call.argument);
        }
        return call.type === "CallExpression" && astUtils.isFunction(call.callee);
      }
      return false;
    }
    function isBlockLikeStatement(sourceCode, node) {
      if (node.type === "DoWhileStatement" && node.body.type === "BlockStatement") {
        return true;
      }
      if (isIIFEStatement(node)) {
        return true;
      }
      const lastToken = sourceCode.getLastToken(node, astUtils.isNotSemicolonToken);
      const belongingNode = lastToken && astUtils.isClosingBraceToken(lastToken) ? sourceCode.getNodeByRangeIndex(lastToken.range[0]) : null;
      return Boolean(belongingNode) && (belongingNode.type === "BlockStatement" || belongingNode.type === "SwitchStatement");
    }
    function getActualLastToken(sourceCode, node) {
      const semiToken = sourceCode.getLastToken(node);
      const prevToken = sourceCode.getTokenBefore(semiToken);
      const nextToken = sourceCode.getTokenAfter(semiToken);
      const isSemicolonLessStyle = Boolean(
        prevToken && nextToken && prevToken.range[0] >= node.range[0] && astUtils.isSemicolonToken(semiToken) && semiToken.loc.start.line !== prevToken.loc.end.line && semiToken.loc.end.line === nextToken.loc.start.line
      );
      return isSemicolonLessStyle ? prevToken : semiToken;
    }
    function replacerToRemovePaddingLines(_, trailingSpaces, indentSpaces) {
      return trailingSpaces + indentSpaces;
    }
    function verifyForAny() {
    }
    function verifyForNever(context, _, nextNode, paddingLines) {
      if (paddingLines.length === 0) {
        return;
      }
      context.report({
        node: nextNode,
        messageId: "unexpectedBlankLine",
        fix(fixer) {
          if (paddingLines.length >= 2) {
            return null;
          }
          const prevToken = paddingLines[0][0];
          const nextToken = paddingLines[0][1];
          const start = prevToken.range[1];
          const end = nextToken.range[0];
          const text = context.sourceCode.text.slice(start, end).replace(PADDING_LINE_SEQUENCE, replacerToRemovePaddingLines);
          return fixer.replaceTextRange([start, end], text);
        }
      });
    }
    function verifyForAlways(context, prevNode, nextNode, paddingLines) {
      if (paddingLines.length > 0) {
        return;
      }
      context.report({
        node: nextNode,
        messageId: "expectedBlankLine",
        fix(fixer) {
          const sourceCode = context.sourceCode;
          let prevToken = getActualLastToken(sourceCode, prevNode);
          const nextToken = sourceCode.getFirstTokenBetween(
            prevToken,
            nextNode,
            {
              includeComments: true,
              /**
               * Skip the trailing comments of the previous node.
               * This inserts a blank line after the last trailing comment.
               *
               * For example:
               *
               *     foo(); // trailing comment.
               *     // comment.
               *     bar();
               *
               * Get fixed to:
               *
               *     foo(); // trailing comment.
               *
               *     // comment.
               *     bar();
               * @param {Token} token The token to check.
               * @returns {boolean} `true` if the token is not a trailing comment.
               * @private
               */
              filter(token) {
                if (astUtils.isTokenOnSameLine(prevToken, token)) {
                  prevToken = token;
                  return false;
                }
                return true;
              }
            }
          ) || nextNode;
          const insertText = astUtils.isTokenOnSameLine(prevToken, nextToken) ? "\n\n" : "\n";
          return fixer.insertTextAfter(prevToken, insertText);
        }
      });
    }
    var PaddingTypes = {
      any: { verify: verifyForAny },
      never: { verify: verifyForNever },
      always: { verify: verifyForAlways }
    };
    var StatementTypes = {
      "*": { test: () => true },
      "block-like": {
        test: (node, sourceCode) => isBlockLikeStatement(sourceCode, node)
      },
      "cjs-export": {
        test: (node, sourceCode) => node.type === "ExpressionStatement" && node.expression.type === "AssignmentExpression" && CJS_EXPORT.test(sourceCode.getText(node.expression.left))
      },
      "cjs-import": {
        test: (node, sourceCode) => node.type === "VariableDeclaration" && node.declarations.length > 0 && Boolean(node.declarations[0].init) && CJS_IMPORT.test(sourceCode.getText(node.declarations[0].init))
      },
      directive: {
        test: astUtils.isDirective
      },
      expression: {
        test: (node) => node.type === "ExpressionStatement" && !astUtils.isDirective(node)
      },
      iife: {
        test: isIIFEStatement
      },
      "multiline-block-like": {
        test: (node, sourceCode) => node.loc.start.line !== node.loc.end.line && isBlockLikeStatement(sourceCode, node)
      },
      "multiline-expression": {
        test: (node) => node.loc.start.line !== node.loc.end.line && node.type === "ExpressionStatement" && !astUtils.isDirective(node)
      },
      "multiline-const": newMultilineKeywordTester("const"),
      "multiline-let": newMultilineKeywordTester("let"),
      "multiline-var": newMultilineKeywordTester("var"),
      "singleline-const": newSinglelineKeywordTester("const"),
      "singleline-let": newSinglelineKeywordTester("let"),
      "singleline-var": newSinglelineKeywordTester("var"),
      block: newNodeTypeTester("BlockStatement"),
      empty: newNodeTypeTester("EmptyStatement"),
      function: newNodeTypeTester("FunctionDeclaration"),
      break: newKeywordTester("break"),
      case: newKeywordTester("case"),
      class: newKeywordTester("class"),
      const: newKeywordTester("const"),
      continue: newKeywordTester("continue"),
      debugger: newKeywordTester("debugger"),
      default: newKeywordTester("default"),
      do: newKeywordTester("do"),
      export: newKeywordTester("export"),
      for: newKeywordTester("for"),
      if: newKeywordTester("if"),
      import: newKeywordTester("import"),
      let: newKeywordTester("let"),
      return: newKeywordTester("return"),
      switch: newKeywordTester("switch"),
      throw: newKeywordTester("throw"),
      try: newKeywordTester("try"),
      var: newKeywordTester("var"),
      while: newKeywordTester("while"),
      with: newKeywordTester("with")
    };
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Require or disallow padding lines between statements",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/padding-line-between-statements"
        },
        fixable: "whitespace",
        schema: {
          definitions: {
            paddingType: {
              enum: Object.keys(PaddingTypes)
            },
            statementType: {
              anyOf: [
                { enum: Object.keys(StatementTypes) },
                {
                  type: "array",
                  items: { enum: Object.keys(StatementTypes) },
                  minItems: 1,
                  uniqueItems: true
                }
              ]
            }
          },
          type: "array",
          items: {
            type: "object",
            properties: {
              blankLine: { $ref: "#/definitions/paddingType" },
              prev: { $ref: "#/definitions/statementType" },
              next: { $ref: "#/definitions/statementType" }
            },
            additionalProperties: false,
            required: ["blankLine", "prev", "next"]
          }
        },
        messages: {
          unexpectedBlankLine: "Unexpected blank line before this statement.",
          expectedBlankLine: "Expected blank line before this statement."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        const configureList = context.options || [];
        let scopeInfo = null;
        function enterScope() {
          scopeInfo = {
            upper: scopeInfo,
            prevNode: null
          };
        }
        function exitScope() {
          scopeInfo = scopeInfo.upper;
        }
        function match(node, type) {
          let innerStatementNode = node;
          while (innerStatementNode.type === "LabeledStatement") {
            innerStatementNode = innerStatementNode.body;
          }
          if (Array.isArray(type)) {
            return type.some(match.bind(null, innerStatementNode));
          }
          return StatementTypes[type].test(innerStatementNode, sourceCode);
        }
        function getPaddingType(prevNode, nextNode) {
          for (let i = configureList.length - 1; i >= 0; --i) {
            const configure = configureList[i];
            const matched = match(prevNode, configure.prev) && match(nextNode, configure.next);
            if (matched) {
              return PaddingTypes[configure.blankLine];
            }
          }
          return PaddingTypes.any;
        }
        function getPaddingLineSequences(prevNode, nextNode) {
          const pairs = [];
          let prevToken = getActualLastToken(sourceCode, prevNode);
          if (nextNode.loc.start.line - prevToken.loc.end.line >= 2) {
            do {
              const token = sourceCode.getTokenAfter(
                prevToken,
                { includeComments: true }
              );
              if (token.loc.start.line - prevToken.loc.end.line >= 2) {
                pairs.push([prevToken, token]);
              }
              prevToken = token;
            } while (prevToken.range[0] < nextNode.range[0]);
          }
          return pairs;
        }
        function verify(node) {
          const parentType = node.parent.type;
          const validParent = astUtils.STATEMENT_LIST_PARENTS.has(parentType) || parentType === "SwitchStatement";
          if (!validParent) {
            return;
          }
          const prevNode = scopeInfo.prevNode;
          if (prevNode) {
            const type = getPaddingType(prevNode, node);
            const paddingLines = getPaddingLineSequences(prevNode, node);
            type.verify(context, prevNode, node, paddingLines);
          }
          scopeInfo.prevNode = node;
        }
        function verifyThenEnterScope(node) {
          verify(node);
          enterScope();
        }
        return {
          Program: enterScope,
          BlockStatement: enterScope,
          SwitchStatement: enterScope,
          StaticBlock: enterScope,
          "Program:exit": exitScope,
          "BlockStatement:exit": exitScope,
          "SwitchStatement:exit": exitScope,
          "StaticBlock:exit": exitScope,
          ":statement": verify,
          SwitchCase: verifyThenEnterScope,
          "SwitchCase:exit": exitScope
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/prefer-arrow-callback.js
var require_prefer_arrow_callback = __commonJS({
  "../../node_modules/eslint/lib/rules/prefer-arrow-callback.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    function isFunctionName(variable) {
      return variable && variable.defs[0].type === "FunctionName";
    }
    function checkMetaProperty(node, metaName, propertyName) {
      return node.meta.name === metaName && node.property.name === propertyName;
    }
    function getVariableOfArguments(scope) {
      const variables = scope.variables;
      for (let i = 0; i < variables.length; ++i) {
        const variable = variables[i];
        if (variable.name === "arguments") {
          return variable.identifiers.length === 0 ? variable : null;
        }
      }
      return null;
    }
    function getCallbackInfo(node) {
      const retv = { isCallback: false, isLexicalThis: false };
      let currentNode = node;
      let parent = node.parent;
      let bound = false;
      while (currentNode) {
        switch (parent.type) {
          case "LogicalExpression":
          case "ChainExpression":
          case "ConditionalExpression":
            break;
          case "MemberExpression":
            if (parent.object === currentNode && !parent.property.computed && parent.property.type === "Identifier" && parent.property.name === "bind") {
              const maybeCallee = parent.parent.type === "ChainExpression" ? parent.parent : parent;
              if (astUtils.isCallee(maybeCallee)) {
                if (!bound) {
                  bound = true;
                  retv.isLexicalThis = maybeCallee.parent.arguments.length === 1 && maybeCallee.parent.arguments[0].type === "ThisExpression";
                }
                parent = maybeCallee.parent;
              } else {
                return retv;
              }
            } else {
              return retv;
            }
            break;
          case "CallExpression":
          case "NewExpression":
            if (parent.callee !== currentNode) {
              retv.isCallback = true;
            }
            return retv;
          default:
            return retv;
        }
        currentNode = parent;
        parent = parent.parent;
      }
      throw new Error("unreachable");
    }
    function hasDuplicateParams(paramsList) {
      return paramsList.every((param) => param.type === "Identifier") && paramsList.length !== new Set(paramsList.map((param) => param.name)).size;
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Require using arrow functions for callbacks",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/prefer-arrow-callback"
        },
        schema: [
          {
            type: "object",
            properties: {
              allowNamedFunctions: {
                type: "boolean",
                default: false
              },
              allowUnboundThis: {
                type: "boolean",
                default: true
              }
            },
            additionalProperties: false
          }
        ],
        fixable: "code",
        messages: {
          preferArrowCallback: "Unexpected function expression."
        }
      },
      create(context) {
        const options = context.options[0] || {};
        const allowUnboundThis = options.allowUnboundThis !== false;
        const allowNamedFunctions = options.allowNamedFunctions;
        const sourceCode = context.sourceCode;
        let stack = [];
        function enterScope() {
          stack.push({ this: false, super: false, meta: false });
        }
        function exitScope() {
          return stack.pop();
        }
        return {
          // Reset internal state.
          Program() {
            stack = [];
          },
          // If there are below, it cannot replace with arrow functions merely.
          ThisExpression() {
            const info = stack[stack.length - 1];
            if (info) {
              info.this = true;
            }
          },
          Super() {
            const info = stack[stack.length - 1];
            if (info) {
              info.super = true;
            }
          },
          MetaProperty(node) {
            const info = stack[stack.length - 1];
            if (info && checkMetaProperty(node, "new", "target")) {
              info.meta = true;
            }
          },
          // To skip nested scopes.
          FunctionDeclaration: enterScope,
          "FunctionDeclaration:exit": exitScope,
          // Main.
          FunctionExpression: enterScope,
          "FunctionExpression:exit"(node) {
            const scopeInfo = exitScope();
            if (allowNamedFunctions && node.id && node.id.name) {
              return;
            }
            if (node.generator) {
              return;
            }
            const nameVar = sourceCode.getDeclaredVariables(node)[0];
            if (isFunctionName(nameVar) && nameVar.references.length > 0) {
              return;
            }
            const variable = getVariableOfArguments(sourceCode.getScope(node));
            if (variable && variable.references.length > 0) {
              return;
            }
            const callbackInfo = getCallbackInfo(node);
            if (callbackInfo.isCallback && (!allowUnboundThis || !scopeInfo.this || callbackInfo.isLexicalThis) && !scopeInfo.super && !scopeInfo.meta) {
              context.report({
                node,
                messageId: "preferArrowCallback",
                *fix(fixer) {
                  if (!callbackInfo.isLexicalThis && scopeInfo.this || hasDuplicateParams(node.params)) {
                    return;
                  }
                  if (callbackInfo.isLexicalThis) {
                    const memberNode = node.parent;
                    if (memberNode.type !== "MemberExpression") {
                      return;
                    }
                    const callNode = memberNode.parent;
                    const firstTokenToRemove = sourceCode.getTokenAfter(memberNode.object, astUtils.isNotClosingParenToken);
                    const lastTokenToRemove = sourceCode.getLastToken(callNode);
                    if (astUtils.isParenthesised(sourceCode, memberNode)) {
                      return;
                    }
                    if (sourceCode.commentsExistBetween(firstTokenToRemove, lastTokenToRemove)) {
                      return;
                    }
                    yield fixer.removeRange([firstTokenToRemove.range[0], lastTokenToRemove.range[1]]);
                  }
                  const functionToken = sourceCode.getFirstToken(node, node.async ? 1 : 0);
                  const leftParenToken = sourceCode.getTokenAfter(functionToken, astUtils.isOpeningParenToken);
                  const tokenBeforeBody = sourceCode.getTokenBefore(node.body);
                  if (sourceCode.commentsExistBetween(functionToken, leftParenToken)) {
                    yield fixer.remove(functionToken);
                    if (node.id) {
                      yield fixer.remove(node.id);
                    }
                  } else {
                    yield fixer.removeRange([functionToken.range[0], leftParenToken.range[0]]);
                  }
                  yield fixer.insertTextAfter(tokenBeforeBody, " =>");
                  let replacedNode = callbackInfo.isLexicalThis ? node.parent.parent : node;
                  if (replacedNode.type === "ChainExpression") {
                    replacedNode = replacedNode.parent;
                  }
                  if (replacedNode.parent.type !== "CallExpression" && replacedNode.parent.type !== "ConditionalExpression" && !astUtils.isParenthesised(sourceCode, replacedNode) && !astUtils.isParenthesised(sourceCode, node)) {
                    yield fixer.insertTextBefore(replacedNode, "(");
                    yield fixer.insertTextAfter(replacedNode, ")");
                  }
                }
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/prefer-const.js
var require_prefer_const = __commonJS({
  "../../node_modules/eslint/lib/rules/prefer-const.js"(exports, module) {
    "use strict";
    var FixTracker = require_fix_tracker();
    var astUtils = require_ast_utils2();
    var PATTERN_TYPE = /^(?:.+?Pattern|RestElement|SpreadProperty|ExperimentalRestProperty|Property)$/u;
    var DECLARATION_HOST_TYPE = /^(?:Program|BlockStatement|StaticBlock|SwitchCase)$/u;
    var DESTRUCTURING_HOST_TYPE = /^(?:VariableDeclarator|AssignmentExpression)$/u;
    function isInitOfForStatement(node) {
      return node.parent.type === "ForStatement" && node.parent.init === node;
    }
    function canBecomeVariableDeclaration(identifier) {
      let node = identifier.parent;
      while (PATTERN_TYPE.test(node.type)) {
        node = node.parent;
      }
      return node.type === "VariableDeclarator" || node.type === "AssignmentExpression" && node.parent.type === "ExpressionStatement" && DECLARATION_HOST_TYPE.test(node.parent.parent.type);
    }
    function isOuterVariableInDestructing(name, initScope) {
      if (initScope.through.some((ref) => ref.resolved && ref.resolved.name === name)) {
        return true;
      }
      const variable = astUtils.getVariableByName(initScope, name);
      if (variable !== null) {
        return variable.defs.some((def) => def.type === "Parameter");
      }
      return false;
    }
    function getDestructuringHost(reference) {
      if (!reference.isWrite()) {
        return null;
      }
      let node = reference.identifier.parent;
      while (PATTERN_TYPE.test(node.type)) {
        node = node.parent;
      }
      if (!DESTRUCTURING_HOST_TYPE.test(node.type)) {
        return null;
      }
      return node;
    }
    function hasMemberExpressionAssignment(node) {
      switch (node.type) {
        case "ObjectPattern":
          return node.properties.some((prop) => {
            if (prop) {
              return hasMemberExpressionAssignment(prop.argument || prop.value);
            }
            return false;
          });
        case "ArrayPattern":
          return node.elements.some((element) => {
            if (element) {
              return hasMemberExpressionAssignment(element);
            }
            return false;
          });
        case "AssignmentPattern":
          return hasMemberExpressionAssignment(node.left);
        case "MemberExpression":
          return true;
      }
      return false;
    }
    function getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign) {
      if (variable.eslintUsed && variable.scope.type === "global") {
        return null;
      }
      let writer = null;
      let isReadBeforeInit = false;
      const references = variable.references;
      for (let i = 0; i < references.length; ++i) {
        const reference = references[i];
        if (reference.isWrite()) {
          const isReassigned = writer !== null && writer.identifier !== reference.identifier;
          if (isReassigned) {
            return null;
          }
          const destructuringHost = getDestructuringHost(reference);
          if (destructuringHost !== null && destructuringHost.left !== void 0) {
            const leftNode = destructuringHost.left;
            let hasOuterVariables = false, hasNonIdentifiers = false;
            if (leftNode.type === "ObjectPattern") {
              const properties = leftNode.properties;
              hasOuterVariables = properties.filter((prop) => prop.value).map((prop) => prop.value.name).some((name) => isOuterVariableInDestructing(name, variable.scope));
              hasNonIdentifiers = hasMemberExpressionAssignment(leftNode);
            } else if (leftNode.type === "ArrayPattern") {
              const elements = leftNode.elements;
              hasOuterVariables = elements.map((element) => element && element.name).some((name) => isOuterVariableInDestructing(name, variable.scope));
              hasNonIdentifiers = hasMemberExpressionAssignment(leftNode);
            }
            if (hasOuterVariables || hasNonIdentifiers) {
              return null;
            }
          }
          writer = reference;
        } else if (reference.isRead() && writer === null) {
          if (ignoreReadBeforeAssign) {
            return null;
          }
          isReadBeforeInit = true;
        }
      }
      const shouldBeConst = writer !== null && writer.from === variable.scope && canBecomeVariableDeclaration(writer.identifier);
      if (!shouldBeConst) {
        return null;
      }
      if (isReadBeforeInit) {
        return variable.defs[0].name;
      }
      return writer.identifier;
    }
    function groupByDestructuring(variables, ignoreReadBeforeAssign) {
      const identifierMap = /* @__PURE__ */ new Map();
      for (let i = 0; i < variables.length; ++i) {
        const variable = variables[i];
        const references = variable.references;
        const identifier = getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign);
        let prevId = null;
        for (let j = 0; j < references.length; ++j) {
          const reference = references[j];
          const id = reference.identifier;
          if (id === prevId) {
            continue;
          }
          prevId = id;
          const group = getDestructuringHost(reference);
          if (group) {
            if (identifierMap.has(group)) {
              identifierMap.get(group).push(identifier);
            } else {
              identifierMap.set(group, [identifier]);
            }
          }
        }
      }
      return identifierMap;
    }
    function findUp(node, type, shouldStop) {
      if (!node || shouldStop(node)) {
        return null;
      }
      if (node.type === type) {
        return node;
      }
      return findUp(node.parent, type, shouldStop);
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Require `const` declarations for variables that are never reassigned after declared",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/prefer-const"
        },
        fixable: "code",
        schema: [
          {
            type: "object",
            properties: {
              destructuring: { enum: ["any", "all"], default: "any" },
              ignoreReadBeforeAssign: { type: "boolean", default: false }
            },
            additionalProperties: false
          }
        ],
        messages: {
          useConst: "'{{name}}' is never reassigned. Use 'const' instead."
        }
      },
      create(context) {
        const options = context.options[0] || {};
        const sourceCode = context.sourceCode;
        const shouldMatchAnyDestructuredVariable = options.destructuring !== "all";
        const ignoreReadBeforeAssign = options.ignoreReadBeforeAssign === true;
        const variables = [];
        let reportCount = 0;
        let checkedId = null;
        let checkedName = "";
        function checkGroup(nodes) {
          const nodesToReport = nodes.filter(Boolean);
          if (nodes.length && (shouldMatchAnyDestructuredVariable || nodesToReport.length === nodes.length)) {
            const varDeclParent = findUp(nodes[0], "VariableDeclaration", (parentNode) => parentNode.type.endsWith("Statement"));
            const isVarDecParentNull = varDeclParent === null;
            if (!isVarDecParentNull && varDeclParent.declarations.length > 0) {
              const firstDeclaration = varDeclParent.declarations[0];
              if (firstDeclaration.init) {
                const firstDecParent = firstDeclaration.init.parent;
                if (firstDecParent.type === "VariableDeclarator") {
                  if (firstDecParent.id.name !== checkedName) {
                    checkedName = firstDecParent.id.name;
                    reportCount = 0;
                  }
                  if (firstDecParent.id.type === "ObjectPattern") {
                    if (firstDecParent.init.name !== checkedName) {
                      checkedName = firstDecParent.init.name;
                      reportCount = 0;
                    }
                  }
                  if (firstDecParent.id !== checkedId) {
                    checkedId = firstDecParent.id;
                    reportCount = 0;
                  }
                }
              }
            }
            let shouldFix = varDeclParent && // Don't do a fix unless all variables in the declarations are initialized (or it's in a for-in or for-of loop)
            (varDeclParent.parent.type === "ForInStatement" || varDeclParent.parent.type === "ForOfStatement" || varDeclParent.declarations.every((declaration) => declaration.init)) && /*
             * If options.destructuring is "all", then this warning will not occur unless
             * every assignment in the destructuring should be const. In that case, it's safe
             * to apply the fix.
             */
            nodesToReport.length === nodes.length;
            if (!isVarDecParentNull && varDeclParent.declarations && varDeclParent.declarations.length !== 1) {
              if (varDeclParent && varDeclParent.declarations && varDeclParent.declarations.length >= 1) {
                reportCount += nodesToReport.length;
                let totalDeclarationsCount = 0;
                varDeclParent.declarations.forEach((declaration) => {
                  if (declaration.id.type === "ObjectPattern") {
                    totalDeclarationsCount += declaration.id.properties.length;
                  } else if (declaration.id.type === "ArrayPattern") {
                    totalDeclarationsCount += declaration.id.elements.length;
                  } else {
                    totalDeclarationsCount += 1;
                  }
                });
                shouldFix = shouldFix && reportCount === totalDeclarationsCount;
              }
            }
            nodesToReport.forEach((node) => {
              context.report({
                node,
                messageId: "useConst",
                data: node,
                fix: shouldFix ? (fixer) => {
                  const letKeywordToken = sourceCode.getFirstToken(varDeclParent, (t) => t.value === varDeclParent.kind);
                  return new FixTracker(fixer, sourceCode).retainRange(varDeclParent.range).replaceTextRange(letKeywordToken.range, "const");
                } : null
              });
            });
          }
        }
        return {
          "Program:exit"() {
            groupByDestructuring(variables, ignoreReadBeforeAssign).forEach(checkGroup);
          },
          VariableDeclaration(node) {
            if (node.kind === "let" && !isInitOfForStatement(node)) {
              variables.push(...sourceCode.getDeclaredVariables(node));
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/prefer-destructuring.js
var require_prefer_destructuring = __commonJS({
  "../../node_modules/eslint/lib/rules/prefer-destructuring.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var PRECEDENCE_OF_ASSIGNMENT_EXPR = astUtils.getPrecedence({ type: "AssignmentExpression" });
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Require destructuring from arrays and/or objects",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/prefer-destructuring"
        },
        fixable: "code",
        schema: [
          {
            /*
             * old support {array: Boolean, object: Boolean}
             * new support {VariableDeclarator: {}, AssignmentExpression: {}}
             */
            oneOf: [
              {
                type: "object",
                properties: {
                  VariableDeclarator: {
                    type: "object",
                    properties: {
                      array: {
                        type: "boolean"
                      },
                      object: {
                        type: "boolean"
                      }
                    },
                    additionalProperties: false
                  },
                  AssignmentExpression: {
                    type: "object",
                    properties: {
                      array: {
                        type: "boolean"
                      },
                      object: {
                        type: "boolean"
                      }
                    },
                    additionalProperties: false
                  }
                },
                additionalProperties: false
              },
              {
                type: "object",
                properties: {
                  array: {
                    type: "boolean"
                  },
                  object: {
                    type: "boolean"
                  }
                },
                additionalProperties: false
              }
            ]
          },
          {
            type: "object",
            properties: {
              enforceForRenamedProperties: {
                type: "boolean"
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          preferDestructuring: "Use {{type}} destructuring."
        }
      },
      create(context) {
        const enabledTypes = context.options[0];
        const enforceForRenamedProperties = context.options[1] && context.options[1].enforceForRenamedProperties;
        let normalizedOptions = {
          VariableDeclarator: { array: true, object: true },
          AssignmentExpression: { array: true, object: true }
        };
        if (enabledTypes) {
          normalizedOptions = typeof enabledTypes.array !== "undefined" || typeof enabledTypes.object !== "undefined" ? { VariableDeclarator: enabledTypes, AssignmentExpression: enabledTypes } : enabledTypes;
        }
        function shouldCheck(nodeType, destructuringType) {
          return normalizedOptions && normalizedOptions[nodeType] && normalizedOptions[nodeType][destructuringType];
        }
        function isArrayIndexAccess(node) {
          return Number.isInteger(node.property.value);
        }
        function report(reportNode, type, fix) {
          context.report({
            node: reportNode,
            messageId: "preferDestructuring",
            data: { type },
            fix
          });
        }
        function shouldFix(node) {
          return node.type === "VariableDeclarator" && node.id.type === "Identifier" && node.init.type === "MemberExpression" && !node.init.computed && node.init.property.type === "Identifier" && node.id.name === node.init.property.name;
        }
        function fixIntoObjectDestructuring(fixer, node) {
          const rightNode = node.init;
          const sourceCode = context.sourceCode;
          if (sourceCode.getCommentsInside(node).length > sourceCode.getCommentsInside(rightNode.object).length) {
            return null;
          }
          let objectText = sourceCode.getText(rightNode.object);
          if (astUtils.getPrecedence(rightNode.object) < PRECEDENCE_OF_ASSIGNMENT_EXPR) {
            objectText = `(${objectText})`;
          }
          return fixer.replaceText(
            node,
            `{${rightNode.property.name}} = ${objectText}`
          );
        }
        function performCheck(leftNode, rightNode, reportNode) {
          if (rightNode.type !== "MemberExpression" || rightNode.object.type === "Super" || rightNode.property.type === "PrivateIdentifier") {
            return;
          }
          if (isArrayIndexAccess(rightNode)) {
            if (shouldCheck(reportNode.type, "array")) {
              report(reportNode, "array", null);
            }
            return;
          }
          const fix = shouldFix(reportNode) ? (fixer) => fixIntoObjectDestructuring(fixer, reportNode) : null;
          if (shouldCheck(reportNode.type, "object") && enforceForRenamedProperties) {
            report(reportNode, "object", fix);
            return;
          }
          if (shouldCheck(reportNode.type, "object")) {
            const property = rightNode.property;
            if (property.type === "Literal" && leftNode.name === property.value || property.type === "Identifier" && leftNode.name === property.name && !rightNode.computed) {
              report(reportNode, "object", fix);
            }
          }
        }
        function checkVariableDeclarator(node) {
          if (!node.init) {
            return;
          }
          if (node.init.type !== "MemberExpression") {
            return;
          }
          performCheck(node.id, node.init, node);
        }
        function checkAssignmentExpression(node) {
          if (node.operator === "=") {
            performCheck(node.left, node.right, node);
          }
        }
        return {
          VariableDeclarator: checkVariableDeclarator,
          AssignmentExpression: checkAssignmentExpression
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/prefer-exponentiation-operator.js
var require_prefer_exponentiation_operator = __commonJS({
  "../../node_modules/eslint/lib/rules/prefer-exponentiation-operator.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var { CALL, ReferenceTracker } = require_eslint_utils();
    var PRECEDENCE_OF_EXPONENTIATION_EXPR = astUtils.getPrecedence({ type: "BinaryExpression", operator: "**" });
    function doesBaseNeedParens(base) {
      return (
        // '**' is right-associative, parens are needed when Math.pow(a ** b, c) is converted to (a ** b) ** c
        astUtils.getPrecedence(base) <= PRECEDENCE_OF_EXPONENTIATION_EXPR || // An unary operator cannot be used immediately before an exponentiation expression
        base.type === "AwaitExpression" || base.type === "UnaryExpression"
      );
    }
    function doesExponentNeedParens(exponent) {
      return astUtils.getPrecedence(exponent) < PRECEDENCE_OF_EXPONENTIATION_EXPR;
    }
    function doesExponentiationExpressionNeedParens(node, sourceCode) {
      const parent = node.parent.type === "ChainExpression" ? node.parent.parent : node.parent;
      const parentPrecedence = astUtils.getPrecedence(parent);
      const needsParens = parent.type === "ClassDeclaration" || parent.type.endsWith("Expression") && (parentPrecedence === -1 || parentPrecedence >= PRECEDENCE_OF_EXPONENTIATION_EXPR) && !(parent.type === "BinaryExpression" && parent.operator === "**" && parent.right === node) && !((parent.type === "CallExpression" || parent.type === "NewExpression") && parent.arguments.includes(node)) && !(parent.type === "MemberExpression" && parent.computed && parent.property === node) && !(parent.type === "ArrayExpression");
      return needsParens && !astUtils.isParenthesised(sourceCode, node);
    }
    function parenthesizeIfShould(text, shouldParenthesize) {
      return shouldParenthesize ? `(${text})` : text;
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow the use of `Math.pow` in favor of the `**` operator",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/prefer-exponentiation-operator"
        },
        schema: [],
        fixable: "code",
        messages: {
          useExponentiation: "Use the '**' operator instead of 'Math.pow'."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        function report(node) {
          context.report({
            node,
            messageId: "useExponentiation",
            fix(fixer) {
              if (node.arguments.length !== 2 || node.arguments.some((arg) => arg.type === "SpreadElement") || sourceCode.getCommentsInside(node).length > 0) {
                return null;
              }
              const base = node.arguments[0], exponent = node.arguments[1], baseText = sourceCode.getText(base), exponentText = sourceCode.getText(exponent), shouldParenthesizeBase = doesBaseNeedParens(base), shouldParenthesizeExponent = doesExponentNeedParens(exponent), shouldParenthesizeAll = doesExponentiationExpressionNeedParens(node, sourceCode);
              let prefix = "", suffix = "";
              if (!shouldParenthesizeAll) {
                if (!shouldParenthesizeBase) {
                  const firstReplacementToken = sourceCode.getFirstToken(base), tokenBefore = sourceCode.getTokenBefore(node);
                  if (tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, firstReplacementToken)) {
                    prefix = " ";
                  }
                }
                if (!shouldParenthesizeExponent) {
                  const lastReplacementToken = sourceCode.getLastToken(exponent), tokenAfter = sourceCode.getTokenAfter(node);
                  if (tokenAfter && node.range[1] === tokenAfter.range[0] && !astUtils.canTokensBeAdjacent(lastReplacementToken, tokenAfter)) {
                    suffix = " ";
                  }
                }
              }
              const baseReplacement = parenthesizeIfShould(baseText, shouldParenthesizeBase), exponentReplacement = parenthesizeIfShould(exponentText, shouldParenthesizeExponent), replacement = parenthesizeIfShould(`${baseReplacement}**${exponentReplacement}`, shouldParenthesizeAll);
              return fixer.replaceText(node, `${prefix}${replacement}${suffix}`);
            }
          });
        }
        return {
          Program(node) {
            const scope = sourceCode.getScope(node);
            const tracker = new ReferenceTracker(scope);
            const trackMap = {
              Math: {
                pow: { [CALL]: true }
              }
            };
            for (const { node: refNode } of tracker.iterateGlobalReferences(trackMap)) {
              report(refNode);
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/prefer-named-capture-group.js
var require_prefer_named_capture_group = __commonJS({
  "../../node_modules/eslint/lib/rules/prefer-named-capture-group.js"(exports, module) {
    "use strict";
    var {
      CALL,
      CONSTRUCT,
      ReferenceTracker,
      getStringIfConstant
    } = require_eslint_utils();
    var regexpp = require_regexpp();
    var parser = new regexpp.RegExpParser();
    function suggestIfPossible(groupStart, pattern, rawText, regexNode) {
      switch (regexNode.type) {
        case "Literal":
          if (typeof regexNode.value === "string" && rawText.includes("\\")) {
            return null;
          }
          break;
        case "TemplateLiteral":
          if (regexNode.expressions.length || rawText.slice(1, -1) !== pattern) {
            return null;
          }
          break;
        default:
          return null;
      }
      const start = regexNode.range[0] + groupStart + 2;
      return [
        {
          fix(fixer) {
            const existingTemps = pattern.match(/temp\d+/gu) || [];
            const highestTempCount = existingTemps.reduce(
              (previous, next) => Math.max(previous, Number(next.slice("temp".length))),
              0
            );
            return fixer.insertTextBeforeRange(
              [start, start],
              `?<temp${highestTempCount + 1}>`
            );
          },
          messageId: "addGroupName"
        },
        {
          fix(fixer) {
            return fixer.insertTextBeforeRange(
              [start, start],
              "?:"
            );
          },
          messageId: "addNonCapture"
        }
      ];
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Enforce using named capture group in regular expression",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/prefer-named-capture-group"
        },
        hasSuggestions: true,
        schema: [],
        messages: {
          addGroupName: "Add name to capture group.",
          addNonCapture: "Convert group to non-capturing.",
          required: "Capture group '{{group}}' should be converted to a named or non-capturing group."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        function checkRegex(pattern, node, regexNode, uFlag) {
          let ast;
          try {
            ast = parser.parsePattern(pattern, 0, pattern.length, uFlag);
          } catch {
            return;
          }
          regexpp.visitRegExpAST(ast, {
            onCapturingGroupEnter(group) {
              if (!group.name) {
                const rawText = sourceCode.getText(regexNode);
                const suggest = suggestIfPossible(group.start, pattern, rawText, regexNode);
                context.report({
                  node,
                  messageId: "required",
                  data: {
                    group: group.raw
                  },
                  suggest
                });
              }
            }
          });
        }
        return {
          Literal(node) {
            if (node.regex) {
              checkRegex(node.regex.pattern, node, node, node.regex.flags.includes("u"));
            }
          },
          Program(node) {
            const scope = sourceCode.getScope(node);
            const tracker = new ReferenceTracker(scope);
            const traceMap = {
              RegExp: {
                [CALL]: true,
                [CONSTRUCT]: true
              }
            };
            for (const { node: refNode } of tracker.iterateGlobalReferences(traceMap)) {
              const regex = getStringIfConstant(refNode.arguments[0]);
              const flags = getStringIfConstant(refNode.arguments[1]);
              if (regex) {
                checkRegex(regex, refNode, refNode.arguments[0], flags && flags.includes("u"));
              }
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/prefer-numeric-literals.js
var require_prefer_numeric_literals = __commonJS({
  "../../node_modules/eslint/lib/rules/prefer-numeric-literals.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var radixMap = /* @__PURE__ */ new Map([
      [2, { system: "binary", literalPrefix: "0b" }],
      [8, { system: "octal", literalPrefix: "0o" }],
      [16, { system: "hexadecimal", literalPrefix: "0x" }]
    ]);
    function isParseInt(calleeNode) {
      return astUtils.isSpecificId(calleeNode, "parseInt") || astUtils.isSpecificMemberAccess(calleeNode, "Number", "parseInt");
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow `parseInt()` and `Number.parseInt()` in favor of binary, octal, and hexadecimal literals",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/prefer-numeric-literals"
        },
        schema: [],
        messages: {
          useLiteral: "Use {{system}} literals instead of {{functionName}}()."
        },
        fixable: "code"
      },
      create(context) {
        const sourceCode = context.sourceCode;
        return {
          "CallExpression[arguments.length=2]"(node) {
            const [strNode, radixNode] = node.arguments, str = astUtils.getStaticStringValue(strNode), radix = radixNode.value;
            if (str !== null && astUtils.isStringLiteral(strNode) && radixNode.type === "Literal" && typeof radix === "number" && radixMap.has(radix) && isParseInt(node.callee)) {
              const { system, literalPrefix } = radixMap.get(radix);
              context.report({
                node,
                messageId: "useLiteral",
                data: {
                  system,
                  functionName: sourceCode.getText(node.callee)
                },
                fix(fixer) {
                  if (sourceCode.getCommentsInside(node).length) {
                    return null;
                  }
                  const replacement = `${literalPrefix}${str}`;
                  if (+replacement !== parseInt(str, radix)) {
                    return null;
                  }
                  const tokenBefore = sourceCode.getTokenBefore(node), tokenAfter = sourceCode.getTokenAfter(node);
                  let prefix = "", suffix = "";
                  if (tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, replacement)) {
                    prefix = " ";
                  }
                  if (tokenAfter && node.range[1] === tokenAfter.range[0] && !astUtils.canTokensBeAdjacent(replacement, tokenAfter)) {
                    suffix = " ";
                  }
                  return fixer.replaceText(node, `${prefix}${replacement}${suffix}`);
                }
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/prefer-object-has-own.js
var require_prefer_object_has_own = __commonJS({
  "../../node_modules/eslint/lib/rules/prefer-object-has-own.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    function hasLeftHandObject(node) {
      if (node.object.type === "ObjectExpression" && node.object.properties.length === 0) {
        return true;
      }
      const objectNodeToCheck = node.object.type === "MemberExpression" && astUtils.getStaticPropertyName(node.object) === "prototype" ? node.object.object : node.object;
      if (objectNodeToCheck.type === "Identifier" && objectNodeToCheck.name === "Object") {
        return true;
      }
      return false;
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow use of `Object.prototype.hasOwnProperty.call()` and prefer use of `Object.hasOwn()`",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/prefer-object-has-own"
        },
        schema: [],
        messages: {
          useHasOwn: "Use 'Object.hasOwn()' instead of 'Object.prototype.hasOwnProperty.call()'."
        },
        fixable: "code"
      },
      create(context) {
        const sourceCode = context.sourceCode;
        return {
          CallExpression(node) {
            if (!(node.callee.type === "MemberExpression" && node.callee.object.type === "MemberExpression")) {
              return;
            }
            const calleePropertyName = astUtils.getStaticPropertyName(node.callee);
            const objectPropertyName = astUtils.getStaticPropertyName(node.callee.object);
            const isObject = hasLeftHandObject(node.callee.object);
            const scope = sourceCode.getScope(node);
            const variable = astUtils.getVariableByName(scope, "Object");
            if (calleePropertyName === "call" && objectPropertyName === "hasOwnProperty" && isObject && variable && variable.scope.type === "global") {
              context.report({
                node,
                messageId: "useHasOwn",
                fix(fixer) {
                  if (sourceCode.getCommentsInside(node.callee).length > 0) {
                    return null;
                  }
                  const tokenJustBeforeNode = sourceCode.getTokenBefore(node.callee, { includeComments: true });
                  if (tokenJustBeforeNode && tokenJustBeforeNode.range[1] === node.callee.range[0] && !astUtils.canTokensBeAdjacent(tokenJustBeforeNode, "Object.hasOwn")) {
                    return fixer.replaceText(node.callee, " Object.hasOwn");
                  }
                  return fixer.replaceText(node.callee, "Object.hasOwn");
                }
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/prefer-object-spread.js
var require_prefer_object_spread = __commonJS({
  "../../node_modules/eslint/lib/rules/prefer-object-spread.js"(exports, module) {
    "use strict";
    var { CALL, ReferenceTracker } = require_eslint_utils();
    var {
      isCommaToken,
      isOpeningParenToken,
      isClosingParenToken,
      isParenthesised
    } = require_ast_utils2();
    var ANY_SPACE = /\s/u;
    function hasArraySpread(node) {
      return node.arguments.some((arg) => arg.type === "SpreadElement");
    }
    function isAccessorProperty(node) {
      return node.type === "Property" && (node.kind === "get" || node.kind === "set");
    }
    function hasAccessors(node) {
      return node.properties.some(isAccessorProperty);
    }
    function hasArgumentsWithAccessors(node) {
      return node.arguments.filter((arg) => arg.type === "ObjectExpression").some(hasAccessors);
    }
    function needsParens(node, sourceCode) {
      const parent = node.parent;
      switch (parent.type) {
        case "VariableDeclarator":
        case "ArrayExpression":
        case "ReturnStatement":
        case "CallExpression":
        case "Property":
          return false;
        case "AssignmentExpression":
          return parent.left === node && !isParenthesised(sourceCode, node);
        default:
          return !isParenthesised(sourceCode, node);
      }
    }
    function argNeedsParens(node, sourceCode) {
      switch (node.type) {
        case "AssignmentExpression":
        case "ArrowFunctionExpression":
        case "ConditionalExpression":
          return !isParenthesised(sourceCode, node);
        default:
          return false;
      }
    }
    function getParenTokens(node, leftArgumentListParen, sourceCode) {
      const parens = [sourceCode.getFirstToken(node), sourceCode.getLastToken(node)];
      let leftNext = sourceCode.getTokenBefore(node);
      let rightNext = sourceCode.getTokenAfter(node);
      while (leftNext && rightNext && leftNext.range[0] > leftArgumentListParen.range[0] && isOpeningParenToken(leftNext) && isClosingParenToken(rightNext)) {
        parens.push(leftNext, rightNext);
        leftNext = sourceCode.getTokenBefore(leftNext);
        rightNext = sourceCode.getTokenAfter(rightNext);
      }
      return parens.sort((a, b) => a.range[0] - b.range[0]);
    }
    function getStartWithSpaces(token, sourceCode) {
      const text = sourceCode.text;
      let start = token.range[0];
      {
        const prevToken = sourceCode.getTokenBefore(token, { includeComments: true });
        if (prevToken && prevToken.type === "Line") {
          return start;
        }
      }
      while (ANY_SPACE.test(text[start - 1] || "")) {
        start -= 1;
      }
      return start;
    }
    function getEndWithSpaces(token, sourceCode) {
      const text = sourceCode.text;
      let end = token.range[1];
      while (ANY_SPACE.test(text[end] || "")) {
        end += 1;
      }
      return end;
    }
    function defineFixer(node, sourceCode) {
      return function* (fixer) {
        const leftParen = sourceCode.getTokenAfter(node.callee, isOpeningParenToken);
        const rightParen = sourceCode.getLastToken(node);
        yield fixer.removeRange([node.range[0], leftParen.range[0]]);
        if (needsParens(node, sourceCode)) {
          yield fixer.replaceText(leftParen, "({");
          yield fixer.replaceText(rightParen, "})");
        } else {
          yield fixer.replaceText(leftParen, "{");
          yield fixer.replaceText(rightParen, "}");
        }
        for (const argNode of node.arguments) {
          const innerParens = getParenTokens(argNode, leftParen, sourceCode);
          const left = innerParens.shift();
          const right = innerParens.pop();
          if (argNode.type === "ObjectExpression") {
            const maybeTrailingComma = sourceCode.getLastToken(argNode, 1);
            const maybeArgumentComma = sourceCode.getTokenAfter(right);
            for (const innerParen of innerParens) {
              yield fixer.remove(innerParen);
            }
            const leftRange = [left.range[0], getEndWithSpaces(left, sourceCode)];
            const rightRange = [
              Math.max(getStartWithSpaces(right, sourceCode), leftRange[1]),
              // Ensure ranges don't overlap
              right.range[1]
            ];
            yield fixer.removeRange(leftRange);
            yield fixer.removeRange(rightRange);
            if ((argNode.properties.length === 0 || isCommaToken(maybeTrailingComma)) && isCommaToken(maybeArgumentComma)) {
              yield fixer.remove(maybeArgumentComma);
            }
          } else {
            if (argNeedsParens(argNode, sourceCode)) {
              yield fixer.insertTextBefore(left, "...(");
              yield fixer.insertTextAfter(right, ")");
            } else {
              yield fixer.insertTextBefore(left, "...");
            }
          }
        }
      };
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow using Object.assign with an object literal as the first argument and prefer the use of object spread instead",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/prefer-object-spread"
        },
        schema: [],
        fixable: "code",
        messages: {
          useSpreadMessage: "Use an object spread instead of `Object.assign` eg: `{ ...foo }`.",
          useLiteralMessage: "Use an object literal instead of `Object.assign`. eg: `{ foo: bar }`."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        return {
          Program(node) {
            const scope = sourceCode.getScope(node);
            const tracker = new ReferenceTracker(scope);
            const trackMap = {
              Object: {
                assign: { [CALL]: true }
              }
            };
            for (const { node: refNode } of tracker.iterateGlobalReferences(trackMap)) {
              if (refNode.arguments.length >= 1 && refNode.arguments[0].type === "ObjectExpression" && !hasArraySpread(refNode) && !(refNode.arguments.length > 1 && hasArgumentsWithAccessors(refNode))) {
                const messageId = refNode.arguments.length === 1 ? "useLiteralMessage" : "useSpreadMessage";
                const fix = defineFixer(refNode, sourceCode);
                context.report({ node: refNode, messageId, fix });
              }
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/prefer-promise-reject-errors.js
var require_prefer_promise_reject_errors = __commonJS({
  "../../node_modules/eslint/lib/rules/prefer-promise-reject-errors.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Require using Error objects as Promise rejection reasons",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/prefer-promise-reject-errors"
        },
        fixable: null,
        schema: [
          {
            type: "object",
            properties: {
              allowEmptyReject: { type: "boolean", default: false }
            },
            additionalProperties: false
          }
        ],
        messages: {
          rejectAnError: "Expected the Promise rejection reason to be an Error."
        }
      },
      create(context) {
        const ALLOW_EMPTY_REJECT = context.options.length && context.options[0].allowEmptyReject;
        const sourceCode = context.sourceCode;
        function checkRejectCall(callExpression) {
          if (!callExpression.arguments.length && ALLOW_EMPTY_REJECT) {
            return;
          }
          if (!callExpression.arguments.length || !astUtils.couldBeError(callExpression.arguments[0]) || callExpression.arguments[0].type === "Identifier" && callExpression.arguments[0].name === "undefined") {
            context.report({
              node: callExpression,
              messageId: "rejectAnError"
            });
          }
        }
        function isPromiseRejectCall(node) {
          return astUtils.isSpecificMemberAccess(node.callee, "Promise", "reject");
        }
        return {
          // Check `Promise.reject(value)` calls.
          CallExpression(node) {
            if (isPromiseRejectCall(node)) {
              checkRejectCall(node);
            }
          },
          /*
           * Check for `new Promise((resolve, reject) => {})`, and check for reject() calls.
           * This function is run on "NewExpression:exit" instead of "NewExpression" to ensure that
           * the nodes in the expression already have the `parent` property.
           */
          "NewExpression:exit"(node) {
            if (node.callee.type === "Identifier" && node.callee.name === "Promise" && node.arguments.length && astUtils.isFunction(node.arguments[0]) && node.arguments[0].params.length > 1 && node.arguments[0].params[1].type === "Identifier") {
              sourceCode.getDeclaredVariables(node.arguments[0]).find((variable) => variable.name === node.arguments[0].params[1].name).references.filter((ref) => ref.isRead()).filter((ref) => ref.identifier.parent.type === "CallExpression" && ref.identifier === ref.identifier.parent.callee).forEach((ref) => checkRejectCall(ref.identifier.parent));
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/prefer-reflect.js
var require_prefer_reflect = __commonJS({
  "../../node_modules/eslint/lib/rules/prefer-reflect.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Require `Reflect` methods where applicable",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/prefer-reflect"
        },
        deprecated: true,
        replacedBy: [],
        schema: [
          {
            type: "object",
            properties: {
              exceptions: {
                type: "array",
                items: {
                  enum: [
                    "apply",
                    "call",
                    "delete",
                    "defineProperty",
                    "getOwnPropertyDescriptor",
                    "getPrototypeOf",
                    "setPrototypeOf",
                    "isExtensible",
                    "getOwnPropertyNames",
                    "preventExtensions"
                  ]
                },
                uniqueItems: true
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          preferReflect: "Avoid using {{existing}}, instead use {{substitute}}."
        }
      },
      create(context) {
        const existingNames = {
          apply: "Function.prototype.apply",
          call: "Function.prototype.call",
          defineProperty: "Object.defineProperty",
          getOwnPropertyDescriptor: "Object.getOwnPropertyDescriptor",
          getPrototypeOf: "Object.getPrototypeOf",
          setPrototypeOf: "Object.setPrototypeOf",
          isExtensible: "Object.isExtensible",
          getOwnPropertyNames: "Object.getOwnPropertyNames",
          preventExtensions: "Object.preventExtensions"
        };
        const reflectSubstitutes = {
          apply: "Reflect.apply",
          call: "Reflect.apply",
          defineProperty: "Reflect.defineProperty",
          getOwnPropertyDescriptor: "Reflect.getOwnPropertyDescriptor",
          getPrototypeOf: "Reflect.getPrototypeOf",
          setPrototypeOf: "Reflect.setPrototypeOf",
          isExtensible: "Reflect.isExtensible",
          getOwnPropertyNames: "Reflect.getOwnPropertyNames",
          preventExtensions: "Reflect.preventExtensions"
        };
        const exceptions = (context.options[0] || {}).exceptions || [];
        function report(node, existing, substitute) {
          context.report({
            node,
            messageId: "preferReflect",
            data: {
              existing,
              substitute
            }
          });
        }
        return {
          CallExpression(node) {
            const methodName = (node.callee.property || {}).name;
            const isReflectCall = (node.callee.object || {}).name === "Reflect";
            const hasReflectSubstitute = Object.prototype.hasOwnProperty.call(reflectSubstitutes, methodName);
            const userConfiguredException = exceptions.includes(methodName);
            if (hasReflectSubstitute && !isReflectCall && !userConfiguredException) {
              report(node, existingNames[methodName], reflectSubstitutes[methodName]);
            }
          },
          UnaryExpression(node) {
            const isDeleteOperator = node.operator === "delete";
            const targetsIdentifier = node.argument.type === "Identifier";
            const userConfiguredException = exceptions.includes("delete");
            if (isDeleteOperator && !targetsIdentifier && !userConfiguredException) {
              report(node, "the delete keyword", "Reflect.deleteProperty");
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/prefer-regex-literals.js
var require_prefer_regex_literals = __commonJS({
  "../../node_modules/eslint/lib/rules/prefer-regex-literals.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var { CALL, CONSTRUCT, ReferenceTracker, findVariable } = require_eslint_utils();
    var { RegExpValidator, visitRegExpAST, RegExpParser } = require_regexpp();
    var { canTokensBeAdjacent } = require_ast_utils2();
    var { REGEXPP_LATEST_ECMA_VERSION } = require_regular_expressions();
    function isStringLiteral(node) {
      return node.type === "Literal" && typeof node.value === "string";
    }
    function isRegexLiteral(node) {
      return node.type === "Literal" && Object.prototype.hasOwnProperty.call(node, "regex");
    }
    var validPrecedingTokens = /* @__PURE__ */ new Set([
      "(",
      ";",
      "[",
      ",",
      "=",
      "+",
      "*",
      "-",
      "?",
      "~",
      "%",
      "**",
      "!",
      "typeof",
      "instanceof",
      "&&",
      "||",
      "??",
      "return",
      "...",
      "delete",
      "void",
      "in",
      "<",
      ">",
      "<=",
      ">=",
      "==",
      "===",
      "!=",
      "!==",
      "<<",
      ">>",
      ">>>",
      "&",
      "|",
      "^",
      ":",
      "{",
      "=>",
      "*=",
      "<<=",
      ">>=",
      ">>>=",
      "^=",
      "|=",
      "&=",
      "??=",
      "||=",
      "&&=",
      "**=",
      "+=",
      "-=",
      "/=",
      "%=",
      "/",
      "do",
      "break",
      "continue",
      "debugger",
      "case",
      "throw"
    ]);
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow use of the `RegExp` constructor in favor of regular expression literals",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/prefer-regex-literals"
        },
        hasSuggestions: true,
        schema: [
          {
            type: "object",
            properties: {
              disallowRedundantWrapping: {
                type: "boolean",
                default: false
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          unexpectedRegExp: "Use a regular expression literal instead of the 'RegExp' constructor.",
          replaceWithLiteral: "Replace with an equivalent regular expression literal.",
          replaceWithLiteralAndFlags: "Replace with an equivalent regular expression literal with flags '{{ flags }}'.",
          replaceWithIntendedLiteralAndFlags: "Replace with a regular expression literal with flags '{{ flags }}'.",
          unexpectedRedundantRegExp: "Regular expression literal is unnecessarily wrapped within a 'RegExp' constructor.",
          unexpectedRedundantRegExpWithFlags: "Use regular expression literal with flags instead of the 'RegExp' constructor."
        }
      },
      create(context) {
        const [{ disallowRedundantWrapping = false } = {}] = context.options;
        const sourceCode = context.sourceCode;
        function isGlobalReference(node) {
          const scope = sourceCode.getScope(node);
          const variable = findVariable(scope, node);
          return variable !== null && variable.scope.type === "global" && variable.defs.length === 0;
        }
        function isStringRawTaggedStaticTemplateLiteral(node) {
          return node.type === "TaggedTemplateExpression" && astUtils.isSpecificMemberAccess(node.tag, "String", "raw") && isGlobalReference(astUtils.skipChainExpression(node.tag).object) && astUtils.isStaticTemplateLiteral(node.quasi);
        }
        function getStringValue(node) {
          if (isStringLiteral(node)) {
            return node.value;
          }
          if (astUtils.isStaticTemplateLiteral(node)) {
            return node.quasis[0].value.cooked;
          }
          if (isStringRawTaggedStaticTemplateLiteral(node)) {
            return node.quasi.quasis[0].value.raw;
          }
          return null;
        }
        function isStaticString(node) {
          return isStringLiteral(node) || astUtils.isStaticTemplateLiteral(node) || isStringRawTaggedStaticTemplateLiteral(node);
        }
        function hasOnlyStaticStringArguments(node) {
          const args = node.arguments;
          if ((args.length === 1 || args.length === 2) && args.every(isStaticString)) {
            return true;
          }
          return false;
        }
        function isUnnecessarilyWrappedRegexLiteral(node) {
          const args = node.arguments;
          if (args.length === 1 && isRegexLiteral(args[0])) {
            return true;
          }
          if (args.length === 2 && isRegexLiteral(args[0]) && isStaticString(args[1])) {
            return true;
          }
          return false;
        }
        function getRegexppEcmaVersion(ecmaVersion) {
          if (ecmaVersion <= 5) {
            return 5;
          }
          return Math.min(ecmaVersion, REGEXPP_LATEST_ECMA_VERSION);
        }
        const regexppEcmaVersion = getRegexppEcmaVersion(context.languageOptions.ecmaVersion);
        function resolveEscapes(character) {
          switch (character) {
            case "\n":
            case "\\\n":
              return "\\n";
            case "\r":
            case "\\\r":
              return "\\r";
            case "	":
            case "\\	":
              return "\\t";
            case "\v":
            case "\\\v":
              return "\\v";
            case "\f":
            case "\\\f":
              return "\\f";
            case "/":
              return "\\/";
            default:
              return null;
          }
        }
        function isValidRegexForEcmaVersion(pattern, flags) {
          const validator = new RegExpValidator({ ecmaVersion: regexppEcmaVersion });
          try {
            validator.validatePattern(pattern, 0, pattern.length, flags ? flags.includes("u") : false);
            if (flags) {
              validator.validateFlags(flags);
            }
            return true;
          } catch {
            return false;
          }
        }
        function areFlagsEqual(flagsA, flagsB) {
          return [...flagsA].sort().join("") === [...flagsB].sort().join("");
        }
        function mergeRegexFlags(flagsA, flagsB) {
          const flagsSet = /* @__PURE__ */ new Set([
            ...flagsA,
            ...flagsB
          ]);
          return [...flagsSet].join("");
        }
        function canFixTo(node, pattern, flags) {
          const tokenBefore = sourceCode.getTokenBefore(node);
          return sourceCode.getCommentsInside(node).length === 0 && (!tokenBefore || validPrecedingTokens.has(tokenBefore.value)) && isValidRegexForEcmaVersion(pattern, flags);
        }
        function getSafeOutput(node, newRegExpValue) {
          const tokenBefore = sourceCode.getTokenBefore(node);
          const tokenAfter = sourceCode.getTokenAfter(node);
          return (tokenBefore && !canTokensBeAdjacent(tokenBefore, newRegExpValue) && tokenBefore.range[1] === node.range[0] ? " " : "") + newRegExpValue + (tokenAfter && !canTokensBeAdjacent(newRegExpValue, tokenAfter) && node.range[1] === tokenAfter.range[0] ? " " : "");
        }
        return {
          Program(node) {
            const scope = sourceCode.getScope(node);
            const tracker = new ReferenceTracker(scope);
            const traceMap = {
              RegExp: {
                [CALL]: true,
                [CONSTRUCT]: true
              }
            };
            for (const { node: refNode } of tracker.iterateGlobalReferences(traceMap)) {
              if (disallowRedundantWrapping && isUnnecessarilyWrappedRegexLiteral(refNode)) {
                const regexNode = refNode.arguments[0];
                if (refNode.arguments.length === 2) {
                  const suggests = [];
                  const argFlags = getStringValue(refNode.arguments[1]) || "";
                  if (canFixTo(refNode, regexNode.regex.pattern, argFlags)) {
                    suggests.push({
                      messageId: "replaceWithLiteralAndFlags",
                      pattern: regexNode.regex.pattern,
                      flags: argFlags
                    });
                  }
                  const literalFlags = regexNode.regex.flags || "";
                  const mergedFlags = mergeRegexFlags(literalFlags, argFlags);
                  if (!areFlagsEqual(mergedFlags, argFlags) && canFixTo(refNode, regexNode.regex.pattern, mergedFlags)) {
                    suggests.push({
                      messageId: "replaceWithIntendedLiteralAndFlags",
                      pattern: regexNode.regex.pattern,
                      flags: mergedFlags
                    });
                  }
                  context.report({
                    node: refNode,
                    messageId: "unexpectedRedundantRegExpWithFlags",
                    suggest: suggests.map(({ flags, pattern, messageId }) => ({
                      messageId,
                      data: {
                        flags
                      },
                      fix(fixer) {
                        return fixer.replaceText(refNode, getSafeOutput(refNode, `/${pattern}/${flags}`));
                      }
                    }))
                  });
                } else {
                  const outputs = [];
                  if (canFixTo(refNode, regexNode.regex.pattern, regexNode.regex.flags)) {
                    outputs.push(sourceCode.getText(regexNode));
                  }
                  context.report({
                    node: refNode,
                    messageId: "unexpectedRedundantRegExp",
                    suggest: outputs.map((output) => ({
                      messageId: "replaceWithLiteral",
                      fix(fixer) {
                        return fixer.replaceText(
                          refNode,
                          getSafeOutput(refNode, output)
                        );
                      }
                    }))
                  });
                }
              } else if (hasOnlyStaticStringArguments(refNode)) {
                let regexContent = getStringValue(refNode.arguments[0]);
                let noFix = false;
                let flags;
                if (refNode.arguments[1]) {
                  flags = getStringValue(refNode.arguments[1]);
                }
                if (!canFixTo(refNode, regexContent, flags)) {
                  noFix = true;
                }
                if (!/^[-a-zA-Z0-9\\[\](){} \t\r\n\v\f!@#$%^&*+^_=/~`.><?,'"|:;]*$/u.test(regexContent)) {
                  noFix = true;
                }
                if (regexContent && !noFix) {
                  let charIncrease = 0;
                  const ast = new RegExpParser({ ecmaVersion: regexppEcmaVersion }).parsePattern(regexContent, 0, regexContent.length, flags ? flags.includes("u") : false);
                  visitRegExpAST(ast, {
                    onCharacterEnter(characterNode) {
                      const escaped = resolveEscapes(characterNode.raw);
                      if (escaped) {
                        regexContent = regexContent.slice(0, characterNode.start + charIncrease) + escaped + regexContent.slice(characterNode.end + charIncrease);
                        if (characterNode.raw.length === 1) {
                          charIncrease += 1;
                        }
                      }
                    }
                  });
                }
                const newRegExpValue = `/${regexContent || "(?:)"}/${flags || ""}`;
                context.report({
                  node: refNode,
                  messageId: "unexpectedRegExp",
                  suggest: noFix ? [] : [{
                    messageId: "replaceWithLiteral",
                    fix(fixer) {
                      return fixer.replaceText(refNode, getSafeOutput(refNode, newRegExpValue));
                    }
                  }]
                });
              }
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/prefer-rest-params.js
var require_prefer_rest_params = __commonJS({
  "../../node_modules/eslint/lib/rules/prefer-rest-params.js"(exports, module) {
    "use strict";
    function getVariableOfArguments(scope) {
      const variables = scope.variables;
      for (let i = 0; i < variables.length; ++i) {
        const variable = variables[i];
        if (variable.name === "arguments") {
          return variable.identifiers.length === 0 ? variable : null;
        }
      }
      return null;
    }
    function isNotNormalMemberAccess(reference) {
      const id = reference.identifier;
      const parent = id.parent;
      return !(parent.type === "MemberExpression" && parent.object === id && !parent.computed);
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Require rest parameters instead of `arguments`",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/prefer-rest-params"
        },
        schema: [],
        messages: {
          preferRestParams: "Use the rest parameters instead of 'arguments'."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        function report(reference) {
          context.report({
            node: reference.identifier,
            loc: reference.identifier.loc,
            messageId: "preferRestParams"
          });
        }
        function checkForArguments(node) {
          const argumentsVar = getVariableOfArguments(sourceCode.getScope(node));
          if (argumentsVar) {
            argumentsVar.references.filter(isNotNormalMemberAccess).forEach(report);
          }
        }
        return {
          "FunctionDeclaration:exit": checkForArguments,
          "FunctionExpression:exit": checkForArguments
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/prefer-spread.js
var require_prefer_spread = __commonJS({
  "../../node_modules/eslint/lib/rules/prefer-spread.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    function isVariadicApplyCalling(node) {
      return astUtils.isSpecificMemberAccess(node.callee, null, "apply") && node.arguments.length === 2 && node.arguments[1].type !== "ArrayExpression" && node.arguments[1].type !== "SpreadElement";
    }
    function isValidThisArg(expectedThis, thisArg, context) {
      if (!expectedThis) {
        return astUtils.isNullOrUndefined(thisArg);
      }
      return astUtils.equalTokens(expectedThis, thisArg, context);
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Require spread operators instead of `.apply()`",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/prefer-spread"
        },
        schema: [],
        fixable: null,
        messages: {
          preferSpread: "Use the spread operator instead of '.apply()'."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        return {
          CallExpression(node) {
            if (!isVariadicApplyCalling(node)) {
              return;
            }
            const applied = astUtils.skipChainExpression(astUtils.skipChainExpression(node.callee).object);
            const expectedThis = applied.type === "MemberExpression" ? applied.object : null;
            const thisArg = node.arguments[0];
            if (isValidThisArg(expectedThis, thisArg, sourceCode)) {
              context.report({
                node,
                messageId: "preferSpread"
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/prefer-template.js
var require_prefer_template = __commonJS({
  "../../node_modules/eslint/lib/rules/prefer-template.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    function isConcatenation(node) {
      return node.type === "BinaryExpression" && node.operator === "+";
    }
    function getTopConcatBinaryExpression(node) {
      let currentNode = node;
      while (isConcatenation(currentNode.parent)) {
        currentNode = currentNode.parent;
      }
      return currentNode;
    }
    function hasOctalOrNonOctalDecimalEscapeSequence(node) {
      if (isConcatenation(node)) {
        return hasOctalOrNonOctalDecimalEscapeSequence(node.left) || hasOctalOrNonOctalDecimalEscapeSequence(node.right);
      }
      if (node.type === "Literal" && typeof node.value === "string") {
        return astUtils.hasOctalOrNonOctalDecimalEscapeSequence(node.raw);
      }
      return false;
    }
    function hasStringLiteral(node) {
      if (isConcatenation(node)) {
        return hasStringLiteral(node.right) || hasStringLiteral(node.left);
      }
      return astUtils.isStringLiteral(node);
    }
    function hasNonStringLiteral(node) {
      if (isConcatenation(node)) {
        return hasNonStringLiteral(node.right) || hasNonStringLiteral(node.left);
      }
      return !astUtils.isStringLiteral(node);
    }
    function startsWithTemplateCurly(node) {
      if (node.type === "BinaryExpression") {
        return startsWithTemplateCurly(node.left);
      }
      if (node.type === "TemplateLiteral") {
        return node.expressions.length && node.quasis.length && node.quasis[0].range[0] === node.quasis[0].range[1];
      }
      return node.type !== "Literal" || typeof node.value !== "string";
    }
    function endsWithTemplateCurly(node) {
      if (node.type === "BinaryExpression") {
        return startsWithTemplateCurly(node.right);
      }
      if (node.type === "TemplateLiteral") {
        return node.expressions.length && node.quasis.length && node.quasis[node.quasis.length - 1].range[0] === node.quasis[node.quasis.length - 1].range[1];
      }
      return node.type !== "Literal" || typeof node.value !== "string";
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Require template literals instead of string concatenation",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/prefer-template"
        },
        schema: [],
        fixable: "code",
        messages: {
          unexpectedStringConcatenation: "Unexpected string concatenation."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        let done = /* @__PURE__ */ Object.create(null);
        function getTextBetween(node1, node2) {
          const allTokens = [node1].concat(sourceCode.getTokensBetween(node1, node2)).concat(node2);
          const sourceText = sourceCode.getText();
          return allTokens.slice(0, -1).reduce((accumulator, token, index) => accumulator + sourceText.slice(token.range[1], allTokens[index + 1].range[0]), "");
        }
        function getTemplateLiteral(currentNode, textBeforeNode, textAfterNode) {
          if (currentNode.type === "Literal" && typeof currentNode.value === "string") {
            return `\`${currentNode.raw.slice(1, -1).replace(/\\*(\$\{|`)/gu, (matched) => {
              if (matched.lastIndexOf("\\") % 2) {
                return `\\${matched}`;
              }
              return matched;
            }).replace(new RegExp(`\\\\${currentNode.raw[0]}`, "gu"), currentNode.raw[0])}\``;
          }
          if (currentNode.type === "TemplateLiteral") {
            return sourceCode.getText(currentNode);
          }
          if (isConcatenation(currentNode) && hasStringLiteral(currentNode)) {
            const plusSign = sourceCode.getFirstTokenBetween(currentNode.left, currentNode.right, (token) => token.value === "+");
            const textBeforePlus = getTextBetween(currentNode.left, plusSign);
            const textAfterPlus = getTextBetween(plusSign, currentNode.right);
            const leftEndsWithCurly = endsWithTemplateCurly(currentNode.left);
            const rightStartsWithCurly = startsWithTemplateCurly(currentNode.right);
            if (leftEndsWithCurly) {
              return getTemplateLiteral(currentNode.left, textBeforeNode, textBeforePlus + textAfterPlus).slice(0, -1) + getTemplateLiteral(currentNode.right, null, textAfterNode).slice(1);
            }
            if (rightStartsWithCurly) {
              return getTemplateLiteral(currentNode.left, textBeforeNode, null).slice(0, -1) + getTemplateLiteral(currentNode.right, textBeforePlus + textAfterPlus, textAfterNode).slice(1);
            }
            return `${getTemplateLiteral(currentNode.left, textBeforeNode, null)}${textBeforePlus}+${textAfterPlus}${getTemplateLiteral(currentNode.right, textAfterNode, null)}`;
          }
          return `\`\${${textBeforeNode || ""}${sourceCode.getText(currentNode)}${textAfterNode || ""}}\``;
        }
        function fixNonStringBinaryExpression(fixer, node) {
          const topBinaryExpr = getTopConcatBinaryExpression(node.parent);
          if (hasOctalOrNonOctalDecimalEscapeSequence(topBinaryExpr)) {
            return null;
          }
          return fixer.replaceText(topBinaryExpr, getTemplateLiteral(topBinaryExpr, null, null));
        }
        function checkForStringConcat(node) {
          if (!astUtils.isStringLiteral(node) || !isConcatenation(node.parent)) {
            return;
          }
          const topBinaryExpr = getTopConcatBinaryExpression(node.parent);
          if (done[topBinaryExpr.range[0]]) {
            return;
          }
          done[topBinaryExpr.range[0]] = true;
          if (hasNonStringLiteral(topBinaryExpr)) {
            context.report({
              node: topBinaryExpr,
              messageId: "unexpectedStringConcatenation",
              fix: (fixer) => fixNonStringBinaryExpression(fixer, node)
            });
          }
        }
        return {
          Program() {
            done = /* @__PURE__ */ Object.create(null);
          },
          Literal: checkForStringConcat,
          TemplateLiteral: checkForStringConcat
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/quote-props.js
var require_quote_props = __commonJS({
  "../../node_modules/eslint/lib/rules/quote-props.js"(exports, module) {
    "use strict";
    var espree = require_espree();
    var astUtils = require_ast_utils2();
    var keywords = require_keywords();
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Require quotes around object literal property names",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/quote-props"
        },
        schema: {
          anyOf: [
            {
              type: "array",
              items: [
                {
                  enum: ["always", "as-needed", "consistent", "consistent-as-needed"]
                }
              ],
              minItems: 0,
              maxItems: 1
            },
            {
              type: "array",
              items: [
                {
                  enum: ["always", "as-needed", "consistent", "consistent-as-needed"]
                },
                {
                  type: "object",
                  properties: {
                    keywords: {
                      type: "boolean"
                    },
                    unnecessary: {
                      type: "boolean"
                    },
                    numbers: {
                      type: "boolean"
                    }
                  },
                  additionalProperties: false
                }
              ],
              minItems: 0,
              maxItems: 2
            }
          ]
        },
        fixable: "code",
        messages: {
          requireQuotesDueToReservedWord: "Properties should be quoted as '{{property}}' is a reserved word.",
          inconsistentlyQuotedProperty: "Inconsistently quoted property '{{key}}' found.",
          unnecessarilyQuotedProperty: "Unnecessarily quoted property '{{property}}' found.",
          unquotedReservedProperty: "Unquoted reserved word '{{property}}' used as key.",
          unquotedNumericProperty: "Unquoted number literal '{{property}}' used as key.",
          unquotedPropertyFound: "Unquoted property '{{property}}' found.",
          redundantQuoting: "Properties shouldn't be quoted as all quotes are redundant."
        }
      },
      create(context) {
        const MODE = context.options[0], KEYWORDS = context.options[1] && context.options[1].keywords, CHECK_UNNECESSARY = !context.options[1] || context.options[1].unnecessary !== false, NUMBERS = context.options[1] && context.options[1].numbers, sourceCode = context.sourceCode;
        function isKeyword(tokenStr) {
          return keywords.includes(tokenStr);
        }
        function areQuotesRedundant(rawKey, tokens, skipNumberLiterals) {
          return tokens.length === 1 && tokens[0].start === 0 && tokens[0].end === rawKey.length && (["Identifier", "Keyword", "Null", "Boolean"].includes(tokens[0].type) || tokens[0].type === "Numeric" && !skipNumberLiterals && String(+tokens[0].value) === tokens[0].value);
        }
        function getUnquotedKey(key) {
          return key.type === "Identifier" ? key.name : key.value;
        }
        function getQuotedKey(key) {
          if (key.type === "Literal" && typeof key.value === "string") {
            return sourceCode.getText(key);
          }
          return `"${key.type === "Identifier" ? key.name : key.value}"`;
        }
        function checkUnnecessaryQuotes(node) {
          const key = node.key;
          if (node.method || node.computed || node.shorthand) {
            return;
          }
          if (key.type === "Literal" && typeof key.value === "string") {
            let tokens;
            try {
              tokens = espree.tokenize(key.value);
            } catch {
              return;
            }
            if (tokens.length !== 1) {
              return;
            }
            const isKeywordToken = isKeyword(tokens[0].value);
            if (isKeywordToken && KEYWORDS) {
              return;
            }
            if (CHECK_UNNECESSARY && areQuotesRedundant(key.value, tokens, NUMBERS)) {
              context.report({
                node,
                messageId: "unnecessarilyQuotedProperty",
                data: { property: key.value },
                fix: (fixer) => fixer.replaceText(key, getUnquotedKey(key))
              });
            }
          } else if (KEYWORDS && key.type === "Identifier" && isKeyword(key.name)) {
            context.report({
              node,
              messageId: "unquotedReservedProperty",
              data: { property: key.name },
              fix: (fixer) => fixer.replaceText(key, getQuotedKey(key))
            });
          } else if (NUMBERS && key.type === "Literal" && astUtils.isNumericLiteral(key)) {
            context.report({
              node,
              messageId: "unquotedNumericProperty",
              data: { property: key.value },
              fix: (fixer) => fixer.replaceText(key, getQuotedKey(key))
            });
          }
        }
        function checkOmittedQuotes(node) {
          const key = node.key;
          if (!node.method && !node.computed && !node.shorthand && !(key.type === "Literal" && typeof key.value === "string")) {
            context.report({
              node,
              messageId: "unquotedPropertyFound",
              data: { property: key.name || key.value },
              fix: (fixer) => fixer.replaceText(key, getQuotedKey(key))
            });
          }
        }
        function checkConsistency(node, checkQuotesRedundancy) {
          const quotedProps = [], unquotedProps = [];
          let keywordKeyName = null, necessaryQuotes = false;
          node.properties.forEach((property) => {
            const key = property.key;
            if (!key || property.method || property.computed || property.shorthand) {
              return;
            }
            if (key.type === "Literal" && typeof key.value === "string") {
              quotedProps.push(property);
              if (checkQuotesRedundancy) {
                let tokens;
                try {
                  tokens = espree.tokenize(key.value);
                } catch {
                  necessaryQuotes = true;
                  return;
                }
                necessaryQuotes = necessaryQuotes || !areQuotesRedundant(key.value, tokens) || KEYWORDS && isKeyword(tokens[0].value);
              }
            } else if (KEYWORDS && checkQuotesRedundancy && key.type === "Identifier" && isKeyword(key.name)) {
              unquotedProps.push(property);
              necessaryQuotes = true;
              keywordKeyName = key.name;
            } else {
              unquotedProps.push(property);
            }
          });
          if (checkQuotesRedundancy && quotedProps.length && !necessaryQuotes) {
            quotedProps.forEach((property) => {
              context.report({
                node: property,
                messageId: "redundantQuoting",
                fix: (fixer) => fixer.replaceText(property.key, getUnquotedKey(property.key))
              });
            });
          } else if (unquotedProps.length && keywordKeyName) {
            unquotedProps.forEach((property) => {
              context.report({
                node: property,
                messageId: "requireQuotesDueToReservedWord",
                data: { property: keywordKeyName },
                fix: (fixer) => fixer.replaceText(property.key, getQuotedKey(property.key))
              });
            });
          } else if (quotedProps.length && unquotedProps.length) {
            unquotedProps.forEach((property) => {
              context.report({
                node: property,
                messageId: "inconsistentlyQuotedProperty",
                data: { key: property.key.name || property.key.value },
                fix: (fixer) => fixer.replaceText(property.key, getQuotedKey(property.key))
              });
            });
          }
        }
        return {
          Property(node) {
            if (MODE === "always" || !MODE) {
              checkOmittedQuotes(node);
            }
            if (MODE === "as-needed") {
              checkUnnecessaryQuotes(node);
            }
          },
          ObjectExpression(node) {
            if (MODE === "consistent") {
              checkConsistency(node, false);
            }
            if (MODE === "consistent-as-needed") {
              checkConsistency(node, true);
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/quotes.js
var require_quotes = __commonJS({
  "../../node_modules/eslint/lib/rules/quotes.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var QUOTE_SETTINGS = {
      double: {
        quote: '"',
        alternateQuote: "'",
        description: "doublequote"
      },
      single: {
        quote: "'",
        alternateQuote: '"',
        description: "singlequote"
      },
      backtick: {
        quote: "`",
        alternateQuote: '"',
        description: "backtick"
      }
    };
    var UNESCAPED_LINEBREAK_PATTERN = new RegExp(String.raw`(^|[^\\])(\\\\)*[${Array.from(astUtils.LINEBREAKS).join("")}]`, "u");
    QUOTE_SETTINGS.double.convert = QUOTE_SETTINGS.single.convert = QUOTE_SETTINGS.backtick.convert = function(str) {
      const newQuote = this.quote;
      const oldQuote = str[0];
      if (newQuote === oldQuote) {
        return str;
      }
      return newQuote + str.slice(1, -1).replace(/\\(\$\{|\r\n?|\n|.)|["'`]|\$\{|(\r\n?|\n)/gu, (match, escaped, newline) => {
        if (escaped === oldQuote || oldQuote === "`" && escaped === "${") {
          return escaped;
        }
        if (match === newQuote || newQuote === "`" && match === "${") {
          return `\\${match}`;
        }
        if (newline && oldQuote === "`") {
          return "\\n";
        }
        return match;
      }) + newQuote;
    };
    var AVOID_ESCAPE = "avoid-escape";
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Enforce the consistent use of either backticks, double, or single quotes",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/quotes"
        },
        fixable: "code",
        schema: [
          {
            enum: ["single", "double", "backtick"]
          },
          {
            anyOf: [
              {
                enum: ["avoid-escape"]
              },
              {
                type: "object",
                properties: {
                  avoidEscape: {
                    type: "boolean"
                  },
                  allowTemplateLiterals: {
                    type: "boolean"
                  }
                },
                additionalProperties: false
              }
            ]
          }
        ],
        messages: {
          wrongQuotes: "Strings must use {{description}}."
        }
      },
      create(context) {
        const quoteOption = context.options[0], settings = QUOTE_SETTINGS[quoteOption || "double"], options = context.options[1], allowTemplateLiterals = options && options.allowTemplateLiterals === true, sourceCode = context.sourceCode;
        let avoidEscape = options && options.avoidEscape === true;
        if (options === AVOID_ESCAPE) {
          avoidEscape = true;
        }
        function isJSXLiteral(node) {
          return node.parent.type === "JSXAttribute" || node.parent.type === "JSXElement" || node.parent.type === "JSXFragment";
        }
        function isDirective(node) {
          return node.type === "ExpressionStatement" && node.expression.type === "Literal" && typeof node.expression.value === "string" && !astUtils.isParenthesised(sourceCode, node.expression);
        }
        function isExpressionInOrJustAfterDirectivePrologue(node) {
          if (!astUtils.isTopLevelExpressionStatement(node.parent)) {
            return false;
          }
          const block = node.parent.parent;
          for (let i = 0; i < block.body.length; ++i) {
            const statement = block.body[i];
            if (statement === node.parent) {
              return true;
            }
            if (!isDirective(statement)) {
              break;
            }
          }
          return false;
        }
        function isAllowedAsNonBacktick(node) {
          const parent = node.parent;
          switch (parent.type) {
            case "ExpressionStatement":
              return !astUtils.isParenthesised(sourceCode, node) && isExpressionInOrJustAfterDirectivePrologue(node);
            case "Property":
            case "PropertyDefinition":
            case "MethodDefinition":
              return parent.key === node && !parent.computed;
            case "ImportDeclaration":
            case "ExportNamedDeclaration":
              return parent.source === node;
            case "ExportAllDeclaration":
              return parent.exported === node || parent.source === node;
            case "ImportSpecifier":
              return parent.imported === node;
            case "ExportSpecifier":
              return parent.local === node || parent.exported === node;
            default:
              return false;
          }
        }
        function isUsingFeatureOfTemplateLiteral(node) {
          const hasTag = node.parent.type === "TaggedTemplateExpression" && node === node.parent.quasi;
          if (hasTag) {
            return true;
          }
          const hasStringInterpolation = node.expressions.length > 0;
          if (hasStringInterpolation) {
            return true;
          }
          const isMultilineString = node.quasis.length >= 1 && UNESCAPED_LINEBREAK_PATTERN.test(node.quasis[0].value.raw);
          if (isMultilineString) {
            return true;
          }
          return false;
        }
        return {
          Literal(node) {
            const val = node.value, rawVal = node.raw;
            if (settings && typeof val === "string") {
              let isValid = quoteOption === "backtick" && isAllowedAsNonBacktick(node) || isJSXLiteral(node) || astUtils.isSurroundedBy(rawVal, settings.quote);
              if (!isValid && avoidEscape) {
                isValid = astUtils.isSurroundedBy(rawVal, settings.alternateQuote) && rawVal.includes(settings.quote);
              }
              if (!isValid) {
                context.report({
                  node,
                  messageId: "wrongQuotes",
                  data: {
                    description: settings.description
                  },
                  fix(fixer) {
                    if (quoteOption === "backtick" && astUtils.hasOctalOrNonOctalDecimalEscapeSequence(rawVal)) {
                      return null;
                    }
                    return fixer.replaceText(node, settings.convert(node.raw));
                  }
                });
              }
            }
          },
          TemplateLiteral(node) {
            if (allowTemplateLiterals || quoteOption === "backtick" || isUsingFeatureOfTemplateLiteral(node)) {
              return;
            }
            context.report({
              node,
              messageId: "wrongQuotes",
              data: {
                description: settings.description
              },
              fix(fixer) {
                if (astUtils.isTopLevelExpressionStatement(node.parent) && !astUtils.isParenthesised(sourceCode, node)) {
                  return null;
                }
                return fixer.replaceText(node, settings.convert(sourceCode.getText(node)));
              }
            });
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/radix.js
var require_radix = __commonJS({
  "../../node_modules/eslint/lib/rules/radix.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var MODE_ALWAYS = "always";
    var MODE_AS_NEEDED = "as-needed";
    var validRadixValues = new Set(Array.from({ length: 37 - 2 }, (_, index) => index + 2));
    function isShadowed(variable) {
      return variable.defs.length >= 1;
    }
    function isParseIntMethod(node) {
      return node.type === "MemberExpression" && !node.computed && node.property.type === "Identifier" && node.property.name === "parseInt";
    }
    function isValidRadix(radix) {
      return !(radix.type === "Literal" && !validRadixValues.has(radix.value) || radix.type === "Identifier" && radix.name === "undefined");
    }
    function isDefaultRadix(radix) {
      return radix.type === "Literal" && radix.value === 10;
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Enforce the consistent use of the radix argument when using `parseInt()`",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/radix"
        },
        hasSuggestions: true,
        schema: [
          {
            enum: ["always", "as-needed"]
          }
        ],
        messages: {
          missingParameters: "Missing parameters.",
          redundantRadix: "Redundant radix parameter.",
          missingRadix: "Missing radix parameter.",
          invalidRadix: "Invalid radix parameter, must be an integer between 2 and 36.",
          addRadixParameter10: "Add radix parameter `10` for parsing decimal numbers."
        }
      },
      create(context) {
        const mode = context.options[0] || MODE_ALWAYS;
        const sourceCode = context.sourceCode;
        function checkArguments(node) {
          const args = node.arguments;
          switch (args.length) {
            case 0:
              context.report({
                node,
                messageId: "missingParameters"
              });
              break;
            case 1:
              if (mode === MODE_ALWAYS) {
                context.report({
                  node,
                  messageId: "missingRadix",
                  suggest: [
                    {
                      messageId: "addRadixParameter10",
                      fix(fixer) {
                        const tokens = sourceCode.getTokens(node);
                        const lastToken = tokens[tokens.length - 1];
                        const secondToLastToken = tokens[tokens.length - 2];
                        const hasTrailingComma = secondToLastToken.type === "Punctuator" && secondToLastToken.value === ",";
                        return fixer.insertTextBefore(lastToken, hasTrailingComma ? " 10," : ", 10");
                      }
                    }
                  ]
                });
              }
              break;
            default:
              if (mode === MODE_AS_NEEDED && isDefaultRadix(args[1])) {
                context.report({
                  node,
                  messageId: "redundantRadix"
                });
              } else if (!isValidRadix(args[1])) {
                context.report({
                  node,
                  messageId: "invalidRadix"
                });
              }
              break;
          }
        }
        return {
          "Program:exit"(node) {
            const scope = sourceCode.getScope(node);
            let variable;
            variable = astUtils.getVariableByName(scope, "parseInt");
            if (variable && !isShadowed(variable)) {
              variable.references.forEach((reference) => {
                const idNode = reference.identifier;
                if (astUtils.isCallee(idNode)) {
                  checkArguments(idNode.parent);
                }
              });
            }
            variable = astUtils.getVariableByName(scope, "Number");
            if (variable && !isShadowed(variable)) {
              variable.references.forEach((reference) => {
                const parentNode = reference.identifier.parent;
                const maybeCallee = parentNode.parent.type === "ChainExpression" ? parentNode.parent : parentNode;
                if (isParseIntMethod(parentNode) && astUtils.isCallee(maybeCallee)) {
                  checkArguments(maybeCallee.parent);
                }
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/require-atomic-updates.js
var require_require_atomic_updates = __commonJS({
  "../../node_modules/eslint/lib/rules/require-atomic-updates.js"(exports, module) {
    "use strict";
    function createReferenceMap(scope, outReferenceMap = /* @__PURE__ */ new Map()) {
      for (const reference of scope.references) {
        if (reference.resolved === null) {
          continue;
        }
        outReferenceMap.set(reference.identifier, reference);
      }
      for (const childScope of scope.childScopes) {
        if (childScope.type !== "function") {
          createReferenceMap(childScope, outReferenceMap);
        }
      }
      return outReferenceMap;
    }
    function getWriteExpr(reference) {
      if (reference.writeExpr) {
        return reference.writeExpr;
      }
      let node = reference.identifier;
      while (node) {
        const t = node.parent.type;
        if (t === "AssignmentExpression" && node.parent.left === node) {
          return node.parent.right;
        }
        if (t === "MemberExpression" && node.parent.object === node) {
          node = node.parent;
          continue;
        }
        break;
      }
      return null;
    }
    function isLocalVariableWithoutEscape(variable, isMemberAccess) {
      if (!variable) {
        return false;
      }
      if (isMemberAccess && variable.defs.some((d) => d.type === "Parameter")) {
        return false;
      }
      const functionScope = variable.scope.variableScope;
      return variable.references.every((reference) => reference.from.variableScope === functionScope);
    }
    var SegmentInfo = class {
      constructor() {
        this.info = /* @__PURE__ */ new WeakMap();
      }
      /**
       * Initialize the segment information.
       * @param {PathSegment} segment The segment to initialize.
       * @returns {void}
       */
      initialize(segment) {
        const outdatedReadVariables = /* @__PURE__ */ new Set();
        const freshReadVariables = /* @__PURE__ */ new Set();
        for (const prevSegment of segment.prevSegments) {
          const info = this.info.get(prevSegment);
          if (info) {
            info.outdatedReadVariables.forEach(Set.prototype.add, outdatedReadVariables);
            info.freshReadVariables.forEach(Set.prototype.add, freshReadVariables);
          }
        }
        this.info.set(segment, { outdatedReadVariables, freshReadVariables });
      }
      /**
       * Mark a given variable as read on given segments.
       * @param {PathSegment[]} segments The segments that it read the variable on.
       * @param {Variable} variable The variable to be read.
       * @returns {void}
       */
      markAsRead(segments, variable) {
        for (const segment of segments) {
          const info = this.info.get(segment);
          if (info) {
            info.freshReadVariables.add(variable);
            info.outdatedReadVariables.delete(variable);
          }
        }
      }
      /**
       * Move `freshReadVariables` to `outdatedReadVariables`.
       * @param {PathSegment[]} segments The segments to process.
       * @returns {void}
       */
      makeOutdated(segments) {
        for (const segment of segments) {
          const info = this.info.get(segment);
          if (info) {
            info.freshReadVariables.forEach(Set.prototype.add, info.outdatedReadVariables);
            info.freshReadVariables.clear();
          }
        }
      }
      /**
       * Check if a given variable is outdated on the current segments.
       * @param {PathSegment[]} segments The current segments.
       * @param {Variable} variable The variable to check.
       * @returns {boolean} `true` if the variable is outdated on the segments.
       */
      isOutdated(segments, variable) {
        for (const segment of segments) {
          const info = this.info.get(segment);
          if (info && info.outdatedReadVariables.has(variable)) {
            return true;
          }
        }
        return false;
      }
    };
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Disallow assignments that can lead to race conditions due to usage of `await` or `yield`",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/require-atomic-updates"
        },
        fixable: null,
        schema: [{
          type: "object",
          properties: {
            allowProperties: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }],
        messages: {
          nonAtomicUpdate: "Possible race condition: `{{value}}` might be reassigned based on an outdated value of `{{value}}`.",
          nonAtomicObjectUpdate: "Possible race condition: `{{value}}` might be assigned based on an outdated state of `{{object}}`."
        }
      },
      create(context) {
        const allowProperties = !!context.options[0] && context.options[0].allowProperties;
        const sourceCode = context.sourceCode;
        const assignmentReferences = /* @__PURE__ */ new Map();
        const segmentInfo = new SegmentInfo();
        let stack = null;
        return {
          onCodePathStart(codePath, node) {
            const scope = sourceCode.getScope(node);
            const shouldVerify = scope.type === "function" && (scope.block.async || scope.block.generator);
            stack = {
              upper: stack,
              codePath,
              referenceMap: shouldVerify ? createReferenceMap(scope) : null
            };
          },
          onCodePathEnd() {
            stack = stack.upper;
          },
          // Initialize the segment information.
          onCodePathSegmentStart(segment) {
            segmentInfo.initialize(segment);
          },
          // Handle references to prepare verification.
          Identifier(node) {
            const { codePath, referenceMap } = stack;
            const reference = referenceMap && referenceMap.get(node);
            if (!reference) {
              return;
            }
            const variable = reference.resolved;
            const writeExpr = getWriteExpr(reference);
            const isMemberAccess = reference.identifier.parent.type === "MemberExpression";
            if (reference.isRead() && !(writeExpr && writeExpr.parent.operator === "=")) {
              segmentInfo.markAsRead(codePath.currentSegments, variable);
            }
            if (writeExpr && writeExpr.parent.right === writeExpr && //  exclude variable declarations.
            !isLocalVariableWithoutEscape(variable, isMemberAccess)) {
              let refs = assignmentReferences.get(writeExpr);
              if (!refs) {
                refs = [];
                assignmentReferences.set(writeExpr, refs);
              }
              refs.push(reference);
            }
          },
          /*
           * Verify assignments.
           * If the reference exists in `outdatedReadVariables` list, report it.
           */
          ":expression:exit"(node) {
            const { codePath, referenceMap } = stack;
            if (!referenceMap) {
              return;
            }
            if (node.type === "AwaitExpression" || node.type === "YieldExpression") {
              segmentInfo.makeOutdated(codePath.currentSegments);
            }
            const references = assignmentReferences.get(node);
            if (references) {
              assignmentReferences.delete(node);
              for (const reference of references) {
                const variable = reference.resolved;
                if (segmentInfo.isOutdated(codePath.currentSegments, variable)) {
                  if (node.parent.left === reference.identifier) {
                    context.report({
                      node: node.parent,
                      messageId: "nonAtomicUpdate",
                      data: {
                        value: variable.name
                      }
                    });
                  } else if (!allowProperties) {
                    context.report({
                      node: node.parent,
                      messageId: "nonAtomicObjectUpdate",
                      data: {
                        value: sourceCode.getText(node.parent.left),
                        object: variable.name
                      }
                    });
                  }
                }
              }
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/require-await.js
var require_require_await = __commonJS({
  "../../node_modules/eslint/lib/rules/require-await.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    function capitalizeFirstLetter(text) {
      return text[0].toUpperCase() + text.slice(1);
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Disallow async functions which have no `await` expression",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/require-await"
        },
        schema: [],
        messages: {
          missingAwait: "{{name}} has no 'await' expression."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        let scopeInfo = null;
        function enterFunction() {
          scopeInfo = {
            upper: scopeInfo,
            hasAwait: false
          };
        }
        function exitFunction(node) {
          if (!node.generator && node.async && !scopeInfo.hasAwait && !astUtils.isEmptyFunction(node)) {
            context.report({
              node,
              loc: astUtils.getFunctionHeadLoc(node, sourceCode),
              messageId: "missingAwait",
              data: {
                name: capitalizeFirstLetter(
                  astUtils.getFunctionNameWithKind(node)
                )
              }
            });
          }
          scopeInfo = scopeInfo.upper;
        }
        return {
          FunctionDeclaration: enterFunction,
          FunctionExpression: enterFunction,
          ArrowFunctionExpression: enterFunction,
          "FunctionDeclaration:exit": exitFunction,
          "FunctionExpression:exit": exitFunction,
          "ArrowFunctionExpression:exit": exitFunction,
          AwaitExpression() {
            if (!scopeInfo) {
              return;
            }
            scopeInfo.hasAwait = true;
          },
          ForOfStatement(node) {
            if (!scopeInfo) {
              return;
            }
            if (node.await) {
              scopeInfo.hasAwait = true;
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/require-jsdoc.js
var require_require_jsdoc = __commonJS({
  "../../node_modules/eslint/lib/rules/require-jsdoc.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Require JSDoc comments",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/require-jsdoc"
        },
        schema: [
          {
            type: "object",
            properties: {
              require: {
                type: "object",
                properties: {
                  ClassDeclaration: {
                    type: "boolean",
                    default: false
                  },
                  MethodDefinition: {
                    type: "boolean",
                    default: false
                  },
                  FunctionDeclaration: {
                    type: "boolean",
                    default: true
                  },
                  ArrowFunctionExpression: {
                    type: "boolean",
                    default: false
                  },
                  FunctionExpression: {
                    type: "boolean",
                    default: false
                  }
                },
                additionalProperties: false,
                default: {}
              }
            },
            additionalProperties: false
          }
        ],
        deprecated: true,
        replacedBy: [],
        messages: {
          missingJSDocComment: "Missing JSDoc comment."
        }
      },
      create(context) {
        const source = context.sourceCode;
        const DEFAULT_OPTIONS = {
          FunctionDeclaration: true,
          MethodDefinition: false,
          ClassDeclaration: false,
          ArrowFunctionExpression: false,
          FunctionExpression: false
        };
        const options = Object.assign(DEFAULT_OPTIONS, context.options[0] && context.options[0].require);
        function report(node) {
          context.report({ node, messageId: "missingJSDocComment" });
        }
        function checkJsDoc(node) {
          const jsdocComment = source.getJSDocComment(node);
          if (!jsdocComment) {
            report(node);
          }
        }
        return {
          FunctionDeclaration(node) {
            if (options.FunctionDeclaration) {
              checkJsDoc(node);
            }
          },
          FunctionExpression(node) {
            if (options.MethodDefinition && node.parent.type === "MethodDefinition" || options.FunctionExpression && (node.parent.type === "VariableDeclarator" || node.parent.type === "Property" && node === node.parent.value)) {
              checkJsDoc(node);
            }
          },
          ClassDeclaration(node) {
            if (options.ClassDeclaration) {
              checkJsDoc(node);
            }
          },
          ArrowFunctionExpression(node) {
            if (options.ArrowFunctionExpression && node.parent.type === "VariableDeclarator") {
              checkJsDoc(node);
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/require-unicode-regexp.js
var require_require_unicode_regexp = __commonJS({
  "../../node_modules/eslint/lib/rules/require-unicode-regexp.js"(exports, module) {
    "use strict";
    var {
      CALL,
      CONSTRUCT,
      ReferenceTracker,
      getStringIfConstant
    } = require_eslint_utils();
    var astUtils = require_ast_utils2();
    var { isValidWithUnicodeFlag } = require_regular_expressions();
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Enforce the use of `u` flag on RegExp",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/require-unicode-regexp"
        },
        hasSuggestions: true,
        messages: {
          addUFlag: "Add the 'u' flag.",
          requireUFlag: "Use the 'u' flag."
        },
        schema: []
      },
      create(context) {
        const sourceCode = context.sourceCode;
        return {
          "Literal[regex]"(node) {
            const flags = node.regex.flags || "";
            if (!flags.includes("u")) {
              context.report({
                messageId: "requireUFlag",
                node,
                suggest: isValidWithUnicodeFlag(context.languageOptions.ecmaVersion, node.regex.pattern) ? [
                  {
                    fix(fixer) {
                      return fixer.insertTextAfter(node, "u");
                    },
                    messageId: "addUFlag"
                  }
                ] : null
              });
            }
          },
          Program(node) {
            const scope = sourceCode.getScope(node);
            const tracker = new ReferenceTracker(scope);
            const trackMap = {
              RegExp: { [CALL]: true, [CONSTRUCT]: true }
            };
            for (const { node: refNode } of tracker.iterateGlobalReferences(trackMap)) {
              const [patternNode, flagsNode] = refNode.arguments;
              if (patternNode && patternNode.type === "SpreadElement") {
                continue;
              }
              const pattern = getStringIfConstant(patternNode, scope);
              const flags = getStringIfConstant(flagsNode, scope);
              if (!flagsNode || typeof flags === "string" && !flags.includes("u")) {
                context.report({
                  messageId: "requireUFlag",
                  node: refNode,
                  suggest: typeof pattern === "string" && isValidWithUnicodeFlag(context.languageOptions.ecmaVersion, pattern) ? [
                    {
                      fix(fixer) {
                        if (flagsNode) {
                          if (flagsNode.type === "Literal" && typeof flagsNode.value === "string" || flagsNode.type === "TemplateLiteral") {
                            const flagsNodeText = sourceCode.getText(flagsNode);
                            return fixer.replaceText(flagsNode, [
                              flagsNodeText.slice(0, flagsNodeText.length - 1),
                              flagsNodeText.slice(flagsNodeText.length - 1)
                            ].join("u"));
                          }
                          return null;
                        }
                        const penultimateToken = sourceCode.getLastToken(refNode, { skip: 1 });
                        return fixer.insertTextAfter(
                          penultimateToken,
                          astUtils.isCommaToken(penultimateToken) ? ' "u",' : ', "u"'
                        );
                      },
                      messageId: "addUFlag"
                    }
                  ] : null
                });
              }
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/require-yield.js
var require_require_yield = __commonJS({
  "../../node_modules/eslint/lib/rules/require-yield.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Require generator functions to contain `yield`",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/require-yield"
        },
        schema: [],
        messages: {
          missingYield: "This generator function does not have 'yield'."
        }
      },
      create(context) {
        const stack = [];
        function beginChecking(node) {
          if (node.generator) {
            stack.push(0);
          }
        }
        function endChecking(node) {
          if (!node.generator) {
            return;
          }
          const countYield = stack.pop();
          if (countYield === 0 && node.body.body.length > 0) {
            context.report({ node, messageId: "missingYield" });
          }
        }
        return {
          FunctionDeclaration: beginChecking,
          "FunctionDeclaration:exit": endChecking,
          FunctionExpression: beginChecking,
          "FunctionExpression:exit": endChecking,
          // Increases the count of `yield` keyword.
          YieldExpression() {
            if (stack.length > 0) {
              stack[stack.length - 1] += 1;
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/rest-spread-spacing.js
var require_rest_spread_spacing = __commonJS({
  "../../node_modules/eslint/lib/rules/rest-spread-spacing.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Enforce spacing between rest and spread operators and their expressions",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/rest-spread-spacing"
        },
        fixable: "whitespace",
        schema: [
          {
            enum: ["always", "never"]
          }
        ],
        messages: {
          unexpectedWhitespace: "Unexpected whitespace after {{type}} operator.",
          expectedWhitespace: "Expected whitespace after {{type}} operator."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode, alwaysSpace = context.options[0] === "always";
        function checkWhiteSpace(node) {
          const operator = sourceCode.getFirstToken(node), nextToken = sourceCode.getTokenAfter(operator), hasWhitespace = sourceCode.isSpaceBetweenTokens(operator, nextToken);
          let type;
          switch (node.type) {
            case "SpreadElement":
              type = "spread";
              if (node.parent.type === "ObjectExpression") {
                type += " property";
              }
              break;
            case "RestElement":
              type = "rest";
              if (node.parent.type === "ObjectPattern") {
                type += " property";
              }
              break;
            case "ExperimentalSpreadProperty":
              type = "spread property";
              break;
            case "ExperimentalRestProperty":
              type = "rest property";
              break;
            default:
              return;
          }
          if (alwaysSpace && !hasWhitespace) {
            context.report({
              node,
              loc: operator.loc,
              messageId: "expectedWhitespace",
              data: {
                type
              },
              fix(fixer) {
                return fixer.replaceTextRange([operator.range[1], nextToken.range[0]], " ");
              }
            });
          } else if (!alwaysSpace && hasWhitespace) {
            context.report({
              node,
              loc: {
                start: operator.loc.end,
                end: nextToken.loc.start
              },
              messageId: "unexpectedWhitespace",
              data: {
                type
              },
              fix(fixer) {
                return fixer.removeRange([operator.range[1], nextToken.range[0]]);
              }
            });
          }
        }
        return {
          SpreadElement: checkWhiteSpace,
          RestElement: checkWhiteSpace,
          ExperimentalSpreadProperty: checkWhiteSpace,
          ExperimentalRestProperty: checkWhiteSpace
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/semi.js
var require_semi = __commonJS({
  "../../node_modules/eslint/lib/rules/semi.js"(exports, module) {
    "use strict";
    var FixTracker = require_fix_tracker();
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Require or disallow semicolons instead of ASI",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/semi"
        },
        fixable: "code",
        schema: {
          anyOf: [
            {
              type: "array",
              items: [
                {
                  enum: ["never"]
                },
                {
                  type: "object",
                  properties: {
                    beforeStatementContinuationChars: {
                      enum: ["always", "any", "never"]
                    }
                  },
                  additionalProperties: false
                }
              ],
              minItems: 0,
              maxItems: 2
            },
            {
              type: "array",
              items: [
                {
                  enum: ["always"]
                },
                {
                  type: "object",
                  properties: {
                    omitLastInOneLineBlock: { type: "boolean" },
                    omitLastInOneLineClassBody: { type: "boolean" }
                  },
                  additionalProperties: false
                }
              ],
              minItems: 0,
              maxItems: 2
            }
          ]
        },
        messages: {
          missingSemi: "Missing semicolon.",
          extraSemi: "Extra semicolon."
        }
      },
      create(context) {
        const OPT_OUT_PATTERN = /^[-[(/+`]/u;
        const unsafeClassFieldNames = /* @__PURE__ */ new Set(["get", "set", "static"]);
        const unsafeClassFieldFollowers = /* @__PURE__ */ new Set(["*", "in", "instanceof"]);
        const options = context.options[1];
        const never = context.options[0] === "never";
        const exceptOneLine = Boolean(options && options.omitLastInOneLineBlock);
        const exceptOneLineClassBody = Boolean(options && options.omitLastInOneLineClassBody);
        const beforeStatementContinuationChars = options && options.beforeStatementContinuationChars || "any";
        const sourceCode = context.sourceCode;
        function report(node, missing) {
          const lastToken = sourceCode.getLastToken(node);
          let messageId, fix, loc;
          if (!missing) {
            messageId = "missingSemi";
            loc = {
              start: lastToken.loc.end,
              end: astUtils.getNextLocation(sourceCode, lastToken.loc.end)
            };
            fix = function(fixer) {
              return fixer.insertTextAfter(lastToken, ";");
            };
          } else {
            messageId = "extraSemi";
            loc = lastToken.loc;
            fix = function(fixer) {
              return new FixTracker(fixer, sourceCode).retainSurroundingTokens(lastToken).remove(lastToken);
            };
          }
          context.report({
            node,
            loc,
            messageId,
            fix
          });
        }
        function isRedundantSemi(semiToken) {
          const nextToken = sourceCode.getTokenAfter(semiToken);
          return !nextToken || astUtils.isClosingBraceToken(nextToken) || astUtils.isSemicolonToken(nextToken);
        }
        function isEndOfArrowBlock(lastToken) {
          if (!astUtils.isClosingBraceToken(lastToken)) {
            return false;
          }
          const node = sourceCode.getNodeByRangeIndex(lastToken.range[0]);
          return node.type === "BlockStatement" && node.parent.type === "ArrowFunctionExpression";
        }
        function maybeClassFieldAsiHazard(node) {
          if (node.type !== "PropertyDefinition") {
            return false;
          }
          const needsNameCheck = !node.computed && node.key.type === "Identifier";
          if (needsNameCheck && unsafeClassFieldNames.has(node.key.name)) {
            const isStaticStatic = node.static && node.key.name === "static";
            if (!isStaticStatic && !node.value) {
              return true;
            }
          }
          const followingToken = sourceCode.getTokenAfter(node);
          return unsafeClassFieldFollowers.has(followingToken.value);
        }
        function isOnSameLineWithNextToken(node) {
          const prevToken = sourceCode.getLastToken(node, 1);
          const nextToken = sourceCode.getTokenAfter(node);
          return !!nextToken && astUtils.isTokenOnSameLine(prevToken, nextToken);
        }
        function maybeAsiHazardAfter(node) {
          const t = node.type;
          if (t === "DoWhileStatement" || t === "BreakStatement" || t === "ContinueStatement" || t === "DebuggerStatement" || t === "ImportDeclaration" || t === "ExportAllDeclaration") {
            return false;
          }
          if (t === "ReturnStatement") {
            return Boolean(node.argument);
          }
          if (t === "ExportNamedDeclaration") {
            return Boolean(node.declaration);
          }
          if (isEndOfArrowBlock(sourceCode.getLastToken(node, 1))) {
            return false;
          }
          return true;
        }
        function maybeAsiHazardBefore(token) {
          return Boolean(token) && OPT_OUT_PATTERN.test(token.value) && token.value !== "++" && token.value !== "--";
        }
        function canRemoveSemicolon(node) {
          if (isRedundantSemi(sourceCode.getLastToken(node))) {
            return true;
          }
          if (maybeClassFieldAsiHazard(node)) {
            return false;
          }
          if (isOnSameLineWithNextToken(node)) {
            return false;
          }
          if (node.type !== "PropertyDefinition" && beforeStatementContinuationChars === "never" && !maybeAsiHazardAfter(node)) {
            return true;
          }
          if (!maybeAsiHazardBefore(sourceCode.getTokenAfter(node))) {
            return true;
          }
          return false;
        }
        function isLastInOneLinerBlock(node) {
          const parent = node.parent;
          const nextToken = sourceCode.getTokenAfter(node);
          if (!nextToken || nextToken.value !== "}") {
            return false;
          }
          if (parent.type === "BlockStatement") {
            return parent.loc.start.line === parent.loc.end.line;
          }
          if (parent.type === "StaticBlock") {
            const openingBrace = sourceCode.getFirstToken(parent, { skip: 1 });
            return openingBrace.loc.start.line === parent.loc.end.line;
          }
          return false;
        }
        function isLastInOneLinerClassBody(node) {
          const parent = node.parent;
          const nextToken = sourceCode.getTokenAfter(node);
          if (!nextToken || nextToken.value !== "}") {
            return false;
          }
          if (parent.type === "ClassBody") {
            return parent.loc.start.line === parent.loc.end.line;
          }
          return false;
        }
        function checkForSemicolon(node) {
          const isSemi = astUtils.isSemicolonToken(sourceCode.getLastToken(node));
          if (never) {
            if (isSemi && canRemoveSemicolon(node)) {
              report(node, true);
            } else if (!isSemi && beforeStatementContinuationChars === "always" && node.type !== "PropertyDefinition" && maybeAsiHazardBefore(sourceCode.getTokenAfter(node))) {
              report(node);
            }
          } else {
            const oneLinerBlock = exceptOneLine && isLastInOneLinerBlock(node);
            const oneLinerClassBody = exceptOneLineClassBody && isLastInOneLinerClassBody(node);
            const oneLinerBlockOrClassBody = oneLinerBlock || oneLinerClassBody;
            if (isSemi && oneLinerBlockOrClassBody) {
              report(node, true);
            } else if (!isSemi && !oneLinerBlockOrClassBody) {
              report(node);
            }
          }
        }
        function checkForSemicolonForVariableDeclaration(node) {
          const parent = node.parent;
          if ((parent.type !== "ForStatement" || parent.init !== node) && (!/^For(?:In|Of)Statement/u.test(parent.type) || parent.left !== node)) {
            checkForSemicolon(node);
          }
        }
        return {
          VariableDeclaration: checkForSemicolonForVariableDeclaration,
          ExpressionStatement: checkForSemicolon,
          ReturnStatement: checkForSemicolon,
          ThrowStatement: checkForSemicolon,
          DoWhileStatement: checkForSemicolon,
          DebuggerStatement: checkForSemicolon,
          BreakStatement: checkForSemicolon,
          ContinueStatement: checkForSemicolon,
          ImportDeclaration: checkForSemicolon,
          ExportAllDeclaration: checkForSemicolon,
          ExportNamedDeclaration(node) {
            if (!node.declaration) {
              checkForSemicolon(node);
            }
          },
          ExportDefaultDeclaration(node) {
            if (!/(?:Class|Function)Declaration/u.test(node.declaration.type)) {
              checkForSemicolon(node);
            }
          },
          PropertyDefinition: checkForSemicolon
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/semi-spacing.js
var require_semi_spacing = __commonJS({
  "../../node_modules/eslint/lib/rules/semi-spacing.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Enforce consistent spacing before and after semicolons",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/semi-spacing"
        },
        fixable: "whitespace",
        schema: [
          {
            type: "object",
            properties: {
              before: {
                type: "boolean",
                default: false
              },
              after: {
                type: "boolean",
                default: true
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          unexpectedWhitespaceBefore: "Unexpected whitespace before semicolon.",
          unexpectedWhitespaceAfter: "Unexpected whitespace after semicolon.",
          missingWhitespaceBefore: "Missing whitespace before semicolon.",
          missingWhitespaceAfter: "Missing whitespace after semicolon."
        }
      },
      create(context) {
        const config = context.options[0], sourceCode = context.sourceCode;
        let requireSpaceBefore = false, requireSpaceAfter = true;
        if (typeof config === "object") {
          requireSpaceBefore = config.before;
          requireSpaceAfter = config.after;
        }
        function hasLeadingSpace(token) {
          const tokenBefore = sourceCode.getTokenBefore(token);
          return tokenBefore && astUtils.isTokenOnSameLine(tokenBefore, token) && sourceCode.isSpaceBetweenTokens(tokenBefore, token);
        }
        function hasTrailingSpace(token) {
          const tokenAfter = sourceCode.getTokenAfter(token);
          return tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter) && sourceCode.isSpaceBetweenTokens(token, tokenAfter);
        }
        function isLastTokenInCurrentLine(token) {
          const tokenAfter = sourceCode.getTokenAfter(token);
          return !(tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter));
        }
        function isFirstTokenInCurrentLine(token) {
          const tokenBefore = sourceCode.getTokenBefore(token);
          return !(tokenBefore && astUtils.isTokenOnSameLine(token, tokenBefore));
        }
        function isBeforeClosingParen(token) {
          const nextToken = sourceCode.getTokenAfter(token);
          return nextToken && astUtils.isClosingBraceToken(nextToken) || astUtils.isClosingParenToken(nextToken);
        }
        function checkSemicolonSpacing(token, node) {
          if (astUtils.isSemicolonToken(token)) {
            if (hasLeadingSpace(token)) {
              if (!requireSpaceBefore) {
                const tokenBefore = sourceCode.getTokenBefore(token);
                const loc = {
                  start: tokenBefore.loc.end,
                  end: token.loc.start
                };
                context.report({
                  node,
                  loc,
                  messageId: "unexpectedWhitespaceBefore",
                  fix(fixer) {
                    return fixer.removeRange([tokenBefore.range[1], token.range[0]]);
                  }
                });
              }
            } else {
              if (requireSpaceBefore) {
                const loc = token.loc;
                context.report({
                  node,
                  loc,
                  messageId: "missingWhitespaceBefore",
                  fix(fixer) {
                    return fixer.insertTextBefore(token, " ");
                  }
                });
              }
            }
            if (!isFirstTokenInCurrentLine(token) && !isLastTokenInCurrentLine(token) && !isBeforeClosingParen(token)) {
              if (hasTrailingSpace(token)) {
                if (!requireSpaceAfter) {
                  const tokenAfter = sourceCode.getTokenAfter(token);
                  const loc = {
                    start: token.loc.end,
                    end: tokenAfter.loc.start
                  };
                  context.report({
                    node,
                    loc,
                    messageId: "unexpectedWhitespaceAfter",
                    fix(fixer) {
                      return fixer.removeRange([token.range[1], tokenAfter.range[0]]);
                    }
                  });
                }
              } else {
                if (requireSpaceAfter) {
                  const loc = token.loc;
                  context.report({
                    node,
                    loc,
                    messageId: "missingWhitespaceAfter",
                    fix(fixer) {
                      return fixer.insertTextAfter(token, " ");
                    }
                  });
                }
              }
            }
          }
        }
        function checkNode(node) {
          const token = sourceCode.getLastToken(node);
          checkSemicolonSpacing(token, node);
        }
        return {
          VariableDeclaration: checkNode,
          ExpressionStatement: checkNode,
          BreakStatement: checkNode,
          ContinueStatement: checkNode,
          DebuggerStatement: checkNode,
          DoWhileStatement: checkNode,
          ReturnStatement: checkNode,
          ThrowStatement: checkNode,
          ImportDeclaration: checkNode,
          ExportNamedDeclaration: checkNode,
          ExportAllDeclaration: checkNode,
          ExportDefaultDeclaration: checkNode,
          ForStatement(node) {
            if (node.init) {
              checkSemicolonSpacing(sourceCode.getTokenAfter(node.init), node);
            }
            if (node.test) {
              checkSemicolonSpacing(sourceCode.getTokenAfter(node.test), node);
            }
          },
          PropertyDefinition: checkNode
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/semi-style.js
var require_semi_style = __commonJS({
  "../../node_modules/eslint/lib/rules/semi-style.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var SELECTOR = [
      "BreakStatement",
      "ContinueStatement",
      "DebuggerStatement",
      "DoWhileStatement",
      "ExportAllDeclaration",
      "ExportDefaultDeclaration",
      "ExportNamedDeclaration",
      "ExpressionStatement",
      "ImportDeclaration",
      "ReturnStatement",
      "ThrowStatement",
      "VariableDeclaration",
      "PropertyDefinition"
    ].join(",");
    function getChildren(node) {
      const t = node.type;
      if (t === "BlockStatement" || t === "StaticBlock" || t === "Program" || t === "ClassBody") {
        return node.body;
      }
      if (t === "SwitchCase") {
        return node.consequent;
      }
      return null;
    }
    function isLastChild(node) {
      const t = node.parent.type;
      if (t === "IfStatement" && node.parent.consequent === node && node.parent.alternate) {
        return true;
      }
      if (t === "DoWhileStatement") {
        return true;
      }
      const nodeList = getChildren(node.parent);
      return nodeList !== null && nodeList[nodeList.length - 1] === node;
    }
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Enforce location of semicolons",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/semi-style"
        },
        schema: [{ enum: ["last", "first"] }],
        fixable: "whitespace",
        messages: {
          expectedSemiColon: "Expected this semicolon to be at {{pos}}."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        const option = context.options[0] || "last";
        function check(semiToken, expected) {
          const prevToken = sourceCode.getTokenBefore(semiToken);
          const nextToken = sourceCode.getTokenAfter(semiToken);
          const prevIsSameLine = !prevToken || astUtils.isTokenOnSameLine(prevToken, semiToken);
          const nextIsSameLine = !nextToken || astUtils.isTokenOnSameLine(semiToken, nextToken);
          if (expected === "last" && !prevIsSameLine || expected === "first" && !nextIsSameLine) {
            context.report({
              loc: semiToken.loc,
              messageId: "expectedSemiColon",
              data: {
                pos: expected === "last" ? "the end of the previous line" : "the beginning of the next line"
              },
              fix(fixer) {
                if (prevToken && nextToken && sourceCode.commentsExistBetween(prevToken, nextToken)) {
                  return null;
                }
                const start = prevToken ? prevToken.range[1] : semiToken.range[0];
                const end = nextToken ? nextToken.range[0] : semiToken.range[1];
                const text = expected === "last" ? ";\n" : "\n;";
                return fixer.replaceTextRange([start, end], text);
              }
            });
          }
        }
        return {
          [SELECTOR](node) {
            if (option === "first" && isLastChild(node)) {
              return;
            }
            const lastToken = sourceCode.getLastToken(node);
            if (astUtils.isSemicolonToken(lastToken)) {
              check(lastToken, option);
            }
          },
          ForStatement(node) {
            const firstSemi = node.init && sourceCode.getTokenAfter(node.init, astUtils.isSemicolonToken);
            const secondSemi = node.test && sourceCode.getTokenAfter(node.test, astUtils.isSemicolonToken);
            if (firstSemi) {
              check(firstSemi, "last");
            }
            if (secondSemi) {
              check(secondSemi, "last");
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/sort-imports.js
var require_sort_imports = __commonJS({
  "../../node_modules/eslint/lib/rules/sort-imports.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Enforce sorted import declarations within modules",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/sort-imports"
        },
        schema: [
          {
            type: "object",
            properties: {
              ignoreCase: {
                type: "boolean",
                default: false
              },
              memberSyntaxSortOrder: {
                type: "array",
                items: {
                  enum: ["none", "all", "multiple", "single"]
                },
                uniqueItems: true,
                minItems: 4,
                maxItems: 4
              },
              ignoreDeclarationSort: {
                type: "boolean",
                default: false
              },
              ignoreMemberSort: {
                type: "boolean",
                default: false
              },
              allowSeparatedGroups: {
                type: "boolean",
                default: false
              }
            },
            additionalProperties: false
          }
        ],
        fixable: "code",
        messages: {
          sortImportsAlphabetically: "Imports should be sorted alphabetically.",
          sortMembersAlphabetically: "Member '{{memberName}}' of the import declaration should be sorted alphabetically.",
          unexpectedSyntaxOrder: "Expected '{{syntaxA}}' syntax before '{{syntaxB}}' syntax."
        }
      },
      create(context) {
        const configuration = context.options[0] || {}, ignoreCase = configuration.ignoreCase || false, ignoreDeclarationSort = configuration.ignoreDeclarationSort || false, ignoreMemberSort = configuration.ignoreMemberSort || false, memberSyntaxSortOrder = configuration.memberSyntaxSortOrder || ["none", "all", "multiple", "single"], allowSeparatedGroups = configuration.allowSeparatedGroups || false, sourceCode = context.sourceCode;
        let previousDeclaration = null;
        function usedMemberSyntax(node) {
          if (node.specifiers.length === 0) {
            return "none";
          }
          if (node.specifiers[0].type === "ImportNamespaceSpecifier") {
            return "all";
          }
          if (node.specifiers.length === 1) {
            return "single";
          }
          return "multiple";
        }
        function getMemberParameterGroupIndex(node) {
          return memberSyntaxSortOrder.indexOf(usedMemberSyntax(node));
        }
        function getFirstLocalMemberName(node) {
          if (node.specifiers[0]) {
            return node.specifiers[0].local.name;
          }
          return null;
        }
        function getNumberOfLinesBetween(left, right) {
          return Math.max(right.loc.start.line - left.loc.end.line - 1, 0);
        }
        return {
          ImportDeclaration(node) {
            if (!ignoreDeclarationSort) {
              if (previousDeclaration && allowSeparatedGroups && getNumberOfLinesBetween(previousDeclaration, node) > 0) {
                previousDeclaration = null;
              }
              if (previousDeclaration) {
                const currentMemberSyntaxGroupIndex = getMemberParameterGroupIndex(node), previousMemberSyntaxGroupIndex = getMemberParameterGroupIndex(previousDeclaration);
                let currentLocalMemberName = getFirstLocalMemberName(node), previousLocalMemberName = getFirstLocalMemberName(previousDeclaration);
                if (ignoreCase) {
                  previousLocalMemberName = previousLocalMemberName && previousLocalMemberName.toLowerCase();
                  currentLocalMemberName = currentLocalMemberName && currentLocalMemberName.toLowerCase();
                }
                if (currentMemberSyntaxGroupIndex !== previousMemberSyntaxGroupIndex) {
                  if (currentMemberSyntaxGroupIndex < previousMemberSyntaxGroupIndex) {
                    context.report({
                      node,
                      messageId: "unexpectedSyntaxOrder",
                      data: {
                        syntaxA: memberSyntaxSortOrder[currentMemberSyntaxGroupIndex],
                        syntaxB: memberSyntaxSortOrder[previousMemberSyntaxGroupIndex]
                      }
                    });
                  }
                } else {
                  if (previousLocalMemberName && currentLocalMemberName && currentLocalMemberName < previousLocalMemberName) {
                    context.report({
                      node,
                      messageId: "sortImportsAlphabetically"
                    });
                  }
                }
              }
              previousDeclaration = node;
            }
            if (!ignoreMemberSort) {
              const importSpecifiers = node.specifiers.filter((specifier) => specifier.type === "ImportSpecifier");
              const getSortableName = ignoreCase ? (specifier) => specifier.local.name.toLowerCase() : (specifier) => specifier.local.name;
              const firstUnsortedIndex = importSpecifiers.map(getSortableName).findIndex((name, index, array) => array[index - 1] > name);
              if (firstUnsortedIndex !== -1) {
                context.report({
                  node: importSpecifiers[firstUnsortedIndex],
                  messageId: "sortMembersAlphabetically",
                  data: { memberName: importSpecifiers[firstUnsortedIndex].local.name },
                  fix(fixer) {
                    if (importSpecifiers.some((specifier) => sourceCode.getCommentsBefore(specifier).length || sourceCode.getCommentsAfter(specifier).length)) {
                      return null;
                    }
                    return fixer.replaceTextRange(
                      [importSpecifiers[0].range[0], importSpecifiers[importSpecifiers.length - 1].range[1]],
                      importSpecifiers.slice().sort((specifierA, specifierB) => {
                        const aName = getSortableName(specifierA);
                        const bName = getSortableName(specifierB);
                        return aName > bName ? 1 : -1;
                      }).reduce((sourceText, specifier, index) => {
                        const textAfterSpecifier = index === importSpecifiers.length - 1 ? "" : sourceCode.getText().slice(importSpecifiers[index].range[1], importSpecifiers[index + 1].range[0]);
                        return sourceText + sourceCode.getText(specifier) + textAfterSpecifier;
                      }, "")
                    );
                  }
                });
              }
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/natural-compare/index.js
var require_natural_compare = __commonJS({
  "../../node_modules/natural-compare/index.js"(exports, module) {
    var naturalCompare = function(a, b) {
      var i, codeA, codeB = 1, posA = 0, posB = 0, alphabet = String.alphabet;
      function getCode(str, pos, code) {
        if (code) {
          for (i = pos; code = getCode(str, i), code < 76 && code > 65; )
            ++i;
          return +str.slice(pos - 1, i);
        }
        code = alphabet && alphabet.indexOf(str.charAt(pos));
        return code > -1 ? code + 76 : (code = str.charCodeAt(pos) || 0, code < 45 || code > 127) ? code : code < 46 ? 65 : code < 48 ? code - 1 : code < 58 ? code + 18 : code < 65 ? code - 11 : code < 91 ? code + 11 : code < 97 ? code - 37 : code < 123 ? code + 5 : code - 63;
      }
      if ((a += "") != (b += ""))
        for (; codeB; ) {
          codeA = getCode(a, posA++);
          codeB = getCode(b, posB++);
          if (codeA < 76 && codeB < 76 && codeA > 66 && codeB > 66) {
            codeA = getCode(a, posA, posA);
            codeB = getCode(b, posB, posA = i);
            posB = i;
          }
          if (codeA != codeB)
            return codeA < codeB ? -1 : 1;
        }
      return 0;
    };
    try {
      module.exports = naturalCompare;
    } catch (e) {
      String.naturalCompare = naturalCompare;
    }
  }
});

// ../../node_modules/eslint/lib/rules/sort-keys.js
var require_sort_keys = __commonJS({
  "../../node_modules/eslint/lib/rules/sort-keys.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var naturalCompare = require_natural_compare();
    function getPropertyName(node) {
      const staticName = astUtils.getStaticPropertyName(node);
      if (staticName !== null) {
        return staticName;
      }
      return node.key.name || null;
    }
    var isValidOrders = {
      asc(a, b) {
        return a <= b;
      },
      ascI(a, b) {
        return a.toLowerCase() <= b.toLowerCase();
      },
      ascN(a, b) {
        return naturalCompare(a, b) <= 0;
      },
      ascIN(a, b) {
        return naturalCompare(a.toLowerCase(), b.toLowerCase()) <= 0;
      },
      desc(a, b) {
        return isValidOrders.asc(b, a);
      },
      descI(a, b) {
        return isValidOrders.ascI(b, a);
      },
      descN(a, b) {
        return isValidOrders.ascN(b, a);
      },
      descIN(a, b) {
        return isValidOrders.ascIN(b, a);
      }
    };
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Require object keys to be sorted",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/sort-keys"
        },
        schema: [
          {
            enum: ["asc", "desc"]
          },
          {
            type: "object",
            properties: {
              caseSensitive: {
                type: "boolean",
                default: true
              },
              natural: {
                type: "boolean",
                default: false
              },
              minKeys: {
                type: "integer",
                minimum: 2,
                default: 2
              },
              allowLineSeparatedGroups: {
                type: "boolean",
                default: false
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          sortKeys: "Expected object keys to be in {{natural}}{{insensitive}}{{order}}ending order. '{{thisName}}' should be before '{{prevName}}'."
        }
      },
      create(context) {
        const order = context.options[0] || "asc";
        const options = context.options[1];
        const insensitive = options && options.caseSensitive === false;
        const natural = options && options.natural;
        const minKeys = options && options.minKeys;
        const allowLineSeparatedGroups = options && options.allowLineSeparatedGroups || false;
        const isValidOrder = isValidOrders[order + (insensitive ? "I" : "") + (natural ? "N" : "")];
        let stack = null;
        const sourceCode = context.sourceCode;
        return {
          ObjectExpression(node) {
            stack = {
              upper: stack,
              prevNode: null,
              prevBlankLine: false,
              prevName: null,
              numKeys: node.properties.length
            };
          },
          "ObjectExpression:exit"() {
            stack = stack.upper;
          },
          SpreadElement(node) {
            if (node.parent.type === "ObjectExpression") {
              stack.prevName = null;
            }
          },
          Property(node) {
            if (node.parent.type === "ObjectPattern") {
              return;
            }
            const prevName = stack.prevName;
            const numKeys = stack.numKeys;
            const thisName = getPropertyName(node);
            const tokens = stack.prevNode && sourceCode.getTokensBetween(stack.prevNode, node, { includeComments: true });
            let isBlankLineBetweenNodes = stack.prevBlankLine;
            if (tokens) {
              tokens.forEach((token, index) => {
                const previousToken = tokens[index - 1];
                if (previousToken && token.loc.start.line - previousToken.loc.end.line > 1) {
                  isBlankLineBetweenNodes = true;
                }
              });
              if (!isBlankLineBetweenNodes && node.loc.start.line - tokens[tokens.length - 1].loc.end.line > 1) {
                isBlankLineBetweenNodes = true;
              }
              if (!isBlankLineBetweenNodes && tokens[0].loc.start.line - stack.prevNode.loc.end.line > 1) {
                isBlankLineBetweenNodes = true;
              }
            }
            stack.prevNode = node;
            if (thisName !== null) {
              stack.prevName = thisName;
            }
            if (allowLineSeparatedGroups && isBlankLineBetweenNodes) {
              stack.prevBlankLine = thisName === null;
              return;
            }
            if (prevName === null || thisName === null || numKeys < minKeys) {
              return;
            }
            if (!isValidOrder(prevName, thisName)) {
              context.report({
                node,
                loc: node.key.loc,
                messageId: "sortKeys",
                data: {
                  thisName,
                  prevName,
                  order,
                  insensitive: insensitive ? "insensitive " : "",
                  natural: natural ? "natural " : ""
                }
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/sort-vars.js
var require_sort_vars = __commonJS({
  "../../node_modules/eslint/lib/rules/sort-vars.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Require variables within the same declaration block to be sorted",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/sort-vars"
        },
        schema: [
          {
            type: "object",
            properties: {
              ignoreCase: {
                type: "boolean",
                default: false
              }
            },
            additionalProperties: false
          }
        ],
        fixable: "code",
        messages: {
          sortVars: "Variables within the same declaration block should be sorted alphabetically."
        }
      },
      create(context) {
        const configuration = context.options[0] || {}, ignoreCase = configuration.ignoreCase || false, sourceCode = context.sourceCode;
        return {
          VariableDeclaration(node) {
            const idDeclarations = node.declarations.filter((decl) => decl.id.type === "Identifier");
            const getSortableName = ignoreCase ? (decl) => decl.id.name.toLowerCase() : (decl) => decl.id.name;
            const unfixable = idDeclarations.some((decl) => decl.init !== null && decl.init.type !== "Literal");
            let fixed = false;
            idDeclarations.slice(1).reduce((memo, decl) => {
              const lastVariableName = getSortableName(memo), currentVariableName = getSortableName(decl);
              if (currentVariableName < lastVariableName) {
                context.report({
                  node: decl,
                  messageId: "sortVars",
                  fix(fixer) {
                    if (unfixable || fixed) {
                      return null;
                    }
                    return fixer.replaceTextRange(
                      [idDeclarations[0].range[0], idDeclarations[idDeclarations.length - 1].range[1]],
                      idDeclarations.slice().sort((declA, declB) => {
                        const aName = getSortableName(declA);
                        const bName = getSortableName(declB);
                        return aName > bName ? 1 : -1;
                      }).reduce((sourceText, identifier, index) => {
                        const textAfterIdentifier = index === idDeclarations.length - 1 ? "" : sourceCode.getText().slice(idDeclarations[index].range[1], idDeclarations[index + 1].range[0]);
                        return sourceText + sourceCode.getText(identifier) + textAfterIdentifier;
                      }, "")
                    );
                  }
                });
                fixed = true;
                return memo;
              }
              return decl;
            }, idDeclarations[0]);
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/space-before-blocks.js
var require_space_before_blocks = __commonJS({
  "../../node_modules/eslint/lib/rules/space-before-blocks.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    function isFunctionBody(node) {
      const parent = node.parent;
      return node.type === "BlockStatement" && astUtils.isFunction(parent) && parent.body === node;
    }
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Enforce consistent spacing before blocks",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/space-before-blocks"
        },
        fixable: "whitespace",
        schema: [
          {
            oneOf: [
              {
                enum: ["always", "never"]
              },
              {
                type: "object",
                properties: {
                  keywords: {
                    enum: ["always", "never", "off"]
                  },
                  functions: {
                    enum: ["always", "never", "off"]
                  },
                  classes: {
                    enum: ["always", "never", "off"]
                  }
                },
                additionalProperties: false
              }
            ]
          }
        ],
        messages: {
          unexpectedSpace: "Unexpected space before opening brace.",
          missingSpace: "Missing space before opening brace."
        }
      },
      create(context) {
        const config = context.options[0], sourceCode = context.sourceCode;
        let alwaysFunctions = true, alwaysKeywords = true, alwaysClasses = true, neverFunctions = false, neverKeywords = false, neverClasses = false;
        if (typeof config === "object") {
          alwaysFunctions = config.functions === "always";
          alwaysKeywords = config.keywords === "always";
          alwaysClasses = config.classes === "always";
          neverFunctions = config.functions === "never";
          neverKeywords = config.keywords === "never";
          neverClasses = config.classes === "never";
        } else if (config === "never") {
          alwaysFunctions = false;
          alwaysKeywords = false;
          alwaysClasses = false;
          neverFunctions = true;
          neverKeywords = true;
          neverClasses = true;
        }
        function isConflicted(precedingToken, node) {
          return astUtils.isArrowToken(precedingToken) || astUtils.isKeywordToken(precedingToken) && !isFunctionBody(node) || astUtils.isColonToken(precedingToken) && node.parent && node.parent.type === "SwitchCase" && precedingToken === astUtils.getSwitchCaseColonToken(node.parent, sourceCode);
        }
        function checkPrecedingSpace(node) {
          const precedingToken = sourceCode.getTokenBefore(node);
          if (precedingToken && !isConflicted(precedingToken, node) && astUtils.isTokenOnSameLine(precedingToken, node)) {
            const hasSpace = sourceCode.isSpaceBetweenTokens(precedingToken, node);
            let requireSpace;
            let requireNoSpace;
            if (isFunctionBody(node)) {
              requireSpace = alwaysFunctions;
              requireNoSpace = neverFunctions;
            } else if (node.type === "ClassBody") {
              requireSpace = alwaysClasses;
              requireNoSpace = neverClasses;
            } else {
              requireSpace = alwaysKeywords;
              requireNoSpace = neverKeywords;
            }
            if (requireSpace && !hasSpace) {
              context.report({
                node,
                messageId: "missingSpace",
                fix(fixer) {
                  return fixer.insertTextBefore(node, " ");
                }
              });
            } else if (requireNoSpace && hasSpace) {
              context.report({
                node,
                messageId: "unexpectedSpace",
                fix(fixer) {
                  return fixer.removeRange([precedingToken.range[1], node.range[0]]);
                }
              });
            }
          }
        }
        function checkSpaceBeforeCaseBlock(node) {
          const cases = node.cases;
          let openingBrace;
          if (cases.length > 0) {
            openingBrace = sourceCode.getTokenBefore(cases[0]);
          } else {
            openingBrace = sourceCode.getLastToken(node, 1);
          }
          checkPrecedingSpace(openingBrace);
        }
        return {
          BlockStatement: checkPrecedingSpace,
          ClassBody: checkPrecedingSpace,
          SwitchStatement: checkSpaceBeforeCaseBlock
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/space-before-function-paren.js
var require_space_before_function_paren = __commonJS({
  "../../node_modules/eslint/lib/rules/space-before-function-paren.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Enforce consistent spacing before `function` definition opening parenthesis",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/space-before-function-paren"
        },
        fixable: "whitespace",
        schema: [
          {
            oneOf: [
              {
                enum: ["always", "never"]
              },
              {
                type: "object",
                properties: {
                  anonymous: {
                    enum: ["always", "never", "ignore"]
                  },
                  named: {
                    enum: ["always", "never", "ignore"]
                  },
                  asyncArrow: {
                    enum: ["always", "never", "ignore"]
                  }
                },
                additionalProperties: false
              }
            ]
          }
        ],
        messages: {
          unexpectedSpace: "Unexpected space before function parentheses.",
          missingSpace: "Missing space before function parentheses."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        const baseConfig = typeof context.options[0] === "string" ? context.options[0] : "always";
        const overrideConfig = typeof context.options[0] === "object" ? context.options[0] : {};
        function isNamedFunction(node) {
          if (node.id) {
            return true;
          }
          const parent = node.parent;
          return parent.type === "MethodDefinition" || parent.type === "Property" && (parent.kind === "get" || parent.kind === "set" || parent.method);
        }
        function getConfigForFunction(node) {
          if (node.type === "ArrowFunctionExpression") {
            if (node.async && astUtils.isOpeningParenToken(sourceCode.getFirstToken(node, { skip: 1 }))) {
              return overrideConfig.asyncArrow || baseConfig;
            }
          } else if (isNamedFunction(node)) {
            return overrideConfig.named || baseConfig;
          } else if (!node.generator) {
            return overrideConfig.anonymous || baseConfig;
          }
          return "ignore";
        }
        function checkFunction(node) {
          const functionConfig = getConfigForFunction(node);
          if (functionConfig === "ignore") {
            return;
          }
          const rightToken = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);
          const leftToken = sourceCode.getTokenBefore(rightToken);
          const hasSpacing = sourceCode.isSpaceBetweenTokens(leftToken, rightToken);
          if (hasSpacing && functionConfig === "never") {
            context.report({
              node,
              loc: {
                start: leftToken.loc.end,
                end: rightToken.loc.start
              },
              messageId: "unexpectedSpace",
              fix(fixer) {
                const comments = sourceCode.getCommentsBefore(rightToken);
                if (comments.some((comment) => comment.type === "Line")) {
                  return null;
                }
                return fixer.replaceTextRange(
                  [leftToken.range[1], rightToken.range[0]],
                  comments.reduce((text, comment) => text + sourceCode.getText(comment), "")
                );
              }
            });
          } else if (!hasSpacing && functionConfig === "always") {
            context.report({
              node,
              loc: rightToken.loc,
              messageId: "missingSpace",
              fix: (fixer) => fixer.insertTextAfter(leftToken, " ")
            });
          }
        }
        return {
          ArrowFunctionExpression: checkFunction,
          FunctionDeclaration: checkFunction,
          FunctionExpression: checkFunction
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/space-in-parens.js
var require_space_in_parens = __commonJS({
  "../../node_modules/eslint/lib/rules/space-in-parens.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Enforce consistent spacing inside parentheses",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/space-in-parens"
        },
        fixable: "whitespace",
        schema: [
          {
            enum: ["always", "never"]
          },
          {
            type: "object",
            properties: {
              exceptions: {
                type: "array",
                items: {
                  enum: ["{}", "[]", "()", "empty"]
                },
                uniqueItems: true
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          missingOpeningSpace: "There must be a space after this paren.",
          missingClosingSpace: "There must be a space before this paren.",
          rejectedOpeningSpace: "There should be no space after this paren.",
          rejectedClosingSpace: "There should be no space before this paren."
        }
      },
      create(context) {
        const ALWAYS = context.options[0] === "always", exceptionsArrayOptions = context.options[1] && context.options[1].exceptions || [], options = {};
        let exceptions;
        if (exceptionsArrayOptions.length) {
          options.braceException = exceptionsArrayOptions.includes("{}");
          options.bracketException = exceptionsArrayOptions.includes("[]");
          options.parenException = exceptionsArrayOptions.includes("()");
          options.empty = exceptionsArrayOptions.includes("empty");
        }
        function getExceptions() {
          const openers = [], closers = [];
          if (options.braceException) {
            openers.push("{");
            closers.push("}");
          }
          if (options.bracketException) {
            openers.push("[");
            closers.push("]");
          }
          if (options.parenException) {
            openers.push("(");
            closers.push(")");
          }
          if (options.empty) {
            openers.push(")");
            closers.push("(");
          }
          return {
            openers,
            closers
          };
        }
        const sourceCode = context.sourceCode;
        function isOpenerException(token) {
          return exceptions.openers.includes(token.value);
        }
        function isCloserException(token) {
          return exceptions.closers.includes(token.value);
        }
        function openerMissingSpace(openingParenToken, tokenAfterOpeningParen) {
          if (sourceCode.isSpaceBetweenTokens(openingParenToken, tokenAfterOpeningParen)) {
            return false;
          }
          if (!options.empty && astUtils.isClosingParenToken(tokenAfterOpeningParen)) {
            return false;
          }
          if (ALWAYS) {
            return !isOpenerException(tokenAfterOpeningParen);
          }
          return isOpenerException(tokenAfterOpeningParen);
        }
        function openerRejectsSpace(openingParenToken, tokenAfterOpeningParen) {
          if (!astUtils.isTokenOnSameLine(openingParenToken, tokenAfterOpeningParen)) {
            return false;
          }
          if (tokenAfterOpeningParen.type === "Line") {
            return false;
          }
          if (!sourceCode.isSpaceBetweenTokens(openingParenToken, tokenAfterOpeningParen)) {
            return false;
          }
          if (ALWAYS) {
            return isOpenerException(tokenAfterOpeningParen);
          }
          return !isOpenerException(tokenAfterOpeningParen);
        }
        function closerMissingSpace(tokenBeforeClosingParen, closingParenToken) {
          if (sourceCode.isSpaceBetweenTokens(tokenBeforeClosingParen, closingParenToken)) {
            return false;
          }
          if (!options.empty && astUtils.isOpeningParenToken(tokenBeforeClosingParen)) {
            return false;
          }
          if (ALWAYS) {
            return !isCloserException(tokenBeforeClosingParen);
          }
          return isCloserException(tokenBeforeClosingParen);
        }
        function closerRejectsSpace(tokenBeforeClosingParen, closingParenToken) {
          if (!astUtils.isTokenOnSameLine(tokenBeforeClosingParen, closingParenToken)) {
            return false;
          }
          if (!sourceCode.isSpaceBetweenTokens(tokenBeforeClosingParen, closingParenToken)) {
            return false;
          }
          if (ALWAYS) {
            return isCloserException(tokenBeforeClosingParen);
          }
          return !isCloserException(tokenBeforeClosingParen);
        }
        return {
          Program: function checkParenSpaces(node) {
            exceptions = getExceptions();
            const tokens = sourceCode.tokensAndComments;
            tokens.forEach((token, i) => {
              const prevToken = tokens[i - 1];
              const nextToken = tokens[i + 1];
              if (!astUtils.isOpeningParenToken(token) && !astUtils.isClosingParenToken(token)) {
                return;
              }
              if (token.value === "(" && openerMissingSpace(token, nextToken)) {
                context.report({
                  node,
                  loc: token.loc,
                  messageId: "missingOpeningSpace",
                  fix(fixer) {
                    return fixer.insertTextAfter(token, " ");
                  }
                });
              }
              if (token.value === "(" && openerRejectsSpace(token, nextToken)) {
                context.report({
                  node,
                  loc: { start: token.loc.end, end: nextToken.loc.start },
                  messageId: "rejectedOpeningSpace",
                  fix(fixer) {
                    return fixer.removeRange([token.range[1], nextToken.range[0]]);
                  }
                });
              }
              if (token.value === ")" && closerMissingSpace(prevToken, token)) {
                context.report({
                  node,
                  loc: token.loc,
                  messageId: "missingClosingSpace",
                  fix(fixer) {
                    return fixer.insertTextBefore(token, " ");
                  }
                });
              }
              if (token.value === ")" && closerRejectsSpace(prevToken, token)) {
                context.report({
                  node,
                  loc: { start: prevToken.loc.end, end: token.loc.start },
                  messageId: "rejectedClosingSpace",
                  fix(fixer) {
                    return fixer.removeRange([prevToken.range[1], token.range[0]]);
                  }
                });
              }
            });
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/space-infix-ops.js
var require_space_infix_ops = __commonJS({
  "../../node_modules/eslint/lib/rules/space-infix-ops.js"(exports, module) {
    "use strict";
    var { isEqToken } = require_ast_utils2();
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Require spacing around infix operators",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/space-infix-ops"
        },
        fixable: "whitespace",
        schema: [
          {
            type: "object",
            properties: {
              int32Hint: {
                type: "boolean",
                default: false
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          missingSpace: "Operator '{{operator}}' must be spaced."
        }
      },
      create(context) {
        const int32Hint = context.options[0] ? context.options[0].int32Hint === true : false;
        const sourceCode = context.sourceCode;
        function getFirstNonSpacedToken(left, right, op) {
          const operator = sourceCode.getFirstTokenBetween(left, right, (token) => token.value === op);
          const prev = sourceCode.getTokenBefore(operator);
          const next = sourceCode.getTokenAfter(operator);
          if (!sourceCode.isSpaceBetweenTokens(prev, operator) || !sourceCode.isSpaceBetweenTokens(operator, next)) {
            return operator;
          }
          return null;
        }
        function report(mainNode, culpritToken) {
          context.report({
            node: mainNode,
            loc: culpritToken.loc,
            messageId: "missingSpace",
            data: {
              operator: culpritToken.value
            },
            fix(fixer) {
              const previousToken = sourceCode.getTokenBefore(culpritToken);
              const afterToken = sourceCode.getTokenAfter(culpritToken);
              let fixString = "";
              if (culpritToken.range[0] - previousToken.range[1] === 0) {
                fixString = " ";
              }
              fixString += culpritToken.value;
              if (afterToken.range[0] - culpritToken.range[1] === 0) {
                fixString += " ";
              }
              return fixer.replaceText(culpritToken, fixString);
            }
          });
        }
        function checkBinary(node) {
          const leftNode = node.left.typeAnnotation ? node.left.typeAnnotation : node.left;
          const rightNode = node.right;
          const operator = node.operator || "=";
          const nonSpacedNode = getFirstNonSpacedToken(leftNode, rightNode, operator);
          if (nonSpacedNode) {
            if (!(int32Hint && sourceCode.getText(node).endsWith("|0"))) {
              report(node, nonSpacedNode);
            }
          }
        }
        function checkConditional(node) {
          const nonSpacedConsequentNode = getFirstNonSpacedToken(node.test, node.consequent, "?");
          const nonSpacedAlternateNode = getFirstNonSpacedToken(node.consequent, node.alternate, ":");
          if (nonSpacedConsequentNode) {
            report(node, nonSpacedConsequentNode);
          }
          if (nonSpacedAlternateNode) {
            report(node, nonSpacedAlternateNode);
          }
        }
        function checkVar(node) {
          const leftNode = node.id.typeAnnotation ? node.id.typeAnnotation : node.id;
          const rightNode = node.init;
          if (rightNode) {
            const nonSpacedNode = getFirstNonSpacedToken(leftNode, rightNode, "=");
            if (nonSpacedNode) {
              report(node, nonSpacedNode);
            }
          }
        }
        return {
          AssignmentExpression: checkBinary,
          AssignmentPattern: checkBinary,
          BinaryExpression: checkBinary,
          LogicalExpression: checkBinary,
          ConditionalExpression: checkConditional,
          VariableDeclarator: checkVar,
          PropertyDefinition(node) {
            if (!node.value) {
              return;
            }
            const operatorToken = sourceCode.getTokenBefore(node.value, isEqToken);
            const leftToken = sourceCode.getTokenBefore(operatorToken);
            const rightToken = sourceCode.getTokenAfter(operatorToken);
            if (!sourceCode.isSpaceBetweenTokens(leftToken, operatorToken) || !sourceCode.isSpaceBetweenTokens(operatorToken, rightToken)) {
              report(node, operatorToken);
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/space-unary-ops.js
var require_space_unary_ops = __commonJS({
  "../../node_modules/eslint/lib/rules/space-unary-ops.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Enforce consistent spacing before or after unary operators",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/space-unary-ops"
        },
        fixable: "whitespace",
        schema: [
          {
            type: "object",
            properties: {
              words: {
                type: "boolean",
                default: true
              },
              nonwords: {
                type: "boolean",
                default: false
              },
              overrides: {
                type: "object",
                additionalProperties: {
                  type: "boolean"
                }
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          unexpectedBefore: "Unexpected space before unary operator '{{operator}}'.",
          unexpectedAfter: "Unexpected space after unary operator '{{operator}}'.",
          unexpectedAfterWord: "Unexpected space after unary word operator '{{word}}'.",
          wordOperator: "Unary word operator '{{word}}' must be followed by whitespace.",
          operator: "Unary operator '{{operator}}' must be followed by whitespace.",
          beforeUnaryExpressions: "Space is required before unary expressions '{{token}}'."
        }
      },
      create(context) {
        const options = context.options[0] || { words: true, nonwords: false };
        const sourceCode = context.sourceCode;
        function isFirstBangInBangBangExpression(node) {
          return node && node.type === "UnaryExpression" && node.argument.operator === "!" && node.argument && node.argument.type === "UnaryExpression" && node.argument.operator === "!";
        }
        function overrideExistsForOperator(operator) {
          return options.overrides && Object.prototype.hasOwnProperty.call(options.overrides, operator);
        }
        function overrideEnforcesSpaces(operator) {
          return options.overrides[operator];
        }
        function verifyWordHasSpaces(node, firstToken, secondToken, word) {
          if (secondToken.range[0] === firstToken.range[1]) {
            context.report({
              node,
              messageId: "wordOperator",
              data: {
                word
              },
              fix(fixer) {
                return fixer.insertTextAfter(firstToken, " ");
              }
            });
          }
        }
        function verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word) {
          if (astUtils.canTokensBeAdjacent(firstToken, secondToken)) {
            if (secondToken.range[0] > firstToken.range[1]) {
              context.report({
                node,
                messageId: "unexpectedAfterWord",
                data: {
                  word
                },
                fix(fixer) {
                  return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);
                }
              });
            }
          }
        }
        function checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, word) {
          if (overrideExistsForOperator(word)) {
            if (overrideEnforcesSpaces(word)) {
              verifyWordHasSpaces(node, firstToken, secondToken, word);
            } else {
              verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);
            }
          } else if (options.words) {
            verifyWordHasSpaces(node, firstToken, secondToken, word);
          } else {
            verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);
          }
        }
        function checkForSpacesAfterYield(node) {
          const tokens = sourceCode.getFirstTokens(node, 3), word = "yield";
          if (!node.argument || node.delegate) {
            return;
          }
          checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], word);
        }
        function checkForSpacesAfterAwait(node) {
          const tokens = sourceCode.getFirstTokens(node, 3);
          checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], "await");
        }
        function verifyNonWordsHaveSpaces(node, firstToken, secondToken) {
          if (node.prefix) {
            if (isFirstBangInBangBangExpression(node)) {
              return;
            }
            if (firstToken.range[1] === secondToken.range[0]) {
              context.report({
                node,
                messageId: "operator",
                data: {
                  operator: firstToken.value
                },
                fix(fixer) {
                  return fixer.insertTextAfter(firstToken, " ");
                }
              });
            }
          } else {
            if (firstToken.range[1] === secondToken.range[0]) {
              context.report({
                node,
                messageId: "beforeUnaryExpressions",
                data: {
                  token: secondToken.value
                },
                fix(fixer) {
                  return fixer.insertTextBefore(secondToken, " ");
                }
              });
            }
          }
        }
        function verifyNonWordsDontHaveSpaces(node, firstToken, secondToken) {
          if (node.prefix) {
            if (secondToken.range[0] > firstToken.range[1]) {
              context.report({
                node,
                messageId: "unexpectedAfter",
                data: {
                  operator: firstToken.value
                },
                fix(fixer) {
                  if (astUtils.canTokensBeAdjacent(firstToken, secondToken)) {
                    return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);
                  }
                  return null;
                }
              });
            }
          } else {
            if (secondToken.range[0] > firstToken.range[1]) {
              context.report({
                node,
                messageId: "unexpectedBefore",
                data: {
                  operator: secondToken.value
                },
                fix(fixer) {
                  return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);
                }
              });
            }
          }
        }
        function checkForSpaces(node) {
          const tokens = node.type === "UpdateExpression" && !node.prefix ? sourceCode.getLastTokens(node, 2) : sourceCode.getFirstTokens(node, 2);
          const firstToken = tokens[0];
          const secondToken = tokens[1];
          if ((node.type === "NewExpression" || node.prefix) && firstToken.type === "Keyword") {
            checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, firstToken.value);
            return;
          }
          const operator = node.prefix ? tokens[0].value : tokens[1].value;
          if (overrideExistsForOperator(operator)) {
            if (overrideEnforcesSpaces(operator)) {
              verifyNonWordsHaveSpaces(node, firstToken, secondToken);
            } else {
              verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);
            }
          } else if (options.nonwords) {
            verifyNonWordsHaveSpaces(node, firstToken, secondToken);
          } else {
            verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);
          }
        }
        return {
          UnaryExpression: checkForSpaces,
          UpdateExpression: checkForSpaces,
          NewExpression: checkForSpaces,
          YieldExpression: checkForSpacesAfterYield,
          AwaitExpression: checkForSpacesAfterAwait
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/spaced-comment.js
var require_spaced_comment = __commonJS({
  "../../node_modules/eslint/lib/rules/spaced-comment.js"(exports, module) {
    "use strict";
    var escapeRegExp = require_escape_string_regexp();
    var astUtils = require_ast_utils2();
    function escape2(s) {
      return `(?:${escapeRegExp(s)})`;
    }
    function escapeAndRepeat(s) {
      return `${escape2(s)}+`;
    }
    function parseMarkersOption(markers) {
      if (!markers.includes("*")) {
        return markers.concat("*");
      }
      return markers;
    }
    function createExceptionsPattern(exceptions) {
      let pattern = "";
      if (exceptions.length === 0) {
        pattern += "\\s";
      } else {
        pattern += "(?:\\s|";
        if (exceptions.length === 1) {
          pattern += escapeAndRepeat(exceptions[0]);
        } else {
          pattern += "(?:";
          pattern += exceptions.map(escapeAndRepeat).join("|");
          pattern += ")";
        }
        pattern += `(?:$|[${Array.from(astUtils.LINEBREAKS).join("")}]))`;
      }
      return pattern;
    }
    function createAlwaysStylePattern(markers, exceptions) {
      let pattern = "^";
      if (markers.length === 1) {
        pattern += escape2(markers[0]);
      } else {
        pattern += "(?:";
        pattern += markers.map(escape2).join("|");
        pattern += ")";
      }
      pattern += "?";
      pattern += createExceptionsPattern(exceptions);
      return new RegExp(pattern, "u");
    }
    function createNeverStylePattern(markers) {
      const pattern = `^(${markers.map(escape2).join("|")})?[ 	]+`;
      return new RegExp(pattern, "u");
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Enforce consistent spacing after the `//` or `/*` in a comment",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/spaced-comment"
        },
        fixable: "whitespace",
        schema: [
          {
            enum: ["always", "never"]
          },
          {
            type: "object",
            properties: {
              exceptions: {
                type: "array",
                items: {
                  type: "string"
                }
              },
              markers: {
                type: "array",
                items: {
                  type: "string"
                }
              },
              line: {
                type: "object",
                properties: {
                  exceptions: {
                    type: "array",
                    items: {
                      type: "string"
                    }
                  },
                  markers: {
                    type: "array",
                    items: {
                      type: "string"
                    }
                  }
                },
                additionalProperties: false
              },
              block: {
                type: "object",
                properties: {
                  exceptions: {
                    type: "array",
                    items: {
                      type: "string"
                    }
                  },
                  markers: {
                    type: "array",
                    items: {
                      type: "string"
                    }
                  },
                  balanced: {
                    type: "boolean",
                    default: false
                  }
                },
                additionalProperties: false
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          unexpectedSpaceAfterMarker: "Unexpected space or tab after marker ({{refChar}}) in comment.",
          expectedExceptionAfter: "Expected exception block, space or tab after '{{refChar}}' in comment.",
          unexpectedSpaceBefore: "Unexpected space or tab before '*/' in comment.",
          unexpectedSpaceAfter: "Unexpected space or tab after '{{refChar}}' in comment.",
          expectedSpaceBefore: "Expected space or tab before '*/' in comment.",
          expectedSpaceAfter: "Expected space or tab after '{{refChar}}' in comment."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        const requireSpace = context.options[0] !== "never";
        const config = context.options[1] || {};
        const balanced = config.block && config.block.balanced;
        const styleRules = ["block", "line"].reduce((rule, type) => {
          const markers = parseMarkersOption(config[type] && config[type].markers || config.markers || []);
          const exceptions = config[type] && config[type].exceptions || config.exceptions || [];
          const endNeverPattern = "[ 	]+$";
          rule[type] = {
            beginRegex: requireSpace ? createAlwaysStylePattern(markers, exceptions) : createNeverStylePattern(markers),
            endRegex: balanced && requireSpace ? new RegExp(`${createExceptionsPattern(exceptions)}$`, "u") : new RegExp(endNeverPattern, "u"),
            hasExceptions: exceptions.length > 0,
            captureMarker: new RegExp(`^(${markers.map(escape2).join("|")})`, "u"),
            markers: new Set(markers)
          };
          return rule;
        }, {});
        function reportBegin(node, messageId, match, refChar) {
          const type = node.type.toLowerCase(), commentIdentifier = type === "block" ? "/*" : "//";
          context.report({
            node,
            fix(fixer) {
              const start = node.range[0];
              let end = start + 2;
              if (requireSpace) {
                if (match) {
                  end += match[0].length;
                }
                return fixer.insertTextAfterRange([start, end], " ");
              }
              end += match[0].length;
              return fixer.replaceTextRange([start, end], commentIdentifier + (match[1] ? match[1] : ""));
            },
            messageId,
            data: { refChar }
          });
        }
        function reportEnd(node, messageId, match) {
          context.report({
            node,
            fix(fixer) {
              if (requireSpace) {
                return fixer.insertTextAfterRange([node.range[0], node.range[1] - 2], " ");
              }
              const end = node.range[1] - 2, start = end - match[0].length;
              return fixer.replaceTextRange([start, end], "");
            },
            messageId
          });
        }
        function checkCommentForSpace(node) {
          const type = node.type.toLowerCase(), rule = styleRules[type], commentIdentifier = type === "block" ? "/*" : "//";
          if (node.value.length === 0 || rule.markers.has(node.value)) {
            return;
          }
          const beginMatch = rule.beginRegex.exec(node.value);
          const endMatch = rule.endRegex.exec(node.value);
          if (requireSpace) {
            if (!beginMatch) {
              const hasMarker = rule.captureMarker.exec(node.value);
              const marker = hasMarker ? commentIdentifier + hasMarker[0] : commentIdentifier;
              if (rule.hasExceptions) {
                reportBegin(node, "expectedExceptionAfter", hasMarker, marker);
              } else {
                reportBegin(node, "expectedSpaceAfter", hasMarker, marker);
              }
            }
            if (balanced && type === "block" && !endMatch) {
              reportEnd(node, "expectedSpaceBefore");
            }
          } else {
            if (beginMatch) {
              if (!beginMatch[1]) {
                reportBegin(node, "unexpectedSpaceAfter", beginMatch, commentIdentifier);
              } else {
                reportBegin(node, "unexpectedSpaceAfterMarker", beginMatch, beginMatch[1]);
              }
            }
            if (balanced && type === "block" && endMatch) {
              reportEnd(node, "unexpectedSpaceBefore", endMatch);
            }
          }
        }
        return {
          Program() {
            const comments = sourceCode.getAllComments();
            comments.filter((token) => token.type !== "Shebang").forEach(checkCommentForSpace);
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/strict.js
var require_strict = __commonJS({
  "../../node_modules/eslint/lib/rules/strict.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    function getUseStrictDirectives(statements) {
      const directives = [];
      for (let i = 0; i < statements.length; i++) {
        const statement = statements[i];
        if (statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && statement.expression.value === "use strict") {
          directives[i] = statement;
        } else {
          break;
        }
      }
      return directives;
    }
    function isSimpleParameter(node) {
      return node.type === "Identifier";
    }
    function isSimpleParameterList(params) {
      return params.every(isSimpleParameter);
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Require or disallow strict mode directives",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/strict"
        },
        schema: [
          {
            enum: ["never", "global", "function", "safe"]
          }
        ],
        fixable: "code",
        messages: {
          function: "Use the function form of 'use strict'.",
          global: "Use the global form of 'use strict'.",
          multiple: "Multiple 'use strict' directives.",
          never: "Strict mode is not permitted.",
          unnecessary: "Unnecessary 'use strict' directive.",
          module: "'use strict' is unnecessary inside of modules.",
          implied: "'use strict' is unnecessary when implied strict mode is enabled.",
          unnecessaryInClasses: "'use strict' is unnecessary inside of classes.",
          nonSimpleParameterList: "'use strict' directive inside a function with non-simple parameter list throws a syntax error since ES2016.",
          wrap: "Wrap {{name}} in a function with 'use strict' directive."
        }
      },
      create(context) {
        const ecmaFeatures = context.parserOptions.ecmaFeatures || {}, scopes = [], classScopes = [];
        let mode = context.options[0] || "safe";
        if (ecmaFeatures.impliedStrict) {
          mode = "implied";
        } else if (mode === "safe") {
          mode = ecmaFeatures.globalReturn || context.languageOptions.sourceType === "commonjs" ? "global" : "function";
        }
        function shouldFix(errorType) {
          return errorType === "multiple" || errorType === "unnecessary" || errorType === "module" || errorType === "implied" || errorType === "unnecessaryInClasses";
        }
        function getFixFunction(node) {
          return (fixer) => fixer.remove(node);
        }
        function reportSlice(nodes, start, end, messageId, fix) {
          nodes.slice(start, end).forEach((node) => {
            context.report({ node, messageId, fix: fix ? getFixFunction(node) : null });
          });
        }
        function reportAll(nodes, messageId, fix) {
          reportSlice(nodes, 0, nodes.length, messageId, fix);
        }
        function reportAllExceptFirst(nodes, messageId, fix) {
          reportSlice(nodes, 1, nodes.length, messageId, fix);
        }
        function enterFunctionInFunctionMode(node, useStrictDirectives) {
          const isInClass = classScopes.length > 0, isParentGlobal = scopes.length === 0 && classScopes.length === 0, isParentStrict = scopes.length > 0 && scopes[scopes.length - 1], isStrict = useStrictDirectives.length > 0;
          if (isStrict) {
            if (!isSimpleParameterList(node.params)) {
              context.report({ node: useStrictDirectives[0], messageId: "nonSimpleParameterList" });
            } else if (isParentStrict) {
              context.report({ node: useStrictDirectives[0], messageId: "unnecessary", fix: getFixFunction(useStrictDirectives[0]) });
            } else if (isInClass) {
              context.report({ node: useStrictDirectives[0], messageId: "unnecessaryInClasses", fix: getFixFunction(useStrictDirectives[0]) });
            }
            reportAllExceptFirst(useStrictDirectives, "multiple", true);
          } else if (isParentGlobal) {
            if (isSimpleParameterList(node.params)) {
              context.report({ node, messageId: "function" });
            } else {
              context.report({
                node,
                messageId: "wrap",
                data: { name: astUtils.getFunctionNameWithKind(node) }
              });
            }
          }
          scopes.push(isParentStrict || isStrict);
        }
        function exitFunctionInFunctionMode() {
          scopes.pop();
        }
        function enterFunction(node) {
          const isBlock = node.body.type === "BlockStatement", useStrictDirectives = isBlock ? getUseStrictDirectives(node.body.body) : [];
          if (mode === "function") {
            enterFunctionInFunctionMode(node, useStrictDirectives);
          } else if (useStrictDirectives.length > 0) {
            if (isSimpleParameterList(node.params)) {
              reportAll(useStrictDirectives, mode, shouldFix(mode));
            } else {
              context.report({ node: useStrictDirectives[0], messageId: "nonSimpleParameterList" });
              reportAllExceptFirst(useStrictDirectives, "multiple", true);
            }
          }
        }
        const rule = {
          Program(node) {
            const useStrictDirectives = getUseStrictDirectives(node.body);
            if (node.sourceType === "module") {
              mode = "module";
            }
            if (mode === "global") {
              if (node.body.length > 0 && useStrictDirectives.length === 0) {
                context.report({ node, messageId: "global" });
              }
              reportAllExceptFirst(useStrictDirectives, "multiple", true);
            } else {
              reportAll(useStrictDirectives, mode, shouldFix(mode));
            }
          },
          FunctionDeclaration: enterFunction,
          FunctionExpression: enterFunction,
          ArrowFunctionExpression: enterFunction
        };
        if (mode === "function") {
          Object.assign(rule, {
            // Inside of class bodies are always strict mode.
            ClassBody() {
              classScopes.push(true);
            },
            "ClassBody:exit"() {
              classScopes.pop();
            },
            "FunctionDeclaration:exit": exitFunctionInFunctionMode,
            "FunctionExpression:exit": exitFunctionInFunctionMode,
            "ArrowFunctionExpression:exit": exitFunctionInFunctionMode
          });
        }
        return rule;
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/switch-colon-spacing.js
var require_switch_colon_spacing = __commonJS({
  "../../node_modules/eslint/lib/rules/switch-colon-spacing.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Enforce spacing around colons of switch statements",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/switch-colon-spacing"
        },
        schema: [
          {
            type: "object",
            properties: {
              before: { type: "boolean", default: false },
              after: { type: "boolean", default: true }
            },
            additionalProperties: false
          }
        ],
        fixable: "whitespace",
        messages: {
          expectedBefore: "Expected space(s) before this colon.",
          expectedAfter: "Expected space(s) after this colon.",
          unexpectedBefore: "Unexpected space(s) before this colon.",
          unexpectedAfter: "Unexpected space(s) after this colon."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        const options = context.options[0] || {};
        const beforeSpacing = options.before === true;
        const afterSpacing = options.after !== false;
        function isValidSpacing(left, right, expected) {
          return astUtils.isClosingBraceToken(right) || !astUtils.isTokenOnSameLine(left, right) || sourceCode.isSpaceBetweenTokens(left, right) === expected;
        }
        function commentsExistBetween(left, right) {
          return sourceCode.getFirstTokenBetween(
            left,
            right,
            {
              includeComments: true,
              filter: astUtils.isCommentToken
            }
          ) !== null;
        }
        function fix(fixer, left, right, spacing) {
          if (commentsExistBetween(left, right)) {
            return null;
          }
          if (spacing) {
            return fixer.insertTextAfter(left, " ");
          }
          return fixer.removeRange([left.range[1], right.range[0]]);
        }
        return {
          SwitchCase(node) {
            const colonToken = astUtils.getSwitchCaseColonToken(node, sourceCode);
            const beforeToken = sourceCode.getTokenBefore(colonToken);
            const afterToken = sourceCode.getTokenAfter(colonToken);
            if (!isValidSpacing(beforeToken, colonToken, beforeSpacing)) {
              context.report({
                node,
                loc: colonToken.loc,
                messageId: beforeSpacing ? "expectedBefore" : "unexpectedBefore",
                fix: (fixer) => fix(fixer, beforeToken, colonToken, beforeSpacing)
              });
            }
            if (!isValidSpacing(colonToken, afterToken, afterSpacing)) {
              context.report({
                node,
                loc: colonToken.loc,
                messageId: afterSpacing ? "expectedAfter" : "unexpectedAfter",
                fix: (fixer) => fix(fixer, colonToken, afterToken, afterSpacing)
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/symbol-description.js
var require_symbol_description = __commonJS({
  "../../node_modules/eslint/lib/rules/symbol-description.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Require symbol descriptions",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/symbol-description"
        },
        fixable: null,
        schema: [],
        messages: {
          expected: "Expected Symbol to have a description."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        function checkArgument(node) {
          if (node.arguments.length === 0) {
            context.report({
              node,
              messageId: "expected"
            });
          }
        }
        return {
          "Program:exit"(node) {
            const scope = sourceCode.getScope(node);
            const variable = astUtils.getVariableByName(scope, "Symbol");
            if (variable && variable.defs.length === 0) {
              variable.references.forEach((reference) => {
                const idNode = reference.identifier;
                if (astUtils.isCallee(idNode)) {
                  checkArgument(idNode.parent);
                }
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/template-curly-spacing.js
var require_template_curly_spacing = __commonJS({
  "../../node_modules/eslint/lib/rules/template-curly-spacing.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Require or disallow spacing around embedded expressions of template strings",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/template-curly-spacing"
        },
        fixable: "whitespace",
        schema: [
          { enum: ["always", "never"] }
        ],
        messages: {
          expectedBefore: "Expected space(s) before '}'.",
          expectedAfter: "Expected space(s) after '${'.",
          unexpectedBefore: "Unexpected space(s) before '}'.",
          unexpectedAfter: "Unexpected space(s) after '${'."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        const always = context.options[0] === "always";
        function checkSpacingBefore(token) {
          if (!token.value.startsWith("}")) {
            return;
          }
          const prevToken = sourceCode.getTokenBefore(token, { includeComments: true }), hasSpace = sourceCode.isSpaceBetween(prevToken, token);
          if (!astUtils.isTokenOnSameLine(prevToken, token)) {
            return;
          }
          if (always && !hasSpace) {
            context.report({
              loc: {
                start: token.loc.start,
                end: {
                  line: token.loc.start.line,
                  column: token.loc.start.column + 1
                }
              },
              messageId: "expectedBefore",
              fix: (fixer) => fixer.insertTextBefore(token, " ")
            });
          }
          if (!always && hasSpace) {
            context.report({
              loc: {
                start: prevToken.loc.end,
                end: token.loc.start
              },
              messageId: "unexpectedBefore",
              fix: (fixer) => fixer.removeRange([prevToken.range[1], token.range[0]])
            });
          }
        }
        function checkSpacingAfter(token) {
          if (!token.value.endsWith("${")) {
            return;
          }
          const nextToken = sourceCode.getTokenAfter(token, { includeComments: true }), hasSpace = sourceCode.isSpaceBetween(token, nextToken);
          if (!astUtils.isTokenOnSameLine(token, nextToken)) {
            return;
          }
          if (always && !hasSpace) {
            context.report({
              loc: {
                start: {
                  line: token.loc.end.line,
                  column: token.loc.end.column - 2
                },
                end: token.loc.end
              },
              messageId: "expectedAfter",
              fix: (fixer) => fixer.insertTextAfter(token, " ")
            });
          }
          if (!always && hasSpace) {
            context.report({
              loc: {
                start: token.loc.end,
                end: nextToken.loc.start
              },
              messageId: "unexpectedAfter",
              fix: (fixer) => fixer.removeRange([token.range[1], nextToken.range[0]])
            });
          }
        }
        return {
          TemplateElement(node) {
            const token = sourceCode.getFirstToken(node);
            checkSpacingBefore(token);
            checkSpacingAfter(token);
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/template-tag-spacing.js
var require_template_tag_spacing = __commonJS({
  "../../node_modules/eslint/lib/rules/template-tag-spacing.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Require or disallow spacing between template tags and their literals",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/template-tag-spacing"
        },
        fixable: "whitespace",
        schema: [
          { enum: ["always", "never"] }
        ],
        messages: {
          unexpected: "Unexpected space between template tag and template literal.",
          missing: "Missing space between template tag and template literal."
        }
      },
      create(context) {
        const never = context.options[0] !== "always";
        const sourceCode = context.sourceCode;
        function checkSpacing(node) {
          const tagToken = sourceCode.getTokenBefore(node.quasi);
          const literalToken = sourceCode.getFirstToken(node.quasi);
          const hasWhitespace = sourceCode.isSpaceBetweenTokens(tagToken, literalToken);
          if (never && hasWhitespace) {
            context.report({
              node,
              loc: {
                start: tagToken.loc.end,
                end: literalToken.loc.start
              },
              messageId: "unexpected",
              fix(fixer) {
                const comments = sourceCode.getCommentsBefore(node.quasi);
                if (comments.some((comment) => comment.type === "Line")) {
                  return null;
                }
                return fixer.replaceTextRange(
                  [tagToken.range[1], literalToken.range[0]],
                  comments.reduce((text, comment) => text + sourceCode.getText(comment), "")
                );
              }
            });
          } else if (!never && !hasWhitespace) {
            context.report({
              node,
              loc: {
                start: node.loc.start,
                end: literalToken.loc.start
              },
              messageId: "missing",
              fix(fixer) {
                return fixer.insertTextAfter(tagToken, " ");
              }
            });
          }
        }
        return {
          TaggedTemplateExpression: checkSpacing
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/unicode-bom.js
var require_unicode_bom = __commonJS({
  "../../node_modules/eslint/lib/rules/unicode-bom.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Require or disallow Unicode byte order mark (BOM)",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/unicode-bom"
        },
        fixable: "whitespace",
        schema: [
          {
            enum: ["always", "never"]
          }
        ],
        messages: {
          expected: "Expected Unicode BOM (Byte Order Mark).",
          unexpected: "Unexpected Unicode BOM (Byte Order Mark)."
        }
      },
      create(context) {
        return {
          Program: function checkUnicodeBOM(node) {
            const sourceCode = context.sourceCode, location = { column: 0, line: 1 }, requireBOM = context.options[0] || "never";
            if (!sourceCode.hasBOM && requireBOM === "always") {
              context.report({
                node,
                loc: location,
                messageId: "expected",
                fix(fixer) {
                  return fixer.insertTextBeforeRange([0, 1], "\uFEFF");
                }
              });
            } else if (sourceCode.hasBOM && requireBOM === "never") {
              context.report({
                node,
                loc: location,
                messageId: "unexpected",
                fix(fixer) {
                  return fixer.removeRange([-1, 0]);
                }
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/use-isnan.js
var require_use_isnan = __commonJS({
  "../../node_modules/eslint/lib/rules/use-isnan.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    function isNaNIdentifier(node) {
      return Boolean(node) && (astUtils.isSpecificId(node, "NaN") || astUtils.isSpecificMemberAccess(node, "Number", "NaN"));
    }
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Require calls to `isNaN()` when checking for `NaN`",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/use-isnan"
        },
        schema: [
          {
            type: "object",
            properties: {
              enforceForSwitchCase: {
                type: "boolean",
                default: true
              },
              enforceForIndexOf: {
                type: "boolean",
                default: false
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          comparisonWithNaN: "Use the isNaN function to compare with NaN.",
          switchNaN: "'switch(NaN)' can never match a case clause. Use Number.isNaN instead of the switch.",
          caseNaN: "'case NaN' can never match. Use Number.isNaN before the switch.",
          indexOfNaN: "Array prototype method '{{ methodName }}' cannot find NaN."
        }
      },
      create(context) {
        const enforceForSwitchCase = !context.options[0] || context.options[0].enforceForSwitchCase;
        const enforceForIndexOf = context.options[0] && context.options[0].enforceForIndexOf;
        function checkBinaryExpression(node) {
          if (/^(?:[<>]|[!=]=)=?$/u.test(node.operator) && (isNaNIdentifier(node.left) || isNaNIdentifier(node.right))) {
            context.report({ node, messageId: "comparisonWithNaN" });
          }
        }
        function checkSwitchStatement(node) {
          if (isNaNIdentifier(node.discriminant)) {
            context.report({ node, messageId: "switchNaN" });
          }
          for (const switchCase of node.cases) {
            if (isNaNIdentifier(switchCase.test)) {
              context.report({ node: switchCase, messageId: "caseNaN" });
            }
          }
        }
        function checkCallExpression(node) {
          const callee = astUtils.skipChainExpression(node.callee);
          if (callee.type === "MemberExpression") {
            const methodName = astUtils.getStaticPropertyName(callee);
            if ((methodName === "indexOf" || methodName === "lastIndexOf") && node.arguments.length === 1 && isNaNIdentifier(node.arguments[0])) {
              context.report({ node, messageId: "indexOfNaN", data: { methodName } });
            }
          }
        }
        const listeners = {
          BinaryExpression: checkBinaryExpression
        };
        if (enforceForSwitchCase) {
          listeners.SwitchStatement = checkSwitchStatement;
        }
        if (enforceForIndexOf) {
          listeners.CallExpression = checkCallExpression;
        }
        return listeners;
      }
    };
  }
});

// ../../node_modules/doctrine/package.json
var require_package3 = __commonJS({
  "../../node_modules/doctrine/package.json"(exports, module) {
    module.exports = {
      name: "doctrine",
      description: "JSDoc parser",
      homepage: "https://github.com/eslint/doctrine",
      main: "lib/doctrine.js",
      version: "3.0.0",
      engines: {
        node: ">=6.0.0"
      },
      directories: {
        lib: "./lib"
      },
      files: [
        "lib"
      ],
      maintainers: [
        {
          name: "Nicholas C. Zakas",
          email: "nicholas+npm@nczconsulting.com",
          web: "https://www.nczonline.net"
        },
        {
          name: "Yusuke Suzuki",
          email: "utatane.tea@gmail.com",
          web: "https://github.com/Constellation"
        }
      ],
      repository: "eslint/doctrine",
      devDependencies: {
        coveralls: "^3.0.1",
        dateformat: "^1.0.11",
        eslint: "^1.10.3",
        "eslint-release": "^1.0.0",
        linefix: "^0.1.1",
        mocha: "^3.4.2",
        "npm-license": "^0.3.1",
        nyc: "^10.3.2",
        semver: "^5.0.3",
        shelljs: "^0.5.3",
        "shelljs-nodecli": "^0.1.1",
        should: "^5.0.1"
      },
      license: "Apache-2.0",
      scripts: {
        pretest: "npm run lint",
        test: "nyc mocha",
        coveralls: "nyc report --reporter=text-lcov | coveralls",
        lint: "eslint lib/",
        "generate-release": "eslint-generate-release",
        "generate-alpharelease": "eslint-generate-prerelease alpha",
        "generate-betarelease": "eslint-generate-prerelease beta",
        "generate-rcrelease": "eslint-generate-prerelease rc",
        "publish-release": "eslint-publish-release"
      },
      dependencies: {
        esutils: "^2.0.2"
      }
    };
  }
});

// ../../node_modules/doctrine/lib/utility.js
var require_utility = __commonJS({
  "../../node_modules/doctrine/lib/utility.js"(exports) {
    (function() {
      "use strict";
      var VERSION;
      VERSION = require_package3().version;
      exports.VERSION = VERSION;
      function DoctrineError(message) {
        this.name = "DoctrineError";
        this.message = message;
      }
      DoctrineError.prototype = function() {
        var Middle = function() {
        };
        Middle.prototype = Error.prototype;
        return new Middle();
      }();
      DoctrineError.prototype.constructor = DoctrineError;
      exports.DoctrineError = DoctrineError;
      function throwError(message) {
        throw new DoctrineError(message);
      }
      exports.throwError = throwError;
      exports.assert = require_assert();
    })();
  }
});

// ../../node_modules/doctrine/lib/typed.js
var require_typed = __commonJS({
  "../../node_modules/doctrine/lib/typed.js"(exports) {
    (function() {
      "use strict";
      var Syntax, Token, source, length, index, previous, token, value, esutils, utility, rangeOffset, addRange;
      esutils = require_utils2();
      utility = require_utility();
      Syntax = {
        NullableLiteral: "NullableLiteral",
        AllLiteral: "AllLiteral",
        NullLiteral: "NullLiteral",
        UndefinedLiteral: "UndefinedLiteral",
        VoidLiteral: "VoidLiteral",
        UnionType: "UnionType",
        ArrayType: "ArrayType",
        RecordType: "RecordType",
        FieldType: "FieldType",
        FunctionType: "FunctionType",
        ParameterType: "ParameterType",
        RestType: "RestType",
        NonNullableType: "NonNullableType",
        OptionalType: "OptionalType",
        NullableType: "NullableType",
        NameExpression: "NameExpression",
        TypeApplication: "TypeApplication",
        StringLiteralType: "StringLiteralType",
        NumericLiteralType: "NumericLiteralType",
        BooleanLiteralType: "BooleanLiteralType"
      };
      Token = {
        ILLEGAL: 0,
        // ILLEGAL
        DOT_LT: 1,
        // .<
        REST: 2,
        // ...
        LT: 3,
        // <
        GT: 4,
        // >
        LPAREN: 5,
        // (
        RPAREN: 6,
        // )
        LBRACE: 7,
        // {
        RBRACE: 8,
        // }
        LBRACK: 9,
        // [
        RBRACK: 10,
        // ]
        COMMA: 11,
        // ,
        COLON: 12,
        // :
        STAR: 13,
        // *
        PIPE: 14,
        // |
        QUESTION: 15,
        // ?
        BANG: 16,
        // !
        EQUAL: 17,
        // =
        NAME: 18,
        // name token
        STRING: 19,
        // string
        NUMBER: 20,
        // number
        EOF: 21
      };
      function isTypeName(ch) {
        return "><(){}[],:*|?!=".indexOf(String.fromCharCode(ch)) === -1 && !esutils.code.isWhiteSpace(ch) && !esutils.code.isLineTerminator(ch);
      }
      function Context(previous2, index2, token2, value2) {
        this._previous = previous2;
        this._index = index2;
        this._token = token2;
        this._value = value2;
      }
      Context.prototype.restore = function() {
        previous = this._previous;
        index = this._index;
        token = this._token;
        value = this._value;
      };
      Context.save = function() {
        return new Context(previous, index, token, value);
      };
      function maybeAddRange(node, range) {
        if (addRange) {
          node.range = [range[0] + rangeOffset, range[1] + rangeOffset];
        }
        return node;
      }
      function advance() {
        var ch = source.charAt(index);
        index += 1;
        return ch;
      }
      function scanHexEscape(prefix) {
        var i, len, ch, code = 0;
        len = prefix === "u" ? 4 : 2;
        for (i = 0; i < len; ++i) {
          if (index < length && esutils.code.isHexDigit(source.charCodeAt(index))) {
            ch = advance();
            code = code * 16 + "0123456789abcdef".indexOf(ch.toLowerCase());
          } else {
            return "";
          }
        }
        return String.fromCharCode(code);
      }
      function scanString() {
        var str = "", quote, ch, code, unescaped, restore;
        quote = source.charAt(index);
        ++index;
        while (index < length) {
          ch = advance();
          if (ch === quote) {
            quote = "";
            break;
          } else if (ch === "\\") {
            ch = advance();
            if (!esutils.code.isLineTerminator(ch.charCodeAt(0))) {
              switch (ch) {
                case "n":
                  str += "\n";
                  break;
                case "r":
                  str += "\r";
                  break;
                case "t":
                  str += "	";
                  break;
                case "u":
                case "x":
                  restore = index;
                  unescaped = scanHexEscape(ch);
                  if (unescaped) {
                    str += unescaped;
                  } else {
                    index = restore;
                    str += ch;
                  }
                  break;
                case "b":
                  str += "\b";
                  break;
                case "f":
                  str += "\f";
                  break;
                case "v":
                  str += "\v";
                  break;
                default:
                  if (esutils.code.isOctalDigit(ch.charCodeAt(0))) {
                    code = "01234567".indexOf(ch);
                    if (index < length && esutils.code.isOctalDigit(source.charCodeAt(index))) {
                      code = code * 8 + "01234567".indexOf(advance());
                      if ("0123".indexOf(ch) >= 0 && index < length && esutils.code.isOctalDigit(source.charCodeAt(index))) {
                        code = code * 8 + "01234567".indexOf(advance());
                      }
                    }
                    str += String.fromCharCode(code);
                  } else {
                    str += ch;
                  }
                  break;
              }
            } else {
              if (ch === "\r" && source.charCodeAt(index) === 10) {
                ++index;
              }
            }
          } else if (esutils.code.isLineTerminator(ch.charCodeAt(0))) {
            break;
          } else {
            str += ch;
          }
        }
        if (quote !== "") {
          utility.throwError("unexpected quote");
        }
        value = str;
        return Token.STRING;
      }
      function scanNumber() {
        var number, ch;
        number = "";
        ch = source.charCodeAt(index);
        if (ch !== 46) {
          number = advance();
          ch = source.charCodeAt(index);
          if (number === "0") {
            if (ch === 120 || ch === 88) {
              number += advance();
              while (index < length) {
                ch = source.charCodeAt(index);
                if (!esutils.code.isHexDigit(ch)) {
                  break;
                }
                number += advance();
              }
              if (number.length <= 2) {
                utility.throwError("unexpected token");
              }
              if (index < length) {
                ch = source.charCodeAt(index);
                if (esutils.code.isIdentifierStartES5(ch)) {
                  utility.throwError("unexpected token");
                }
              }
              value = parseInt(number, 16);
              return Token.NUMBER;
            }
            if (esutils.code.isOctalDigit(ch)) {
              number += advance();
              while (index < length) {
                ch = source.charCodeAt(index);
                if (!esutils.code.isOctalDigit(ch)) {
                  break;
                }
                number += advance();
              }
              if (index < length) {
                ch = source.charCodeAt(index);
                if (esutils.code.isIdentifierStartES5(ch) || esutils.code.isDecimalDigit(ch)) {
                  utility.throwError("unexpected token");
                }
              }
              value = parseInt(number, 8);
              return Token.NUMBER;
            }
            if (esutils.code.isDecimalDigit(ch)) {
              utility.throwError("unexpected token");
            }
          }
          while (index < length) {
            ch = source.charCodeAt(index);
            if (!esutils.code.isDecimalDigit(ch)) {
              break;
            }
            number += advance();
          }
        }
        if (ch === 46) {
          number += advance();
          while (index < length) {
            ch = source.charCodeAt(index);
            if (!esutils.code.isDecimalDigit(ch)) {
              break;
            }
            number += advance();
          }
        }
        if (ch === 101 || ch === 69) {
          number += advance();
          ch = source.charCodeAt(index);
          if (ch === 43 || ch === 45) {
            number += advance();
          }
          ch = source.charCodeAt(index);
          if (esutils.code.isDecimalDigit(ch)) {
            number += advance();
            while (index < length) {
              ch = source.charCodeAt(index);
              if (!esutils.code.isDecimalDigit(ch)) {
                break;
              }
              number += advance();
            }
          } else {
            utility.throwError("unexpected token");
          }
        }
        if (index < length) {
          ch = source.charCodeAt(index);
          if (esutils.code.isIdentifierStartES5(ch)) {
            utility.throwError("unexpected token");
          }
        }
        value = parseFloat(number);
        return Token.NUMBER;
      }
      function scanTypeName() {
        var ch, ch2;
        value = advance();
        while (index < length && isTypeName(source.charCodeAt(index))) {
          ch = source.charCodeAt(index);
          if (ch === 46) {
            if (index + 1 >= length) {
              return Token.ILLEGAL;
            }
            ch2 = source.charCodeAt(index + 1);
            if (ch2 === 60) {
              break;
            }
          }
          value += advance();
        }
        return Token.NAME;
      }
      function next() {
        var ch;
        previous = index;
        while (index < length && esutils.code.isWhiteSpace(source.charCodeAt(index))) {
          advance();
        }
        if (index >= length) {
          token = Token.EOF;
          return token;
        }
        ch = source.charCodeAt(index);
        switch (ch) {
          case 39:
          case 34:
            token = scanString();
            return token;
          case 58:
            advance();
            token = Token.COLON;
            return token;
          case 44:
            advance();
            token = Token.COMMA;
            return token;
          case 40:
            advance();
            token = Token.LPAREN;
            return token;
          case 41:
            advance();
            token = Token.RPAREN;
            return token;
          case 91:
            advance();
            token = Token.LBRACK;
            return token;
          case 93:
            advance();
            token = Token.RBRACK;
            return token;
          case 123:
            advance();
            token = Token.LBRACE;
            return token;
          case 125:
            advance();
            token = Token.RBRACE;
            return token;
          case 46:
            if (index + 1 < length) {
              ch = source.charCodeAt(index + 1);
              if (ch === 60) {
                advance();
                advance();
                token = Token.DOT_LT;
                return token;
              }
              if (ch === 46 && index + 2 < length && source.charCodeAt(index + 2) === 46) {
                advance();
                advance();
                advance();
                token = Token.REST;
                return token;
              }
              if (esutils.code.isDecimalDigit(ch)) {
                token = scanNumber();
                return token;
              }
            }
            token = Token.ILLEGAL;
            return token;
          case 60:
            advance();
            token = Token.LT;
            return token;
          case 62:
            advance();
            token = Token.GT;
            return token;
          case 42:
            advance();
            token = Token.STAR;
            return token;
          case 124:
            advance();
            token = Token.PIPE;
            return token;
          case 63:
            advance();
            token = Token.QUESTION;
            return token;
          case 33:
            advance();
            token = Token.BANG;
            return token;
          case 61:
            advance();
            token = Token.EQUAL;
            return token;
          case 45:
            token = scanNumber();
            return token;
          default:
            if (esutils.code.isDecimalDigit(ch)) {
              token = scanNumber();
              return token;
            }
            utility.assert(isTypeName(ch));
            token = scanTypeName();
            return token;
        }
      }
      function consume(target, text) {
        utility.assert(token === target, text || "consumed token not matched");
        next();
      }
      function expect(target, message) {
        if (token !== target) {
          utility.throwError(message || "unexpected token");
        }
        next();
      }
      function parseUnionType() {
        var elements, startIndex = index - 1;
        consume(Token.LPAREN, "UnionType should start with (");
        elements = [];
        if (token !== Token.RPAREN) {
          while (true) {
            elements.push(parseTypeExpression());
            if (token === Token.RPAREN) {
              break;
            }
            expect(Token.PIPE);
          }
        }
        consume(Token.RPAREN, "UnionType should end with )");
        return maybeAddRange({
          type: Syntax.UnionType,
          elements
        }, [startIndex, previous]);
      }
      function parseArrayType() {
        var elements, startIndex = index - 1, restStartIndex;
        consume(Token.LBRACK, "ArrayType should start with [");
        elements = [];
        while (token !== Token.RBRACK) {
          if (token === Token.REST) {
            restStartIndex = index - 3;
            consume(Token.REST);
            elements.push(maybeAddRange({
              type: Syntax.RestType,
              expression: parseTypeExpression()
            }, [restStartIndex, previous]));
            break;
          } else {
            elements.push(parseTypeExpression());
          }
          if (token !== Token.RBRACK) {
            expect(Token.COMMA);
          }
        }
        expect(Token.RBRACK);
        return maybeAddRange({
          type: Syntax.ArrayType,
          elements
        }, [startIndex, previous]);
      }
      function parseFieldName() {
        var v = value;
        if (token === Token.NAME || token === Token.STRING) {
          next();
          return v;
        }
        if (token === Token.NUMBER) {
          consume(Token.NUMBER);
          return String(v);
        }
        utility.throwError("unexpected token");
      }
      function parseFieldType() {
        var key, rangeStart = previous;
        key = parseFieldName();
        if (token === Token.COLON) {
          consume(Token.COLON);
          return maybeAddRange({
            type: Syntax.FieldType,
            key,
            value: parseTypeExpression()
          }, [rangeStart, previous]);
        }
        return maybeAddRange({
          type: Syntax.FieldType,
          key,
          value: null
        }, [rangeStart, previous]);
      }
      function parseRecordType() {
        var fields, rangeStart = index - 1, rangeEnd;
        consume(Token.LBRACE, "RecordType should start with {");
        fields = [];
        if (token === Token.COMMA) {
          consume(Token.COMMA);
        } else {
          while (token !== Token.RBRACE) {
            fields.push(parseFieldType());
            if (token !== Token.RBRACE) {
              expect(Token.COMMA);
            }
          }
        }
        rangeEnd = index;
        expect(Token.RBRACE);
        return maybeAddRange({
          type: Syntax.RecordType,
          fields
        }, [rangeStart, rangeEnd]);
      }
      function parseNameExpression() {
        var name = value, rangeStart = index - name.length;
        expect(Token.NAME);
        if (token === Token.COLON && (name === "module" || name === "external" || name === "event")) {
          consume(Token.COLON);
          name += ":" + value;
          expect(Token.NAME);
        }
        return maybeAddRange({
          type: Syntax.NameExpression,
          name
        }, [rangeStart, previous]);
      }
      function parseTypeExpressionList() {
        var elements = [];
        elements.push(parseTop());
        while (token === Token.COMMA) {
          consume(Token.COMMA);
          elements.push(parseTop());
        }
        return elements;
      }
      function parseTypeName() {
        var expr, applications, startIndex = index - value.length;
        expr = parseNameExpression();
        if (token === Token.DOT_LT || token === Token.LT) {
          next();
          applications = parseTypeExpressionList();
          expect(Token.GT);
          return maybeAddRange({
            type: Syntax.TypeApplication,
            expression: expr,
            applications
          }, [startIndex, previous]);
        }
        return expr;
      }
      function parseResultType() {
        consume(Token.COLON, "ResultType should start with :");
        if (token === Token.NAME && value === "void") {
          consume(Token.NAME);
          return {
            type: Syntax.VoidLiteral
          };
        }
        return parseTypeExpression();
      }
      function parseParametersType() {
        var params = [], optionalSequence = false, expr, rest = false, startIndex, restStartIndex = index - 3, nameStartIndex;
        while (token !== Token.RPAREN) {
          if (token === Token.REST) {
            consume(Token.REST);
            rest = true;
          }
          startIndex = previous;
          expr = parseTypeExpression();
          if (expr.type === Syntax.NameExpression && token === Token.COLON) {
            nameStartIndex = previous - expr.name.length;
            consume(Token.COLON);
            expr = maybeAddRange({
              type: Syntax.ParameterType,
              name: expr.name,
              expression: parseTypeExpression()
            }, [nameStartIndex, previous]);
          }
          if (token === Token.EQUAL) {
            consume(Token.EQUAL);
            expr = maybeAddRange({
              type: Syntax.OptionalType,
              expression: expr
            }, [startIndex, previous]);
            optionalSequence = true;
          } else {
            if (optionalSequence) {
              utility.throwError("unexpected token");
            }
          }
          if (rest) {
            expr = maybeAddRange({
              type: Syntax.RestType,
              expression: expr
            }, [restStartIndex, previous]);
          }
          params.push(expr);
          if (token !== Token.RPAREN) {
            expect(Token.COMMA);
          }
        }
        return params;
      }
      function parseFunctionType() {
        var isNew, thisBinding, params, result, fnType, startIndex = index - value.length;
        utility.assert(token === Token.NAME && value === "function", "FunctionType should start with 'function'");
        consume(Token.NAME);
        expect(Token.LPAREN);
        isNew = false;
        params = [];
        thisBinding = null;
        if (token !== Token.RPAREN) {
          if (token === Token.NAME && (value === "this" || value === "new")) {
            isNew = value === "new";
            consume(Token.NAME);
            expect(Token.COLON);
            thisBinding = parseTypeName();
            if (token === Token.COMMA) {
              consume(Token.COMMA);
              params = parseParametersType();
            }
          } else {
            params = parseParametersType();
          }
        }
        expect(Token.RPAREN);
        result = null;
        if (token === Token.COLON) {
          result = parseResultType();
        }
        fnType = maybeAddRange({
          type: Syntax.FunctionType,
          params,
          result
        }, [startIndex, previous]);
        if (thisBinding) {
          fnType["this"] = thisBinding;
          if (isNew) {
            fnType["new"] = true;
          }
        }
        return fnType;
      }
      function parseBasicTypeExpression() {
        var context, startIndex;
        switch (token) {
          case Token.STAR:
            consume(Token.STAR);
            return maybeAddRange({
              type: Syntax.AllLiteral
            }, [previous - 1, previous]);
          case Token.LPAREN:
            return parseUnionType();
          case Token.LBRACK:
            return parseArrayType();
          case Token.LBRACE:
            return parseRecordType();
          case Token.NAME:
            startIndex = index - value.length;
            if (value === "null") {
              consume(Token.NAME);
              return maybeAddRange({
                type: Syntax.NullLiteral
              }, [startIndex, previous]);
            }
            if (value === "undefined") {
              consume(Token.NAME);
              return maybeAddRange({
                type: Syntax.UndefinedLiteral
              }, [startIndex, previous]);
            }
            if (value === "true" || value === "false") {
              consume(Token.NAME);
              return maybeAddRange({
                type: Syntax.BooleanLiteralType,
                value: value === "true"
              }, [startIndex, previous]);
            }
            context = Context.save();
            if (value === "function") {
              try {
                return parseFunctionType();
              } catch (e) {
                context.restore();
              }
            }
            return parseTypeName();
          case Token.STRING:
            next();
            return maybeAddRange({
              type: Syntax.StringLiteralType,
              value
            }, [previous - value.length - 2, previous]);
          case Token.NUMBER:
            next();
            return maybeAddRange({
              type: Syntax.NumericLiteralType,
              value
            }, [previous - String(value).length, previous]);
          default:
            utility.throwError("unexpected token");
        }
      }
      function parseTypeExpression() {
        var expr, rangeStart;
        if (token === Token.QUESTION) {
          rangeStart = index - 1;
          consume(Token.QUESTION);
          if (token === Token.COMMA || token === Token.EQUAL || token === Token.RBRACE || token === Token.RPAREN || token === Token.PIPE || token === Token.EOF || token === Token.RBRACK || token === Token.GT) {
            return maybeAddRange({
              type: Syntax.NullableLiteral
            }, [rangeStart, previous]);
          }
          return maybeAddRange({
            type: Syntax.NullableType,
            expression: parseBasicTypeExpression(),
            prefix: true
          }, [rangeStart, previous]);
        } else if (token === Token.BANG) {
          rangeStart = index - 1;
          consume(Token.BANG);
          return maybeAddRange({
            type: Syntax.NonNullableType,
            expression: parseBasicTypeExpression(),
            prefix: true
          }, [rangeStart, previous]);
        } else {
          rangeStart = previous;
        }
        expr = parseBasicTypeExpression();
        if (token === Token.BANG) {
          consume(Token.BANG);
          return maybeAddRange({
            type: Syntax.NonNullableType,
            expression: expr,
            prefix: false
          }, [rangeStart, previous]);
        }
        if (token === Token.QUESTION) {
          consume(Token.QUESTION);
          return maybeAddRange({
            type: Syntax.NullableType,
            expression: expr,
            prefix: false
          }, [rangeStart, previous]);
        }
        if (token === Token.LBRACK) {
          consume(Token.LBRACK);
          expect(Token.RBRACK, "expected an array-style type declaration (" + value + "[])");
          return maybeAddRange({
            type: Syntax.TypeApplication,
            expression: maybeAddRange({
              type: Syntax.NameExpression,
              name: "Array"
            }, [rangeStart, previous]),
            applications: [expr]
          }, [rangeStart, previous]);
        }
        return expr;
      }
      function parseTop() {
        var expr, elements;
        expr = parseTypeExpression();
        if (token !== Token.PIPE) {
          return expr;
        }
        elements = [expr];
        consume(Token.PIPE);
        while (true) {
          elements.push(parseTypeExpression());
          if (token !== Token.PIPE) {
            break;
          }
          consume(Token.PIPE);
        }
        return maybeAddRange({
          type: Syntax.UnionType,
          elements
        }, [0, index]);
      }
      function parseTopParamType() {
        var expr;
        if (token === Token.REST) {
          consume(Token.REST);
          return maybeAddRange({
            type: Syntax.RestType,
            expression: parseTop()
          }, [0, index]);
        }
        expr = parseTop();
        if (token === Token.EQUAL) {
          consume(Token.EQUAL);
          return maybeAddRange({
            type: Syntax.OptionalType,
            expression: expr
          }, [0, index]);
        }
        return expr;
      }
      function parseType(src, opt) {
        var expr;
        source = src;
        length = source.length;
        index = 0;
        previous = 0;
        addRange = opt && opt.range;
        rangeOffset = opt && opt.startIndex || 0;
        next();
        expr = parseTop();
        if (opt && opt.midstream) {
          return {
            expression: expr,
            index: previous
          };
        }
        if (token !== Token.EOF) {
          utility.throwError("not reach to EOF");
        }
        return expr;
      }
      function parseParamType(src, opt) {
        var expr;
        source = src;
        length = source.length;
        index = 0;
        previous = 0;
        addRange = opt && opt.range;
        rangeOffset = opt && opt.startIndex || 0;
        next();
        expr = parseTopParamType();
        if (opt && opt.midstream) {
          return {
            expression: expr,
            index: previous
          };
        }
        if (token !== Token.EOF) {
          utility.throwError("not reach to EOF");
        }
        return expr;
      }
      function stringifyImpl(node, compact, topLevel) {
        var result, i, iz;
        switch (node.type) {
          case Syntax.NullableLiteral:
            result = "?";
            break;
          case Syntax.AllLiteral:
            result = "*";
            break;
          case Syntax.NullLiteral:
            result = "null";
            break;
          case Syntax.UndefinedLiteral:
            result = "undefined";
            break;
          case Syntax.VoidLiteral:
            result = "void";
            break;
          case Syntax.UnionType:
            if (!topLevel) {
              result = "(";
            } else {
              result = "";
            }
            for (i = 0, iz = node.elements.length; i < iz; ++i) {
              result += stringifyImpl(node.elements[i], compact);
              if (i + 1 !== iz) {
                result += compact ? "|" : " | ";
              }
            }
            if (!topLevel) {
              result += ")";
            }
            break;
          case Syntax.ArrayType:
            result = "[";
            for (i = 0, iz = node.elements.length; i < iz; ++i) {
              result += stringifyImpl(node.elements[i], compact);
              if (i + 1 !== iz) {
                result += compact ? "," : ", ";
              }
            }
            result += "]";
            break;
          case Syntax.RecordType:
            result = "{";
            for (i = 0, iz = node.fields.length; i < iz; ++i) {
              result += stringifyImpl(node.fields[i], compact);
              if (i + 1 !== iz) {
                result += compact ? "," : ", ";
              }
            }
            result += "}";
            break;
          case Syntax.FieldType:
            if (node.value) {
              result = node.key + (compact ? ":" : ": ") + stringifyImpl(node.value, compact);
            } else {
              result = node.key;
            }
            break;
          case Syntax.FunctionType:
            result = compact ? "function(" : "function (";
            if (node["this"]) {
              if (node["new"]) {
                result += compact ? "new:" : "new: ";
              } else {
                result += compact ? "this:" : "this: ";
              }
              result += stringifyImpl(node["this"], compact);
              if (node.params.length !== 0) {
                result += compact ? "," : ", ";
              }
            }
            for (i = 0, iz = node.params.length; i < iz; ++i) {
              result += stringifyImpl(node.params[i], compact);
              if (i + 1 !== iz) {
                result += compact ? "," : ", ";
              }
            }
            result += ")";
            if (node.result) {
              result += (compact ? ":" : ": ") + stringifyImpl(node.result, compact);
            }
            break;
          case Syntax.ParameterType:
            result = node.name + (compact ? ":" : ": ") + stringifyImpl(node.expression, compact);
            break;
          case Syntax.RestType:
            result = "...";
            if (node.expression) {
              result += stringifyImpl(node.expression, compact);
            }
            break;
          case Syntax.NonNullableType:
            if (node.prefix) {
              result = "!" + stringifyImpl(node.expression, compact);
            } else {
              result = stringifyImpl(node.expression, compact) + "!";
            }
            break;
          case Syntax.OptionalType:
            result = stringifyImpl(node.expression, compact) + "=";
            break;
          case Syntax.NullableType:
            if (node.prefix) {
              result = "?" + stringifyImpl(node.expression, compact);
            } else {
              result = stringifyImpl(node.expression, compact) + "?";
            }
            break;
          case Syntax.NameExpression:
            result = node.name;
            break;
          case Syntax.TypeApplication:
            result = stringifyImpl(node.expression, compact) + ".<";
            for (i = 0, iz = node.applications.length; i < iz; ++i) {
              result += stringifyImpl(node.applications[i], compact);
              if (i + 1 !== iz) {
                result += compact ? "," : ", ";
              }
            }
            result += ">";
            break;
          case Syntax.StringLiteralType:
            result = '"' + node.value + '"';
            break;
          case Syntax.NumericLiteralType:
            result = String(node.value);
            break;
          case Syntax.BooleanLiteralType:
            result = String(node.value);
            break;
          default:
            utility.throwError("Unknown type " + node.type);
        }
        return result;
      }
      function stringify(node, options) {
        if (options == null) {
          options = {};
        }
        return stringifyImpl(node, options.compact, options.topLevel);
      }
      exports.parseType = parseType;
      exports.parseParamType = parseParamType;
      exports.stringify = stringify;
      exports.Syntax = Syntax;
    })();
  }
});

// ../../node_modules/doctrine/lib/doctrine.js
var require_doctrine = __commonJS({
  "../../node_modules/doctrine/lib/doctrine.js"(exports) {
    (function() {
      "use strict";
      var typed, utility, jsdoc, esutils, hasOwnProperty;
      esutils = require_utils2();
      typed = require_typed();
      utility = require_utility();
      function sliceSource(source, index, last) {
        return source.slice(index, last);
      }
      hasOwnProperty = function() {
        var func = Object.prototype.hasOwnProperty;
        return function hasOwnProperty2(obj, name) {
          return func.call(obj, name);
        };
      }();
      function shallowCopy(obj) {
        var ret = {}, key;
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            ret[key] = obj[key];
          }
        }
        return ret;
      }
      function isASCIIAlphanumeric(ch) {
        return ch >= 97 && ch <= 122 || ch >= 65 && ch <= 90 || ch >= 48 && ch <= 57;
      }
      function isParamTitle(title) {
        return title === "param" || title === "argument" || title === "arg";
      }
      function isReturnTitle(title) {
        return title === "return" || title === "returns";
      }
      function isProperty(title) {
        return title === "property" || title === "prop";
      }
      function isNameParameterRequired(title) {
        return isParamTitle(title) || isProperty(title) || title === "alias" || title === "this" || title === "mixes" || title === "requires";
      }
      function isAllowedName(title) {
        return isNameParameterRequired(title) || title === "const" || title === "constant";
      }
      function isAllowedNested(title) {
        return isProperty(title) || isParamTitle(title);
      }
      function isAllowedOptional(title) {
        return isProperty(title) || isParamTitle(title);
      }
      function isTypeParameterRequired(title) {
        return isParamTitle(title) || isReturnTitle(title) || title === "define" || title === "enum" || title === "implements" || title === "this" || title === "type" || title === "typedef" || isProperty(title);
      }
      function isAllowedType(title) {
        return isTypeParameterRequired(title) || title === "throws" || title === "const" || title === "constant" || title === "namespace" || title === "member" || title === "var" || title === "module" || title === "constructor" || title === "class" || title === "extends" || title === "augments" || title === "public" || title === "private" || title === "protected";
      }
      var WHITESPACE = "[ \\f\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]";
      var STAR_MATCHER = "(" + WHITESPACE + "*(?:\\*" + WHITESPACE + "?)?)(.+|[\r\n\u2028\u2029])";
      function unwrapComment(doc) {
        return doc.replace(/^\/\*\*?/, "").replace(/\*\/$/, "").replace(new RegExp(STAR_MATCHER, "g"), "$2").replace(/\s*$/, "");
      }
      function convertUnwrappedCommentIndex(originalSource, unwrappedIndex) {
        var replacedSource = originalSource.replace(/^\/\*\*?/, "");
        var numSkippedChars = 0;
        var matcher = new RegExp(STAR_MATCHER, "g");
        var match;
        while (match = matcher.exec(replacedSource)) {
          numSkippedChars += match[1].length;
          if (match.index + match[0].length > unwrappedIndex + numSkippedChars) {
            return unwrappedIndex + numSkippedChars + originalSource.length - replacedSource.length;
          }
        }
        return originalSource.replace(/\*\/$/, "").replace(/\s*$/, "").length;
      }
      (function(exports2) {
        var Rules, index, lineNumber, length, source, originalSource, recoverable, sloppy, strict;
        function advance() {
          var ch = source.charCodeAt(index);
          index += 1;
          if (esutils.code.isLineTerminator(ch) && !(ch === 13 && source.charCodeAt(index) === 10)) {
            lineNumber += 1;
          }
          return String.fromCharCode(ch);
        }
        function scanTitle() {
          var title = "";
          advance();
          while (index < length && isASCIIAlphanumeric(source.charCodeAt(index))) {
            title += advance();
          }
          return title;
        }
        function seekContent() {
          var ch, waiting, last = index;
          waiting = false;
          while (last < length) {
            ch = source.charCodeAt(last);
            if (esutils.code.isLineTerminator(ch) && !(ch === 13 && source.charCodeAt(last + 1) === 10)) {
              waiting = true;
            } else if (waiting) {
              if (ch === 64) {
                break;
              }
              if (!esutils.code.isWhiteSpace(ch)) {
                waiting = false;
              }
            }
            last += 1;
          }
          return last;
        }
        function parseType(title, last, addRange) {
          var ch, brace, type, startIndex, direct = false;
          while (index < last) {
            ch = source.charCodeAt(index);
            if (esutils.code.isWhiteSpace(ch)) {
              advance();
            } else if (ch === 123) {
              advance();
              break;
            } else {
              direct = true;
              break;
            }
          }
          if (direct) {
            return null;
          }
          brace = 1;
          type = "";
          while (index < last) {
            ch = source.charCodeAt(index);
            if (esutils.code.isLineTerminator(ch)) {
              advance();
            } else {
              if (ch === 125) {
                brace -= 1;
                if (brace === 0) {
                  advance();
                  break;
                }
              } else if (ch === 123) {
                brace += 1;
              }
              if (type === "") {
                startIndex = index;
              }
              type += advance();
            }
          }
          if (brace !== 0) {
            return utility.throwError("Braces are not balanced");
          }
          if (isAllowedOptional(title)) {
            return typed.parseParamType(type, { startIndex: convertIndex(startIndex), range: addRange });
          }
          return typed.parseType(type, { startIndex: convertIndex(startIndex), range: addRange });
        }
        function scanIdentifier(last) {
          var identifier;
          if (!esutils.code.isIdentifierStartES5(source.charCodeAt(index)) && !source[index].match(/[0-9]/)) {
            return null;
          }
          identifier = advance();
          while (index < last && esutils.code.isIdentifierPartES5(source.charCodeAt(index))) {
            identifier += advance();
          }
          return identifier;
        }
        function skipWhiteSpace(last) {
          while (index < last && (esutils.code.isWhiteSpace(source.charCodeAt(index)) || esutils.code.isLineTerminator(source.charCodeAt(index)))) {
            advance();
          }
        }
        function parseName(last, allowBrackets, allowNestedParams) {
          var name = "", useBrackets, insideString;
          skipWhiteSpace(last);
          if (index >= last) {
            return null;
          }
          if (source.charCodeAt(index) === 91) {
            if (allowBrackets) {
              useBrackets = true;
              name = advance();
            } else {
              return null;
            }
          }
          name += scanIdentifier(last);
          if (allowNestedParams) {
            if (source.charCodeAt(index) === 58 && (name === "module" || name === "external" || name === "event")) {
              name += advance();
              name += scanIdentifier(last);
            }
            if (source.charCodeAt(index) === 91 && source.charCodeAt(index + 1) === 93) {
              name += advance();
              name += advance();
            }
            while (source.charCodeAt(index) === 46 || source.charCodeAt(index) === 47 || source.charCodeAt(index) === 35 || source.charCodeAt(index) === 45 || source.charCodeAt(index) === 126) {
              name += advance();
              name += scanIdentifier(last);
            }
          }
          if (useBrackets) {
            skipWhiteSpace(last);
            if (source.charCodeAt(index) === 61) {
              name += advance();
              skipWhiteSpace(last);
              var ch;
              var bracketDepth = 1;
              while (index < last) {
                ch = source.charCodeAt(index);
                if (esutils.code.isWhiteSpace(ch)) {
                  if (!insideString) {
                    skipWhiteSpace(last);
                    ch = source.charCodeAt(index);
                  }
                }
                if (ch === 39) {
                  if (!insideString) {
                    insideString = "'";
                  } else {
                    if (insideString === "'") {
                      insideString = "";
                    }
                  }
                }
                if (ch === 34) {
                  if (!insideString) {
                    insideString = '"';
                  } else {
                    if (insideString === '"') {
                      insideString = "";
                    }
                  }
                }
                if (ch === 91) {
                  bracketDepth++;
                } else if (ch === 93 && --bracketDepth === 0) {
                  break;
                }
                name += advance();
              }
            }
            skipWhiteSpace(last);
            if (index >= last || source.charCodeAt(index) !== 93) {
              return null;
            }
            name += advance();
          }
          return name;
        }
        function skipToTag() {
          while (index < length && source.charCodeAt(index) !== 64) {
            advance();
          }
          if (index >= length) {
            return false;
          }
          utility.assert(
            source.charCodeAt(index) === 64
            /* '@' */
          );
          return true;
        }
        function convertIndex(rangeIndex) {
          if (source === originalSource) {
            return rangeIndex;
          }
          return convertUnwrappedCommentIndex(originalSource, rangeIndex);
        }
        function TagParser(options, title) {
          this._options = options;
          this._title = title.toLowerCase();
          this._tag = {
            title,
            description: null
          };
          if (this._options.lineNumbers) {
            this._tag.lineNumber = lineNumber;
          }
          this._first = index - title.length - 1;
          this._last = 0;
          this._extra = {};
        }
        TagParser.prototype.addError = function addError(errorText) {
          var args = Array.prototype.slice.call(arguments, 1), msg = errorText.replace(
            /%(\d)/g,
            function(whole, index2) {
              utility.assert(index2 < args.length, "Message reference must be in range");
              return args[index2];
            }
          );
          if (!this._tag.errors) {
            this._tag.errors = [];
          }
          if (strict) {
            utility.throwError(msg);
          }
          this._tag.errors.push(msg);
          return recoverable;
        };
        TagParser.prototype.parseType = function() {
          if (isTypeParameterRequired(this._title)) {
            try {
              this._tag.type = parseType(this._title, this._last, this._options.range);
              if (!this._tag.type) {
                if (!isParamTitle(this._title) && !isReturnTitle(this._title)) {
                  if (!this.addError("Missing or invalid tag type")) {
                    return false;
                  }
                }
              }
            } catch (error) {
              this._tag.type = null;
              if (!this.addError(error.message)) {
                return false;
              }
            }
          } else if (isAllowedType(this._title)) {
            try {
              this._tag.type = parseType(this._title, this._last, this._options.range);
            } catch (e) {
            }
          }
          return true;
        };
        TagParser.prototype._parseNamePath = function(optional) {
          var name;
          name = parseName(this._last, sloppy && isAllowedOptional(this._title), true);
          if (!name) {
            if (!optional) {
              if (!this.addError("Missing or invalid tag name")) {
                return false;
              }
            }
          }
          this._tag.name = name;
          return true;
        };
        TagParser.prototype.parseNamePath = function() {
          return this._parseNamePath(false);
        };
        TagParser.prototype.parseNamePathOptional = function() {
          return this._parseNamePath(true);
        };
        TagParser.prototype.parseName = function() {
          var assign, name;
          if (isAllowedName(this._title)) {
            this._tag.name = parseName(this._last, sloppy && isAllowedOptional(this._title), isAllowedNested(this._title));
            if (!this._tag.name) {
              if (!isNameParameterRequired(this._title)) {
                return true;
              }
              if (isParamTitle(this._title) && this._tag.type && this._tag.type.name) {
                this._extra.name = this._tag.type;
                this._tag.name = this._tag.type.name;
                this._tag.type = null;
              } else {
                if (!this.addError("Missing or invalid tag name")) {
                  return false;
                }
              }
            } else {
              name = this._tag.name;
              if (name.charAt(0) === "[" && name.charAt(name.length - 1) === "]") {
                assign = name.substring(1, name.length - 1).split("=");
                if (assign.length > 1) {
                  this._tag["default"] = assign.slice(1).join("=");
                }
                this._tag.name = assign[0];
                if (this._tag.type && this._tag.type.type !== "OptionalType") {
                  this._tag.type = {
                    type: "OptionalType",
                    expression: this._tag.type
                  };
                }
              }
            }
          }
          return true;
        };
        TagParser.prototype.parseDescription = function parseDescription() {
          var description = sliceSource(source, index, this._last).trim();
          if (description) {
            if (/^-\s+/.test(description)) {
              description = description.substring(2);
            }
            this._tag.description = description;
          }
          return true;
        };
        TagParser.prototype.parseCaption = function parseDescription() {
          var description = sliceSource(source, index, this._last).trim();
          var captionStartTag = "<caption>";
          var captionEndTag = "</caption>";
          var captionStart = description.indexOf(captionStartTag);
          var captionEnd = description.indexOf(captionEndTag);
          if (captionStart >= 0 && captionEnd >= 0) {
            this._tag.caption = description.substring(
              captionStart + captionStartTag.length,
              captionEnd
            ).trim();
            this._tag.description = description.substring(captionEnd + captionEndTag.length).trim();
          } else {
            this._tag.description = description;
          }
          return true;
        };
        TagParser.prototype.parseKind = function parseKind() {
          var kind, kinds;
          kinds = {
            "class": true,
            "constant": true,
            "event": true,
            "external": true,
            "file": true,
            "function": true,
            "member": true,
            "mixin": true,
            "module": true,
            "namespace": true,
            "typedef": true
          };
          kind = sliceSource(source, index, this._last).trim();
          this._tag.kind = kind;
          if (!hasOwnProperty(kinds, kind)) {
            if (!this.addError("Invalid kind name '%0'", kind)) {
              return false;
            }
          }
          return true;
        };
        TagParser.prototype.parseAccess = function parseAccess() {
          var access;
          access = sliceSource(source, index, this._last).trim();
          this._tag.access = access;
          if (access !== "private" && access !== "protected" && access !== "public") {
            if (!this.addError("Invalid access name '%0'", access)) {
              return false;
            }
          }
          return true;
        };
        TagParser.prototype.parseThis = function parseThis() {
          var value = sliceSource(source, index, this._last).trim();
          if (value && value.charAt(0) === "{") {
            var gotType = this.parseType();
            if (gotType && this._tag.type.type === "NameExpression" || this._tag.type.type === "UnionType") {
              this._tag.name = this._tag.type.name;
              return true;
            } else {
              return this.addError("Invalid name for this");
            }
          } else {
            return this.parseNamePath();
          }
        };
        TagParser.prototype.parseVariation = function parseVariation() {
          var variation, text;
          text = sliceSource(source, index, this._last).trim();
          variation = parseFloat(text, 10);
          this._tag.variation = variation;
          if (isNaN(variation)) {
            if (!this.addError("Invalid variation '%0'", text)) {
              return false;
            }
          }
          return true;
        };
        TagParser.prototype.ensureEnd = function() {
          var shouldBeEmpty = sliceSource(source, index, this._last).trim();
          if (shouldBeEmpty) {
            if (!this.addError("Unknown content '%0'", shouldBeEmpty)) {
              return false;
            }
          }
          return true;
        };
        TagParser.prototype.epilogue = function epilogue() {
          var description;
          description = this._tag.description;
          if (isAllowedOptional(this._title) && !this._tag.type && description && description.charAt(0) === "[") {
            this._tag.type = this._extra.name;
            if (!this._tag.name) {
              this._tag.name = void 0;
            }
            if (!sloppy) {
              if (!this.addError("Missing or invalid tag name")) {
                return false;
              }
            }
          }
          return true;
        };
        Rules = {
          // http://usejsdoc.org/tags-access.html
          "access": ["parseAccess"],
          // http://usejsdoc.org/tags-alias.html
          "alias": ["parseNamePath", "ensureEnd"],
          // http://usejsdoc.org/tags-augments.html
          "augments": ["parseType", "parseNamePathOptional", "ensureEnd"],
          // http://usejsdoc.org/tags-constructor.html
          "constructor": ["parseType", "parseNamePathOptional", "ensureEnd"],
          // Synonym: http://usejsdoc.org/tags-constructor.html
          "class": ["parseType", "parseNamePathOptional", "ensureEnd"],
          // Synonym: http://usejsdoc.org/tags-extends.html
          "extends": ["parseType", "parseNamePathOptional", "ensureEnd"],
          // http://usejsdoc.org/tags-example.html
          "example": ["parseCaption"],
          // http://usejsdoc.org/tags-deprecated.html
          "deprecated": ["parseDescription"],
          // http://usejsdoc.org/tags-global.html
          "global": ["ensureEnd"],
          // http://usejsdoc.org/tags-inner.html
          "inner": ["ensureEnd"],
          // http://usejsdoc.org/tags-instance.html
          "instance": ["ensureEnd"],
          // http://usejsdoc.org/tags-kind.html
          "kind": ["parseKind"],
          // http://usejsdoc.org/tags-mixes.html
          "mixes": ["parseNamePath", "ensureEnd"],
          // http://usejsdoc.org/tags-mixin.html
          "mixin": ["parseNamePathOptional", "ensureEnd"],
          // http://usejsdoc.org/tags-member.html
          "member": ["parseType", "parseNamePathOptional", "ensureEnd"],
          // http://usejsdoc.org/tags-method.html
          "method": ["parseNamePathOptional", "ensureEnd"],
          // http://usejsdoc.org/tags-module.html
          "module": ["parseType", "parseNamePathOptional", "ensureEnd"],
          // Synonym: http://usejsdoc.org/tags-method.html
          "func": ["parseNamePathOptional", "ensureEnd"],
          // Synonym: http://usejsdoc.org/tags-method.html
          "function": ["parseNamePathOptional", "ensureEnd"],
          // Synonym: http://usejsdoc.org/tags-member.html
          "var": ["parseType", "parseNamePathOptional", "ensureEnd"],
          // http://usejsdoc.org/tags-name.html
          "name": ["parseNamePath", "ensureEnd"],
          // http://usejsdoc.org/tags-namespace.html
          "namespace": ["parseType", "parseNamePathOptional", "ensureEnd"],
          // http://usejsdoc.org/tags-private.html
          "private": ["parseType", "parseDescription"],
          // http://usejsdoc.org/tags-protected.html
          "protected": ["parseType", "parseDescription"],
          // http://usejsdoc.org/tags-public.html
          "public": ["parseType", "parseDescription"],
          // http://usejsdoc.org/tags-readonly.html
          "readonly": ["ensureEnd"],
          // http://usejsdoc.org/tags-requires.html
          "requires": ["parseNamePath", "ensureEnd"],
          // http://usejsdoc.org/tags-since.html
          "since": ["parseDescription"],
          // http://usejsdoc.org/tags-static.html
          "static": ["ensureEnd"],
          // http://usejsdoc.org/tags-summary.html
          "summary": ["parseDescription"],
          // http://usejsdoc.org/tags-this.html
          "this": ["parseThis", "ensureEnd"],
          // http://usejsdoc.org/tags-todo.html
          "todo": ["parseDescription"],
          // http://usejsdoc.org/tags-typedef.html
          "typedef": ["parseType", "parseNamePathOptional"],
          // http://usejsdoc.org/tags-variation.html
          "variation": ["parseVariation"],
          // http://usejsdoc.org/tags-version.html
          "version": ["parseDescription"]
        };
        TagParser.prototype.parse = function parse2() {
          var i, iz, sequences, method;
          if (!this._title) {
            if (!this.addError("Missing or invalid title")) {
              return null;
            }
          }
          this._last = seekContent(this._title);
          if (this._options.range) {
            this._tag.range = [this._first, source.slice(0, this._last).replace(/\s*$/, "").length].map(convertIndex);
          }
          if (hasOwnProperty(Rules, this._title)) {
            sequences = Rules[this._title];
          } else {
            sequences = ["parseType", "parseName", "parseDescription", "epilogue"];
          }
          for (i = 0, iz = sequences.length; i < iz; ++i) {
            method = sequences[i];
            if (!this[method]()) {
              return null;
            }
          }
          return this._tag;
        };
        function parseTag(options) {
          var title, parser, tag;
          if (!skipToTag()) {
            return null;
          }
          title = scanTitle();
          parser = new TagParser(options, title);
          tag = parser.parse();
          while (index < parser._last) {
            advance();
          }
          return tag;
        }
        function scanJSDocDescription(preserveWhitespace) {
          var description = "", ch, atAllowed;
          atAllowed = true;
          while (index < length) {
            ch = source.charCodeAt(index);
            if (atAllowed && ch === 64) {
              break;
            }
            if (esutils.code.isLineTerminator(ch)) {
              atAllowed = true;
            } else if (atAllowed && !esutils.code.isWhiteSpace(ch)) {
              atAllowed = false;
            }
            description += advance();
          }
          return preserveWhitespace ? description : description.trim();
        }
        function parse(comment, options) {
          var tags = [], tag, description, interestingTags, i, iz;
          if (options === void 0) {
            options = {};
          }
          if (typeof options.unwrap === "boolean" && options.unwrap) {
            source = unwrapComment(comment);
          } else {
            source = comment;
          }
          originalSource = comment;
          if (options.tags) {
            if (Array.isArray(options.tags)) {
              interestingTags = {};
              for (i = 0, iz = options.tags.length; i < iz; i++) {
                if (typeof options.tags[i] === "string") {
                  interestingTags[options.tags[i]] = true;
                } else {
                  utility.throwError('Invalid "tags" parameter: ' + options.tags);
                }
              }
            } else {
              utility.throwError('Invalid "tags" parameter: ' + options.tags);
            }
          }
          length = source.length;
          index = 0;
          lineNumber = 0;
          recoverable = options.recoverable;
          sloppy = options.sloppy;
          strict = options.strict;
          description = scanJSDocDescription(options.preserveWhitespace);
          while (true) {
            tag = parseTag(options);
            if (!tag) {
              break;
            }
            if (!interestingTags || interestingTags.hasOwnProperty(tag.title)) {
              tags.push(tag);
            }
          }
          return {
            description,
            tags
          };
        }
        exports2.parse = parse;
      })(jsdoc = {});
      exports.version = utility.VERSION;
      exports.parse = jsdoc.parse;
      exports.parseType = typed.parseType;
      exports.parseParamType = typed.parseParamType;
      exports.unwrapComment = unwrapComment;
      exports.Syntax = shallowCopy(typed.Syntax);
      exports.Error = utility.DoctrineError;
      exports.type = {
        Syntax: exports.Syntax,
        parseType: typed.parseType,
        parseParamType: typed.parseParamType,
        stringify: typed.stringify
      };
    })();
  }
});

// ../../node_modules/eslint/lib/rules/valid-jsdoc.js
var require_valid_jsdoc = __commonJS({
  "../../node_modules/eslint/lib/rules/valid-jsdoc.js"(exports, module) {
    "use strict";
    var doctrine = require_doctrine();
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Enforce valid JSDoc comments",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/valid-jsdoc"
        },
        schema: [
          {
            type: "object",
            properties: {
              prefer: {
                type: "object",
                additionalProperties: {
                  type: "string"
                }
              },
              preferType: {
                type: "object",
                additionalProperties: {
                  type: "string"
                }
              },
              requireReturn: {
                type: "boolean",
                default: true
              },
              requireParamDescription: {
                type: "boolean",
                default: true
              },
              requireReturnDescription: {
                type: "boolean",
                default: true
              },
              matchDescription: {
                type: "string"
              },
              requireReturnType: {
                type: "boolean",
                default: true
              },
              requireParamType: {
                type: "boolean",
                default: true
              }
            },
            additionalProperties: false
          }
        ],
        fixable: "code",
        messages: {
          unexpectedTag: "Unexpected @{{title}} tag; function has no return statement.",
          expected: "Expected JSDoc for '{{name}}' but found '{{jsdocName}}'.",
          use: "Use @{{name}} instead.",
          useType: "Use '{{expectedTypeName}}' instead of '{{currentTypeName}}'.",
          syntaxError: "JSDoc syntax error.",
          missingBrace: "JSDoc type missing brace.",
          missingParamDesc: "Missing JSDoc parameter description for '{{name}}'.",
          missingParamType: "Missing JSDoc parameter type for '{{name}}'.",
          missingReturnType: "Missing JSDoc return type.",
          missingReturnDesc: "Missing JSDoc return description.",
          missingReturn: "Missing JSDoc @{{returns}} for function.",
          missingParam: "Missing JSDoc for parameter '{{name}}'.",
          duplicateParam: "Duplicate JSDoc parameter '{{name}}'.",
          unsatisfiedDesc: "JSDoc description does not satisfy the regex pattern."
        },
        deprecated: true,
        replacedBy: []
      },
      create(context) {
        const options = context.options[0] || {}, prefer = options.prefer || {}, sourceCode = context.sourceCode, requireReturn = options.requireReturn !== false, requireParamDescription = options.requireParamDescription !== false, requireReturnDescription = options.requireReturnDescription !== false, requireReturnType = options.requireReturnType !== false, requireParamType = options.requireParamType !== false, preferType = options.preferType || {}, checkPreferType = Object.keys(preferType).length !== 0;
        const fns = [];
        function isTypeClass(node) {
          return node.type === "ClassExpression" || node.type === "ClassDeclaration";
        }
        function startFunction(node) {
          fns.push({
            returnPresent: node.type === "ArrowFunctionExpression" && node.body.type !== "BlockStatement" || isTypeClass(node) || node.async
          });
        }
        function addReturn(node) {
          const functionState = fns[fns.length - 1];
          if (functionState && node.argument !== null) {
            functionState.returnPresent = true;
          }
        }
        function isValidReturnType(tag) {
          return tag.type === null || tag.type.name === "void" || tag.type.type === "UndefinedLiteral";
        }
        function canTypeBeValidated(type) {
          return type !== "UndefinedLiteral" && // {undefined} as there is no name property available.
          type !== "NullLiteral" && // {null}
          type !== "NullableLiteral" && // {?}
          type !== "FunctionType" && // {function(a)}
          type !== "AllLiteral";
        }
        function getCurrentExpectedTypes(type) {
          let currentType;
          if (type.name) {
            currentType = type;
          } else if (type.expression) {
            currentType = type.expression;
          }
          return {
            currentType,
            expectedTypeName: currentType && preferType[currentType.name]
          };
        }
        function getAbsoluteRange(jsdocComment, parsedJsdocNode) {
          return {
            start: sourceCode.getLocFromIndex(jsdocComment.range[0] + 2 + parsedJsdocNode.range[0]),
            end: sourceCode.getLocFromIndex(jsdocComment.range[0] + 2 + parsedJsdocNode.range[1])
          };
        }
        function validateType(jsdocNode, type) {
          if (!type || !canTypeBeValidated(type.type)) {
            return;
          }
          const typesToCheck = [];
          let elements = [];
          switch (type.type) {
            case "TypeApplication":
              elements = type.applications[0].type === "UnionType" ? type.applications[0].elements : type.applications;
              typesToCheck.push(getCurrentExpectedTypes(type));
              break;
            case "RecordType":
              elements = type.fields;
              break;
            case "UnionType":
            case "ArrayType":
              elements = type.elements;
              break;
            case "FieldType":
              if (type.value) {
                typesToCheck.push(getCurrentExpectedTypes(type.value));
              }
              break;
            default:
              typesToCheck.push(getCurrentExpectedTypes(type));
          }
          elements.forEach(validateType.bind(null, jsdocNode));
          typesToCheck.forEach((typeToCheck) => {
            if (typeToCheck.expectedTypeName && typeToCheck.expectedTypeName !== typeToCheck.currentType.name) {
              context.report({
                node: jsdocNode,
                messageId: "useType",
                loc: getAbsoluteRange(jsdocNode, typeToCheck.currentType),
                data: {
                  currentTypeName: typeToCheck.currentType.name,
                  expectedTypeName: typeToCheck.expectedTypeName
                },
                fix(fixer) {
                  return fixer.replaceTextRange(
                    typeToCheck.currentType.range.map((indexInComment) => jsdocNode.range[0] + 2 + indexInComment),
                    typeToCheck.expectedTypeName
                  );
                }
              });
            }
          });
        }
        function checkJSDoc(node) {
          const jsdocNode = sourceCode.getJSDocComment(node), functionData = fns.pop(), paramTagsByName = /* @__PURE__ */ Object.create(null), paramTags = [];
          let hasReturns = false, returnsTag, hasConstructor = false, isInterface = false, isOverride = false, isAbstract = false;
          if (jsdocNode) {
            let jsdoc;
            try {
              jsdoc = doctrine.parse(jsdocNode.value, {
                strict: true,
                unwrap: true,
                sloppy: true,
                range: true
              });
            } catch (ex) {
              if (/braces/iu.test(ex.message)) {
                context.report({ node: jsdocNode, messageId: "missingBrace" });
              } else {
                context.report({ node: jsdocNode, messageId: "syntaxError" });
              }
              return;
            }
            jsdoc.tags.forEach((tag) => {
              switch (tag.title.toLowerCase()) {
                case "param":
                case "arg":
                case "argument":
                  paramTags.push(tag);
                  break;
                case "return":
                case "returns":
                  hasReturns = true;
                  returnsTag = tag;
                  break;
                case "constructor":
                case "class":
                  hasConstructor = true;
                  break;
                case "override":
                case "inheritdoc":
                  isOverride = true;
                  break;
                case "abstract":
                case "virtual":
                  isAbstract = true;
                  break;
                case "interface":
                  isInterface = true;
                  break;
              }
              if (Object.prototype.hasOwnProperty.call(prefer, tag.title) && tag.title !== prefer[tag.title]) {
                const entireTagRange = getAbsoluteRange(jsdocNode, tag);
                context.report({
                  node: jsdocNode,
                  messageId: "use",
                  loc: {
                    start: entireTagRange.start,
                    end: {
                      line: entireTagRange.start.line,
                      column: entireTagRange.start.column + `@${tag.title}`.length
                    }
                  },
                  data: { name: prefer[tag.title] },
                  fix(fixer) {
                    return fixer.replaceTextRange(
                      [
                        jsdocNode.range[0] + tag.range[0] + 3,
                        jsdocNode.range[0] + tag.range[0] + tag.title.length + 3
                      ],
                      prefer[tag.title]
                    );
                  }
                });
              }
              if (checkPreferType && tag.type) {
                validateType(jsdocNode, tag.type);
              }
            });
            paramTags.forEach((param) => {
              if (requireParamType && !param.type) {
                context.report({
                  node: jsdocNode,
                  messageId: "missingParamType",
                  loc: getAbsoluteRange(jsdocNode, param),
                  data: { name: param.name }
                });
              }
              if (!param.description && requireParamDescription) {
                context.report({
                  node: jsdocNode,
                  messageId: "missingParamDesc",
                  loc: getAbsoluteRange(jsdocNode, param),
                  data: { name: param.name }
                });
              }
              if (paramTagsByName[param.name]) {
                context.report({
                  node: jsdocNode,
                  messageId: "duplicateParam",
                  loc: getAbsoluteRange(jsdocNode, param),
                  data: { name: param.name }
                });
              } else if (!param.name.includes(".")) {
                paramTagsByName[param.name] = param;
              }
            });
            if (hasReturns) {
              if (!requireReturn && !functionData.returnPresent && (returnsTag.type === null || !isValidReturnType(returnsTag)) && !isAbstract) {
                context.report({
                  node: jsdocNode,
                  messageId: "unexpectedTag",
                  loc: getAbsoluteRange(jsdocNode, returnsTag),
                  data: {
                    title: returnsTag.title
                  }
                });
              } else {
                if (requireReturnType && !returnsTag.type) {
                  context.report({ node: jsdocNode, messageId: "missingReturnType" });
                }
                if (!isValidReturnType(returnsTag) && !returnsTag.description && requireReturnDescription) {
                  context.report({ node: jsdocNode, messageId: "missingReturnDesc" });
                }
              }
            }
            if (!isOverride && !hasReturns && !hasConstructor && !isInterface && node.parent.kind !== "get" && node.parent.kind !== "constructor" && node.parent.kind !== "set" && !isTypeClass(node)) {
              if (requireReturn || functionData.returnPresent && !node.async) {
                context.report({
                  node: jsdocNode,
                  messageId: "missingReturn",
                  data: {
                    returns: prefer.returns || "returns"
                  }
                });
              }
            }
            const jsdocParamNames = Object.keys(paramTagsByName);
            if (node.params) {
              node.params.forEach((param, paramsIndex) => {
                const bindingParam = param.type === "AssignmentPattern" ? param.left : param;
                if (bindingParam.type === "Identifier") {
                  const name = bindingParam.name;
                  if (jsdocParamNames[paramsIndex] && name !== jsdocParamNames[paramsIndex]) {
                    context.report({
                      node: jsdocNode,
                      messageId: "expected",
                      loc: getAbsoluteRange(jsdocNode, paramTagsByName[jsdocParamNames[paramsIndex]]),
                      data: {
                        name,
                        jsdocName: jsdocParamNames[paramsIndex]
                      }
                    });
                  } else if (!paramTagsByName[name] && !isOverride) {
                    context.report({
                      node: jsdocNode,
                      messageId: "missingParam",
                      data: {
                        name
                      }
                    });
                  }
                }
              });
            }
            if (options.matchDescription) {
              const regex = new RegExp(options.matchDescription, "u");
              if (!regex.test(jsdoc.description)) {
                context.report({ node: jsdocNode, messageId: "unsatisfiedDesc" });
              }
            }
          }
        }
        return {
          ArrowFunctionExpression: startFunction,
          FunctionExpression: startFunction,
          FunctionDeclaration: startFunction,
          ClassExpression: startFunction,
          ClassDeclaration: startFunction,
          "ArrowFunctionExpression:exit": checkJSDoc,
          "FunctionExpression:exit": checkJSDoc,
          "FunctionDeclaration:exit": checkJSDoc,
          "ClassExpression:exit": checkJSDoc,
          "ClassDeclaration:exit": checkJSDoc,
          ReturnStatement: addReturn
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/valid-typeof.js
var require_valid_typeof = __commonJS({
  "../../node_modules/eslint/lib/rules/valid-typeof.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    module.exports = {
      meta: {
        type: "problem",
        docs: {
          description: "Enforce comparing `typeof` expressions against valid strings",
          recommended: true,
          url: "https://eslint.org/docs/latest/rules/valid-typeof"
        },
        hasSuggestions: true,
        schema: [
          {
            type: "object",
            properties: {
              requireStringLiterals: {
                type: "boolean",
                default: false
              }
            },
            additionalProperties: false
          }
        ],
        messages: {
          invalidValue: "Invalid typeof comparison value.",
          notString: "Typeof comparisons should be to string literals.",
          suggestString: 'Use `"{{type}}"` instead of `{{type}}`.'
        }
      },
      create(context) {
        const VALID_TYPES = /* @__PURE__ */ new Set(["symbol", "undefined", "object", "boolean", "number", "string", "function", "bigint"]), OPERATORS = /* @__PURE__ */ new Set(["==", "===", "!=", "!=="]);
        const sourceCode = context.sourceCode;
        const requireStringLiterals = context.options[0] && context.options[0].requireStringLiterals;
        let globalScope;
        function isReferenceToGlobalVariable(node) {
          const variable = globalScope.set.get(node.name);
          return variable && variable.defs.length === 0 && variable.references.some((ref) => ref.identifier === node);
        }
        function isTypeofExpression(node) {
          return node.type === "UnaryExpression" && node.operator === "typeof";
        }
        return {
          Program(node) {
            globalScope = sourceCode.getScope(node);
          },
          UnaryExpression(node) {
            if (isTypeofExpression(node)) {
              const { parent } = node;
              if (parent.type === "BinaryExpression" && OPERATORS.has(parent.operator)) {
                const sibling = parent.left === node ? parent.right : parent.left;
                if (sibling.type === "Literal" || astUtils.isStaticTemplateLiteral(sibling)) {
                  const value = sibling.type === "Literal" ? sibling.value : sibling.quasis[0].value.cooked;
                  if (!VALID_TYPES.has(value)) {
                    context.report({ node: sibling, messageId: "invalidValue" });
                  }
                } else if (sibling.type === "Identifier" && sibling.name === "undefined" && isReferenceToGlobalVariable(sibling)) {
                  context.report({
                    node: sibling,
                    messageId: requireStringLiterals ? "notString" : "invalidValue",
                    suggest: [
                      {
                        messageId: "suggestString",
                        data: { type: "undefined" },
                        fix(fixer) {
                          return fixer.replaceText(sibling, '"undefined"');
                        }
                      }
                    ]
                  });
                } else if (requireStringLiterals && !isTypeofExpression(sibling)) {
                  context.report({ node: sibling, messageId: "notString" });
                }
              }
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/vars-on-top.js
var require_vars_on_top = __commonJS({
  "../../node_modules/eslint/lib/rules/vars-on-top.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: "Require `var` declarations be placed at the top of their containing scope",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/vars-on-top"
        },
        schema: [],
        messages: {
          top: "All 'var' declarations must be at the top of the function scope."
        }
      },
      create(context) {
        function looksLikeDirective(node) {
          return node.type === "ExpressionStatement" && node.expression.type === "Literal" && typeof node.expression.value === "string";
        }
        function looksLikeImport(node) {
          return node.type === "ImportDeclaration" || node.type === "ImportSpecifier" || node.type === "ImportDefaultSpecifier" || node.type === "ImportNamespaceSpecifier";
        }
        function isVariableDeclaration(node) {
          return node.type === "VariableDeclaration" || node.type === "ExportNamedDeclaration" && node.declaration && node.declaration.type === "VariableDeclaration";
        }
        function isVarOnTop(node, statements) {
          const l = statements.length;
          let i = 0;
          if (node.parent.type !== "StaticBlock") {
            for (; i < l; ++i) {
              if (!looksLikeDirective(statements[i]) && !looksLikeImport(statements[i])) {
                break;
              }
            }
          }
          for (; i < l; ++i) {
            if (!isVariableDeclaration(statements[i])) {
              return false;
            }
            if (statements[i] === node) {
              return true;
            }
          }
          return false;
        }
        function globalVarCheck(node, parent) {
          if (!isVarOnTop(node, parent.body)) {
            context.report({ node, messageId: "top" });
          }
        }
        function blockScopeVarCheck(node) {
          const { parent } = node;
          if (parent.type === "BlockStatement" && /Function/u.test(parent.parent.type) && isVarOnTop(node, parent.body)) {
            return;
          }
          if (parent.type === "StaticBlock" && isVarOnTop(node, parent.body)) {
            return;
          }
          context.report({ node, messageId: "top" });
        }
        return {
          "VariableDeclaration[kind='var']"(node) {
            if (node.parent.type === "ExportNamedDeclaration") {
              globalVarCheck(node.parent, node.parent.parent);
            } else if (node.parent.type === "Program") {
              globalVarCheck(node, node.parent);
            } else {
              blockScopeVarCheck(node);
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/wrap-iife.js
var require_wrap_iife = __commonJS({
  "../../node_modules/eslint/lib/rules/wrap-iife.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    var eslintUtils = require_eslint_utils();
    function isCalleeOfNewExpression(node) {
      const maybeCallee = node.parent.type === "ChainExpression" ? node.parent : node;
      return maybeCallee.parent.type === "NewExpression" && maybeCallee.parent.callee === maybeCallee;
    }
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Require parentheses around immediate `function` invocations",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/wrap-iife"
        },
        schema: [
          {
            enum: ["outside", "inside", "any"]
          },
          {
            type: "object",
            properties: {
              functionPrototypeMethods: {
                type: "boolean",
                default: false
              }
            },
            additionalProperties: false
          }
        ],
        fixable: "code",
        messages: {
          wrapInvocation: "Wrap an immediate function invocation in parentheses.",
          wrapExpression: "Wrap only the function expression in parens.",
          moveInvocation: "Move the invocation into the parens that contain the function."
        }
      },
      create(context) {
        const style = context.options[0] || "outside";
        const includeFunctionPrototypeMethods = context.options[1] && context.options[1].functionPrototypeMethods;
        const sourceCode = context.sourceCode;
        function isWrappedInAnyParens(node) {
          return astUtils.isParenthesised(sourceCode, node);
        }
        function isWrappedInGroupingParens(node) {
          return eslintUtils.isParenthesized(1, node, sourceCode);
        }
        function getFunctionNodeFromIIFE(node) {
          const callee = astUtils.skipChainExpression(node.callee);
          if (callee.type === "FunctionExpression") {
            return callee;
          }
          if (includeFunctionPrototypeMethods && callee.type === "MemberExpression" && callee.object.type === "FunctionExpression" && (astUtils.getStaticPropertyName(callee) === "call" || astUtils.getStaticPropertyName(callee) === "apply")) {
            return callee.object;
          }
          return null;
        }
        return {
          CallExpression(node) {
            const innerNode = getFunctionNodeFromIIFE(node);
            if (!innerNode) {
              return;
            }
            const isCallExpressionWrapped = isWrappedInAnyParens(node), isFunctionExpressionWrapped = isWrappedInAnyParens(innerNode);
            if (!isCallExpressionWrapped && !isFunctionExpressionWrapped) {
              context.report({
                node,
                messageId: "wrapInvocation",
                fix(fixer) {
                  const nodeToSurround = style === "inside" ? innerNode : node;
                  return fixer.replaceText(nodeToSurround, `(${sourceCode.getText(nodeToSurround)})`);
                }
              });
            } else if (style === "inside" && !isFunctionExpressionWrapped) {
              context.report({
                node,
                messageId: "wrapExpression",
                fix(fixer) {
                  if (isWrappedInGroupingParens(node) && !isCalleeOfNewExpression(node)) {
                    const parenAfter = sourceCode.getTokenAfter(node);
                    return fixer.replaceTextRange(
                      [innerNode.range[1], parenAfter.range[1]],
                      `)${sourceCode.getText().slice(innerNode.range[1], parenAfter.range[0])}`
                    );
                  }
                  return fixer.replaceText(innerNode, `(${sourceCode.getText(innerNode)})`);
                }
              });
            } else if (style === "outside" && !isCallExpressionWrapped) {
              context.report({
                node,
                messageId: "moveInvocation",
                fix(fixer) {
                  const parenAfter = sourceCode.getTokenAfter(innerNode);
                  return fixer.replaceTextRange(
                    [parenAfter.range[0], node.range[1]],
                    `${sourceCode.getText().slice(parenAfter.range[1], node.range[1])})`
                  );
                }
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/wrap-regex.js
var require_wrap_regex = __commonJS({
  "../../node_modules/eslint/lib/rules/wrap-regex.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Require parenthesis around regex literals",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/wrap-regex"
        },
        schema: [],
        fixable: "code",
        messages: {
          requireParens: "Wrap the regexp literal in parens to disambiguate the slash."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        return {
          Literal(node) {
            const token = sourceCode.getFirstToken(node), nodeType = token.type;
            if (nodeType === "RegularExpression") {
              const beforeToken = sourceCode.getTokenBefore(node);
              const afterToken = sourceCode.getTokenAfter(node);
              const { parent } = node;
              if (parent.type === "MemberExpression" && parent.object === node && !(beforeToken && beforeToken.value === "(" && afterToken && afterToken.value === ")")) {
                context.report({
                  node,
                  messageId: "requireParens",
                  fix: (fixer) => fixer.replaceText(node, `(${sourceCode.getText(node)})`)
                });
              }
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/yield-star-spacing.js
var require_yield_star_spacing = __commonJS({
  "../../node_modules/eslint/lib/rules/yield-star-spacing.js"(exports, module) {
    "use strict";
    module.exports = {
      meta: {
        type: "layout",
        docs: {
          description: "Require or disallow spacing around the `*` in `yield*` expressions",
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/yield-star-spacing"
        },
        fixable: "whitespace",
        schema: [
          {
            oneOf: [
              {
                enum: ["before", "after", "both", "neither"]
              },
              {
                type: "object",
                properties: {
                  before: { type: "boolean" },
                  after: { type: "boolean" }
                },
                additionalProperties: false
              }
            ]
          }
        ],
        messages: {
          missingBefore: "Missing space before *.",
          missingAfter: "Missing space after *.",
          unexpectedBefore: "Unexpected space before *.",
          unexpectedAfter: "Unexpected space after *."
        }
      },
      create(context) {
        const sourceCode = context.sourceCode;
        const mode = function(option) {
          if (!option || typeof option === "string") {
            return {
              before: { before: true, after: false },
              after: { before: false, after: true },
              both: { before: true, after: true },
              neither: { before: false, after: false }
            }[option || "after"];
          }
          return option;
        }(context.options[0]);
        function checkSpacing(side, leftToken, rightToken) {
          if (sourceCode.isSpaceBetweenTokens(leftToken, rightToken) !== mode[side]) {
            const after = leftToken.value === "*";
            const spaceRequired = mode[side];
            const node = after ? leftToken : rightToken;
            let messageId = "";
            if (spaceRequired) {
              messageId = side === "before" ? "missingBefore" : "missingAfter";
            } else {
              messageId = side === "before" ? "unexpectedBefore" : "unexpectedAfter";
            }
            context.report({
              node,
              messageId,
              fix(fixer) {
                if (spaceRequired) {
                  if (after) {
                    return fixer.insertTextAfter(node, " ");
                  }
                  return fixer.insertTextBefore(node, " ");
                }
                return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);
              }
            });
          }
        }
        function checkExpression(node) {
          if (!node.delegate) {
            return;
          }
          const tokens = sourceCode.getFirstTokens(node, 3);
          const yieldToken = tokens[0];
          const starToken = tokens[1];
          const nextToken = tokens[2];
          checkSpacing("before", yieldToken, starToken);
          checkSpacing("after", starToken, nextToken);
        }
        return {
          YieldExpression: checkExpression
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/yoda.js
var require_yoda = __commonJS({
  "../../node_modules/eslint/lib/rules/yoda.js"(exports, module) {
    "use strict";
    var astUtils = require_ast_utils2();
    function isComparisonOperator(operator) {
      return /^(==|===|!=|!==|<|>|<=|>=)$/u.test(operator);
    }
    function isEqualityOperator(operator) {
      return /^(==|===)$/u.test(operator);
    }
    function isRangeTestOperator(operator) {
      return ["<", "<="].includes(operator);
    }
    function isNegativeNumericLiteral(node) {
      return node.type === "UnaryExpression" && node.operator === "-" && node.prefix && astUtils.isNumericLiteral(node.argument);
    }
    function looksLikeLiteral(node) {
      return isNegativeNumericLiteral(node) || astUtils.isStaticTemplateLiteral(node);
    }
    function getNormalizedLiteral(node) {
      if (node.type === "Literal") {
        return node;
      }
      if (isNegativeNumericLiteral(node)) {
        return {
          type: "Literal",
          value: -node.argument.value,
          raw: `-${node.argument.value}`
        };
      }
      if (astUtils.isStaticTemplateLiteral(node)) {
        return {
          type: "Literal",
          value: node.quasis[0].value.cooked,
          raw: node.quasis[0].value.raw
        };
      }
      return null;
    }
    module.exports = {
      meta: {
        type: "suggestion",
        docs: {
          description: 'Require or disallow "Yoda" conditions',
          recommended: false,
          url: "https://eslint.org/docs/latest/rules/yoda"
        },
        schema: [
          {
            enum: ["always", "never"]
          },
          {
            type: "object",
            properties: {
              exceptRange: {
                type: "boolean",
                default: false
              },
              onlyEquality: {
                type: "boolean",
                default: false
              }
            },
            additionalProperties: false
          }
        ],
        fixable: "code",
        messages: {
          expected: "Expected literal to be on the {{expectedSide}} side of {{operator}}."
        }
      },
      create(context) {
        const always = context.options[0] === "always";
        const exceptRange = context.options[1] && context.options[1].exceptRange;
        const onlyEquality = context.options[1] && context.options[1].onlyEquality;
        const sourceCode = context.sourceCode;
        function isRangeTest(node) {
          const left = node.left, right = node.right;
          function isBetweenTest() {
            if (node.operator === "&&" && astUtils.isSameReference(left.right, right.left)) {
              const leftLiteral = getNormalizedLiteral(left.left);
              const rightLiteral = getNormalizedLiteral(right.right);
              if (leftLiteral === null && rightLiteral === null) {
                return false;
              }
              if (rightLiteral === null || leftLiteral === null) {
                return true;
              }
              if (leftLiteral.value <= rightLiteral.value) {
                return true;
              }
            }
            return false;
          }
          function isOutsideTest() {
            if (node.operator === "||" && astUtils.isSameReference(left.left, right.right)) {
              const leftLiteral = getNormalizedLiteral(left.right);
              const rightLiteral = getNormalizedLiteral(right.left);
              if (leftLiteral === null && rightLiteral === null) {
                return false;
              }
              if (rightLiteral === null || leftLiteral === null) {
                return true;
              }
              if (leftLiteral.value <= rightLiteral.value) {
                return true;
              }
            }
            return false;
          }
          function isParenWrapped() {
            return astUtils.isParenthesised(sourceCode, node);
          }
          return node.type === "LogicalExpression" && left.type === "BinaryExpression" && right.type === "BinaryExpression" && isRangeTestOperator(left.operator) && isRangeTestOperator(right.operator) && (isBetweenTest() || isOutsideTest()) && isParenWrapped();
        }
        const OPERATOR_FLIP_MAP = {
          "===": "===",
          "!==": "!==",
          "==": "==",
          "!=": "!=",
          "<": ">",
          ">": "<",
          "<=": ">=",
          ">=": "<="
        };
        function getFlippedString(node) {
          const operatorToken = sourceCode.getFirstTokenBetween(
            node.left,
            node.right,
            (token) => token.value === node.operator
          );
          const lastLeftToken = sourceCode.getTokenBefore(operatorToken);
          const firstRightToken = sourceCode.getTokenAfter(operatorToken);
          const source = sourceCode.getText();
          const leftText = source.slice(
            node.range[0],
            lastLeftToken.range[1]
          );
          const textBeforeOperator = source.slice(
            lastLeftToken.range[1],
            operatorToken.range[0]
          );
          const textAfterOperator = source.slice(
            operatorToken.range[1],
            firstRightToken.range[0]
          );
          const rightText = source.slice(
            firstRightToken.range[0],
            node.range[1]
          );
          const tokenBefore = sourceCode.getTokenBefore(node);
          const tokenAfter = sourceCode.getTokenAfter(node);
          let prefix = "";
          let suffix = "";
          if (tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, firstRightToken)) {
            prefix = " ";
          }
          if (tokenAfter && node.range[1] === tokenAfter.range[0] && !astUtils.canTokensBeAdjacent(lastLeftToken, tokenAfter)) {
            suffix = " ";
          }
          return prefix + rightText + textBeforeOperator + OPERATOR_FLIP_MAP[operatorToken.value] + textAfterOperator + leftText + suffix;
        }
        return {
          BinaryExpression(node) {
            const expectedLiteral = always ? node.left : node.right;
            const expectedNonLiteral = always ? node.right : node.left;
            if ((expectedNonLiteral.type === "Literal" || looksLikeLiteral(expectedNonLiteral)) && !(expectedLiteral.type === "Literal" || looksLikeLiteral(expectedLiteral)) && !(!isEqualityOperator(node.operator) && onlyEquality) && isComparisonOperator(node.operator) && !(exceptRange && isRangeTest(node.parent))) {
              context.report({
                node,
                messageId: "expected",
                data: {
                  operator: node.operator,
                  expectedSide: always ? "left" : "right"
                },
                fix: (fixer) => fixer.replaceText(node, getFlippedString(node))
              });
            }
          }
        };
      }
    };
  }
});

// ../../node_modules/eslint/lib/rules/index.js
var require_rules2 = __commonJS({
  "../../node_modules/eslint/lib/rules/index.js"(exports, module) {
    "use strict";
    var { LazyLoadingRuleMap } = require_lazy_loading_rule_map();
    module.exports = new LazyLoadingRuleMap(Object.entries({
      "accessor-pairs": () => require_accessor_pairs(),
      "array-bracket-newline": () => require_array_bracket_newline(),
      "array-bracket-spacing": () => require_array_bracket_spacing(),
      "array-callback-return": () => require_array_callback_return(),
      "array-element-newline": () => require_array_element_newline(),
      "arrow-body-style": () => require_arrow_body_style(),
      "arrow-parens": () => require_arrow_parens(),
      "arrow-spacing": () => require_arrow_spacing(),
      "block-scoped-var": () => require_block_scoped_var(),
      "block-spacing": () => require_block_spacing(),
      "brace-style": () => require_brace_style(),
      "callback-return": () => require_callback_return(),
      camelcase: () => require_camelcase(),
      "capitalized-comments": () => require_capitalized_comments(),
      "class-methods-use-this": () => require_class_methods_use_this(),
      "comma-dangle": () => require_comma_dangle(),
      "comma-spacing": () => require_comma_spacing(),
      "comma-style": () => require_comma_style(),
      complexity: () => require_complexity(),
      "computed-property-spacing": () => require_computed_property_spacing(),
      "consistent-return": () => require_consistent_return(),
      "consistent-this": () => require_consistent_this(),
      "constructor-super": () => require_constructor_super(),
      curly: () => require_curly(),
      "default-case": () => require_default_case(),
      "default-case-last": () => require_default_case_last(),
      "default-param-last": () => require_default_param_last(),
      "dot-location": () => require_dot_location(),
      "dot-notation": () => require_dot_notation(),
      "eol-last": () => require_eol_last(),
      eqeqeq: () => require_eqeqeq(),
      "for-direction": () => require_for_direction(),
      "func-call-spacing": () => require_func_call_spacing(),
      "func-name-matching": () => require_func_name_matching(),
      "func-names": () => require_func_names(),
      "func-style": () => require_func_style(),
      "function-call-argument-newline": () => require_function_call_argument_newline(),
      "function-paren-newline": () => require_function_paren_newline(),
      "generator-star-spacing": () => require_generator_star_spacing(),
      "getter-return": () => require_getter_return(),
      "global-require": () => require_global_require(),
      "grouped-accessor-pairs": () => require_grouped_accessor_pairs(),
      "guard-for-in": () => require_guard_for_in(),
      "handle-callback-err": () => require_handle_callback_err(),
      "id-blacklist": () => require_id_blacklist(),
      "id-denylist": () => require_id_denylist(),
      "id-length": () => require_id_length(),
      "id-match": () => require_id_match(),
      "implicit-arrow-linebreak": () => require_implicit_arrow_linebreak(),
      indent: () => require_indent(),
      "indent-legacy": () => require_indent_legacy(),
      "init-declarations": () => require_init_declarations(),
      "jsx-quotes": () => require_jsx_quotes(),
      "key-spacing": () => require_key_spacing(),
      "keyword-spacing": () => require_keyword_spacing(),
      "line-comment-position": () => require_line_comment_position(),
      "linebreak-style": () => require_linebreak_style(),
      "lines-around-comment": () => require_lines_around_comment(),
      "lines-around-directive": () => require_lines_around_directive(),
      "lines-between-class-members": () => require_lines_between_class_members(),
      "logical-assignment-operators": () => require_logical_assignment_operators(),
      "max-classes-per-file": () => require_max_classes_per_file(),
      "max-depth": () => require_max_depth(),
      "max-len": () => require_max_len(),
      "max-lines": () => require_max_lines(),
      "max-lines-per-function": () => require_max_lines_per_function(),
      "max-nested-callbacks": () => require_max_nested_callbacks(),
      "max-params": () => require_max_params(),
      "max-statements": () => require_max_statements(),
      "max-statements-per-line": () => require_max_statements_per_line(),
      "multiline-comment-style": () => require_multiline_comment_style(),
      "multiline-ternary": () => require_multiline_ternary(),
      "new-cap": () => require_new_cap(),
      "new-parens": () => require_new_parens(),
      "newline-after-var": () => require_newline_after_var(),
      "newline-before-return": () => require_newline_before_return(),
      "newline-per-chained-call": () => require_newline_per_chained_call(),
      "no-alert": () => require_no_alert(),
      "no-array-constructor": () => require_no_array_constructor(),
      "no-async-promise-executor": () => require_no_async_promise_executor(),
      "no-await-in-loop": () => require_no_await_in_loop(),
      "no-bitwise": () => require_no_bitwise(),
      "no-buffer-constructor": () => require_no_buffer_constructor(),
      "no-caller": () => require_no_caller(),
      "no-case-declarations": () => require_no_case_declarations(),
      "no-catch-shadow": () => require_no_catch_shadow(),
      "no-class-assign": () => require_no_class_assign(),
      "no-compare-neg-zero": () => require_no_compare_neg_zero(),
      "no-cond-assign": () => require_no_cond_assign(),
      "no-confusing-arrow": () => require_no_confusing_arrow(),
      "no-console": () => require_no_console(),
      "no-const-assign": () => require_no_const_assign(),
      "no-constant-binary-expression": () => require_no_constant_binary_expression(),
      "no-constant-condition": () => require_no_constant_condition(),
      "no-constructor-return": () => require_no_constructor_return(),
      "no-continue": () => require_no_continue(),
      "no-control-regex": () => require_no_control_regex(),
      "no-debugger": () => require_no_debugger(),
      "no-delete-var": () => require_no_delete_var(),
      "no-div-regex": () => require_no_div_regex(),
      "no-dupe-args": () => require_no_dupe_args(),
      "no-dupe-class-members": () => require_no_dupe_class_members(),
      "no-dupe-else-if": () => require_no_dupe_else_if(),
      "no-dupe-keys": () => require_no_dupe_keys(),
      "no-duplicate-case": () => require_no_duplicate_case(),
      "no-duplicate-imports": () => require_no_duplicate_imports(),
      "no-else-return": () => require_no_else_return(),
      "no-empty": () => require_no_empty(),
      "no-empty-character-class": () => require_no_empty_character_class(),
      "no-empty-function": () => require_no_empty_function(),
      "no-empty-pattern": () => require_no_empty_pattern(),
      "no-empty-static-block": () => require_no_empty_static_block(),
      "no-eq-null": () => require_no_eq_null(),
      "no-eval": () => require_no_eval(),
      "no-ex-assign": () => require_no_ex_assign(),
      "no-extend-native": () => require_no_extend_native(),
      "no-extra-bind": () => require_no_extra_bind(),
      "no-extra-boolean-cast": () => require_no_extra_boolean_cast(),
      "no-extra-label": () => require_no_extra_label(),
      "no-extra-parens": () => require_no_extra_parens(),
      "no-extra-semi": () => require_no_extra_semi(),
      "no-fallthrough": () => require_no_fallthrough(),
      "no-floating-decimal": () => require_no_floating_decimal(),
      "no-func-assign": () => require_no_func_assign(),
      "no-global-assign": () => require_no_global_assign(),
      "no-implicit-coercion": () => require_no_implicit_coercion(),
      "no-implicit-globals": () => require_no_implicit_globals(),
      "no-implied-eval": () => require_no_implied_eval(),
      "no-import-assign": () => require_no_import_assign(),
      "no-inline-comments": () => require_no_inline_comments(),
      "no-inner-declarations": () => require_no_inner_declarations(),
      "no-invalid-regexp": () => require_no_invalid_regexp(),
      "no-invalid-this": () => require_no_invalid_this(),
      "no-irregular-whitespace": () => require_no_irregular_whitespace(),
      "no-iterator": () => require_no_iterator(),
      "no-label-var": () => require_no_label_var(),
      "no-labels": () => require_no_labels(),
      "no-lone-blocks": () => require_no_lone_blocks(),
      "no-lonely-if": () => require_no_lonely_if(),
      "no-loop-func": () => require_no_loop_func(),
      "no-loss-of-precision": () => require_no_loss_of_precision(),
      "no-magic-numbers": () => require_no_magic_numbers(),
      "no-misleading-character-class": () => require_no_misleading_character_class(),
      "no-mixed-operators": () => require_no_mixed_operators(),
      "no-mixed-requires": () => require_no_mixed_requires(),
      "no-mixed-spaces-and-tabs": () => require_no_mixed_spaces_and_tabs(),
      "no-multi-assign": () => require_no_multi_assign(),
      "no-multi-spaces": () => require_no_multi_spaces(),
      "no-multi-str": () => require_no_multi_str(),
      "no-multiple-empty-lines": () => require_no_multiple_empty_lines(),
      "no-native-reassign": () => require_no_native_reassign(),
      "no-negated-condition": () => require_no_negated_condition(),
      "no-negated-in-lhs": () => require_no_negated_in_lhs(),
      "no-nested-ternary": () => require_no_nested_ternary(),
      "no-new": () => require_no_new(),
      "no-new-func": () => require_no_new_func(),
      "no-new-native-nonconstructor": () => require_no_new_native_nonconstructor(),
      "no-new-object": () => require_no_new_object(),
      "no-new-require": () => require_no_new_require(),
      "no-new-symbol": () => require_no_new_symbol(),
      "no-new-wrappers": () => require_no_new_wrappers(),
      "no-nonoctal-decimal-escape": () => require_no_nonoctal_decimal_escape(),
      "no-obj-calls": () => require_no_obj_calls(),
      "no-octal": () => require_no_octal(),
      "no-octal-escape": () => require_no_octal_escape(),
      "no-param-reassign": () => require_no_param_reassign(),
      "no-path-concat": () => require_no_path_concat(),
      "no-plusplus": () => require_no_plusplus(),
      "no-process-env": () => require_no_process_env(),
      "no-process-exit": () => require_no_process_exit(),
      "no-promise-executor-return": () => require_no_promise_executor_return(),
      "no-proto": () => require_no_proto(),
      "no-prototype-builtins": () => require_no_prototype_builtins(),
      "no-redeclare": () => require_no_redeclare(),
      "no-regex-spaces": () => require_no_regex_spaces(),
      "no-restricted-exports": () => require_no_restricted_exports(),
      "no-restricted-globals": () => require_no_restricted_globals(),
      "no-restricted-imports": () => require_no_restricted_imports(),
      "no-restricted-modules": () => require_no_restricted_modules(),
      "no-restricted-properties": () => require_no_restricted_properties(),
      "no-restricted-syntax": () => require_no_restricted_syntax(),
      "no-return-assign": () => require_no_return_assign(),
      "no-return-await": () => require_no_return_await(),
      "no-script-url": () => require_no_script_url(),
      "no-self-assign": () => require_no_self_assign(),
      "no-self-compare": () => require_no_self_compare(),
      "no-sequences": () => require_no_sequences(),
      "no-setter-return": () => require_no_setter_return(),
      "no-shadow": () => require_no_shadow(),
      "no-shadow-restricted-names": () => require_no_shadow_restricted_names(),
      "no-spaced-func": () => require_no_spaced_func(),
      "no-sparse-arrays": () => require_no_sparse_arrays(),
      "no-sync": () => require_no_sync(),
      "no-tabs": () => require_no_tabs(),
      "no-template-curly-in-string": () => require_no_template_curly_in_string(),
      "no-ternary": () => require_no_ternary(),
      "no-this-before-super": () => require_no_this_before_super(),
      "no-throw-literal": () => require_no_throw_literal(),
      "no-trailing-spaces": () => require_no_trailing_spaces(),
      "no-undef": () => require_no_undef(),
      "no-undef-init": () => require_no_undef_init(),
      "no-undefined": () => require_no_undefined(),
      "no-underscore-dangle": () => require_no_underscore_dangle(),
      "no-unexpected-multiline": () => require_no_unexpected_multiline(),
      "no-unmodified-loop-condition": () => require_no_unmodified_loop_condition(),
      "no-unneeded-ternary": () => require_no_unneeded_ternary(),
      "no-unreachable": () => require_no_unreachable(),
      "no-unreachable-loop": () => require_no_unreachable_loop(),
      "no-unsafe-finally": () => require_no_unsafe_finally(),
      "no-unsafe-negation": () => require_no_unsafe_negation(),
      "no-unsafe-optional-chaining": () => require_no_unsafe_optional_chaining(),
      "no-unused-expressions": () => require_no_unused_expressions(),
      "no-unused-labels": () => require_no_unused_labels(),
      "no-unused-private-class-members": () => require_no_unused_private_class_members(),
      "no-unused-vars": () => require_no_unused_vars(),
      "no-use-before-define": () => require_no_use_before_define(),
      "no-useless-backreference": () => require_no_useless_backreference(),
      "no-useless-call": () => require_no_useless_call(),
      "no-useless-catch": () => require_no_useless_catch(),
      "no-useless-computed-key": () => require_no_useless_computed_key(),
      "no-useless-concat": () => require_no_useless_concat(),
      "no-useless-constructor": () => require_no_useless_constructor(),
      "no-useless-escape": () => require_no_useless_escape(),
      "no-useless-rename": () => require_no_useless_rename(),
      "no-useless-return": () => require_no_useless_return(),
      "no-var": () => require_no_var(),
      "no-void": () => require_no_void(),
      "no-warning-comments": () => require_no_warning_comments(),
      "no-whitespace-before-property": () => require_no_whitespace_before_property(),
      "no-with": () => require_no_with(),
      "nonblock-statement-body-position": () => require_nonblock_statement_body_position(),
      "object-curly-newline": () => require_object_curly_newline(),
      "object-curly-spacing": () => require_object_curly_spacing(),
      "object-property-newline": () => require_object_property_newline(),
      "object-shorthand": () => require_object_shorthand(),
      "one-var": () => require_one_var(),
      "one-var-declaration-per-line": () => require_one_var_declaration_per_line(),
      "operator-assignment": () => require_operator_assignment(),
      "operator-linebreak": () => require_operator_linebreak(),
      "padded-blocks": () => require_padded_blocks(),
      "padding-line-between-statements": () => require_padding_line_between_statements(),
      "prefer-arrow-callback": () => require_prefer_arrow_callback(),
      "prefer-const": () => require_prefer_const(),
      "prefer-destructuring": () => require_prefer_destructuring(),
      "prefer-exponentiation-operator": () => require_prefer_exponentiation_operator(),
      "prefer-named-capture-group": () => require_prefer_named_capture_group(),
      "prefer-numeric-literals": () => require_prefer_numeric_literals(),
      "prefer-object-has-own": () => require_prefer_object_has_own(),
      "prefer-object-spread": () => require_prefer_object_spread(),
      "prefer-promise-reject-errors": () => require_prefer_promise_reject_errors(),
      "prefer-reflect": () => require_prefer_reflect(),
      "prefer-regex-literals": () => require_prefer_regex_literals(),
      "prefer-rest-params": () => require_prefer_rest_params(),
      "prefer-spread": () => require_prefer_spread(),
      "prefer-template": () => require_prefer_template(),
      "quote-props": () => require_quote_props(),
      quotes: () => require_quotes(),
      radix: () => require_radix(),
      "require-atomic-updates": () => require_require_atomic_updates(),
      "require-await": () => require_require_await(),
      "require-jsdoc": () => require_require_jsdoc(),
      "require-unicode-regexp": () => require_require_unicode_regexp(),
      "require-yield": () => require_require_yield(),
      "rest-spread-spacing": () => require_rest_spread_spacing(),
      semi: () => require_semi(),
      "semi-spacing": () => require_semi_spacing(),
      "semi-style": () => require_semi_style(),
      "sort-imports": () => require_sort_imports(),
      "sort-keys": () => require_sort_keys(),
      "sort-vars": () => require_sort_vars(),
      "space-before-blocks": () => require_space_before_blocks(),
      "space-before-function-paren": () => require_space_before_function_paren(),
      "space-in-parens": () => require_space_in_parens(),
      "space-infix-ops": () => require_space_infix_ops(),
      "space-unary-ops": () => require_space_unary_ops(),
      "spaced-comment": () => require_spaced_comment(),
      strict: () => require_strict(),
      "switch-colon-spacing": () => require_switch_colon_spacing(),
      "symbol-description": () => require_symbol_description(),
      "template-curly-spacing": () => require_template_curly_spacing(),
      "template-tag-spacing": () => require_template_tag_spacing(),
      "unicode-bom": () => require_unicode_bom(),
      "use-isnan": () => require_use_isnan(),
      "valid-jsdoc": () => require_valid_jsdoc(),
      "valid-typeof": () => require_valid_typeof(),
      "vars-on-top": () => require_vars_on_top(),
      "wrap-iife": () => require_wrap_iife(),
      "wrap-regex": () => require_wrap_regex(),
      "yield-star-spacing": () => require_yield_star_spacing(),
      yoda: () => require_yoda()
    }));
  }
});

// ../../node_modules/eslint/lib/linter/rules.js
var require_rules3 = __commonJS({
  "../../node_modules/eslint/lib/linter/rules.js"(exports, module) {
    "use strict";
    var builtInRules = require_rules2();
    function normalizeRule(rule) {
      return typeof rule === "function" ? Object.assign({ create: rule }, rule) : rule;
    }
    var Rules = class {
      constructor() {
        this._rules = /* @__PURE__ */ Object.create(null);
      }
      /**
       * Registers a rule module for rule id in storage.
       * @param {string} ruleId Rule id (file name).
       * @param {Function} ruleModule Rule handler.
       * @returns {void}
       */
      define(ruleId, ruleModule) {
        this._rules[ruleId] = normalizeRule(ruleModule);
      }
      /**
       * Access rule handler by id (file name).
       * @param {string} ruleId Rule id (file name).
       * @returns {{create: Function, schema: JsonSchema[]}}
       * A rule. This is normalized to always have the new-style shape with a `create` method.
       */
      get(ruleId) {
        if (typeof this._rules[ruleId] === "string") {
          this.define(ruleId, __require(this._rules[ruleId]));
        }
        if (this._rules[ruleId]) {
          return this._rules[ruleId];
        }
        if (builtInRules.has(ruleId)) {
          return builtInRules.get(ruleId);
        }
        return null;
      }
      *[Symbol.iterator]() {
        yield* builtInRules;
        for (const ruleId of Object.keys(this._rules)) {
          yield [ruleId, this.get(ruleId)];
        }
      }
    };
    module.exports = Rules;
  }
});

// ../../node_modules/eslint/lib/linter/safe-emitter.js
var require_safe_emitter = __commonJS({
  "../../node_modules/eslint/lib/linter/safe-emitter.js"(exports, module) {
    "use strict";
    module.exports = () => {
      const listeners = /* @__PURE__ */ Object.create(null);
      return Object.freeze({
        on(eventName, listener) {
          if (eventName in listeners) {
            listeners[eventName].push(listener);
          } else {
            listeners[eventName] = [listener];
          }
        },
        emit(eventName, ...args) {
          if (eventName in listeners) {
            listeners[eventName].forEach((listener) => listener(...args));
          }
        },
        eventNames() {
          return Object.keys(listeners);
        }
      });
    };
  }
});

// ../../node_modules/eslint/lib/linter/source-code-fixer.js
var require_source_code_fixer = __commonJS({
  "../../node_modules/eslint/lib/linter/source-code-fixer.js"(exports, module) {
    "use strict";
    var debug = require_browser()("eslint:source-code-fixer");
    var BOM = "\uFEFF";
    function compareMessagesByFixRange(a, b) {
      return a.fix.range[0] - b.fix.range[0] || a.fix.range[1] - b.fix.range[1];
    }
    function compareMessagesByLocation(a, b) {
      return a.line - b.line || a.column - b.column;
    }
    function SourceCodeFixer() {
      Object.freeze(this);
    }
    SourceCodeFixer.applyFixes = function(sourceText, messages, shouldFix) {
      debug("Applying fixes");
      if (shouldFix === false) {
        debug("shouldFix parameter was false, not attempting fixes");
        return {
          fixed: false,
          messages,
          output: sourceText
        };
      }
      const remainingMessages = [], fixes = [], bom = sourceText.startsWith(BOM) ? BOM : "", text = bom ? sourceText.slice(1) : sourceText;
      let lastPos = Number.NEGATIVE_INFINITY, output = bom;
      function attemptFix(problem) {
        const fix = problem.fix;
        const start = fix.range[0];
        const end = fix.range[1];
        if (lastPos >= start || start > end) {
          remainingMessages.push(problem);
          return false;
        }
        if (start < 0 && end >= 0 || start === 0 && fix.text.startsWith(BOM)) {
          output = "";
        }
        output += text.slice(Math.max(0, lastPos), Math.max(0, start));
        output += fix.text;
        lastPos = end;
        return true;
      }
      messages.forEach((problem) => {
        if (Object.prototype.hasOwnProperty.call(problem, "fix")) {
          fixes.push(problem);
        } else {
          remainingMessages.push(problem);
        }
      });
      if (fixes.length) {
        debug("Found fixes to apply");
        let fixesWereApplied = false;
        for (const problem of fixes.sort(compareMessagesByFixRange)) {
          if (typeof shouldFix !== "function" || shouldFix(problem)) {
            attemptFix(problem);
            fixesWereApplied = true;
          } else {
            remainingMessages.push(problem);
          }
        }
        output += text.slice(Math.max(0, lastPos));
        return {
          fixed: fixesWereApplied,
          messages: remainingMessages.sort(compareMessagesByLocation),
          output
        };
      }
      debug("No fixes to apply");
      return {
        fixed: false,
        messages,
        output: bom + text
      };
    };
    module.exports = SourceCodeFixer;
  }
});

// ../../node_modules/eslint/lib/linter/timing.js
var require_timing = __commonJS({
  "../../node_modules/eslint/lib/linter/timing.js"(exports, module) {
    "use strict";
    function alignLeft(str, len, ch) {
      return str + new Array(len - str.length + 1).join(ch || " ");
    }
    function alignRight(str, len, ch) {
      return new Array(len - str.length + 1).join(ch || " ") + str;
    }
    var enabled = !!process.env.TIMING;
    var HEADERS = ["Rule", "Time (ms)", "Relative"];
    var ALIGN = [alignLeft, alignRight, alignRight];
    function getListSize() {
      const MINIMUM_SIZE = 10;
      if (typeof process.env.TIMING !== "string") {
        return MINIMUM_SIZE;
      }
      if (process.env.TIMING.toLowerCase() === "all") {
        return Number.POSITIVE_INFINITY;
      }
      const TIMING_ENV_VAR_AS_INTEGER = Number.parseInt(process.env.TIMING, 10);
      return TIMING_ENV_VAR_AS_INTEGER > 10 ? TIMING_ENV_VAR_AS_INTEGER : MINIMUM_SIZE;
    }
    function display(data) {
      let total = 0;
      const rows = Object.keys(data).map((key) => {
        const time = data[key];
        total += time;
        return [key, time];
      }).sort((a, b) => b[1] - a[1]).slice(0, getListSize());
      rows.forEach((row) => {
        row.push(`${(row[1] * 100 / total).toFixed(1)}%`);
        row[1] = row[1].toFixed(3);
      });
      rows.unshift(HEADERS);
      const widths = [];
      rows.forEach((row) => {
        const len = row.length;
        for (let i = 0; i < len; i++) {
          const n = row[i].length;
          if (!widths[i] || n > widths[i]) {
            widths[i] = n;
          }
        }
      });
      const table = rows.map((row) => row.map((cell, index) => ALIGN[index](cell, widths[index])).join(" | "));
      table.splice(1, 0, widths.map((width, index) => {
        const extraAlignment = index !== 0 && index !== widths.length - 1 ? 2 : 1;
        return ALIGN[index](":", width + extraAlignment, "-");
      }).join("|"));
      console.log(table.join("\n"));
    }
    module.exports = function() {
      const data = /* @__PURE__ */ Object.create(null);
      function time(key, fn) {
        if (typeof data[key] === "undefined") {
          data[key] = 0;
        }
        return function(...args) {
          let t = process.hrtime();
          const result = fn(...args);
          t = process.hrtime(t);
          data[key] += t[0] * 1e3 + t[1] / 1e6;
          return result;
        };
      }
      if (enabled) {
        process.on("exit", () => {
          display(data);
        });
      }
      return {
        time,
        enabled,
        getListSize
      };
    }();
  }
});

// ../../node_modules/eslint/conf/replacements.json
var require_replacements = __commonJS({
  "../../node_modules/eslint/conf/replacements.json"(exports, module) {
    module.exports = {
      rules: {
        "generator-star": ["generator-star-spacing"],
        "global-strict": ["strict"],
        "no-arrow-condition": ["no-confusing-arrow", "no-constant-condition"],
        "no-comma-dangle": ["comma-dangle"],
        "no-empty-class": ["no-empty-character-class"],
        "no-empty-label": ["no-labels"],
        "no-extra-strict": ["strict"],
        "no-reserved-keys": ["quote-props"],
        "no-space-before-semi": ["semi-spacing"],
        "no-wrap-func": ["no-extra-parens"],
        "space-after-function-name": ["space-before-function-paren"],
        "space-after-keywords": ["keyword-spacing"],
        "space-before-function-parentheses": ["space-before-function-paren"],
        "space-before-keywords": ["keyword-spacing"],
        "space-in-brackets": ["object-curly-spacing", "array-bracket-spacing", "computed-property-spacing"],
        "space-return-throw-case": ["keyword-spacing"],
        "space-unary-word-ops": ["space-unary-ops"],
        "spaced-line-comment": ["spaced-comment"]
      }
    };
  }
});

// ../../node_modules/eslint/lib/config/flat-config-helpers.js
var require_flat_config_helpers = __commonJS({
  "../../node_modules/eslint/lib/config/flat-config-helpers.js"(exports, module) {
    "use strict";
    function parseRuleId(ruleId) {
      let pluginName, ruleName;
      if (ruleId.includes("/")) {
        if (ruleId.startsWith("@")) {
          pluginName = ruleId.slice(0, ruleId.lastIndexOf("/"));
        } else {
          pluginName = ruleId.slice(0, ruleId.indexOf("/"));
        }
        ruleName = ruleId.slice(pluginName.length + 1);
      } else {
        pluginName = "@";
        ruleName = ruleId;
      }
      return {
        pluginName,
        ruleName
      };
    }
    function getRuleFromConfig(ruleId, config) {
      const { pluginName, ruleName } = parseRuleId(ruleId);
      const plugin = config.plugins && config.plugins[pluginName];
      let rule = plugin && plugin.rules && plugin.rules[ruleName];
      if (rule && typeof rule === "function") {
        rule = {
          create: rule
        };
      }
      return rule;
    }
    function getRuleOptionsSchema(rule) {
      if (!rule) {
        return null;
      }
      const schema = rule.schema || rule.meta && rule.meta.schema;
      if (Array.isArray(schema)) {
        if (schema.length) {
          return {
            type: "array",
            items: schema,
            minItems: 0,
            maxItems: schema.length
          };
        }
        return {
          type: "array",
          minItems: 0,
          maxItems: 0
        };
      }
      return schema || null;
    }
    module.exports = {
      parseRuleId,
      getRuleFromConfig,
      getRuleOptionsSchema
    };
  }
});

// ../../node_modules/concat-map/index.js
var require_concat_map = __commonJS({
  "../../node_modules/concat-map/index.js"(exports, module) {
    module.exports = function(xs, fn) {
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x))
          res.push.apply(res, x);
        else
          res.push(x);
      }
      return res;
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
  }
});

// ../../node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "../../node_modules/balanced-match/index.js"(exports, module) {
    "use strict";
    module.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp)
        a = maybeMatch(a, str);
      if (b instanceof RegExp)
        b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// ../../node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "../../node_modules/brace-expansion/index.js"(exports, module) {
    var concatMap = require_concat_map();
    var balanced = require_balanced_match();
    module.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m || /\$$/.test(m.pre))
        return [str];
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m.post.match(/,.*\}/)) {
          str = m.pre + "{" + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            var post = m.post.length ? expand(m.post, false) : [""];
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      var N;
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n.some(isPadded);
        N = [];
        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === "\\")
              c = "";
          } else {
            c = String(i);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                if (i < 0)
                  c = "-" + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap(n, function(el) {
          return expand(el, false);
        });
      }
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
      return expansions;
    }
  }
});

// ../../node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
  "../../node_modules/minimatch/minimatch.js"(exports, module) {
    module.exports = minimatch;
    minimatch.Minimatch = Minimatch;
    var path = function() {
      try {
        return require_path_browserify();
      } catch (e) {
      }
    }() || {
      sep: "/"
    };
    minimatch.sep = path.sep;
    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
    var expand = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s) {
      return s.split("").reduce(function(set, c) {
        set[c] = true;
        return set;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch.filter = filter;
    function filter(pattern, options) {
      options = options || {};
      return function(p, i, list) {
        return minimatch(p, pattern, options);
      };
    }
    function ext(a, b) {
      b = b || {};
      var t = {};
      Object.keys(a).forEach(function(k) {
        t[k] = a[k];
      });
      Object.keys(b).forEach(function(k) {
        t[k] = b[k];
      });
      return t;
    }
    minimatch.defaults = function(def) {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch;
      }
      var orig = minimatch;
      var m = function minimatch2(p, pattern, options) {
        return orig(p, pattern, ext(def, options));
      };
      m.Minimatch = function Minimatch2(pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options));
      };
      m.Minimatch.defaults = function defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      };
      m.filter = function filter2(pattern, options) {
        return orig.filter(pattern, ext(def, options));
      };
      m.defaults = function defaults(options) {
        return orig.defaults(ext(def, options));
      };
      m.makeRe = function makeRe2(pattern, options) {
        return orig.makeRe(pattern, ext(def, options));
      };
      m.braceExpand = function braceExpand2(pattern, options) {
        return orig.braceExpand(pattern, ext(def, options));
      };
      m.match = function(list, pattern, options) {
        return orig.match(list, pattern, ext(def, options));
      };
      return m;
    };
    Minimatch.defaults = function(def) {
      return minimatch.defaults(def).Minimatch;
    };
    function minimatch(p, pattern, options) {
      assertValidPattern(pattern);
      if (!options)
        options = {};
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern, options).match(p);
    }
    function Minimatch(pattern, options) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options);
      }
      assertValidPattern(pattern);
      if (!options)
        options = {};
      pattern = pattern.trim();
      if (!options.allowWindowsEscape && path.sep !== "/") {
        pattern = pattern.split(path.sep).join("/");
      }
      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.partial = !!options.partial;
      this.make();
    }
    Minimatch.prototype.debug = function() {
    };
    Minimatch.prototype.make = make;
    function make() {
      var pattern = this.pattern;
      var options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set = this.globSet = this.braceExpand();
      if (options.debug)
        this.debug = function debug() {
          console.error.apply(console, arguments);
        };
      this.debug(this.pattern, set);
      set = this.globParts = set.map(function(s) {
        return s.split(slashSplit);
      });
      this.debug(this.pattern, set);
      set = set.map(function(s, si, set2) {
        return s.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set);
      set = set.filter(function(s) {
        return s.indexOf(false) === -1;
      });
      this.debug(this.pattern, set);
      this.set = set;
    }
    Minimatch.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern;
      var negate = false;
      var options = this.options;
      var negateOffset = 0;
      if (options.nonegate)
        return;
      for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.substr(negateOffset);
      this.negate = negate;
    }
    minimatch.braceExpand = function(pattern, options) {
      return braceExpand(pattern, options);
    };
    Minimatch.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options) {
      if (!options) {
        if (this instanceof Minimatch) {
          options = this.options;
        } else {
          options = {};
        }
      }
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      assertValidPattern(pattern);
      if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return expand(pattern);
    }
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = function(pattern) {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    Minimatch.prototype.parse = parse;
    var SUBPARSE = {};
    function parse(pattern, isSub) {
      assertValidPattern(pattern);
      var options = this.options;
      if (pattern === "**") {
        if (!options.noglobstar)
          return GLOBSTAR;
        else
          pattern = "*";
      }
      if (pattern === "")
        return "";
      var re = "";
      var hasMagic = !!options.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self2 = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          self2.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      }
      for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
        this.debug("%s	%s %s %j", pattern, i, re, c);
        if (escaping && reSpecials[c]) {
          re += "\\" + c;
          escaping = false;
          continue;
        }
        switch (c) {
          case "/": {
            return false;
          }
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i === classStart + 1)
                c = "^";
              re += c;
              continue;
            }
            self2.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options.noext)
              clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            patternListStack.push({
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            });
            re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic = true;
            var pl = patternListStack.pop();
            re += pl.close;
            if (pl.type === "!") {
              negativeLists.push(pl);
            }
            pl.reEnd = re.length;
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re += "|";
            continue;
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re.length;
            re += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c;
              escaping = false;
              continue;
            }
            var cs = pattern.substring(classStart + 1, i);
            try {
              RegExp("[" + cs + "]");
            } catch (er) {
              var sp = this.parse(cs, SUBPARSE);
              re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
              hasMagic = hasMagic || sp[1];
              inClass = false;
              continue;
            }
            hasMagic = true;
            inClass = false;
            re += c;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials[c] && !(c === "^" && inClass)) {
              re += "\\";
            }
            re += c;
        }
      }
      if (inClass) {
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re);
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      var addPatternStart = false;
      switch (re.charAt(0)) {
        case "[":
        case ".":
        case "(":
          addPatternStart = true;
      }
      for (var n = negativeLists.length - 1; n > -1; n--) {
        var nl = negativeLists[n];
        var nlBefore = re.slice(0, nl.reStart);
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re = newRe;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      var flags = options.nocase ? "i" : "";
      try {
        var regExp = new RegExp("^" + re + "$", flags);
      } catch (er) {
        return new RegExp("$.");
      }
      regExp._glob = pattern;
      regExp._src = re;
      return regExp;
    }
    minimatch.makeRe = function(pattern, options) {
      return new Minimatch(pattern, options || {}).makeRe();
    };
    Minimatch.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      var set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options = this.options;
      var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
      var flags = options.nocase ? "i" : "";
      var re = set.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate)
        re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch.match = function(list, pattern, options) {
      options = options || {};
      var mm = new Minimatch(pattern, options);
      list = list.filter(function(f) {
        return mm.match(f);
      });
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    Minimatch.prototype.match = function match(f, partial) {
      if (typeof partial === "undefined")
        partial = this.partial;
      this.debug("match", f, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f === "";
      if (f === "/" && partial)
        return true;
      var options = this.options;
      if (path.sep !== "/") {
        f = f.split(path.sep).join("/");
      }
      f = f.split(slashSplit);
      this.debug(this.pattern, "split", f);
      var set = this.set;
      this.debug(this.pattern, "set", set);
      var filename;
      var i;
      for (i = f.length - 1; i >= 0; i--) {
        filename = f[i];
        if (filename)
          break;
      }
      for (i = 0; i < set.length; i++) {
        var pattern = set[i];
        var file = f;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        var hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options.flipNegate)
        return false;
      return this.negate;
    };
    Minimatch.prototype.matchOne = function(file, pattern, partial) {
      var options = this.options;
      this.debug(
        "matchOne",
        { "this": this, file, pattern }
      );
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false)
          return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          hit = f === p;
          this.debug("string match", p, f, hit);
        } else {
          hit = f.match(p);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        return fi === fl - 1 && file[fi] === "";
      }
      throw new Error("wtf?");
    };
    function globUnescape(s) {
      return s.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
});

// ../../node_modules/@humanwhocodes/object-schema/src/merge-strategy.js
var require_merge_strategy = __commonJS({
  "../../node_modules/@humanwhocodes/object-schema/src/merge-strategy.js"(exports) {
    "use strict";
    var MergeStrategy = class {
      /**
       * Merges two keys by overwriting the first with the second.
       * @param {*} value1 The value from the first object key. 
       * @param {*} value2 The value from the second object key.
       * @returns {*} The second value.
       */
      static overwrite(value1, value2) {
        return value2;
      }
      /**
       * Merges two keys by replacing the first with the second only if the
       * second is defined.
       * @param {*} value1 The value from the first object key. 
       * @param {*} value2 The value from the second object key.
       * @returns {*} The second value if it is defined.
       */
      static replace(value1, value2) {
        if (typeof value2 !== "undefined") {
          return value2;
        }
        return value1;
      }
      /**
       * Merges two properties by assigning properties from the second to the first.
       * @param {*} value1 The value from the first object key.
       * @param {*} value2 The value from the second object key.
       * @returns {*} A new object containing properties from both value1 and
       *      value2.
       */
      static assign(value1, value2) {
        return Object.assign({}, value1, value2);
      }
    };
    exports.MergeStrategy = MergeStrategy;
  }
});

// ../../node_modules/@humanwhocodes/object-schema/src/validation-strategy.js
var require_validation_strategy = __commonJS({
  "../../node_modules/@humanwhocodes/object-schema/src/validation-strategy.js"(exports) {
    "use strict";
    var ValidationStrategy = class {
      /**
       * Validates that a value is an array.
       * @param {*} value The value to validate.
       * @returns {void}
       * @throws {TypeError} If the value is invalid. 
       */
      static array(value) {
        if (!Array.isArray(value)) {
          throw new TypeError("Expected an array.");
        }
      }
      /**
       * Validates that a value is a boolean.
       * @param {*} value The value to validate.
       * @returns {void}
       * @throws {TypeError} If the value is invalid. 
       */
      static boolean(value) {
        if (typeof value !== "boolean") {
          throw new TypeError("Expected a Boolean.");
        }
      }
      /**
       * Validates that a value is a number.
       * @param {*} value The value to validate.
       * @returns {void}
       * @throws {TypeError} If the value is invalid. 
       */
      static number(value) {
        if (typeof value !== "number") {
          throw new TypeError("Expected a number.");
        }
      }
      /**
       * Validates that a value is a object.
       * @param {*} value The value to validate.
       * @returns {void}
       * @throws {TypeError} If the value is invalid. 
       */
      static object(value) {
        if (!value || typeof value !== "object") {
          throw new TypeError("Expected an object.");
        }
      }
      /**
       * Validates that a value is a object or null.
       * @param {*} value The value to validate.
       * @returns {void}
       * @throws {TypeError} If the value is invalid. 
       */
      static "object?"(value) {
        if (typeof value !== "object") {
          throw new TypeError("Expected an object or null.");
        }
      }
      /**
       * Validates that a value is a string.
       * @param {*} value The value to validate.
       * @returns {void}
       * @throws {TypeError} If the value is invalid. 
       */
      static string(value) {
        if (typeof value !== "string") {
          throw new TypeError("Expected a string.");
        }
      }
      /**
       * Validates that a value is a non-empty string.
       * @param {*} value The value to validate.
       * @returns {void}
       * @throws {TypeError} If the value is invalid. 
       */
      static "string!"(value) {
        if (typeof value !== "string" || value.length === 0) {
          throw new TypeError("Expected a non-empty string.");
        }
      }
    };
    exports.ValidationStrategy = ValidationStrategy;
  }
});

// ../../node_modules/@humanwhocodes/object-schema/src/object-schema.js
var require_object_schema = __commonJS({
  "../../node_modules/@humanwhocodes/object-schema/src/object-schema.js"(exports) {
    "use strict";
    var { MergeStrategy } = require_merge_strategy();
    var { ValidationStrategy } = require_validation_strategy();
    var strategies = Symbol("strategies");
    var requiredKeys = Symbol("requiredKeys");
    function validateDefinition(name, strategy) {
      let hasSchema = false;
      if (strategy.schema) {
        if (typeof strategy.schema === "object") {
          hasSchema = true;
        } else {
          throw new TypeError("Schema must be an object.");
        }
      }
      if (typeof strategy.merge === "string") {
        if (!(strategy.merge in MergeStrategy)) {
          throw new TypeError(`Definition for key "${name}" missing valid merge strategy.`);
        }
      } else if (!hasSchema && typeof strategy.merge !== "function") {
        throw new TypeError(`Definition for key "${name}" must have a merge property.`);
      }
      if (typeof strategy.validate === "string") {
        if (!(strategy.validate in ValidationStrategy)) {
          throw new TypeError(`Definition for key "${name}" missing valid validation strategy.`);
        }
      } else if (!hasSchema && typeof strategy.validate !== "function") {
        throw new TypeError(`Definition for key "${name}" must have a validate() method.`);
      }
    }
    var ObjectSchema = class {
      /**
       * Creates a new instance.
       */
      constructor(definitions) {
        if (!definitions) {
          throw new Error("Schema definitions missing.");
        }
        this[strategies] = /* @__PURE__ */ new Map();
        this[requiredKeys] = /* @__PURE__ */ new Map();
        for (const key of Object.keys(definitions)) {
          validateDefinition(key, definitions[key]);
          if (typeof definitions[key].schema === "object") {
            const schema = new ObjectSchema(definitions[key].schema);
            definitions[key] = {
              ...definitions[key],
              merge(first = {}, second = {}) {
                return schema.merge(first, second);
              },
              validate(value) {
                ValidationStrategy.object(value);
                schema.validate(value);
              }
            };
          }
          if (typeof definitions[key].merge === "string") {
            definitions[key] = {
              ...definitions[key],
              merge: MergeStrategy[definitions[key].merge]
            };
          }
          ;
          if (typeof definitions[key].validate === "string") {
            definitions[key] = {
              ...definitions[key],
              validate: ValidationStrategy[definitions[key].validate]
            };
          }
          ;
          this[strategies].set(key, definitions[key]);
          if (definitions[key].required) {
            this[requiredKeys].set(key, definitions[key]);
          }
        }
      }
      /**
       * Determines if a strategy has been registered for the given object key.
       * @param {string} key The object key to find a strategy for.
       * @returns {boolean} True if the key has a strategy registered, false if not. 
       */
      hasKey(key) {
        return this[strategies].has(key);
      }
      /**
       * Merges objects together to create a new object comprised of the keys
       * of the all objects. Keys are merged based on the each key's merge
       * strategy.
       * @param {...Object} objects The objects to merge.
       * @returns {Object} A new object with a mix of all objects' keys.
       * @throws {Error} If any object is invalid.
       */
      merge(...objects) {
        if (objects.length < 2) {
          throw new Error("merge() requires at least two arguments.");
        }
        if (objects.some((object) => object == null || typeof object !== "object")) {
          throw new Error("All arguments must be objects.");
        }
        return objects.reduce((result, object) => {
          this.validate(object);
          for (const [key, strategy] of this[strategies]) {
            try {
              if (key in result || key in object) {
                const value = strategy.merge.call(this, result[key], object[key]);
                if (value !== void 0) {
                  result[key] = value;
                }
              }
            } catch (ex) {
              ex.message = `Key "${key}": ` + ex.message;
              throw ex;
            }
          }
          return result;
        }, {});
      }
      /**
       * Validates an object's keys based on the validate strategy for each key.
       * @param {Object} object The object to validate.
       * @returns {void}
       * @throws {Error} When the object is invalid. 
       */
      validate(object) {
        for (const key of Object.keys(object)) {
          if (!this.hasKey(key)) {
            throw new Error(`Unexpected key "${key}" found.`);
          }
          const strategy = this[strategies].get(key);
          if (Array.isArray(strategy.requires)) {
            if (!strategy.requires.every((otherKey) => otherKey in object)) {
              throw new Error(`Key "${key}" requires keys "${strategy.requires.join('", "')}".`);
            }
          }
          try {
            strategy.validate.call(strategy, object[key]);
          } catch (ex) {
            ex.message = `Key "${key}": ` + ex.message;
            throw ex;
          }
        }
        for (const [key] of this[requiredKeys]) {
          if (!(key in object)) {
            throw new Error(`Missing required key "${key}".`);
          }
        }
      }
    };
    exports.ObjectSchema = ObjectSchema;
  }
});

// ../../node_modules/@humanwhocodes/object-schema/src/index.js
var require_src2 = __commonJS({
  "../../node_modules/@humanwhocodes/object-schema/src/index.js"(exports) {
    exports.ObjectSchema = require_object_schema().ObjectSchema;
    exports.MergeStrategy = require_merge_strategy().MergeStrategy;
    exports.ValidationStrategy = require_validation_strategy().ValidationStrategy;
  }
});

// ../../node_modules/@humanwhocodes/config-array/api.js
var require_api = __commonJS({
  "../../node_modules/@humanwhocodes/config-array/api.js"(exports) {
    "use strict";
    var path = require_path_browserify();
    var minimatch = require_minimatch();
    var createDebug = require_browser();
    var objectSchema = require_src2();
    function assertIsArray(value) {
      if (!Array.isArray(value)) {
        throw new TypeError("Expected value to be an array.");
      }
    }
    function assertIsArrayOfStringsAndFunctions(value, name) {
      assertIsArray(value);
      if (value.some((item) => typeof item !== "string" && typeof item !== "function")) {
        throw new TypeError("Expected array to only contain strings.");
      }
    }
    var baseSchema = Object.freeze({
      name: {
        required: false,
        merge() {
          return void 0;
        },
        validate(value) {
          if (typeof value !== "string") {
            throw new TypeError("Property must be a string.");
          }
        }
      },
      files: {
        required: false,
        merge() {
          return void 0;
        },
        validate(value) {
          assertIsArray(value);
          value.forEach((item) => {
            if (Array.isArray(item)) {
              assertIsArrayOfStringsAndFunctions(item);
            } else if (typeof item !== "string" && typeof item !== "function") {
              throw new TypeError("Items must be a string, a function, or an array of strings and functions.");
            }
          });
        }
      },
      ignores: {
        required: false,
        merge() {
          return void 0;
        },
        validate: assertIsArrayOfStringsAndFunctions
      }
    });
    var Minimatch = minimatch.Minimatch;
    var minimatchCache = /* @__PURE__ */ new Map();
    var negatedMinimatchCache = /* @__PURE__ */ new Map();
    var debug = createDebug("@hwc/config-array");
    var MINIMATCH_OPTIONS = {
      // matchBase: true,
      dot: true
    };
    var CONFIG_TYPES = /* @__PURE__ */ new Set(["array", "function"]);
    function isString(value) {
      return typeof value === "string";
    }
    function assertNonEmptyFilesArray(config) {
      if (!Array.isArray(config.files) || config.files.length === 0) {
        throw new TypeError("The files key must be a non-empty array.");
      }
    }
    function doMatch(filepath, pattern, options = {}) {
      let cache = minimatchCache;
      if (options.flipNegate) {
        cache = negatedMinimatchCache;
      }
      let matcher = cache.get(pattern);
      if (!matcher) {
        matcher = new Minimatch(pattern, Object.assign({}, MINIMATCH_OPTIONS, options));
        cache.set(pattern, matcher);
      }
      return matcher.match(filepath);
    }
    async function normalize(items, context, extraConfigTypes) {
      const allowFunctions = extraConfigTypes.includes("function");
      const allowArrays = extraConfigTypes.includes("array");
      async function* flatTraverse(array) {
        for (let item of array) {
          if (typeof item === "function") {
            if (!allowFunctions) {
              throw new TypeError("Unexpected function.");
            }
            item = item(context);
            if (item.then) {
              item = await item;
            }
          }
          if (Array.isArray(item)) {
            if (!allowArrays) {
              throw new TypeError("Unexpected array.");
            }
            yield* flatTraverse(item);
          } else if (typeof item === "function") {
            throw new TypeError("A config function can only return an object or array.");
          } else {
            yield item;
          }
        }
      }
      const asyncIterable = await flatTraverse(items);
      const configs = [];
      for await (const config of asyncIterable) {
        configs.push(config);
      }
      return configs;
    }
    function normalizeSync(items, context, extraConfigTypes) {
      const allowFunctions = extraConfigTypes.includes("function");
      const allowArrays = extraConfigTypes.includes("array");
      function* flatTraverse(array) {
        for (let item of array) {
          if (typeof item === "function") {
            if (!allowFunctions) {
              throw new TypeError("Unexpected function.");
            }
            item = item(context);
            if (item.then) {
              throw new TypeError("Async config functions are not supported.");
            }
          }
          if (Array.isArray(item)) {
            if (!allowArrays) {
              throw new TypeError("Unexpected array.");
            }
            yield* flatTraverse(item);
          } else if (typeof item === "function") {
            throw new TypeError("A config function can only return an object or array.");
          } else {
            yield item;
          }
        }
      }
      return [...flatTraverse(items)];
    }
    function shouldIgnorePath(ignores, filePath, relativeFilePath) {
      if (relativeFilePath.startsWith("..")) {
        return true;
      }
      return ignores.reduce((ignored, matcher) => {
        if (!ignored) {
          if (typeof matcher === "function") {
            return matcher(filePath);
          }
          if (!matcher.startsWith("!")) {
            return doMatch(relativeFilePath, matcher);
          }
          return false;
        }
        if (typeof matcher === "string" && matcher.startsWith("!")) {
          return !doMatch(relativeFilePath, matcher, {
            flipNegate: true
          });
        }
        return ignored;
      }, false);
    }
    function pathMatchesIgnores(filePath, basePath, config) {
      const relativeFilePath = path.relative(basePath, filePath);
      return Object.keys(config).length > 1 && !shouldIgnorePath(config.ignores, filePath, relativeFilePath);
    }
    function pathMatches(filePath, basePath, config) {
      const relativeFilePath = path.relative(basePath, filePath);
      assertNonEmptyFilesArray(config);
      const match = (pattern) => {
        if (isString(pattern)) {
          return doMatch(relativeFilePath, pattern);
        }
        if (typeof pattern === "function") {
          return pattern(filePath);
        }
        throw new TypeError(`Unexpected matcher type ${pattern}.`);
      };
      let filePathMatchesPattern = config.files.some((pattern) => {
        if (Array.isArray(pattern)) {
          return pattern.every(match);
        }
        return match(pattern);
      });
      if (filePathMatchesPattern && config.ignores) {
        filePathMatchesPattern = !shouldIgnorePath(config.ignores, filePath, relativeFilePath);
      }
      return filePathMatchesPattern;
    }
    function assertNormalized(configArray) {
      if (!configArray.isNormalized()) {
        throw new Error("ConfigArray must be normalized to perform this operation.");
      }
    }
    function assertExtraConfigTypes(extraConfigTypes) {
      if (extraConfigTypes.length > 2) {
        throw new TypeError("configTypes must be an array with at most two items.");
      }
      for (const configType of extraConfigTypes) {
        if (!CONFIG_TYPES.has(configType)) {
          throw new TypeError(`Unexpected config type "${configType}" found. Expected one of: "object", "array", "function".`);
        }
      }
    }
    var ConfigArraySymbol = {
      isNormalized: Symbol("isNormalized"),
      configCache: Symbol("configCache"),
      schema: Symbol("schema"),
      finalizeConfig: Symbol("finalizeConfig"),
      preprocessConfig: Symbol("preprocessConfig")
    };
    var dataCache = /* @__PURE__ */ new WeakMap();
    var ConfigArray = class extends Array {
      /**
       * Creates a new instance of ConfigArray.
       * @param {Iterable|Function|Object} configs An iterable yielding config
       *      objects, or a config function, or a config object.
       * @param {string} [options.basePath=""] The path of the config file
       * @param {boolean} [options.normalized=false] Flag indicating if the
       *      configs have already been normalized.
       * @param {Object} [options.schema] The additional schema 
       *      definitions to use for the ConfigArray schema.
       * @param {Array<string>} [options.configTypes] List of config types supported.
       */
      constructor(configs, {
        basePath = "",
        normalized = false,
        schema: customSchema,
        extraConfigTypes = []
      } = {}) {
        super();
        this[ConfigArraySymbol.isNormalized] = normalized;
        this[ConfigArraySymbol.schema] = new objectSchema.ObjectSchema(
          Object.assign({}, customSchema, baseSchema)
        );
        this.basePath = basePath;
        assertExtraConfigTypes(extraConfigTypes);
        this.extraConfigTypes = Object.freeze([...extraConfigTypes]);
        this[ConfigArraySymbol.configCache] = /* @__PURE__ */ new Map();
        dataCache.set(this, {
          explicitMatches: /* @__PURE__ */ new Map(),
          directoryMatches: /* @__PURE__ */ new Map(),
          files: void 0,
          ignores: void 0
        });
        if (Array.isArray(configs)) {
          this.push(...configs);
        } else {
          this.push(configs);
        }
      }
      /**
       * Prevent normal array methods from creating a new `ConfigArray` instance.
       * This is to ensure that methods such as `slice()` won't try to create a 
       * new instance of `ConfigArray` behind the scenes as doing so may throw
       * an error due to the different constructor signature.
       * @returns {Function} The `Array` constructor.
       */
      static get [Symbol.species]() {
        return Array;
      }
      /**
       * Returns the `files` globs from every config object in the array.
       * This can be used to determine which files will be matched by a
       * config array or to use as a glob pattern when no patterns are provided
       * for a command line interface.
       * @returns {Array<string|Function>} An array of matchers.
       */
      get files() {
        assertNormalized(this);
        const cache = dataCache.get(this);
        if (cache.files) {
          return cache.files;
        }
        const result = [];
        for (const config of this) {
          if (config.files) {
            config.files.forEach((filePattern) => {
              result.push(filePattern);
            });
          }
        }
        cache.files = result;
        dataCache.set(this, cache);
        return result;
      }
      /**
       * Returns ignore matchers that should always be ignored regardless of
       * the matching `files` fields in any configs. This is necessary to mimic
       * the behavior of things like .gitignore and .eslintignore, allowing a
       * globbing operation to be faster.
       * @returns {string[]} An array of string patterns and functions to be ignored.
       */
      get ignores() {
        assertNormalized(this);
        const cache = dataCache.get(this);
        if (cache.ignores) {
          return cache.ignores;
        }
        const result = [];
        for (const config of this) {
          if (config.ignores && Object.keys(config).length === 1) {
            config.ignores.forEach((ignore) => {
              result.push(ignore);
              if (typeof ignore === "string") {
                if (ignore.startsWith("!")) {
                  if (ignore.endsWith("/**")) {
                    result.push(ignore.slice(0, ignore.length - 3));
                  } else if (ignore.endsWith("/*")) {
                    result.push(ignore.slice(0, ignore.length - 2));
                  }
                }
                if (ignore.endsWith("/")) {
                  result.push(ignore.slice(0, ignore.length - 1));
                  result.push(ignore + "**");
                } else if (!ignore.endsWith("*")) {
                  result.push(ignore + "/**");
                }
              }
            });
          }
        }
        cache.ignores = result;
        dataCache.set(this, cache);
        return result;
      }
      /**
       * Indicates if the config array has been normalized.
       * @returns {boolean} True if the config array is normalized, false if not.
       */
      isNormalized() {
        return this[ConfigArraySymbol.isNormalized];
      }
      /**
       * Normalizes a config array by flattening embedded arrays and executing
       * config functions.
       * @param {ConfigContext} context The context object for config functions.
       * @returns {Promise<ConfigArray>} The current ConfigArray instance.
       */
      async normalize(context = {}) {
        if (!this.isNormalized()) {
          const normalizedConfigs = await normalize(this, context, this.extraConfigTypes);
          this.length = 0;
          this.push(...normalizedConfigs.map(this[ConfigArraySymbol.preprocessConfig].bind(this)));
          this[ConfigArraySymbol.isNormalized] = true;
          Object.freeze(this);
        }
        return this;
      }
      /**
       * Normalizes a config array by flattening embedded arrays and executing
       * config functions.
       * @param {ConfigContext} context The context object for config functions.
       * @returns {ConfigArray} The current ConfigArray instance.
       */
      normalizeSync(context = {}) {
        if (!this.isNormalized()) {
          const normalizedConfigs = normalizeSync(this, context, this.extraConfigTypes);
          this.length = 0;
          this.push(...normalizedConfigs.map(this[ConfigArraySymbol.preprocessConfig].bind(this)));
          this[ConfigArraySymbol.isNormalized] = true;
          Object.freeze(this);
        }
        return this;
      }
      /**
       * Finalizes the state of a config before being cached and returned by
       * `getConfig()`. Does nothing by default but is provided to be
       * overridden by subclasses as necessary.
       * @param {Object} config The config to finalize.
       * @returns {Object} The finalized config.
       */
      [ConfigArraySymbol.finalizeConfig](config) {
        return config;
      }
      /**
       * Preprocesses a config during the normalization process. This is the
       * method to override if you want to convert an array item before it is
       * validated for the first time. For example, if you want to replace a
       * string with an object, this is the method to override.
       * @param {Object} config The config to preprocess.
       * @returns {Object} The config to use in place of the argument.
       */
      [ConfigArraySymbol.preprocessConfig](config) {
        return config;
      }
      /**
       * Determines if a given file path explicitly matches a `files` entry
       * and also doesn't match an `ignores` entry. Configs that don't have
       * a `files` property are not considered an explicit match.
       * @param {string} filePath The complete path of a file to check.
       * @returns {boolean} True if the file path matches a `files` entry
       * 		or false if not.
       */
      isExplicitMatch(filePath) {
        assertNormalized(this);
        const cache = dataCache.get(this);
        let result = cache.explicitMatches.get(filePath);
        if (typeof result == "boolean") {
          return result;
        }
        const relativeFilePath = path.relative(this.basePath, filePath);
        if (shouldIgnorePath(this.ignores, filePath, relativeFilePath)) {
          debug(`Ignoring ${filePath}`);
          cache.explicitMatches.set(filePath, false);
          return false;
        }
        for (const config of this) {
          if (!config.files) {
            continue;
          }
          if (pathMatches(filePath, this.basePath, config)) {
            debug(`Matching config found for ${filePath}`);
            cache.explicitMatches.set(filePath, true);
            return true;
          }
        }
        return false;
      }
      /**
       * Returns the config object for a given file path.
       * @param {string} filePath The complete path of a file to get a config for.
       * @returns {Object} The config object for this file.
       */
      getConfig(filePath) {
        assertNormalized(this);
        const cache = this[ConfigArraySymbol.configCache];
        let finalConfig = cache.get(filePath);
        if (finalConfig) {
          return finalConfig;
        }
        if (this.isDirectoryIgnored(path.dirname(filePath))) {
          debug(`Ignoring ${filePath} based on directory pattern`);
          cache.set(filePath, finalConfig);
          return finalConfig;
        }
        const relativeFilePath = path.relative(this.basePath, filePath);
        if (shouldIgnorePath(this.ignores, filePath, relativeFilePath)) {
          debug(`Ignoring ${filePath} based on file pattern`);
          cache.set(filePath, finalConfig);
          return finalConfig;
        }
        const matchingConfigIndices = [];
        let matchFound = false;
        const universalPattern = /\/\*{1,2}$/;
        this.forEach((config, index) => {
          if (!config.files) {
            if (!config.ignores) {
              debug(`Anonymous universal config found for ${filePath}`);
              matchingConfigIndices.push(index);
              return;
            }
            if (pathMatchesIgnores(filePath, this.basePath, config)) {
              debug(`Matching config found for ${filePath} (based on ignores: ${config.ignores})`);
              matchingConfigIndices.push(index);
              return;
            }
            debug(`Skipped config found for ${filePath} (based on ignores: ${config.ignores})`);
            return;
          }
          assertNonEmptyFilesArray(config);
          const universalFiles = config.files.filter(
            (pattern) => universalPattern.test(pattern)
          );
          if (universalFiles.length) {
            debug("Universal files patterns found. Checking carefully.");
            const nonUniversalFiles = config.files.filter(
              (pattern) => !universalPattern.test(pattern)
            );
            if (nonUniversalFiles.length && pathMatches(
              filePath,
              this.basePath,
              { files: nonUniversalFiles, ignores: config.ignores }
            )) {
              debug(`Matching config found for ${filePath}`);
              matchingConfigIndices.push(index);
              matchFound = true;
              return;
            }
            if (universalFiles.length && pathMatches(
              filePath,
              this.basePath,
              { files: universalFiles, ignores: config.ignores }
            )) {
              debug(`Matching config found for ${filePath}`);
              matchingConfigIndices.push(index);
              return;
            }
            return;
          }
          if (pathMatches(filePath, this.basePath, config)) {
            debug(`Matching config found for ${filePath}`);
            matchingConfigIndices.push(index);
            matchFound = true;
            return;
          }
        });
        if (!matchFound) {
          debug(`No matching configs found for ${filePath}`);
          cache.set(filePath, finalConfig);
          return finalConfig;
        }
        finalConfig = cache.get(matchingConfigIndices.toString());
        if (finalConfig) {
          cache.set(filePath, finalConfig);
          return finalConfig;
        }
        finalConfig = matchingConfigIndices.reduce((result, index) => {
          return this[ConfigArraySymbol.schema].merge(result, this[index]);
        }, {}, this);
        finalConfig = this[ConfigArraySymbol.finalizeConfig](finalConfig);
        cache.set(filePath, finalConfig);
        cache.set(matchingConfigIndices.toString(), finalConfig);
        return finalConfig;
      }
      /**
       * Determines if the given filepath is ignored based on the configs.
       * @param {string} filePath The complete path of a file to check.
       * @returns {boolean} True if the path is ignored, false if not.
       * @deprecated Use `isFileIgnored` instead.
       */
      isIgnored(filePath) {
        return this.isFileIgnored(filePath);
      }
      /**
       * Determines if the given filepath is ignored based on the configs.
       * @param {string} filePath The complete path of a file to check.
       * @returns {boolean} True if the path is ignored, false if not.
       */
      isFileIgnored(filePath) {
        return this.getConfig(filePath) === void 0;
      }
      /**
       * Determines if the given directory is ignored based on the configs.
       * This checks only default `ignores` that don't have `files` in the 
       * same config. A pattern such as `/foo` be considered to ignore the directory
       * while a pattern such as `/foo/**` is not considered to ignore the
       * directory because it is matching files.
       * @param {string} directoryPath The complete path of a directory to check.
       * @returns {boolean} True if the directory is ignored, false if not. Will
       * 		return true for any directory that is not inside of `basePath`.
       * @throws {Error} When the `ConfigArray` is not normalized.
       */
      isDirectoryIgnored(directoryPath) {
        assertNormalized(this);
        const relativeDirectoryPath = path.relative(this.basePath, directoryPath).replace(/\\/g, "/");
        if (relativeDirectoryPath.startsWith("..")) {
          return true;
        }
        const cache = dataCache.get(this).directoryMatches;
        if (cache.has(relativeDirectoryPath)) {
          return cache.get(relativeDirectoryPath);
        }
        const directoryParts = relativeDirectoryPath.split("/");
        let relativeDirectoryToCheck = "";
        let result = false;
        do {
          relativeDirectoryToCheck += directoryParts.shift() + "/";
          result = shouldIgnorePath(
            this.ignores,
            path.join(this.basePath, relativeDirectoryToCheck),
            relativeDirectoryToCheck
          );
          cache.set(relativeDirectoryToCheck, result);
        } while (!result && directoryParts.length);
        cache.set(relativeDirectoryPath, result);
        return result;
      }
    };
    exports.ConfigArray = ConfigArray;
    exports.ConfigArraySymbol = ConfigArraySymbol;
  }
});

// ../../node_modules/eslint/lib/config/flat-config-schema.js
var require_flat_config_schema = __commonJS({
  "../../node_modules/eslint/lib/config/flat-config-schema.js"(exports) {
    "use strict";
    var ruleSeverities = /* @__PURE__ */ new Map([
      [0, 0],
      ["off", 0],
      [1, 1],
      ["warn", 1],
      [2, 2],
      ["error", 2]
    ]);
    var globalVariablesValues = /* @__PURE__ */ new Set([
      true,
      "true",
      "writable",
      "writeable",
      false,
      "false",
      "readonly",
      "readable",
      null,
      "off"
    ]);
    function isNonNullObject(value) {
      return typeof value === "object" && value !== null;
    }
    function isUndefined(value) {
      return typeof value === "undefined";
    }
    function deepMerge(first = {}, second = {}) {
      if (Array.isArray(second)) {
        return second;
      }
      const result = {
        ...first,
        ...second
      };
      for (const key of Object.keys(second)) {
        if (key === "__proto__") {
          continue;
        }
        const firstValue = first[key];
        const secondValue = second[key];
        if (isNonNullObject(firstValue)) {
          result[key] = deepMerge(firstValue, secondValue);
        } else if (isUndefined(firstValue)) {
          if (isNonNullObject(secondValue)) {
            result[key] = deepMerge(
              Array.isArray(secondValue) ? [] : {},
              secondValue
            );
          } else if (!isUndefined(secondValue)) {
            result[key] = secondValue;
          }
        }
      }
      return result;
    }
    function normalizeRuleOptions(ruleOptions) {
      const finalOptions = Array.isArray(ruleOptions) ? ruleOptions.slice(0) : [ruleOptions];
      finalOptions[0] = ruleSeverities.get(finalOptions[0]);
      return finalOptions;
    }
    var InvalidRuleOptionsError = class extends Error {
      /**
       * @param {string} ruleId Rule name being configured.
       * @param {any} value The invalid value.
       */
      constructor(ruleId, value) {
        super(`Key "${ruleId}": Expected severity of "off", 0, "warn", 1, "error", or 2.`);
        this.messageTemplate = "invalid-rule-options";
        this.messageData = { ruleId, value };
      }
    };
    function assertIsRuleOptions(ruleId, value) {
      if (typeof value !== "string" && typeof value !== "number" && !Array.isArray(value)) {
        throw new InvalidRuleOptionsError(ruleId, value);
      }
    }
    var InvalidRuleSeverityError = class extends Error {
      /**
       * @param {string} ruleId Rule name being configured.
       * @param {any} value The invalid value.
       */
      constructor(ruleId, value) {
        super(`Key "${ruleId}": Expected severity of "off", 0, "warn", 1, "error", or 2.`);
        this.messageTemplate = "invalid-rule-severity";
        this.messageData = { ruleId, value };
      }
    };
    function assertIsRuleSeverity(ruleId, value) {
      const severity = typeof value === "string" ? ruleSeverities.get(value.toLowerCase()) : ruleSeverities.get(value);
      if (typeof severity === "undefined") {
        throw new InvalidRuleSeverityError(ruleId, value);
      }
    }
    function assertIsPluginMemberName(value) {
      if (!/[@a-z0-9-_$]+(?:\/(?:[a-z0-9-_$]+))+$/iu.test(value)) {
        throw new TypeError(`Expected string in the form "pluginName/objectName" but found "${value}".`);
      }
    }
    function assertIsObject(value) {
      if (!isNonNullObject(value)) {
        throw new TypeError("Expected an object.");
      }
    }
    var booleanSchema = {
      merge: "replace",
      validate: "boolean"
    };
    var deepObjectAssignSchema = {
      merge(first = {}, second = {}) {
        return deepMerge(first, second);
      },
      validate: "object"
    };
    var globalsSchema = {
      merge: "assign",
      validate(value) {
        assertIsObject(value);
        for (const key of Object.keys(value)) {
          if (key === "__proto__") {
            continue;
          }
          if (key !== key.trim()) {
            throw new TypeError(`Global "${key}" has leading or trailing whitespace.`);
          }
          if (!globalVariablesValues.has(value[key])) {
            throw new TypeError(`Key "${key}": Expected "readonly", "writable", or "off".`);
          }
        }
      }
    };
    var parserSchema = {
      merge: "replace",
      validate(value) {
        if (!value || typeof value !== "object" || typeof value.parse !== "function" && typeof value.parseForESLint !== "function") {
          throw new TypeError("Expected object with parse() or parseForESLint() method.");
        }
      }
    };
    var pluginsSchema = {
      merge(first = {}, second = {}) {
        const keys = /* @__PURE__ */ new Set([...Object.keys(first), ...Object.keys(second)]);
        const result = {};
        for (const key of keys) {
          if (key === "__proto__") {
            continue;
          }
          if (key in first && key in second && first[key] !== second[key]) {
            throw new TypeError(`Cannot redefine plugin "${key}".`);
          }
          result[key] = second[key] || first[key];
        }
        return result;
      },
      validate(value) {
        if (value === null || typeof value !== "object") {
          throw new TypeError("Expected an object.");
        }
        for (const key of Object.keys(value)) {
          if (key === "__proto__") {
            continue;
          }
          if (value[key] === null || typeof value[key] !== "object") {
            throw new TypeError(`Key "${key}": Expected an object.`);
          }
        }
      }
    };
    var processorSchema = {
      merge: "replace",
      validate(value) {
        if (typeof value === "string") {
          assertIsPluginMemberName(value);
        } else if (value && typeof value === "object") {
          if (typeof value.preprocess !== "function" || typeof value.postprocess !== "function") {
            throw new TypeError("Object must have a preprocess() and a postprocess() method.");
          }
        } else {
          throw new TypeError("Expected an object or a string.");
        }
      }
    };
    var rulesSchema = {
      merge(first = {}, second = {}) {
        const result = {
          ...first,
          ...second
        };
        for (const ruleId of Object.keys(result)) {
          if (ruleId === "__proto__") {
            delete result.__proto__;
            continue;
          }
          result[ruleId] = normalizeRuleOptions(result[ruleId]);
          if (!(ruleId in first) || !(ruleId in second)) {
            continue;
          }
          const firstRuleOptions = normalizeRuleOptions(first[ruleId]);
          const secondRuleOptions = normalizeRuleOptions(second[ruleId]);
          if (secondRuleOptions.length === 1) {
            result[ruleId] = [secondRuleOptions[0], ...firstRuleOptions.slice(1)];
            continue;
          }
        }
        return result;
      },
      validate(value) {
        assertIsObject(value);
        for (const ruleId of Object.keys(value)) {
          if (ruleId === "__proto__") {
            continue;
          }
          const ruleOptions = value[ruleId];
          assertIsRuleOptions(ruleId, ruleOptions);
          if (Array.isArray(ruleOptions)) {
            assertIsRuleSeverity(ruleId, ruleOptions[0]);
          } else {
            assertIsRuleSeverity(ruleId, ruleOptions);
          }
        }
      }
    };
    var ecmaVersionSchema = {
      merge: "replace",
      validate(value) {
        if (typeof value === "number" || value === "latest") {
          return;
        }
        throw new TypeError('Expected a number or "latest".');
      }
    };
    var sourceTypeSchema = {
      merge: "replace",
      validate(value) {
        if (typeof value !== "string" || !/^(?:script|module|commonjs)$/u.test(value)) {
          throw new TypeError('Expected "script", "module", or "commonjs".');
        }
      }
    };
    exports.flatConfigSchema = {
      settings: deepObjectAssignSchema,
      linterOptions: {
        schema: {
          noInlineConfig: booleanSchema,
          reportUnusedDisableDirectives: booleanSchema
        }
      },
      languageOptions: {
        schema: {
          ecmaVersion: ecmaVersionSchema,
          sourceType: sourceTypeSchema,
          globals: globalsSchema,
          parser: parserSchema,
          parserOptions: deepObjectAssignSchema
        }
      },
      processor: processorSchema,
      plugins: pluginsSchema,
      rules: rulesSchema
    };
  }
});

// ../../node_modules/ajv/lib/refs/json-schema-draft-04.json
var require_json_schema_draft_04 = __commonJS({
  "../../node_modules/ajv/lib/refs/json-schema-draft-04.json"(exports, module) {
    module.exports = {
      id: "http://json-schema.org/draft-04/schema#",
      $schema: "http://json-schema.org/draft-04/schema#",
      description: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        positiveInteger: {
          type: "integer",
          minimum: 0
        },
        positiveIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/positiveInteger" }, { default: 0 }]
        },
        simpleTypes: {
          enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          minItems: 1,
          uniqueItems: true
        }
      },
      type: "object",
      properties: {
        id: {
          type: "string"
        },
        $schema: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: {},
        multipleOf: {
          type: "number",
          minimum: 0,
          exclusiveMinimum: true
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "boolean",
          default: false
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "boolean",
          default: false
        },
        maxLength: { $ref: "#/definitions/positiveInteger" },
        minLength: { $ref: "#/definitions/positiveIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: {
          anyOf: [
            { type: "boolean" },
            { $ref: "#" }
          ],
          default: {}
        },
        items: {
          anyOf: [
            { $ref: "#" },
            { $ref: "#/definitions/schemaArray" }
          ],
          default: {}
        },
        maxItems: { $ref: "#/definitions/positiveInteger" },
        minItems: { $ref: "#/definitions/positiveIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        maxProperties: { $ref: "#/definitions/positiveInteger" },
        minProperties: { $ref: "#/definitions/positiveIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: {
          anyOf: [
            { type: "boolean" },
            { $ref: "#" }
          ],
          default: {}
        },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [
              { $ref: "#" },
              { $ref: "#/definitions/stringArray" }
            ]
          }
        },
        enum: {
          type: "array",
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      dependencies: {
        exclusiveMaximum: ["maximum"],
        exclusiveMinimum: ["minimum"]
      },
      default: {}
    };
  }
});

// ../../node_modules/eslint/lib/shared/ajv.js
var require_ajv2 = __commonJS({
  "../../node_modules/eslint/lib/shared/ajv.js"(exports, module) {
    "use strict";
    var Ajv = require_ajv();
    var metaSchema = require_json_schema_draft_04();
    module.exports = (additionalOptions = {}) => {
      const ajv = new Ajv({
        meta: false,
        useDefaults: true,
        validateSchema: false,
        missingRefs: "ignore",
        verbose: true,
        schemaId: "auto",
        ...additionalOptions
      });
      ajv.addMetaSchema(metaSchema);
      ajv._opts.defaultMeta = metaSchema.id;
      return ajv;
    };
  }
});

// ../../node_modules/eslint/lib/config/rule-validator.js
var require_rule_validator = __commonJS({
  "../../node_modules/eslint/lib/config/rule-validator.js"(exports) {
    "use strict";
    var ajv = require_ajv2()();
    var {
      parseRuleId,
      getRuleFromConfig,
      getRuleOptionsSchema
    } = require_flat_config_helpers();
    var ruleReplacements = require_replacements();
    function throwRuleNotFoundError({ pluginName, ruleName }, config) {
      const ruleId = pluginName === "@" ? ruleName : `${pluginName}/${ruleName}`;
      const errorMessageHeader = `Key "rules": Key "${ruleId}"`;
      let errorMessage = `${errorMessageHeader}: Could not find plugin "${pluginName}".`;
      if (config.plugins && config.plugins[pluginName]) {
        const replacementRuleName = ruleReplacements.rules[ruleName];
        if (pluginName === "@" && replacementRuleName) {
          errorMessage = `${errorMessageHeader}: Rule "${ruleName}" was removed and replaced by "${replacementRuleName}".`;
        } else {
          errorMessage = `${errorMessageHeader}: Could not find "${ruleName}" in plugin "${pluginName}".`;
          for (const [otherPluginName, otherPlugin] of Object.entries(config.plugins)) {
            if (otherPlugin.rules && otherPlugin.rules[ruleName]) {
              errorMessage += ` Did you mean "${otherPluginName}/${ruleName}"?`;
              break;
            }
          }
        }
      }
      throw new TypeError(errorMessage);
    }
    var RuleValidator = class {
      /**
       * Creates a new instance.
       */
      constructor() {
        this.validators = /* @__PURE__ */ new WeakMap();
      }
      /**
       * Validates all of the rule configurations in a config against each
       * rule's schema.
       * @param {Object} config The full config to validate. This object must
       *      contain both the rules section and the plugins section.
       * @returns {void}
       * @throws {Error} If a rule's configuration does not match its schema.
       */
      validate(config) {
        if (!config.rules) {
          return;
        }
        for (const [ruleId, ruleOptions] of Object.entries(config.rules)) {
          if (ruleId === "__proto__") {
            continue;
          }
          if (ruleOptions[0] === 0) {
            continue;
          }
          const rule = getRuleFromConfig(ruleId, config);
          if (!rule) {
            throwRuleNotFoundError(parseRuleId(ruleId), config);
          }
          if (!this.validators.has(rule)) {
            const schema = getRuleOptionsSchema(rule);
            if (schema) {
              this.validators.set(rule, ajv.compile(schema));
            }
          }
          const validateRule = this.validators.get(rule);
          if (validateRule) {
            validateRule(ruleOptions.slice(1));
            if (validateRule.errors) {
              throw new Error(`Key "rules": Key "${ruleId}": ${validateRule.errors.map(
                (error) => `	Value ${JSON.stringify(error.data)} ${error.message}.
`
              ).join("")}`);
            }
          }
        }
      }
    };
    exports.RuleValidator = RuleValidator;
  }
});

// ../../node_modules/eslint/lib/config/default-config.js
var require_default_config = __commonJS({
  "../../node_modules/eslint/lib/config/default-config.js"(exports) {
    "use strict";
    var Rules = require_rules2();
    exports.defaultConfig = [
      {
        plugins: {
          "@": {
            /*
             * Because we try to delay loading rules until absolutely
             * necessary, a proxy allows us to hook into the lazy-loading
             * aspect of the rules map while still keeping all of the
             * relevant configuration inside of the config array.
             */
            rules: new Proxy({}, {
              get(target, property) {
                return Rules.get(property);
              },
              has(target, property) {
                return Rules.has(property);
              }
            })
          }
        },
        languageOptions: {
          sourceType: "module",
          ecmaVersion: "latest",
          parser: require_espree(),
          parserOptions: {}
        }
      },
      // default ignores are listed here
      {
        ignores: [
          "**/node_modules/",
          ".git/"
        ]
      },
      // intentionally empty config to ensure these files are globbed by default
      {
        files: ["**/*.js", "**/*.mjs"]
      },
      {
        files: ["**/*.cjs"],
        languageOptions: {
          sourceType: "commonjs",
          ecmaVersion: "latest"
        }
      }
    ];
  }
});

// ../../node_modules/@eslint/js/src/configs/eslint-all.js
var require_eslint_all = __commonJS({
  "../../node_modules/@eslint/js/src/configs/eslint-all.js"(exports, module) {
    "use strict";
    module.exports = Object.freeze({
      "rules": {
        "accessor-pairs": "error",
        "array-bracket-newline": "error",
        "array-bracket-spacing": "error",
        "array-callback-return": "error",
        "array-element-newline": "error",
        "arrow-body-style": "error",
        "arrow-parens": "error",
        "arrow-spacing": "error",
        "block-scoped-var": "error",
        "block-spacing": "error",
        "brace-style": "error",
        "camelcase": "error",
        "capitalized-comments": "error",
        "class-methods-use-this": "error",
        "comma-dangle": "error",
        "comma-spacing": "error",
        "comma-style": "error",
        "complexity": "error",
        "computed-property-spacing": "error",
        "consistent-return": "error",
        "consistent-this": "error",
        "constructor-super": "error",
        "curly": "error",
        "default-case": "error",
        "default-case-last": "error",
        "default-param-last": "error",
        "dot-location": "error",
        "dot-notation": "error",
        "eol-last": "error",
        "eqeqeq": "error",
        "for-direction": "error",
        "func-call-spacing": "error",
        "func-name-matching": "error",
        "func-names": "error",
        "func-style": "error",
        "function-call-argument-newline": "error",
        "function-paren-newline": "error",
        "generator-star-spacing": "error",
        "getter-return": "error",
        "grouped-accessor-pairs": "error",
        "guard-for-in": "error",
        "id-denylist": "error",
        "id-length": "error",
        "id-match": "error",
        "implicit-arrow-linebreak": "error",
        "indent": "error",
        "init-declarations": "error",
        "jsx-quotes": "error",
        "key-spacing": "error",
        "keyword-spacing": "error",
        "line-comment-position": "error",
        "linebreak-style": "error",
        "lines-around-comment": "error",
        "lines-between-class-members": "error",
        "logical-assignment-operators": "error",
        "max-classes-per-file": "error",
        "max-depth": "error",
        "max-len": "error",
        "max-lines": "error",
        "max-lines-per-function": "error",
        "max-nested-callbacks": "error",
        "max-params": "error",
        "max-statements": "error",
        "max-statements-per-line": "error",
        "multiline-comment-style": "error",
        "multiline-ternary": "error",
        "new-cap": "error",
        "new-parens": "error",
        "newline-per-chained-call": "error",
        "no-alert": "error",
        "no-array-constructor": "error",
        "no-async-promise-executor": "error",
        "no-await-in-loop": "error",
        "no-bitwise": "error",
        "no-caller": "error",
        "no-case-declarations": "error",
        "no-class-assign": "error",
        "no-compare-neg-zero": "error",
        "no-cond-assign": "error",
        "no-confusing-arrow": "error",
        "no-console": "error",
        "no-const-assign": "error",
        "no-constant-binary-expression": "error",
        "no-constant-condition": "error",
        "no-constructor-return": "error",
        "no-continue": "error",
        "no-control-regex": "error",
        "no-debugger": "error",
        "no-delete-var": "error",
        "no-div-regex": "error",
        "no-dupe-args": "error",
        "no-dupe-class-members": "error",
        "no-dupe-else-if": "error",
        "no-dupe-keys": "error",
        "no-duplicate-case": "error",
        "no-duplicate-imports": "error",
        "no-else-return": "error",
        "no-empty": "error",
        "no-empty-character-class": "error",
        "no-empty-function": "error",
        "no-empty-pattern": "error",
        "no-empty-static-block": "error",
        "no-eq-null": "error",
        "no-eval": "error",
        "no-ex-assign": "error",
        "no-extend-native": "error",
        "no-extra-bind": "error",
        "no-extra-boolean-cast": "error",
        "no-extra-label": "error",
        "no-extra-parens": "error",
        "no-extra-semi": "error",
        "no-fallthrough": "error",
        "no-floating-decimal": "error",
        "no-func-assign": "error",
        "no-global-assign": "error",
        "no-implicit-coercion": "error",
        "no-implicit-globals": "error",
        "no-implied-eval": "error",
        "no-import-assign": "error",
        "no-inline-comments": "error",
        "no-inner-declarations": "error",
        "no-invalid-regexp": "error",
        "no-invalid-this": "error",
        "no-irregular-whitespace": "error",
        "no-iterator": "error",
        "no-label-var": "error",
        "no-labels": "error",
        "no-lone-blocks": "error",
        "no-lonely-if": "error",
        "no-loop-func": "error",
        "no-loss-of-precision": "error",
        "no-magic-numbers": "error",
        "no-misleading-character-class": "error",
        "no-mixed-operators": "error",
        "no-mixed-spaces-and-tabs": "error",
        "no-multi-assign": "error",
        "no-multi-spaces": "error",
        "no-multi-str": "error",
        "no-multiple-empty-lines": "error",
        "no-negated-condition": "error",
        "no-nested-ternary": "error",
        "no-new": "error",
        "no-new-func": "error",
        "no-new-native-nonconstructor": "error",
        "no-new-object": "error",
        "no-new-symbol": "error",
        "no-new-wrappers": "error",
        "no-nonoctal-decimal-escape": "error",
        "no-obj-calls": "error",
        "no-octal": "error",
        "no-octal-escape": "error",
        "no-param-reassign": "error",
        "no-plusplus": "error",
        "no-promise-executor-return": "error",
        "no-proto": "error",
        "no-prototype-builtins": "error",
        "no-redeclare": "error",
        "no-regex-spaces": "error",
        "no-restricted-exports": "error",
        "no-restricted-globals": "error",
        "no-restricted-imports": "error",
        "no-restricted-properties": "error",
        "no-restricted-syntax": "error",
        "no-return-assign": "error",
        "no-return-await": "error",
        "no-script-url": "error",
        "no-self-assign": "error",
        "no-self-compare": "error",
        "no-sequences": "error",
        "no-setter-return": "error",
        "no-shadow": "error",
        "no-shadow-restricted-names": "error",
        "no-sparse-arrays": "error",
        "no-tabs": "error",
        "no-template-curly-in-string": "error",
        "no-ternary": "error",
        "no-this-before-super": "error",
        "no-throw-literal": "error",
        "no-trailing-spaces": "error",
        "no-undef": "error",
        "no-undef-init": "error",
        "no-undefined": "error",
        "no-underscore-dangle": "error",
        "no-unexpected-multiline": "error",
        "no-unmodified-loop-condition": "error",
        "no-unneeded-ternary": "error",
        "no-unreachable": "error",
        "no-unreachable-loop": "error",
        "no-unsafe-finally": "error",
        "no-unsafe-negation": "error",
        "no-unsafe-optional-chaining": "error",
        "no-unused-expressions": "error",
        "no-unused-labels": "error",
        "no-unused-private-class-members": "error",
        "no-unused-vars": "error",
        "no-use-before-define": "error",
        "no-useless-backreference": "error",
        "no-useless-call": "error",
        "no-useless-catch": "error",
        "no-useless-computed-key": "error",
        "no-useless-concat": "error",
        "no-useless-constructor": "error",
        "no-useless-escape": "error",
        "no-useless-rename": "error",
        "no-useless-return": "error",
        "no-var": "error",
        "no-void": "error",
        "no-warning-comments": "error",
        "no-whitespace-before-property": "error",
        "no-with": "error",
        "nonblock-statement-body-position": "error",
        "object-curly-newline": "error",
        "object-curly-spacing": "error",
        "object-property-newline": "error",
        "object-shorthand": "error",
        "one-var": "error",
        "one-var-declaration-per-line": "error",
        "operator-assignment": "error",
        "operator-linebreak": "error",
        "padded-blocks": "error",
        "padding-line-between-statements": "error",
        "prefer-arrow-callback": "error",
        "prefer-const": "error",
        "prefer-destructuring": "error",
        "prefer-exponentiation-operator": "error",
        "prefer-named-capture-group": "error",
        "prefer-numeric-literals": "error",
        "prefer-object-has-own": "error",
        "prefer-object-spread": "error",
        "prefer-promise-reject-errors": "error",
        "prefer-regex-literals": "error",
        "prefer-rest-params": "error",
        "prefer-spread": "error",
        "prefer-template": "error",
        "quote-props": "error",
        "quotes": "error",
        "radix": "error",
        "require-atomic-updates": "error",
        "require-await": "error",
        "require-unicode-regexp": "error",
        "require-yield": "error",
        "rest-spread-spacing": "error",
        "semi": "error",
        "semi-spacing": "error",
        "semi-style": "error",
        "sort-imports": "error",
        "sort-keys": "error",
        "sort-vars": "error",
        "space-before-blocks": "error",
        "space-before-function-paren": "error",
        "space-in-parens": "error",
        "space-infix-ops": "error",
        "space-unary-ops": "error",
        "spaced-comment": "error",
        "strict": "error",
        "switch-colon-spacing": "error",
        "symbol-description": "error",
        "template-curly-spacing": "error",
        "template-tag-spacing": "error",
        "unicode-bom": "error",
        "use-isnan": "error",
        "valid-typeof": "error",
        "vars-on-top": "error",
        "wrap-iife": "error",
        "wrap-regex": "error",
        "yield-star-spacing": "error",
        "yoda": "error"
      }
    });
  }
});

// ../../node_modules/@eslint/js/src/configs/eslint-recommended.js
var require_eslint_recommended = __commonJS({
  "../../node_modules/@eslint/js/src/configs/eslint-recommended.js"(exports, module) {
    "use strict";
    module.exports = Object.freeze({
      rules: Object.freeze({
        "constructor-super": "error",
        "for-direction": "error",
        "getter-return": "error",
        "no-async-promise-executor": "error",
        "no-case-declarations": "error",
        "no-class-assign": "error",
        "no-compare-neg-zero": "error",
        "no-cond-assign": "error",
        "no-const-assign": "error",
        "no-constant-condition": "error",
        "no-control-regex": "error",
        "no-debugger": "error",
        "no-delete-var": "error",
        "no-dupe-args": "error",
        "no-dupe-class-members": "error",
        "no-dupe-else-if": "error",
        "no-dupe-keys": "error",
        "no-duplicate-case": "error",
        "no-empty": "error",
        "no-empty-character-class": "error",
        "no-empty-pattern": "error",
        "no-ex-assign": "error",
        "no-extra-boolean-cast": "error",
        "no-extra-semi": "error",
        "no-fallthrough": "error",
        "no-func-assign": "error",
        "no-global-assign": "error",
        "no-import-assign": "error",
        "no-inner-declarations": "error",
        "no-invalid-regexp": "error",
        "no-irregular-whitespace": "error",
        "no-loss-of-precision": "error",
        "no-misleading-character-class": "error",
        "no-mixed-spaces-and-tabs": "error",
        "no-new-symbol": "error",
        "no-nonoctal-decimal-escape": "error",
        "no-obj-calls": "error",
        "no-octal": "error",
        "no-prototype-builtins": "error",
        "no-redeclare": "error",
        "no-regex-spaces": "error",
        "no-self-assign": "error",
        "no-setter-return": "error",
        "no-shadow-restricted-names": "error",
        "no-sparse-arrays": "error",
        "no-this-before-super": "error",
        "no-undef": "error",
        "no-unexpected-multiline": "error",
        "no-unreachable": "error",
        "no-unsafe-finally": "error",
        "no-unsafe-negation": "error",
        "no-unsafe-optional-chaining": "error",
        "no-unused-labels": "error",
        "no-unused-vars": "error",
        "no-useless-backreference": "error",
        "no-useless-catch": "error",
        "no-useless-escape": "error",
        "no-with": "error",
        "require-yield": "error",
        "use-isnan": "error",
        "valid-typeof": "error"
      })
    });
  }
});

// ../../node_modules/@eslint/js/src/index.js
var require_src3 = __commonJS({
  "../../node_modules/@eslint/js/src/index.js"(exports, module) {
    "use strict";
    module.exports = {
      configs: {
        all: require_eslint_all(),
        recommended: require_eslint_recommended()
      }
    };
  }
});

// ../../node_modules/eslint/lib/config/flat-config-array.js
var require_flat_config_array = __commonJS({
  "../../node_modules/eslint/lib/config/flat-config-array.js"(exports) {
    "use strict";
    var { ConfigArray, ConfigArraySymbol } = require_api();
    var { flatConfigSchema } = require_flat_config_schema();
    var { RuleValidator } = require_rule_validator();
    var { defaultConfig } = require_default_config();
    var jsPlugin = require_src3();
    var ruleValidator = new RuleValidator();
    function splitPluginIdentifier(identifier) {
      const parts = identifier.split("/");
      return {
        objectName: parts.pop(),
        pluginName: parts.join("/")
      };
    }
    function getObjectId(object) {
      let name = object.name;
      if (!name) {
        if (!object.meta) {
          return null;
        }
        name = object.meta.name;
        if (!name) {
          return null;
        }
      }
      let version = object.version;
      if (!version) {
        version = object.meta && object.meta.version;
      }
      if (version) {
        return `${name}@${version}`;
      }
      return name;
    }
    var originalBaseConfig = Symbol("originalBaseConfig");
    var FlatConfigArray = class extends ConfigArray {
      /**
       * Creates a new instance.
       * @param {*[]} configs An array of configuration information.
       * @param {{basePath: string, shouldIgnore: boolean, baseConfig: FlatConfig}} options The options
       *      to use for the config array instance.
       */
      constructor(configs, {
        basePath,
        shouldIgnore = true,
        baseConfig = defaultConfig
      } = {}) {
        super(configs, {
          basePath,
          schema: flatConfigSchema
        });
        if (baseConfig[Symbol.iterator]) {
          this.unshift(...baseConfig);
        } else {
          this.unshift(baseConfig);
        }
        this[originalBaseConfig] = baseConfig;
        Object.defineProperty(this, originalBaseConfig, { writable: false });
        this.shouldIgnore = shouldIgnore;
        Object.defineProperty(this, "shouldIgnore", { writable: false });
      }
      /* eslint-disable class-methods-use-this -- Desired as instance method */
      /**
       * Replaces a config with another config to allow us to put strings
       * in the config array that will be replaced by objects before
       * normalization.
       * @param {Object} config The config to preprocess.
       * @returns {Object} The preprocessed config.
       */
      [ConfigArraySymbol.preprocessConfig](config) {
        if (config === "eslint:recommended") {
          if (typeof process !== "undefined" && process.emitWarning) {
            process.emitWarning("The 'eslint:recommended' string configuration is deprecated and will be replaced by the @eslint/js package's 'recommended' config.");
          }
          return jsPlugin.configs.recommended;
        }
        if (config === "eslint:all") {
          if (typeof process !== "undefined" && process.emitWarning) {
            process.emitWarning("The 'eslint:all' string configuration is deprecated and will be replaced by the @eslint/js package's 'all' config.");
          }
          return jsPlugin.configs.all;
        }
        if (!this.shouldIgnore && !this[originalBaseConfig].includes(config) && config.ignores && !config.files) {
          const { ignores, ...otherKeys } = config;
          return otherKeys;
        }
        return config;
      }
      /**
       * Finalizes the config by replacing plugin references with their objects
       * and validating rule option schemas.
       * @param {Object} config The config to finalize.
       * @returns {Object} The finalized config.
       * @throws {TypeError} If the config is invalid.
       */
      [ConfigArraySymbol.finalizeConfig](config) {
        const { plugins, languageOptions, processor } = config;
        let parserName, processorName;
        let invalidParser = false, invalidProcessor = false;
        if (languageOptions && languageOptions.parser) {
          const { parser } = languageOptions;
          if (typeof parser === "object") {
            parserName = getObjectId(parser);
            if (!parserName) {
              invalidParser = true;
            }
          } else {
            invalidParser = true;
          }
        }
        if (processor) {
          if (typeof processor === "string") {
            const { pluginName, objectName: localProcessorName } = splitPluginIdentifier(processor);
            processorName = processor;
            if (!plugins || !plugins[pluginName] || !plugins[pluginName].processors || !plugins[pluginName].processors[localProcessorName]) {
              throw new TypeError(`Key "processor": Could not find "${localProcessorName}" in plugin "${pluginName}".`);
            }
            config.processor = plugins[pluginName].processors[localProcessorName];
          } else if (typeof processor === "object") {
            processorName = getObjectId(processor);
            if (!processorName) {
              invalidProcessor = true;
            }
          } else {
            invalidProcessor = true;
          }
        }
        ruleValidator.validate(config);
        Object.defineProperty(config, "toJSON", {
          value: function() {
            if (invalidParser) {
              throw new Error("Could not serialize parser object (missing 'meta' object).");
            }
            if (invalidProcessor) {
              throw new Error("Could not serialize processor object (missing 'meta' object).");
            }
            return {
              ...this,
              plugins: Object.entries(plugins).map(([namespace, plugin]) => {
                const pluginId = getObjectId(plugin);
                if (!pluginId) {
                  return namespace;
                }
                return `${namespace}:${pluginId}`;
              }),
              languageOptions: {
                ...languageOptions,
                parser: parserName
              },
              processor: processorName
            };
          }
        });
        return config;
      }
      /* eslint-enable class-methods-use-this -- Desired as instance method */
    };
    exports.FlatConfigArray = FlatConfigArray;
  }
});

// ../../node_modules/eslint/conf/globals.js
var require_globals3 = __commonJS({
  "../../node_modules/eslint/conf/globals.js"(exports, module) {
    "use strict";
    var commonjs = {
      exports: true,
      global: false,
      module: false,
      require: false
    };
    var es3 = {
      Array: false,
      Boolean: false,
      constructor: false,
      Date: false,
      decodeURI: false,
      decodeURIComponent: false,
      encodeURI: false,
      encodeURIComponent: false,
      Error: false,
      escape: false,
      eval: false,
      EvalError: false,
      Function: false,
      hasOwnProperty: false,
      Infinity: false,
      isFinite: false,
      isNaN: false,
      isPrototypeOf: false,
      Math: false,
      NaN: false,
      Number: false,
      Object: false,
      parseFloat: false,
      parseInt: false,
      propertyIsEnumerable: false,
      RangeError: false,
      ReferenceError: false,
      RegExp: false,
      String: false,
      SyntaxError: false,
      toLocaleString: false,
      toString: false,
      TypeError: false,
      undefined: false,
      unescape: false,
      URIError: false,
      valueOf: false
    };
    var es5 = {
      ...es3,
      JSON: false
    };
    var es2015 = {
      ...es5,
      ArrayBuffer: false,
      DataView: false,
      Float32Array: false,
      Float64Array: false,
      Int16Array: false,
      Int32Array: false,
      Int8Array: false,
      Map: false,
      Promise: false,
      Proxy: false,
      Reflect: false,
      Set: false,
      Symbol: false,
      Uint16Array: false,
      Uint32Array: false,
      Uint8Array: false,
      Uint8ClampedArray: false,
      WeakMap: false,
      WeakSet: false
    };
    var es2016 = {
      ...es2015
    };
    var es2017 = {
      ...es2016,
      Atomics: false,
      SharedArrayBuffer: false
    };
    var es2018 = {
      ...es2017
    };
    var es2019 = {
      ...es2018
    };
    var es2020 = {
      ...es2019,
      BigInt: false,
      BigInt64Array: false,
      BigUint64Array: false,
      globalThis: false
    };
    var es2021 = {
      ...es2020,
      AggregateError: false,
      FinalizationRegistry: false,
      WeakRef: false
    };
    var es2022 = {
      ...es2021
    };
    var es2023 = {
      ...es2022
    };
    var es2024 = {
      ...es2023
    };
    module.exports = {
      commonjs,
      es3,
      es5,
      es2015,
      es2016,
      es2017,
      es2018,
      es2019,
      es2020,
      es2021,
      es2022,
      es2023,
      es2024
    };
  }
});

// ../../node_modules/eslint/lib/linter/linter.js
var require_linter = __commonJS({
  "../../node_modules/eslint/lib/linter/linter.js"(exports, module) {
    "use strict";
    var path = require_path_browserify();
    var eslintScope = require_eslint_scope();
    var evk = require_eslint_visitor_keys();
    var espree = require_espree();
    var merge = require_lodash();
    var pkg = require_package2();
    var astUtils = require_ast_utils();
    var {
      directivesPattern
    } = require_directives();
    var {
      Legacy: {
        ConfigOps,
        ConfigValidator,
        environments: BuiltInEnvironments
      }
    } = require_eslintrc_universal();
    var Traverser = require_traverser();
    var { SourceCode } = require_source_code2();
    var CodePathAnalyzer = require_code_path_analyzer();
    var applyDisableDirectives = require_apply_disable_directives();
    var ConfigCommentParser = require_config_comment_parser();
    var NodeEventGenerator = require_node_event_generator();
    var createReportTranslator = require_report_translator();
    var Rules = require_rules3();
    var createEmitter = require_safe_emitter();
    var SourceCodeFixer = require_source_code_fixer();
    var timing = require_timing();
    var ruleReplacements = require_replacements();
    var { getRuleFromConfig } = require_flat_config_helpers();
    var { FlatConfigArray } = require_flat_config_array();
    var debug = require_browser()("eslint:linter");
    var MAX_AUTOFIX_PASSES = 10;
    var DEFAULT_PARSER_NAME = "espree";
    var DEFAULT_ECMA_VERSION = 5;
    var commentParser = new ConfigCommentParser();
    var DEFAULT_ERROR_LOC = { start: { line: 1, column: 0 }, end: { line: 1, column: 1 } };
    var parserSymbol = Symbol.for("eslint.RuleTester.parser");
    var globals = require_globals3();
    function isEspree(parser) {
      return !!(parser === espree || parser[parserSymbol] === espree);
    }
    function getGlobalsForEcmaVersion(ecmaVersion) {
      switch (ecmaVersion) {
        case 3:
          return globals.es3;
        case 5:
          return globals.es5;
        default:
          if (ecmaVersion < 2015) {
            return globals[`es${ecmaVersion + 2009}`];
          }
          return globals[`es${ecmaVersion}`];
      }
    }
    function addDeclaredGlobals(globalScope, configGlobals, { exportedVariables, enabledGlobals }) {
      for (const id of /* @__PURE__ */ new Set([...Object.keys(configGlobals), ...Object.keys(enabledGlobals)])) {
        const configValue = configGlobals[id] === void 0 ? void 0 : ConfigOps.normalizeConfigGlobal(configGlobals[id]);
        const commentValue = enabledGlobals[id] && enabledGlobals[id].value;
        const value = commentValue || configValue;
        const sourceComments = enabledGlobals[id] && enabledGlobals[id].comments;
        if (value === "off") {
          continue;
        }
        let variable = globalScope.set.get(id);
        if (!variable) {
          variable = new eslintScope.Variable(id, globalScope);
          globalScope.variables.push(variable);
          globalScope.set.set(id, variable);
        }
        variable.eslintImplicitGlobalSetting = configValue;
        variable.eslintExplicitGlobal = sourceComments !== void 0;
        variable.eslintExplicitGlobalComments = sourceComments;
        variable.writeable = value === "writable";
      }
      Object.keys(exportedVariables).forEach((name) => {
        const variable = globalScope.set.get(name);
        if (variable) {
          variable.eslintUsed = true;
          variable.eslintExported = true;
        }
      });
      globalScope.through = globalScope.through.filter((reference) => {
        const name = reference.identifier.name;
        const variable = globalScope.set.get(name);
        if (variable) {
          reference.resolved = variable;
          variable.references.push(reference);
          return false;
        }
        return true;
      });
    }
    function createMissingRuleMessage(ruleId) {
      return Object.prototype.hasOwnProperty.call(ruleReplacements.rules, ruleId) ? `Rule '${ruleId}' was removed and replaced by: ${ruleReplacements.rules[ruleId].join(", ")}` : `Definition for rule '${ruleId}' was not found.`;
    }
    function createLintingProblem(options) {
      const {
        ruleId = null,
        loc = DEFAULT_ERROR_LOC,
        message = createMissingRuleMessage(options.ruleId),
        severity = 2
      } = options;
      return {
        ruleId,
        message,
        line: loc.start.line,
        column: loc.start.column + 1,
        endLine: loc.end.line,
        endColumn: loc.end.column + 1,
        severity,
        nodeType: null
      };
    }
    function createDisableDirectives(options) {
      const { commentToken, type, value, justification, ruleMapper } = options;
      const ruleIds = Object.keys(commentParser.parseListConfig(value));
      const directiveRules = ruleIds.length ? ruleIds : [null];
      const result = {
        directives: [],
        // valid disable directives
        directiveProblems: []
        // problems in directives
      };
      const parentComment = { commentToken, ruleIds };
      for (const ruleId of directiveRules) {
        if (ruleId === null || !!ruleMapper(ruleId)) {
          if (type === "disable-next-line") {
            result.directives.push({
              parentComment,
              type,
              line: commentToken.loc.end.line,
              column: commentToken.loc.end.column + 1,
              ruleId,
              justification
            });
          } else {
            result.directives.push({
              parentComment,
              type,
              line: commentToken.loc.start.line,
              column: commentToken.loc.start.column + 1,
              ruleId,
              justification
            });
          }
        } else {
          result.directiveProblems.push(createLintingProblem({ ruleId, loc: commentToken.loc }));
        }
      }
      return result;
    }
    function extractDirectiveComment(value) {
      const match = /\s-{2,}\s/u.exec(value);
      if (!match) {
        return { directivePart: value.trim(), justificationPart: "" };
      }
      const directive = value.slice(0, match.index).trim();
      const justification = value.slice(match.index + match[0].length).trim();
      return { directivePart: directive, justificationPart: justification };
    }
    function getDirectiveComments(ast, ruleMapper, warnInlineConfig) {
      const configuredRules = {};
      const enabledGlobals = /* @__PURE__ */ Object.create(null);
      const exportedVariables = {};
      const problems = [];
      const disableDirectives = [];
      const validator = new ConfigValidator({
        builtInRules: Rules
      });
      ast.comments.filter((token) => token.type !== "Shebang").forEach((comment) => {
        const { directivePart, justificationPart } = extractDirectiveComment(comment.value);
        const match = directivesPattern.exec(directivePart);
        if (!match) {
          return;
        }
        const directiveText = match[1];
        const lineCommentSupported = /^eslint-disable-(next-)?line$/u.test(directiveText);
        if (comment.type === "Line" && !lineCommentSupported) {
          return;
        }
        if (warnInlineConfig) {
          const kind = comment.type === "Block" ? `/*${directiveText}*/` : `//${directiveText}`;
          problems.push(createLintingProblem({
            ruleId: null,
            message: `'${kind}' has no effect because you have 'noInlineConfig' setting in ${warnInlineConfig}.`,
            loc: comment.loc,
            severity: 1
          }));
          return;
        }
        if (directiveText === "eslint-disable-line" && comment.loc.start.line !== comment.loc.end.line) {
          const message = `${directiveText} comment should not span multiple lines.`;
          problems.push(createLintingProblem({
            ruleId: null,
            message,
            loc: comment.loc
          }));
          return;
        }
        const directiveValue = directivePart.slice(match.index + directiveText.length);
        switch (directiveText) {
          case "eslint-disable":
          case "eslint-enable":
          case "eslint-disable-next-line":
          case "eslint-disable-line": {
            const directiveType = directiveText.slice("eslint-".length);
            const options = { commentToken: comment, type: directiveType, value: directiveValue, justification: justificationPart, ruleMapper };
            const { directives, directiveProblems } = createDisableDirectives(options);
            disableDirectives.push(...directives);
            problems.push(...directiveProblems);
            break;
          }
          case "exported":
            Object.assign(exportedVariables, commentParser.parseStringConfig(directiveValue, comment));
            break;
          case "globals":
          case "global":
            for (const [id, { value }] of Object.entries(commentParser.parseStringConfig(directiveValue, comment))) {
              let normalizedValue;
              try {
                normalizedValue = ConfigOps.normalizeConfigGlobal(value);
              } catch (err) {
                problems.push(createLintingProblem({
                  ruleId: null,
                  loc: comment.loc,
                  message: err.message
                }));
                continue;
              }
              if (enabledGlobals[id]) {
                enabledGlobals[id].comments.push(comment);
                enabledGlobals[id].value = normalizedValue;
              } else {
                enabledGlobals[id] = {
                  comments: [comment],
                  value: normalizedValue
                };
              }
            }
            break;
          case "eslint": {
            const parseResult = commentParser.parseJsonConfig(directiveValue, comment.loc);
            if (parseResult.success) {
              Object.keys(parseResult.config).forEach((name) => {
                const rule = ruleMapper(name);
                const ruleValue = parseResult.config[name];
                if (!rule) {
                  problems.push(createLintingProblem({ ruleId: name, loc: comment.loc }));
                  return;
                }
                try {
                  validator.validateRuleOptions(rule, name, ruleValue);
                } catch (err) {
                  problems.push(createLintingProblem({
                    ruleId: name,
                    message: err.message,
                    loc: comment.loc
                  }));
                  return;
                }
                configuredRules[name] = ruleValue;
              });
            } else {
              problems.push(parseResult.error);
            }
            break;
          }
        }
      });
      return {
        configuredRules,
        enabledGlobals,
        exportedVariables,
        problems,
        disableDirectives
      };
    }
    function normalizeEcmaVersion(parser, ecmaVersion) {
      if (isEspree(parser)) {
        if (ecmaVersion === "latest") {
          return espree.latestEcmaVersion;
        }
      }
      return ecmaVersion >= 2015 ? ecmaVersion - 2009 : ecmaVersion;
    }
    function normalizeEcmaVersionForLanguageOptions(ecmaVersion) {
      switch (ecmaVersion) {
        case 3:
          return 3;
        case 5:
        case void 0:
          return 5;
        default:
          if (typeof ecmaVersion === "number") {
            return ecmaVersion >= 2015 ? ecmaVersion : ecmaVersion + 2009;
          }
      }
      return espree.latestEcmaVersion + 2009;
    }
    var eslintEnvPattern = /\/\*\s*eslint-env\s(.+?)(?:\*\/|$)/gsu;
    function findEslintEnv(text) {
      let match, retv;
      eslintEnvPattern.lastIndex = 0;
      while ((match = eslintEnvPattern.exec(text)) !== null) {
        if (match[0].endsWith("*/")) {
          retv = Object.assign(
            retv || {},
            commentParser.parseListConfig(extractDirectiveComment(match[1]).directivePart)
          );
        }
      }
      return retv;
    }
    function normalizeFilename(filename) {
      const parts = filename.split(path.sep);
      const index = parts.lastIndexOf("<text>");
      return index === -1 ? filename : parts.slice(index).join(path.sep);
    }
    function normalizeVerifyOptions(providedOptions, config) {
      const linterOptions = config.linterOptions || config;
      const disableInlineConfig = linterOptions.noInlineConfig === true;
      const ignoreInlineConfig = providedOptions.allowInlineConfig === false;
      const configNameOfNoInlineConfig = config.configNameOfNoInlineConfig ? ` (${config.configNameOfNoInlineConfig})` : "";
      let reportUnusedDisableDirectives = providedOptions.reportUnusedDisableDirectives;
      if (typeof reportUnusedDisableDirectives === "boolean") {
        reportUnusedDisableDirectives = reportUnusedDisableDirectives ? "error" : "off";
      }
      if (typeof reportUnusedDisableDirectives !== "string") {
        reportUnusedDisableDirectives = linterOptions.reportUnusedDisableDirectives ? "warn" : "off";
      }
      return {
        filename: normalizeFilename(providedOptions.filename || "<input>"),
        allowInlineConfig: !ignoreInlineConfig,
        warnInlineConfig: disableInlineConfig && !ignoreInlineConfig ? `your config${configNameOfNoInlineConfig}` : null,
        reportUnusedDisableDirectives,
        disableFixes: Boolean(providedOptions.disableFixes)
      };
    }
    function resolveParserOptions(parser, providedOptions, enabledEnvironments) {
      const parserOptionsFromEnv = enabledEnvironments.filter((env) => env.parserOptions).reduce((parserOptions, env) => merge(parserOptions, env.parserOptions), {});
      const mergedParserOptions = merge(parserOptionsFromEnv, providedOptions || {});
      const isModule = mergedParserOptions.sourceType === "module";
      if (isModule) {
        mergedParserOptions.ecmaFeatures = Object.assign({}, mergedParserOptions.ecmaFeatures, { globalReturn: false });
      }
      mergedParserOptions.ecmaVersion = normalizeEcmaVersion(parser, mergedParserOptions.ecmaVersion);
      return mergedParserOptions;
    }
    function createLanguageOptions({ globals: configuredGlobals, parser, parserOptions }) {
      const {
        ecmaVersion,
        sourceType
      } = parserOptions;
      return {
        globals: configuredGlobals,
        ecmaVersion: normalizeEcmaVersionForLanguageOptions(ecmaVersion),
        sourceType,
        parser,
        parserOptions
      };
    }
    function resolveGlobals(providedGlobals, enabledEnvironments) {
      return Object.assign(
        {},
        ...enabledEnvironments.filter((env) => env.globals).map((env) => env.globals),
        providedGlobals
      );
    }
    function stripUnicodeBOM(text) {
      if (text.charCodeAt(0) === 65279) {
        return text.slice(1);
      }
      return text;
    }
    function getRuleOptions(ruleConfig) {
      if (Array.isArray(ruleConfig)) {
        return ruleConfig.slice(1);
      }
      return [];
    }
    function analyzeScope(ast, languageOptions, visitorKeys) {
      const parserOptions = languageOptions.parserOptions;
      const ecmaFeatures = parserOptions.ecmaFeatures || {};
      const ecmaVersion = languageOptions.ecmaVersion || DEFAULT_ECMA_VERSION;
      return eslintScope.analyze(ast, {
        ignoreEval: true,
        nodejsScope: ecmaFeatures.globalReturn,
        impliedStrict: ecmaFeatures.impliedStrict,
        ecmaVersion: typeof ecmaVersion === "number" ? ecmaVersion : 6,
        sourceType: languageOptions.sourceType || "script",
        childVisitorKeys: visitorKeys || evk.KEYS,
        fallback: Traverser.getKeys
      });
    }
    function parse(text, languageOptions, filePath) {
      const textToParse = stripUnicodeBOM(text).replace(astUtils.shebangPattern, (match, captured) => `//${captured}`);
      const { ecmaVersion, sourceType, parser } = languageOptions;
      const parserOptions = Object.assign(
        { ecmaVersion, sourceType },
        languageOptions.parserOptions,
        {
          loc: true,
          range: true,
          raw: true,
          tokens: true,
          comment: true,
          eslintVisitorKeys: true,
          eslintScopeManager: true,
          filePath
        }
      );
      try {
        debug("Parsing:", filePath);
        const parseResult = typeof parser.parseForESLint === "function" ? parser.parseForESLint(textToParse, parserOptions) : { ast: parser.parse(textToParse, parserOptions) };
        debug("Parsing successful:", filePath);
        const ast = parseResult.ast;
        const parserServices = parseResult.services || {};
        const visitorKeys = parseResult.visitorKeys || evk.KEYS;
        debug("Scope analysis:", filePath);
        const scopeManager = parseResult.scopeManager || analyzeScope(ast, languageOptions, visitorKeys);
        debug("Scope analysis successful:", filePath);
        return {
          success: true,
          /*
           * Save all values that `parseForESLint()` returned.
           * If a `SourceCode` object is given as the first parameter instead of source code text,
           * linter skips the parsing process and reuses the source code object.
           * In that case, linter needs all the values that `parseForESLint()` returned.
           */
          sourceCode: new SourceCode({
            text,
            ast,
            parserServices,
            scopeManager,
            visitorKeys
          })
        };
      } catch (ex) {
        const message = `Parsing error: ${ex.message.replace(/^line \d+:/iu, "").trim()}`;
        debug("%s\n%s", message, ex.stack);
        return {
          success: false,
          error: {
            ruleId: null,
            fatal: true,
            severity: 2,
            message,
            line: ex.lineNumber,
            column: ex.column,
            nodeType: null
          }
        };
      }
    }
    function createRuleListeners(rule, ruleContext) {
      try {
        return rule.create(ruleContext);
      } catch (ex) {
        ex.message = `Error while loading rule '${ruleContext.id}': ${ex.message}`;
        throw ex;
      }
    }
    var DEPRECATED_SOURCECODE_PASSTHROUGHS = {
      getSource: "getText",
      getSourceLines: "getLines",
      getAllComments: "getAllComments",
      getNodeByRangeIndex: "getNodeByRangeIndex",
      getComments: "getComments",
      getCommentsBefore: "getCommentsBefore",
      getCommentsAfter: "getCommentsAfter",
      getCommentsInside: "getCommentsInside",
      getJSDocComment: "getJSDocComment",
      getFirstToken: "getFirstToken",
      getFirstTokens: "getFirstTokens",
      getLastToken: "getLastToken",
      getLastTokens: "getLastTokens",
      getTokenAfter: "getTokenAfter",
      getTokenBefore: "getTokenBefore",
      getTokenByRangeStart: "getTokenByRangeStart",
      getTokens: "getTokens",
      getTokensAfter: "getTokensAfter",
      getTokensBefore: "getTokensBefore",
      getTokensBetween: "getTokensBetween"
    };
    var BASE_TRAVERSAL_CONTEXT = Object.freeze(
      Object.keys(DEPRECATED_SOURCECODE_PASSTHROUGHS).reduce(
        (contextInfo, methodName) => Object.assign(contextInfo, {
          [methodName](...args) {
            return this.sourceCode[DEPRECATED_SOURCECODE_PASSTHROUGHS[methodName]](...args);
          }
        }),
        {}
      )
    );
    function runRules(sourceCode, configuredRules, ruleMapper, parserName, languageOptions, settings, filename, disableFixes, cwd, physicalFilename) {
      const emitter = createEmitter();
      const nodeQueue = [];
      let currentNode = sourceCode.ast;
      Traverser.traverse(sourceCode.ast, {
        enter(node, parent) {
          node.parent = parent;
          nodeQueue.push({ isEntering: true, node });
        },
        leave(node) {
          nodeQueue.push({ isEntering: false, node });
        },
        visitorKeys: sourceCode.visitorKeys
      });
      const sharedTraversalContext = Object.freeze(
        Object.assign(
          Object.create(BASE_TRAVERSAL_CONTEXT),
          {
            getAncestors: () => sourceCode.getAncestors(currentNode),
            getDeclaredVariables: (node) => sourceCode.getDeclaredVariables(node),
            getCwd: () => cwd,
            cwd,
            getFilename: () => filename,
            filename,
            getPhysicalFilename: () => physicalFilename || filename,
            physicalFilename: physicalFilename || filename,
            getScope: () => sourceCode.getScope(currentNode),
            getSourceCode: () => sourceCode,
            sourceCode,
            markVariableAsUsed: (name) => sourceCode.markVariableAsUsed(name, currentNode),
            parserOptions: {
              ...languageOptions.parserOptions
            },
            parserPath: parserName,
            languageOptions,
            parserServices: sourceCode.parserServices,
            settings
          }
        )
      );
      const lintingProblems = [];
      Object.keys(configuredRules).forEach((ruleId) => {
        const severity = ConfigOps.getRuleSeverity(configuredRules[ruleId]);
        if (severity === 0) {
          return;
        }
        const rule = ruleMapper(ruleId);
        if (!rule) {
          lintingProblems.push(createLintingProblem({ ruleId }));
          return;
        }
        const messageIds = rule.meta && rule.meta.messages;
        let reportTranslator = null;
        const ruleContext = Object.freeze(
          Object.assign(
            Object.create(sharedTraversalContext),
            {
              id: ruleId,
              options: getRuleOptions(configuredRules[ruleId]),
              report(...args) {
                if (reportTranslator === null) {
                  reportTranslator = createReportTranslator({
                    ruleId,
                    severity,
                    sourceCode,
                    messageIds,
                    disableFixes
                  });
                }
                const problem = reportTranslator(...args);
                if (problem.fix && !(rule.meta && rule.meta.fixable)) {
                  throw new Error('Fixable rules must set the `meta.fixable` property to "code" or "whitespace".');
                }
                if (problem.suggestions && !(rule.meta && rule.meta.hasSuggestions === true)) {
                  if (rule.meta && rule.meta.docs && typeof rule.meta.docs.suggestion !== "undefined") {
                    throw new Error("Rules with suggestions must set the `meta.hasSuggestions` property to `true`. `meta.docs.suggestion` is ignored by ESLint.");
                  }
                  throw new Error("Rules with suggestions must set the `meta.hasSuggestions` property to `true`.");
                }
                lintingProblems.push(problem);
              }
            }
          )
        );
        const ruleListeners = timing.enabled ? timing.time(ruleId, createRuleListeners)(rule, ruleContext) : createRuleListeners(rule, ruleContext);
        function addRuleErrorHandler(ruleListener) {
          return function ruleErrorHandler(...listenerArgs) {
            try {
              return ruleListener(...listenerArgs);
            } catch (e) {
              e.ruleId = ruleId;
              throw e;
            }
          };
        }
        if (typeof ruleListeners === "undefined" || ruleListeners === null) {
          throw new Error(`The create() function for rule '${ruleId}' did not return an object.`);
        }
        Object.keys(ruleListeners).forEach((selector) => {
          const ruleListener = timing.enabled ? timing.time(ruleId, ruleListeners[selector]) : ruleListeners[selector];
          emitter.on(
            selector,
            addRuleErrorHandler(ruleListener)
          );
        });
      });
      const eventGenerator = nodeQueue[0].node.type === "Program" ? new CodePathAnalyzer(new NodeEventGenerator(emitter, { visitorKeys: sourceCode.visitorKeys, fallback: Traverser.getKeys })) : new NodeEventGenerator(emitter, { visitorKeys: sourceCode.visitorKeys, fallback: Traverser.getKeys });
      nodeQueue.forEach((traversalInfo) => {
        currentNode = traversalInfo.node;
        try {
          if (traversalInfo.isEntering) {
            eventGenerator.enterNode(currentNode);
          } else {
            eventGenerator.leaveNode(currentNode);
          }
        } catch (err) {
          err.currentNode = currentNode;
          throw err;
        }
      });
      return lintingProblems;
    }
    function ensureText(textOrSourceCode) {
      if (typeof textOrSourceCode === "object") {
        const { hasBOM, text } = textOrSourceCode;
        const bom = hasBOM ? "\uFEFF" : "";
        return bom + text;
      }
      return String(textOrSourceCode);
    }
    function getEnv(slots, envId) {
      return slots.lastConfigArray && slots.lastConfigArray.pluginEnvironments.get(envId) || BuiltInEnvironments.get(envId) || null;
    }
    function getRule(slots, ruleId) {
      return slots.lastConfigArray && slots.lastConfigArray.pluginRules.get(ruleId) || slots.ruleMap.get(ruleId);
    }
    function normalizeCwd(cwd) {
      if (cwd) {
        return cwd;
      }
      if (typeof process === "object") {
        return process.cwd();
      }
      return void 0;
    }
    var internalSlotsMap = /* @__PURE__ */ new WeakMap();
    function assertEslintrcConfig(linter) {
      const { configType } = internalSlotsMap.get(linter);
      if (configType === "flat") {
        throw new Error("This method cannot be used with flat config. Add your entries directly into the config array.");
      }
    }
    var Linter2 = class {
      /**
       * Initialize the Linter.
       * @param {Object} [config] the config object
       * @param {string} [config.cwd] path to a directory that should be considered as the current working directory, can be undefined.
       * @param {"flat"|"eslintrc"} [config.configType="eslintrc"] the type of config used.
       */
      constructor({ cwd, configType } = {}) {
        internalSlotsMap.set(this, {
          cwd: normalizeCwd(cwd),
          lastConfigArray: null,
          lastSourceCode: null,
          lastSuppressedMessages: [],
          configType,
          // TODO: Remove after flat config conversion
          parserMap: /* @__PURE__ */ new Map([["espree", espree]]),
          ruleMap: new Rules()
        });
        this.version = pkg.version;
      }
      /**
       * Getter for package version.
       * @static
       * @returns {string} The version from package.json.
       */
      static get version() {
        return pkg.version;
      }
      /**
       * Same as linter.verify, except without support for processors.
       * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.
       * @param {ConfigData} providedConfig An ESLintConfig instance to configure everything.
       * @param {VerifyOptions} [providedOptions] The optional filename of the file being checked.
       * @throws {Error} If during rule execution.
       * @returns {(LintMessage|SuppressedLintMessage)[]} The results as an array of messages or an empty array if no messages.
       */
      _verifyWithoutProcessors(textOrSourceCode, providedConfig, providedOptions) {
        const slots = internalSlotsMap.get(this);
        const config = providedConfig || {};
        const options = normalizeVerifyOptions(providedOptions, config);
        let text;
        if (typeof textOrSourceCode === "string") {
          slots.lastSourceCode = null;
          text = textOrSourceCode;
        } else {
          slots.lastSourceCode = textOrSourceCode;
          text = textOrSourceCode.text;
        }
        let parserName = DEFAULT_PARSER_NAME;
        let parser = espree;
        if (typeof config.parser === "object" && config.parser !== null) {
          parserName = config.parser.filePath;
          parser = config.parser.definition;
        } else if (typeof config.parser === "string") {
          if (!slots.parserMap.has(config.parser)) {
            return [{
              ruleId: null,
              fatal: true,
              severity: 2,
              message: `Configured parser '${config.parser}' was not found.`,
              line: 0,
              column: 0,
              nodeType: null
            }];
          }
          parserName = config.parser;
          parser = slots.parserMap.get(config.parser);
        }
        const envInFile = options.allowInlineConfig && !options.warnInlineConfig ? findEslintEnv(text) : {};
        const resolvedEnvConfig = Object.assign({ builtin: true }, config.env, envInFile);
        const enabledEnvs = Object.keys(resolvedEnvConfig).filter((envName) => resolvedEnvConfig[envName]).map((envName) => getEnv(slots, envName)).filter((env) => env);
        const parserOptions = resolveParserOptions(parser, config.parserOptions || {}, enabledEnvs);
        const configuredGlobals = resolveGlobals(config.globals || {}, enabledEnvs);
        const settings = config.settings || {};
        const languageOptions = createLanguageOptions({
          globals: config.globals,
          parser,
          parserOptions
        });
        if (!slots.lastSourceCode) {
          const parseResult = parse(
            text,
            languageOptions,
            options.filename
          );
          if (!parseResult.success) {
            return [parseResult.error];
          }
          slots.lastSourceCode = parseResult.sourceCode;
        } else {
          if (!slots.lastSourceCode.scopeManager) {
            slots.lastSourceCode = new SourceCode({
              text: slots.lastSourceCode.text,
              ast: slots.lastSourceCode.ast,
              parserServices: slots.lastSourceCode.parserServices,
              visitorKeys: slots.lastSourceCode.visitorKeys,
              scopeManager: analyzeScope(slots.lastSourceCode.ast, languageOptions)
            });
          }
        }
        const sourceCode = slots.lastSourceCode;
        const commentDirectives = options.allowInlineConfig ? getDirectiveComments(sourceCode.ast, (ruleId) => getRule(slots, ruleId), options.warnInlineConfig) : { configuredRules: {}, enabledGlobals: {}, exportedVariables: {}, problems: [], disableDirectives: [] };
        addDeclaredGlobals(
          sourceCode.scopeManager.scopes[0],
          configuredGlobals,
          { exportedVariables: commentDirectives.exportedVariables, enabledGlobals: commentDirectives.enabledGlobals }
        );
        const configuredRules = Object.assign({}, config.rules, commentDirectives.configuredRules);
        let lintingProblems;
        try {
          lintingProblems = runRules(
            sourceCode,
            configuredRules,
            (ruleId) => getRule(slots, ruleId),
            parserName,
            languageOptions,
            settings,
            options.filename,
            options.disableFixes,
            slots.cwd,
            providedOptions.physicalFilename
          );
        } catch (err) {
          err.message += `
Occurred while linting ${options.filename}`;
          debug("An error occurred while traversing");
          debug("Filename:", options.filename);
          if (err.currentNode) {
            const { line } = err.currentNode.loc.start;
            debug("Line:", line);
            err.message += `:${line}`;
          }
          debug("Parser Options:", parserOptions);
          debug("Parser Path:", parserName);
          debug("Settings:", settings);
          if (err.ruleId) {
            err.message += `
Rule: "${err.ruleId}"`;
          }
          throw err;
        }
        return applyDisableDirectives({
          directives: commentDirectives.disableDirectives,
          disableFixes: options.disableFixes,
          problems: lintingProblems.concat(commentDirectives.problems).sort((problemA, problemB) => problemA.line - problemB.line || problemA.column - problemB.column),
          reportUnusedDisableDirectives: options.reportUnusedDisableDirectives
        });
      }
      /**
       * Verifies the text against the rules specified by the second argument.
       * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.
       * @param {ConfigData|ConfigArray} config An ESLintConfig instance to configure everything.
       * @param {(string|(VerifyOptions&ProcessorOptions))} [filenameOrOptions] The optional filename of the file being checked.
       *      If this is not set, the filename will default to '<input>' in the rule context. If
       *      an object, then it has "filename", "allowInlineConfig", and some properties.
       * @returns {LintMessage[]} The results as an array of messages or an empty array if no messages.
       */
      verify(textOrSourceCode, config, filenameOrOptions) {
        debug("Verify");
        const { configType } = internalSlotsMap.get(this);
        const options = typeof filenameOrOptions === "string" ? { filename: filenameOrOptions } : filenameOrOptions || {};
        if (config) {
          if (configType === "flat") {
            let configArray = config;
            if (!Array.isArray(config) || typeof config.getConfig !== "function") {
              configArray = new FlatConfigArray(config);
              configArray.normalizeSync();
            }
            return this._distinguishSuppressedMessages(this._verifyWithFlatConfigArray(textOrSourceCode, configArray, options, true));
          }
          if (typeof config.extractConfig === "function") {
            return this._distinguishSuppressedMessages(this._verifyWithConfigArray(textOrSourceCode, config, options));
          }
        }
        if (options.preprocess || options.postprocess) {
          return this._distinguishSuppressedMessages(this._verifyWithProcessor(textOrSourceCode, config, options));
        }
        return this._distinguishSuppressedMessages(this._verifyWithoutProcessors(textOrSourceCode, config, options));
      }
      /**
       * Verify with a processor.
       * @param {string|SourceCode} textOrSourceCode The source code.
       * @param {FlatConfig} config The config array.
       * @param {VerifyOptions&ProcessorOptions} options The options.
       * @param {FlatConfigArray} [configForRecursive] The `ConfigArray` object to apply multiple processors recursively.
       * @returns {(LintMessage|SuppressedLintMessage)[]} The found problems.
       */
      _verifyWithFlatConfigArrayAndProcessor(textOrSourceCode, config, options, configForRecursive) {
        const filename = options.filename || "<input>";
        const filenameToExpose = normalizeFilename(filename);
        const physicalFilename = options.physicalFilename || filenameToExpose;
        const text = ensureText(textOrSourceCode);
        const preprocess = options.preprocess || ((rawText) => [rawText]);
        const postprocess = options.postprocess || ((messagesList) => messagesList.flat());
        const filterCodeBlock = options.filterCodeBlock || ((blockFilename) => blockFilename.endsWith(".js"));
        const originalExtname = path.extname(filename);
        let blocks;
        try {
          blocks = preprocess(text, filenameToExpose);
        } catch (ex) {
          const message = `Preprocessing error: ${ex.message.replace(/^line \d+:/iu, "").trim()}`;
          debug("%s\n%s", message, ex.stack);
          return [
            {
              ruleId: null,
              fatal: true,
              severity: 2,
              message,
              line: ex.lineNumber,
              column: ex.column,
              nodeType: null
            }
          ];
        }
        const messageLists = blocks.map((block, i) => {
          debug("A code block was found: %o", block.filename || "(unnamed)");
          if (typeof block === "string") {
            return this._verifyWithFlatConfigArrayAndWithoutProcessors(block, config, options);
          }
          const blockText = block.text;
          const blockName = path.join(filename, `${i}_${block.filename}`);
          if (!filterCodeBlock(blockName, blockText)) {
            debug("This code block was skipped.");
            return [];
          }
          if (configForRecursive && (text !== blockText || path.extname(blockName) !== originalExtname)) {
            debug("Resolving configuration again because the file content or extension was changed.");
            return this._verifyWithFlatConfigArray(
              blockText,
              configForRecursive,
              { ...options, filename: blockName, physicalFilename }
            );
          }
          return this._verifyWithFlatConfigArrayAndWithoutProcessors(
            blockText,
            config,
            { ...options, filename: blockName, physicalFilename }
          );
        });
        return postprocess(messageLists, filenameToExpose);
      }
      /**
       * Same as linter.verify, except without support for processors.
       * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.
       * @param {FlatConfig} providedConfig An ESLintConfig instance to configure everything.
       * @param {VerifyOptions} [providedOptions] The optional filename of the file being checked.
       * @throws {Error} If during rule execution.
       * @returns {(LintMessage|SuppressedLintMessage)[]} The results as an array of messages or an empty array if no messages.
       */
      _verifyWithFlatConfigArrayAndWithoutProcessors(textOrSourceCode, providedConfig, providedOptions) {
        const slots = internalSlotsMap.get(this);
        const config = providedConfig || {};
        const options = normalizeVerifyOptions(providedOptions, config);
        let text;
        if (typeof textOrSourceCode === "string") {
          slots.lastSourceCode = null;
          text = textOrSourceCode;
        } else {
          slots.lastSourceCode = textOrSourceCode;
          text = textOrSourceCode.text;
        }
        const languageOptions = config.languageOptions;
        languageOptions.ecmaVersion = normalizeEcmaVersionForLanguageOptions(
          languageOptions.ecmaVersion
        );
        const configuredGlobals = Object.assign(
          {},
          getGlobalsForEcmaVersion(languageOptions.ecmaVersion),
          languageOptions.sourceType === "commonjs" ? globals.commonjs : void 0,
          languageOptions.globals
        );
        if (!languageOptions.parser) {
          throw new TypeError(`No parser specified for ${options.filename}`);
        }
        if (isEspree(languageOptions.parser)) {
          const parserOptions = languageOptions.parserOptions;
          if (languageOptions.sourceType) {
            parserOptions.sourceType = languageOptions.sourceType;
            if (parserOptions.sourceType === "module" && parserOptions.ecmaFeatures && parserOptions.ecmaFeatures.globalReturn) {
              parserOptions.ecmaFeatures.globalReturn = false;
            }
          }
        }
        const settings = config.settings || {};
        if (!slots.lastSourceCode) {
          const parseResult = parse(
            text,
            languageOptions,
            options.filename
          );
          if (!parseResult.success) {
            return [parseResult.error];
          }
          slots.lastSourceCode = parseResult.sourceCode;
        } else {
          if (!slots.lastSourceCode.scopeManager) {
            slots.lastSourceCode = new SourceCode({
              text: slots.lastSourceCode.text,
              ast: slots.lastSourceCode.ast,
              parserServices: slots.lastSourceCode.parserServices,
              visitorKeys: slots.lastSourceCode.visitorKeys,
              scopeManager: analyzeScope(slots.lastSourceCode.ast, languageOptions)
            });
          }
        }
        const sourceCode = slots.lastSourceCode;
        const commentDirectives = options.allowInlineConfig ? getDirectiveComments(
          sourceCode.ast,
          (ruleId) => getRuleFromConfig(ruleId, config),
          options.warnInlineConfig
        ) : { configuredRules: {}, enabledGlobals: {}, exportedVariables: {}, problems: [], disableDirectives: [] };
        addDeclaredGlobals(
          sourceCode.scopeManager.scopes[0],
          configuredGlobals,
          { exportedVariables: commentDirectives.exportedVariables, enabledGlobals: commentDirectives.enabledGlobals }
        );
        const configuredRules = Object.assign({}, config.rules, commentDirectives.configuredRules);
        let lintingProblems;
        try {
          lintingProblems = runRules(
            sourceCode,
            configuredRules,
            (ruleId) => getRuleFromConfig(ruleId, config),
            void 0,
            languageOptions,
            settings,
            options.filename,
            options.disableFixes,
            slots.cwd,
            providedOptions.physicalFilename
          );
        } catch (err) {
          err.message += `
Occurred while linting ${options.filename}`;
          debug("An error occurred while traversing");
          debug("Filename:", options.filename);
          if (err.currentNode) {
            const { line } = err.currentNode.loc.start;
            debug("Line:", line);
            err.message += `:${line}`;
          }
          debug("Parser Options:", languageOptions.parserOptions);
          debug("Settings:", settings);
          if (err.ruleId) {
            err.message += `
Rule: "${err.ruleId}"`;
          }
          throw err;
        }
        return applyDisableDirectives({
          directives: commentDirectives.disableDirectives,
          disableFixes: options.disableFixes,
          problems: lintingProblems.concat(commentDirectives.problems).sort((problemA, problemB) => problemA.line - problemB.line || problemA.column - problemB.column),
          reportUnusedDisableDirectives: options.reportUnusedDisableDirectives
        });
      }
      /**
       * Verify a given code with `ConfigArray`.
       * @param {string|SourceCode} textOrSourceCode The source code.
       * @param {ConfigArray} configArray The config array.
       * @param {VerifyOptions&ProcessorOptions} options The options.
       * @returns {(LintMessage|SuppressedLintMessage)[]} The found problems.
       */
      _verifyWithConfigArray(textOrSourceCode, configArray, options) {
        debug("With ConfigArray: %s", options.filename);
        internalSlotsMap.get(this).lastConfigArray = configArray;
        const config = configArray.extractConfig(options.filename);
        const processor = config.processor && configArray.pluginProcessors.get(config.processor);
        if (processor) {
          debug("Apply the processor: %o", config.processor);
          const { preprocess, postprocess, supportsAutofix } = processor;
          const disableFixes = options.disableFixes || !supportsAutofix;
          return this._verifyWithProcessor(
            textOrSourceCode,
            config,
            { ...options, disableFixes, postprocess, preprocess },
            configArray
          );
        }
        return this._verifyWithoutProcessors(textOrSourceCode, config, options);
      }
      /**
       * Verify a given code with a flat config.
       * @param {string|SourceCode} textOrSourceCode The source code.
       * @param {FlatConfigArray} configArray The config array.
       * @param {VerifyOptions&ProcessorOptions} options The options.
       * @param {boolean} [firstCall=false] Indicates if this is being called directly
       *      from verify(). (TODO: Remove once eslintrc is removed.)
       * @returns {(LintMessage|SuppressedLintMessage)[]} The found problems.
       */
      _verifyWithFlatConfigArray(textOrSourceCode, configArray, options, firstCall = false) {
        debug("With flat config: %s", options.filename);
        const filename = options.filename || "__placeholder__.js";
        internalSlotsMap.get(this).lastConfigArray = configArray;
        const config = configArray.getConfig(filename);
        if (!config) {
          return [
            {
              ruleId: null,
              severity: 1,
              message: `No matching configuration found for ${filename}.`,
              line: 0,
              column: 0,
              nodeType: null
            }
          ];
        }
        if (config.processor) {
          debug("Apply the processor: %o", config.processor);
          const { preprocess, postprocess, supportsAutofix } = config.processor;
          const disableFixes = options.disableFixes || !supportsAutofix;
          return this._verifyWithFlatConfigArrayAndProcessor(
            textOrSourceCode,
            config,
            { ...options, filename, disableFixes, postprocess, preprocess },
            configArray
          );
        }
        if (firstCall && (options.preprocess || options.postprocess)) {
          return this._verifyWithFlatConfigArrayAndProcessor(textOrSourceCode, config, options);
        }
        return this._verifyWithFlatConfigArrayAndWithoutProcessors(textOrSourceCode, config, options);
      }
      /**
       * Verify with a processor.
       * @param {string|SourceCode} textOrSourceCode The source code.
       * @param {ConfigData|ExtractedConfig} config The config array.
       * @param {VerifyOptions&ProcessorOptions} options The options.
       * @param {ConfigArray} [configForRecursive] The `ConfigArray` object to apply multiple processors recursively.
       * @returns {(LintMessage|SuppressedLintMessage)[]} The found problems.
       */
      _verifyWithProcessor(textOrSourceCode, config, options, configForRecursive) {
        const filename = options.filename || "<input>";
        const filenameToExpose = normalizeFilename(filename);
        const physicalFilename = options.physicalFilename || filenameToExpose;
        const text = ensureText(textOrSourceCode);
        const preprocess = options.preprocess || ((rawText) => [rawText]);
        const postprocess = options.postprocess || ((messagesList) => messagesList.flat());
        const filterCodeBlock = options.filterCodeBlock || ((blockFilename) => blockFilename.endsWith(".js"));
        const originalExtname = path.extname(filename);
        let blocks;
        try {
          blocks = preprocess(text, filenameToExpose);
        } catch (ex) {
          const message = `Preprocessing error: ${ex.message.replace(/^line \d+:/iu, "").trim()}`;
          debug("%s\n%s", message, ex.stack);
          return [
            {
              ruleId: null,
              fatal: true,
              severity: 2,
              message,
              line: ex.lineNumber,
              column: ex.column,
              nodeType: null
            }
          ];
        }
        const messageLists = blocks.map((block, i) => {
          debug("A code block was found: %o", block.filename || "(unnamed)");
          if (typeof block === "string") {
            return this._verifyWithoutProcessors(block, config, options);
          }
          const blockText = block.text;
          const blockName = path.join(filename, `${i}_${block.filename}`);
          if (!filterCodeBlock(blockName, blockText)) {
            debug("This code block was skipped.");
            return [];
          }
          if (configForRecursive && (text !== blockText || path.extname(blockName) !== originalExtname)) {
            debug("Resolving configuration again because the file content or extension was changed.");
            return this._verifyWithConfigArray(
              blockText,
              configForRecursive,
              { ...options, filename: blockName, physicalFilename }
            );
          }
          return this._verifyWithoutProcessors(
            blockText,
            config,
            { ...options, filename: blockName, physicalFilename }
          );
        });
        return postprocess(messageLists, filenameToExpose);
      }
      /**
       * Given a list of reported problems, distinguish problems between normal messages and suppressed messages.
       * The normal messages will be returned and the suppressed messages will be stored as lastSuppressedMessages.
       * @param {Array<LintMessage|SuppressedLintMessage>} problems A list of reported problems.
       * @returns {LintMessage[]} A list of LintMessage.
       */
      _distinguishSuppressedMessages(problems) {
        const messages = [];
        const suppressedMessages = [];
        const slots = internalSlotsMap.get(this);
        for (const problem of problems) {
          if (problem.suppressions) {
            suppressedMessages.push(problem);
          } else {
            messages.push(problem);
          }
        }
        slots.lastSuppressedMessages = suppressedMessages;
        return messages;
      }
      /**
       * Gets the SourceCode object representing the parsed source.
       * @returns {SourceCode} The SourceCode object.
       */
      getSourceCode() {
        return internalSlotsMap.get(this).lastSourceCode;
      }
      /**
       * Gets the list of SuppressedLintMessage produced in the last running.
       * @returns {SuppressedLintMessage[]} The list of SuppressedLintMessage
       */
      getSuppressedMessages() {
        return internalSlotsMap.get(this).lastSuppressedMessages;
      }
      /**
       * Defines a new linting rule.
       * @param {string} ruleId A unique rule identifier
       * @param {Function | Rule} ruleModule Function from context to object mapping AST node types to event handlers
       * @returns {void}
       */
      defineRule(ruleId, ruleModule) {
        assertEslintrcConfig(this);
        internalSlotsMap.get(this).ruleMap.define(ruleId, ruleModule);
      }
      /**
       * Defines many new linting rules.
       * @param {Record<string, Function | Rule>} rulesToDefine map from unique rule identifier to rule
       * @returns {void}
       */
      defineRules(rulesToDefine) {
        assertEslintrcConfig(this);
        Object.getOwnPropertyNames(rulesToDefine).forEach((ruleId) => {
          this.defineRule(ruleId, rulesToDefine[ruleId]);
        });
      }
      /**
       * Gets an object with all loaded rules.
       * @returns {Map<string, Rule>} All loaded rules
       */
      getRules() {
        assertEslintrcConfig(this);
        const { lastConfigArray, ruleMap } = internalSlotsMap.get(this);
        return new Map(function* () {
          yield* ruleMap;
          if (lastConfigArray) {
            yield* lastConfigArray.pluginRules;
          }
        }());
      }
      /**
       * Define a new parser module
       * @param {string} parserId Name of the parser
       * @param {Parser} parserModule The parser object
       * @returns {void}
       */
      defineParser(parserId, parserModule) {
        assertEslintrcConfig(this);
        internalSlotsMap.get(this).parserMap.set(parserId, parserModule);
      }
      /**
       * Performs multiple autofix passes over the text until as many fixes as possible
       * have been applied.
       * @param {string} text The source text to apply fixes to.
       * @param {ConfigData|ConfigArray|FlatConfigArray} config The ESLint config object to use.
       * @param {VerifyOptions&ProcessorOptions&FixOptions} options The ESLint options object to use.
       * @returns {{fixed:boolean,messages:LintMessage[],output:string}} The result of the fix operation as returned from the
       *      SourceCodeFixer.
       */
      verifyAndFix(text, config, options) {
        let messages = [], fixedResult, fixed = false, passNumber = 0, currentText = text;
        const debugTextDescription = options && options.filename || `${text.slice(0, 10)}...`;
        const shouldFix = options && typeof options.fix !== "undefined" ? options.fix : true;
        do {
          passNumber++;
          debug(`Linting code for ${debugTextDescription} (pass ${passNumber})`);
          messages = this.verify(currentText, config, options);
          debug(`Generating fixed text for ${debugTextDescription} (pass ${passNumber})`);
          fixedResult = SourceCodeFixer.applyFixes(currentText, messages, shouldFix);
          if (messages.length === 1 && messages[0].fatal) {
            break;
          }
          fixed = fixed || fixedResult.fixed;
          currentText = fixedResult.output;
        } while (fixedResult.fixed && passNumber < MAX_AUTOFIX_PASSES);
        if (fixedResult.fixed) {
          fixedResult.messages = this.verify(currentText, config, options);
        }
        fixedResult.fixed = fixed;
        fixedResult.output = currentText;
        return fixedResult;
      }
    };
    module.exports = {
      Linter: Linter2,
      /**
       * Get the internal slots of a given Linter instance for tests.
       * @param {Linter} instance The Linter instance to get.
       * @returns {LinterInternalSlots} The internal slots.
       */
      getLinterInternalSlots(instance) {
        return internalSlotsMap.get(instance);
      }
    };
  }
});

// src/index.js
var import_linter = __toESM(require_linter(), 1);
var export_Linter = import_linter.Linter;
export {
  export_Linter as Linter
};
/*! Bundled license information:

assert/build/internal/util/comparisons.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)

uri-js/dist/es5/uri.all.js:
  (** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js *)

eslint/lib/rules/utils/patterns/letters.js:
  (**
   * @fileoverview Pattern for detecting any letter (even letters outside of ASCII).
   * NOTE: This file was generated using this script in JSCS based on the Unicode 7.0.0 standard: https://github.com/jscs-dev/node-jscs/blob/f5ed14427deb7e7aac84f3056a5aab2d9f3e563e/publish/helpers/generate-patterns.js
   * Do not edit this file by hand-- please use https://github.com/mathiasbynens/regenerate to regenerate the regular expression exported from this file.
   * @author Kevin Partington
   * @license MIT License (from JSCS). See below.
   *)

natural-compare/index.js:
  (*
   * @version    1.4.0
   * @date       2015-10-26
   * @stability  3 - Stable
   * @author     Lauri Rooden (https://github.com/litejs/natural-compare-lite)
   * @license    MIT License
   *)
*/
