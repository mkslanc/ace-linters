{"version":3,"file":"bundle.6922.js","mappings":"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","sources":["webpack://ace-linters-root/./packages/ace-linters/build/lua-service.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(self, () => {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 7438:\n/***/ (function(module, exports, __webpack_require__) {\n\n/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* global exports:true, module:true, require:true, define:true, global:true */\n\n(function (root, name, factory) {\n  'use strict';\n\n  // Used to determine if values are of the language type `Object`\n  var objectTypes = {\n        'function': true\n      , 'object': true\n    }\n    // Detect free variable `exports`\n    , freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports\n    // Detect free variable `module`\n    , freeModule = objectTypes[\"object\"] && module && !module.nodeType && module\n    // Detect free variable `global`, from Node.js or Browserified code, and\n    // use it as `window`\n    , freeGlobal = freeExports && freeModule && typeof __webpack_require__.g === 'object' && __webpack_require__.g\n    // Detect the popular CommonJS extension `module.exports`\n    , moduleExports = freeModule && freeModule.exports === freeExports && freeExports;\n\n  /* istanbul ignore else */\n  if (freeGlobal && (freeGlobal.global === freeGlobal ||\n                     /* istanbul ignore next */ freeGlobal.window === freeGlobal ||\n                     /* istanbul ignore next */ freeGlobal.self === freeGlobal)) {\n    root = freeGlobal;\n  }\n\n  // Some AMD build optimizers, like r.js, check for specific condition\n  // patterns like the following:\n  /* istanbul ignore if */\n  if (true) {\n    // defined as an anonymous module.\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    // In case the source has been processed and wrapped in a define module use\n    // the supplied `exports` object.\n    if (freeExports && moduleExports) factory(freeModule.exports);\n  }\n  // check for `exports` after `define` in case a build optimizer adds an\n  // `exports` object\n  else /* istanbul ignore else */ {}\n}(this, 'luaparse', function (exports) {\n  'use strict';\n\n  exports.version = \"0.3.1\";\n\n  var input, options, length, features, encodingMode;\n\n  // Options can be set either globally on the parser object through\n  // defaultOptions, or during the parse call.\n  var defaultOptions = exports.defaultOptions = {\n    // Explicitly tell the parser when the input ends.\n      wait: false\n    // Store comments as an array in the chunk object.\n    , comments: true\n    // Track identifier scopes by adding an isLocal attribute to each\n    // identifier-node.\n    , scope: false\n    // Store location information on each syntax node as\n    // `loc: { start: { line, column }, end: { line, column } }`.\n    , locations: false\n    // Store the start and end character locations on each syntax node as\n    // `range: [start, end]`.\n    , ranges: false\n    // A callback which will be invoked when a syntax node has been completed.\n    // The node which has been created will be passed as the only parameter.\n    , onCreateNode: null\n    // A callback which will be invoked when a new scope is created.\n    , onCreateScope: null\n    // A callback which will be invoked when the current scope is destroyed.\n    , onDestroyScope: null\n    // A callback which will be invoked when a local variable is declared in the current scope.\n    // The variable's name will be passed as the only parameter\n    , onLocalDeclaration: null\n    // The version of Lua targeted by the parser (string; allowed values are\n    // '5.1', '5.2', '5.3').\n    , luaVersion: '5.1'\n    // Encoding mode: how to interpret code units higher than U+007F in input\n    , encodingMode: 'none'\n  };\n\n  function encodeUTF8(codepoint, highMask) {\n    highMask = highMask || 0;\n\n    if (codepoint < 0x80) {\n      return String.fromCharCode(codepoint);\n    } else if (codepoint < 0x800) {\n      return String.fromCharCode(\n        highMask | 0xc0 |  (codepoint >>  6)        ,\n        highMask | 0x80 | ( codepoint        & 0x3f)\n      );\n    } else if (codepoint < 0x10000) {\n      return String.fromCharCode(\n        highMask | 0xe0 |  (codepoint >> 12)        ,\n        highMask | 0x80 | ((codepoint >>  6) & 0x3f),\n        highMask | 0x80 | ( codepoint        & 0x3f)\n      );\n    } else /* istanbul ignore else */ if (codepoint < 0x110000) {\n      return String.fromCharCode(\n        highMask | 0xf0 |  (codepoint >> 18)        ,\n        highMask | 0x80 | ((codepoint >> 12) & 0x3f),\n        highMask | 0x80 | ((codepoint >>  6) & 0x3f),\n        highMask | 0x80 | ( codepoint        & 0x3f)\n      );\n    } else {\n      // TODO: Lua 5.4 allows up to six-byte sequences, as in UTF-8:1993\n      return null;\n    }\n  }\n\n  function toHex(num, digits) {\n    var result = num.toString(16);\n    while (result.length < digits)\n      result = '0' + result;\n    return result;\n  }\n\n  function checkChars(rx) {\n    return function (s) {\n      var m = rx.exec(s);\n      if (!m)\n        return s;\n      raise(null, errors.invalidCodeUnit, toHex(m[0].charCodeAt(0), 4).toUpperCase());\n    };\n  }\n\n  var encodingModes = {\n    // `pseudo-latin1` encoding mode: assume the input was decoded with the latin1 encoding\n    // WARNING: latin1 does **NOT** mean cp1252 here like in the bone-headed WHATWG standard;\n    // it means true ISO/IEC 8859-1 identity-mapped to Basic Latin and Latin-1 Supplement blocks\n    'pseudo-latin1': {\n      fixup: checkChars(/[^\\x00-\\xff]/),\n      encodeByte: function (value) {\n        if (value === null)\n          return '';\n        return String.fromCharCode(value);\n      },\n      encodeUTF8: function (codepoint) {\n        return encodeUTF8(codepoint);\n      },\n    },\n\n    // `x-user-defined` encoding mode: assume the input was decoded with the WHATWG `x-user-defined` encoding\n    'x-user-defined': {\n      fixup: checkChars(/[^\\x00-\\x7f\\uf780-\\uf7ff]/),\n      encodeByte: function (value) {\n        if (value === null)\n          return '';\n        if (value >= 0x80)\n          return String.fromCharCode(value | 0xf700);\n        return String.fromCharCode(value);\n      },\n      encodeUTF8: function (codepoint) {\n        return encodeUTF8(codepoint, 0xf700);\n      }\n    },\n\n    // `none` encoding mode: disregard intrepretation of string literals, leave identifiers as-is\n    'none': {\n      discardStrings: true,\n      fixup: function (s) {\n        return s;\n      },\n      encodeByte: function (value) {\n        return '';\n      },\n      encodeUTF8: function (codepoint) {\n        return '';\n      }\n    }\n  };\n\n  // The available tokens expressed as enum flags so they can be checked with\n  // bitwise operations.\n\n  var EOF = 1, StringLiteral = 2, Keyword = 4, Identifier = 8\n    , NumericLiteral = 16, Punctuator = 32, BooleanLiteral = 64\n    , NilLiteral = 128, VarargLiteral = 256;\n\n  exports.tokenTypes = { EOF: EOF, StringLiteral: StringLiteral\n    , Keyword: Keyword, Identifier: Identifier, NumericLiteral: NumericLiteral\n    , Punctuator: Punctuator, BooleanLiteral: BooleanLiteral\n    , NilLiteral: NilLiteral, VarargLiteral: VarargLiteral\n  };\n\n  // As this parser is a bit different from luas own, the error messages\n  // will be different in some situations.\n\n  var errors = exports.errors = {\n      unexpected: 'unexpected %1 \\'%2\\' near \\'%3\\''\n    , unexpectedEOF: 'unexpected symbol near \\'<eof>\\''\n    , expected: '\\'%1\\' expected near \\'%2\\''\n    , expectedToken: '%1 expected near \\'%2\\''\n    , unfinishedString: 'unfinished string near \\'%1\\''\n    , malformedNumber: 'malformed number near \\'%1\\''\n    , decimalEscapeTooLarge: 'decimal escape too large near \\'%1\\''\n    , invalidEscape: 'invalid escape sequence near \\'%1\\''\n    , hexadecimalDigitExpected: 'hexadecimal digit expected near \\'%1\\''\n    , braceExpected: 'missing \\'%1\\' near \\'%2\\''\n    , tooLargeCodepoint: 'UTF-8 value too large near \\'%1\\''\n    , unfinishedLongString: 'unfinished long string (starting at line %1) near \\'%2\\''\n    , unfinishedLongComment: 'unfinished long comment (starting at line %1) near \\'%2\\''\n    , ambiguousSyntax: 'ambiguous syntax (function call x new statement) near \\'%1\\''\n    , noLoopToBreak: 'no loop to break near \\'%1\\''\n    , labelAlreadyDefined: 'label \\'%1\\' already defined on line %2'\n    , labelNotVisible: 'no visible label \\'%1\\' for <goto>'\n    , gotoJumpInLocalScope: '<goto %1> jumps into the scope of local \\'%2\\''\n    , cannotUseVararg: 'cannot use \\'...\\' outside a vararg function near \\'%1\\''\n    , invalidCodeUnit: 'code unit U+%1 is not allowed in the current encoding mode'\n  };\n\n  // ### Abstract Syntax Tree\n  //\n  // The default AST structure is inspired by the Mozilla Parser API but can\n  // easily be customized by overriding these functions.\n\n  var ast = exports.ast = {\n      labelStatement: function(label) {\n      return {\n          type: 'LabelStatement'\n        , label: label\n      };\n    }\n\n    , breakStatement: function() {\n      return {\n          type: 'BreakStatement'\n      };\n    }\n\n    , gotoStatement: function(label) {\n      return {\n          type: 'GotoStatement'\n        , label: label\n      };\n    }\n\n    , returnStatement: function(args) {\n      return {\n          type: 'ReturnStatement'\n        , 'arguments': args\n      };\n    }\n\n    , ifStatement: function(clauses) {\n      return {\n          type: 'IfStatement'\n        , clauses: clauses\n      };\n    }\n    , ifClause: function(condition, body) {\n      return {\n          type: 'IfClause'\n        , condition: condition\n        , body: body\n      };\n    }\n    , elseifClause: function(condition, body) {\n      return {\n          type: 'ElseifClause'\n        , condition: condition\n        , body: body\n      };\n    }\n    , elseClause: function(body) {\n      return {\n          type: 'ElseClause'\n        , body: body\n      };\n    }\n\n    , whileStatement: function(condition, body) {\n      return {\n          type: 'WhileStatement'\n        , condition: condition\n        , body: body\n      };\n    }\n\n    , doStatement: function(body) {\n      return {\n          type: 'DoStatement'\n        , body: body\n      };\n    }\n\n    , repeatStatement: function(condition, body) {\n      return {\n          type: 'RepeatStatement'\n        , condition: condition\n        , body: body\n      };\n    }\n\n    , localStatement: function(variables, init) {\n      return {\n          type: 'LocalStatement'\n        , variables: variables\n        , init: init\n      };\n    }\n\n    , assignmentStatement: function(variables, init) {\n      return {\n          type: 'AssignmentStatement'\n        , variables: variables\n        , init: init\n      };\n    }\n\n    , callStatement: function(expression) {\n      return {\n          type: 'CallStatement'\n        , expression: expression\n      };\n    }\n\n    , functionStatement: function(identifier, parameters, isLocal, body) {\n      return {\n          type: 'FunctionDeclaration'\n        , identifier: identifier\n        , isLocal: isLocal\n        , parameters: parameters\n        , body: body\n      };\n    }\n\n    , forNumericStatement: function(variable, start, end, step, body) {\n      return {\n          type: 'ForNumericStatement'\n        , variable: variable\n        , start: start\n        , end: end\n        , step: step\n        , body: body\n      };\n    }\n\n    , forGenericStatement: function(variables, iterators, body) {\n      return {\n          type: 'ForGenericStatement'\n        , variables: variables\n        , iterators: iterators\n        , body: body\n      };\n    }\n\n    , chunk: function(body) {\n      return {\n          type: 'Chunk'\n        , body: body\n      };\n    }\n\n    , identifier: function(name) {\n      return {\n          type: 'Identifier'\n        , name: name\n      };\n    }\n\n    , literal: function(type, value, raw) {\n      type = (type === StringLiteral) ? 'StringLiteral'\n        : (type === NumericLiteral) ? 'NumericLiteral'\n        : (type === BooleanLiteral) ? 'BooleanLiteral'\n        : (type === NilLiteral) ? 'NilLiteral'\n        : 'VarargLiteral';\n\n      return {\n          type: type\n        , value: value\n        , raw: raw\n      };\n    }\n\n    , tableKey: function(key, value) {\n      return {\n          type: 'TableKey'\n        , key: key\n        , value: value\n      };\n    }\n    , tableKeyString: function(key, value) {\n      return {\n          type: 'TableKeyString'\n        , key: key\n        , value: value\n      };\n    }\n    , tableValue: function(value) {\n      return {\n          type: 'TableValue'\n        , value: value\n      };\n    }\n\n\n    , tableConstructorExpression: function(fields) {\n      return {\n          type: 'TableConstructorExpression'\n        , fields: fields\n      };\n    }\n    , binaryExpression: function(operator, left, right) {\n      var type = ('and' === operator || 'or' === operator) ?\n        'LogicalExpression' :\n        'BinaryExpression';\n\n      return {\n          type: type\n        , operator: operator\n        , left: left\n        , right: right\n      };\n    }\n    , unaryExpression: function(operator, argument) {\n      return {\n          type: 'UnaryExpression'\n        , operator: operator\n        , argument: argument\n      };\n    }\n    , memberExpression: function(base, indexer, identifier) {\n      return {\n          type: 'MemberExpression'\n        , indexer: indexer\n        , identifier: identifier\n        , base: base\n      };\n    }\n\n    , indexExpression: function(base, index) {\n      return {\n          type: 'IndexExpression'\n        , base: base\n        , index: index\n      };\n    }\n\n    , callExpression: function(base, args) {\n      return {\n          type: 'CallExpression'\n        , base: base\n        , 'arguments': args\n      };\n    }\n\n    , tableCallExpression: function(base, args) {\n      return {\n          type: 'TableCallExpression'\n        , base: base\n        , 'arguments': args\n      };\n    }\n\n    , stringCallExpression: function(base, argument) {\n      return {\n          type: 'StringCallExpression'\n        , base: base\n        , argument: argument\n      };\n    }\n\n    , comment: function(value, raw) {\n      return {\n          type: 'Comment'\n        , value: value\n        , raw: raw\n      };\n    }\n  };\n\n  // Wrap up the node object.\n\n  function finishNode(node) {\n    // Pop a `Marker` off the location-array and attach its location data.\n    if (trackLocations) {\n      var location = locations.pop();\n      location.complete();\n      location.bless(node);\n    }\n    if (options.onCreateNode) options.onCreateNode(node);\n    return node;\n  }\n\n\n  // Helpers\n  // -------\n\n  var slice = Array.prototype.slice\n    , toString = Object.prototype.toString\n    ;\n\n  var indexOf = /* istanbul ignore next */ function (array, element) {\n    for (var i = 0, length = array.length; i < length; ++i) {\n      if (array[i] === element) return i;\n    }\n    return -1;\n  };\n\n  /* istanbul ignore else */\n  if (Array.prototype.indexOf)\n    indexOf = function (array, element) {\n      return array.indexOf(element);\n    };\n\n  // Iterate through an array of objects and return the index of an object\n  // with a matching property.\n\n  function indexOfObject(array, property, element) {\n    for (var i = 0, length = array.length; i < length; ++i) {\n      if (array[i][property] === element) return i;\n    }\n    return -1;\n  }\n\n  // A sprintf implementation using %index (beginning at 1) to input\n  // arguments in the format string.\n  //\n  // Example:\n  //\n  //     // Unexpected function in token\n  //     sprintf('Unexpected %2 in %1.', 'token', 'function');\n\n  function sprintf(format) {\n    var args = slice.call(arguments, 1);\n    format = format.replace(/%(\\d)/g, function (match, index) {\n      return '' + args[index - 1] || /* istanbul ignore next */ '';\n    });\n    return format;\n  }\n\n  // Polyfill for `Object.assign`.\n\n  var assign = /* istanbul ignore next */ function (dest) {\n    var args = slice.call(arguments, 1)\n      , src, prop;\n\n    for (var i = 0, length = args.length; i < length; ++i) {\n      src = args[i];\n      for (prop in src)\n        /* istanbul ignore else */\n        if (Object.prototype.hasOwnProperty.call(src, prop)) {\n          dest[prop] = src[prop];\n        }\n    }\n\n    return dest;\n  };\n\n  /* istanbul ignore else */\n  if (Object.assign)\n    assign = Object.assign;\n\n  // ### Error functions\n\n  exports.SyntaxError = SyntaxError;\n\n  // XXX: Eliminate this function and change the error type to be different from SyntaxError.\n  // This will unfortunately be a breaking change, because some downstream users depend\n  // on the error thrown being an instance of SyntaxError. For example, the Ace editor:\n  // <https://github.com/ajaxorg/ace/blob/4c7e5eb3f5d5ca9434847be51834a4e41661b852/lib/ace/mode/lua_worker.js#L55>\n\n  function fixupError(e) {\n    /* istanbul ignore if */\n    if (!Object.create)\n      return e;\n    return Object.create(e, {\n      'line': { 'writable': true, value: e.line },\n      'index': { 'writable': true, value: e.index },\n      'column': { 'writable': true, value: e.column }\n    });\n  }\n\n  // #### Raise an exception.\n  //\n  // Raise an exception by passing a token, a string format and its paramters.\n  //\n  // The passed tokens location will automatically be added to the error\n  // message if it exists, if not it will default to the lexers current\n  // position.\n  //\n  // Example:\n  //\n  //     // [1:0] expected [ near (\n  //     raise(token, \"expected %1 near %2\", '[', token.value);\n\n  function raise(token) {\n    var message = sprintf.apply(null, slice.call(arguments, 1))\n      , error, col;\n\n    if (token === null || typeof token.line === 'undefined') {\n      col = index - lineStart + 1;\n      error = fixupError(new SyntaxError(sprintf('[%1:%2] %3', line, col, message)));\n      error.index = index;\n      error.line = line;\n      error.column = col;\n    } else {\n      col = token.range[0] - token.lineStart;\n      error = fixupError(new SyntaxError(sprintf('[%1:%2] %3', token.line, col, message)));\n      error.line = token.line;\n      error.index = token.range[0];\n      error.column = col;\n    }\n    throw error;\n  }\n\n  function tokenValue(token) {\n    var raw = input.slice(token.range[0], token.range[1]);\n    if (raw)\n      return raw;\n    return token.value;\n  }\n\n  // #### Raise an unexpected token error.\n  //\n  // Example:\n  //\n  //     // expected <name> near '0'\n  //     raiseUnexpectedToken('<name>', token);\n\n  function raiseUnexpectedToken(type, token) {\n    raise(token, errors.expectedToken, type, tokenValue(token));\n  }\n\n  // #### Raise a general unexpected error\n  //\n  // Usage should pass either a token object or a symbol string which was\n  // expected. We can also specify a nearby token such as <eof>, this will\n  // default to the currently active token.\n  //\n  // Example:\n  //\n  //     // Unexpected symbol 'end' near '<eof>'\n  //     unexpected(token);\n  //\n  // If there's no token in the buffer it means we have reached <eof>.\n\n  function unexpected(found) {\n    var near = tokenValue(lookahead);\n    if ('undefined' !== typeof found.type) {\n      var type;\n      switch (found.type) {\n        case StringLiteral:   type = 'string';      break;\n        case Keyword:         type = 'keyword';     break;\n        case Identifier:      type = 'identifier';  break;\n        case NumericLiteral:  type = 'number';      break;\n        case Punctuator:      type = 'symbol';      break;\n        case BooleanLiteral:  type = 'boolean';     break;\n        case NilLiteral:\n          return raise(found, errors.unexpected, 'symbol', 'nil', near);\n        case EOF:\n          return raise(found, errors.unexpectedEOF);\n      }\n      return raise(found, errors.unexpected, type, tokenValue(found), near);\n    }\n    return raise(found, errors.unexpected, 'symbol', found, near);\n  }\n\n  // Lexer\n  // -----\n  //\n  // The lexer, or the tokenizer reads the input string character by character\n  // and derives a token left-right. To be as efficient as possible the lexer\n  // prioritizes the common cases such as identifiers. It also works with\n  // character codes instead of characters as string comparisons was the\n  // biggest bottleneck of the parser.\n  //\n  // If `options.comments` is enabled, all comments encountered will be stored\n  // in an array which later will be appended to the chunk object. If disabled,\n  // they will simply be disregarded.\n  //\n  // When the lexer has derived a valid token, it will be returned as an object\n  // containing its value and as well as its position in the input string (this\n  // is always enabled to provide proper debug messages).\n  //\n  // `lex()` starts lexing and returns the following token in the stream.\n\n  var index\n    , token\n    , previousToken\n    , lookahead\n    , comments\n    , tokenStart\n    , line\n    , lineStart;\n\n  exports.lex = lex;\n\n  function lex() {\n    skipWhiteSpace();\n\n    // Skip comments beginning with --\n    while (45 === input.charCodeAt(index) &&\n           45 === input.charCodeAt(index + 1)) {\n      scanComment();\n      skipWhiteSpace();\n    }\n    if (index >= length) return {\n        type : EOF\n      , value: '<eof>'\n      , line: line\n      , lineStart: lineStart\n      , range: [index, index]\n    };\n\n    var charCode = input.charCodeAt(index)\n      , next = input.charCodeAt(index + 1);\n\n    // Memorize the range index where the token begins.\n    tokenStart = index;\n    if (isIdentifierStart(charCode)) return scanIdentifierOrKeyword();\n\n    switch (charCode) {\n      case 39: case 34: // '\"\n        return scanStringLiteral();\n\n      case 48: case 49: case 50: case 51: case 52: case 53:\n      case 54: case 55: case 56: case 57: // 0-9\n        return scanNumericLiteral();\n\n      case 46: // .\n        // If the dot is followed by a digit it's a float.\n        if (isDecDigit(next)) return scanNumericLiteral();\n        if (46 === next) {\n          if (46 === input.charCodeAt(index + 2)) return scanVarargLiteral();\n          return scanPunctuator('..');\n        }\n        return scanPunctuator('.');\n\n      case 61: // =\n        if (61 === next) return scanPunctuator('==');\n        return scanPunctuator('=');\n\n      case 62: // >\n        if (features.bitwiseOperators)\n          if (62 === next) return scanPunctuator('>>');\n        if (61 === next) return scanPunctuator('>=');\n        return scanPunctuator('>');\n\n      case 60: // <\n        if (features.bitwiseOperators)\n          if (60 === next) return scanPunctuator('<<');\n        if (61 === next) return scanPunctuator('<=');\n        return scanPunctuator('<');\n\n      case 126: // ~\n        if (61 === next) return scanPunctuator('~=');\n        if (!features.bitwiseOperators)\n          break;\n        return scanPunctuator('~');\n\n      case 58: // :\n        if (features.labels)\n          if (58 === next) return scanPunctuator('::');\n        return scanPunctuator(':');\n\n      case 91: // [\n        // Check for a multiline string, they begin with [= or [[\n        if (91 === next || 61 === next) return scanLongStringLiteral();\n        return scanPunctuator('[');\n\n      case 47: // /\n        // Check for integer division op (//)\n        if (features.integerDivision)\n          if (47 === next) return scanPunctuator('//');\n        return scanPunctuator('/');\n\n      case 38: case 124: // & |\n        if (!features.bitwiseOperators)\n          break;\n\n        /* fall through */\n      case 42: case 94: case 37: case 44: case 123: case 125:\n      case 93: case 40: case 41: case 59: case 35: case 45:\n      case 43: // * ^ % , { } ] ( ) ; # - +\n        return scanPunctuator(input.charAt(index));\n    }\n\n    return unexpected(input.charAt(index));\n  }\n\n  // Whitespace has no semantic meaning in lua so simply skip ahead while\n  // tracking the encounted newlines. Any kind of eol sequence is counted as a\n  // single line.\n\n  function consumeEOL() {\n    var charCode = input.charCodeAt(index)\n      , peekCharCode = input.charCodeAt(index + 1);\n\n    if (isLineTerminator(charCode)) {\n      // Count \\n\\r and \\r\\n as one newline.\n      if (10 === charCode && 13 === peekCharCode) ++index;\n      if (13 === charCode && 10 === peekCharCode) ++index;\n      ++line;\n      lineStart = ++index;\n\n      return true;\n    }\n    return false;\n  }\n\n  function skipWhiteSpace() {\n    while (index < length) {\n      var charCode = input.charCodeAt(index);\n      if (isWhiteSpace(charCode)) {\n        ++index;\n      } else if (!consumeEOL()) {\n        break;\n      }\n    }\n  }\n\n  // Identifiers, keywords, booleans and nil all look the same syntax wise. We\n  // simply go through them one by one and defaulting to an identifier if no\n  // previous case matched.\n\n  function scanIdentifierOrKeyword() {\n    var value, type;\n\n    // Slicing the input string is prefered before string concatenation in a\n    // loop for performance reasons.\n    while (isIdentifierPart(input.charCodeAt(++index)));\n    value = encodingMode.fixup(input.slice(tokenStart, index));\n\n    // Decide on the token type and possibly cast the value.\n    if (isKeyword(value)) {\n      type = Keyword;\n    } else if ('true' === value || 'false' === value) {\n      type = BooleanLiteral;\n      value = ('true' === value);\n    } else if ('nil' === value) {\n      type = NilLiteral;\n      value = null;\n    } else {\n      type = Identifier;\n    }\n\n    return {\n        type: type\n      , value: value\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Once a punctuator reaches this function it should already have been\n  // validated so we simply return it as a token.\n\n  function scanPunctuator(value) {\n    index += value.length;\n    return {\n        type: Punctuator\n      , value: value\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // A vararg literal consists of three dots.\n\n  function scanVarargLiteral() {\n    index += 3;\n    return {\n        type: VarargLiteral\n      , value: '...'\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Find the string literal by matching the delimiter marks used.\n\n  function scanStringLiteral() {\n    var delimiter = input.charCodeAt(index++)\n      , beginLine = line\n      , beginLineStart = lineStart\n      , stringStart = index\n      , string = encodingMode.discardStrings ? null : ''\n      , charCode;\n\n    for (;;) {\n      charCode = input.charCodeAt(index++);\n      if (delimiter === charCode) break;\n      // EOF or `\\n` terminates a string literal. If we haven't found the\n      // ending delimiter by now, raise an exception.\n      if (index > length || isLineTerminator(charCode)) {\n        string += input.slice(stringStart, index - 1);\n        raise(null, errors.unfinishedString, input.slice(tokenStart, index - 1));\n      }\n      if (92 === charCode) { // backslash\n        if (!encodingMode.discardStrings) {\n          var beforeEscape = input.slice(stringStart, index - 1);\n          string += encodingMode.fixup(beforeEscape);\n        }\n        var escapeValue = readEscapeSequence();\n        if (!encodingMode.discardStrings)\n          string += escapeValue;\n        stringStart = index;\n      }\n    }\n    if (!encodingMode.discardStrings) {\n      string += encodingMode.encodeByte(null);\n      string += encodingMode.fixup(input.slice(stringStart, index - 1));\n    }\n\n    return {\n        type: StringLiteral\n      , value: string\n      , line: beginLine\n      , lineStart: beginLineStart\n      , lastLine: line\n      , lastLineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Expect a multiline string literal and return it as a regular string\n  // literal, if it doesn't validate into a valid multiline string, throw an\n  // exception.\n\n  function scanLongStringLiteral() {\n    var beginLine = line\n      , beginLineStart = lineStart\n      , string = readLongString(false);\n    // Fail if it's not a multiline literal.\n    if (false === string) raise(token, errors.expected, '[', tokenValue(token));\n\n    return {\n        type: StringLiteral\n      , value: encodingMode.discardStrings ? null : encodingMode.fixup(string)\n      , line: beginLine\n      , lineStart: beginLineStart\n      , lastLine: line\n      , lastLineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Numeric literals will be returned as floating-point numbers instead of\n  // strings. The raw value should be retrieved from slicing the input string\n  // later on in the process.\n  //\n  // If a hexadecimal number is encountered, it will be converted.\n\n  function scanNumericLiteral() {\n    var character = input.charAt(index)\n      , next = input.charAt(index + 1);\n\n    var literal = ('0' === character && 'xX'.indexOf(next || null) >= 0) ?\n      readHexLiteral() : readDecLiteral();\n\n    var foundImaginaryUnit = readImaginaryUnitSuffix()\n      , foundInt64Suffix = readInt64Suffix();\n\n    if (foundInt64Suffix && (foundImaginaryUnit || literal.hasFractionPart)) {\n      raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n    }\n\n    return {\n        type: NumericLiteral\n      , value: literal.value\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  function readImaginaryUnitSuffix() {\n    if (!features.imaginaryNumbers) return;\n\n    // Imaginary unit number suffix is optional.\n    // See http://luajit.org/ext_ffi_api.html#literals\n    if ('iI'.indexOf(input.charAt(index) || null) >= 0) {\n      ++index;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  function readInt64Suffix() {\n    if (!features.integerSuffixes) return;\n\n    // Int64/uint64 number suffix is optional.\n    // See http://luajit.org/ext_ffi_api.html#literals\n\n    if ('uU'.indexOf(input.charAt(index) || null) >= 0) {\n      ++index;\n      if ('lL'.indexOf(input.charAt(index) || null) >= 0) {\n        ++index;\n        if ('lL'.indexOf(input.charAt(index) || null) >= 0) {\n          ++index;\n          return 'ULL';\n        } else {\n          // UL but no L\n          raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n        }\n      } else {\n        // U but no L\n        raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n      }\n    } else if ('lL'.indexOf(input.charAt(index) || null) >= 0) {\n        ++index;\n        if ('lL'.indexOf(input.charAt(index) || null) >= 0) {\n          ++index;\n          return 'LL';\n        } else {\n          // First L but no second L\n          raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n        }\n    }\n  }\n\n  // Lua hexadecimals have an optional fraction part and an optional binary\n  // exoponent part. These are not included in JavaScript so we will compute\n  // all three parts separately and then sum them up at the end of the function\n  // with the following algorithm.\n  //\n  //     Digit := toDec(digit)\n  //     Fraction := toDec(fraction) / 16 ^ fractionCount\n  //     BinaryExp := 2 ^ binaryExp\n  //     Number := ( Digit + Fraction ) * BinaryExp\n\n  function readHexLiteral() {\n    var fraction = 0 // defaults to 0 as it gets summed\n      , binaryExponent = 1 // defaults to 1 as it gets multiplied\n      , binarySign = 1 // positive\n      , digit, fractionStart, exponentStart, digitStart;\n\n    digitStart = index += 2; // Skip 0x part\n\n    // A minimum of one hex digit is required.\n    if (!isHexDigit(input.charCodeAt(index)))\n      raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n\n    while (isHexDigit(input.charCodeAt(index))) ++index;\n    // Convert the hexadecimal digit to base 10.\n    digit = parseInt(input.slice(digitStart, index), 16);\n\n    // Fraction part is optional.\n    var foundFraction = false;\n    if ('.' === input.charAt(index)) {\n      foundFraction = true;\n      fractionStart = ++index;\n\n      while (isHexDigit(input.charCodeAt(index))) ++index;\n      fraction = input.slice(fractionStart, index);\n\n      // Empty fraction parts should default to 0, others should be converted\n      // 0.x form so we can use summation at the end.\n      fraction = (fractionStart === index) ? 0\n        : parseInt(fraction, 16) / Math.pow(16, index - fractionStart);\n    }\n\n    // Binary exponents are optional\n    var foundBinaryExponent = false;\n    if ('pP'.indexOf(input.charAt(index) || null) >= 0) {\n      foundBinaryExponent = true;\n      ++index;\n\n      // Sign part is optional and defaults to 1 (positive).\n      if ('+-'.indexOf(input.charAt(index) || null) >= 0)\n        binarySign = ('+' === input.charAt(index++)) ? 1 : -1;\n\n      exponentStart = index;\n\n      // The binary exponent sign requires a decimal digit.\n      if (!isDecDigit(input.charCodeAt(index)))\n        raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n\n      while (isDecDigit(input.charCodeAt(index))) ++index;\n      binaryExponent = input.slice(exponentStart, index);\n\n      // Calculate the binary exponent of the number.\n      binaryExponent = Math.pow(2, binaryExponent * binarySign);\n    }\n\n    return {\n      value: (digit + fraction) * binaryExponent,\n      hasFractionPart: foundFraction || foundBinaryExponent\n    };\n  }\n\n  // Decimal numbers are exactly the same in Lua and in JavaScript, because of\n  // this we check where the token ends and then parse it with native\n  // functions.\n\n  function readDecLiteral() {\n    while (isDecDigit(input.charCodeAt(index))) ++index;\n    // Fraction part is optional\n    var foundFraction = false;\n    if ('.' === input.charAt(index)) {\n      foundFraction = true;\n      ++index;\n      // Fraction part defaults to 0\n      while (isDecDigit(input.charCodeAt(index))) ++index;\n    }\n\n    // Exponent part is optional.\n    var foundExponent = false;\n    if ('eE'.indexOf(input.charAt(index) || null) >= 0) {\n      foundExponent = true;\n      ++index;\n      // Sign part is optional.\n      if ('+-'.indexOf(input.charAt(index) || null) >= 0) ++index;\n      // An exponent is required to contain at least one decimal digit.\n      if (!isDecDigit(input.charCodeAt(index)))\n        raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n\n      while (isDecDigit(input.charCodeAt(index))) ++index;\n    }\n\n    return {\n      value: parseFloat(input.slice(tokenStart, index)),\n      hasFractionPart: foundFraction || foundExponent\n    };\n  }\n\n  function readUnicodeEscapeSequence() {\n    var sequenceStart = index++;\n\n    if (input.charAt(index++) !== '{')\n      raise(null, errors.braceExpected, '{', '\\\\' + input.slice(sequenceStart, index));\n    if (!isHexDigit(input.charCodeAt(index)))\n      raise(null, errors.hexadecimalDigitExpected, '\\\\' + input.slice(sequenceStart, index));\n\n    while (input.charCodeAt(index) === 0x30) ++index;\n    var escStart = index;\n\n    while (isHexDigit(input.charCodeAt(index))) {\n      ++index;\n      if (index - escStart > 6)\n        raise(null, errors.tooLargeCodepoint, '\\\\' + input.slice(sequenceStart, index));\n    }\n\n    var b = input.charAt(index++);\n    if (b !== '}') {\n      if ((b === '\"') || (b === \"'\"))\n        raise(null, errors.braceExpected, '}', '\\\\' + input.slice(sequenceStart, index--));\n      else\n        raise(null, errors.hexadecimalDigitExpected, '\\\\' + input.slice(sequenceStart, index));\n    }\n\n    var codepoint = parseInt(input.slice(escStart, index - 1) || '0', 16);\n    var frag = '\\\\' + input.slice(sequenceStart, index);\n\n    if (codepoint > 0x10ffff) {\n      raise(null, errors.tooLargeCodepoint, frag);\n    }\n\n    return encodingMode.encodeUTF8(codepoint, frag);\n  }\n\n  // Translate escape sequences to the actual characters.\n  function readEscapeSequence() {\n    var sequenceStart = index;\n    switch (input.charAt(index)) {\n      // Lua allow the following escape sequences.\n      case 'a': ++index; return '\\x07';\n      case 'n': ++index; return '\\n';\n      case 'r': ++index; return '\\r';\n      case 't': ++index; return '\\t';\n      case 'v': ++index; return '\\x0b';\n      case 'b': ++index; return '\\b';\n      case 'f': ++index; return '\\f';\n\n      // Backslash at the end of the line. We treat all line endings as equivalent,\n      // and as representing the [LF] character (code 10). Lua 5.1 through 5.3\n      // have been verified to behave the same way.\n      case '\\r':\n      case '\\n':\n        consumeEOL();\n        return '\\n';\n\n      case '0': case '1': case '2': case '3': case '4':\n      case '5': case '6': case '7': case '8': case '9':\n        // \\ddd, where ddd is a sequence of up to three decimal digits.\n        while (isDecDigit(input.charCodeAt(index)) && index - sequenceStart < 3) ++index;\n\n        var frag = input.slice(sequenceStart, index);\n        var ddd = parseInt(frag, 10);\n        if (ddd > 255) {\n          raise(null, errors.decimalEscapeTooLarge, '\\\\' + ddd);\n        }\n        return encodingMode.encodeByte(ddd, '\\\\' + frag);\n\n      case 'z':\n        if (features.skipWhitespaceEscape) {\n          ++index;\n          skipWhiteSpace();\n          return '';\n        }\n        break;\n\n      case 'x':\n        if (features.hexEscapes) {\n          // \\xXX, where XX is a sequence of exactly two hexadecimal digits\n          if (isHexDigit(input.charCodeAt(index + 1)) &&\n              isHexDigit(input.charCodeAt(index + 2))) {\n            index += 3;\n            return encodingMode.encodeByte(parseInt(input.slice(sequenceStart + 1, index), 16), '\\\\' + input.slice(sequenceStart, index));\n          }\n          raise(null, errors.hexadecimalDigitExpected, '\\\\' + input.slice(sequenceStart, index + 2));\n        }\n        break;\n\n      case 'u':\n        if (features.unicodeEscapes)\n          return readUnicodeEscapeSequence();\n        break;\n\n      case '\\\\': case '\"': case \"'\":\n        return input.charAt(index++);\n    }\n\n    if (features.strictEscapes)\n      raise(null, errors.invalidEscape, '\\\\' + input.slice(sequenceStart, index + 1));\n    return input.charAt(index++);\n  }\n\n  // Comments begin with -- after which it will be decided if they are\n  // multiline comments or not.\n  //\n  // The multiline functionality works the exact same way as with string\n  // literals so we reuse the functionality.\n\n  function scanComment() {\n    tokenStart = index;\n    index += 2; // --\n\n    var character = input.charAt(index)\n      , content = ''\n      , isLong = false\n      , commentStart = index\n      , lineStartComment = lineStart\n      , lineComment = line;\n\n    if ('[' === character) {\n      content = readLongString(true);\n      // This wasn't a multiline comment after all.\n      if (false === content) content = character;\n      else isLong = true;\n    }\n    // Scan until next line as long as it's not a multiline comment.\n    if (!isLong) {\n      while (index < length) {\n        if (isLineTerminator(input.charCodeAt(index))) break;\n        ++index;\n      }\n      if (options.comments) content = input.slice(commentStart, index);\n    }\n\n    if (options.comments) {\n      var node = ast.comment(content, input.slice(tokenStart, index));\n\n      // `Marker`s depend on tokens available in the parser and as comments are\n      // intercepted in the lexer all location data is set manually.\n      if (options.locations) {\n        node.loc = {\n            start: { line: lineComment, column: tokenStart - lineStartComment }\n          , end: { line: line, column: index - lineStart }\n        };\n      }\n      if (options.ranges) {\n        node.range = [tokenStart, index];\n      }\n      if (options.onCreateNode) options.onCreateNode(node);\n      comments.push(node);\n    }\n  }\n\n  // Read a multiline string by calculating the depth of `=` characters and\n  // then appending until an equal depth is found.\n\n  function readLongString(isComment) {\n    var level = 0\n      , content = ''\n      , terminator = false\n      , character, stringStart, firstLine = line;\n\n    ++index; // [\n\n    // Calculate the depth of the comment.\n    while ('=' === input.charAt(index + level)) ++level;\n    // Exit, this is not a long string afterall.\n    if ('[' !== input.charAt(index + level)) return false;\n\n    index += level + 1;\n\n    // If the first character is a newline, ignore it and begin on next line.\n    if (isLineTerminator(input.charCodeAt(index))) consumeEOL();\n\n    stringStart = index;\n    while (index < length) {\n      // To keep track of line numbers run the `consumeEOL()` which increments\n      // its counter.\n      while (isLineTerminator(input.charCodeAt(index))) consumeEOL();\n\n      character = input.charAt(index++);\n\n      // Once the delimiter is found, iterate through the depth count and see\n      // if it matches.\n      if (']' === character) {\n        terminator = true;\n        for (var i = 0; i < level; ++i) {\n          if ('=' !== input.charAt(index + i)) terminator = false;\n        }\n        if (']' !== input.charAt(index + level)) terminator = false;\n      }\n\n      // We reached the end of the multiline string. Get out now.\n      if (terminator) {\n        content += input.slice(stringStart, index - 1);\n        index += level + 1;\n        return content;\n      }\n    }\n\n    raise(null, isComment ?\n                errors.unfinishedLongComment :\n                errors.unfinishedLongString,\n          firstLine, '<eof>');\n  }\n\n  // ## Lex functions and helpers.\n\n  // Read the next token.\n  //\n  // This is actually done by setting the current token to the lookahead and\n  // reading in the new lookahead token.\n\n  function next() {\n    previousToken = token;\n    token = lookahead;\n    lookahead = lex();\n  }\n\n  // Consume a token if its value matches. Once consumed or not, return the\n  // success of the operation.\n\n  function consume(value) {\n    if (value === token.value) {\n      next();\n      return true;\n    }\n    return false;\n  }\n\n  // Expect the next token value to match. If not, throw an exception.\n\n  function expect(value) {\n    if (value === token.value) next();\n    else raise(token, errors.expected, value, tokenValue(token));\n  }\n\n  // ### Validation functions\n\n  function isWhiteSpace(charCode) {\n    return 9 === charCode || 32 === charCode || 0xB === charCode || 0xC === charCode;\n  }\n\n  function isLineTerminator(charCode) {\n    return 10 === charCode || 13 === charCode;\n  }\n\n  function isDecDigit(charCode) {\n    return charCode >= 48 && charCode <= 57;\n  }\n\n  function isHexDigit(charCode) {\n    return (charCode >= 48 && charCode <= 57) || (charCode >= 97 && charCode <= 102) || (charCode >= 65 && charCode <= 70);\n  }\n\n  // From [Lua 5.2](http://www.lua.org/manual/5.2/manual.html#8.1) onwards\n  // identifiers cannot use 'locale-dependent' letters (i.e. dependent on the C locale).\n  // On the other hand, LuaJIT allows arbitrary octets  128 in identifiers.\n\n  function isIdentifierStart(charCode) {\n    if ((charCode >= 65 && charCode <= 90) || (charCode >= 97 && charCode <= 122) || 95 === charCode)\n      return true;\n    if (features.extendedIdentifiers && charCode >= 128)\n      return true;\n    return false;\n  }\n\n  function isIdentifierPart(charCode) {\n    if ((charCode >= 65 && charCode <= 90) || (charCode >= 97 && charCode <= 122) || 95 === charCode || (charCode >= 48 && charCode <= 57))\n      return true;\n    if (features.extendedIdentifiers && charCode >= 128)\n      return true;\n    return false;\n  }\n\n  // [3.1 Lexical Conventions](http://www.lua.org/manual/5.2/manual.html#3.1)\n  //\n  // `true`, `false` and `nil` will not be considered keywords, but literals.\n\n  function isKeyword(id) {\n    switch (id.length) {\n      case 2:\n        return 'do' === id || 'if' === id || 'in' === id || 'or' === id;\n      case 3:\n        return 'and' === id || 'end' === id || 'for' === id || 'not' === id;\n      case 4:\n        if ('else' === id || 'then' === id)\n          return true;\n        if (features.labels && !features.contextualGoto)\n          return ('goto' === id);\n        return false;\n      case 5:\n        return 'break' === id || 'local' === id || 'until' === id || 'while' === id;\n      case 6:\n        return 'elseif' === id || 'repeat' === id || 'return' === id;\n      case 8:\n        return 'function' === id;\n    }\n    return false;\n  }\n\n  function isUnary(token) {\n    if (Punctuator === token.type) return '#-~'.indexOf(token.value) >= 0;\n    if (Keyword === token.type) return 'not' === token.value;\n    return false;\n  }\n\n  // Check if the token syntactically closes a block.\n\n  function isBlockFollow(token) {\n    if (EOF === token.type) return true;\n    if (Keyword !== token.type) return false;\n    switch (token.value) {\n      case 'else': case 'elseif':\n      case 'end': case 'until':\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  // Scope\n  // -----\n\n  // Store each block scope as a an array of identifier names. Each scope is\n  // stored in an FILO-array.\n  var scopes\n    // The current scope index\n    , scopeDepth\n    // A list of all global identifier nodes.\n    , globals;\n\n  // Create a new scope inheriting all declarations from the previous scope.\n  function createScope() {\n    var scope = scopes[scopeDepth++].slice();\n    scopes.push(scope);\n    if (options.onCreateScope) options.onCreateScope();\n  }\n\n  // Exit and remove the current scope.\n  function destroyScope() {\n    var scope = scopes.pop();\n    --scopeDepth;\n    if (options.onDestroyScope) options.onDestroyScope();\n  }\n\n  // Add identifier name to the current scope if it doesnt already exist.\n  function scopeIdentifierName(name) {\n    if (options.onLocalDeclaration) options.onLocalDeclaration(name);\n    if (-1 !== indexOf(scopes[scopeDepth], name)) return;\n    scopes[scopeDepth].push(name);\n  }\n\n  // Add identifier to the current scope\n  function scopeIdentifier(node) {\n    scopeIdentifierName(node.name);\n    attachScope(node, true);\n  }\n\n  // Attach scope information to node. If the node is global, store it in the\n  // globals array so we can return the information to the user.\n  function attachScope(node, isLocal) {\n    if (!isLocal && -1 === indexOfObject(globals, 'name', node.name))\n      globals.push(node);\n\n    node.isLocal = isLocal;\n  }\n\n  // Is the identifier name available in this scope.\n  function scopeHasName(name) {\n    return (-1 !== indexOf(scopes[scopeDepth], name));\n  }\n\n  // Location tracking\n  // -----------------\n  //\n  // Locations are stored in FILO-array as a `Marker` object consisting of both\n  // `loc` and `range` data. Once a `Marker` is popped off the list an end\n  // location is added and the data is attached to a syntax node.\n\n  var locations = []\n    , trackLocations;\n\n  function createLocationMarker() {\n    return new Marker(token);\n  }\n\n  function Marker(token) {\n    if (options.locations) {\n      this.loc = {\n          start: {\n            line: token.line\n          , column: token.range[0] - token.lineStart\n        }\n        , end: {\n            line: 0\n          , column: 0\n        }\n      };\n    }\n    if (options.ranges) this.range = [token.range[0], 0];\n  }\n\n  // Complete the location data stored in the `Marker` by adding the location\n  // of the *previous token* as an end location.\n  Marker.prototype.complete = function() {\n    if (options.locations) {\n      this.loc.end.line = previousToken.lastLine || previousToken.line;\n      this.loc.end.column = previousToken.range[1] - (previousToken.lastLineStart || previousToken.lineStart);\n    }\n    if (options.ranges) {\n      this.range[1] = previousToken.range[1];\n    }\n  };\n\n  Marker.prototype.bless = function (node) {\n    if (this.loc) {\n      var loc = this.loc;\n      node.loc = {\n        start: {\n          line: loc.start.line,\n          column: loc.start.column\n        },\n        end: {\n          line: loc.end.line,\n          column: loc.end.column\n        }\n      };\n    }\n    if (this.range) {\n      node.range = [\n        this.range[0],\n        this.range[1]\n      ];\n    }\n  };\n\n  // Create a new `Marker` and add it to the FILO-array.\n  function markLocation() {\n    if (trackLocations) locations.push(createLocationMarker());\n  }\n\n  // Push an arbitrary `Marker` object onto the FILO-array.\n  function pushLocation(marker) {\n    if (trackLocations) locations.push(marker);\n  }\n\n  // Control flow tracking\n  // ---------------------\n  // A context object that validates loop breaks and `goto`-based control flow.\n\n  function FullFlowContext() {\n    this.scopes = [];\n    this.pendingGotos = [];\n  }\n\n  FullFlowContext.prototype.isInLoop = function () {\n    var i = this.scopes.length;\n    while (i --> 0) {\n      if (this.scopes[i].isLoop)\n        return true;\n    }\n    return false;\n  };\n\n  FullFlowContext.prototype.pushScope = function (isLoop) {\n    var scope = {\n      labels: {},\n      locals: [],\n      deferredGotos: [],\n      isLoop: !!isLoop\n    };\n    this.scopes.push(scope);\n  };\n\n  FullFlowContext.prototype.popScope = function () {\n    for (var i = 0; i < this.pendingGotos.length; ++i) {\n      var theGoto = this.pendingGotos[i];\n      if (theGoto.maxDepth >= this.scopes.length)\n        if (--theGoto.maxDepth <= 0)\n          raise(theGoto.token, errors.labelNotVisible, theGoto.target);\n    }\n\n    this.scopes.pop();\n  };\n\n  FullFlowContext.prototype.addGoto = function (target, token) {\n    var localCounts = [];\n\n    for (var i = 0; i < this.scopes.length; ++i) {\n      var scope = this.scopes[i];\n      localCounts.push(scope.locals.length);\n      if (Object.prototype.hasOwnProperty.call(scope.labels, target))\n        return;\n    }\n\n    this.pendingGotos.push({\n      maxDepth: this.scopes.length,\n      target: target,\n      token: token,\n      localCounts: localCounts\n    });\n  };\n\n  FullFlowContext.prototype.addLabel = function (name, token) {\n    var scope = this.currentScope();\n\n    if (Object.prototype.hasOwnProperty.call(scope.labels, name)) {\n      raise(token, errors.labelAlreadyDefined, name, scope.labels[name].line);\n    } else {\n      var newGotos = [];\n\n      for (var i = 0; i < this.pendingGotos.length; ++i) {\n        var theGoto = this.pendingGotos[i];\n\n        if (theGoto.maxDepth >= this.scopes.length && theGoto.target === name) {\n          if (theGoto.localCounts[this.scopes.length - 1] < scope.locals.length) {\n            scope.deferredGotos.push(theGoto);\n          }\n          continue;\n        }\n\n        newGotos.push(theGoto);\n      }\n\n      this.pendingGotos = newGotos;\n    }\n\n    scope.labels[name] = {\n      localCount: scope.locals.length,\n      line: token.line\n    };\n  };\n\n  FullFlowContext.prototype.addLocal = function (name, token) {\n    this.currentScope().locals.push({\n      name: name,\n      token: token\n    });\n  };\n\n  FullFlowContext.prototype.currentScope = function () {\n    return this.scopes[this.scopes.length - 1];\n  };\n\n  FullFlowContext.prototype.raiseDeferredErrors = function () {\n    var scope = this.currentScope();\n    var bads = scope.deferredGotos;\n    for (var i = 0; i < bads.length; ++i) {\n      var theGoto = bads[i];\n      raise(theGoto.token, errors.gotoJumpInLocalScope, theGoto.target, scope.locals[theGoto.localCounts[this.scopes.length - 1]].name);\n    }\n    // Would be dead code currently, but may be useful later\n    // if (bads.length)\n    //   scope.deferredGotos = [];\n  };\n\n  // Simplified context that only checks the validity of loop breaks.\n\n  function LoopFlowContext() {\n    this.level = 0;\n    this.loopLevels = [];\n  }\n\n  LoopFlowContext.prototype.isInLoop = function () {\n    return !!this.loopLevels.length;\n  };\n\n  LoopFlowContext.prototype.pushScope = function (isLoop) {\n    ++this.level;\n    if (isLoop)\n      this.loopLevels.push(this.level);\n  };\n\n  LoopFlowContext.prototype.popScope = function () {\n    var levels = this.loopLevels;\n    var levlen = levels.length;\n    if (levlen) {\n      if (levels[levlen - 1] === this.level)\n        levels.pop();\n    }\n    --this.level;\n  };\n\n  LoopFlowContext.prototype.addGoto =\n  LoopFlowContext.prototype.addLabel =\n  /* istanbul ignore next */\n  function () { throw new Error('This should never happen'); };\n\n  LoopFlowContext.prototype.addLocal =\n  LoopFlowContext.prototype.raiseDeferredErrors =\n  function () {};\n\n  function makeFlowContext() {\n    return features.labels ? new FullFlowContext() : new LoopFlowContext();\n  }\n\n  // Parse functions\n  // ---------------\n\n  // Chunk is the main program object. Syntactically it's the same as a block.\n  //\n  //     chunk ::= block\n\n  function parseChunk() {\n    next();\n    markLocation();\n    if (options.scope) createScope();\n    var flowContext = makeFlowContext();\n    flowContext.allowVararg = true;\n    flowContext.pushScope();\n    var body = parseBlock(flowContext);\n    flowContext.popScope();\n    if (options.scope) destroyScope();\n    if (EOF !== token.type) unexpected(token);\n    // If the body is empty no previousToken exists when finishNode runs.\n    if (trackLocations && !body.length) previousToken = token;\n    return finishNode(ast.chunk(body));\n  }\n\n  // A block contains a list of statements with an optional return statement\n  // as its last statement.\n  //\n  //     block ::= {stat} [retstat]\n\n  function parseBlock(flowContext) {\n    var block = []\n      , statement;\n\n    while (!isBlockFollow(token)) {\n      // Return has to be the last statement in a block.\n      // Likewise 'break' in Lua older than 5.2\n      if ('return' === token.value || (!features.relaxedBreak && 'break' === token.value)) {\n        block.push(parseStatement(flowContext));\n        break;\n      }\n      statement = parseStatement(flowContext);\n      consume(';');\n      // Statements are only added if they are returned, this allows us to\n      // ignore some statements, such as EmptyStatement.\n      if (statement) block.push(statement);\n    }\n\n    // Doesn't really need an ast node\n    return block;\n  }\n\n  // There are two types of statements, simple and compound.\n  //\n  //     statement ::= break | goto | do | while | repeat | return\n  //          | if | for | function | local | label | assignment\n  //          | functioncall | ';'\n\n  function parseStatement(flowContext) {\n    markLocation();\n\n    if (Punctuator === token.type) {\n      if (consume('::')) return parseLabelStatement(flowContext);\n    }\n\n    // When a `;` is encounted, simply eat it without storing it.\n    if (features.emptyStatement) {\n      if (consume(';')) {\n        if (trackLocations) locations.pop();\n        return;\n      }\n    }\n\n    flowContext.raiseDeferredErrors();\n\n    if (Keyword === token.type) {\n      switch (token.value) {\n        case 'local':    next(); return parseLocalStatement(flowContext);\n        case 'if':       next(); return parseIfStatement(flowContext);\n        case 'return':   next(); return parseReturnStatement(flowContext);\n        case 'function': next();\n          var name = parseFunctionName();\n          return parseFunctionDeclaration(name);\n        case 'while':    next(); return parseWhileStatement(flowContext);\n        case 'for':      next(); return parseForStatement(flowContext);\n        case 'repeat':   next(); return parseRepeatStatement(flowContext);\n        case 'break':    next();\n          if (!flowContext.isInLoop())\n            raise(token, errors.noLoopToBreak, token.value);\n          return parseBreakStatement();\n        case 'do':       next(); return parseDoStatement(flowContext);\n        case 'goto':     next(); return parseGotoStatement(flowContext);\n      }\n    }\n\n    if (features.contextualGoto &&\n        token.type === Identifier && token.value === 'goto' &&\n        lookahead.type === Identifier && lookahead.value !== 'goto') {\n      next(); return parseGotoStatement(flowContext);\n    }\n\n    // Assignments memorizes the location and pushes it manually for wrapper nodes.\n    if (trackLocations) locations.pop();\n\n    return parseAssignmentOrCallStatement(flowContext);\n  }\n\n  // ## Statements\n\n  //     label ::= '::' Name '::'\n\n  function parseLabelStatement(flowContext) {\n    var nameToken = token\n      , label = parseIdentifier();\n\n    if (options.scope) {\n      scopeIdentifierName('::' + nameToken.value + '::');\n      attachScope(label, true);\n    }\n\n    expect('::');\n\n    flowContext.addLabel(nameToken.value, nameToken);\n    return finishNode(ast.labelStatement(label));\n  }\n\n  //     break ::= 'break'\n\n  function parseBreakStatement() {\n    return finishNode(ast.breakStatement());\n  }\n\n  //     goto ::= 'goto' Name\n\n  function parseGotoStatement(flowContext) {\n    var name = token.value\n      , gotoToken = previousToken\n      , label = parseIdentifier();\n\n    flowContext.addGoto(name, gotoToken);\n    return finishNode(ast.gotoStatement(label));\n  }\n\n  //     do ::= 'do' block 'end'\n\n  function parseDoStatement(flowContext) {\n    if (options.scope) createScope();\n    flowContext.pushScope();\n    var body = parseBlock(flowContext);\n    flowContext.popScope();\n    if (options.scope) destroyScope();\n    expect('end');\n    return finishNode(ast.doStatement(body));\n  }\n\n  //     while ::= 'while' exp 'do' block 'end'\n\n  function parseWhileStatement(flowContext) {\n    var condition = parseExpectedExpression(flowContext);\n    expect('do');\n    if (options.scope) createScope();\n    flowContext.pushScope(true);\n    var body = parseBlock(flowContext);\n    flowContext.popScope();\n    if (options.scope) destroyScope();\n    expect('end');\n    return finishNode(ast.whileStatement(condition, body));\n  }\n\n  //     repeat ::= 'repeat' block 'until' exp\n\n  function parseRepeatStatement(flowContext) {\n    if (options.scope) createScope();\n    flowContext.pushScope(true);\n    var body = parseBlock(flowContext);\n    expect('until');\n    flowContext.raiseDeferredErrors();\n    var condition = parseExpectedExpression(flowContext);\n    flowContext.popScope();\n    if (options.scope) destroyScope();\n    return finishNode(ast.repeatStatement(condition, body));\n  }\n\n  //     retstat ::= 'return' [exp {',' exp}] [';']\n\n  function parseReturnStatement(flowContext) {\n    var expressions = [];\n\n    if ('end' !== token.value) {\n      var expression = parseExpression(flowContext);\n      if (null != expression) expressions.push(expression);\n      while (consume(',')) {\n        expression = parseExpectedExpression(flowContext);\n        expressions.push(expression);\n      }\n      consume(';'); // grammar tells us ; is optional here.\n    }\n    return finishNode(ast.returnStatement(expressions));\n  }\n\n  //     if ::= 'if' exp 'then' block {elif} ['else' block] 'end'\n  //     elif ::= 'elseif' exp 'then' block\n\n  function parseIfStatement(flowContext) {\n    var clauses = []\n      , condition\n      , body\n      , marker;\n\n    // IfClauses begin at the same location as the parent IfStatement.\n    // It ends at the start of `end`, `else`, or `elseif`.\n    if (trackLocations) {\n      marker = locations[locations.length - 1];\n      locations.push(marker);\n    }\n    condition = parseExpectedExpression(flowContext);\n    expect('then');\n    if (options.scope) createScope();\n    flowContext.pushScope();\n    body = parseBlock(flowContext);\n    flowContext.popScope();\n    if (options.scope) destroyScope();\n    clauses.push(finishNode(ast.ifClause(condition, body)));\n\n    if (trackLocations) marker = createLocationMarker();\n    while (consume('elseif')) {\n      pushLocation(marker);\n      condition = parseExpectedExpression(flowContext);\n      expect('then');\n      if (options.scope) createScope();\n      flowContext.pushScope();\n      body = parseBlock(flowContext);\n      flowContext.popScope();\n      if (options.scope) destroyScope();\n      clauses.push(finishNode(ast.elseifClause(condition, body)));\n      if (trackLocations) marker = createLocationMarker();\n    }\n\n    if (consume('else')) {\n      // Include the `else` in the location of ElseClause.\n      if (trackLocations) {\n        marker = new Marker(previousToken);\n        locations.push(marker);\n      }\n      if (options.scope) createScope();\n      flowContext.pushScope();\n      body = parseBlock(flowContext);\n      flowContext.popScope();\n      if (options.scope) destroyScope();\n      clauses.push(finishNode(ast.elseClause(body)));\n    }\n\n    expect('end');\n    return finishNode(ast.ifStatement(clauses));\n  }\n\n  // There are two types of for statements, generic and numeric.\n  //\n  //     for ::= Name '=' exp ',' exp [',' exp] 'do' block 'end'\n  //     for ::= namelist 'in' explist 'do' block 'end'\n  //     namelist ::= Name {',' Name}\n  //     explist ::= exp {',' exp}\n\n  function parseForStatement(flowContext) {\n    var variable = parseIdentifier()\n      , body;\n\n    // The start-identifier is local.\n\n    if (options.scope) {\n      createScope();\n      scopeIdentifier(variable);\n    }\n\n    // If the first expression is followed by a `=` punctuator, this is a\n    // Numeric For Statement.\n    if (consume('=')) {\n      // Start expression\n      var start = parseExpectedExpression(flowContext);\n      expect(',');\n      // End expression\n      var end = parseExpectedExpression(flowContext);\n      // Optional step expression\n      var step = consume(',') ? parseExpectedExpression(flowContext) : null;\n\n      expect('do');\n      flowContext.pushScope(true);\n      body = parseBlock(flowContext);\n      flowContext.popScope();\n      expect('end');\n      if (options.scope) destroyScope();\n\n      return finishNode(ast.forNumericStatement(variable, start, end, step, body));\n    }\n    // If not, it's a Generic For Statement\n    else {\n      // The namelist can contain one or more identifiers.\n      var variables = [variable];\n      while (consume(',')) {\n        variable = parseIdentifier();\n        // Each variable in the namelist is locally scoped.\n        if (options.scope) scopeIdentifier(variable);\n        variables.push(variable);\n      }\n      expect('in');\n      var iterators = [];\n\n      // One or more expressions in the explist.\n      do {\n        var expression = parseExpectedExpression(flowContext);\n        iterators.push(expression);\n      } while (consume(','));\n\n      expect('do');\n      flowContext.pushScope(true);\n      body = parseBlock(flowContext);\n      flowContext.popScope();\n      expect('end');\n      if (options.scope) destroyScope();\n\n      return finishNode(ast.forGenericStatement(variables, iterators, body));\n    }\n  }\n\n  // Local statements can either be variable assignments or function\n  // definitions. If a function definition is found, it will be delegated to\n  // `parseFunctionDeclaration()` with the isLocal flag.\n  //\n  // This AST structure might change into a local assignment with a function\n  // child.\n  //\n  //     local ::= 'local' 'function' Name funcdecl\n  //        | 'local' Name {',' Name} ['=' exp {',' exp}]\n\n  function parseLocalStatement(flowContext) {\n    var name\n      , declToken = previousToken;\n\n    if (Identifier === token.type) {\n      var variables = []\n        , init = [];\n\n      do {\n        name = parseIdentifier();\n\n        variables.push(name);\n        flowContext.addLocal(name.name, declToken);\n      } while (consume(','));\n\n      if (consume('=')) {\n        do {\n          var expression = parseExpectedExpression(flowContext);\n          init.push(expression);\n        } while (consume(','));\n      }\n\n      // Declarations doesn't exist before the statement has been evaluated.\n      // Therefore assignments can't use their declarator. And the identifiers\n      // shouldn't be added to the scope until the statement is complete.\n      if (options.scope) {\n        for (var i = 0, l = variables.length; i < l; ++i) {\n          scopeIdentifier(variables[i]);\n        }\n      }\n\n      return finishNode(ast.localStatement(variables, init));\n    }\n    if (consume('function')) {\n      name = parseIdentifier();\n      flowContext.addLocal(name.name, declToken);\n\n      if (options.scope) {\n        scopeIdentifier(name);\n        createScope();\n      }\n\n      // MemberExpressions are not allowed in local function statements.\n      return parseFunctionDeclaration(name, true);\n    } else {\n      raiseUnexpectedToken('<name>', token);\n    }\n  }\n\n  //     assignment ::= varlist '=' explist\n  //     var ::= Name | prefixexp '[' exp ']' | prefixexp '.' Name\n  //     varlist ::= var {',' var}\n  //     explist ::= exp {',' exp}\n  //\n  //     call ::= callexp\n  //     callexp ::= prefixexp args | prefixexp ':' Name args\n\n  function parseAssignmentOrCallStatement(flowContext) {\n    // Keep a reference to the previous token for better error messages in case\n    // of invalid statement\n    var previous = token\n      , marker, startMarker;\n    var lvalue, base, name;\n\n    var targets = [];\n\n    if (trackLocations) startMarker = createLocationMarker();\n\n    do {\n      if (trackLocations) marker = createLocationMarker();\n\n      if (Identifier === token.type) {\n        name = token.value;\n        base = parseIdentifier();\n        // Set the parent scope.\n        if (options.scope) attachScope(base, scopeHasName(name));\n        lvalue = true;\n      } else if ('(' === token.value) {\n        next();\n        base = parseExpectedExpression(flowContext);\n        expect(')');\n        lvalue = false;\n      } else {\n        return unexpected(token);\n      }\n\n      both: for (;;) {\n        var newBase;\n\n        switch (StringLiteral === token.type ? '\"' : token.value) {\n        case '.':\n        case '[':\n          lvalue = true;\n          break;\n        case ':':\n        case '(':\n        case '{':\n        case '\"':\n          lvalue = null;\n          break;\n        default:\n          break both;\n        }\n\n        base = parsePrefixExpressionPart(base, marker, flowContext);\n      }\n\n      targets.push(base);\n\n      if (',' !== token.value)\n        break;\n\n      if (!lvalue) {\n        return unexpected(token);\n      }\n\n      next();\n    } while (true);\n\n    if (targets.length === 1 && lvalue === null) {\n      pushLocation(marker);\n      return finishNode(ast.callStatement(targets[0]));\n    } else if (!lvalue) {\n      return unexpected(token);\n    }\n\n    expect('=');\n\n    var values = [];\n\n    do {\n      values.push(parseExpectedExpression(flowContext));\n    } while (consume(','));\n\n    pushLocation(startMarker);\n    return finishNode(ast.assignmentStatement(targets, values));\n  }\n\n  // ### Non-statements\n\n  //     Identifier ::= Name\n\n  function parseIdentifier() {\n    markLocation();\n    var identifier = token.value;\n    if (Identifier !== token.type) raiseUnexpectedToken('<name>', token);\n    next();\n    return finishNode(ast.identifier(identifier));\n  }\n\n  // Parse the functions parameters and body block. The name should already\n  // have been parsed and passed to this declaration function. By separating\n  // this we allow for anonymous functions in expressions.\n  //\n  // For local functions there's a boolean parameter which needs to be set\n  // when parsing the declaration.\n  //\n  //     funcdecl ::= '(' [parlist] ')' block 'end'\n  //     parlist ::= Name {',' Name} | [',' '...'] | '...'\n\n  function parseFunctionDeclaration(name, isLocal) {\n    var flowContext = makeFlowContext();\n    flowContext.pushScope();\n\n    var parameters = [];\n    expect('(');\n\n    // The declaration has arguments\n    if (!consume(')')) {\n      // Arguments are a comma separated list of identifiers, optionally ending\n      // with a vararg.\n      while (true) {\n        if (Identifier === token.type) {\n          var parameter = parseIdentifier();\n          // Function parameters are local.\n          if (options.scope) scopeIdentifier(parameter);\n\n          parameters.push(parameter);\n\n          if (consume(',')) continue;\n        }\n        // No arguments are allowed after a vararg.\n        else if (VarargLiteral === token.type) {\n          flowContext.allowVararg = true;\n          parameters.push(parsePrimaryExpression(flowContext));\n        } else {\n          raiseUnexpectedToken('<name> or \\'...\\'', token);\n        }\n        expect(')');\n        break;\n      }\n    }\n\n    var body = parseBlock(flowContext);\n    flowContext.popScope();\n    expect('end');\n    if (options.scope) destroyScope();\n\n    isLocal = isLocal || false;\n    return finishNode(ast.functionStatement(name, parameters, isLocal, body));\n  }\n\n  // Parse the function name as identifiers and member expressions.\n  //\n  //     Name {'.' Name} [':' Name]\n\n  function parseFunctionName() {\n    var base, name, marker;\n\n    if (trackLocations) marker = createLocationMarker();\n    base = parseIdentifier();\n\n    if (options.scope) {\n      attachScope(base, scopeHasName(base.name));\n      createScope();\n    }\n\n    while (consume('.')) {\n      pushLocation(marker);\n      name = parseIdentifier();\n      base = finishNode(ast.memberExpression(base, '.', name));\n    }\n\n    if (consume(':')) {\n      pushLocation(marker);\n      name = parseIdentifier();\n      base = finishNode(ast.memberExpression(base, ':', name));\n      if (options.scope) scopeIdentifierName('self');\n    }\n\n    return base;\n  }\n\n  //     tableconstructor ::= '{' [fieldlist] '}'\n  //     fieldlist ::= field {fieldsep field} fieldsep\n  //     field ::= '[' exp ']' '=' exp | Name = 'exp' | exp\n  //\n  //     fieldsep ::= ',' | ';'\n\n  function parseTableConstructor(flowContext) {\n    var fields = []\n      , key, value;\n\n    while (true) {\n      markLocation();\n      if (Punctuator === token.type && consume('[')) {\n        key = parseExpectedExpression(flowContext);\n        expect(']');\n        expect('=');\n        value = parseExpectedExpression(flowContext);\n        fields.push(finishNode(ast.tableKey(key, value)));\n      } else if (Identifier === token.type) {\n        if ('=' === lookahead.value) {\n          key = parseIdentifier();\n          next();\n          value = parseExpectedExpression(flowContext);\n          fields.push(finishNode(ast.tableKeyString(key, value)));\n        } else {\n          value = parseExpectedExpression(flowContext);\n          fields.push(finishNode(ast.tableValue(value)));\n        }\n      } else {\n        if (null == (value = parseExpression(flowContext))) {\n          locations.pop();\n          break;\n        }\n        fields.push(finishNode(ast.tableValue(value)));\n      }\n      if (',;'.indexOf(token.value) >= 0) {\n        next();\n        continue;\n      }\n      break;\n    }\n    expect('}');\n    return finishNode(ast.tableConstructorExpression(fields));\n  }\n\n  // Expression parser\n  // -----------------\n  //\n  // Expressions are evaluated and always return a value. If nothing is\n  // matched null will be returned.\n  //\n  //     exp ::= (unop exp | primary | prefixexp ) { binop exp }\n  //\n  //     primary ::= nil | false | true | Number | String | '...'\n  //          | functiondef | tableconstructor\n  //\n  //     prefixexp ::= (Name | '(' exp ')' ) { '[' exp ']'\n  //          | '.' Name | ':' Name args | args }\n  //\n\n  function parseExpression(flowContext) {\n    var expression = parseSubExpression(0, flowContext);\n    return expression;\n  }\n\n  // Parse an expression expecting it to be valid.\n\n  function parseExpectedExpression(flowContext) {\n    var expression = parseExpression(flowContext);\n    if (null == expression) raiseUnexpectedToken('<expression>', token);\n    else return expression;\n  }\n\n\n  // Return the precedence priority of the operator.\n  //\n  // As unary `-` can't be distinguished from binary `-`, unary precedence\n  // isn't described in this table but in `parseSubExpression()` itself.\n  //\n  // As this function gets hit on every expression it's been optimized due to\n  // the expensive CompareICStub which took ~8% of the parse time.\n\n  function binaryPrecedence(operator) {\n    var charCode = operator.charCodeAt(0)\n      , length = operator.length;\n\n    if (1 === length) {\n      switch (charCode) {\n        case 94: return 12; // ^\n        case 42: case 47: case 37: return 10; // * / %\n        case 43: case 45: return 9; // + -\n        case 38: return 6; // &\n        case 126: return 5; // ~\n        case 124: return 4; // |\n        case 60: case 62: return 3; // < >\n      }\n    } else if (2 === length) {\n      switch (charCode) {\n        case 47: return 10; // //\n        case 46: return 8; // ..\n        case 60: case 62:\n            if('<<' === operator || '>>' === operator) return 7; // << >>\n            return 3; // <= >=\n        case 61: case 126: return 3; // == ~=\n        case 111: return 1; // or\n      }\n    } else if (97 === charCode && 'and' === operator) return 2;\n    return 0;\n  }\n\n  // Implement an operator-precedence parser to handle binary operator\n  // precedence.\n  //\n  // We use this algorithm because it's compact, it's fast and Lua core uses\n  // the same so we can be sure our expressions are parsed in the same manner\n  // without excessive amounts of tests.\n  //\n  //     exp ::= (unop exp | primary | prefixexp ) { binop exp }\n\n  function parseSubExpression(minPrecedence, flowContext) {\n    var operator = token.value\n    // The left-hand side in binary operations.\n      , expression, marker;\n\n    if (trackLocations) marker = createLocationMarker();\n\n    // UnaryExpression\n    if (isUnary(token)) {\n      markLocation();\n      next();\n      var argument = parseSubExpression(10, flowContext);\n      if (argument == null) raiseUnexpectedToken('<expression>', token);\n      expression = finishNode(ast.unaryExpression(operator, argument));\n    }\n    if (null == expression) {\n      // PrimaryExpression\n      expression = parsePrimaryExpression(flowContext);\n\n      // PrefixExpression\n      if (null == expression) {\n        expression = parsePrefixExpression(flowContext);\n      }\n    }\n    // This is not a valid left hand expression.\n    if (null == expression) return null;\n\n    var precedence;\n    while (true) {\n      operator = token.value;\n\n      precedence = (Punctuator === token.type || Keyword === token.type) ?\n        binaryPrecedence(operator) : 0;\n\n      if (precedence === 0 || precedence <= minPrecedence) break;\n      // Right-hand precedence operators\n      if ('^' === operator || '..' === operator) --precedence;\n      next();\n      var right = parseSubExpression(precedence, flowContext);\n      if (null == right) raiseUnexpectedToken('<expression>', token);\n      // Push in the marker created before the loop to wrap its entirety.\n      if (trackLocations) locations.push(marker);\n      expression = finishNode(ast.binaryExpression(operator, expression, right));\n\n    }\n    return expression;\n  }\n\n  //     prefixexp ::= prefix {suffix}\n  //     prefix ::= Name | '(' exp ')'\n  //     suffix ::= '[' exp ']' | '.' Name | ':' Name args | args\n  //\n  //     args ::= '(' [explist] ')' | tableconstructor | String\n\n  function parsePrefixExpressionPart(base, marker, flowContext) {\n    var expression, identifier;\n\n    if (Punctuator === token.type) {\n      switch (token.value) {\n        case '[':\n          pushLocation(marker);\n          next();\n          expression = parseExpectedExpression(flowContext);\n          expect(']');\n          return finishNode(ast.indexExpression(base, expression));\n        case '.':\n          pushLocation(marker);\n          next();\n          identifier = parseIdentifier();\n          return finishNode(ast.memberExpression(base, '.', identifier));\n        case ':':\n          pushLocation(marker);\n          next();\n          identifier = parseIdentifier();\n          base = finishNode(ast.memberExpression(base, ':', identifier));\n          // Once a : is found, this has to be a CallExpression, otherwise\n          // throw an error.\n          pushLocation(marker);\n          return parseCallExpression(base, flowContext);\n        case '(': case '{': // args\n          pushLocation(marker);\n          return parseCallExpression(base, flowContext);\n      }\n    } else if (StringLiteral === token.type) {\n      pushLocation(marker);\n      return parseCallExpression(base, flowContext);\n    }\n\n    return null;\n  }\n\n  function parsePrefixExpression(flowContext) {\n    var base, name, marker;\n\n    if (trackLocations) marker = createLocationMarker();\n\n    // The prefix\n    if (Identifier === token.type) {\n      name = token.value;\n      base = parseIdentifier();\n      // Set the parent scope.\n      if (options.scope) attachScope(base, scopeHasName(name));\n    } else if (consume('(')) {\n      base = parseExpectedExpression(flowContext);\n      expect(')');\n    } else {\n      return null;\n    }\n\n    // The suffix\n    for (;;) {\n      var newBase = parsePrefixExpressionPart(base, marker, flowContext);\n      if (newBase === null)\n        break;\n      base = newBase;\n    }\n\n    return base;\n  }\n\n  //     args ::= '(' [explist] ')' | tableconstructor | String\n\n  function parseCallExpression(base, flowContext) {\n    if (Punctuator === token.type) {\n      switch (token.value) {\n        case '(':\n          if (!features.emptyStatement) {\n            if (token.line !== previousToken.line)\n              raise(null, errors.ambiguousSyntax, token.value);\n          }\n          next();\n\n          // List of expressions\n          var expressions = [];\n          var expression = parseExpression(flowContext);\n          if (null != expression) expressions.push(expression);\n          while (consume(',')) {\n            expression = parseExpectedExpression(flowContext);\n            expressions.push(expression);\n          }\n\n          expect(')');\n          return finishNode(ast.callExpression(base, expressions));\n\n        case '{':\n          markLocation();\n          next();\n          var table = parseTableConstructor(flowContext);\n          return finishNode(ast.tableCallExpression(base, table));\n      }\n    } else if (StringLiteral === token.type) {\n      return finishNode(ast.stringCallExpression(base, parsePrimaryExpression(flowContext)));\n    }\n\n    raiseUnexpectedToken('function arguments', token);\n  }\n\n  //     primary ::= String | Numeric | nil | true | false\n  //          | functiondef | tableconstructor | '...'\n\n  function parsePrimaryExpression(flowContext) {\n    var literals = StringLiteral | NumericLiteral | BooleanLiteral | NilLiteral | VarargLiteral\n      , value = token.value\n      , type = token.type\n      , marker;\n\n    if (trackLocations) marker = createLocationMarker();\n\n    if (type === VarargLiteral && !flowContext.allowVararg) {\n      raise(token, errors.cannotUseVararg, token.value);\n    }\n\n    if (type & literals) {\n      pushLocation(marker);\n      var raw = input.slice(token.range[0], token.range[1]);\n      next();\n      return finishNode(ast.literal(type, value, raw));\n    } else if (Keyword === type && 'function' === value) {\n      pushLocation(marker);\n      next();\n      if (options.scope) createScope();\n      return parseFunctionDeclaration(null);\n    } else if (consume('{')) {\n      pushLocation(marker);\n      return parseTableConstructor(flowContext);\n    }\n  }\n\n  // Parser\n  // ------\n\n  // Export the main parser.\n  //\n  //   - `wait` Hold parsing until end() is called. Defaults to false\n  //   - `comments` Store comments. Defaults to true.\n  //   - `scope` Track identifier scope. Defaults to false.\n  //   - `locations` Store location information. Defaults to false.\n  //   - `ranges` Store the start and end character locations. Defaults to\n  //     false.\n  //   - `onCreateNode` Callback which will be invoked when a syntax node is\n  //     created.\n  //   - `onCreateScope` Callback which will be invoked when a new scope is\n  //     created.\n  //   - `onDestroyScope` Callback which will be invoked when the current scope\n  //     is destroyed.\n  //\n  // Example:\n  //\n  //     var parser = require('luaparser');\n  //     parser.parse('i = 0');\n\n  exports.parse = parse;\n\n  var versionFeatures = {\n    '5.1': {\n    },\n    '5.2': {\n      labels: true,\n      emptyStatement: true,\n      hexEscapes: true,\n      skipWhitespaceEscape: true,\n      strictEscapes: true,\n      relaxedBreak: true\n    },\n    '5.3': {\n      labels: true,\n      emptyStatement: true,\n      hexEscapes: true,\n      skipWhitespaceEscape: true,\n      strictEscapes: true,\n      unicodeEscapes: true,\n      bitwiseOperators: true,\n      integerDivision: true,\n      relaxedBreak: true\n    },\n    'LuaJIT': {\n      // XXX: LuaJIT language features may depend on compilation options; may need to\n      // rethink how to handle this. Specifically, there is a LUAJIT_ENABLE_LUA52COMPAT\n      // that removes contextual goto. Maybe add 'LuaJIT-5.2compat' as well?\n      labels: true,\n      contextualGoto: true,\n      hexEscapes: true,\n      skipWhitespaceEscape: true,\n      strictEscapes: true,\n      unicodeEscapes: true,\n      imaginaryNumbers: true,\n      integerSuffixes: true\n    }\n  };\n\n  function parse(_input, _options) {\n    if ('undefined' === typeof _options && 'object' === typeof _input) {\n      _options = _input;\n      _input = undefined;\n    }\n    if (!_options) _options = {};\n\n    input = _input || '';\n    options = assign({}, defaultOptions, _options);\n\n    // Rewind the lexer\n    index = 0;\n    line = 1;\n    lineStart = 0;\n    length = input.length;\n    // When tracking identifier scope, initialize with an empty scope.\n    scopes = [[]];\n    scopeDepth = 0;\n    globals = [];\n    locations = [];\n\n    if (!Object.prototype.hasOwnProperty.call(versionFeatures, options.luaVersion)) {\n      throw new Error(sprintf(\"Lua version '%1' not supported\", options.luaVersion));\n    }\n\n    features = assign({}, versionFeatures[options.luaVersion]);\n    if (options.extendedIdentifiers !== void 0)\n      features.extendedIdentifiers = !!options.extendedIdentifiers;\n\n    if (!Object.prototype.hasOwnProperty.call(encodingModes, options.encodingMode)) {\n      throw new Error(sprintf(\"Encoding mode '%1' not supported\", options.encodingMode));\n    }\n\n    encodingMode = encodingModes[options.encodingMode];\n\n    if (options.comments) comments = [];\n    if (!options.wait) return end();\n    return exports;\n  }\n\n  // Write to the source code buffer without beginning the parse.\n  exports.write = write;\n\n  function write(_input) {\n    input += String(_input);\n    length = input.length;\n    return exports;\n  }\n\n  // Send an EOF and begin parsing.\n  exports.end = end;\n\n  function end(_input) {\n    if ('undefined' !== typeof _input) write(_input);\n\n    // Ignore shebangs.\n    if (input && input.substr(0, 2) === '#!') input = input.replace(/^.*/, function (line) {\n      return line.replace(/./g, ' ');\n    });\n\n    length = input.length;\n    trackLocations = options.locations || options.ranges;\n    // Initialize with a lookahead token.\n    lookahead = lex();\n\n    var chunk = parseChunk();\n    if (options.comments) chunk.comments = comments;\n    if (options.scope) chunk.globals = globals;\n\n    /* istanbul ignore if */\n    if (locations.length > 0)\n      throw new Error('Location tracking failed. This is most likely a bug in luaparse');\n\n    return chunk;\n  }\n\n}));\n/* vim: set sw=2 ts=2 et tw=79 : */\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t(() => {\n/******/ \t\t// define getter functions for harmony exports\n/******/ \t\t__webpack_require__.d = (exports, definition) => {\n/******/ \t\t\tfor(var key in definition) {\n/******/ \t\t\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n/******/ \t\t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/global */\n/******/ \t(() => {\n/******/ \t\t__webpack_require__.g = (function() {\n/******/ \t\t\tif (typeof globalThis === 'object') return globalThis;\n/******/ \t\t\ttry {\n/******/ \t\t\t\treturn this || new Function('return this')();\n/******/ \t\t\t} catch (e) {\n/******/ \t\t\t\tif (typeof window === 'object') return window;\n/******/ \t\t\t}\n/******/ \t\t})();\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t(() => {\n/******/ \t\t__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/make namespace object */\n/******/ \t(() => {\n/******/ \t\t// define __esModule on exports\n/******/ \t\t__webpack_require__.r = (exports) => {\n/******/ \t\t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t\t}\n/******/ \t\t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/node module decorator */\n/******/ \t(() => {\n/******/ \t\t__webpack_require__.nmd = (module) => {\n/******/ \t\t\tmodule.paths = [];\n/******/ \t\t\tif (!module.children) module.children = [];\n/******/ \t\t\treturn module;\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/************************************************************************/\nvar __webpack_exports__ = {};\n// This entry need to be wrapped in an IIFE because it need to be in strict mode.\n(() => {\n\"use strict\";\n// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"LuaService\": () => (/* binding */ LuaService)\n});\n\n;// CONCATENATED MODULE: ./utils.ts\nfunction mergeObjects(obj1, obj2) {\n  if (!obj1)\n    return obj2;\n  if (!obj2)\n    return obj1;\n  const mergedObjects = { ...obj2, ...obj1 };\n  for (const key of Object.keys(mergedObjects)) {\n    if (obj1[key] && obj2[key]) {\n      if (Array.isArray(obj1[key])) {\n        mergedObjects[key] = obj1[key].concat(obj2[key]);\n      } else if (Array.isArray(obj2[key])) {\n        mergedObjects[key] = obj2[key].concat(obj1[key]);\n      } else if (typeof obj1[key] === \"object\" && typeof obj2[key] === \"object\") {\n        mergedObjects[key] = mergeObjects(obj1[key], obj2[key]);\n      }\n    }\n  }\n  return mergedObjects;\n}\nfunction notEmpty(value) {\n  return value !== null && value !== void 0;\n}\n\n;// CONCATENATED MODULE: ../../node_modules/vscode-languageserver-textdocument/lib/esm/main.js\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n\nvar __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar FullTextDocument = /** @class */ (function () {\n    function FullTextDocument(uri, languageId, version, content) {\n        this._uri = uri;\n        this._languageId = languageId;\n        this._version = version;\n        this._content = content;\n        this._lineOffsets = undefined;\n    }\n    Object.defineProperty(FullTextDocument.prototype, \"uri\", {\n        get: function () {\n            return this._uri;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(FullTextDocument.prototype, \"languageId\", {\n        get: function () {\n            return this._languageId;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(FullTextDocument.prototype, \"version\", {\n        get: function () {\n            return this._version;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    FullTextDocument.prototype.getText = function (range) {\n        if (range) {\n            var start = this.offsetAt(range.start);\n            var end = this.offsetAt(range.end);\n            return this._content.substring(start, end);\n        }\n        return this._content;\n    };\n    FullTextDocument.prototype.update = function (changes, version) {\n        for (var _i = 0, changes_1 = changes; _i < changes_1.length; _i++) {\n            var change = changes_1[_i];\n            if (FullTextDocument.isIncremental(change)) {\n                // makes sure start is before end\n                var range = getWellformedRange(change.range);\n                // update content\n                var startOffset = this.offsetAt(range.start);\n                var endOffset = this.offsetAt(range.end);\n                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);\n                // update the offsets\n                var startLine = Math.max(range.start.line, 0);\n                var endLine = Math.max(range.end.line, 0);\n                var lineOffsets = this._lineOffsets;\n                var addedLineOffsets = computeLineOffsets(change.text, false, startOffset);\n                if (endLine - startLine === addedLineOffsets.length) {\n                    for (var i = 0, len = addedLineOffsets.length; i < len; i++) {\n                        lineOffsets[i + startLine + 1] = addedLineOffsets[i];\n                    }\n                }\n                else {\n                    if (addedLineOffsets.length < 10000) {\n                        lineOffsets.splice.apply(lineOffsets, __spreadArray([startLine + 1, endLine - startLine], addedLineOffsets, false));\n                    }\n                    else { // avoid too many arguments for splice\n                        this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));\n                    }\n                }\n                var diff = change.text.length - (endOffset - startOffset);\n                if (diff !== 0) {\n                    for (var i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {\n                        lineOffsets[i] = lineOffsets[i] + diff;\n                    }\n                }\n            }\n            else if (FullTextDocument.isFull(change)) {\n                this._content = change.text;\n                this._lineOffsets = undefined;\n            }\n            else {\n                throw new Error('Unknown change event received');\n            }\n        }\n        this._version = version;\n    };\n    FullTextDocument.prototype.getLineOffsets = function () {\n        if (this._lineOffsets === undefined) {\n            this._lineOffsets = computeLineOffsets(this._content, true);\n        }\n        return this._lineOffsets;\n    };\n    FullTextDocument.prototype.positionAt = function (offset) {\n        offset = Math.max(Math.min(offset, this._content.length), 0);\n        var lineOffsets = this.getLineOffsets();\n        var low = 0, high = lineOffsets.length;\n        if (high === 0) {\n            return { line: 0, character: offset };\n        }\n        while (low < high) {\n            var mid = Math.floor((low + high) / 2);\n            if (lineOffsets[mid] > offset) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        // low is the least x for which the line offset is larger than the current offset\n        // or array.length if no line offset is larger than the current offset\n        var line = low - 1;\n        return { line: line, character: offset - lineOffsets[line] };\n    };\n    FullTextDocument.prototype.offsetAt = function (position) {\n        var lineOffsets = this.getLineOffsets();\n        if (position.line >= lineOffsets.length) {\n            return this._content.length;\n        }\n        else if (position.line < 0) {\n            return 0;\n        }\n        var lineOffset = lineOffsets[position.line];\n        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;\n        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\n    };\n    Object.defineProperty(FullTextDocument.prototype, \"lineCount\", {\n        get: function () {\n            return this.getLineOffsets().length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    FullTextDocument.isIncremental = function (event) {\n        var candidate = event;\n        return candidate !== undefined && candidate !== null &&\n            typeof candidate.text === 'string' && candidate.range !== undefined &&\n            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');\n    };\n    FullTextDocument.isFull = function (event) {\n        var candidate = event;\n        return candidate !== undefined && candidate !== null &&\n            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;\n    };\n    return FullTextDocument;\n}());\nvar TextDocument;\n(function (TextDocument) {\n    /**\n     * Creates a new text document.\n     *\n     * @param uri The document's uri.\n     * @param languageId  The document's language Id.\n     * @param version The document's initial version number.\n     * @param content The document's content.\n     */\n    function create(uri, languageId, version, content) {\n        return new FullTextDocument(uri, languageId, version, content);\n    }\n    TextDocument.create = create;\n    /**\n     * Updates a TextDocument by modifying its content.\n     *\n     * @param document the document to update. Only documents created by TextDocument.create are valid inputs.\n     * @param changes the changes to apply to the document.\n     * @param version the changes version for the document.\n     * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.\n     *\n     */\n    function update(document, changes, version) {\n        if (document instanceof FullTextDocument) {\n            document.update(changes, version);\n            return document;\n        }\n        else {\n            throw new Error('TextDocument.update: document must be created by TextDocument.create');\n        }\n    }\n    TextDocument.update = update;\n    function applyEdits(document, edits) {\n        var text = document.getText();\n        var sortedEdits = mergeSort(edits.map(getWellformedEdit), function (a, b) {\n            var diff = a.range.start.line - b.range.start.line;\n            if (diff === 0) {\n                return a.range.start.character - b.range.start.character;\n            }\n            return diff;\n        });\n        var lastModifiedOffset = 0;\n        var spans = [];\n        for (var _i = 0, sortedEdits_1 = sortedEdits; _i < sortedEdits_1.length; _i++) {\n            var e = sortedEdits_1[_i];\n            var startOffset = document.offsetAt(e.range.start);\n            if (startOffset < lastModifiedOffset) {\n                throw new Error('Overlapping edit');\n            }\n            else if (startOffset > lastModifiedOffset) {\n                spans.push(text.substring(lastModifiedOffset, startOffset));\n            }\n            if (e.newText.length) {\n                spans.push(e.newText);\n            }\n            lastModifiedOffset = document.offsetAt(e.range.end);\n        }\n        spans.push(text.substr(lastModifiedOffset));\n        return spans.join('');\n    }\n    TextDocument.applyEdits = applyEdits;\n})(TextDocument || (TextDocument = {}));\nfunction mergeSort(data, compare) {\n    if (data.length <= 1) {\n        // sorted\n        return data;\n    }\n    var p = (data.length / 2) | 0;\n    var left = data.slice(0, p);\n    var right = data.slice(p);\n    mergeSort(left, compare);\n    mergeSort(right, compare);\n    var leftIdx = 0;\n    var rightIdx = 0;\n    var i = 0;\n    while (leftIdx < left.length && rightIdx < right.length) {\n        var ret = compare(left[leftIdx], right[rightIdx]);\n        if (ret <= 0) {\n            // smaller_equal -> take left to preserve order\n            data[i++] = left[leftIdx++];\n        }\n        else {\n            // greater -> take right\n            data[i++] = right[rightIdx++];\n        }\n    }\n    while (leftIdx < left.length) {\n        data[i++] = left[leftIdx++];\n    }\n    while (rightIdx < right.length) {\n        data[i++] = right[rightIdx++];\n    }\n    return data;\n}\nfunction computeLineOffsets(text, isAtLineStart, textOffset) {\n    if (textOffset === void 0) { textOffset = 0; }\n    var result = isAtLineStart ? [textOffset] : [];\n    for (var i = 0; i < text.length; i++) {\n        var ch = text.charCodeAt(i);\n        if (ch === 13 /* CharCode.CarriageReturn */ || ch === 10 /* CharCode.LineFeed */) {\n            if (ch === 13 /* CharCode.CarriageReturn */ && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                i++;\n            }\n            result.push(textOffset + i + 1);\n        }\n    }\n    return result;\n}\nfunction getWellformedRange(range) {\n    var start = range.start;\n    var end = range.end;\n    if (start.line > end.line || (start.line === end.line && start.character > end.character)) {\n        return { start: end, end: start };\n    }\n    return range;\n}\nfunction getWellformedEdit(textEdit) {\n    var range = getWellformedRange(textEdit.range);\n    if (range !== textEdit.range) {\n        return { newText: textEdit.newText, range: range };\n    }\n    return textEdit;\n}\n\n;// CONCATENATED MODULE: ./services/base-service.ts\n\n\nclass BaseService {\n  constructor(mode) {\n    this.documents = {};\n    this.options = {};\n    this.globalOptions = {};\n    this.mode = mode;\n  }\n  addDocument(document) {\n    this.documents[document.uri] = TextDocument.create(\n      document.uri,\n      document.languageId,\n      document.version,\n      document.text\n    );\n  }\n  getDocument(uri) {\n    return this.documents[uri];\n  }\n  removeDocument(document) {\n    delete this.documents[document.uri];\n    if (this.options[document.uri]) {\n      delete this.options[document.uri];\n    }\n  }\n  getDocumentValue(uri) {\n    var _a;\n    return (_a = this.getDocument(uri)) == null ? void 0 : _a.getText();\n  }\n  setValue(identifier, value) {\n    let document = this.getDocument(identifier.uri);\n    if (document) {\n      document = TextDocument.create(document.uri, document.languageId, document.version, value);\n      this.documents[document.uri] = document;\n    }\n  }\n  setGlobalOptions(options) {\n    this.globalOptions = options != null ? options : {};\n  }\n  setOptions(sessionID, options, merge = false) {\n    this.options[sessionID] = merge ? mergeObjects(options, this.options[sessionID]) : options;\n  }\n  getOption(sessionID, optionName) {\n    if (this.options[sessionID] && this.options[sessionID][optionName]) {\n      return this.options[sessionID][optionName];\n    } else {\n      return this.globalOptions[optionName];\n    }\n  }\n  applyDeltas(identifier, deltas) {\n    let document = this.getDocument(identifier.uri);\n    if (document)\n      TextDocument.update(document, deltas, identifier.version);\n  }\n  async doComplete(document, position) {\n    return null;\n  }\n  async doHover(document, position) {\n    return null;\n  }\n  async doResolve(item) {\n    return null;\n  }\n  async doValidation(document) {\n    return [];\n  }\n  format(document, range, options) {\n    return [];\n  }\n  async provideSignatureHelp(document, position) {\n    return null;\n  }\n  async findDocumentHighlights(document, position) {\n    return [];\n  }\n}\n\n// EXTERNAL MODULE: ../../node_modules/luaparse/luaparse.js\nvar luaparse = __webpack_require__(7438);\n;// CONCATENATED MODULE: ./services/lua/lua-service.ts\n\n\nclass LuaService extends BaseService {\n  constructor(mode) {\n    super(mode);\n    this.$service = luaparse;\n  }\n  async doValidation(document) {\n    let value = this.getDocumentValue(document.uri);\n    if (!value)\n      return [];\n    let errors = [];\n    try {\n      this.$service.parse(value);\n    } catch (e) {\n      if (e instanceof this.$service.SyntaxError) {\n        errors.push({\n          range: {\n            start: {\n              line: e.line - 1,\n              character: e.column\n            },\n            end: {\n              line: e.line - 1,\n              character: e.column\n            }\n          },\n          message: e.message,\n          severity: 1\n        });\n      }\n    }\n    return errors;\n  }\n}\n\n})();\n\n/******/ \treturn __webpack_exports__;\n/******/ })()\n;\n});"],"names":[],"sourceRoot":""}