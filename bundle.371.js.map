{"version":3,"file":"bundle.371.js","mappings":";;;;;;AAAa;;AAEb,kBAAkB,uCAA+C;AACjE,gBAAgB,+CAA2C;AAC3D,mBAAmB,mDAAuC;AAC1D,yBAAyB,yDAA6C;AACtE,aAAa,4CAA2B;AACxC,WAAW,mBAAO,CAAC,KAAsB;AACzC,WAAW,mBAAO,CAAC,KAAa;AAChC,UAAU,mBAAO,CAAC,IAAY;AAC9B,gBAAgB,mBAAO,CAAC,KAAkB;AAC1C,uBAAuB,6CAA4C;AACnE,oBAAoB,0CAAyC;AAC7D,uBAAuB,6CAA4C;;AAEnE;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mDAAmD;AACnD;;AAEA;AACA;AACA,UAAU;AACV;;AAEA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD,2BAA2B;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA,mBAAmB,6CAA6C;AAChE;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,eAAe;AACf;;;AAGA;;AAEA,0CAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,gCAAgC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8BAA8B;AAC/D,uCAAuC,+BAA+B;AACtE,oCAAoC,uCAAuC;AAC3E;AACA;AACA;AACA,uCAAuC,yBAAyB,aAAa,oCAAoC;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mBAAmB;AAClD;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;;AAEA,GAAG,kBAAkB;AACrB;AACA;;AAEA,MAAM,kBAAkB;AACxB;AACA;AACA;AACA;AACA,CAAC;;AAED,0BAA0B;AAC1B,qBAAqB;AACrB,kBAAkB;AAClB,yBAAyB","sources":["webpack://ace-linters-root/./node_modules/ace-code/src/ext/inline_autocomplete.js"],"sourcesContent":["\"use strict\";\n\nvar HashHandler = require(\"../keyboard/hash_handler\").HashHandler;\nvar AceInline = require(\"../autocomplete/inline\").AceInline;\nvar FilteredList = require(\"../autocomplete\").FilteredList;\nvar CompletionProvider = require(\"../autocomplete\").CompletionProvider;\nvar Editor = require(\"../editor\").Editor;\nvar util = require(\"../autocomplete/util\");\nvar lang = require(\"../lib/lang\");\nvar dom = require(\"../lib/dom\");\nvar useragent = require(\"../lib/useragent\");\nvar snippetCompleter = require(\"./language_tools\").snippetCompleter;\nvar textCompleter = require(\"./language_tools\").textCompleter;\nvar keyWordCompleter = require(\"./language_tools\").keyWordCompleter;\n\nvar destroyCompleter = function(e, editor) {\n    editor.completer && editor.completer.destroy();\n};\n\nvar minPosition = function (posA, posB) {\n    if (posB.row > posA.row) {\n        return posA;\n    } else if (posB.row === posA.row && posB.column > posA.column) {\n        return posA;\n    }\n    return posB;\n};\n\n\n/**\n * This class controls the inline-only autocompletion components and their lifecycle.\n * This is more lightweight than the popup-based autocompletion, as it can only work with exact prefix matches.\n * There is an inline ghost text renderer and an optional command bar tooltip inside.\n */\nclass InlineAutocomplete {\n    constructor(editor) {\n        this.editor = editor;\n        this.tooltipEnabled = true;\n        this.keyboardHandler = new HashHandler(this.commands);\n        this.$index = -1;\n\n        this.blurListener = this.blurListener.bind(this);\n        this.changeListener = this.changeListener.bind(this);\n        this.mousewheelListener = this.mousewheelListener.bind(this);\n\n        this.changeTimer = lang.delayedCall(function() {\n            this.updateCompletions();\n        }.bind(this));\n    }\n    \n    getInlineRenderer() {\n        if (!this.inlineRenderer)\n            this.inlineRenderer = new AceInline();\n        return this.inlineRenderer;\n    }\n\n    getInlineTooltip() {\n        if (!this.inlineTooltip) {\n            this.inlineTooltip = new InlineTooltip(this.editor, document.body || document.documentElement);\n            this.inlineTooltip.setCommands(this.commands);\n        }\n        return this.inlineTooltip;\n    }\n\n\n    /**\n     * This function is the entry point to the class. This triggers the gathering of the autocompletion and displaying the results;\n     * @param {CompletionOptions} options\n     */\n    show(options) {\n        this.activated = true;\n\n        if (this.editor.completer !== this) {\n            if (this.editor.completer)\n                this.editor.completer.detach();\n            this.editor.completer = this;\n        }\n\n        this.editor.on(\"changeSelection\", this.changeListener);\n        this.editor.on(\"blur\", this.blurListener);\n        this.editor.on(\"mousewheel\", this.mousewheelListener);\n\n        this.updateCompletions(options);\n    }\n\n    $open() {\n        if (this.editor.textInput.setAriaOptions) {\n            this.editor.textInput.setAriaOptions({});\n        }\n\n        if (this.tooltipEnabled) {\n            this.getInlineTooltip().show(this.editor);\n        } else if (this.tooltipEnabled === \"hover\") {\n        }\n\n        this.editor.keyBinding.addKeyboardHandler(this.keyboardHandler);\n\n        if (this.$index === -1) {\n            this.setIndex(0);\n        } else {\n            this.$showCompletion();\n        }\n        \n        this.changeTimer.cancel();\n    }\n    \n    insertMatch() {\n        var result = this.getCompletionProvider().insertByIndex(this.editor, this.$index);\n        this.detach();\n        return result;\n    }\n\n    changeListener(e) {\n        var cursor = this.editor.selection.lead;\n        if (cursor.row != this.base.row || cursor.column < this.base.column) {\n            this.detach();\n        }\n        if (this.activated)\n            this.changeTimer.schedule();\n        else\n            this.detach();\n    }\n\n    blurListener(e) {\n        this.detach();\n    }\n\n    mousewheelListener(e) {\n        if (this.inlineTooltip && this.inlineTooltip.isShown()) {\n            this.inlineTooltip.updatePosition();\n        }\n    }\n\n    goTo(where) {\n        if (!this.completions || !this.completions.filtered) {\n            return;\n        }\n        switch(where.toLowerCase()) {\n            case \"prev\":\n                this.setIndex(Math.max(0, this.$index - 1));\n                break;\n            case \"next\":\n                this.setIndex(this.$index + 1);\n                break;\n            case \"first\":\n                this.setIndex(0);\n                break;\n            case \"last\":\n                this.setIndex(this.completions.filtered.length - 1);\n                break;\n        }\n    }\n\n    getLength() {\n        if (!this.completions || !this.completions.filtered) {\n            return 0;\n        }\n        return this.completions.filtered.length;\n    }\n\n    getData(index) {\n        if (index == undefined || index === null) {\n            return this.completions.filtered[this.$index];\n        } else {\n            return this.completions.filtered[index];\n        }\n    }\n\n    getIndex() {\n        return this.$index;\n    }\n\n    isOpen() {\n        return this.$index >= 0;\n    }\n\n    setIndex(value) {\n        if (!this.completions || !this.completions.filtered) {\n            return;\n        }\n        var newIndex = Math.max(-1, Math.min(this.completions.filtered.length - 1, value));\n        if (newIndex !== this.$index) {\n            this.$index = newIndex;\n            this.$showCompletion();\n        }\n    }\n\n    getCompletionProvider() {\n        if (!this.completionProvider)\n            this.completionProvider = new CompletionProvider();\n        return this.completionProvider;\n    }\n\n    $showCompletion() {\n        if (!this.getInlineRenderer().show(this.editor, this.completions.filtered[this.$index], this.completions.filterText)) {\n            // Not able to show the completion, hide the previous one\n            this.getInlineRenderer().hide();\n        }\n        if (this.inlineTooltip && this.inlineTooltip.isShown()) {\n            this.inlineTooltip.updateButtons();\n        }\n    }\n\n    $updatePrefix() {\n        var pos = this.editor.getCursorPosition();\n        var prefix = this.editor.session.getTextRange({start: this.base, end: pos});\n        this.completions.setFilter(prefix);\n        if (!this.completions.filtered.length)\n            return this.detach();\n        if (this.completions.filtered.length == 1\n        && this.completions.filtered[0].value == prefix\n        && !this.completions.filtered[0].snippet)\n            return this.detach();\n        this.$open(this.editor, prefix);\n        return prefix;\n    }\n\n    updateCompletions(options) {\n        var prefix = \"\";\n        \n        if (options && options.matches) {\n            var pos = this.editor.getSelectionRange().start;\n            this.base = this.editor.session.doc.createAnchor(pos.row, pos.column);\n            this.base.$insertRight = true;\n            this.completions = new FilteredList(options.matches);\n            return this.$open(this.editor, \"\");\n        }\n\n        if (this.base && this.completions) {\n            prefix = this.$updatePrefix();\n        }\n\n        var session = this.editor.getSession();\n        var pos = this.editor.getCursorPosition();\n        var prefix = util.getCompletionPrefix(this.editor);\n        this.base = session.doc.createAnchor(pos.row, pos.column - prefix.length);\n        this.base.$insertRight = true;\n        var options = {\n            exactMatch: true,\n            ignoreCaption: true\n        };\n        this.getCompletionProvider().provideCompletions(this.editor, options, function(err, completions, finished) {\n            var filtered = completions.filtered;\n            var prefix = util.getCompletionPrefix(this.editor);\n\n            if (finished) {\n                // No results\n                if (!filtered.length)\n                    return this.detach();\n\n                // One result equals to the prefix\n                if (filtered.length == 1 && filtered[0].value == prefix && !filtered[0].snippet)\n                    return this.detach();\n            }\n            this.completions = completions;\n            this.$open(this.editor, prefix);\n        }.bind(this));\n    }\n\n    detach() {\n        if (this.editor) {\n            this.editor.keyBinding.removeKeyboardHandler(this.keyboardHandler);\n            this.editor.off(\"changeSelection\", this.changeListener);\n            this.editor.off(\"blur\", this.blurListener);\n            this.editor.off(\"mousewheel\", this.mousewheelListener);\n        }\n        this.changeTimer.cancel();\n        if (this.inlineTooltip) {\n            this.inlineTooltip.detach();\n        }\n        \n        this.setIndex(-1);\n\n        if (this.completionProvider) {\n            this.completionProvider.detach();\n        }\n\n        if (this.inlineRenderer && this.inlineRenderer.isOpen()) {\n            this.inlineRenderer.hide();\n        }\n\n        if (this.base)\n            this.base.detach();\n        this.activated = false;\n        this.completionProvider = this.completions = this.base = null;\n    }\n\n    destroy() {\n        this.detach();\n        if (this.inlineRenderer)\n            this.inlineRenderer.destroy();\n        if (this.inlineTooltip)\n            this.inlineTooltip.destroy();\n        if (this.editor && this.editor.completer == this) {\n            this.editor.off(\"destroy\", destroyCompleter);\n            this.editor.completer = null;\n        }\n        this.inlineTooltip = this.editor = this.inlineRenderer = null;\n    }\n\n}\n\nInlineAutocomplete.prototype.commands = {\n    \"Previous\": {\n        bindKey: \"Alt-[\",\n        name: \"Previous\",\n        exec: function(editor) {\n            editor.completer.goTo(\"prev\");\n        },\n        enabled: function(editor) {\n            return editor.completer.getIndex() > 0;\n        },\n        position: 10\n    },\n    \"Next\": {\n        bindKey: \"Alt-]\",\n        name: \"Next\",\n        exec: function(editor) {\n            editor.completer.goTo(\"next\");\n        },\n        enabled: function(editor) {\n            return editor.completer.getIndex() < editor.completer.getLength() - 1;\n        },\n        position: 20\n    },\n    \"Accept\": {\n        bindKey: { win: \"Tab|Ctrl-Right\", mac: \"Tab|Cmd-Right\" },\n        name: \"Accept\",\n        exec: function(editor) {\n            return editor.completer.insertMatch();\n        },\n        enabled: function(editor) {\n            return editor.completer.getIndex() >= 0;\n        },\n        position: 30\n    },\n    \"Close\": {\n        bindKey: \"Esc\",\n        name: \"Close\",\n        exec: function(editor) {\n            editor.completer.detach();\n        },\n        enabled: true,\n        position: 40\n    }\n};\n\nInlineAutocomplete.for = function(editor) {\n    if (editor.completer instanceof InlineAutocomplete) {\n        return editor.completer;\n    }\n    if (editor.completer) {\n        editor.completer.destroy();\n        editor.completer = null;\n    }\n\n    editor.completer = new InlineAutocomplete(editor);\n    editor.once(\"destroy\", destroyCompleter);\n    return editor.completer;\n};\n\nInlineAutocomplete.startCommand = {\n    name: \"startInlineAutocomplete\",\n    exec: function(editor, options) {\n        var completer = InlineAutocomplete.for(editor);\n        completer.show(options);\n    },\n    bindKey: { win: \"Alt-C\", mac: \"Option-C\" }\n};\n\n\nvar completers = [snippetCompleter, textCompleter, keyWordCompleter];\n\nrequire(\"../config\").defineOptions(Editor.prototype, \"editor\", {\n    enableInlineAutocompletion: {\n        set: function(val) {\n            if (val) {\n                if (!this.completers)\n                    this.completers = Array.isArray(val)? val : completers;\n                this.commands.addCommand(InlineAutocomplete.startCommand);\n            } else {\n                this.commands.removeCommand(InlineAutocomplete.startCommand);\n            }\n        },\n        value: false\n    }\n});\n\n\nvar ENTRY_CLASS_NAME = 'inline_autocomplete_tooltip_entry';\nvar BUTTON_CLASS_NAME = 'inline_autocomplete_tooltip_button';\nvar TOOLTIP_CLASS_NAME = 'ace_tooltip ace_inline_autocomplete_tooltip';\nvar TOOLTIP_ID = 'inline_autocomplete_tooltip';\n\n/**\n * Displays a command tooltip above the selection, with clickable elements.\n */\nclass InlineTooltip {\n    /**\n     * Creates the inline command tooltip helper which displays the available keyboard commands for the user.\n     * @param {Editor} editor\n     * @param {HTMLElement} parentElement\n     */\n    constructor(editor, parentElement) {\n        this.editor = editor;\n        this.htmlElement = document.createElement('div');\n        var el = this.htmlElement;\n        el.style.display = 'none';\n        if (parentElement) {\n            parentElement.appendChild(el);\n        }\n        el.id = TOOLTIP_ID;\n        el.style['pointer-events'] = 'auto';\n        el.className = TOOLTIP_CLASS_NAME;\n        this.commands = {};\n        this.buttons = {};\n        this.eventListeners = {};\n    }\n\n    /**\n     * This function sets the commands. Note that it is advised to call this before calling show, otherwise there are no buttons to render\n     * @param {Record<string, TooltipCommand>} commands\n     */\n    setCommands(commands) {\n        if (!commands || !this.htmlElement) {\n            return;\n        }\n        this.detach();\n        var el = this.htmlElement;\n        while (el.hasChildNodes()) {\n            el.removeChild(el.firstChild);\n        }\n\n        this.commands = commands;\n        this.buttons = {};\n        this.eventListeners = {};\n    \n        Object.keys(commands)\n            .map(function(key) { return [key, commands[key]]; })\n            .filter(function (entry) { return entry[1].position > 0; })\n            .sort(function (a, b) { return a[1].position - b[1].position; })\n            .forEach(function (entry) {\n                var key = entry[0];\n                var command = entry[1];\n                dom.buildDom([\"div\", { class: ENTRY_CLASS_NAME }, [['div', { class: BUTTON_CLASS_NAME, ref: key }, this.buttons]]], el, this.buttons);\n                var bindKey = command.bindKey;\n                if (typeof bindKey === 'object') {\n                    bindKey = useragent.isMac ? bindKey.mac : bindKey.win;\n                }\n                bindKey = bindKey.replace(\"|\", \" / \");\n                var buttonText = dom.createTextNode([command.name, \"(\", bindKey, \")\"].join(\" \"));\n                this.buttons[key].appendChild(buttonText);\n            }.bind(this));\n    }\n\n    /**\n     * Displays the clickable command bar tooltip\n     */\n    show() {\n        this.detach();\n\n        this.htmlElement.style.display = '';\n        this.htmlElement.addEventListener('mousedown', captureMousedown.bind(this));\n\n        this.updatePosition();\n        this.updateButtons(true);\n    }\n\n    isShown() {\n        return !!this.htmlElement && window.getComputedStyle(this.htmlElement).display !== \"none\";\n    }\n\n    /**\n     * Updates the position of the command bar tooltip. It aligns itself above the topmost selection in the editor.\n     */\n    updatePosition() {\n        if (!this.editor) {\n            return;\n        }\n        var renderer = this.editor.renderer;\n\n        var ranges;\n        if (this.editor.selection.getAllRanges) {\n            ranges = this.editor.selection.getAllRanges();\n        } else {\n            ranges = [this.editor.getSelection()];\n        }\n        if (!ranges.length) {\n            return;\n        }\n        var minPos = minPosition(ranges[0].start, ranges[0].end);\n        for (var i = 0, range; range = ranges[i]; i++) {\n            minPos = minPosition(minPos, minPosition(range.start, range.end));\n        }\n\n        var pos = renderer.$cursorLayer.getPixelPosition(minPos, true);\n\n        var el = this.htmlElement;\n        var screenWidth = window.innerWidth;\n        var rect = this.editor.container.getBoundingClientRect();\n\n        pos.top += rect.top - renderer.layerConfig.offset;\n        pos.left += rect.left - this.editor.renderer.scrollLeft;\n        pos.left += renderer.gutterWidth;\n\n        var top = pos.top - el.offsetHeight;\n\n        el.style.top = top + \"px\";\n        el.style.bottom = \"\";\n        el.style.left = Math.min(screenWidth - el.offsetWidth, pos.left) + \"px\";\n    }\n\n    /**\n     * Updates the buttons in the command bar tooltip. Should be called every time when any of the buttons can become disabled or enabled.\n     */\n    updateButtons(force) {\n        Object.keys(this.buttons).forEach(function(key) {\n            var commandEnabled = this.commands[key].enabled;\n            if (typeof commandEnabled === 'function') {\n                commandEnabled = commandEnabled(this.editor);\n            }\n\n            if (commandEnabled && (force || !this.eventListeners[key])) {\n                this.buttons[key].className = BUTTON_CLASS_NAME;\n                this.buttons[key].ariaDisabled = this.buttons[key].disabled = false;\n                this.buttons[key].removeAttribute(\"disabled\");\n                var eventListener = function(e) {\n                    this.commands[key].exec(this.editor);\n                    e.preventDefault();\n                }.bind(this);\n                this.eventListeners[key] = eventListener;\n                this.buttons[key].addEventListener('mousedown', eventListener);\n            }\n            if (!commandEnabled && (force || this.eventListeners[key])) {\n                this.buttons[key].className = BUTTON_CLASS_NAME + \"_disabled\";\n                this.buttons[key].ariaDisabled = this.buttons[key].disabled = true;\n                this.buttons[key].setAttribute(\"disabled\", \"\");\n                this.buttons[key].removeEventListener('mousedown', this.eventListeners[key]);\n                delete this.eventListeners[key];\n            }\n        }.bind(this));\n    }\n    \n    detach() {\n        var listenerKeys = Object.keys(this.eventListeners);\n        if (this.eventListeners && listenerKeys.length) {\n            listenerKeys.forEach(function(key) {\n                this.buttons[key].removeEventListener('mousedown', this.eventListeners[key]);\n                delete this.eventListeners[key];\n            }.bind(this));\n        }\n        if (this.htmlElement) {\n            this.htmlElement.removeEventListener('mousedown', captureMousedown.bind(this));\n            this.htmlElement.style.display = 'none';\n        }\n    }\n\n    destroy() {\n        this.detach();\n        if (this.htmlElement) {\n            this.htmlElement.parentNode.removeChild(this.htmlElement);\n        }\n        this.editor = null;\n        this.buttons = null;\n        this.htmlElement = null;\n        this.controls = null;\n    }\n}\n\nvar captureMousedown = function(e) {\n    e.preventDefault();\n};\n\ndom.importCssString(`\n.ace_inline_autocomplete_tooltip {\n    display: inline-block;\n}\n.${ENTRY_CLASS_NAME} {\n    display: inline-block;\n    padding: 0 5px;\n}\n\n.${BUTTON_CLASS_NAME} {\n    display: inline-block;\n    cursor: pointer;\n    padding: 5px;\n}\n\n.${BUTTON_CLASS_NAME}:hover {\n    background-color: rgba(0, 0, 0, 0.1);\n}\n\ndiv.${BUTTON_CLASS_NAME}_disabled {\n    display: inline-block;\n    padding: 5px;\n    cursor: default;\n    color: #777;\n}`, \"inlinetooltip.css\", false);\n\nexports.InlineAutocomplete = InlineAutocomplete;\nexports.InlineTooltip = InlineTooltip;\nexports.TOOLTIP_ID = TOOLTIP_ID;\nexports.BUTTON_CLASS_NAME = BUTTON_CLASS_NAME;\n"],"names":[],"sourceRoot":""}